---
title: 面试题-栈和队列
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-07 13:32:06
tags:
---



收集了栈和队列相关题目。



## 面试9：两个栈实现队列

<!-- more -->



### 题面：

如题

### 思路：

栈是FILO结构，将两个栈的结合起来就可以达到FIFO的效果。

### 代码：

```
template <typename T> class CQueue
{
    public:
    	CQueue(void);
    	~CQueue(void);
    void appendTail(const T& node){
        stack2.push(node);
    }
   	T deleteHead(){
        if(stack1.empty()){
            while(!stack2.empty()){
                stack1.push(stack2.top());
                stack2.pop();
            }
        }
        //弹空栈应抛出异常
        if(stack1.empty()) 
            throw new exception("queue is empty.");

        T topValue = stack1.top();
        stack1.pop();
        return topValue;        
    }
    private:
    	stack<T> stack1, stack2;
}
```

## 面试题9相关题：两个队列实现栈

```
//思考了一下只能用一个队列循序存储数据，在插入操作时直接插入。删除时把一个队列的除了最后一个其他数据顺序放到临时存储队列，最后删除最后一个数据。
```

## 包含min函数的栈

### 题面：

给定栈的数据结构，要求实现对栈的操作min，push，pop，并且复杂度为O(1)O(1)。

### 思路：

这题的难度不在于思维，而在于一种思想。为了保持栈FILO的特性，必须有一个栈负责存储原数据。但是如何实现min？一开始的想法是维护一个递增的栈，但是明显的复杂度高，且不易维护。简单如我没有想到可以直接维护一个**每一个元素都代表着当前被压入栈时的栈的最小值**的**状态栈**。也就是说在数据压入栈的时候求出之前记录的最小值和被压入元素的最小值，然后压入状态栈。pop的时候也很简单，直接两个栈都pop就ok。

可以这么做的理由，是栈的min值是与将来无关的，仅与过去有关，换句话说就是状态值仅与当前栈的内容有关。

好优雅。

```
class StackMin{
    private:
    	stack<int> s, sMin;
    public:
    void push(int x){
        if(sMin.size() > 0)
            sMin.push(min(x, sMin.top()));
        else sMin.push(x);
        s.push(x);
    }
    void pop(){
        if(sMin.size() == 0) return;
        sMin.pop();
        s.pop();
    }
    int min(){
        if(sMin.size() > 0) 
	        return sMin.top();
        else 
            throw new exception();
    }
}
```

> 错误：没有检查栈的元素数量。

## 面31：合法的栈的弹出序列

### 题面：

给出一个按增序的数字序列`1，2，3，4……`压入栈的序列， 同时给出一个对应数字的弹出序列，判断弹出序列是否是压入序列的弹出序列。

### 思路：

不考虑数据的错误输入的话。一个简单而自然的思路就是模拟，建立一个辅助栈。对于弹出序列的当前数据，如果比栈顶数据大或者栈没有数据，则压入数据，直到栈顶和当前弹出序列的值一样大。如果等于栈顶数据，弹出栈顶。如果比栈顶数据小，则序列错误。如果正常运行结束则序列正确。

> 不太容易讲清楚，最好举个例子。
>
> 想了一丢丢，终于讲清楚了。重点在于判断模拟过程的条件需要缕清。

### 样例：

```
true:
1,2,3
1,2,3

1,2,3
3,2,1

1,2,3
3,1,2

1,2,3,4,5,6
3,4,2,5,1,6

1,2,3,4,5,6
3,4,2,6,1,5
```

### 代码：

```
bool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop){
    stack<int> s;
    int pushMax = 0;
    if(lenPush != lenPop) return false;
    for(int i = 0; i < lenPush; i++){
        if(s.empty() || aPush[i] > s.top()){
            int k = pushMax + 1;
            while(k <= aPush[i]){
                s.push(k);
                k++;
            }
            pushMax = k - 1;
        }
        if(s.top() == aPush[i]){
            s.pop();                       
        }else{
            return false;
        }
        
    }
    return true;
}
```



## 面59 题二：队列的最大值

### 题面：

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1


### 思路：

第一种肯定会想到把一个队列拆成两个栈来做；第二种比较巧妙，通过分析滑动窗口内元素最大值的变化，可以写出类似的如下代码。
具体思路，是用双头队列维护队列最大值。
### 代码：
```c++
class MaxQueue {
public:
    deque<int> value;
    deque<int> maxValue;

    MaxQueue() {
        value.clear();
        maxValue.clear();
    }
    
    int max_value() {
        if(value.size() > 0){
            return maxValue.front();
        }
        else 
           // throw new exception;
           return -1;
    }
    
    void push_back(int number) {
        value.push_back(number);
        
        while(maxValue.size() > 0 && maxValue.back() < number){
            maxValue.pop_back();
        }        
        maxValue.push_back(number);     
    }
    
    int pop_front() {
        if(value.size() > 0){
            int popValue = value.front();
            if(maxValue.front() == popValue){
                maxValue.pop_front();
            }
            value.pop_front();
            return popValue;
        }else
          //  throw new exception;
          return -1;
    }
};

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue* obj = new MaxQueue();
 * int param_1 = obj->max_value();
 * obj->push_back(value);
 * int param_3 = obj->pop_front();
 */
 ```
