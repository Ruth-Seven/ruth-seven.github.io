---
title: 面试题 二叉树
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 13:25:51
---



收集二叉树相关题目，相关测试代码见[此](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp)。

<!-- more -->

sCmd = ‘C:; cd C:\Users\xusx\Sumo\SUMO\bin; duarouter -n xsxlankershim.net.xml –route-files xsx.flow.xml -o rou.rou.xml’
os.system(sCmd)

### 结构

```
struct BinaryTreeNode{
    double dbValue;
    BinaryTreeNode *pLeft;
    BinaryTreeNode *pRight;   
}
```

## 面7：中序遍历和前序遍历序列来重建二叉树

```
BinaryTreeNode* ConstructNode(int *startPreorder,  int *endPreordrer, 
                              int *startInorder, int *endInorder){
    //这个代码健壮性就很好！对空值和非法输出进行了区分。
	if(startPreorder > endPreorder  || startInorder > endInorder ){	
        if(startPreorder == endPreorder - 1  && startInorder ==  endInorder - 1) 
        	return nullptr;
        else 
            throw std::exception("Invalid Input.\n");
    } 
    //寻找中序遍历中的根节点值坐标
    int nodeValue = startPreordre[0];
	int *rootInorder = startInorder;
    for(; rootInorder <= enInorder && *rootInordre != nodevalue; rootInorder++);
	//健壮一下
    if(enInorder < rootInorder){
        throw std::exception("Invalid input!\n");
    }
    //构建左右子树
    BinaryTreeNode* pNode = new BinaryTreeNode();
    int lNodeNum = rootInorder - startInorder;
    pNode->pLeft = 
        ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1);
    pNode->pRight = 
        ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder);
    pNode->value = nodeValue;
    return pNode;
	
}

BinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length){
    //length == 0的代码的健壮性显然不如 length <= 0
    if(preorder == null || inorder == null || length <= 0) return nullptr;
	return ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1);
    
}
```

## 面8：二叉树的下一个节点

第一次考虑的时候居然还想错了，分析不够全面。从二叉树中序遍历来看，若一个节点有右子树，则下一个节点就是其右子树的最左节点。倘若没有，则必然是考虑父亲节点。如果该节点是父亲节点的左子节点，那么下一个节点就是父亲节点，不然可以溯源查找其父辈节点是左子树的祖父节点。这个过程可以使用父亲节点和迭代完成。

```
BinaryTreeNode *GetNext(BinaryTreeNode *pNode){
    if(pNode == nullptr) return;
    if(pNode->pRight){
        BinaryTreeNode* pChild = pNode->pRight;
        while(pChild->pLeft != nullptr) pChild = pChild->pRight;
        return pChild;
    }else{
        BinaryTreeNode* pParent = pNode->pParent, *pCurrent = pNode;
		//循环控制条件有点像哨兵，没有找到的话pParent自然就是unllptr,代码更加简洁了
        while(pParent != nullptr && pParent->pRight != pCurrent){
            pCurrent = pParent;
            pParent = pParent->pParent;
        }
        return pParent;       
    }
    return nullptr;
}
```

> 相比之前的代码这个写法差一点点
>
> ```
> while(pParent->pParent != nullptr && pParent->pRight != pCurrent){
>             pCurrent = pParent;
>             pParent = pParent->pParent;
>         }
>         if(pParent->pRight == pCurrent){
>             return pParent;
>         }
>        
> ```

## 面26：树的子结构

### 题面：

输入两棵树`A`和`B`，判断`B`是否是`A`的子结构。`B`是`A`的子结构子结构定义为`A`的一部分和`B`完全相同。

### 思路：

递归的判断对`A`的每一个节点判断该节点下的是否有`B`的结构。

### 代码：

```
bool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){
	if(pRoot2 == nullptr) return true;
    else if(pRoot1 == nullptr) return false;
    
    if(equal(pRoot1->dbValue, pRoot2->dbValue)){
        if(pRoot2->pRight == nullptr && pRoot2->pLeft == nullptr) return true;
	    return judgeSameTree(pRoot1->pLeft, pRoot2->pLeft)
            && judgeSameTree(pRoot2->pRight, pRoot2->pRight);
    }
    return false;
}

bool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){
	if(pRoot1){
        if(judgeSameTree(pRoot1, pRoot2)) return true;
        else return HasSubtreeCore(pRoot1->pLeft, pRoot2) 
            	|| HasSubtreeCore(pRoot1->pRight, pRight);
    }
    return false;
}
bool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){
    if(pRoot2 == nullptr) return true;
    if(pRoot1 == nullptr) return false;
    return HasSubtreeCore(pRoot1, pRoot2);   	    
}
```

### 测试：

[参见](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp)

## 面27：翻转二叉树

### 题面：

给出一棵二叉树并返回其镜像二叉树。

### 思路：

直接交换节点的左右指针节点即可。

### 代码：

```
BinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode){
    if(pNode == nullptr) return nullptr;
    BinaryTreeNode *pTemp = pNode->pRight;
    pNode->pRight = pNode->pLeft;
    pNode->pLeft = pTemp;
	MirrorRecursively(pNode->pLeft);
    MirrorRecursively(pNode->pRight);
    return pNode;    
}
```

## 面28：对称二叉树

### 题面：

判断一棵树是否对称。

### 思路：

从第一个节点左子树开始递归的判断，其右子树的节点是否完全相同。只需要一边对另一边镜像操作就ok。

### 代码：

```
bool isSymmetrical(BinaryTreeNode* pHead){
	if(pHead == nullptr) return true;
    return isSymmetricalCore(pHead->pLeft, pHead->pRight);
}
bool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2){
    if(p1 == nullptr && p2 == nullptr) return true;
    if(p1 == nullptr && p2 != nullptr 
       || p2 == nullptr && p1 != nullptr
      || p1->value != p2->value) 
    	return false;
    return isSemmetricalCore(p1->left, p2->right) 
    	&&  isSemmetricalCore(p1->right, p2->left);    
}
```

> 有趣的是，我这种写法也可以看成前序遍历序列和对称前序遍历序列的比较。

## 面32：层序遍历二叉树

### 题面：

如标题

### 思路：

层序遍历

### 代码：

```
void PrintByLayer(BinaryTreeNode* pHead){
    if(pHead == nullptr) return;
    queue<BinaryTreeNode*> que;
    que.push(pHead);
    while(que.size()){
        BinaryTreeNode *pNode = que.front();
        que.pop();
        printf("%.2f ", pNode->dbValue);
        if(pNode->pLeft) que.push(pNode->pLeft);
        if(pNode->pRight) que.push(pNode->pRight);        
    }
    printf("\n");
}
```

## 面32相关题：分行打印层序遍历二叉树

### 题面：

如标题

### 思路：

在层序遍历的基础上，有两种解题思路：一是记录当前层未打印的节点数量和下一层的需要打印的节点数量，二是在队列中添加一个一层的节点末端的标志符、

### 代码：

```
void PrintByLayerSparate(BinaryTreeNode* pHead){
    if(pHead == nullptr) return;
    queue<BinaryTreeNode*> que;
    que.push(pHead);
	int printValue = 1, nextValue = 0;
    while(que.size()){
        BinaryTreeNode *pNode = que.front();
        que.pop();
        printValue--;
        printf("%.2f ", pNode->dbValue);
        if(pNode->pLeft){
          	que.push(pNode->pLeft);
            nextValue++;
        } 
        if(pNode->pRight){
            que.push(pNode->pRight);          
            nextValue++;
        }
        
        if(printValue == 0){
            printValue = nextValue;
            nextValue = 0;
            printf("\n");
        }
    }
    
}
```

## 面32相关题：之字形打印二叉树

### 题面：

如标题

### 思路：

一种方法就是分层层序遍历+栈逆序存储并输出。

第二种方法就用栈把一层的节点逆序输出，并将下一层的节点记录在另一个栈中，如此循环，输出所有的层。

### 代码：

```
void PirntZhi(BinaryTreeNode *pHead){
    if(pHead == nullptr) return;
    stack<BinaryTreeNode*> s[2];
    int cur = 0;
    s[cur].push(pHead);
    BinaryTreeNode *pNode = nullptr;
    while(s[cur].size()){
        while(s[cur].size()){
		   pNode = s[cur].top();
            s[cur].pop();
            printf("%.2 ", pNode->dbValue);
            if(cur == 0){
                if(pNode->pLeft) s[1 - cur].push(pNode->pLeft);
                if(pNode->pRight) s[1 - cur].push(pNode->pRight);                
            }else{
                if(pNode->pRight) s[1 - cur].push(pNode->pRight);                
            	if(pNode->pLeft) s[1 - cur].push(pNode->pLeft);                
            }
        }
       	printf("\n");
        cur = 1- cur;
    }
    
}
```



#### [103. Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if(!root) return {};
        stack<TreeNode*> cur1, cur2;
        cur1.push(root);
        vector<vector<int>> zigarr;
        int flag = 1;
        while(cur1.size() || cur2.size()){
            if(flag) zigview(cur1, cur2, zigarr, flag), flag = 1 - flag ;
            else  zigview(cur2, cur1, zigarr, flag), flag = 1 - flag;
        }
        return zigarr;
    }

    void zigview(stack<TreeNode*>& now, stack<TreeNode*>& next, vector<vector<int>> &zigarr, int flag){
        vector<int> arr;
        while(!now.empty()){
            arr.push_back(now.top()->val);
            if(flag){
                if(now.top()->left) next.push(now.top()->left);
                if(now.top()->right) next.push(now.top()->right);
                now.pop();
            }else{
                if(now.top()->right) next.push(now.top()->right);
                if(now.top()->left) next.push(now.top()->left);
                now.pop();
            }            
        }
        zigarr.push_back(arr);
    }
};
```



## 面33:判断后序遍历序列有效性

### 题面：

给定一颗二叉搜索树的后续遍历序列，判断该后序遍历序列是否合法。

### 思路：

依据后续遍历的定义，可以把序列依据最后一个元素`K`分成两半，且满足前一部分全部小于`K`的值，后一部分全部大于`K`的值，若不符合这个结论，则该后序遍历不可能存在一颗二叉树与之对应。递归的判断这两部分是否符合这些定义。

### 代码：

```
bool isPostSequenceCore(int sequence[], int start, int end){
    if(start >= end) return true;
    int key = sequence[end - 1];
    int split = start;
    while(sequence[split] < key) split++;
    for(int i = split; i < end; i++){
        if(sequence[i] < key) return false;
    }
    return isPostSequenceCore(sequence, start, split) 
        && isPostSequenceCore(sequence, split, end - 1);
}

bool isPostSequence(int sequence[], int len){
    if(sequence == nullptr || len <= 0) return false;
    return isPostSequenceCore(sequence, 0, len);
}
```

> 如果是c++的话，也可以直接用指针代替start。

## 面34：树的路径的元素之和

### 题面：

打印出树的路径上的值之和与给定数字相同的所有路径。路径从根到叶子。

### 思路：

dfs遍历 + 记录路径即可。

### 代码：

```
void PrintPathCore(BinaryTreeNode* pNode, stack<int> &s, int add, int expectedSum){
    s.push((int)pNode->dbValue);
    add += (int)(pNode->dbValue);
    if(pNode->pLeft == nullptr && pNode->pRight == nullptr){
        if(add == expectedSum){
            stack<int> sTemp;
            while(s.size()){
               
                sTemp.push(s.top());
                s.pop();                
            }
            while(sTemp.size()){
                printf("%d->", sTemp.top());
                s.push(sTemp.top());
                sTemp.pop();
            }
            printf("\n");
        }
        // printf("%d, %d, %d\n", expectedSum, add, s.size());
        s.pop();
        return;
    }
    if(pNode->pLeft) PrintPathCore(pNode->pLeft, s, add, expectedSum);    
    if(pNode->pRight) PrintPathCore(pNode->pRight, s, add, expectedSum);
    s.pop();
}


void PrintPath(BinaryTreeNode* pHead, int expectedSum){
    if(pHead == nullptr) return;
	stack<int> s;
    PrintPathCore(pHead, s, 0, expectedSum);
    printf("\n");
}
```

> 中午时间不要打代码，太困了



## [437. Path Sum III](https://leetcode-cn.com/problems/path-sum-iii/) 路径之和

类似，但不相同。

前缀和 + 递归

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count = 0;
    int pathSum(TreeNode* root, int sum) {
        add(root, 0);    
        findNode(root, sum, 0);
        return count;
    }
    void findNode(TreeNode* root, int num, int presum){
        if(!root) return;
        cal(root, num, presum);
        findNode(root->left, num, root->val);
        findNode(root->right, num, root->val);
    }
    void cal(TreeNode* root, int target, int presum){
        if(!root) return;
        if(root->val - presum == target) count++;
        cal(root->left, target, presum);
        cal(root->right, target, presum);
    }
    void add(TreeNode* root, int presum){
        if(!root) return;
        root->val += presum;
        add(root->left, root->val);
        add(root->right, root->val);
    }
};
```



写法二：提供一种递归的小小思路

```c++
class Solution {
public:
    int count = 0;
    int pathSum(TreeNode* root, int sum) {
        if(!root) return 0;
        return cal(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);
    }
    int cal(TreeNode* root, int sum){
        if(!root) return 0;
        sum -= root->val;
        return (sum == 0) + cal(root->left, sum) + cal(root->right, sum);
    }
    
};
```



最优解法：前缀和 + 回溯 + 维护前缀和出现的次数：`times[presum]`

> 突然想到3数之和。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int, int> ct = {{0,1}};
    int pathSum(TreeNode* root, int sum) {
        int amount = 0;
        dfs(root, 0, sum, amount);
        return amount;
    }
    void dfs(TreeNode *root, int presum, int sum, int &amount){
        if(!root) return;
        root->val += presum;
        amount += ct[root->val - sum];

        ++ct[root->val];
        dfs(root->left, root->val, sum, amount);
        dfs(root->right, root->val, sum, amount);
        --ct[root->val];

    }
    
};
```



## 面36：把二叉搜索树转化为双向链表（同链表中的内容）

### 题面：

如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。

### 思路：

可以从递归的角度入手。对于一个节点`A`，中序遍历到`A`，则`A`的左子树已经转化为了链表，连接好`A`和`A`的左子树的最大节点（前一个指针）的指针则连接完成。

那对于`A`的右子树的最小节点`B`与`A`之间的连接，也可以看成`B`与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。

注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。

> 对于一个节点`A`的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点`B`的指针，并设置好`B`的右指针和`A`的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是`NULL`，所以无需修改。

### 代码：

```
void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&preNode, BinaryTreeNode *&pHead){
    if(pRoot == nullptr) return;
  	AdjustLinkCore(pRoot->pLeft, preNode, pHead);

    if(pHead == nullptr) pHead = pRoot;
    pRoot->pLeft = preNode;
    if(preNode) preNode->pRight = pRoot;
    preNode = pRoot;
    
    AdjustLinkCore(pRoot->pRight, preNode, pHead);
}
BinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){
    BinaryTreeNode *preNode = nullptr;
    BinaryTreeNode *pHead = nullptr;
    AdjustLinkCore(pRoot, preNode, pHead);
    return pHead;
}
```

## 面36：序列化和反序列化二叉树

### 题面：

序列化定义：

> 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

二叉树的序列化可以把非空节点的值序列化，把空节点序列化为`$`。

### 思路：

由于序列化把空节点的信息也包含进来了，所以无需添加更多序列。

> 这题更像流的应用题

### 代码：

```
void Serialize(BinaryTreeNode *pRoot, ostream& stream){
    if(pRoot == nullptr){
        stream << '$';
        return;
    } 
    stream << pRoot->value << ',';
    Serialize(pRoot->pLeft);
    Serialize(pRoot->pRight);    
}

void Deserialize(BinaryTreeNode *&pRoot, istream& stream){
	int number;
    if(ReadSteam(stream, &number)){
        pRoot = new BinaryTreeNode();
        pNew->pLeft = nullptr;
        pNew->pRight = nullptr;
        pNew->value = number;
    }
    Deserialize(pRoot->pLeft, stream);
	Deserialize(pRoot->pRight, steam);    
}

```

