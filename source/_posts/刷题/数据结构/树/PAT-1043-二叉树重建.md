---
title: PAT 1043 二叉树重建
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 13:17:52
---

<!-- more -->



## 搜索二叉树的前序列推出整个二叉树或者推出后序列

思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点；

难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界；



**PAT 1043**

```
其实有点意思
柳神的代码比我的构思好多了
vector<int>pre,post;
bool isMirror;
void checkPre(int root,int tail)//【root，tail】
{
    if(root>tail) return;//! 空节点退出
    int i=root+1,j=tail;
    if(!isMirror)
    {
        //!while退出之时 就是到了另一个子树序列的开头与结尾
        while(i<=tail&&pre[root]>pre[i]) i++;
        while(j>root&&pre[root]<=pre[j]) j--;//!若该序列是二叉搜索树则必有i==j+1
    }
    else
    {
        while(i<=tail&&pre[root]<=pre[i]) i++;
        while(j>root&&pre[root]>pre[j]) j--;
    }
    if(i-j!=1) return;//!由于树可能不存在 需要处理异常情况
    checkPre(root+1,j);
    checkPre(i,tail);
    post.push_back(pre[root]);//!前序遍历压入当前根节点；
}
int main()
{
    int n, flag = 1;
    scanf("%d",&n);
    pre.resize(n+1);
    for(int i=0; i<n; i++) scanf("%d",&pre[i]);
    checkPre(0,n-1);
    if(post.size()!=n)//! 不为二、        printf("YES\n");
        for(int i=0; i<n; i++)
        {
            printf("%d",post[i]);
            printf("%c",i!=n-1?' ':'\n');
        }
    }
    else printf("NO\n");

}
```