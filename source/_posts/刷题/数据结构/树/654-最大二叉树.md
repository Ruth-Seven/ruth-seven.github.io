---
title: 654. 最大二叉树
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 14:09:42
---

<!-- more -->



一个基础的递归建树就可以解决。

以递归的思想处理每一个新数组，先找出最大值所在并以此值一分数组为2个数组，同时递归建树即可。

Note：注意边界错误，如right到底没有没值



```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return constructBT(nums, 0, nums.size() - 1);
        
    }
    TreeNode* constructBT(vector<int>& nums, int left, int right){
        if(left > right)
            return NULL;
        
        int index = left, nmax = nums[left];
        for(int i = left + 1; i <= right; i++){
            if(nmax < nums[i]){
                nmax = nums[i];
                index = i;
            }
        }
        TreeNode* root = new TreeNode(nmax);
        root->left = constructBT(nums, left, index - 1);
        root->right  = constructBT(nums, index + 1, right);
        return root;
    }
    
    

};
```

