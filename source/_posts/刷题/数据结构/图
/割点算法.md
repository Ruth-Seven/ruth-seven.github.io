---
title: 割点算法
thumbnail: 'http://static.come2rss.xyz/mirage.png'
toc: true
top: 10
date: 2021-05-09 11:34:08
tags:
categories:
---





## 割点算法Tarjan

割点算法 引入了建立在DFS生成树的遍历节点的时间戳概念，如果一个节点`u`的子节点`v`可以找到一条不经过`u`以外的路径到达`u`的祖先，那么显然有一条通路可以回到`u`的祖先。反之，如果存在`v`找不到这么一条路径回到`u`的祖先，那么显然`u`是一个割点，他分割了`v`所在的子树和其他子树（如果`u`不是根的话，包括祖先所在子树）。



![image-20210509113600747](http://static.come2rss.xyz/image-20210509113600747.png)

那么一个割点有多少子树呢？
首先，一个割点的对应的`v`是独立在各个子树的吗？是的，如果存在`v1`和`v2`都找到路径，且在一个子树中，那么必然有`v1`可以通过`v2`找到`u`，那么在DFS搜索的时候，必定会一次遍历`v1`和`v2`。所以每个割点对应的子树只会搜索到一个`v`。
扩展一下， 那么经过去掉割点的图最多有几个连通块？

<!-- more -->

[POJ 2117 Electricity](http://poj.org/problem?id=2117)

> [参考解答](https://leetcode-cn.com/circle/article/FH8cqr/#poj-3177/newcoder-10774/acw-395-%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84)
```c++

#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
const int N = 10005;
const int M = 30005;
int tot;
int to[M], nxt[M], head[M]; // graph 链式前向星存储方式
int dfn[N];
int low[N];
int ts;
int n, m;
int bp, cnt;
int root;
void add(int u, int v){ // connstruct graph;
    ++tot;
    to[tot] = v;
    nxt[tot] = head[u];
    head[u] = tot;
}
void tarjan(int u){
    // cout << u << ' '; 
    int subtree = 0;
    dfn[u] = low[u] = ++ts;
    for(int i = head[u]; i; i = nxt[i]){
        int v = to[i];
        
        if(dfn[v]) low[u] = min(low[u], dfn[v]);
        else{
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if(low[v] >= dfn[u]) ++subtree;; // 节点u是割点，且割点对应的子节点v是在一个被分割子树中
        }
    }
    if( u != root) ++subtree;
    bp = max(bp, subtree);
}
int main(){
    while(scanf("%d%d", &n, &m), n || m){
        ts = tot = bp = cnt = 0;
        memset(head, 0x00, sizeof head); // to 和 edge 不需要重置
        memset(dfn, 0x00, sizeof dfn);
        memset(low, 0x00, sizeof low);
        int a ,b;
        while(m--){
            scanf("%d%d", &a, &b);
            add(a, b);
            add(b, a);            
        }
        
        for(root = 0; root < n; ++root){
            if(!dfn[root]){
                tarjan(root);
                cnt++;
            }
        }
        printf("%d\n", cnt + bp - 1);
    }
    return 0;
}   



```


## 补充知识点
- [前向星](https://baike.baidu.com/item/%E5%89%8D%E5%90%91%E6%98%9F?fr=aladdin)
- [链式前向星](https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F)

前向星不过是把边按出发点排序并顺序存储下来， 通过记录首部位置来遍历；
链式前向星更进一步，通过在头部位置记录边的地点，同时以静态方式存储边，在静态边中存储下下条边的地址。



最后还有常用的对拍程序：

```shell
#!/bin/sh
g++ $1 -o ./a.out 
./a.out < input  > myoutput
diff myoutput output -s -u
```

