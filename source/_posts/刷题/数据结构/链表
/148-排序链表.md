---
title: 148. 排序链表
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
date: 2021-03-31 10:46:40
tags:
categories:
---







# [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)



我写过最累最烦的链表题，循环归并排序思路比较好想，但是容易错，非常容易错，哈哈。

<!-- more -->



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* midNode(ListNode* head, ListNode* end = nullptr){
        ListNode* fastp  = head, *slowp = head;
        while(fastp){
            fastp = fastp->next;
            if(fastp) fastp = fastp->next;
            slowp = slowp->next;
        }
        return slowp;
    }

    ListNode *split(ListNode* node, int nums){
        ListNode* p = node;
        if(p == nullptr) return nullptr;
        int k = 1;
        while(k < nums && p->next){
            p = p->next;
            ++k;
        }
        ListNode *ans =  p->next;
        p->next = nullptr;
        return ans;
    }

    ListNode* merger(ListNode* heada, ListNode* headb, ListNode* &pre) {
        ListNode *p1 = heada, *p2 = headb, *head = new ListNode(), *p = head;
        if(!p1 && !p2){
            pre->next = nullptr;
            return nullptr;
        }
        while(p1 && p2){
            if(p1->val < p2->val){
                p->next = p1;
                p1 = p1->next;
            }else{
                p->next = p2;
                p2 = p2->next;
            }
            p = p->next;
        }
        p->next = p1 ? p1 : p2;
        while(p->next) p = p->next;
        
        // link prenode and endnode.
        if(pre) pre->next = head->next;
        pre = p;
        // return merged list head;
        p = head->next;
        delete head;
        //print(p, "p->next");
        return p;
    }

    ListNode* sortList(ListNode* head) {
        ListNode* p1 = head, *p2 = head;
        ListNode * prehead = new ListNode();
        prehead->next = head;
        int flag = 1;
        for(int i = 1; flag; i *= 2){
            ListNode* pre = prehead;
            ListNode * nextp1 = prehead->next; // #bug: nextp1 = head； but head has be reset.
            flag = 0;
            p2 = prehead; // @reset p2
            //print(prehead, "@");
            while(p2){
                flag++;
                p1 = nextp1;
                p2 = split(p1, i);                
                nextp1 = split(p2, i);
               // print(p1, "p1");
               //  print(p2, "p2");
                merger(p1, p2, pre); // merge and link.
               // print(prehead, "#");
                if(p1 == prehead->next && !p2 && flag == 1) flag = 0;
            }

        }
        head = prehead->next;
        delete prehead;
        return head;
    }

    void print(ListNode* head, string s = "@"){
        cout << s  + ":" ;
        while(head){
            cout << head->val << ' ';
            head = head->next;
        } 
        cout <<endl;
    }
};
```

