---
title: 面试题-二分
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 13:30:40
---



收集查找二分查找相关题目



## 面11：旋转数组

<!-- more -->

### 题面：

旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。

### 思路：

一种就是直接遍历。

更快地可是使用二分法查找元素。依据二分法，记指针有`A`，`B`，`mid`；。若有数组`array[mid]>=array[A]`则有`mid`在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则`mid`在后一个移动过的区间，应该向前半部分二分。

但是由于题面说数据可能不是递增的，所以可能出现`array[A]=array[mid]=array[B]`的情况，这时如果`mid`指向移动过的区间就会出现错误，比如`1,0,1,1,1`，`A=0,B=4,mid=2`。如何避免呢？只能是直接遍历。

> 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了`array[mid]<=array[A]`且`array[mid]>array[B]`，这个假设一提出来就显得非常的荒谬了。

### 样例：

```
4,5,6,7,1,2,3
1,1,0,1,1,1,1
1,1,1,1,0,1,1
```

### 代码:

```
int Min(int* numbers, int length){
    if(numbers == null || length <= 0) 
        throw new std::exception("Invalid parameters");
    int start = 0, end = length - 1, mid;
    while(start < end){
        int mid = ((end - start) >> 1) + start;
        if(numbers[start] == numbers[mid] == numbers[end] ){
            int minNum = numbers[0];
            for(int i = 1; i < length; i++)
                if( numbers[i] < minNum) minNum = numbers[i];
            return minNum;
        }
        
        if(numbers[mid] >= numbers[start]) start = mid + 1;
        else end = mid;
    }
    return numbers[end];    
}
```

## 面53:(待完成)

### 题面：

旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。

### 思路：

一种就是直接遍历。

更快地可是使用二分法查找元素。依据二分法，记指针有`A`，`B`，`mid`；。若有数组`array[mid]>=array[A]`则有`mid`在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则`mid`在后一个移动过的区间，应该向前半部分二分。

但是由于题面说数据可能不是递增的，所以可能出现`array[A]=array[mid]=array[B]`的情况，这时如果`mid`指向移动过的区间就会出现错误，比如`1,0,1,1,1`，`A=0,B=4,mid=2`。如何避免呢？只能是直接遍历。

> 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了`array[mid]<=array[A]`且`array[mid]>array[B]`，这个假设一提出来就显得非常的荒谬了。

### 样例：

```
4,5,6,7,1,2,3
1,1,0,1,1,1,1
1,1,1,1,0,1,1
```

### 代码: