---
title: 81. Search in Rotated Sorted Array II
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-10-30 09:56:38
---





## [81. Search in Rotated Sorted Array II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)









## 思路：

这题好像是33题的follow up。

增添了各个元素可能相等的条件。

没做出来。



如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 `nums[mid]==nums[l]`那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。

跳出这层，能不能直接在二分搜索呢？



<!-- more -->

> 参考题解
>
> ![image-20201030095548987](http://static.come2rss.xyz/image-20201030095548987.png)





```c++
// 失败的二分
// class Solution {
// public:

    
//     bool search(vector<int>& nums, int target) {
//         int n = nums.size();
//         int l = 0, r = n, mid, start = l;
//         while(l < r){
//             mid = (l + r) / 2;
//             if(nums[mid] < nums[start]) r = mid;
//             else if(nums[mid] == nums[start]) start++;
//             else l = mid + 1;
//             // cout << l << endl;
//         }    

//         // cout << l << endl;
//         vector<int>::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target);
//         vector<int>::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target);
//         if( iter1 != nums.end() && *iter1 == target || iter2 != nums.end() && *iter2 == target)
//             return true;
//         else return false;
//     }
// };

class Solution {
public:

    
    bool search(vector<int>& nums, int target) {
        int n = nums.size();
        int l = 0, r = n - 1, mid, start = l;
        while(l <= r){
            mid = ( r + l) / 2;
            if(nums[mid] == target)
                return true;
            else if(nums[mid] > nums[l]){
                if(nums[l] <= target && target < nums[mid])
                    r = mid - 1;
                else l = mid + 1;
            }
            else if(nums[mid] < nums[l]){
                if(nums[mid] < target && target <= nums[r])
                    l = mid + 1;
                else r = mid - 1; 
            }
            else if(nums[mid] == nums[l])
                l++;
        }
        return false;
    }
};

```