---
title: 37.解数独
thumbnail: 'http://static.come2rss.xyz/moxige.jpg'
toc: true
top: 10
categories:
tags:

date: 2020-09-17 12:57:20
---

## [37 解数独](https://leetcode-cn.com/problems/sudoku-solver/)  - 位运算 回溯



编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
空白格用 '.' 表示。



<!--more-->

## 思路：

回溯。

错误想法：模拟平时玩数独的方法，寻找可能性最小的格子并确定，这种方法反而实现复杂，难以查找BUG。

> 简单方法反而最有效

## 扩展：

如何计算复杂度？



## 代码：

### 1A

```c++

//错误代码
class Solution {
public:
    const static int len = 9;
    void print(vector<vector<char>> &board){
        static int sum = 1;
        printf("-----------------\n%d \n", sum++);
        if(sum < 5)  return;
        for(int i = 0; i < len; i++){
            for(int j = 0; j < len; j++)
                printf("%c ", board[i][j]);
            printf("\n");
        }
    }
    void solveSudokuCore(vector<vector<char>> &board, vector<char> poss[][len], int &flag){
         int minPoss = 20;
         int x = -1, y = -1;
        

         //print
         print(board);

         if(flag == 0) return;
         for(int i = 0; i < len; i++)
         for(int j = 0; j < len; j++){
             int size = poss[i][j].size();
             if(size == 1){
                // do it.
                 board[i][j] = poss[i][j][0];
                 poss[i][j].clear();
                 // remove the impossible number.
                 for(int t = 0; t < len; t++){
                     vector<char> &rowP = poss[i][t];
                     vector<char> &colP = poss[t][j];
                     rowP.erase(remove(rowP.begin(), rowP.end(), board[i][j]), rowP.end());
                     colP.erase(remove(colP.begin(), colP.end(), board[i][j]), colP.end());
                 }
                
               // int block = (i % 3) * 3 + j / 3;
                int x = i / 3 * 3;
                int y = j % 3 * 3;
                for(int p = x; p < x + 3; p++)
                for(int q = y; q < y + 3; q++)
                {
                     vector<char> &vecP = poss[p][q];
                     vecP.erase(remove(vecP.begin(), vecP.end(), board[i][j]), vecP.end());
                }

                solveSudokuCore(board, poss, flag);
                return;
             
             }
             // This is a bad path.
            else if( size == 0 && board[i][j] == '.'){
                printf("[End point]:%d %d\n", i, j);
                return;
            }
            
            // Find the minimum possibly grid;
             else if(minPoss > size && size > 1){
                minPoss = size;
                x = i;
                y = j;

            }        
         }

         //The no more possbility. End the Search.
         if(minPoss == 20){
               flag = 0;
               return;
         }
             
         // there are none grid that has only one possible result.
         vector<char> ans = poss[x][y];
         poss[x][y].clear();
         for(int i = 0; i < ans.size(); i++){            
            poss[x][y].push_back(ans[i]);
            solveSudokuCore(board, poss, flag);
            poss[x][y].clear();
         }  
            
         

    }


    void solveSudoku(vector<vector<char>>& board) {
     
        vector<char> pos[len][len];
        bool hasNum[len + 1] = {0};
        for(int i=0; i < len; i++)
        for(int j=0; j < len; j++){
            if(board[i][j] == '.'){

                memset(hasNum, 0,  sizeof(bool) * (len + 1));
                for(int k = 0; k < len; k++){
                    if(board[k][j] != '.')
                        hasNum[board[k][j] -'0'] = 1;
                    if(board[i][k] != '.')
                        hasNum[board[i][k] -'0'] = 1;
                }                
                int x = i / 3 * 3;
                int y = j / 3 * 3;
                for(int p = x; p < x + 3; p++)
                    for(int q = y; q < y + 3; q++)
                    {
                        if(board[p][q] != '.')
                            hasNum[board[p][q] - '0'] = 1;
                    }
                for(int l = 1; l < len + 1; l++)
                    if(hasNum[l] == 0)
                        pos[i][j].push_back(l + '0');        
                
            }
        }
        int flag  = 1;
        solveSudokuCore(board, pos, flag);                  
    }
};


//1A
class Solution {
public:
    const static int len = 9;
    void print(vector<vector<char>> &board, int x, int y){
        static int sum = 1;
        printf("-----------------\n%d  %d  %d;\n", sum++, x, y);
        if(sum < 8)  return;
        for(int i = 0; i < len; i++){
            for(int j = 0; j < len; j++)
                printf("%c ", board[i][j]);
            printf("\n");
        }
    }
   
    void solveSudoku(vector<vector<char>>& board) {
     
        int rowNum[len][len] = {0};
        int colNum[len][len] = {0};
        int cubeNum[len][len] = {0};
        memset(rowNum, 0, sizeof(int) * len * len);
        memset(colNum, 0, sizeof(int) * len * len);
        memset(cubeNum, 0, sizeof(int) * len * len);

        for(int i=0; i < len; i++)
        for(int j=0; j < len; j++){
            if(board[i][j] != '.'){
                rowNum[i][board[i][j] - '0' - 1] = 1;
                colNum[j][board[i][j] - '0' - 1] = 1;            
                
                int cube = i / 3 * 3 + j / 3;
                cubeNum[cube][board[i][j] - '0' - 1] = 1;
            }
        }
        int flag = 0;
        solveSudokuCore(board, rowNum, colNum, cubeNum, 0, 0, flag);

    }
    void changeXY(int x , int y, int &nx, int &ny){
        y++;
        if(y == 9){
            y = 0;
            x++;
        }
        nx = x;
        ny = y;
    }
    
    void solveSudokuCore(vector<vector<char>> &board, int rowNum[][len], int colNum[][len], int cubeNum[][len], int x, int y, int &flag){
       					//回溯剪枝
//        if(x == 8)
  //         print(board, x, y);
        if(x == 9){
            flag = 1;
            return;
        } 

        int nx, ny;
        if(board[x][y] == '.'){
            for(int i = 0; i < len; i++){
                int cube = (x / 3 * 3 + y / 3);
                if(!rowNum[x][i] && !colNum[y][i] && !cubeNum[cube][i]){
                    board[x][y] = i + 1 + '0';

                    rowNum[x][i] = 1;
                    colNum[y][i] = 1;
                    cubeNum[cube][i] = 1;

                    
                    changeXY(x, y, nx, ny);
                    solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);
                    
					//回溯剪枝
                     if(flag) return;
                    board[x][y] = '.';
                    rowNum[x][i] = 0;
                    colNum[y][i] = 0;
                    cubeNum[cube][i] = 0;

                   
                }
            }
        }
        else{

            changeXY(x, y, nx, ny);
            solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);
        }

    }
};
```







### 位运算版本

```c++

class Solution {
private:
    int line[9];
    int column[9];
    int block[3][3];
    bool valid;
    vector<pair<int, int>> spaces;

public:
    void flip(int i, int j, int digit) {
        line[i] ^= (1 << digit);
        column[j] ^= (1 << digit);
        block[i / 3][j / 3] ^= (1 << digit);
    }

    void dfs(vector<vector<char>>& board, int pos) {
        if (pos == spaces.size()) {
            valid = true;
            return;
        }

        auto [i, j] = spaces[pos];
        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;
        for (; mask && !valid; mask &= (mask - 1)) {
            int digitMask = mask & (-mask);
            int digit = __builtin_ctz(digitMask);
            flip(i, j, digit);
            board[i][j] = digit + '0' + 1;
            dfs(board, pos + 1);
            flip(i, j, digit);
        }
    }

    void solveSudoku(vector<vector<char>>& board) {
        memset(line, 0, sizeof(line));
        memset(column, 0, sizeof(column));
        memset(block, 0, sizeof(block));
        valid = false;

        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') {
                    spaces.emplace_back(i, j);
                }
                else {
                    int digit = board[i][j] - '0' - 1;
                    flip(i, j, digit);
                }
            }
        }

        dfs(board, 0);
    }
};
```

> 位运算技巧：
>
> ​	取出最低位的1，其他位为零：`x & (-x)`
>
> ​	消除最低位的1：`x & (x - 1 )`
>
> ​     变换第pos位：`x ^ (1 << pos)`
>
> 得到最低位1的序数（低位零的个数）：`__builtin_ctz(unsigned_int x)`



### 优化

```c++
class Solution {
private:
    int line[9];
    int column[9];
    int block[3][3];
    bool valid;
    vector<pair<int, int>> spaces;

public:
    void flip(int i, int j, int digit) {
        line[i] ^= (1 << digit);
        column[j] ^= (1 << digit);
        block[i / 3][j / 3] ^= (1 << digit);
    }

    void dfs(vector<vector<char>>& board, int pos) {
        if (pos == spaces.size()) {
            valid = true;
            return;
        }

        auto [i, j] = spaces[pos];
        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;
        for (; mask && !valid; mask &= (mask - 1)) {
            int digitMask = mask & (-mask);
            int digit = __builtin_ctz(digitMask);
            flip(i, j, digit);
            board[i][j] = digit + '0' + 1;
            dfs(board, pos + 1);
            flip(i, j, digit);
        }
    }

    void solveSudoku(vector<vector<char>>& board) {
        memset(line, 0, sizeof(line));
        memset(column, 0, sizeof(column));
        memset(block, 0, sizeof(block));
        valid = false;

        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] != '.') {
                    int digit = board[i][j] - '0' - 1;
                    flip(i, j, digit);
                }
            }
        }
        int len = 9;
        bool flag = true;
        while(flag){
            flag = false;
            for(int i = 0; i < len; i++){
                for(int j = 0; j < len; j++){
                    if(board[i][j] != '.') continue;
                    int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1FF;
                    if( !(mask & (mask - 1))){
                        int digitnum = __builtin_ctz(mask & (-mask)) ;
                        flip(i, j, digitnum);
                        board[i][j] = digitnum + '0' + 1;
                        flag = true;
                    }
                }
            }

        }
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') {
                    spaces.emplace_back(i, j);
                }
            }
        }

        dfs(board, 0);
    }
};


```



