---
title: 面试题-建模
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-11 15:07:27
tags:
---

收集抽象建模题目。

<!-- more -->



## 面60：n个骰子的点数

### 题面：

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

## 思路：

第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。

## 代码：

```c++
class Solution {
public:
    int maxGV = 6;

    void calProb(vector<int>&prob, int originN, int currentN, int addS){
        if(currentN == 0){
            prob[addS - originN]++;
            return;
        } 
        for(int i = 1; i <= maxGV; i++)
            calProb(prob, originN, currentN - 1, addS + i);
    }
    vector<double> twoSum(int n) {
        // if(n < 1) return vector<int>();        
        vector<int> prob(n * maxGV - n + 1, 0);
        calProb(prob, n, n, 0);
        double allProb = pow(maxGV, n);
        vector<double> res(n * maxGV - n + 1);
        for(int i = 0; i < res.size(); i++)
            res[i] = prob[i] / allProb;
        return res;
    }
};


class Solution {
public:
    int maxGV = 6;

    vector<double> twoSum(int n) {
        // if(n < 1) return vector<int>();        
        int addLen = n * maxGV;
        vector<int>prob[2];
        for(int i = 0; i < 2; i++){
            prob[i].resize(addLen);
            for(int j = 0; j < addLen; j++)
                prob[i][j] = 0;            
        }

        int calIdx = 0;
        for(int i = 0; i < maxGV; i++)
            prob[1 - calIdx][i] = 1;
        
        for(int i = 0; i < n - 1; i++){
            for(int k = 0; k < addLen; k++){
                prob[calIdx][k] = 0;
                for(int j = max(0, k - maxGV); j < k; j++){
                    prob[calIdx][k] += prob[1 - calIdx][j];
                }
            }
                       
            calIdx = 1 - calIdx;
        }
        double allProb = pow(maxGV, n);
        vector<double> res(addLen - n + 1);
        for(int i = 0; i < res.size(); i++)
            res[i] = prob[1 - calIdx][i + n -1 ] / allProb;
        return res;
    }
};
```

## 面61：约瑟夫环

这题老朋友了。

### 题面：

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof)

## 思路：

数学+ 迭代。

求出`n`个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。

将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)\%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。

![fig1](http://static.come2rss.xyz/jianzhi_62_fig1.gif)

而且有$f(0,m) = 0$，可以快速用迭代计算出来。



### 代码：

```c++

class Solution {
public:
    int lastRemaining(int n, int m) {
        int res = 0;
        for(int i = 1;i <= n; i++){
            res = (res + m) % i;
        }
        return res;
    }
};
```

