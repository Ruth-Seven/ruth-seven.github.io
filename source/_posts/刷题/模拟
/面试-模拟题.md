---
title: 面试 模拟题
thumbnail: 'http://static.come2rss.xyz/科罗拉多州大沙丘公园.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 13:21:49
---





收集一些模拟题。

<!-- more -->

## 面29：打印矩阵

### 题面：

给出一个N*M的矩阵，按照从里到外的顺序顺时针打印矩阵。

### 思路：

（代码一）模拟题就是硬上。由于整个打印过程可以看成一圈圈的打印，所以按圈地打印。同时为了保持打印动作的一致行，都是打印一行或者一列差一个单元矩阵。

不考虑上面的一致性，直接考虑填涂条件的话，也就复杂一点点。

### 代码：

一种可以优美的实现N*N的正方形矩阵填充的代码。

```
#include<string>
#include<cstdio>
#include<iostream>
#include<queue>
#include<stack>
#include<map>
#include<cstring>
using namespace std;

void printNumberRect(int n, int m){
	vector<vector<int> > rect;
    rect.resize(n);
    for(int i = 0; i < rect.size(); i++) rect[i].resize(m);
    
    int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1;
    int counter = 1;
    while(xLeftUp <= xRightDown && yLeftUp <= yRightDown){
        for(; y < yRightDown; y++){
			rect[x][y] = counter;
            counter++;
        }
       
        for(; x < xRightDown; x++){
			rect[x][y] = counter;
            counter++;
        }
       
        for(; y > yLeftUp; y--){            
			rect[x][y] = counter;
            counter++;
        }
       
        for(; x > xLeftUp; x--){
			rect[x][y] = counter;
            counter++;
        }
        x++;
        y++;
        xLeftUp++;
        yLeftUp++;
        xRightDown--;
        yRightDown--;
    }
    if(xLeftUp == xRightDown + 2 && yLeftUp == yRightDown + 2 ) rect[x - 1][y - 1] = counter;
    for(int i = 0; i < rect.size(); i++){
        for(int j = 0; j < rect[i].size(); j++)
            printf("%d ", rect[i][j]);
        printf("\n");
    }
    printf("\n");
}

int main(){
    //freopen("data.in", "r", stdin);
   printNumberRect(0, 0);
   printNumberRect(2, 3);
   printNumberRect(6, 3);
   printNumberRect(3, 3);
}
```

就直接填写。

```
void printNumberRect(int n, int m){
	vector<vector<int> > rect;
    rect.resize(n);
    for(int i = 0; i < rect.size(); i++) rect[i].resize(m);
    
    int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1;
    int counter = 1;
    while(xLeftUp <= xRightDown && yLeftUp <= yRightDown){
        for(; y <= yRightDown; y++){
			rect[x][y] = counter;
            counter++;
        }
        for(x++, y--; x <= xRightDown; x++){
			rect[x][y] = counter;
            counter++;
        }
       //横着画可能会重叠
        for(x--, y--; y >= yLeftUp && x > xLeftUp; y--){            
			rect[x][y] = counter;
            counter++;
        }
        //同上
        for(y++, x--; x > xLeftUp && y < yRightDown; x--){
			rect[x][y] = counter;
            counter++;
        }
        x++;
        y++;
        xLeftUp++;
        yLeftUp++;
        xRightDown--;
        yRightDown--;
    }

    for(int i = 0; i < rect.size(); i++){
        for(int j = 0; j < rect[i].size(); j++)
            printf("%d ", rect[i][j]);
        printf("\n");
    }
    printf("\n");
}
```

