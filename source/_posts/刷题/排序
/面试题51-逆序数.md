---
title: '面试题51:逆序数'
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-07 13:21:31
tags:
---





这道题目还是比较神奇的。

<!-- more -->

### 题目：

在一个数组中找出所有的逆序数。

逆序数就是指前一个数字大于后一个数组的一对数字。

### 思路：

可以暴力查找，但是复杂度是O(N)O(N)。

想尝试用DP，但是没有明确的子问题分解界线。

最优算法是分治算法。将序列递归的一分为二，直到分割成长度为1的数组。在回朔地合并相邻的两个数组，同时统计序列的逆序数。在回朔的一个合并过程中，两个数组已经保持有序，也就是说数组内部的逆序数都不存在，只统计两个数组间的逆序数。

### 代码：

```
int InversePairCore(int *A, int *copy, int start, int end){
    // the the len of array should be looger than 1.
    // for example, the function will struggle with [0, 1].
    // becaues start = 0, mid = 0, end = 1. Moreover the situtaion never change.
    if(start + 1 >= end) return 0;
    int mid = (end + start) / 2;
	int leftCount = InversePairCore(A, copy, start, mid);
	int rightCount = InversePairCore(A, copy, mid, end);
    int midCount = 0;
    int p1 = mid - 1, p2 = end - 1, p3 = end - 1;
	while(p1 >= start && p2 >= mid){
        if(A[p1] > A[p2]){
            copy[p3] = A[p1];
            p3--;
            p1--;
        	
           midCount += p2 - mid + 1;
        } else{
            copy[p3] = A[p2];
            p3--;
            p2--;        	
        }        
    }
    while(p1 >= start){
          copy[p3] = A[p1];
            p3--;
            p1--;        
    }
    while(p2 >= mid){
            copy[p3] = A[p2];
            p3--;
            p2--;        	        
    }
    for(int i = start; i < end; i++) A[i] = copy[i];
    return rightCount + midCount + leftCount;
}

int InversePair(int A[], int length){
    if(A == nullptr || length <= 0) return 0;
    int *copy = new int(length);
//    for(int i = 0; i < length; i++) copy[i] = A[i];
    return InversePairCore(A, copy, 0, length);    
}
```

