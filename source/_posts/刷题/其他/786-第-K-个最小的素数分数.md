---
title: 786. 第 K 个最小的素数分数
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-07 14:13:32
tags:
---


<!-- more -->

## [786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)

难度hard

### 思路：

明显的有`A[i] < A[j]`，能够推出`A[i]/A[j] > A[i]/A[j+1]`，但是不能推出`A[i+1]/A[j]`和`A[i]/A[j+1]`的关系，毫无用处。

自然可以想到要用堆来维护第K小的数，而然超时。

评论里提出一种二分的方法，



### 代码：

堆维护数组

```
struct cmp{
    bool operator () (pair<int, int> x, pair<int, int> y){
        return x.first * 1.0 / x.second  < y.first * 1.0 / y.second;        
    }
};

class Solution {
public:
    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {
        priority_queue<pair<int, int>, vector<pair<int, int> >, cmp> pq;
        for(int i = 0; i < A.size() - 1; i++){
            for(int j = i + 1; j < A.size(); j++){
                double temp = A[i] * 1.0 /  A[j];
                if(pq.size() < K){
                    pq.push(make_pair(A[i], A[j]));
                }else if(pq.top().first * 1.0 / pq.top().second > temp){
                    pq.pop();
                    pq.push(make_pair(A[i], A[j]));
                }
            }
        }
        vector<int> res = vector(2, 0);
        res[0] = pq.top().first, res[1] = pq.top().second;
        return res;

    }    
};
```