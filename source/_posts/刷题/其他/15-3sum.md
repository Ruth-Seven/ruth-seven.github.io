---
title: 15 3sum
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 14:15:37
---

<!-- more -->

## 思路：

- 简单的说，先有序化，再二重循环遍历前两个指针，第三个指针采用二分法即可。注意跳过重复值

- 更巧妙的解法——双指针解法。先有序化，遍历第一个数字的同时，采用双指针从两边逼近结果。

  > 实际上这是对数组有序的利用。



**二重循环 + 二分**

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        vector< vector<int> > res;
        sort(nums.begin(), nums.end());
        // for(int i = 0;i < len; i++)
        //     printf("%d", nums[i]);
        for(int i=0; i < len - 2; i++){
                //排除重复结果
                if(i!=0 && nums[i-1] == nums[i]) continue;
            for(int j=i + 1; j < len - 1; j++){
                //排除重复结果
                if(j!=i+1 && nums[j] == nums[j-1]) continue;
                int ld = j + 1, rd = len - 1, mid;
                while(ld < rd){
                    mid = (ld + rd ) / 2;
                    if( nums[mid] + nums[i] + nums[j] >= 0)
                        rd = mid;
                    else ld = mid + 1; // 注意这里向上二分的时候， mid没有变动，同时循环可能结束。导致了mid的值可能在某种情况下雨rdld不同 ，所以循环结束最好选ld或者rd
                } 
                // printf("%d   ", mid);
                if(nums[rd] + nums[i] + nums[j] == 0){
                    res.push_back({nums[i], nums[j], nums[rd]});
                }
                
            }
        }
        return res;
    }
};
```

**双指针法**

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        vector< vector<int> > res;
        sort(nums.begin(), nums.end());
        for(int i=0;i < len - 2; i++){
            // 排除重复结果
            if(i !=0 && nums[i] == nums[i-1]) continue;
            int j = i + 1, k = len - 1;
            while(j < k){
                int sum = nums[i] + nums[k] + nums[j];
                // 排除重复结果
                if(j != i + 1 && nums[j] == nums[j-1]){
                    j++;
                    continue;

                }
                if(k != len -1 && nums[k] == nums[k+1]){
                    k--;
                    continue;
                }
                if(sum > 0) k--;
                else if(sum < 0) j++;
                else{
                    res.push_back({nums[i], nums[j], nums[k]});
                    j++, k--;
                }
            }

        }
        return res;
    }
};
```

\#[二分](http://blog.come2rss.xyz/tags/二分/)[TWO POINTERS](http://blog.come2rss.xyz/tags/Two-pointers/)