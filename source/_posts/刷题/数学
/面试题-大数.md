---
title: 面试题-大数
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-07 13:27:41
tags:
---

<!-- more -->



大数相关



## 面17：打印从1到最大的n位数

### 题目：

如题

### 思路1：

明显的太简单了。坑还是在数据范围上，考虑使用大数加法模拟计算。

### 思路2：

也可以使用全排列的思路，思考除了开头为0的n个`0~9`数字的排列组合就是题目所要求的的数据。

### 代码：

**大数**

```
#include<string>
#include<cstdio>
#include<iostream>
#include<queue>
#include<stack>
#include<map>
#include<cstring>
using namespace std;

bool isIncreaseDigit(int *numbers, char* n){
    for(int i = 0; n[i] != '\0'; i++)
        if(numbers[i] != n[i] - '0') return true;
	return false;
}

void PrintNumber(int *numbers, int MAXLEN){
    int idx = MAXLEN - 1;
    while(idx >= 0 && numbers[idx] == 0) idx --;
    for(int i = idx; i >= 0; --i)
        putchar(numbers[i] + '0');
    putchar('\n');
}

void Print1ToMaxDigits(char *n){
    const int MAXLEN = 1000;
	if(n == nullptr || strlen(n) <= 0 || strlen(n) >= MAXLEN) return;
    char test0[2] = "0";
	if(strcmp(test0, n) == 0){
        printf("0\n");
        return;
    }
    
	//reverse the input string
	char *newN = new char(MAXLEN);
	int lenN = strlen(n);
	for(int i = 0; i < lenN; i++)
		newN[lenN - i - 1] = n[i];
    
	//big data.
    int *numbers = new int[MAXLEN];
    memset(numbers, 0, sizeof(numbers));
    
	//Calculate the numbers.
    while(isIncreaseDigit(numbers, newN)){
        numbers[0]++;
		int idx = 0;
        while(numbers[idx] == 10){
            numbers[idx] = 0;
            ++idx;
            numbers[idx]++;
        	
        }
		PrintNumber(numbers, MAXLEN);
    }
    delete  []numbers;
    
}
int main(){
    //freopen("data.in", "r", stdin);
	char a[5] = {"1239"};
	Print1ToMaxDigits(a);
}
```

**全排列组合**

```
#include<string>
#include<cstdio>
#include<iostream>
#include<queue>
#include<stack>
#include<map>
#include<cstring>
using namespace std;

bool isIncreaseDigit(int *numbers, char* n){
    for(int i = 0; n[i] != '\0'; i++)
        if(numbers[i] != n[i] - '0') return true;
	return false;
}

void PrintNumber(int *numbers, int MAXLEN){
    int idx = MAXLEN - 1;
	//不输出前置零和全零
    while(idx >= 0 && numbers[idx] == 0) idx --;
	if(idx == -1) return;
	for(int i = idx; i >= 0; --i)
        putchar(numbers[i] + '0');
    putchar('\n');
}

void Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &flag){
	if(flag) return;
	if(pos == -1) {
		//直接用flag剪枝
		if(!isIncreaseDigit(numbers, newN)) flag  = 1;
        PrintNumber(numbers, lenOfN);
        return;
    }

	if(!isIncreaseDigit(numbers, newN)) return;
    for(int i = 0; i <= 9; i++){
        numbers[pos] = i;        
        Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag);		
	}
}
    
void Print1ToMaxDigits(char *n){
	if(n == nullptr || strlen(n) <= 0) return;
    char test0[2] = "0";
	if(strcmp(test0, n) == 0){
        printf("0\n");
        return;
    }
    
	//reverse the input string
	int lenOfN = strlen(n);
	char *newN = new char(lenOfN);
	
	for(int i = 0; i < lenOfN; i++)
		newN[lenOfN - i - 1] = n[i];
    newN[lenOfN] = '\0';

	//big data.
    int *numbers = new int[lenOfN];
    memset(numbers, 0, sizeof(numbers));
    
	//Calculate the numbers.
	int flag = 0;
    Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag);
    delete  []numbers;
    
}
int main(){
    //freopen("data.in", "r", stdin);
	// char a[5] = {"1239"};
	// char a[5] = {"0"};
	char a[50] = {"100"};
	Print1ToMaxDigits(a);
	// int t1[5] = {1, 2};
	// printf("%d", isIncreaseDigit(t1, a));

}
```

> 把自己写懵逼了，调试了好久，原来发现自己剪枝错了。
>
> 由于判断条件在变化，而剪枝条件是不变的，所以不能在更变条件后剪枝