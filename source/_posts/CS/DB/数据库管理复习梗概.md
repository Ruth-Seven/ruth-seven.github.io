---
title: 数据库管理复习梗概
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-07 12:22:24
tags:
---

参考书籍：《数据库系统教程》3Ed. 施伯乐

## 基本概念

### 概览



- 数据库（DateBase，DB）：长期存储在计算机内的数据集合

- 数据库管理系统（DataBase Mangement System, DBMS）：管理数据库的软件，其操作包括CRUD。

- 数据库系统（DataBase System，DBS）：由计算机软硬件和数据资源组成的计算机系统。

- 实体联系（Entity Relationship，ER）模型：对实体和实体之间关系的抽象。

- 概念模型：对用户需要的建模，往往建立出了ER模型。

- 逻辑模型：表达了数据库整体逻辑的模型。最重要的是关系模型，对象模型，还包括层次模型、网状模型。

- 逻辑独立性：应用程序与数据库的逻辑结构保持独立，即数据库的逻辑结构由DBMS即使变化了，应用程序也无需变化。

- 物理独立性：应用程序与数据库的物理结构保持独立，即数据库在磁盘的保存格式有数据库管理系统设置，应用程序无需关注数据库的物理结构。

  > 两种独立性都是将数据在磁盘中的定义和存储格式独立分离出去，因而简化应用程序编程，减少了程序维护和修改。

  ### 关系模型

- 关系模型：简单理解为一个二维表格

- 子模式：用户需要用到数据的描述（？）

  - 记录\元祖：表格中的一行数据
  - 关系\实例：元祖的集合
  - 字段\属性：表的一列的**列本身**
  - 元数：属性的个数
  - 基数：元祖个数

- 关键码\key\键：字段或者字段的集合

  - 超键（super key）：可以唯一标识元祖的键
  - 候选键（Candidate key）：不含多余属性的超键
  - 主键（Primary key）：用户选择的候选键
  - 外键（Foreign key）：其他关系模型的主键

- 完全性规则（*表示省略相同成分）：

  - 实体：主键不可缺
  - 参照：外键指向的元祖不可空
  - 用户：用户可自己定义完整性

- 关系代数

  - 并：两个关系模型的去重合并
  - 差：关系模型AB相减
  - 笛卡尔积：两个关系模型的全排列
  - 投影：选择一个关系模型若干列
  - 选择：选择一个关系模型的若干行
  - ————
  - 交：求两个关系模型的公共元祖
  - 连接：筛选出符合条件的两个模型的笛卡尔积
  - 自然连接：条件是公共字段相同的连接，并去除公共字段
  - 除法：A/B即尽可能 包含了所有B字段的且除了B字段A字段值相同的元祖集合。（简要的记忆为寻找公因数）
  - ————
  - 改名
  - 广义投影：允许投影中使用算术运算
  - 外连接：就是把自然连接过程中丢失的元祖加以填充空值（NULL）并加入自然连接的结果
  - 左（右）外连接：类似于外连接，就是把单单是左（右）边的模型丢弃掉的元祖加入
  - 半连接：自然连接后投影到一个关系模型（不残缺的那边）上

------

## SQL语句

### 术语

- 基本表：关系模式
  - 表的三种类型：
    - 基本表：实际存储在数据库中的表
    - 视图：若干表和其他视图组成的表的定义，在用户面前都是一样的
    - 导出表：查询导出的表
- 存储文件：存储模式（文件存储的方式）
- 视图：子模式
- 行：元祖
- 列：属性
- SQL模式（schema）：**表**和**约束**的**集合**（可能有多个表）

### 操作

**模式创建**：`CREATE SCHEMA <模式名> AUTHORIZATION <用户名>`

**模式撤销**：`DROP SCHEMA <模式名> [CASCADE | RESTRICT]` ; `CASCADE`即级联式，撤销下属的模式中所有的基本表、视图、索引；`RESTRICT`即约束式，仅当模式不存在任何下属元素才允许撤销；（`SCHEMA`可以替换为`DATABASE`）

**添加自定义类型**：`CREATE DOMAIN <YOUR_DOMAIN> CHAR(8)`这里把`CHAR(8)`定义成了自定义的domain名，可直接使用

**创建基本表**：

```
CREATE TABLE <基本表名>
	(
      --列表类型
      T#  CHAR(4) NOT NULL, --默认允许空值（与主键定义冗余）
	 TITLE CHAR(10), 
     -- 完整性约束
	 PRIMARY KEY(T#)    -- 定义主键
     FOREIGN KEY(C#) REFERENCES S(C#) --定义外键为C#，且对应S表的主键C#
    
	);
```

**插入数据：**

```
INSRET
```

**修改基本表：**

```
--增加表的列
ALTER TABLE <基本表名> ADD  <列名> <类型>
--删除表的列
ALTER TABLE <基本表名> DROP <列名> [CASCADE | RESTRICT ]
	-- CASCADE表明删除列的同时删除所有使用该列约束和视图
--修改列形状
ALTER TABLE <基本表名> MODIFY   <列名> <类型>
```

**撤销基本表：**

```
DROP TABLE <基本表名> [ CASCADE| RESTRICT] --同理
```

索引：？？

**数据查询：**

```
--- 基本sql查询语句
SELECT 属性1,属性2.....属性n 
FROM 表1,表2......表N
WHERE 关系表达式

---sql语句之间可以使用UNION（并） \ INTERSECT（交） \ EXCEPT（差）


----嵌套查询，括号中的子查询优先进行
SELECT 属性1,属性2.....属性n 
FROM 表1,表2......表N
WHERE 关系表达式 IN (
	SQL查询语句
	)
	---嵌套查询的速度往往比笛卡尔积的运算速度快
```

**待补充：更复杂的还有相关子查询（。。）、where使用的运算符,以及（P85~P101）**

------

## 关系数据库的规范设计

### 基本概念

**函数依赖（FD，Functional Dependency）：**当一个基本表中的属性集Y是属性集X的”函数值”(即X的值可以确定出唯一的Y)，就说明了X->Y,或者说Y依赖于X，这个基本表存在函数依赖。

（函数蕴涵P120）

**逻辑蕴涵：**若函数依赖集合F中存在的FD X→YX→Y和Y→ZY→Z，存在X→ZX→Z成立，则可称为F逻辑蕴涵X→ZX→Z 。

**闭包：** 就是函数依赖集上FF所有函数依赖和逻辑蕴涵推出来的依赖关系的完整集合，即为F+F+ 闭包。

**FD推理规则：** A→BA→B

- 自反性：AA自身能确定出自身的子集，这样推导出来的FD也称**平凡的FD**
- 增广性：依赖两边可以同时增加变量
- 传递性：可传递（逻辑蕴涵）
- ————
- 合并性：同时能推导出两个结果BCBC，就能推导出两个结果的和B,CB,C
- 分解性：与合并性相反，是将结果BCBC拆分成两个B,CB,C
- 伪传递性：传递过程中需要添加一个因素，X→Y,YZ→WX→Y,YZ→W 等价于XZ→WXZ→W
- 复合型：两个FD可以两边组成成一个FD
- ————
- 可以使用FD的定义来定义超键和候选键

当函数依赖集的闭包相等时，函数依赖集**等价**。可定义最难小函数依赖集：

- FD右边都是单属性；
- 无冗余FD
- FD的左边的属性集不是冗余的（子集无法代替集

**求出R的最小依赖集算法**

1. 分解FD的右边属性集，并去重
2. 消除左边冗余的FD
3. 消除R中冗余FD

模式分解特性

**无损分解：**把数据库模式分解为多个模式，并将分解的模式全部自然连接发现多出了元祖（**寄生元祖**）（也就是有损分解，实际上是信息的丢失，信息论！不确定性越大，信息量越小）。反之如果元祖不多不少就是无损分解。

> 上述讨论中假设模式存在一个“范关系”rr，可以分解为多个子关系rkrk。
>
> 当然也存在不存在范关系的rr，在连接过程中某个riri子关系的元祖会被丢失掉，这个被称为破环范关系的**悬挂元祖**

**依赖保持：**就是分解的模式中的依赖的并与原模式的依赖等价。

无损分解的测试方法：略（p128）

保持函数依赖的分解：略（p129）

### 关系模式的范式

**第一范式：**关系模式的R的关系r的属性值都是不可分的单一的（反例“AB”）

**第二范式：**每个非主属性完全依赖于候选键（挺严格的）。不完全依赖也就是局部依赖意味着A→BA→B 这个条件存在BB依赖于AA的一个子集，（注意这个FD推理规则A1不一样）

> 主属性：关系模式中R的候选键中的属性
>
> 化解成第二范式的算法：将一个局部依赖X→YX→Y的属性XYXY提出来形成一个关系，同时在原有属性集UU形成一个新的关系U−YU−Y；重复上述动作直到没有局部依赖。

**第三范式：**每个非主属性都不传递依赖与候选键，即为第三范式

> 传递依赖就是：X→Y,Y→ZX→Y,Y→Z 且X不依赖与Y，Z不是Y的子集

**BC范式：** 每个主属性不都传递依赖于候选键，则为BC范式。（相比于第三范式排除了主属性对候选键的传递依赖）

分解方法：略（p134）

------

## 数据库设计和ER模式

### 数据库设计过程：

1. 规划：调查、可行性分析等
2. 需求分析：分析用户活动，系统范围，分数用户数据，数据流图；数据字典(描述数据)
3. 概念设计：数据抽象设计局部概念模型和全局概念模型（比如ER）
4. 逻辑设计：把上一步概念模型转化符合具体DBMS的逻辑模型，比如关系模型；设计外模型（api接口）；评价模型；修正模型
5. 物理设计：存储记录结构设计；确定存储位置；完全性和安全性考虑；

### ER图

**组成结构：**

- 实体：数据对象
- 联系：实体之间的关系
  - 元数\度数（degree）：联系所涉及的实体个数
  - 数值约束：
    - （x,y）表示该实体的联系的**另一方**的数量限制
    - N或者：表示对实体在联系中的**映射数量关系**
  - 参与约束：
    - 双直线：完全参数该联系
    - 单直线：部分参与该联系
- 属性：实体的特征
  - 简单属性和复合属性：在于可不可分
  - 单值和多值属性：在于可不可同时取多个值
    - 替换：
      - 多值属性替换为一个新的实体类型
      - 用多个单值属性代替

**ER转关系模型的算法：**

1. 实体直接转化为一个关系
2. 关系的转化方法
   1. 一元关系直接转化属性
   2. 1：1关系转化为一个实体的外键和属性
   3. 1：N关系转化”N处”实体的外键和属性
   4. N:M关系转化为两个实体的主键和一个属性
   5. ————
   6. 三元关系可类比二元关系的转化方法（太无聊了不看了）

------

## 数据库存储结构

#### 文件组织

定长存储：连接方法和顺序方法

不定长存储解决方案：

- 字符串表示形式：分槽式页结构（定长的首部顺序排列并记录剩余数据的其实起始地址，不定长的二进制数据从低端生长）
- 变长记录的定长表现形式：预留空间、固定块的溢出块相补充、定长块的连接形式（p187）

 (不想看了555)