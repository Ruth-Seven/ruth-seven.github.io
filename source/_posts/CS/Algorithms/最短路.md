---
title: 最短路
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 12:07:08
---

````c++

#include<iostream>
#include<cstdio>
#include<vector>
#include<string>
#include<queue>
#include<algorithm>
#include<cmath>
using namespace std;
const int INF = 0x3ffffff;
const int MX = 500;
int n, m, l, cap, s, t;
int dis[MX], vis[MX], bvis[MX], edge[MX][MX], fushe[MX];
int bec = -1    , becfu = INF, allp;
double rate = 1;
vector<int> path[MX], bepath, nwpath;
int disjk(){
    fill(dis,dis + MX, INF);
    dis[s] = 0;
    for(int i = 0;i < n;i++){
        int u = -1, minv =  INF;
        for(int j = 0;j < n; j++){
            if(!vis[j] && dis[j] < minv){
                minv = dis[j];
                u  = j;
            }
        }
        if(u == -1 ) break;
        vis[u] = 1;
        for(int v = 0; v < n;v++){
            if( edge[u][v] != INF && !vis[v]){//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点
                                            //! 但是之前已经放缩的节点是绝对不会再被放缩的。。因为无负权
//            if( edge[u][v] != INF ){//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点
                if(!vis[v] && dis[v] > dis[u] + edge[u][v] ){
                    dis[v] = dis[u] + edge[u][v];
                    path[v].clear();
                    path[v].push_back(u);
                }else if( dis[v] ==  dis[u] + edge[u][v]){
                    path[v].push_back(u);
                }
//            }

        }
    }
}

int bfs(){
    queue<int> que, lay;
    que.push(s);
    lay.push(0);
    bvis[s] = 1;
    while(que.size()){
        int u = que.front(), layer = lay.front(); que.pop(), lay.pop();
        if(layer < l)
            fushe[u] += (int)(ceil(1.0 * fushe[u] * (l - layer) / l));
        for(int i = 0; i < n;i++)
            if(edge[u][i] != INF && !bvis[i]){//!
                que.push(i);
                bvis[i] = 1;
                lay.push( layer + 1);
            }
    }
}
int dfs(int u){
    nwpath.push_back(u);
    if(u == s){
        allp ++;
        int npc = 0, npfushe = 0;
        for(int i = 0;i < nwpath.size(); i++){
            npc += fushe[nwpath[i]];
            if(i < nwpath.size() / 2) npfushe += fushe[nwpath[i]];
        }
        npc = npc % cap;
        if(npc > bec || npc == bec && npfushe < becfu){ //! npc >= bec
            bepath = nwpath;
            bec = npc;
            becfu = npfushe;
        }
    }else{
        for(int i = 0;i < path[u].size(); i++)
            dfs(path[u][i]);
    }
    nwpath.pop_back();
}

 int main(){
    fill(edge[0], edge[0] + MX * MX , INF);//! init
    int c1, c2, tmp;
    cin >> n >> m >> l >> cap >> s >> t;
    for(int i = 0;i < n;i ++) cin >> fushe[i] ;
    for(int i = 0; i < m;i++){
        scanf("%d%d%d",&c1, &c2, &tmp);
        edge[c1][c2] = edge[c2][c1] = tmp;
    }
    bfs();
    disjk();
    dfs(t);
    if( !bvis[t]) printf("-1\n");
    else{
        printf("%d %d %d %d\n", allp, dis[t], bec, becfu);
        reverse(bepath.begin(), bepath.end());
//        if(bepath.size()) printf("%d", bepath[0]);//! runtime error
        for(int i = 0;i < bepath.size(); i++)
            if(i + 1 == bepath.size()) printf("%d", bepath[i]);
            else  printf("%d->", bepath[i]);
    }
    return 0;
}

````

