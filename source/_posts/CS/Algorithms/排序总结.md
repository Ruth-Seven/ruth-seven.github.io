---
title: 排序总结
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-07 12:14:28
tags:
---



## 交换类？

### 选择排序



不具有稳定性，复杂度稳定在O(n2)O(n2)。

> 存在不同元素大范围交换，所以不稳定。

```
int main(){
    // freopen("./data.in", "r", stdin);
    int c[6] = {5, 3, 2, 1, 7, 2}, n = 6;
    for(int i = 0; i < n; i++){
		int mp = i;
        for(int j = i + 1; j < n; j++){
            if(c[j] < c[mp]){
				mp = j;
			}
        }
        int temp = c[mp];
        c[mp] = c[i];
        c[i] = temp;
    }
    for(int i=0; i < n; i++){
        printf("%d ", c[i]);
    }
    printf("\n");
    return 0;
}
```

### 冒泡排序

具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。

```
int main(){
    // freopen("./data.in", "r", stdin);
    int c[6] = {5, 3, 2, 1, 7, 2}, n = 6;
    for(int i=0; i < n-1; i++){
        int flag = 0;
        for(int j=0; j < n - 1 - i; j++){
            if(c[j] > c[j+1]){
                int temp = c[j];
                c[j] = c[j + 1];
                c[j + 1 ] = temp;
                flag = 1;
            }
        }
        if(!flag) break;
    }
    for(int i=0; i < n; i++){
        printf("%d ", c[i]);
    }
    printf("\n");
    return 0;
}
```

## ？？

### 插入排序

具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。

```
int main(){
    // freopen("./data.in", "r", stdin);
    int c[6] = {5, 3, 2, 1, 7, 2}, n = 6;
    for(int i = 1; i < n; i++){
        int j = i, t = c[j];
        while(j > 0 && t < c[j - 1]){
            c[j] = c[j - 1];
            j--;
        }
        c[j] = t;
    }
    for(int i=0; i < n; i++){
        printf("%d ", c[i]);
    }
    printf("\n");
    return 0;
}
```

## 归并排序

稳定，复杂度为O(nlgn)O(nlgn)。

```
int printArr(int A[], int r, int l){
    for(int i=r; i < l + 1; i++){
        printf("%d ", A[i]);
    }
    printf("\n");

}

const int maxn  = 100;
int merge(int arr[], int l1, int r1, int l2, int r2){
	int i = l1, j = l2, k = 0;
	int temp[maxn];
	while(i <= r1 && j <= r2){
		if(arr[i] < arr[j])
			temp[k++] = arr[i++]; 
		else if(arr[i] >= arr[j])
			temp[k++] = arr[j++];
	}
	while(i <= r1)
    	temp[k++] = arr[i++]; 
	while(j <= r2)
    	temp[k++] = arr[j++]; 
    for(int i = l1, k = 0; i <= r2; i++, k++) arr[i] = temp[k];
}

//递归写法
int mergeSort_re(int A[], int l, int r){
	if(l < r){
		int mid = (l + r) / 2;
		mergeSort_re(A, l, mid);
		mergeSort_re(A, mid + 1, r);
		merge(A, l, mid, mid + 1, r);
	}
}
// 迭代写法
int mergeSort_for(int A[], int l, int r){
	if(l < r){
		int n = r - l + 1;
		//step为组内元素个数
		for(int step = 1; step <= n; step *= 2){
			for(int i = 0; i < n; i += 2*step){
				//这么写行不行？测试一下A[5]
				// 事实证明这种写法很优美!
				merge(&A[l], i, i + step - 1, i + step, min(i + 2 * step - 1, n - 1));
			}
		    printArr(A, l, r);
        }
        
	}

}
int main(){
    // freopen("./data.in", "r", stdin);
    int c[10] = {5, 3, 2, 1, 7, 2, 10, 3, 5, -1}, n = 10;
    
    // mergeSort_re(c, 0, n - 1);
    mergeSort_for(c, 5, n - 1);
    
    printArr(c, 0, n - 1);
    return 0;
}
```

## 快速排序

不稳定，复杂度为O(nlgn)O(nlgn)到O(n2)O(n2)，最广泛使用的排序算法。

```
//挖沙法 分割
int Partition(int A[], int l, int r){
	//三个数取最小值
    int minp = l;
    if(A[r] < A[minp]) minp = r;
    if(A[(r + l) / 2] < A[minp]) minp = (r + l) / 2;
    int temp = A[minp];
    A[minp] = A[l];
    A[l] = temp;
    int i = l, j = r;
    while(i < j){
        while(i < j && temp < A[j]) j--;
        A[i] = A[j];
        while(i < j && temp >= A[i]) i++;
        A[j] = A[i];
    }
    A[j] = temp;
    return j;
}
void quickSort(int A[], int l, int r){
    if(l >= r) return;
    int mid = partition(A, l, r);
        printArr(A, 0, 9);
        printf("%d\n", mid);
    quickSort(A, l, mid - 1); // 如果这里取mid - 1, 可能会导致mid为右侧最小值的情况时，无限partition！（没错，微妙的递归）
    quickSort(A, mid + 1, r);

}
```



