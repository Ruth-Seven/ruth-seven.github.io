---
title: 拓扑排序
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 12:09:07
---

```c++


/** This is Code of JJ

Problem      :拓扑排序
Source       :
Solution     :
AnyDetial    :

DateAndTime  :2.26
CostofTime   :

**/
#include<iostream>
#include<queue>
#include<stack>
#include<vector>
#include<cstdio>
using namespace std;

const int N = 1e3;

vector<int>adj[N];
int indegree[N],dvis[N];

int n,m;

vector<int>res;

bool topu()
{
    int sortnum = 0;
    queue<int>q;
    for(int i=0;i<n;i++)
    {
        if(indegree[i]==0)
            q.push(i);
    }
    while(!q.empty())
    {
        int u = q.front();
        cout<< u << endl;
        q.pop();

        for(int j=0;j<adj[u].size();j++)
        {
            int k = adj[u][j];
            indegree[k]--;
            if(indegree[k]==0)
            {
                q.push(k);
            }
        }
        sortnum++;
    }

    if(sortnum==n) return true;
    else return false;
}


//dfs 逆序输出拓扑排序
stack<int> s;
int vis[N];
void dfs(int u){
    vis[u] = 1;
    for(int i=0;i<adj[u].size();i++){
        int v = adj[u][i];
        if(!vis[v]){
            dfs(v);
        }
    }
    s.push(u);
    cout<<u<<endl;
}
int main()
{
    scanf("%d%d",&n,&m);

    int c1, c2, w;
    for(int j=0;j<m;j++)
    {
        scanf("%d%d",&c1,&c2);
        adj[c1].push_back(c2);
        indegree[c2] ++;

    }
    topu();
}
/*

5 5
0 1
1 3
3 4
0 2
2 4
*/w
```

