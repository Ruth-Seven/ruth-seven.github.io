---
title: 关键路径
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:  
categories:
date: 2020-08-07 12:06:27
---





​	```

```c++
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
using namespace std;
const int mss = 1e3 + 100;
const int INF = 0x3fffffff;
int edge[mss][mss], n, m;
int ve[mss], vl[mss], e[mss][mss], l[mss][mss];
int ingree[mss], maxtime;
stack<int> stk;
vector<int> activity[mss], tempp;
int topu(){
    queue<int> que;
    for(int i = 1;i <= n;i++)
        if(ingree[i] == 0) que.push(i);
    while(que.size()){
        int u = que.front(); que.pop();
        stk.push(u);
        for(int i = 1; i <= n;i++){
            if(edge[u][i] != INF){
                ingree[i] --;
                if(ingree[i] == 0) que.push(i);
                ve[i] = max(ve[i], ve[u] + edge[u][i]);// 拓扑排序兵同时计算 每个节点的最早开始时间
//                cout << ve[u] << endl;
            }
        }
    }
    if(stk.size() == n) return true;
    else return false;
}
int critical_path(){
    //初始化汇点
    int maxv = 0;
    for(int i = 1;i <= n; i++)
        if( maxv < ve[i]) maxv =  ve[i];
    for(int i = 1;i <= n; i++)
        vl[i] = maxv;
    maxtime = maxv;
    //逆拓扑排序地计算每个节点的最晚开始时间
    while(stk.size()){
        int u = stk.top(); stk.pop();
        for(int i = 1;i <= n;i++){
            if(edge[u][i] != INF)
                vl[u] = min( vl[u], vl[i] - edge[u][i]);
        }
    }
    // 查找关键路径
    for(int i = 1;i <= n;i ++){
        for(int j = 1;j <= n;j ++){
            if(edge[i][j] != INF){
                e[i][j] = ve[i];
                l[i][j] = vl[j] - edge[i][j];
                if(e[i][j] == l[i][j]){//插入path 以便查询所关键路径
                    activity[i].push_back(j);
                }
            }
        }
    }
    //排序以保证按序输出
    for(int i = 0;i <= n; i++){
        sort(activity[i].begin(), activity[i].end());
    }
}
int dfs(int u){//输出所有关键路径
    tempp.push_back(u);
//    cout << u << endl;
    if(activity[u].size() == 0){
        for(int i =0 ;i < tempp.size() ;i++){
            cout << tempp[i];
            if(i + 1 != tempp.size()) cout << "->";
            else cout << "\n";
        }
    }else {
        for(int i = 0;i < activity[u].size(); i++)
            dfs( activity[u][i]);
    }
    tempp.pop_back();
}
int main(){
    fill(edge[0], edge[0] + mss * mss, INF);
    int u, v, w;
    cin >> n >> m;
    for(int i = 0;i < m;i++){
        cin >> u >> v >> w;
        edge[u][v] = w;
        ingree[v]++;
    }
    if(!topu()){
        cout << "NO\n";
        return 0;
    }
    cout << "YES\n";
    critical_path();
    int q;
    cin >> q;
    for(int i = 0;i < q;i++){
        cin >> u >> v;
        cout << e[u][v] << ' ' << l[u][v] << endl;
    }
    cout << maxtime << endl;
    for(int i = 1;i <= n;i++)
        if( activity[i].size() && ve[i] == 0) dfs(i); //一个关键路径的起点的后序存在节点的 且最早开始时间为0
}
```

