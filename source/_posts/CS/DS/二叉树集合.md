---
title: 二叉树集合
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 12:23:28
---

（好像不怎么用心的样子呢）



```c++
/** This is Code of JJ

Problem      :
Source       :
Solution     :
AnyDetial    :
注意点：
1.递归边界是root为NULL
2.插入：
    查找失败--NULL--即为插入点
    利用插入创建时，第一个数据就是查找失败的点！
3.层序遍历：队列里存的是地址；
DateAndTime  :
CostofTime   :

**/

#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;

struct Node{
    int data;
    Node *lchild,*rchild;
    Node()
    {
        lchild = NULL;
        rchild = NULL;
    }
    Node(int a)
    {
        data = a;
        lchild = NULL;
        rchild = NULL;
    }
}; //

Node* newnode(int a)//! create a node with new!
{
    return new Node(a);
}

//! find those nodes whose data is x and replace those data with x;
void search_node(Node* root, int key, int x)
{
    if(root==NULL) return;
    if(root->data==key) root->data = x;//! a -> data !
    search_node(root->rchild,key,x);
    search_node(root->lchild,key,x);
}

void insert(Node *&root, int x)
{
    if(root==NULL)//! The
    {
        root = newnode(x);
        return;
    }
    if(root->data>x)
    {
        insert(root->lchild,x);
    }else{
        insert(root->rchild,x);
    }
}

Node* create(int a[], int n)
{
    Node *root = NULL;//!the index begin with 0;
    for(int i=0;i<n;i++)
    {
        insert(root,a[i]);
    }
    return root;
}

void preorder(Node *root)
{
    if(root==NULL) return;!
    printf("%d ",root->data);
    preorder(root->lchild);
    preorder(root->rchild);
}
void inorder(Node *root)
{
    if(root==NULL) return;
    inorder(root->lchild);
    printf("%d ",root->data);
    inorder(root->rchild);
}
void postorder(Node *root)
{
    if(root==NULL) return;
    inorder(root->lchild);
    inorder(root->rchild);
    printf("%d ",root->data);
}
void layerorder(Node* root)
{
    if(root==NULL) return;
    queue<Node*>q;
    q.push(root);
    while(!q.empty())
    {
        Node *t = q.front();
        q.pop();
        printf("%d ",t->data);
        if(t->lchild!=NULL) q.push(t->lchild);
        if(t->rchild!=NULL) q.push(t->rchild);
    }

}
//!前序遍历和中序遍历重建树
Node *create_in_pre( int inorder[], int inl, int inr, int preorder[], int prel, int prer)//! in[l,r], pre[l,r],
{
    if(inl>inr || prel>prer) return NULL;
    int pos_in = inl;
    for(;pos_in<=inr;pos_in++)
    {
        if(inorder[pos_in]==preorder[prel])// find the index of root
            break;
    }
    int numleft = pos_in - inl;// the number of left tree;
    Node *root = newnode(preorder[prel]);
    root->lchild = create_in_pre(inorder, inl, pos_in-1, preorder, prel+1, prel+numleft);
    root->rchild = create_in_pre(inorder, pos_in+1, inr, preorder, prel+numleft+1, prer);
    return root;
}

//!后序遍历和中序遍历重建树
Node *create_in_post(int in[],int inl, int inr, int post[], int postl, int postr)
{
    if(inl>inr) return NULL;
    Node *root = newnode(post[postr]);
    int pos = inl;
    for(;pos<inr;pos++)
    {
        if(in[pos]==root->data) break;
    }
    int k = pos - inl;
    root->lchild = create_in_post(in,inl,pos-1,post,postl,postl+k-1);
    root->rchild = create_in_post(in,pos+1,inr,post,postl+k,postr-1);
    return root;
}
int main()
{
    int a[1000] = {1,3,-2,5,7,-10,15,0} ,n = 8;
    Node *root = create(a,n);
    preorder(root);
    cout<<endl;
    inorder(root);
    cout<<endl;
    postorder(root);
    cout<<endl;
    int pre[10] = {1 ,-2 ,-10, 0, 3 ,5 ,7 ,15};
    int in[10] = {-10, -2, 0, 1, 3, 5, 7, 15};
    int post[10] = {-10 ,-2, 0, 3, 5, 7, 15 ,1};

    Node *newroot1 = create_in_pre(in,0,7,pre,0,7);
    Node *newroot2 = create_in_post(in,0,7,post,0,7);
    cout<<"!recreate!\n";
    inorder(newroot1);
    cout<<endl;
    inorder(newroot2);

}
```

