---
title: 二叉查找树实现
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
tags:
categories:
date: 2020-08-07 12:25:42
---



二叉查找树的一个实现

```c++
尤其注意删除那一部分的逻辑！

/** This is Code of JJ

Problem      :
Source       :
Solution     :
AnyDetial    :
注意点：
1.递归边界是root为NULL
2.插入：
    查找失败--NULL--即为插入点
    利用插入创建时，第一个数据就是查找失败的点！
3.层序遍历：队列里存的是地址；
DateAndTime  :
CostofTime   :

**/

#include<iostream>
#include<queue>
#include<cstdio>
#include<stack>
using namespace std;

struct Node{
    int data,layer;
    Node *lchild,*rchild;
    Node()
    {
        lchild = NULL;
        rchild = NULL;
    }
    Node(int a)
    {
        data = a;
        lchild = NULL;
        rchild = NULL;
    }
}; //

Node* newnode(int a)//! create a node with new!
{
    return new Node(a);
}

//! find those nodes whose data is x and replace those data with x;
void search_node(Node* root, int key, int x)
{
    if(root==NULL) return;
    if(root->data==key) root->data = x;//! a -> data !
    search_node(root->rchild,key,x);
    search_node(root->lchild,key,x);
}

void insert(Node *&root, int x)
{
    if(root==NULL)//! The
    {
        root = newnode(x);
        return;
    }
    if(root->data>x)
    {
        insert(root->lchild,x);
    }else{
        insert(root->rchild,x);
    }
}

Node* create(int a[], int n)
{
    Node *root = NULL;//!the index begin with 0;
    for(int i=0;i<n;i++)
    {
        insert(root,a[i]);
    }
    return root;
}

void preorder(Node *root)
{
    if(root==NULL) return;!
    printf("%d ",root->data);
    preorder(root->lchild);
    preorder(root->rchild);
}
//!可用于递归赋值父节点信息和遍历输出根到所有节点的路径

Node *path[1000];
int pos = -1;
void preorder_withrint(Node *root)
{
    if(root==NULL) return;
    path[++pos] = root;
//    cout<<pos<<endl;
    for(int i=0;i<pos;i++)
        printf("%d ",path[i]->data);
    printf("%d\n",path[pos]->data);
//    printf("%d ",root->data);
    preorder_withrint(root->lchild);
    preorder_withrint(root->rchild);
    pos--;
}

void inorder(Node *root)
{
    if(root==NULL) return;
    inorder(root->lchild);
    printf("%d ",root->data);
    inorder(root->rchild);
}

//!错误代码 ： 此代码无法识别已经某一节点右节点是否已经压入过栈，而陷入无限循环之中
void inoder_withrecursion(Node *root)
{
    cout<<"Worry Code!\n";
    Node *q;
    stack<Node*> s;
    s.push(root);
    while(!s.empty()){
        getchar()
        ;q = s.top();
        if(q->lchild)//!一个错误点
            s.push(q->lchild);
        else{
            printf("%d ",q->data);
            s.pop();
            if(q->rchild)
                s.push(q->rchild);
        }
    }
}
void postorder(Node *root)
{
    if(root==NULL) return;
    inorder(root->lchild);
    inorder(root->rchild);
    printf("%d ",root->data);
}
void layerorder(Node* root)
{
    if(root==NULL) return;
    queue<Node*>q;
    q.push(root);
    while(!q.empty())
    {
        Node *t = q.front();
        q.pop();
        printf("%d ",t->data);
        if(t->lchild!=NULL) q.push(t->lchild);
        if(t->rchild!=NULL) q.push(t->rchild);
    }

}
int layerorder_withlayer(Node* root)
{
    if(root==NULL) return 0 ;
    int Nol = 0,Non = 0,maxn = 0;
    queue<Node*>q;
    root -> layer = 1;
    q.push(root);
    while(!q.empty())
    {
        Node *t = q.front();
        if(t->layer!=Nol){
            Nol = t->layer;
            Non = 1;
            cout<<"?";
        }else
            Non ++;
        maxn = max(Non,maxn);
        q.pop();
        printf("%d %d\n",t->data,t->layer);
        if(t->lchild!=NULL) {
            t->lchild->layer = Nol + 1;
            q.push(t->lchild);
        }
        if(t->rchild!=NULL){
            t->rchild->layer = Nol + 1;
            q.push(t->rchild);
        }
    }
    return maxn;

}
//!前序遍历和中序遍历重建树
Node *create_in_pre( int inorder[], int inl, int inr, int preorder[], int prel, int prer)//! in[l,r], pre[l,r],
{
    if(inl>inr || prel>prer) return NULL;
    int pos_in = inl;
    for(;pos_in<=inr;pos_in++)
    {
        if(inorder[pos_in]==preorder[prel])// find the index of root
            break;
    }
    int numleft = pos_in - inl;// the number of left tree;
    Node *root = newnode(preorder[prel]);
    root->lchild = create_in_pre(inorder, inl, pos_in-1, preorder, prel+1, prel+numleft);
    root->rchild = create_in_pre(inorder, pos_in+1, inr, preorder, prel+numleft+1, prer);
    return root;
}

//!后序遍历和中序遍历重建树
Node *create_in_post(int in[],int inl, int inr, int post[], int postl, int postr)
{
    if(inl>inr) return NULL;
    Node *root = newnode(post[postr]);
    int pos = inl;
    for(;pos<inr;pos++)
    {
        if(in[pos]==root->data) break;
    }
    int k = pos - inl;
    root->lchild = create_in_post(in,inl,pos-1,post,postl,postl+k-1);
    root->rchild = create_in_post(in,pos+1,inr,post,postl+k,postr-1);
    return root;
}
int main()
{
    int a[1000] = {1,3,-2,5,7,-10,15,0} ,n = 8;
    Node *root = create(a,n);
//    preorder(root);
    cout<<endl;
    inorder(root);
    cout<<endl;
//    inoder_withrecursion(root);
    preorder_withrint(root);
    cout<<endl;
//    postorder(root);
//    cout<<endl;
//    layerorder(root);
//    cout<<endl<<"max of Layer\n"<< endl;
//    cout<<layerorder_withlayer(root);
//    cout<<endl;

//    int pre[10] = {1 ,-2 ,-10, 0, 3 ,5 ,7 ,15};
//    int in[10] = {-10, -2, 0, 1, 3, 5, 7, 15};
//    int post[10] = {-10 ,-2, 0, 3, 5, 7, 15 ,1};
//
//    Node *newroot1 = create_in_pre(in,0,7,pre,0,7);
//    Node *newroot2 = create_in_post(in,0,7,post,0,7);
//    cout<<"!recreate!\n";
//    inorder(newroot1);
//    cout<<endl;
//    inorder(newroot2);

}

```

