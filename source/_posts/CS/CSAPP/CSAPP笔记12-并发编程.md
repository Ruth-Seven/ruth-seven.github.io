---
title: CSAPP笔记12-并发编程
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-31 09:13:09
tags:
---
现代操作系统提供了三种方法进行并发编程——进程、I/O多路复用和线程。这章节提供了三种构造并发服务器的思路。
<!-- more -->

## 基于进程的并发服务器

主进程在TCP链接成功后，`fork`一个子进程来处理链接内容。主进程绑定僵死信号到自定义函数，保证僵死进程被主进程回收。

![image-20200831092105604](http://static.come2rss.xyz/image-20200831092105604.png)

明显的，父子进程拥有同一份全局变量，但是父子进程无法直接通信，只能通过IPC（进程间通信）机制。与此同时，带来的进程管理和IPC开销都很高。

> unix IPC：指同一主机上一个进程对其他进程相互通信的技术。其中包括，管道、先进先出、系统V共享内存以及系统V信号量。

## 基于I/O多路复用的并发编程/基于I/O多路复用的并发事件驱动服务器

`select`函数提供了从多路I/O读取的事件触发唤醒机制。该函数会要求内核挂起进程，并等待至少一个I/O事件发生后，在讲控制权返还给应用程序。他避免了等待终端输入的同时无法处理外部链接的尴尬情况，提高了系统并行程度。虽然当它在处理一个请求时，仍然无法处理另一个请求。

以此我们可以编写基于多路I/O的并发事件服务器，更进一步的，我们将进程的状态模型化为状态机。每个状态都有一组输入事件，转移。



### 优劣之处

事件驱动事件的优点之一就是根据事件给予程序设计更多控制权。另外，基于多路I/O的事件驱动程序服务器运行在单一进程上下文中，因此每个逻辑流都能访问该进程的所有地址空间，使得流之间的数据共享变得容易。其次，可是使用方便熟悉的调试工具。

事件驱动的另一个明显的缺点就是编码复杂。不幸的是，如果并发力度减少，复杂性还会上升。它的另一个缺点就是不能充分利用多核资源。



## 基于线程的并发编程

线程是微型进程，由内核调度。多个线程运行在同一进程的上下文中，共享进程虚拟空间的所有内容，包括代码、数据、堆、共享库和打开的文件。那么单个线程独有的资源有程序计数器、栈和栈指针，线程ID，条件码和通用寄存器值。也就是说，线程切换的代价远远比进程小。另外，线程不像进程拥有严格父子关系，主进程和对等线程的唯一区别在于主进程是一个创建的线程。所有和一个进程相关的线程组成一个线程池，其中每一个线程都可以杀死他的对等线程，或者等待其终止。

线程的栈一般来说都是不共享的，但是由于线程的 栈都保存在进程的虚拟空间中，而且线程的栈的空间对其他的线程总是不设防的。如果一个线程能够获得其他线程的栈地址，实际是读写栈上的任何部分的。

在变量上，全局变量和本地静态变量（函数内部的带static修饰的变量）都保存在虚拟空间中读写区域，运行过程中只有该变量的一份实例。也就是说，即使每个线程都定了一个`cnt`变量，每个线程在后续读写也是读写这个静态变量的唯一实例。而本地自动变量随着函数运行而保存在栈中，随着函数结束而消失。

每个进程都是一个主线程，在创建一个线程后，称那个线程为对等线程（peer thread）。那么两个线程开始并发运行，当主进程遭遇慢速系统调用后，或者被系统的间隔计数器中断，控制转给另一个线程。 这就是线程执行的主要模式。



### POSIX线程

Posix线程（Pthreads）是C程序处理线程的一个标准接口，而且在所有Linux系统上通用。

`int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg)` 创建一个新线程。`pthread_t`指线程ID

`pthread_t pthread_self(void)`：返回线程的ID。

#### 终止

`void pthread_exit(void *thread_return)` 主进程调用会等待其他线程终止再终止主进程和整个进程。其他进程调用会显式地终止线程。

`exit()`终止进程和所有相关的线程

`int pthread_cancel(pthread_t tid)`：另一个线程调用，终止另一个对等线程。

#### 等待

`int pthread_join(pthread_t tid, void **thread_retunr)` 阻塞线程等待其他线程终止。

#### 分离

`int pthread_detach(pthread_t tid)`：分离该线程。分离后的线程不会被其他线程杀死或回收，它的内存资源在它终止后将有系统自动释放。相反，可结合的线程可被杀死和回收。

> 实际上高性能服务器不愿意也没必要等待每一个对等线程终止，载回收它的资源。那么每个资源都应该在调用该函数，分离它自己。`pthread_detach(pthread_self())`！

### 初始化

```c
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
```

once_control是一个全局或者静态变量。用这个参数调用`pthread_once`后将在其第一次运行时调用`init_routine`，之后的再调用`pthread_once`将不会再干任何事情。这个特性在多个线程动态初始化共享变量特别有用。

### 线程的同步和竞争

同步竞争问题是经典的并行问题，常常在多线程编程对引出麻烦。尤其是仅仅一行简单操作代码却有多条指令组成的情况下，让人百思不得其解。

具体不记录了，也是一些重复的内容。





### 预线程化的并发服务器



![image-20200831123224901](http://static.come2rss.xyz/image-20200831123224901.png)

descriptors：描述符

其实这图所示的服务器模型也是一种事件驱动模型。

## 线程提高并行性

不得不提，并发的兄弟——并行。在多核处理器上，每个核都可以运行一个进程或者线程，就是所谓的并行。可以理解，并行程序是并发程序的真子集。并行程序简单的来说可以大任务分成几个小任务分配给不同的线程，再由主线程来收集计算最终结果。但是由于线程之间可能存在的运行同步和竞争问题需要进行PV操作，还有多变量的内存引用，线程切换等开销，并行程序可能还不如非并行版本的程序快。

要提高效率，要注意几个点：

+ 尽量减少共享变量，减少巨大的同步开销。
+ 多引用局部变量来消除不必要的内存引用。

### 刻画程序的性能

并行程序的加速比（强扩展，strong scaling）：
$$
S_t = \frac{T_1}{T_p}
$$
$T_p$为程序在$k$个核上的运行时间。如果$T_1$是顺序版本的程序，则称公式为绝对加速比，如果$T_1$是并行版本的程序，那么公式称为相对加速比。前者要求的拥有源代码甚至有等价的复杂度实现要求很高。但是和后者增加无谓的切换线程的开销，使得$S_t$偏大。

效率（efficiency）：
$$
E_p = \frac{S_p}{p} = \frac{T_1}{pT_p}
$$
效率是对由于并行化造成的开销的衡量。高效率的程序在有用的工作上花费更多的时间，而在同步和通信上花费更少的时间。

弱扩展：同等增加处理器数量和任务总量，可以比较不同阶段的效率和加速比变化，得出其变化是否是线性的。



## 线程安全问题

线程不安全的问题一共有四种：

+ 不保护共享变量的函数：显然的
+ 返回指向静态变量的函数：静态变量对于线程来说是共享的，返回指向它的函数容易导致其结果被其他调用篡改
+ 保持跨越的多个调用状态的函数：调用结果随着调用序列的变化而变化。显然，调用结果容易被多线程所扰乱。
+ 调用线程不安全的函数：就是调用以上三种不安全函数的函数！

解决方法：

+ 第一种：重写代码，加锁；
+ 第二种：重写代码，加锁；在调用和获取结果的时候，加锁（可以定义一个线程安全的包装函数，执行加锁-复制，然后通过这个包装函数来取代所有线程不安全的调用）。
+ 第三种：唯一的方式就是重写它。使他不再依赖任何static变量，只依靠参数传递的实参。
+ 第四种：那就调用线程安全的函数就行了吧

### 可重入性

一类线程安全的函数成为可重入函数。它们的特点就是调用过程中不会引用任何共享数据。那么可以说，可重入函数是线程安全函数的真子集。

![image-20200831130012789](http://static.come2rss.xyz/image-20200831130012789.png)







