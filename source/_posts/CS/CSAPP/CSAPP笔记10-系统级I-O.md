---
title: CSAPP笔记10-系统级I/O
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-31 07:29:46
tags:
---

输入输出是在主存和外部设备（磁盘驱动器、终端和网络）之间复制数据的过程。所有的语言都提供执行I/O的高级别工具，比如ASNI的C提供了Scanf和Printf。在Linux系统中，内核提供的系统级Unix I/O实现了较高级别的I/O函数。学习Unix I/O有助于我们理解系统I/O的运作原理，理清其他系统概念，甚至在不得已的情况使用Unix I/O编程。

<!-- more -->

## Unix I/O

一个Unix文件就是一个$m$字节的序列。所有的I/O设备，比如网络、磁盘和终端，都被模型化为文件，而所有的输入输出都被当做文件的读和写。这种优雅的映射方法允许Linux允许一种的统一且一致的方式执行读写。

+ 打开文件：如果应用程序要求内核打开一个文件，内核负责在打开表中修改文件条记录，从文件描述符池中选一个可用的描述符，然后返回标志该文件的非负整数文件**描述符**。内核负责记录文件的所有信息。
+ 标准文件：Linux shell创建的每个进程都有三个打开文件，分别是 标准输入、标准输出和标准错误，其描述符分别为0，1和2。在头文件<unistd.h>定义了常量：STDIN_FILNO、STDOUT_FILENO和STDERR_FILENO。它们可以用来代替文件描述符。
+ 文件位置：每个打开的文件都有内核维护的**文件位置$k$**，每次读和写一段内容都是在文件位置为起点，进行读写，并移动指针到后续部分。当**读**操作使文件位置$k>m$（m为文件长度），触发一个称为`end-of-file`的条件。应用程序可以检测到这个条件，但实际上文件并没有这个符号。
+ 关闭文件：当应用程序通知内核关闭文件的时候，内核释放文件打开时创建的数据结构，将描述符恢复到可用的描述符池中。抑或一个进程终止了，内核会关闭该进程打开的所有文件。

## 文件

每个Linux文件的都有一个类型（type）:

+ 普通文件：分为二进制文件和文本文件。文本文件是由文本行序列组成的，一行文本行以`\n`新行符（ASCII的换行符LF）结束。
+ 目录：包含了指向其他文件链接的文件。其中至少包含了两个链接，一个指向文件本身`.`，另一个指向父文件`..`。
+ 套接字：一个与其他网络主机进行网络通信的文件。

其他文件如命名通道， 符号链接以及字符和块设备。

mu [mu]







> size_t：unsigned  int
>
> ssize_t：long

## I/O API

![image-20200831084554937](http://static.come2rss.xyz/image-20200831084554937.png)

### 基操

`int open(char *filename, int flags, int mode)` 打开文件并返回描述符。`flags`参数描述了如何访问，`mode`描述了读写权限。

`ssize_t read(int fd, void *buf, size_t n)`：从文件`fd`中读取`n`个字节到`*buf`。文件读取可能因为网络通信，读到EOF或者从终端中读取而传送的字节比应用程序要求的少。这些不足值并非错误，但是不够健壮。

`ssize_t write(int fd, cons void *buf, size_t n)`从内存位置`buf`读取`n`个字节写到文件`fd`。

### 目录

`DIR *opendir(cons char *name)`：从路径`name`获取目录流的指针。流是对条目序列列表的抽象。

`struct dirent *readdir(DIR *dirp)`：返回指向dirp指向的下一个目录项的指针。

`int cloes(DIR *dirp)`：关闭目录流并释放所有资源。

### I/O重定向

`dup2(int oldfd, int newfd)`：把进程的描述符表的`oldfd`项复制到`newfd`项，并关闭`newfd`指向的内容。

### 标准I/O

C语言定义了一组高级输入输出函数，称之为标准I/O库。它将每一个打开的文件模型化一个流。对于程序员而言每一个流就是一个指向`FILE`结构的指针。

类型为`FILE`的流是对文件描述符和流缓冲区的抽象。流缓冲区作用就是把开销较高的Linux I/O系统调用的数量尽可能减少。比如标准I/O函数`getc`会在第一次调用时调用Unix I/O函数`read`读取一串字符串，之后便可以返回一个字符给应用程序。之后只要缓冲区有未使用的字符，`getc`就可以直接从缓冲区中获取。

## 打开文件数据结构

内核用三个数据结构描述打开的文件：

+ 描述符表：每个文件都有一个描述符表，表中的每个描述符都指向内核得打开文件表。
+ 打开文件表：记录着打开文件的信息，仅此一张，所有进程共享。每个表项包含了文件位置、引用计数以及一个指向`v-node`表中的对应表项指针。引用计数会因对应文件的关闭而减少，直到变为零，该文件打开项也关闭。
+ v-node表：存放关于文件本身的信息，比如文件存放位置，文件大小，访问权限等等。所有进程共享。

举几个栗子🌰：

一个进程打开两个文件：

![image-20200831083227048](http://static.come2rss.xyz/image-20200831083227048.png)

一个进程用相同的参数打开一个文件两次：

可以看到内核并不是只打开一个文件一次，而是新增了两个文件打开项（这部分内容和以前学习到内容由冲突）。如此，内核提供了两个读写位置给进程

![image-20200831083257058](http://static.come2rss.xyz/image-20200831083257058.png)

父子进程刚刚fork完：

![image-20200831083515013](http://static.come2rss.xyz/image-20200831083515013.png)



## 建议

+ 尽可能使用标准函数，除非需要的信息太低级
+ 不要用`scanf`或`rio_readlineb`读取二进制文件 。二进制文件的`0xa`字节会使文件读取失败。
+ 标准I/O用于网络读取时会出意外的错误，最后使用健壮的`rio`。