---
title: CSAPP笔记-虚拟内存
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-30 17:46:07
tags:
---

CSAPP的虚拟内存章节的前半部分主要讲述虚拟内存的实现细节和运转原理，其后半部分主要学习Linux的虚拟内存管理。
<!-- more -->

## Linux虚拟内存系统

Linux将虚拟内存分为一个个区域（area），所谓区域就是一片连续的虚拟页。Linux允许区域之间存在空隙，而空隙中的页面不被内核记录，也不占据任何空间。

![image-20200830175355795](D:\Blogfile\pic\CSAPP笔记-虚拟内存\image-20200830175355795.png)

内核为每个进程维护一个`task_struct`任务结构，任务结构包含内核运行进程所需的所有信息，比如PID，指向用户栈的指针，可执行目标文件的名字和程序计数器的值。`task_struct`中`mm`指向`mm_struct`，其中`pgd`指向第一级页表的基址，其值在进程运行时存放在页表基址寄存器中。`mmap`指向`vm_area_structs`的链表，每个单元记录了一个区域的信息。

`mm_start`. Points to the beginning of the area. 

`vm_end`. Points to the end of the area.

` vm_prot`. Describes the read/write permissions for all of the pages contained in the area. 

`vm_flags`. Describes (among other things) whether the pages in the area are shared with other processes or private to this process. 

`vm_next`. Points to the next area struct in the list.

## Linxu缺页异常管理

MMU在试图翻译某个虚拟地址A时，触发一个缺页异常，将控制转移给缺页处理程序。缺页处理程序随即遍历区域结构的链接，通过比较`vm_end`和`vm_start`来得出地址是否合法。否则触发一个段错误。继续，判断读取页是否有因为写仅读页，用户模式下读内核区域等问题导致的缺页异常，如果是爆出保护异常。否则，最后循规蹈矩的从磁盘读入所缺的页，如果物理页满了，就淘汰替换一页。缺页处理程序返回后，CPU重新启动引起缺页的程序的指令，重新读取所缺的页面。

## 内存映射

内存映射（memory mapping）：将虚拟内存区域与一个磁盘上的对象（object）关联起来，以初始化这个区域。linux可以把文件系统的普通文件和匿名文件映射到虚拟内存中。前者比较显然，后者的匿名文件是内核创建的全零文件，如果CPU引用该文件，内核就会寻找一页合适的并修改为全零页。

值得注意的是，一旦虚拟页被初始化了就会在交换区域（交换文件或者交换空间）交换，也就是说交换空间的大小限制了实际是虚拟页的总量。

### 再看共享对象

在内存映射的基础上，我们可以方便地把共享对象映射到不同进程的不同虚拟空间内，同时保持只有一份单独共享对象的副本。但是这带了一个问题：任何一个进程都无法对共享对象进行写（除非每个进程都同意），而写时复制（copy-on-write）的技术提供了解决方案。任何一个进程对共享对象的写时，把要写的部分复制到内存的另一页上，并修改映射到写的那页。如此一来，通过延迟私有对象或者共享对象的副本直到最后一刻，写时复制最充分地利用了稀有的物理内存。

![image-20200830182013430](http://static.come2rss.xyz/image-20200830182013430.png)

### 再看fork函数

父进程调用fork创建子进程时，内核为新进程创建`task_struct`数据结构，其`mm_struct`内容，页表内容和父进程一致。他将两个进程的每个页面标记为只读，并将两个进程的每个区域结构标记为私有的写时复制。也就是说当进程进行写操作的时候，写时复制机制就会创建新页面，也就为每个页面保持了私有地址的抽象概念。

### 再看execve函数

execve函数在原有进程中加载可执行文件，创建新进程。它需要以下几个步骤：

+ 删除已有的用户区域
+ 映射私有区域：为新程序的代码、数据、bss和栈区域创建新的区域结构。当然所有的区域都是私有的、写时复制的。bss区域是请求二进制零的，映射到匿名文件。栈和堆区域也是请求二进制的，长度为零。
+ 映射共享区域
+ 设置程序计数器

![image-20200830183508219](http://static.come2rss.xyz/image-20200830183508219.png)



### mmap函数也可进行用户级内存映射

## 动态内存分配

动态内存分配常见于`new`，`malloc`。其底层都是动态内存分配器维护虚拟内存中的堆，它将堆看做多个许多页组成的块（block）。块要么是已经被程序使用的已分配块，要么是处于空闲状态的块。

分配器有两种实现；

+ 显式分配器（explicit allocator）：要求显式地分配和释放任何块。比如`free`和`malloc`。
+ 隐式分配器（implicit allocator）：也称垃圾收集器（garbage collector）。它会自动检测一个分配块何时不被程序所使用并将其释放。

### 常见的C动态申请函数

`void *malloc(size_t size)`：动态申请变量。

`void *alloc(size_t size)`：基于`malloc`的瘦包装函数，将分配的内存初始化为零。

`void *sbrk(intptr_t incr)`：通过内核指针`brk`来增加`incr`来扩展和收缩堆。

> brk指示了堆的上界。不                                                                                                                                                                      

`void free(void *ptr)`：释放对应内存。



## 隐式空闲链表

大多数分配器将块的信息嵌入块中以便于区分块的边界，大小。如下图所示，一个典型的块的前4b是头部，包含了块的大小和是是否被分配的标识，之后就是负载，最后一部分是用于对齐的填充内容。

![image-20200830205453908](http://static.come2rss.xyz/image-20200830205453908.png)

隐式空闲链表就是用首部信息来确定下一个块的位置，可实现单向顺序遍历。注意，这里的链表是包含了已分配块。

![image-20200830205813562](http://static.come2rss.xyz/image-20200830205813562.png)

> 由于系统对齐要求，块的最小大小=min(首部+填充，首部+内容+填充)；填充部分要求块的大小满足对齐要求。

如何寻找空闲块也是拥有多种分配策略，比如首次适配，下一次适配和最佳适配。

## 合并空闲块

有分配空闲块可以选择把整块空闲块分配给对象，也可以根据对象的大小分配一定大的内容，将剩余的部分当做空闲块加入空间链表。释放内存后，自然会多出一块空闲块 ，这又涉及了空闲块的合并。合并可以简单的想：当空闲块出现就立即与周围临近空闲块合并。值得注意的是，追求优秀性能的动态分配器是以某种形式推迟空闲块合并的。

为了让空闲块与上一块的空闲块快速合并，提出了带脚步的块格式。这种改进虽然将编译所有块的复杂度降到了常数级的复杂度，但是增加了块的无效载荷，产生了显著的内存开销。有一种更优雅的优化方法，保持空闲块的脚步，对于已分配块，取消脚部，同时将已分配/空闲的FLAG写到低位空白位中。这样就节省了已分配的脚部开销。

## 显式空闲链表

顾名思义，显式空闲链表把对上下空闲块的地址放在块中，记为`pred`和`succ`。

![image-20200830211350701](http://static.come2rss.xyz/image-20200830211350701.png)

显然的，显式空闲链表增大了最小块的大小，也潜在的提高了内部碎片的程度。

## 分离的空闲链表

分离的空闲链表利用了分离存储的技术，同时维护多个大小一致或者差不多的空闲块链表。其中大小差不多的块分成一些等价类，也叫做大小类。

+ 简单分离存储：每个大小类的空闲链表包含着大小完全相同的空闲块。动态分配器将不分割的方式，直接把整个块分配出去，同时对释放空闲块也是直接回收空闲块。其优点在于分配和释放的常数时间操作。但是容易造成外部和内部碎片。
+ 分离适配：为了分配一个块，必须确定请求的大小类，并对适当的空闲链表做首次适配，查找一个合适的块、如果找到了一个，那么就把他分配出去，并且把剩余的块插入适当的空闲链表上……
+ 伙伴系统：属于分离适配的一个特例，每个块的体积都是2^K。每一个块可以分割为一样大的小块，这就是所谓的伙伴，显然的，这两个伙伴的距离相邻，合并操作简单。由于块的大小限制，不适合通用的任务。

## 垃圾回收

垃圾回收机制的原理在于它把内存看做一张可达图，图中存在根节点和堆节点，根节点可能是寄存器、栈或者是读写数据区域内的全局变量，总是就是不在堆中的变量。如果有有向边$p\rightarrow q$，则代表变量$p$指向变量$q$。如果有从根节点出发到某一节点$k$，那么我们称$k$是可达的。对应的不节点属于被遗忘的变量，它应该被回收。

![image-20200830233948750](http://static.come2rss.xyz/image-20200830233948750.png)

在分配的空闲块时，malloc函数如果没有拿到做够的空间，就会调用垃圾回收器，以便收集一些垃圾到空闲链表。如果空间还是不够，那就只能再申请空间给堆。

由于C++指针不会显式指出存放在内存中的变量是否是指针，那么非指针变量也可能是一个指针，所以C++的垃圾回收机制必须采取保守策略，将每个被指向被分配的在堆中的变量当做可达的！即使实际上变量可能是不可达的。

### Mark & Sweep 垃圾收集器

算法过程如下：

**Mark阶段**：遍历每一个根节点，并扫描其所指引的堆节点。扫描过程中，遍历节点的每一个字，并递归调用，尝试访问新的可行性节点。如果节点可达，那么标记一下。

**Sweep阶段**：遍历堆中每一个节点，如果没有被标记过，那么就回收掉。



### C程序中常见的与内存相关的错误

1. 引用野指针
2. 读未初始化的内存
3. 栈缓冲区溢出（局部变量数组溢出）
4. 假设指针和指向的对象大小相等
5. 数据**访问\赋值**位置溢出
6. 引用指针非而指向的对象
7. 指针运算错误
8. 函数外引用函数内的非static局部变量
9. 引用堆中释放掉的数据
10. 内存泄漏