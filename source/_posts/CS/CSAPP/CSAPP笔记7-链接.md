---
title: CSAPP笔记7：链接
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-28 13:38:40
tags:
---

链接是将各种代码和数据片段手机并组合成为一个单一文件的过程。链接方式从编译时（compile time）的静态链接，到加载时的共享库的动态链接，发展到运行时的共享库的动态链接。

> 这章的内容比较严谨，对知识的连续性要求较高。最好细细品读，尽可能理解大部分内容，这对后续学习帮助较大。

<!-- more -->

学习链接能够帮助我们：

+ 帮助理解大型软件的构建过程。
+ 避免编程中的错误。
+ 理解语言的作用域规则。
+ 理解计算机系统的诸如虚拟内存、分页、加载和运行程序的概念。
+ 帮助使用共享库。

## 编译过程

编译驱动程序，比如常见的GUN的GCC工具，调用预处理器，编译器，汇编器和连接器，将目标代码翻译成可执行二进制文件。

其翻译过程如下图，预处理器将源文件`main.c`处理成`main.i`ASCII中间文件，编译器将`mian.i`编译成ASCII汇编文件`main.s`，再由汇编器将`main.s`翻译成一个**可重定位目标文件**`main.o`。同理`sum.c`也是编译成`sum.o`。最后由连接器将两个汇编文件链接，创建出一个**可执行目标文件**`prog`。shell在执行过程中调用**加载器**的函数，将可执行文件的代码和数据复制到内存，最后把控制转移到这个程序的开头。

​	![编译过程](http://static.come2rss.xyz/image-20200829133841101.png)

## 静态链接

上述描述是一种静态链接过程，连接器将一组可重定位目标文件和命令参数作为输入，以完全链接的，可加载和运行的可执行目标文件作为输出。为了完成链接，连接器主要完成两个任务：

+ 符号解析。可重定位目标文件定义并引用符号，其符号可能是全局变量，静态变量，或者一个函数。连接器的任务就是将符号和符号引用对应起来。
+ 重定位。编译器和汇编器生成都的是从0开始的数据节和代码节。链接器通过符号定义与一个内存位置相关联，从而重定位这些节，修改所有对符号的引用，指向对应内存位置。

有趣的基础事实，目标文件包含不同的字节块，是程序代码，或者程序数据，抑或引导连接器和加载器的数据结构。链接器不了解目标机器，这部分内容由编译器和汇编器干的差不多了。

## 目标文件

目标文件有三种类型:

+ 可重定位目标文件：包含二进制代码和数据。
+ 共享目标文件：特殊的的可重定位目标文件，可在加载或者运行时被动态加载到内存并连接
+ 可执行目标文件：包含二进制代合数据，可直接被复制到内存并执行。

CSAPP以ELF目标文件格式为代表，进行叙述。

## 可重定位目标文件

ELF文件格式解析如下：

ELF header：包含了系统信息，即系统字的大小，字节顺序。剩下的内容帮助连接器分析，如ELF头大小，目标文件类型，机器类型，节头部表的偏移以及节头部表中条目的大小和数量。

Section header table（节头部表）：描述目标文件的节。

这种之间的都是节。典型节如下：

+ `.text`：编译后的机器代码。
+ `.rodata`：只读数据。
+ `.data`：已初始化的全局和静态C变量。
+ `.bss`：未初始化的全局和静态C变量，以及初始为零的全局变量和静态变量。但是此节仅仅是一个“占位符”。
+ `.symtab`：一个符号表，存放在程序中定义和引用的函数和全局变量的信息。
+ `.rel.text`：一个`.text`节（代码）中位置的列表，当把这个文件和其他目标文件相链接，需要修改。注意，可执行目标文件由于不需要重定位，所以不需要此节。
+ `.rel.data`：被模块引用或者定义的所有全局变量的重定位信息，
+ `.debug`：调试符号表，包含局部变量和类型定义，定义和引用的全局变量，以及原始C源文件。`-g`为参数调用编译驱动程序才能获得。
+ `.line`：原始C源程序中的行号和`.text`节机器指令之间的映射，同样需要`-g`。
+ `.strtab`：字符串表，其内容包括`.symtab`和`.debug`节中的符号表，以及节头部中的节名字。

![ELF文件格式](http://static.come2rss.xyz/image-20200829141748698.png)

#### 符号和符号表

> 在C中，文件代表了一个模块，`static`关键字所修饰的函数和**全局变量**表示该模块私有，其他模块无法访问。如同C++和java中的`private`。尽可能用`static`来保护你的变量和函数是很好的编程习惯。

可重定位目标模块$m$的符号表包含三种符号：

+ 由模块$m$生成的并可被其他模块所引用的全局符号，即非静态的C函数和全局变量。
+ 被其他模块定义且被模块$m$引用的全局符号，称之为外部符号。与上一种符号对称。
+ 只被模块$m$定义的和引用的局部符号。他们对应于带`static`属性的C函数和全局变量。

可以知道，连接器对于本地非静态变量（非静态本地变量）没有兴趣，这是因为这是由栈管理的！那么带有`static`修饰的**本地过程变量并**非用栈管理，而是在`.data`和`.bss`分配空间，并在符号变创建一个有唯一名字的本地连接器符号。



符号表是汇编器构造的，使用编译器输输出到汇编语言的`.s`文件的符号。`.symtab`节中包含ELF符号表，这种符号表包含一个符号条目的数组。具体内容如下：

![image-20200829150135929](http://static.come2rss.xyz/image-20200829150135929.png)

使用工具`GNU READELF`可以方便的查看目标文件内容。可以对应两张图片查看。

![image-20200829150159632](http://static.come2rss.xyz/image-20200829150159632.png)

每个符号都分配到一个节中，并用section字段以索引的形式表示。

值得注意的是，可重定位目标文件存在三个伪节（pseudo-section）。它们没有节头部表对应的条目。

+ `ABS`：存放补钙被重定位的符号。
+ `UNDEF`：未被定义的符号，也就是在本目标模块所引用但是在其他地方的符号。
+ `COMMON`：表示未被分配位置的未初始化的数据目标。

`COMMON`和`.bss`很相似，GCC以一种绝对化的方式存放符号：

+ `COMMON`：未初始化的全局变量。
+ `.bss`：未初始化的静态变量，以及初始化为0的全局或静态变量。

`.bss`和`COMMON`的存放内容非常相似，但仍有不同。编译器把弱符号放到`COMMON`中，因为可能存在其他目标文件也定义了同一个弱符号，编译器把符号连接权给连接器。对于初始化的全局变量和静态变量，他们都属于强符号，可以自信的放入`.bss`和`.data`。

## 符号解析

链接器所做的符号解析就把符号和一组输入目标文件的符号表中的一个符号定义关联起来。对于局部符号，汇编器会保证其命名的唯一。但是对于全局变量，如果编译器碰到一个在当面模块没有定义的符号（变量或者函数名），就会生成一个链接器符号表条目，并由链接器在所有输入目标文件中查找被引用符号的定义。如果没有查找到，就报错。

更复杂的情况，在于全局符号的重复定义。

> C++和java支持方法的重载，其通过链接符号的重整（mangling）来区分极其相似的函数的区别。重整也就是把唯一的方法和参数，或者类名进行编码，使之独一无二。

### 链接器解析多重定义的全局符号

编译器通过符号的强弱关系来处理多重定义的符号。函数和已初始化的全局变量是强符号，未初始化的全局变量的是弱符号。规则如下：

+ 不允许有同名的多个强符号
+ 如果有一个强符号和多个弱符号，那么选择强符号。
+ 如果有多个弱符号，那么随机选择一个弱符号。

但是规则2和规则3容易显露出一个非常难以察觉的错误：如果有两个未被初始化的同名变量被定义，尤其两个变量类型不同，那么将会可能导致变量类型被覆盖的错误。

```c
/* foo5.c */ 
#include <stdio.h> 
void f(void); 

int y = 15212; 
int x = 15213; 
int main(){
    f();
	printf("x = 0x%x y = 0x%x \n", 12 x, y); 
    return 0; 
}

/* bar5.c */ 
double x; 
void f(){
    x = -0.0;
}
```



### 与静态库连接

所有编译系统都支持一种机制——将所有的目标模块打包成一个单独文件`.a`（称为存档`archive`，有一个头部描述各个成员模块的位置和大小），称为静态库，并作为链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。静态库机制的出现不仅仅减少因为使用标准函数所带来的代码多余，而且方便迭代所引用的目标模块，再链接一次即可。

> C编译器驱动默认传递`libc.a`库文件给链接器。

典型链接过程：

![image-20200829165319573](http://static.come2rss.xyz/image-20200829165319573.png)

```shell
#创建静态库
linux> gcc -c addvec.c multvec.c 
linux> ar rcs libvector.a addvec.o multvec.o

#编译链接
linux> gcc -c main2.c 
linux> gcc -static -o prog2c main2.o -L. -lvector #-static 静态编译
#or equivalently
linux> gcc -static -o prog2c main2.o ./libvector.a    
```

### 链接器用静态库来解析引用

解析静态库的算法概括一下就是：从左到右遍历一次所有文件；对于可重定位目标文件，记录下符号引用，并解析记录下的符号引用；对于静态库，单单只是解析符号引用。

所以如果一个包含了符号定义的文件排在引用其符号的文件之前，链接器无法对这个符号进行解析，导致直接报错。一般关于库的准则是将他们放在命令行的结尾。当然也可重复写库名来应对多个文件循环调用的情况。

## 重定位

一旦链接器完成了符号连接过程，接下来就是重定位：

+ 重定位节和符号定义：把相同类型的节聚合在一起，由此可以计算出所有聚合节的地址。然后，链接器将运行时内存地址赋给聚合节以及输出模块定义的每个符号。这样每个指令和全局变量都有唯一的内存地址了。
+ 重定位节中的符号引用：链接器修改代码节和数据节对每个符号的引用，使其指向正确的运行时地址。

重定位节和符号定义给出所有节和符号定义的运行时地址，这就给了重定位节的符号引用带来了方便。符号引用有两种方式一种是重定位PC相对引用，另一种是重定位绝对引用。第一种很熟悉，譬如JUMP或者RET等常用的跳转函数提供的控制流，其计算过程需要考虑下一条指令地址的值。第二种更简单，直接加就ok。

重定位完成后，就生成了可执行目标文件的`.data`和`.text`节。加载器可以直接把这些节复制到内存中，不再进行任何修改的执行这些指令。



## 可执行二进制文件

二进制组成的可执行二进制文件类似于目标文件格式。略有不同的是，增加了一个带有初始化功能的`_init()`函数的`.init`，同时也不需要`.rel`节。

### 加载过程

![image-20200829211920212](http://static.come2rss.xyz/image-20200829211920212.png)



### 程序加载的内存映像

>  首先，什么叫做内存映像呢？ 进程的内存映像，指的是内核在内存中如何存放可执行程序文件。注意了，这里的可执行程序文件和内存映像是有区别的，具体是：
>   1) 可执行程序是位于硬盘上的，而内存映像位于内存上；
>   2) 可执行程序没有堆栈，因为只有当程序被加载到内存上的时候才会分配相应的堆栈
>   3) 可执行程序是静态的，因为它还没运行，但是内存映像是动态的，数据是随着运行过程改变的；

![image-20200829212452732](http://static.come2rss.xyz/image-20200829212452732.png)

注意，由于`.data`有对齐要求，所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆栈运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR），所以每次程序运行的这些区域地址都会变化。

## 加载时动态链接

上节中静态库具有明显的两个缺点：无法快速更新静态库，必须显式地重新链接；多个程序使用同一份静态库的代码会导致内存的极大浪费。共享库（shared library）致力于解决这两个问题。共享库是也称共享目标，程序在运行或加载时可以加载到任意的内存地址，与其他不同的程序链接起来。这个过程称为动态链接（dynamic linking）。

> linux常用`.so`作为动态目标文件后缀，微软操作系统称之为DLL（动态链接库）。

链接过程如下：

+ 链接过程中，仅仅执行一些链接，复制一些共享库的重定位和符号表信息，使之能在运行时解析对共享库的代码和数据的引用。
+ 加载器加载程序到内存中，找到动态链接的节，加载和运行动态链接器。
+ 动态链接器重定位共性库的文本和数据到某个内存中；然后重定位程序中对共享库的程序和数据的符号引用。（修改了目标文件的代码，算不上位置无关代码）

### 动态链接命令：

```shell
#生成动态库
linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c #-fpic 指示编译器产生位置无关代码 -shared指示链接器创建一个共享的目标文件
#编译
linux> gcc -o prog2l main2.c ./libvector.so
```

## 运行时动态链接

这种技术支持了应用无需在编译和链接是将库链接到应用中，是一项非常强大的技术。比如，分发共享库的新版本来更新软件；Web服务器通过生成动态内容的共享库，并将其存储在内存中，达到快速调用的目的，而无需生成一个线程或者进程，减少了开销，提高了性能。更进一步的说，无需停止服务器，而可以更新已经存在的函数，以及添加新的函数！

栗子：Linux提供了动态链接库的简单接口`dlopne`，`dlerror`，`dlclose`和`dlsym`。

![image-20200829223616309](http://static.come2rss.xyz/image-20200829223616309.png)



## 位置无关代码

可以加载但是无需重定位的代码叫做位置无关代码，GCC使用`-fpic`选项指示GNU编译系统生成PIC代码。

同一个共享库中的全局变量和函数调用的容易解决，即通过统一模块中引用和定义相对位置不变的特性构造一个GOT（Global Offset Table，全局偏移量表）。GOT属于调用模块的数据段内容，其记录了每个全局数据目标（过程或者全局变量）都有一个重定位记录。加载时，动态链接器会重定位GOT的每个条目，使其包含正确的绝对地址。在访问引用时，利用数据段和代码段相对位置不变的特性可以计算出对应条目和调用指令的下一条指令的距离，并用PC相对跳转给出GOT条目地址，这部分由链接器构造共享库时完成。

![image-20200830094830284](http://static.come2rss.xyz/image-20200830094830284.png)

   那么，对于调用模块引用共享库的符号定义时，上述解决方法便失效了。这时我们引入延迟绑定的概念——将过程地址的绑定推迟到第一次调用该过程（理论上，当然可以一次绑定完所有的引用，但是这种方法避免了动态绑定器在第一次调用时消耗大量时间）。我们在调用模块中加入数据段的GOT，代码段的PIT（Procedure Linkage table）。GOT保存着动态链接器和其他函数的绝对化地址（动态链接器链接完成以后），PIT保存着调用动态链接器代码，调用共享库模块所需要的“初始化”代码。PIT和GOT联动的算法还是比较巧妙的，先尝试调用引用地址，没有初始化就压参数调用动态链接器，再初始化参数，最后把控制权返回给原来模块再调用一次共享库引用。

![image-20200830100908262](http://static.come2rss.xyz/image-20200830100908262.png)

## 库打桩机制

库打桩技术就是把调用函数替换成其他函数，一般用包装函数来代替原来的函数，用于追踪数据，记录调用情况，甚至直接替换成另一个实现。有三种不同的打桩机制：

### 编译时打桩

拥有源代码，保证不修改源代码的情况下，最好添加一个`#define func() myfunc()`和函数声明的源文件，一个函数定义的`.h`文件。在编译选项中添加`-I`参数进行打桩，告诉C预处理器先在本地目录寻找`malloc.h`。

```shell
linux> gcc -DCOMPILETIME -c mymalloc.c
linux> gcc -I. -o intc int.c mymalloc.o 
```

![image-20200830103614496](http://static.come2rss.xyz/image-20200830103614496.png)

### 链接时打桩

Linux静态编译器支持在链接过程中`--wrap f`标志来打桩，链接器会把`f`解析成`__wrap_f`，把`__real_f`解析成`f`。

```shell
linux> gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o
# -Wl 把`,--wrap,malloc`替换成` --wrap malloc`传递给静态链接器
```

那么只要编写一个wrap和free字符包装过的函数声明和定义就Ok了。而且仅仅只需要可重定位目标文件就行了！

![image-20200830104355735](http://static.come2rss.xyz/image-20200830104355735.png)

### 运行时打桩

如果程序使用的共享库的函数是我们想要打桩的，直接修改动态链接器的`LD_PRELOAD`环境变量为当前打桩的所替换的共享库路径即可。动态链接器会先去那个路径寻找共享库，从而自动替换打桩函数。但是需要创建共享库，而且被替换函数之前得是共享库函数。

```shell
#创建共享库
linux> gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl
#编译
linux> gcc -o intr int.c
#修改环境变量
linux> LD_PRELOAD="./mymalloc.so" ./intr
```



## 工具小结

`ar`. Creates static libraries, and inserts, deletes, lists, and extracts members. 

`strings`. Lists all of the printable strings contained in an object ﬁle. 

`strip`. Deletes symbol table information from an object ﬁle. 

`nm`. Lists the symbols deﬁned in the symbol table of an object ﬁle. 

`size`. Lists the names and sizes of the sections in an object ﬁle. 

`readelf`. Displays the complete structure of an object ﬁle, including all of the information encoded in the ELF header. Subsumes the functionality of size and nm. 

`objdump`. The mother of all binary tools. Can display all of the information in an object ﬁle. Its most useful function is disassembling the binary instructions in the .text section.
Linux systems also provide the `ldd` program for manipulating shared libraries:
`ldd`: Lists the shared libraries that an executable needs at run time.