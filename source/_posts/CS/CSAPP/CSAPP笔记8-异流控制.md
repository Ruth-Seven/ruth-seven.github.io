---
title: CSAPP笔记8-异常控制流
thumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'
toc: true
top: 10
categories:
date: 2020-08-27 16:51:05
tags:
---

这章的内容很精彩！解答了很多关于进程和信号量的知识。（但是内容太多了！简略的记一下）
<!-- more -->

面对系统和程序中的突变，也称之为异常控制量（Exceptional Control FLow, ECF）。异常控制流发生在机器的各个层面上。比如，在硬件层面上，硬件检测到的突发事件会把控制权转移给异常处理程序；在操作系统层面上，内核通过上下文内容切换将控制权从一个进程转移到另一个进程中；在应用层上，一个进程可以发送一个信号给另一个进程，而接受者会将控制权突然转移给它的一个信号处理程序。一个程序可以回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。

理解ECF的重要性非常大，它有助于我们理解系统如何和应用程序交互，理解重要的系统程序，理解并发，进而帮助我们编写有趣的系统程序，认识到软件异常如何工作。

## 异常

异常（exception）是ECF的一种形式，其实现一半由硬件实现，一半由软件实现。

异常的基本的思想就是当处理器检测到事件（events）发生时，异常是当处理器检测有事发生时，通过异常号作为索引查找一张异常表的表项——异常处理程序地址，进行间接过程调用（异常），即调用对应的操作系统子程序——异常处理程序（exception handler）。



![异常表](http://static.come2rss.xyz/image-20200827165745681.png)

其中异常表基址寄存器（exception table base register）保存着异常表的基址。异常表的内容和异常表基址寄存器都由操作系统重启或加电后初始化。

![image-20200831135831569](http://static.come2rss.xyz/image-20200831135831569.png)

而事件的发生可能和当前指令有关，也可能有当前指令无关，比如发生缺页或者除零，又比如计时器产生一个时间中断信号。

异常处理结束后，一般有三种情况：

+ 将控制权给当前指令
+ 将控制权给当前指令的下一条指令
+ 将当前进程终止

异常类似于过程调用，但有几点不同：

| 不同点                                       | 过程调用       | 异常                                               |
| -------------------------------------------- | -------------- | -------------------------------------------------- |
| 返回地址                                     | 下一条         | 下一条或者正在执行的那条，或者直接终止程序         |
| 多压入包含条件码的<br />EFLAGS寄存和其他内容 | 不会           | 会                                                 |
| 压入栈                                       | 保存在用户栈中 | 如果控制权从用户程序到内核，则压入所有内容到内核栈 |
| 权限                                         | 运行在用户模式 | 运行在内核模式，对资源有完全的访问权限             |
|                                              |                |                                                    |



### 异常的类型

中断，故障，陷阱和终止。下图做了小结：

![image-20200831140810963](http://static.come2rss.xyz/image-20200831140810963.png)

#### 中断

中断是来自指令外部的事件引起的，与当前指令无关，可以说 是异步的，其他它三个指令都是同步的。CPU在当前指令完成后检测到中断位电压升高，并在系统总线上受到异常号，就触发了中断。硬件触发中断的异常处理程序常常称为中断处理程序（interrupt handler）。

![image-20200831141347277](http://static.come2rss.xyz/image-20200831141347277.png)

中断处理程序被调用后，将原有的现场恢复，将控制权转移给下一条指令$I_{next}$。好像一切都没有发生！

#### 陷阱和系统调用

陷阱（trap）是有意的异常，是执行一条指令（比如 `syscall n`）的结果。陷阱最重要的用途是在用户程序和内核之间提供一个像过程样的接口，叫做系统调用。陷阱让处于用户模式的程序可以调用内核模式的程序，并有权访问内核模式的栈。

#### 故障

故障是由错误情况引起的，可能能够被错误处理程序所修复。当故障发生时，处理器将控制转交给故障处理程序。如果故障被修复，那么就返回到引起故障的那条指令，相反的，如果故障没有被修复，就犯规到内核中的`abort`例程，`abort`例程将会终止引起故障的应用程序。

#### 终止

终止是不可恢复的致命错误引起的结果，通常是一些硬件错误，比如SRAM或者DRAM位被损坏时发生的奇偶错误。同样的，终止处理程序会把控制转移给`abort`例程，该例程会终止应用程序。

## Linux/x86_64异常

常见的Linux系统异常和对应信息：

![image-20200831143619319](http://static.come2rss.xyz/image-20200831143619319.png)

14号是缺页故障。

C程序提供一串包装了可以调用任何系统调用的`syscall`函数的高级函数。我们称一系列系统调用和包装他们的函数称之为系统级函数。注意，所有到Linux系统调用的函数都是通过通用寄存而不是栈来传递参数的（本身调用时最多用6个参数，寄存器刚刚好放得下）。

![image-20200831143544867](http://static.come2rss.xyz/image-20200831143544867.png)

## 错误处理

Unix系统级函数遇到错误时，通常会返回-1，设置全局变量`errno`带来表示出现了什么错误。但是检测错误带来的代码臃肿真是逼死强迫症，作者提供一种的错误处理包装函数的优雅写法。

```c
pid_t Fork(void) //让FOrk的调用减少到了一行
{
    pid_t pid;
    if((pid fork() < 0)
       unix_error("Fork error");
    return pid;
}
void unix_error(char *msg)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(errno));
    exit(0);
}
```



## 进程

进程的经典定义就是一个执行中程序的实例。我们把程序执行的指令的PC序列称为逻辑控制流，也称逻辑流。对于每一个进程而言，它一直在执行，从来没有中断过，一直独占使用处理器。这归功于CPU提供的独立的逻辑控制流。但是从CPU 的角度讲，多个并发的逻辑控制流组成了并发流。一个进程和其他进程轮流执行的概念叫多任务，也称时间分片。显然的，并行流是并发流的真子集。

系统给每个进程都提供了独立的私有地址空间，这得力于虚拟内存的强大功能。它使得每一个程序都有一致结构的地址空间，好像独自使用整个系统存储空间。

操作系统提供了独立的地址空间和可以执行的指令，这是进程抽象的必须条件。为了控制指令的安全性和权限，系统设了运行模式——**用户模式和内核模式**。CPU的一个模式位若为1则当前为内核模式，反之则为用户模式。用户模式限制了指令的读写权限，特权指令无法被使用。

> linux 提供了用户模式访问内核模式的一种途径：`/proc文件系统`——其中记录了内核数据结构的内容，比如进程和CPU的信息，`/sys文件系统`：系统总线和设备的底层信息

操作系统为每个进程维护了**上下文**来保持各个进程的状态，而上下文的切换就是较高形式的异常控制流。上下文是内核需要重新启动一个进程所需要的状态，它通常包括通用目的寄存器，浮点寄存器，程序技术器，用户栈，状态寄存器，内核栈和**各种数据结构**，比如页表、进程表和文件表。

### 并发

并发就是指两个进程交错运行（必有一个进程被中断至少一次）。

### 子进程

`fork()`出来的子进程与父进程完全相同，包括代码，数据，变量，寄存内容，打开的文件标识符等等，但是注意，虽然相同却不是同一份。`fork()`有一个神奇的特性，一次运行，两次返回，即返回给子进程零，返回给父进程子进程的PID。父子进程除了地址空间、数据代码，栈和堆空间相同外，其共享文件分享的是同一份共享文件，比如共享库，当然打开文件表也是复制，继承了下来。

一个子进程因某种原因终止时，它被保持在一种已终止的状态，直到被他的父进程所回收。当子进程终止时，内核发出子进程终止的信号给父进程（默认行为是忽略，可以编写函数处理）。当父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后抛弃掉已终止的进程。至此进程就消失了。一个终止但是没有被回收的进程称为僵死进程。

如果父进程终止了，内核会安排`init`来成为子进程的养父。`init`是所有进程的祖先，PID为1，它不会终止。



`execve()`是用新的程序在**当前进程的上下文中**加载并运行一个新的进程，也就是说原来的进程程序已经没了，`exceve()`不返回。同时新进程**继承了原来程序的PID**，地址空间，文件描述符。

#### 进程命令

```c
#等待进程结束 P518
pid_t waitpid(pid_t pid, int *statusp, int options)
pid_t wait(*statusp)
   
#休眠
sleep(unsigned int secs)
    #返回0或者被信号中断而返回时还需要的休眠的时间                                                                                                                             
    
```

#### 加载并运行程序

一个典型的程序运行开始的创建的用户栈。从高往低看，首先是环境变量字符串和命令行字符串，之后是指向环境变量的指针数组和指向命令行变量的指针数组。之后是`libc_start_main`系统启动函数的栈帧，该函数负责初始化和调用`main`函数。最后是未来即将创建的`main`函数的栈帧。

> main的三个参数：
>
> + argc: argv[]数组的非空指针的数量
> + argv: argv[]数组的第一个条目
> + envp：指向envp[]数组的第一个条目

![image-20200906110615766](http://static.come2rss.xyz/image-20200906110615766.png)

常见函数

```c
char *getenv(const char *names);
int setenv(const char *name, const char *newvalue, intoverwrite);
void unsetenv(const char *name);
```



## 信号

 信号就是一条小消息，通知进程系统中发生了某种事件。信号可由进程kill发出，或者系统内核检测到了某个事件而发出。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户程序不可见。程序出现出了某种异常或者事件，内核就会发一条信号给程序或者可能是父进程。



![image-20200906111627434](http://static.come2rss.xyz/image-20200906111627434.png)

> dump core:把代码和数据的映像写到磁盘上。过程的主存用core memory（磁芯存储器）实现。

### 信号的发送，接受和处理

内核通过**更新上下文的某个状态**来发送信号。内核发送信号可能是讷河检测到一个系统信息，或者`kill`函数显示的要求内核发送信号。

按信号值小为优秀，查看未被阻塞的待处理信号的集合（`pending & ~blocked`）进程接收到信号后，可以选择忽略，或者终止，又或者调用信号处理程序（signal handler）的用户层函数来捕获这个信号。

> 可以通过`singal()`修改信号相关联的行为。

![image-20200906131815397](http://static.come2rss.xyz/image-20200906131815397.png)

没有被处理的信息称之为待处理信号。内核为每个向量维护了一个`pending`向量来保存每一个待处理信号的集合。只要传递了信号，对应`pending`位就被设置，只要接受了一个第$k$位的信号，`pending`就会清除`pending`向量的第$k$位。

信号可以被堵塞，被堵塞的信号可以发送，但是产生的待处理信号无法被接受，直到取消对这种信号的阻塞。`blocked`位向量维护者被堵塞的信号的集合。

每个信号只会被接受一次，每个位只能接受一次对应信号，也就是说多余的信号无法被检测出来。

> 不要尝试用信号来计数……因为这并不准确。

### 信号编程

> Waiting for my laziness. 这部分不错的，以后再总结吧