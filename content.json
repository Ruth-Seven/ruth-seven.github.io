{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"about","text":"这里是Ove的小小笔记本。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index-1.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"contact","text":"","link":"/contact/index.html"},{"title":"friend","text":"","link":"/friend/index.html"},{"title":"tags","text":"","link":"/tags/index-1.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"有趣的题目","text":"记录一下写到的好玩的题目： 题目 类型 打分 1289.Minimum Falling Path Sum2 dp 4 790. Domino and Tromino Tiling dp 6 1286. Iterator for Combination 全组合 5 142. Linked List Cycle II twopoints 6 76. Minimum Window Substring towpoints 7 680. Valid Palindrome II twopinnts，贪心 4 69. Sqrt(x) 二分，牛顿迭代 3 81. Search in Rotated Sorted Array II 二分 6 154. Find Minimum in Rotated Sorted Array II 二分 7 75. Sort Colors threepoints 3 51. N-Queens 回溯 4 417. Pacific Atlantic Water Flow dfs 6 126. Word Ladder II tbfs 8 47. Permutations II 回溯 6 40. Combination Sum II 回溯 5 310. Minimum Height Trees 拓扑；dfs 6 300. Longest Increasing Subsequence dp；贪心 6 474. Ones and Zeroes dp；多维01背包 6 322. Coin Change dp;完全背包 6 650. 2 Keys Keyboard dp;数学 5 10. Regular Expression Matching dp` 8 123. Best Time to Buy and Sell Stock III dp 5 188. Best Time to Buy and Sell Stock IV dp 8 53. Maximum Subarray 好题目 注意递归解法 线段树；dp 8 241. 为运算表达式设计优先级 dp; 分支 4 932. Beautiful Array 分治 7 168. Excel Sheet Column Title 数学 7 462. Minimum Moves to Equal Array Elements II 数学；第K大 7 260. Single Number III 位运算 8 218. The Skyline Problem 扫描线 9 149. Max Points on a Line 哈希表 6 332. Reconstruct Itinerary 图论；欧拉图 7 146. LRU Cache LRU实习 8 882. Reachable Nodes In Subdivided Graph 最短路 8 109. Convert Sorted List to Binary Search Tree AVL重构 7 错排问题-年会抽奖 概率论 10 331. Verify Preorder Serialization of a Binary Tree 二叉树 7 148. Sort List 链表 8 面试题 04.09. BST Sequences LCCI 二叉树 7 42. Trapping Rain Water 单调栈 8 312. Burst Balloons dp；启发式 9 847. 访问所有节点的最短路径 旅行商 8 POJ 2117 Electricity 割点 7 面试题 17.24. 最大子矩阵 dp 7 最大值减去最小值小于或等于num的子数组数量 双头队列单调栈 8 由于某种不知名力量，Post not found: 1289-Minimum-Falling-Path-Sum2之类的站内链接没法生效，直接 使用写完的文章标题作为搜索凭据八。","link":"/2020/09/23/shua-ti/you-qu-de-ti-mu/"},{"title":"优秀是会遗传的吧？","text":"G姐妈妈访谈录听到G姐麻麻和G姐的访谈，非常非常震惊。G姐家庭环境非常好，爸爸是富二代，妈妈美国名校硕士，哈佛博士后。妈妈比较开明，理性，对家庭和孩子都是采取鼓励式教育。我最欣赏的是G妈身上那股专注投身于命运的专注，那种全身心的投入目标中去，抗争所能争取的，从不疲劳不抱怨的状态和心境。同时也为她这种看透人世的智慧，巧妙的与人相处的气质所膜拜。 哈哈，但愿我也能找到这么一个优秀的女孩子。可以看看胸大有脑用心做视频的G姐。","link":"/2020/11/25/sui-tan/you-xiu-shi-hui-yi-chuan-de-ba/"},{"title":"大数据产品思考——地球保卫者","text":"地球守护者就课堂作业扯扯淡 原谅我的文不对题 大数据之所以大，是得利于现代化数字化生活的在全国全球范围的快速普及和发展，其中数据的起源来源于大众生活中重复的需求和行为。比如美团控制了外卖，点餐的信息渠道，支付宝和微信支付把持了人民支付行为的巨大入口。现有的模式（我观察到的）就有：平台推出新模式改变用户行为，压缩传统市场占有空间，由此在平台上收集用户大数据，并用大数据进行决策优化以提升营收。比如Keep让用户接受了记录运动生活，进而尝试付费解锁运动健康知识，而掌握了大量人群的运动数据可以帮助keep分析用户，但真正的需求还是运动。 这个案例是大数据附加在产品平台上的属性，我在思考真正能够用大数据驱动需求产品到底有什么？也许有大数据监控道路，监控生态，智能城市管理之类的需求（这些都用人做了）。我想可能用大数据监控太阳系突入起来的小行星防止撞击地球是一个好主意！没错 真正的困难不仅仅在于如何构象出一款大数据产品，而是如何获取到用户（或政府一抑或公司，看你们做哪个端）的数据。政府的数据因为保密、安全、设备老旧和人脉不通而无法获取，大公司数据就更难了，你都有了为啥自己不做一个（腾讯：偷袭！我69岁的老数据）。到底是为了做大数据产品去构象一款产品呢，还是依据需求去做一个产品，如果能用大数据就用大数据，孰优孰劣。 如果用大数据平台技术优势作为优势点，我…… 上衣面对年轻人多元化，多潮流的服装需求，一个快速推荐、指出潮流指数，表现个人欲望的平台呼之欲出。你可以在平台po出你的着装，平台会自动记录识别用户的服装种类，购买平台。平台会对用户进行用户画像，尝试进行用户推荐相似的风格的衣服和用户。在大数据加持下，用户可以在平台上查看当天当月当季的流行指数，欣赏最火的衣服推荐，从平台推送中做出更加适合自己的，省心的选择。在更加高级的人性化定制，大数据起到了更多的作用：个人风格设计、365天不重样个人着装设计…… 总之这是一个结合用户社交个性化展示，用户衣服选购，用户衣服流行趋势展示的选衣平台。 这个需求很真，我就想要。 痛点：种子用户难获取 痒点：可以名正言顺的发自拍 爽点：让懒鬼随便选择衣服，让个性化高的用户有展示空间，获取认同和名气 市场规模：全国全球 种子用户：这是一个边际获客成本很低的平台。种子用户建议在大学高校中大规模推广，他们是需求最大的群体。 利润来源：衣服推荐商的佣金以及高度自定义话的衣物界相关金主广告植入，做成一个免费的平台是互联网常态吧。","link":"/2020/11/28/sui-tan/da-shu-ju-chan-pin-si-kao-di-qiu-bao-wei-zhe/"},{"title":"Attention mechanism","text":"Attention mechanism 阅读 《A survey on Natural Language Processing (NLP) &amp; applications in insurance》的论文中的The Attention Mechanism部分所做的笔记。 Attention机制提出的目的就是为了把在句子里的不同词语附上不同的权重，类比与人类观察物体时会给不同的物体分配不同的时长和注意力。 以最经典的scaled DOt-Product Attention 和 Multi-Head Attention 为例： 单头Attention是多头Attention的组合部分，先讲单头。 QKV是三个输入X变换的向量，分别定义为“query”，“key”和“value”。 最后经过$W^0 \\in \\R^{d_V \\times p}$仿射变化，得到 其中整个过程用到了4个系数矩阵$W^Q \\in \\R^{p \\times d_q}$，$W^K \\in \\R^{p \\times d_k}$, $W^V \\in \\R^{p \\times d_v}$和$W^0 \\in \\R^{d_V \\times p}$ 其中，$d_v = d_k = d_q$ 理解Scaled Dot-Product Attention部分，多头的部分就简单了。多头就是把同一组输入喂给多组同结构的单头Attention，然后把多组$Attention(Q,V,K)$concatenate起来,最后进行仿射变换。 有公式：$$z_i = Attention(Q_i, k_i, V_i) \\in \\R^{n \\times d_v} \\C = Concat(Z_i) \\in \\R ^{n \\times (d_v * h)}\\Z = CW^0 \\in \\R^{n * p}$$ 注意一下， 两者的Z和QVK意义基本相同。 最后在文章的最后说明一下多头Attention的意义：多个相同结构的机制组合一起，更多是通过多组参数来降低注意力集中在不该集中的地方的概率。以此提高模型的鲁棒性。","link":"/2021/01/15/ai/dl/attention-mechanism/"},{"title":"Bag Of Words (BoW) and TF-IDF","text":"Bag Of Words (BoW) and TF-IDF 阅读 《A survey on Natural Language Processing (NLP) &amp; applications in insurance》的论文中的The Attention Mechanism部分所做的笔记。 Bag of words词袋模型就是简单的对每个句子进行字频统计。但是有明显的缺点：1. 没有词序信息。2. 字典太大的话，每个句子的向量会过大。 Term Frequency-Inverse Document Frequency (Tf-Idf)是词袋的优化方法。他在词频统计的基础上， 用公式：$$tf(w,d) = \\frac {\\text{number of times the word w appears in d}}{\\text{total number of words in d}}\\idf(w,d) = log\\frac{len(d)}{df(w)}\\tf-idf = tf(w,d) * idf(w,d)$$其中$tf(w,d)中$$d$是the d set of sentence，$w$是word。$idf(w,d)$中$df(w)$包含$w$的句子数量，$len(d)$是句子的总数量。 例子： 那么我们就可以理解到， $idf(w,d)$就是就是强调词$w$的稀缺性，值越大说明越稀缺，这个词也就越重要。","link":"/2021/01/15/ai/dl/bag-of-words-bow-and-tf-idf/"},{"title":"DeepLearning 读书笔记","text":"DeepLearning读书笔记（1）数学符号英语名词: Identity matrix：单位矩阵 Moore–Penrose pseudo inverse：摩尔－彭若斯广义逆 Determinant：行列式 Partial derivative ：偏微分 Gradient ：梯度 Definate integral：定积分 Variance：方差 Covariance：协方差 Shannon entropy：香农熵 Kullback-Leibler divergence：KL散度 Composition of the funcitions：函数的组合 parametrize：参数化 softplus： 公式如下 log(1+ex)log(1+ex) The empirical distribution：经验分布（往往有训练集定义的） 疑惑处： (P14) jocabian matrix 和 The Hessian matrix. 绪论人类作为的地球上最智能的灵长类动物，可以高效地处理许多非形式化任务——难以用数学公式描述的问题，而计算机与人类正好相反，擅长处于规则化问题。AI(artificial intelligence)拥有从数据或者世界中学习模式的能力，这称之为machine learning。 简单模型的学习能力极大的依赖于数据特征。对于复杂的特征工作，表示学习 （representation learning）可以从复杂的数据中学习到远远优于人类所做出的的特征表示，仅需要稍稍的人工干预。表示学习一个典型代表就是自动编码器（autoencoder）。学习特征或者设计特征的算法的目的就是为了分离出factors of variation——影响事物变化的因素，比如识别车任务中的车轮，识别语音中的讲话人的年龄、性别。 2021年1月15日 11:56:35 更新：这种书，做笔记是不可能的，写写书上更高效。","link":"/2020/08/07/ai/dl/deeplearning-du-shu-bi-ji/"},{"title":"LCA问题","text":"LCA问题即最近公共祖先问题 常见解法有递归法，向上","link":"/2020/08/07/cs/algorithms/lca-wen-ti/"},{"title":"中缀式计算","text":"中缀表示式计算分为两个步骤，一是中缀转后缀，二是后缀表达式计算； #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; using namespace std; stack&lt;char&gt; stop; // 符号栈 map&lt;char, int&gt; opp; // 运算符 映射到优先级 the priority of operators stack&lt;double&gt; stn;// 数字栈 string mid2Post(string s){ string res; for(int i = 0; i &lt; s.size(); i++){ if(isdigit(s[i]) || s[i] == '.') res += s[i]; else{ if(s[i] == ' ') continue; //去空格 if(s[i] == '(') stop.push(s[i]); else if(s[i] == ')'){ while(stop.top() != '('){ res += stop.top(); stop.pop(); } stop.pop(); }else{ int pro = opp[s[i]]; //为运算符两旁数字插入空格,否则无法区分数字 res += ' '; //pop出运算优先级高的运算操作符 while( !stop.empty() &amp;&amp; pro &lt;= opp[stop.top()]){ //注意这里stack要有数据, res += stop.top(); stop.pop(); } stop.push(s[i]); } } } while(!stop.empty()){ res += stop.top(); stop.pop(); } return res; } // 获取正数（可有小数点） double getNum(string &amp;str, int &amp;pos){ int k = pos, flag = 1;// flag = 1表计算正整数 double inter = 0, fac = 0, pow10 = 10; while(isdigit(str[k]) || str[k] == '.'){ if( str[k] == '.') flag = 0; else if(flag == 1){ //计算正整数 inter = inter * 10 + (double)(str[k] - '0'); //地址？ }else{ // 计算小数 fac += (double)(str[k]-'0') / pow10; pow10 *= 10; } k++; if(k &gt;= str.size() ) break; } pos = k; return inter + fac; } //计算后缀表达式的值 double calPost(string pStr){ if(pStr.size() == 0) return 0; for(int i = 0; i &lt; pStr.size(); i++){ if(isdigit(pStr[i])){ //对于数字 double t = getNum(pStr, i); i--; //多加了一次i printf(&quot;%f\\n&quot;, t); stn.push(t); }else if(pStr[i] == '+' || pStr[i] == '-' || pStr[i] == '*' || pStr[i] == '/') { // 对于运算符（不包括小数，理论上规范的格式中应该被数据包裹着） double op2 = stn.top(); stn.pop(); //注意压栈后 数据顺序是反的 double op1 = stn.top(); stn.pop(); if(pStr[i] == '+') stn.push(op1 + op2); else if(pStr[i] == '-') stn.push(op1 - op2); else if(pStr[i] == '*') stn.push(op1 * op2); else if(pStr[i] == '/') stn.push(op1 / op2); //不做非零判断了 } } if( stn.size() != 1){ printf(&quot;error! the size of stck of num isn't 1.\\n&quot;); return -1; } return stn.top(); } int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); string str; getline(cin, str); cout &lt;&lt; str &lt;&lt; endl; opp['+'] = opp['-'] = 1; opp['/'] = opp['*'] = 2; opp['('] = 0; //'(' 特殊处理 string pStr = mid2Post(str); cout &lt;&lt; pStr &lt;&lt; endl; double calRes = calPost(pStr); printf(&quot;%.2lf\\n&quot;, calRes); } 细节上也可以再改动，比如在识别数字的时候就把它提取出来并用结构体的形式存储下来。","link":"/2020/08/07/cs/algorithms/zhong-zhui-shi-ji-suan/"},{"title":"关键路径","text":"​ ``` #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;stack&gt; using namespace std; const int mss = 1e3 + 100; const int INF = 0x3fffffff; int edge[mss][mss], n, m; int ve[mss], vl[mss], e[mss][mss], l[mss][mss]; int ingree[mss], maxtime; stack&lt;int&gt; stk; vector&lt;int&gt; activity[mss], tempp; int topu(){ queue&lt;int&gt; que; for(int i = 1;i &lt;= n;i++) if(ingree[i] == 0) que.push(i); while(que.size()){ int u = que.front(); que.pop(); stk.push(u); for(int i = 1; i &lt;= n;i++){ if(edge[u][i] != INF){ ingree[i] --; if(ingree[i] == 0) que.push(i); ve[i] = max(ve[i], ve[u] + edge[u][i]);// 拓扑排序兵同时计算 每个节点的最早开始时间 // cout &lt;&lt; ve[u] &lt;&lt; endl; } } } if(stk.size() == n) return true; else return false; } int critical_path(){ //初始化汇点 int maxv = 0; for(int i = 1;i &lt;= n; i++) if( maxv &lt; ve[i]) maxv = ve[i]; for(int i = 1;i &lt;= n; i++) vl[i] = maxv; maxtime = maxv; //逆拓扑排序地计算每个节点的最晚开始时间 while(stk.size()){ int u = stk.top(); stk.pop(); for(int i = 1;i &lt;= n;i++){ if(edge[u][i] != INF) vl[u] = min( vl[u], vl[i] - edge[u][i]); } } // 查找关键路径 for(int i = 1;i &lt;= n;i ++){ for(int j = 1;j &lt;= n;j ++){ if(edge[i][j] != INF){ e[i][j] = ve[i]; l[i][j] = vl[j] - edge[i][j]; if(e[i][j] == l[i][j]){//插入path 以便查询所关键路径 activity[i].push_back(j); } } } } //排序以保证按序输出 for(int i = 0;i &lt;= n; i++){ sort(activity[i].begin(), activity[i].end()); } } int dfs(int u){//输出所有关键路径 tempp.push_back(u); // cout &lt;&lt; u &lt;&lt; endl; if(activity[u].size() == 0){ for(int i =0 ;i &lt; tempp.size() ;i++){ cout &lt;&lt; tempp[i]; if(i + 1 != tempp.size()) cout &lt;&lt; &quot;-&gt;&quot;; else cout &lt;&lt; &quot;\\n&quot;; } }else { for(int i = 0;i &lt; activity[u].size(); i++) dfs( activity[u][i]); } tempp.pop_back(); } int main(){ fill(edge[0], edge[0] + mss * mss, INF); int u, v, w; cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i &lt; m;i++){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge[u][v] = w; ingree[v]++; } if(!topu()){ cout &lt;&lt; &quot;NO\\n&quot;; return 0; } cout &lt;&lt; &quot;YES\\n&quot;; critical_path(); int q; cin &gt;&gt; q; for(int i = 0;i &lt; q;i++){ cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; e[u][v] &lt;&lt; ' ' &lt;&lt; l[u][v] &lt;&lt; endl; } cout &lt;&lt; maxtime &lt;&lt; endl; for(int i = 1;i &lt;= n;i++) if( activity[i].size() &amp;&amp; ve[i] == 0) dfs(i); //一个关键路径的起点的后序存在节点的 且最早开始时间为0 }","link":"/2020/08/07/cs/algorithms/guan-jian-lu-jing/"},{"title":"双指针法","text":"双指针算法作为编程中的一种思想，利用了数据有序性，有效减少了算法复杂度。比如在两数之和的题目，可达到O(n)O(n)复杂度，而非O(n2)O(n2)。在序列递增的数组中找两个数之和为aim。 对于a[i]+a[j]==Ma[i]+a[j]==M, 结果成立； 对于a[i]+a[j]&lt;Ma[i]+a[j]&lt;M，则有a[i−1]+a[j]&lt;Ma[i−1]+a[j]&lt;M成立，但是a[i+1]+a[j]a[i+1]+a[j]大小未知。尝试ii向上移动 对于a[i]+a[j]&gt;Ma[i]+a[j]&gt;M，则有a[i]+a[j+1]&gt;Ma[i]+a[j+1]&gt;M成立，但是a[i]+a[j−1]a[i]+a[j−1]大小未知。尝试jj向上移动 上面的算法推导有一个不太严谨的地方：没有证明[0,i−1]和[j+1,n−1][0,i−1]和[j+1,n−1]之间的元素的任何搭配不成立。 诶好像可以用归纳法！ int aim, i = 0, j = n - 1; while(i&lt;j){ int sum = arr[i] + arr[j]; if(sum ==aim){ pirntf(&quot;%d,%d\\n&quot;, arr[i], arr[j]); i++; j--; } if(sum &lt; aim){ i++ }else j--; } 其他例子，如两个数列合并的双指针例子。","link":"/2020/08/07/cs/algorithms/shuang-zhi-zhen-fa/"},{"title":"字符串hash","text":"滚动哈希：O(n+m)时间内完成字符串匹配；实现：选取两个台适的互素数$b$和h(l&lt;b&lt;h)，假设字符串 C=clc2c3…CmC=clc2c3…Cm，定义哈希函数：$$H(C)=(C_1b_{m−1}+C_2b_{m−2}+⋯+C_mb_0)$$ 其中b是基数。 可以得出O(n)的时间复杂度就可以计算得到一个串的Hash值。而由取余性质 $$(A+B)$$ 以滚动计算hash值，可实现以复杂度O(1)O(1)计算每个母串的长度为nn子串的hash值。最后再O(n+m)时间内完成字符串匹配。在实现时，可以使用64位无符号整数计算哈希值，并取M等于264264，通过自然溢出省去求模运算。 typedef unsigned long long ull; const ull b=100000007;//哈希的基数； //C是否在S中出现 bool contain(string C,string S) { int m = C.length(), n = S.length(); if(m &gt; n) return false; //计算b的m次方 ull t=1; for(int i = 0;i &lt; m; i++) t *= b; //计算C和S长度为m的前缀对应的哈希值 ull Chash=0, Shash=0; for(int i = 0;i &lt; m; i++) Chash = Chash * b + C[i]; for(int i = 0; i &lt; m; i++) Shash = Shash * b + S[i]; //对S不断右移一位，更新哈希值并判断 for(int i = 0; i + m &lt; n; i++){ if(Chash == Shash) return true;//S从位置i开始长度为m的字符串子串等于C； Shash = Shash * b - S[i] * t + S[i+m]; } return false; }","link":"/2020/08/07/cs/algorithms/zi-fu-chuan-hash/"},{"title":"快速幂","text":"快速幂算法，也称二分幂。 递归写法： typedef long long ll; ll binaryPow(ll a, ll b, ll m){ if(b == 0) return 1; if(b &amp; 1) return a * binaryPow(a, b - 1, m) % m; else{ ll mul = binaryPow(a, b / 2, m); return mul * mul % m; } } 迭代写法： typedef long long ll; ll binaryPow(ll a, ll b, ll m){ ll res = 1， pow = a; while(b){ if(b &amp; 1) res = res * pow % m; //注意这两个地方的取余 pow = pow * pow % m; b &gt;&gt; 1; } return res; }","link":"/2020/08/07/cs/algorithms/kuai-su-mi/"},{"title":"拓扑排序","text":"/** This is Code of JJ Problem :拓扑排序 Source : Solution : AnyDetial : DateAndTime :2.26 CostofTime : **/ #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;vector&gt; #include&lt;cstdio&gt; using namespace std; const int N = 1e3; vector&lt;int&gt;adj[N]; int indegree[N],dvis[N]; int n,m; vector&lt;int&gt;res; bool topu() { int sortnum = 0; queue&lt;int&gt;q; for(int i=0;i&lt;n;i++) { if(indegree[i]==0) q.push(i); } while(!q.empty()) { int u = q.front(); cout&lt;&lt; u &lt;&lt; endl; q.pop(); for(int j=0;j&lt;adj[u].size();j++) { int k = adj[u][j]; indegree[k]--; if(indegree[k]==0) { q.push(k); } } sortnum++; } if(sortnum==n) return true; else return false; } //dfs 逆序输出拓扑排序 stack&lt;int&gt; s; int vis[N]; void dfs(int u){ vis[u] = 1; for(int i=0;i&lt;adj[u].size();i++){ int v = adj[u][i]; if(!vis[v]){ dfs(v); } } s.push(u); cout&lt;&lt;u&lt;&lt;endl; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int c1, c2, w; for(int j=0;j&lt;m;j++) { scanf(&quot;%d%d&quot;,&amp;c1,&amp;c2); adj[c1].push_back(c2); indegree[c2] ++; } topu(); } /* 5 5 0 1 1 3 3 4 0 2 2 4 */w","link":"/2020/08/07/cs/algorithms/tuo-bu-pai-xu/"},{"title":"排序总结","text":"交换类？选择排序不具有稳定性，复杂度稳定在O(n2)O(n2)。 存在不同元素大范围交换，所以不稳定。 int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[6] = {5, 3, 2, 1, 7, 2}, n = 6; for(int i = 0; i &lt; n; i++){ int mp = i; for(int j = i + 1; j &lt; n; j++){ if(c[j] &lt; c[mp]){ mp = j; } } int temp = c[mp]; c[mp] = c[i]; c[i] = temp; } for(int i=0; i &lt; n; i++){ printf(&quot;%d &quot;, c[i]); } printf(&quot;\\n&quot;); return 0; } 冒泡排序具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。 int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[6] = {5, 3, 2, 1, 7, 2}, n = 6; for(int i=0; i &lt; n-1; i++){ int flag = 0; for(int j=0; j &lt; n - 1 - i; j++){ if(c[j] &gt; c[j+1]){ int temp = c[j]; c[j] = c[j + 1]; c[j + 1 ] = temp; flag = 1; } } if(!flag) break; } for(int i=0; i &lt; n; i++){ printf(&quot;%d &quot;, c[i]); } printf(&quot;\\n&quot;); return 0; } ？？插入排序具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。 int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[6] = {5, 3, 2, 1, 7, 2}, n = 6; for(int i = 1; i &lt; n; i++){ int j = i, t = c[j]; while(j &gt; 0 &amp;&amp; t &lt; c[j - 1]){ c[j] = c[j - 1]; j--; } c[j] = t; } for(int i=0; i &lt; n; i++){ printf(&quot;%d &quot;, c[i]); } printf(&quot;\\n&quot;); return 0; } 归并排序稳定，复杂度为O(nlgn)O(nlgn)。 int printArr(int A[], int r, int l){ for(int i=r; i &lt; l + 1; i++){ printf(&quot;%d &quot;, A[i]); } printf(&quot;\\n&quot;); } const int maxn = 100; int merge(int arr[], int l1, int r1, int l2, int r2){ int i = l1, j = l2, k = 0; int temp[maxn]; while(i &lt;= r1 &amp;&amp; j &lt;= r2){ if(arr[i] &lt; arr[j]) temp[k++] = arr[i++]; else if(arr[i] &gt;= arr[j]) temp[k++] = arr[j++]; } while(i &lt;= r1) temp[k++] = arr[i++]; while(j &lt;= r2) temp[k++] = arr[j++]; for(int i = l1, k = 0; i &lt;= r2; i++, k++) arr[i] = temp[k]; } //递归写法 int mergeSort_re(int A[], int l, int r){ if(l &lt; r){ int mid = (l + r) / 2; mergeSort_re(A, l, mid); mergeSort_re(A, mid + 1, r); merge(A, l, mid, mid + 1, r); } } // 迭代写法 int mergeSort_for(int A[], int l, int r){ if(l &lt; r){ int n = r - l + 1; //step为组内元素个数 for(int step = 1; step &lt;= n; step *= 2){ for(int i = 0; i &lt; n; i += 2*step){ //这么写行不行？测试一下A[5] // 事实证明这种写法很优美! merge(&amp;A[l], i, i + step - 1, i + step, min(i + 2 * step - 1, n - 1)); } printArr(A, l, r); } } } int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[10] = {5, 3, 2, 1, 7, 2, 10, 3, 5, -1}, n = 10; // mergeSort_re(c, 0, n - 1); mergeSort_for(c, 5, n - 1); printArr(c, 0, n - 1); return 0; } 快速排序不稳定，复杂度为O(nlgn)O(nlgn)到O(n2)O(n2)，最广泛使用的排序算法。 //挖沙法 分割 int Partition(int A[], int l, int r){ //三个数取最小值 int minp = l; if(A[r] &lt; A[minp]) minp = r; if(A[(r + l) / 2] &lt; A[minp]) minp = (r + l) / 2; int temp = A[minp]; A[minp] = A[l]; A[l] = temp; int i = l, j = r; while(i &lt; j){ while(i &lt; j &amp;&amp; temp &lt; A[j]) j--; A[i] = A[j]; while(i &lt; j &amp;&amp; temp &gt;= A[i]) i++; A[j] = A[i]; } A[j] = temp; return j; } void quickSort(int A[], int l, int r){ if(l &gt;= r) return; int mid = partition(A, l, r); printArr(A, 0, 9); printf(&quot;%d\\n&quot;, mid); quickSort(A, l, mid - 1); // 如果这里取mid - 1, 可能会导致mid为右侧最小值的情况时，无限partition！（没错，微妙的递归） quickSort(A, mid + 1, r); }","link":"/2020/08/07/cs/algorithms/pai-xu-zong-jie/"},{"title":"最大公约数——欧几里得算法","text":"欧几里得算法又称碾转相除法，其算法基于以下定理： gcd(a,b)=gcd(b,agcd(a,b)=gcd(b,a 其中gcd(a, b)表示a除于b的余数。 int gcd(int a, int b){ return b? gcd(b, a % b) : a; }","link":"/2020/08/07/cs/algorithms/zui-da-gong-yue-shu/"},{"title":"最短路","text":"#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; const int INF = 0x3ffffff; const int MX = 500; int n, m, l, cap, s, t; int dis[MX], vis[MX], bvis[MX], edge[MX][MX], fushe[MX]; int bec = -1 , becfu = INF, allp; double rate = 1; vector&lt;int&gt; path[MX], bepath, nwpath; int disjk(){ fill(dis,dis + MX, INF); dis[s] = 0; for(int i = 0;i &lt; n;i++){ int u = -1, minv = INF; for(int j = 0;j &lt; n; j++){ if(!vis[j] &amp;&amp; dis[j] &lt; minv){ minv = dis[j]; u = j; } } if(u == -1 ) break; vis[u] = 1; for(int v = 0; v &lt; n;v++){ if( edge[u][v] != INF &amp;&amp; !vis[v]){//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点 //! 但是之前已经放缩的节点是绝对不会再被放缩的。。因为无负权 // if( edge[u][v] != INF ){//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点 if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + edge[u][v] ){ dis[v] = dis[u] + edge[u][v]; path[v].clear(); path[v].push_back(u); }else if( dis[v] == dis[u] + edge[u][v]){ path[v].push_back(u); } // } } } } int bfs(){ queue&lt;int&gt; que, lay; que.push(s); lay.push(0); bvis[s] = 1; while(que.size()){ int u = que.front(), layer = lay.front(); que.pop(), lay.pop(); if(layer &lt; l) fushe[u] += (int)(ceil(1.0 * fushe[u] * (l - layer) / l)); for(int i = 0; i &lt; n;i++) if(edge[u][i] != INF &amp;&amp; !bvis[i]){//! que.push(i); bvis[i] = 1; lay.push( layer + 1); } } } int dfs(int u){ nwpath.push_back(u); if(u == s){ allp ++; int npc = 0, npfushe = 0; for(int i = 0;i &lt; nwpath.size(); i++){ npc += fushe[nwpath[i]]; if(i &lt; nwpath.size() / 2) npfushe += fushe[nwpath[i]]; } npc = npc % cap; if(npc &gt; bec || npc == bec &amp;&amp; npfushe &lt; becfu){ //! npc &gt;= bec bepath = nwpath; bec = npc; becfu = npfushe; } }else{ for(int i = 0;i &lt; path[u].size(); i++) dfs(path[u][i]); } nwpath.pop_back(); } int main(){ fill(edge[0], edge[0] + MX * MX , INF);//! init int c1, c2, tmp; cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; cap &gt;&gt; s &gt;&gt; t; for(int i = 0;i &lt; n;i ++) cin &gt;&gt; fushe[i] ; for(int i = 0; i &lt; m;i++){ scanf(&quot;%d%d%d&quot;,&amp;c1, &amp;c2, &amp;tmp); edge[c1][c2] = edge[c2][c1] = tmp; } bfs(); disjk(); dfs(t); if( !bvis[t]) printf(&quot;-1\\n&quot;); else{ printf(&quot;%d %d %d %d\\n&quot;, allp, dis[t], bec, becfu); reverse(bepath.begin(), bepath.end()); // if(bepath.size()) printf(&quot;%d&quot;, bepath[0]);//! runtime error for(int i = 0;i &lt; bepath.size(); i++) if(i + 1 == bepath.size()) printf(&quot;%d&quot;, bepath[i]); else printf(&quot;%d-&gt;&quot;, bepath[i]); } return 0; }","link":"/2020/08/07/cs/algorithms/zui-duan-lu/"},{"title":"树状数组","text":"树状数组对A[i]数组进行前前缀和的维护的时更新成了一个大难题，树状数组提供O(logn)的复杂度更新速度。C[i]所能管理的A[i]数字如下图所示，如果查询7的前缀和，则需要计算C[7] + C[6] + C[4]。 可以发现每次下标的最后一个1都消失了, 而这个1和之后的零可以用lowbit函数计算。巧妙的是，依次得到p末尾少一的数，和依次自增末尾1和零组成的数，分别是遍历求和数的值，和该数节点的祖先。由此我们可以利用lowbit来计算sum和建树。 # define lowbit(x) (x) &amp; (-x) void add(int p, int x){ while(p &lt; n){ c[p] += x; p += lowbit(p); } } int gsum(int p){ int res = 0; while(p &gt;=1){ res += c[p]; p -= lowbit(p); } return res; } //o(n)建树 void build(int a[], int n){ for(int i = 0;i &lt; n; ++i){ c[i] += a[i]; if(i + lowbit(i) &lt; n) c[i + lowbit(i)] += a[i]; } } //区间计算和 int add1(int l, int r ){ return gsum(r) - gsum(l - 1); } 参考资料","link":"/2020/10/15/cs/algorithms/shu-zhuang-shu-zu/"},{"title":"素数","text":"用素数性质简单判断bool isPrime(int n){ if(n &lt;= 1) return false; int sqr = (int)sqrt(1.0 * n); for(int i = 2; i &lt;= sqr; i++) if(n % i == 0) return false; return true; } 打素数表经典的埃氏筛法 const int maxn = 1e5; int prime[maxn], pNum = 0; void findPrime(){ for(int i = 2; i &lt; maxn; i++){ if(prime[i] == 0){ prime[pNum++] = i; for(int j = i * 2; j &lt; maxn; j += i) prime[j] = 1; printf(&quot;%d\\n&quot;, i); } } } 素数表的经典应用就是分解质因子，在有了素数表的情况下分解一个数字的因子的复杂度为O(n−−√)O(n)","link":"/2020/08/07/cs/algorithms/su-shu/"},{"title":"CNAME和A记录","text":"域名解析中A记录、CNAME记录的区别和联系域名解析就是域名申请后做的到IP地址的转换过程。域名的解析工作由DNS服务器完成。 A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。 CNAME记录即：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就 “","link":"/2020/08/07/cs/cn/cname-he-a-ji-lu/"},{"title":"DNS污染","text":"&lt;转载自南通宵云网络&gt; 更多详细内容 什么是DNS污染？按照百度百科的解释就是：某些网络运营商为了某些目的，对DNS进行了某些操作，导致使用ISP的正常上网设置无法通过域名取得正确的IP地址。某些国家或地区为出于某些目的防止某网站被访问，而且其又掌握部分国际DNS根目录服务器或镜像，也可以利用此方法进行屏蔽。 和某些流氓运营商利用DNS劫持域名发些小广告不同，DNS污染则让域名直接无法访问了，非得修改DNS服务器不可。 怎么验证是否遭遇DNS污染？1.点“开始”-“运行”-输入CMD，再输入 ipconfig /all ，在下“DNS SERVER”里找到你使用的DNS服务器地址。 2.再输入 nslookup http://idcbest.com（你的域名） 你的DNS服务器IP ，来查看是否能解析。 3.再输入 nslookup http://idcbest.com 8.8.8.8 使用Google的DNS服务器验证。 域名遭遇DNS污染怎么解决？1.更换DNS解析服务器。一般来说，域名注册商家都是提供免费的DNS解析服务的，以我所实用的新之洲数据为例，就提供了许多免费的DNS解析服务，而且解析速度很快，比之前实用的什么万网之流要快得多，不可能全部被污染，所以更换两个DNS服务器即可。 2.使用第三方DNS解析服务。目前有很多第三方网站提供DNS解析服务，不少都是免费的，国内也有免费提供DNS解析服务的，使用第三方DNS服务可以部分解决问题，比如新之洲数据正在使用的DNSpod服务，就是国内还算比较稳定的DNS解析服务。 注意事项一：在换用第三方解析服务的时候，应该先到DNSPOD之类的解析服务商那里将域名解析，过几个小时再到新之洲数据之类的域名注册商那里去修改DNS服务器，这样可以避免博客出现因解析时间造成的空白期。 注意事项二：Godaddy目前本身域名就被DNS污染了，即使挂VPN也访问不了，只有更改自己电脑的DNS（比如改成google的8.8.8.8）才能访问。 3.搭建自己的DNS服务器。这样子最保险，当然也最是费时废财，有条件的朋友可以尝试。","link":"/2020/08/31/cs/cn/dns-wu-ran/"},{"title":"http劫持","text":"&lt;转载自掘金&gt; 深入理解Http请求、DNS劫持与解析。背景前段时间在处理iOS端的HTTPDNS相关SDK，在接入和测试环节发现大家对HTTP的整体请求流程包括HTTP劫持原理以及HTTPDNS的工作原理并不是太清楚，所以写下这边文章帮助大家深入web请求过程：如何发起请求，HTTP协议解析，DNS域名解析。 HTTP发起一个请求 过程当我们在手机端请求一个@”www.baidu.com&quot;的域名的时候 1.请求到达运营商的DNS服务器并由其把这个域名解析成对应的IP地址。 2.根据IP地址在互联网上找到对应的服务器，向这个服务器发起一个get\\post请求。 3.由这个服务器找到对应的资源原路返回给访问的用户。 这里只是一个大概的流程实际每一步都有复杂的结构和逻辑例如：服务器可能有很多台，到底指定哪台服务器来处理请求，需要一个负载均衡设备来平均分配所有用户的请求。请求的数据是存储在分布式缓存中还是一个静态文件中，或是在数据库里。当数据返回浏览器时，浏览器解析数据发现还有一些静态资源（如CSS、JS或者图片）时又会发起另外的HTTP请求，而这些请求很可能会在CDN上，那么CDN服务器上又会处理这个用户的请求。 HTTP劫持我们使用HTTPDNS的主要目的就是解决HTTP劫持问题。HTTP的劫持分两种第一种是DNS劫持，第二种是内容劫持，后者是基于前者的基础上发展出来，是比较高级的劫持手段，目前无解，下面来分开讲解： 1：DNS劫持 劫持流程 DNS劫持又称 域名劫持 ，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。其实本质就是对DNS解析服务器做手脚，或者是使用伪造的DNS解析服务器可以通过下图来展示 DNS劫持原理 从图中可以看出红色的是劫持的流程，劫持后将你的请求转发到一个虚假的服务器。 解决办法DNS的劫持过程是通过攻击运营商的解析服务器来达到目的。我们可以不用运营商的DNS解析而使用自己的解析服务器或者是提前在自己的App中将解析好的域名以IP的形式发出去就可以绕过运营商DNS解析，这样一来也避免了DNS劫持的问题。 2：内容劫持 劫持流程 内容劫持网上很少有提到，这也是在做httpDNS SDK所遇到的一个问题，其实内容劫持一开始的出发点是好的，是运营商为了加快用户的访问速度同时减少自己的流量损耗而做的一个缓存机制，用户在像服务器请求数据的时候运营商会把用户的请求转移到这个缓存池中，如果缓存中有就直接返回，没有的话再去像服务器请求然后拦截并缓存服务端给用户的回调数据，这样一来可以极大的降低运营商像服务器请求的次数，也能加快用户的访问，所以出发点是好，但是一些非法的商家对缓存池内部做一次些处理就是直接对返回的内容进行修改，这样一来我们就会接受到错误的数据 内容劫持 黄色线条就是比价危险的了，因为回调的数据很可能已经被篡改过。 解决办法： 现在暂时没有发现办法，不过这样的劫持不是很多。 DNS解析过程如果是iOS设备请直接跳到第三步骤 1.系统会检查浏览器缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存是受这个域名的失效时间和缓存的空间大小控制的。 2.如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中即为本地的Host文件。 3.如果本地Host文件中没有那么操作系统会把这个域名发送给这里设置的LocalDNS，也就是本地区的域名服务器。这个DNS通常都提供给你本地互联网接入的一个DNS解析服务。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约90%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。 4.如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析 5.根域名服务器返回给本地域名服务器一个所查询的域的主域名服务器（gTLD Server）地址。gTLD是国际顶级域名服务器，如.com，.cn、.org等。全球只有13台左右。 6.本地域名服务器（Local DNS Server）再向上一步返回的gTLD服务器发送请求。 7.接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成 8.Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。 9.返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。 10.把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。以上的流程可以简化为下图 DNS解析 绿色的为非iOS设备的操作流程 CDN工作机制CDN简介CDN，全称Content Delivery Network，根本的作用是将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。他-有别于镜像，它比镜像更智能，可以这样做一个比喻：CDN=镜像（Mirror） + 缓存（cache） + 整体负载均衡（GSLB），因而，CDN可以明显提高Internet中信息流动的效率。目前CDN都以缓存网站中的静态数据为主，如CSS、JS、图片和静态网页等数据。用户在从主站服务器请求到动态内容后再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度，如淘宝有90%以上的数据都是由CDN来提供的。这里引用一个网上比较形象的例子：A家的网速 100M的，但他只用了10M的速度，B家的网速是10M的，但是他需要15M的速度才行。怎么办呢。 C是一家CDN服务商，在A家有个节点（就像A是一个赞助商一样）B在C家买了CDN加速服务。当B的速度不够的时候，CDN加速就会选择有节余的节点来帮B，提高B的速度。这样B的速度就能达到或超过15M ，皆大欢喜。A没浪费，B速度有了，C赚了钱。 当C的节点在全国都有，非常多的时候。那么你用C家的CDN加速服务，你就会健步如飞了。 CDN工作流程一个用户访问某个静态文件（如CSS），这个静态文件的域名假如是www.baidu.com，而这个域名最终会被指向CDN全局中CDN负载均衡服务器，再由这个负载均衡服务器来最终分配是哪个地方的访问用户，返回给离这个访问用户最近的CDN节点。之后用户就直接去这个CDN节点访问这个静态文件了，如果这个节点中请求的文件不存在，就会再回到源站去获取这个文件，然后再返回给用户。 负载均衡负载均衡就是对工作任务进行平衡、分摊到多个操作单元上执行，如图片服务器、应用服务器等，共同完成工作任务。它可以提高服务器响应速度及利用效率，避免软件或者硬件模块出现单点失效，解决网络拥塞问题，实现地理位置无关性，为用户提供较一致的访问质量。CDN整体的工作流程可以大概归为下图： image.png","link":"/2020/08/31/cs/cn/http-jie-chi/"},{"title":"CSAPP笔记1","text":"Programmer’s Perspective )–3th edition考完了研究生，浪荡了许久，终于肯安下心来钻研提升内功，就从这本书开始吧，抄录两端话送给自己的激励！ 读完了本书以后你将成为极少数的“牛人”，这些“牛人”知道事情是怎么运作的，也知道当事情出现故障是如何修复。你写的程序将能更好利用操作系统和系统软件提供的功能，对各种操作条件和运行时的参数都能正确操作，运行起来更快，并避免出现使得成型容易受到网络攻击的缺陷。同时你也要做好更深入探究的准备。研究像编译器，计算机体系结构，操作系统，嵌入式系统、网络互连和网络安全这样高级题目。——译者序 We cover data representations, mechine level representations of C programs, processor architecture, program optimizations, the memory hierarchy, exceptional control flow(exceptions, interrupts, processes, and Unix signals), virtual memory and memory management, system-level I/O, basic network programming, and concurrent programming. THes concepts are suppeorted by series of fun and hands-on lab assignments. —— CSAPP online. 正如书籍的题目，此书的编写者考虑到大多数人都不会编写一个OS或者制作一个CPU，那么从一个程序员的角度可以更具体而实用的理解类似于C语言是怎么编译成汇编语言，不同的设置是如何影响计算机性能的，代理是如何工作的计算机基础内容。此书着手于x86处理器机器和Linux类系统，并用C作为工具来实操，提供了多个Lab。 CHAPTER 1 The wonder of computer system伟大的编译器一个最基本的C源文件是由N个ASCII码组成的数据串，将以文件的形式存储在计算机磁盘中。而每个ASCII都有由8bit组成，或者说是一字节组成，容易忽视的是，文本每一行的末尾都有\\n符号，其编码为10，或者是00001010。 中文的注释计算机将怎么处理？猜测可能有文件保存读取编码方式有关。 在linux环境下每一个C源文件都会被编译驱动(compiler driver)所编译为machine-language instructions 组成的可执行程序。 image-20200503124858005 Pre-processor：预处理器 Assembler：汇编器 Linker：链接器 gcc -o hello hello.c 运作四个步骤：Preprocessing phase将#include&lt;stdio.h&gt;的语句所标记的系统头文件stdio.h内容插入到程序文本中，并形成hello.i；Compilation phase:将hello.i翻译成assembly-language program(汇编程序)； 汇编语言作用之处在于给多种高层次语句的不同编译器提供同一个低层次的输出语言。 Assembly phase： 汇编器将汇编程序hello.s翻译成机器及的二进制relocatable object program(可重定位程序)。 GCC是伟大的自由(free speach的自由)软件思想主导的运动GUN（GUN’s Not Unix, hh递归的）的产物，其功能强大，能够支持多种语言。同样的GUN产物还有GDB debugger，EMACS editor。 Linking phase：linker将预编译好的printf.o文件链接到可重定位文件hello.o形成了最终的可执行文件hello。 重视编译器的效率问题作为现代工具的使用者，我们程序员无需重造一个编译器或者了解其中的构造，但是更有意义的是去了解如何编写代码才能让编译器翻译出更有效率的代码。书中提出了几个例子：if-else是否比switch更有效？for和while哪个效率更高？pointer referenes 是否比数组下标更快？为什么简单的重新放置算数表达式参数(arithmetic expression)可以提高效率？ 处理器读取和接触存储在内存中的指令commmand-line interpreter ——shell 可以接受指令并运行，如果输入的指令一个word不是built-in shell command，那么shell就会默认该字符为可执行文文件并load和执行,如./hello将执行可执行文件hello，shell会等待程序结束(terminate)，之后输出提示符(a prompt)。 系统硬件组织 image-20200503124915375 一个Inter风格的硬件组织图 总线(Buses)类似人体血管的贯通系统内部传输固定大小电子信息比特的管道(conduits)，通常这个大小的值不固定。 I/O 设备(I/O Devices)I/O设备是计算机系统负责接收发送给外部世界的设备，通过控制器(contrlllers)和适配器(adapter)连接到I/O总线。控制器和适配器的目的为了传输信息，但是控制器是由计算机原有的芯片控制的或者说是在母板(motherboard)上的电路印刷而成的，适配器是可以插入母板插槽的芯片卡。常见的外部设备有磁盘、显示器和鼠标键盘。 主存(Main Memory)主存是系统在运行程序时的暂时存放数据和指令的空间。物理上，其一般有动态随机存储芯片(dynamic random access memory, DRAM)芯片组成。逻辑上说内存实际就是一个地址从零开始的线性字节数组。另外系统指令可由多个比特组成，数据项大小随数据类型不同而变化。 原句： In general, each of the machine instructions that constitute a program can consist of a variable number of bytes 处理器(Processor)中央处理器(central processing unit)是计算机的心脏，负责解释(interpet)和执行(execute)从内存运送到CPU的IR(instrruction register)的指令。简单的说，CPU包括了其运算器部分（如ALU，寄存器等）和控制器部分（如PC，IR等等）。在CPU运行过程中，CPU解释PC指向的指令，根据指令执行操作并更新PC值。 简单来说，指令包括了Load、Store、Operate(数据运算)和Jump类。 运行hello程序从硬件底层在理解一次刚刚的运行过程，在我们打入./hello命令指示，shell程序将键盘输入的字符通过寄存器和总线存储到内存中，当输入Enter1后shell开始执行shell程序。 有趣！ image-20200503124936718 shell将原本存储在Disk中的代码和数据复制到内存中。系统借助了直接存储器存储器(direct memory access, DMA)而无需通过CPU传输数据直达主存。 image-20200503124954066 最后，CPU运行hello程序，执行对应指令，并把数据hello,world\\n复制到寄存器并打印到屏幕。 image-20200503125006147 其中必然包括了中断技术。 高速缓存至关重要从上文的例子看到程序运行过程中存在大量数据和指令移动，而现有的机械结构却造成了存储器速度和容量之间的取舍难题。往往速度快的存储器（比如寄存器）容量却很小，相反的容量大的存储器比如磁盘、光盘存储速度都很慢。为了解决这一难题，现在计算机配备了高速缓存(cache)，甚至是多级高速缓存。其运用了局部性原理(locality)。这对程序性能有着重要影响。 locality:程序会倾向于使用局部区域的代码和数据 image-20200503125016708 cache的加入让我们有一个更美妙的想法：存储器层次结构(memory hierarchy)，这种结构从上到下，速度逐渐变慢，价格变低，同时容量上升。更有趣的是，上层可以视为相邻下层的缓存，相邻下层可以视为上层的存储，比如分布式系统中的本地磁盘就是远程存储系统的缓存。 操作系统管理硬件hello程序运行中时，外部数据的输入和打印屏幕这些操作硬件的举动都不是源程序或者shell所做的，都是使用了操作系统所提供的接口。操作系统是计算机硬件和应用软件之间的管理层，一方面负责保护硬件不直接受到应用软件的操作，另一方面提供给所有应用软件统一且简单的接口。 image-20200503125027579 操作系统通过几个抽象的功能来实现对计算机资源的管理，如下图。 确实抽象，Processes本身带着运行程序的位置信息、进程信息和源程序信息，也就是说Processes是对三者的管理。其他类似 image-20200503125035839 进程(Processes)即使是单核处理器(uniprocessor)计算机也可以同时（宏观）运行多个进程，操作系统在记录并控制了所有进程的上下文(content)。操作系统通过保存当前的进程上下文，并载入一个新进程的上下文可以实现进程切换。 image-20200503125045850 一个正在运行的进程可以通过系统调用来调用操作系统的功能，比如读写磁盘，执行另一个程序创建新进程。 线程(Threads)线程作为“轻量级”的进程，能快速访问同进程下的共享资源，占有更少的内存空间，运行效率更高，可以充分利用多核计算机的计算效能。 虚拟内存（Virutual Memory）顾名思义，虚拟内存是操作系统在内存的基础上虚拟空间。对于软件来说虚拟内存唯一可以接触到的空间，物理内存对他们是透明的。 image-20200503125120329 从低地址到高地址所存放的内容分别是： 程序的代码和数据 读写数据 堆(heap)：可以由进程通过程序malloca，new动态创建 分享库(shared libraries)：比如C++的math库 栈：在用户调用函数增长，返回函数时减小， 内核虚拟内存：保留给内核程序的空间。用户应用程序无法读取这部分内容，也无法直接掉调用。 文件(Files)至少在Unix I/O上，file系统将各式的外设输入输出设备、甚至网络建模成一个文件。统一的文件形式给系统操作员极大的方便。 linux: a complex, Posix-compliant version of the Unix operating system. posix，Portable Operating System Interface X——可移植操作系统接口 网络：计算机与其他系统的沟通桥梁 讲的太粗略，不计 重要主题 This concludes our initial whirlwind tour of systems. An important idea to take away from this discussion is that a system is more than just hardware. It is a collection of intertwined hardware and systems software that must cooperate in order to achieve the ultimate goal of running application programs. Amdahl’s LawAmdahl’s Law假设简单系统的各个部件线性工作，提升一个部件的效率其实对整齐来说提升并不明显。 image-20200503125132267 并发(Concurrency)和并行(Parallelism)并发是对计算机同时运行多个事件的广义概念。并行是指？？？ 在分时(time-sharing)操作系统上，所谓的并发仅仅只是一种模拟(simulated)，通过不断的切换进程（在进程(Process-Level Concurrency)级别上 ）让电脑同时相应多个用户的操作。而在线程级别(Threa-Level)上，即时在单核对一个单一的进程也有执行的多重控制流。 随着由多个有单独的操作系统内核管理的单个处理器组成的多核处理器(multiple processors)的到来，多核操作系统诞生了，随之而来的是超线程(hyperthreading)！ image-20200503125144846 image-20200503125157325 超线程（也称为sinultaneous multi-threading）是一种允许一个核同时执行的多个控制流，涉及了部分硬件的多分设计，比如PC(program countes)，寄存器文件，而其余硬件只设一份，比如浮点数计算。可以说，在并发概念提出50年的铺垫后，多核处理器和超线程的出现才引爆了对多线程编程应用和并行的极大热情。（Eng. P55） 指令级并行通过多核处理的多核处理能力，以及现代流水线架构来实现。 单指令多数据(SIMD，single-instruction, multile-data)并行是通过特殊硬件允许一条指令同时进行多重操作。常常用于处理图像、声音等数据。 抽象(abstraction)的重要性 计算机最重要的两个概念——抽象和局部性原理 抽象在计算机领域无处不在，提供给调用者的统一的函数接口API(Application program inteface)是函数的抽象，文件本身就是输出输入设备和物理数据的抽象，虚拟内存是内存和文件的抽象，进程是指令和数据的抽象，而计算机本身也是一个运行在硬件上的虚拟机(可见开头图) 终于读完了一个综述，开心 :heart: :happy::happy::happy:~~于2020.04.27.10:17","link":"/2020/08/07/cs/csapp/csapp-bi-ji-1/"},{"title":"CSAPP笔记10-系统级I&#x2F;O","text":"输入输出是在主存和外部设备（磁盘驱动器、终端和网络）之间复制数据的过程。所有的语言都提供执行I/O的高级别工具，比如ASNI的C提供了Scanf和Printf。在Linux系统中，内核提供的系统级Unix I/O实现了较高级别的I/O函数。学习Unix I/O有助于我们理解系统I/O的运作原理，理清其他系统概念，甚至在不得已的情况使用Unix I/O编程。 Unix I/O一个Unix文件就是一个$m$字节的序列。所有的I/O设备，比如网络、磁盘和终端，都被模型化为文件，而所有的输入输出都被当做文件的读和写。这种优雅的映射方法允许Linux允许一种的统一且一致的方式执行读写。 打开文件：如果应用程序要求内核打开一个文件，内核负责在打开表中修改文件条记录，从文件描述符池中选一个可用的描述符，然后返回标志该文件的非负整数文件描述符。内核负责记录文件的所有信息。 标准文件：Linux shell创建的每个进程都有三个打开文件，分别是 标准输入、标准输出和标准错误，其描述符分别为0，1和2。在头文件&lt;unistd.h&gt;定义了常量：STDIN_FILNO、STDOUT_FILENO和STDERR_FILENO。它们可以用来代替文件描述符。 文件位置：每个打开的文件都有内核维护的文件位置$k$**，每次读和写一段内容都是在文件位置为起点，进行读写，并移动指针到后续部分。当读**操作使文件位置$k&gt;m$（m为文件长度），触发一个称为end-of-file的条件。应用程序可以检测到这个条件，但实际上文件并没有这个符号。 关闭文件：当应用程序通知内核关闭文件的时候，内核释放文件打开时创建的数据结构，将描述符恢复到可用的描述符池中。抑或一个进程终止了，内核会关闭该进程打开的所有文件。 文件每个Linux文件的都有一个类型（type）: 普通文件：分为二进制文件和文本文件。文本文件是由文本行序列组成的，一行文本行以\\n新行符（ASCII的换行符LF）结束。 目录：包含了指向其他文件链接的文件。其中至少包含了两个链接，一个指向文件本身.，另一个指向父文件..。 套接字：一个与其他网络主机进行网络通信的文件。 其他文件如命名通道， 符号链接以及字符和块设备。 mu [mu] size_t：unsigned int ssize_t：long I/O API 基操int open(char *filename, int flags, int mode) 打开文件并返回描述符。flags参数描述了如何访问，mode描述了读写权限。 ssize_t read(int fd, void *buf, size_t n)：从文件fd中读取n个字节到*buf。文件读取可能因为网络通信，读到EOF或者从终端中读取而传送的字节比应用程序要求的少。这些不足值并非错误，但是不够健壮。 ssize_t write(int fd, cons void *buf, size_t n)从内存位置buf读取n个字节写到文件fd。 目录DIR *opendir(cons char *name)：从路径name获取目录流的指针。流是对条目序列列表的抽象。 struct dirent *readdir(DIR *dirp)：返回指向dirp指向的下一个目录项的指针。 int cloes(DIR *dirp)：关闭目录流并释放所有资源。 I/O重定向dup2(int oldfd, int newfd)：把进程的描述符表的oldfd项复制到newfd项，并关闭newfd指向的内容。 标准I/OC语言定义了一组高级输入输出函数，称之为标准I/O库。它将每一个打开的文件模型化一个流。对于程序员而言每一个流就是一个指向FILE结构的指针。 类型为FILE的流是对文件描述符和流缓冲区的抽象。流缓冲区作用就是把开销较高的Linux I/O系统调用的数量尽可能减少。比如标准I/O函数getc会在第一次调用时调用Unix I/O函数read读取一串字符串，之后便可以返回一个字符给应用程序。之后只要缓冲区有未使用的字符，getc就可以直接从缓冲区中获取。 打开文件数据结构内核用三个数据结构描述打开的文件： 描述符表：每个文件都有一个描述符表，表中的每个描述符都指向内核得打开文件表。 打开文件表：记录着打开文件的信息，仅此一张，所有进程共享。每个表项包含了文件位置、引用计数以及一个指向v-node表中的对应表项指针。引用计数会因对应文件的关闭而减少，直到变为零，该文件打开项也关闭。 v-node表：存放关于文件本身的信息，比如文件存放位置，文件大小，访问权限等等。所有进程共享。 举几个栗子🌰： 一个进程打开两个文件： 一个进程用相同的参数打开一个文件两次： 可以看到内核并不是只打开一个文件一次，而是新增了两个文件打开项（这部分内容和以前学习到内容由冲突）。如此，内核提供了两个读写位置给进程 父子进程刚刚fork完： 建议 尽可能使用标准函数，除非需要的信息太低级 不要用scanf或rio_readlineb读取二进制文件 。二进制文件的0xa字节会使文件读取失败。 标准I/O用于网络读取时会出意外的错误，最后使用健壮的rio。","link":"/2020/08/31/cs/csapp/csapp-bi-ji-10-xi-tong-ji-i-o/"},{"title":"CSAPP笔记12-并发编程","text":"现代操作系统提供了三种方法进行并发编程——进程、I/O多路复用和线程。这章节提供了三种构造并发服务器的思路。 基于进程的并发服务器主进程在TCP链接成功后，fork一个子进程来处理链接内容。主进程绑定僵死信号到自定义函数，保证僵死进程被主进程回收。 明显的，父子进程拥有同一份全局变量，但是父子进程无法直接通信，只能通过IPC（进程间通信）机制。与此同时，带来的进程管理和IPC开销都很高。 unix IPC：指同一主机上一个进程对其他进程相互通信的技术。其中包括，管道、先进先出、系统V共享内存以及系统V信号量。 基于I/O多路复用的并发编程/基于I/O多路复用的并发事件驱动服务器select函数提供了从多路I/O读取的事件触发唤醒机制。该函数会要求内核挂起进程，并等待至少一个I/O事件发生后，在讲控制权返还给应用程序。他避免了等待终端输入的同时无法处理外部链接的尴尬情况，提高了系统并行程度。虽然当它在处理一个请求时，仍然无法处理另一个请求。 以此我们可以编写基于多路I/O的并发事件服务器，更进一步的，我们将进程的状态模型化为状态机。每个状态都有一组输入事件，转移。 优劣之处事件驱动事件的优点之一就是根据事件给予程序设计更多控制权。另外，基于多路I/O的事件驱动程序服务器运行在单一进程上下文中，因此每个逻辑流都能访问该进程的所有地址空间，使得流之间的数据共享变得容易。其次，可是使用方便熟悉的调试工具。 事件驱动的另一个明显的缺点就是编码复杂。不幸的是，如果并发力度减少，复杂性还会上升。它的另一个缺点就是不能充分利用多核资源。 基于线程的并发编程线程是微型进程，由内核调度。多个线程运行在同一进程的上下文中，共享进程虚拟空间的所有内容，包括代码、数据、堆、共享库和打开的文件。那么单个线程独有的资源有程序计数器、栈和栈指针，线程ID，条件码和通用寄存器值。也就是说，线程切换的代价远远比进程小。另外，线程不像进程拥有严格父子关系，主进程和对等线程的唯一区别在于主进程是一个创建的线程。所有和一个进程相关的线程组成一个线程池，其中每一个线程都可以杀死他的对等线程，或者等待其终止。 线程的栈一般来说都是不共享的，但是由于线程的 栈都保存在进程的虚拟空间中，而且线程的栈的空间对其他的线程总是不设防的。如果一个线程能够获得其他线程的栈地址，实际是读写栈上的任何部分的。 在变量上，全局变量和本地静态变量（函数内部的带static修饰的变量）都保存在虚拟空间中读写区域，运行过程中只有该变量的一份实例。也就是说，即使每个线程都定了一个cnt变量，每个线程在后续读写也是读写这个静态变量的唯一实例。而本地自动变量随着函数运行而保存在栈中，随着函数结束而消失。 每个进程都是一个主线程，在创建一个线程后，称那个线程为对等线程（peer thread）。那么两个线程开始并发运行，当主进程遭遇慢速系统调用后，或者被系统的间隔计数器中断，控制转给另一个线程。 这就是线程执行的主要模式。 POSIX线程Posix线程（Pthreads）是C程序处理线程的一个标准接口，而且在所有Linux系统上通用。 int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg) 创建一个新线程。pthread_t指线程ID pthread_t pthread_self(void)：返回线程的ID。 终止void pthread_exit(void *thread_return) 主进程调用会等待其他线程终止再终止主进程和整个进程。其他进程调用会显式地终止线程。 exit()终止进程和所有相关的线程 int pthread_cancel(pthread_t tid)：另一个线程调用，终止另一个对等线程。 等待int pthread_join(pthread_t tid, void **thread_retunr) 阻塞线程等待其他线程终止。 分离int pthread_detach(pthread_t tid)：分离该线程。分离后的线程不会被其他线程杀死或回收，它的内存资源在它终止后将有系统自动释放。相反，可结合的线程可被杀死和回收。 实际上高性能服务器不愿意也没必要等待每一个对等线程终止，载回收它的资源。那么每个资源都应该在调用该函数，分离它自己。pthread_detach(pthread_self())！ 初始化pthread_once_t once_control = PTHREAD_ONCE_INIT; int pthread_once(pthread_once_t *once_control, void (*init_routine)(void)); once_control是一个全局或者静态变量。用这个参数调用pthread_once后将在其第一次运行时调用init_routine，之后的再调用pthread_once将不会再干任何事情。这个特性在多个线程动态初始化共享变量特别有用。 线程的同步和竞争同步竞争问题是经典的并行问题，常常在多线程编程对引出麻烦。尤其是仅仅一行简单操作代码却有多条指令组成的情况下，让人百思不得其解。 具体不记录了，也是一些重复的内容。 预线程化的并发服务器 descriptors：描述符 其实这图所示的服务器模型也是一种事件驱动模型。 线程提高并行性不得不提，并发的兄弟——并行。在多核处理器上，每个核都可以运行一个进程或者线程，就是所谓的并行。可以理解，并行程序是并发程序的真子集。并行程序简单的来说可以大任务分成几个小任务分配给不同的线程，再由主线程来收集计算最终结果。但是由于线程之间可能存在的运行同步和竞争问题需要进行PV操作，还有多变量的内存引用，线程切换等开销，并行程序可能还不如非并行版本的程序快。 要提高效率，要注意几个点： 尽量减少共享变量，减少巨大的同步开销。 多引用局部变量来消除不必要的内存引用。 刻画程序的性能并行程序的加速比（强扩展，strong scaling）：$$S_t = \\frac{T_1}{T_p}$$$T_p$为程序在$k$个核上的运行时间。如果$T_1$是顺序版本的程序，则称公式为绝对加速比，如果$T_1$是并行版本的程序，那么公式称为相对加速比。前者要求的拥有源代码甚至有等价的复杂度实现要求很高。但是和后者增加无谓的切换线程的开销，使得$S_t$偏大。 效率（efficiency）：$$E_p = \\frac{S_p}{p} = \\frac{T_1}{pT_p}$$效率是对由于并行化造成的开销的衡量。高效率的程序在有用的工作上花费更多的时间，而在同步和通信上花费更少的时间。 弱扩展：同等增加处理器数量和任务总量，可以比较不同阶段的效率和加速比变化，得出其变化是否是线性的。 线程安全问题线程不安全的问题一共有四种： 不保护共享变量的函数：显然的 返回指向静态变量的函数：静态变量对于线程来说是共享的，返回指向它的函数容易导致其结果被其他调用篡改 保持跨越的多个调用状态的函数：调用结果随着调用序列的变化而变化。显然，调用结果容易被多线程所扰乱。 调用线程不安全的函数：就是调用以上三种不安全函数的函数！ 解决方法： 第一种：重写代码，加锁； 第二种：重写代码，加锁；在调用和获取结果的时候，加锁（可以定义一个线程安全的包装函数，执行加锁-复制，然后通过这个包装函数来取代所有线程不安全的调用）。 第三种：唯一的方式就是重写它。使他不再依赖任何static变量，只依靠参数传递的实参。 第四种：那就调用线程安全的函数就行了吧 可重入性一类线程安全的函数成为可重入函数。它们的特点就是调用过程中不会引用任何共享数据。那么可以说，可重入函数是线程安全函数的真子集。","link":"/2020/08/31/cs/csapp/csapp-bi-ji-12-bing-fa-bian-cheng/"},{"title":"CSAPP笔记2","text":"程序结构和执行过程本章主要讲解程序在机器级代码上的执行过程以及程序编译翻译过程。 信息存储相比人类熟悉的代表了十指的十进制，二进制的稳定性、表达形态少、对硬件芯片的友好性是建造计算机的更优选择。典型的二进制应用就是记录数值，float-point encoding 和 Unsigned encoding就是代表。 有趣的是，计算机的算术运算过程即使是对溢出运算也会满足结合律(associative) 数值组成的bit有限就造成了数据表达的有限，从而引出的计算溢出，甚至安全问题都是编程者需要考虑的。 虚拟空间(virtual memory)是计算机操作系统提供的虚拟空间，以C语言的指针举例，一个C pointer指向的一定是一个数据类型(int, float, or structure)的第一个字节的虚拟地址。C语言本身会组织类型信息(type information)以便获取指针指向的数据内容，但是在机器级的代码中所有的程序对象都是一样的bit。(p63) C语言在早期计算机语言发展占据重要的位置，比如提供了内存分配器（memory allocator）——the malloc library function。C语言的编译可以对GCC（Gun Compiler Collection）添加参数以控制编译版本 gcc -std=c11 prog.c 指定了C11标准版本 -std=c99指定了C99版本 -ansi和-std=c89指定了C90版本 -std=gnu11指定了GNU项目的开发的一个版本，包括了ISO C11的内容 C语言支持向后兼容（backward compliale，“后”就是指过去，而非口语所说的“以后”），那么C语言编译的32bit的程序也可以在64位机子上跑。但是64bit的程序不能在32位的机子上跑。 gcc -m32 prog.c 设置了编译的位数，同理-m64设置了64bits C的指针有两个方面——值和类型，值指向了指针指向的内容的地址，类型指出了指向的地址的存放的信息的种类。 十六进制计数 （Hexadecimal Notation） image-20200503124826544 1000多页是时候考虑时间问题了，有更值得去做事情去干，暂时读的话还不读英文版了。","link":"/2020/08/07/cs/csapp/csapp-bi-ji-2/"},{"title":"CSAPP笔记3-程序的机器级表示","text":"主要记录C代码对应机器指令是什么，具体实现过程。 过程过程是一种软件封装思想，输入参数并指定返回值以实现一种功能。过程的形式有函数、方法、子例程和处理函数。 过程的一个通性就是使用了先进先出的内容管理原则。 运行时栈运行函数会在调用函数是，将多余六个参数的参数加入到栈中，并保存返回地址。剩下的交给被调用函数，被调用函数将保护现场——保存寄存器，将寄存器放不下的临时变量加入栈中，“Argument build area”不太清除。被调用的函数在栈中所构建的内容称为栈帧。注意不是每个函数都需要栈帧，注意栈顶指针是%rsp。 C数据结构structstruct的所有成员都存放在一段连续区域中，指向结构的指针的内容是结构的最低地址。编译器维护结构信息，指示每个字段的字节偏移，并把这些偏移编码到内存引用指令中，从而产生对结构元素的引用。 unionunion联合可以保存两个互斥（不可同时存在）的数据类型，其大小与最大的成员相同。union还可以通过引用不同的成员来存储数据，甚至改变不同字节上的数据，当然字节顺序就成了问题。 double uu2double(unsigned word0, unsigned word1){ union{ double d; unsigned u[2]; }temp; temp.u[0] = word0; temp.u[1] = word1; return temp.d; //两个unsinged组成一个double类型元素，小端机器上temp.u[0]是d的低位四个字节。 } 数据对齐为了提升数据存取效率，设立了数据对齐的原则——任何$K$字节的基本对象的地址必须是$K$的倍数。如下： K 类型 1 char 2 short 4 int，float 8 long，double，**char*** 深入的考虑，S2的三个元素的分配的内存空间如下：int:0；int:4；char；8。重点是，如果考虑了S2[2]元素的存在条件，为了保证每个元素的成员地址在正确的位置，应该再分配S2成员3个比特。如此整个结构的空间为12bytes。 struct S2{ int i; int j; char c; }; 指针指针是C的特色，也是极容易错误的内容。 将指针从一种类型强制转化为另一种类型，只改变他的类型，而不改变他的值 指针也可以指向函数。 int fun(int x, int *P); //定义了一个指向以int和int *为参数，返回int的函数指针。 int (*fp)(int, int *);//int *fp(int, int *)会被解释为函数原型 fp = fun;","link":"/2020/08/12/cs/csapp/csapp-bi-ji-3-cheng-xu-de-ji-qi-ji-biao-shi/"},{"title":"CSAPP笔记5-程序优化","text":"GCC为我们C++语言提供了优秀的自动优化方法，-O1,-O2,-Og可以配置不同优化程度。但是GCC的优化也有局限性，它小心翼翼地保护不能确定结果的代码，比如：下述代码中，如果p2指向了v的最后一个元素，其计算结果和p2指向一个int data = (*v)[(int)v.size() - 1]的结果完全不同。 int f(vector&lt;int&gt; *v, int *p2){ for(int i = 0; i &lt; v-&gt;size(); i++) *p2 = *p2 * (*v + i); } 程序级优化方法上述代码可以有三种可以讨论的方向。 程序优化指标CPE：每个元素（泛指，比如一组指令，一段语句，一句汇编都可以是一个元素）所花费的平均CPU周期。 减少不必要的函数调用如果计算过程不存在改变vector的长度，v-&gt;size()应该避免多次调用，因为计算结果都是相同的。但是编译器不会把函数移动出去，因为它不知道for循环体的副作用。程序员应该主动移动该类函数。 减少不必要的内存引用上述例子中p2被不断的读，写，同时体现在编译语言上就不断的从内存中读，到内存中写。然而更好的方法就是定义一个暂时变量，从而在寄存器中保存结果，大幅减少读写指令。同样的因为指针未知指向，编译器也不会主动增加变量来暂存结果，只能由程序员手动更改代码。 循环展开可以在一次循环中计算原本循环中多次计算的结果。 从现代处理器理解程序优化处理器的不同单元有分支、算数运算、加载和存储多个功能，每个单元负责执行不同指令的不同操作。加载单元的数量限制了数据量的上限，称之为吞吐量界限。延迟也就是完成运算的需要的总时间。延迟界限是顺序指令执行的上限。 另外，发射时间指两个同类型的运算之间需要的最小周期数，容量指能够执行单元指令的功能单元数量。 从数据流图的角度分析代码瓶颈： double mult(int a[], int len){ int i = 1; long res = 1; for(; i &lt; len; i++){ res = rse * a[i]; } return res; } 仅仅关注循环翻译的代码可以得到： 明显的有，存储器含义如下 %rax: a[0] + len * 8 %rdx:a[0] + i * 8 %xmm0: res 把寄存器和指令关系联系起来，可以得出： 把图形变形一下，然后留下迭代中变化的寄存器和使其变化的指令，可得(b)。 讲多个迭代的数据流图拼接起来可得： 其中明显的有关键路径，也是整个迭代执行的瓶颈，就是说迭代的CPE等于关键路径的CPE。 容易混淆的是，关键路径查找失败，注意寄存器要相同。 循环展开也就是一次循环中计算多次迭代的值，已达到减少迭代的次数的目的。可以提高效率，但是CPE不会超过延迟界限，这是因为本质上将经过循环展开的代码所有执行过程展示，执行op数量和原有迭代相同。 编译器在优化等级3以上就自动循环展开。 提高并行性令人兴奋的是，提高并行性的方法可以打破延迟界限，但是无法突破吞吐界限。 多个累计变量将多个迭代拆分成每次迭代中计算多个不相互影响的计算式，从而降低迭代次数。 比如以下代码可以称为2*2循环展开： 前一个2指循环展开的计算式， 后一个2指一个迭代计算的变量。 long res1 = 1, res2 = 1; for(int i = 1; i &lt; len; i += 2){ res1 *= a[i]; res2 *= a[i + 1]; } res = res1 * res2; 可以猜出，这两条计算指令可以并行处理，而且在数据流图上也出现两条关键路径。假设乘法的CPE为5，那么这个迭代的CPE为$5/2= 2.5$。 不过要小心，这种改变了计算顺序的优化方法，可能会导致计算结果的突变。比如浮点数乘法计算的溢出（上溢，下溢），浮点数的加法和乘法是不可结合的，原因如上。不过一般来说，极端数据模式的出现概率很低，而且一般来说，提高代码性能远远比防止极端数据出现更重要。 放心的是，整数加法和乘法可以结合。 重新结合变化如下图，把计算OP顺序改变，可以得到近乎一半的性能提升。 原因仍然可以从数据流图中寻找： 至于另一条的数据流图，也很好画，结果正是两个mul在一个迭代中的关键路径上。 AVX向量指令是Intel引入的SSE指令。（SSE是Streaming SIMD Extensions的缩写，SIMP为Single-In-struction, Multiple-Data，即单指令，多数据流的缩写）当前的AVX寄存器长为32B，每一个寄存器可以存放8个32bits或者4个64bits的数字。 vmulps (%rcx), %ymm0, %ymm1可以读出8个数据进行相乘，$a_i=a_i*b_i, 0&lt;= i&lt;8$。 可以对32位运算的效率提高8倍，64位计算的效率提高4倍。 但，AVX指令无法产生64位整数的并行乘法指令。 其他因素由于循环内部暂存量过多，寄存器数量不够，反而导致需要在栈中暂时保存，这会到时效率变低。 分支语句尽可能转化条件数据传送，否则如果预测错误效率会降很多。 以下就是条件数据传送： v = cal_exper1； n = cal_exper2; if(t) rse = v; 一般到的if-else形式语句就是条件操作传送。 综合应用Unix提供了一个GPROF可以分析函数调用情况，以便我们优化代码。 操作步骤gcc -Og -pg prog.c -o prog //-pg 避免内联函数变形，使用GPROF剖析 ./prog file.txt //产生gmon.out grpof prog //分析数据 解析剖析第一部分容易看出： 第二部分： 前两行指find_ele_rec被find_ele_rec和insret_string的调用情况，第三行指find_ele_rec总被调用情况，后两行指find_ele_rec调用的两个函数情况。 可以看出find_ele_rec是一个递归函数，而且…… GPROF计时不准。基于间段计时中断的机制，典型的中断时间是1ms，容易对执行时间不长的程序误判时长。对于计时长的GPROF的程序计时显得准确。 如果没有执行内联替换则调用信息准确。 不会显示对库函数的计时，除非用一个包装函数（wrapper function）","link":"/2020/08/13/cs/csapp/csapp-bi-ji-5-cheng-xu-you-hua/"},{"title":"CSAPP笔记8-异常控制流","text":"这章的内容很精彩！解答了很多关于进程和信号量的知识。（但是内容太多了！简略的记一下） 面对系统和程序中的突变，也称之为异常控制量（Exceptional Control FLow, ECF）。异常控制流发生在机器的各个层面上。比如，在硬件层面上，硬件检测到的突发事件会把控制权转移给异常处理程序；在操作系统层面上，内核通过上下文内容切换将控制权从一个进程转移到另一个进程中；在应用层上，一个进程可以发送一个信号给另一个进程，而接受者会将控制权突然转移给它的一个信号处理程序。一个程序可以回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。 理解ECF的重要性非常大，它有助于我们理解系统如何和应用程序交互，理解重要的系统程序，理解并发，进而帮助我们编写有趣的系统程序，认识到软件异常如何工作。 异常异常（exception）是ECF的一种形式，其实现一半由硬件实现，一半由软件实现。 异常的基本的思想就是当处理器检测到事件（events）发生时，异常是当处理器检测有事发生时，通过异常号作为索引查找一张异常表的表项——异常处理程序地址，进行间接过程调用（异常），即调用对应的操作系统子程序——异常处理程序（exception handler）。 其中异常表基址寄存器（exception table base register）保存着异常表的基址。异常表的内容和异常表基址寄存器都由操作系统重启或加电后初始化。 而事件的发生可能和当前指令有关，也可能有当前指令无关，比如发生缺页或者除零，又比如计时器产生一个时间中断信号。 异常处理结束后，一般有三种情况： 将控制权给当前指令 将控制权给当前指令的下一条指令 将当前进程终止 异常类似于过程调用，但有几点不同： 不同点 过程调用 异常 返回地址 下一条 下一条或者正在执行的那条，或者直接终止程序 多压入包含条件码的EFLAGS寄存和其他内容 不会 会 压入栈 保存在用户栈中 如果控制权从用户程序到内核，则压入所有内容到内核栈 权限 运行在用户模式 运行在内核模式，对资源有完全的访问权限 异常的类型中断，故障，陷阱和终止。下图做了小结： 中断中断是来自指令外部的事件引起的，与当前指令无关，可以说 是异步的，其他它三个指令都是同步的。CPU在当前指令完成后检测到中断位电压升高，并在系统总线上受到异常号，就触发了中断。硬件触发中断的异常处理程序常常称为中断处理程序（interrupt handler）。 中断处理程序被调用后，将原有的现场恢复，将控制权转移给下一条指令$I_{next}$。好像一切都没有发生！ 陷阱和系统调用陷阱（trap）是有意的异常，是执行一条指令（比如 syscall n）的结果。陷阱最重要的用途是在用户程序和内核之间提供一个像过程样的接口，叫做系统调用。陷阱让处于用户模式的程序可以调用内核模式的程序，并有权访问内核模式的栈。 故障故障是由错误情况引起的，可能能够被错误处理程序所修复。当故障发生时，处理器将控制转交给故障处理程序。如果故障被修复，那么就返回到引起故障的那条指令，相反的，如果故障没有被修复，就犯规到内核中的abort例程，abort例程将会终止引起故障的应用程序。 终止终止是不可恢复的致命错误引起的结果，通常是一些硬件错误，比如SRAM或者DRAM位被损坏时发生的奇偶错误。同样的，终止处理程序会把控制转移给abort例程，该例程会终止应用程序。 Linux/x86_64异常常见的Linux系统异常和对应信息： 14号是缺页故障。 C程序提供一串包装了可以调用任何系统调用的syscall函数的高级函数。我们称一系列系统调用和包装他们的函数称之为系统级函数。注意，所有到Linux系统调用的函数都是通过通用寄存而不是栈来传递参数的（本身调用时最多用6个参数，寄存器刚刚好放得下）。 错误处理Unix系统级函数遇到错误时，通常会返回-1，设置全局变量errno带来表示出现了什么错误。但是检测错误带来的代码臃肿真是逼死强迫症，作者提供一种的错误处理包装函数的优雅写法。 pid_t Fork(void) //让FOrk的调用减少到了一行 { pid_t pid; if((pid fork() &lt; 0) unix_error(&quot;Fork error&quot;); return pid; } void unix_error(char *msg) { fprintf(stderr, &quot;%s: %s\\n&quot;, msg, strerror(errno)); exit(0); } 进程进程的经典定义就是一个执行中程序的实例。我们把程序执行的指令的PC序列称为逻辑控制流，也称逻辑流。对于每一个进程而言，它一直在执行，从来没有中断过，一直独占使用处理器。这归功于CPU提供的独立的逻辑控制流。但是从CPU 的角度讲，多个并发的逻辑控制流组成了并发流。一个进程和其他进程轮流执行的概念叫多任务，也称时间分片。显然的，并行流是并发流的真子集。 系统给每个进程都提供了独立的私有地址空间，这得力于虚拟内存的强大功能。它使得每一个程序都有一致结构的地址空间，好像独自使用整个系统存储空间。 操作系统提供了独立的地址空间和可以执行的指令，这是进程抽象的必须条件。为了控制指令的安全性和权限，系统设了运行模式——用户模式和内核模式。CPU的一个模式位若为1则当前为内核模式，反之则为用户模式。用户模式限制了指令的读写权限，特权指令无法被使用。 linux 提供了用户模式访问内核模式的一种途径：/proc文件系统——其中记录了内核数据结构的内容，比如进程和CPU的信息，/sys文件系统：系统总线和设备的底层信息 操作系统为每个进程维护了上下文来保持各个进程的状态，而上下文的切换就是较高形式的异常控制流。上下文是内核需要重新启动一个进程所需要的状态，它通常包括通用目的寄存器，浮点寄存器，程序技术器，用户栈，状态寄存器，内核栈和各种数据结构，比如页表、进程表和文件表。 并发并发就是指两个进程交错运行（必有一个进程被中断至少一次）。 子进程fork()出来的子进程与父进程完全相同，包括代码，数据，变量，寄存内容，打开的文件标识符等等，但是注意，虽然相同却不是同一份。fork()有一个神奇的特性，一次运行，两次返回，即返回给子进程零，返回给父进程子进程的PID。父子进程除了地址空间、数据代码，栈和堆空间相同外，其共享文件分享的是同一份共享文件，比如共享库，当然打开文件表也是复制，继承了下来。 一个子进程因某种原因终止时，它被保持在一种已终止的状态，直到被他的父进程所回收。当子进程终止时，内核发出子进程终止的信号给父进程（默认行为是忽略，可以编写函数处理）。当父进程回收子进程后，内核将子进程的退出状态传递给父进程，然后抛弃掉已终止的进程。至此进程就消失了。一个终止但是没有被回收的进程称为僵死进程。 如果父进程终止了，内核会安排init来成为子进程的养父。init是所有进程的祖先，PID为1，它不会终止。 execve()是用新的程序在当前进程的上下文中加载并运行一个新的进程，也就是说原来的进程程序已经没了，exceve()不返回。同时新进程继承了原来程序的PID，地址空间，文件描述符。 进程命令#等待进程结束 P518 pid_t waitpid(pid_t pid, int *statusp, int options) pid_t wait(*statusp) #休眠 sleep(unsigned int secs) #返回0或者被信号中断而返回时还需要的休眠的时间 加载并运行程序一个典型的程序运行开始的创建的用户栈。从高往低看，首先是环境变量字符串和命令行字符串，之后是指向环境变量的指针数组和指向命令行变量的指针数组。之后是libc_start_main系统启动函数的栈帧，该函数负责初始化和调用main函数。最后是未来即将创建的main函数的栈帧。 main的三个参数： argc: argv[]数组的非空指针的数量 argv: argv[]数组的第一个条目 envp：指向envp[]数组的第一个条目 常见函数 char *getenv(const char *names); int setenv(const char *name, const char *newvalue, intoverwrite); void unsetenv(const char *name); 信号 信号就是一条小消息，通知进程系统中发生了某种事件。信号可由进程kill发出，或者系统内核检测到了某个事件而发出。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户程序不可见。程序出现出了某种异常或者事件，内核就会发一条信号给程序或者可能是父进程。 dump core:把代码和数据的映像写到磁盘上。过程的主存用core memory（磁芯存储器）实现。 信号的发送，接受和处理内核通过更新上下文的某个状态来发送信号。内核发送信号可能是讷河检测到一个系统信息，或者kill函数显示的要求内核发送信号。 按信号值小为优秀，查看未被阻塞的待处理信号的集合（pending &amp; ~blocked）进程接收到信号后，可以选择忽略，或者终止，又或者调用信号处理程序（signal handler）的用户层函数来捕获这个信号。 可以通过singal()修改信号相关联的行为。 没有被处理的信息称之为待处理信号。内核为每个向量维护了一个pending向量来保存每一个待处理信号的集合。只要传递了信号，对应pending位就被设置，只要接受了一个第$k$位的信号，pending就会清除pending向量的第$k$位。 信号可以被堵塞，被堵塞的信号可以发送，但是产生的待处理信号无法被接受，直到取消对这种信号的阻塞。blocked位向量维护者被堵塞的信号的集合。 每个信号只会被接受一次，每个位只能接受一次对应信号，也就是说多余的信号无法被检测出来。 不要尝试用信号来计数……因为这并不准确。 信号编程 Waiting for my laziness. 这部分不错的，以后再总结吧","link":"/2020/08/27/cs/csapp/csapp-bi-ji-8-yi-liu-kong-zhi/"},{"title":"CSAPP笔记-虚拟内存","text":"CSAPP的虚拟内存章节的前半部分主要讲述虚拟内存的实现细节和运转原理，其后半部分主要学习Linux的虚拟内存管理。 Linux虚拟内存系统Linux将虚拟内存分为一个个区域（area），所谓区域就是一片连续的虚拟页。Linux允许区域之间存在空隙，而空隙中的页面不被内核记录，也不占据任何空间。 内核为每个进程维护一个task_struct任务结构，任务结构包含内核运行进程所需的所有信息，比如PID，指向用户栈的指针，可执行目标文件的名字和程序计数器的值。task_struct中mm指向mm_struct，其中pgd指向第一级页表的基址，其值在进程运行时存放在页表基址寄存器中。mmap指向vm_area_structs的链表，每个单元记录了一个区域的信息。 mm_start. Points to the beginning of the area. vm_end. Points to the end of the area. vm_prot. Describes the read/write permissions for all of the pages contained in the area. vm_flags. Describes (among other things) whether the pages in the area are shared with other processes or private to this process. vm_next. Points to the next area struct in the list. Linxu缺页异常管理MMU在试图翻译某个虚拟地址A时，触发一个缺页异常，将控制转移给缺页处理程序。缺页处理程序随即遍历区域结构的链接，通过比较vm_end和vm_start来得出地址是否合法。否则触发一个段错误。继续，判断读取页是否有因为写仅读页，用户模式下读内核区域等问题导致的缺页异常，如果是爆出保护异常。否则，最后循规蹈矩的从磁盘读入所缺的页，如果物理页满了，就淘汰替换一页。缺页处理程序返回后，CPU重新启动引起缺页的程序的指令，重新读取所缺的页面。 内存映射内存映射（memory mapping）：将虚拟内存区域与一个磁盘上的对象（object）关联起来，以初始化这个区域。linux可以把文件系统的普通文件和匿名文件映射到虚拟内存中。前者比较显然，后者的匿名文件是内核创建的全零文件，如果CPU引用该文件，内核就会寻找一页合适的并修改为全零页。 值得注意的是，一旦虚拟页被初始化了就会在交换区域（交换文件或者交换空间）交换，也就是说交换空间的大小限制了实际是虚拟页的总量。 再看共享对象在内存映射的基础上，我们可以方便地把共享对象映射到不同进程的不同虚拟空间内，同时保持只有一份单独共享对象的副本。但是这带了一个问题：任何一个进程都无法对共享对象进行写（除非每个进程都同意），而写时复制（copy-on-write）的技术提供了解决方案。任何一个进程对共享对象的写时，把要写的部分复制到内存的另一页上，并修改映射到写的那页。如此一来，通过延迟私有对象或者共享对象的副本直到最后一刻，写时复制最充分地利用了稀有的物理内存。 再看fork函数父进程调用fork创建子进程时，内核为新进程创建task_struct数据结构，其mm_struct内容，页表内容和父进程一致。他将两个进程的每个页面标记为只读，并将两个进程的每个区域结构标记为私有的写时复制。也就是说当进程进行写操作的时候，写时复制机制就会创建新页面，也就为每个页面保持了私有地址的抽象概念。 再看execve函数execve函数在原有进程中加载可执行文件，创建新进程。它需要以下几个步骤： 删除已有的用户区域 映射私有区域：为新程序的代码、数据、bss和栈区域创建新的区域结构。当然所有的区域都是私有的、写时复制的。bss区域是请求二进制零的，映射到匿名文件。栈和堆区域也是请求二进制的，长度为零。 映射共享区域 设置程序计数器 mmap函数也可进行用户级内存映射动态内存分配动态内存分配常见于new，malloc。其底层都是动态内存分配器维护虚拟内存中的堆，它将堆看做多个许多页组成的块（block）。块要么是已经被程序使用的已分配块，要么是处于空闲状态的块。 分配器有两种实现； 显式分配器（explicit allocator）：要求显式地分配和释放任何块。比如free和malloc。 隐式分配器（implicit allocator）：也称垃圾收集器（garbage collector）。它会自动检测一个分配块何时不被程序所使用并将其释放。 常见的C动态申请函数void *malloc(size_t size)：动态申请变量。 void *alloc(size_t size)：基于malloc的瘦包装函数，将分配的内存初始化为零。 void *sbrk(intptr_t incr)：通过内核指针brk来增加incr来扩展和收缩堆。 brk指示了堆的上界。不 void free(void *ptr)：释放对应内存。 隐式空闲链表大多数分配器将块的信息嵌入块中以便于区分块的边界，大小。如下图所示，一个典型的块的前4b是头部，包含了块的大小和是是否被分配的标识，之后就是负载，最后一部分是用于对齐的填充内容。 隐式空闲链表就是用首部信息来确定下一个块的位置，可实现单向顺序遍历。注意，这里的链表是包含了已分配块。 由于系统对齐要求，块的最小大小=min(首部+填充，首部+内容+填充)；填充部分要求块的大小满足对齐要求。 如何寻找空闲块也是拥有多种分配策略，比如首次适配，下一次适配和最佳适配。 合并空闲块有分配空闲块可以选择把整块空闲块分配给对象，也可以根据对象的大小分配一定大的内容，将剩余的部分当做空闲块加入空间链表。释放内存后，自然会多出一块空闲块 ，这又涉及了空闲块的合并。合并可以简单的想：当空闲块出现就立即与周围临近空闲块合并。值得注意的是，追求优秀性能的动态分配器是以某种形式推迟空闲块合并的。 为了让空闲块与上一块的空闲块快速合并，提出了带脚步的块格式。这种改进虽然将编译所有块的复杂度降到了常数级的复杂度，但是增加了块的无效载荷，产生了显著的内存开销。有一种更优雅的优化方法，保持空闲块的脚步，对于已分配块，取消脚部，同时将已分配/空闲的FLAG写到低位空白位中。这样就节省了已分配的脚部开销。 显式空闲链表顾名思义，显式空闲链表把对上下空闲块的地址放在块中，记为pred和succ。 显然的，显式空闲链表增大了最小块的大小，也潜在的提高了内部碎片的程度。 分离的空闲链表分离的空闲链表利用了分离存储的技术，同时维护多个大小一致或者差不多的空闲块链表。其中大小差不多的块分成一些等价类，也叫做大小类。 简单分离存储：每个大小类的空闲链表包含着大小完全相同的空闲块。动态分配器将不分割的方式，直接把整个块分配出去，同时对释放空闲块也是直接回收空闲块。其优点在于分配和释放的常数时间操作。但是容易造成外部和内部碎片。 分离适配：为了分配一个块，必须确定请求的大小类，并对适当的空闲链表做首次适配，查找一个合适的块、如果找到了一个，那么就把他分配出去，并且把剩余的块插入适当的空闲链表上…… 伙伴系统：属于分离适配的一个特例，每个块的体积都是2^K。每一个块可以分割为一样大的小块，这就是所谓的伙伴，显然的，这两个伙伴的距离相邻，合并操作简单。由于块的大小限制，不适合通用的任务。 垃圾回收垃圾回收机制的原理在于它把内存看做一张可达图，图中存在根节点和堆节点，根节点可能是寄存器、栈或者是读写数据区域内的全局变量，总是就是不在堆中的变量。如果有有向边$p\\rightarrow q$，则代表变量$p$指向变量$q$。如果有从根节点出发到某一节点$k$，那么我们称$k$是可达的。对应的不节点属于被遗忘的变量，它应该被回收。 在分配的空闲块时，malloc函数如果没有拿到做够的空间，就会调用垃圾回收器，以便收集一些垃圾到空闲链表。如果空间还是不够，那就只能再申请空间给堆。 由于C++指针不会显式指出存放在内存中的变量是否是指针，那么非指针变量也可能是一个指针，所以C++的垃圾回收机制必须采取保守策略，将每个被指向被分配的在堆中的变量当做可达的！即使实际上变量可能是不可达的。 Mark &amp; Sweep 垃圾收集器算法过程如下： Mark阶段：遍历每一个根节点，并扫描其所指引的堆节点。扫描过程中，遍历节点的每一个字，并递归调用，尝试访问新的可行性节点。如果节点可达，那么标记一下。 Sweep阶段：遍历堆中每一个节点，如果没有被标记过，那么就回收掉。 C程序中常见的与内存相关的错误 引用野指针 读未初始化的内存 栈缓冲区溢出（局部变量数组溢出） 假设指针和指向的对象大小相等 数据访问\\赋值位置溢出 引用指针非而指向的对象 指针运算错误 函数外引用函数内的非static局部变量 引用堆中释放掉的数据 内存泄漏","link":"/2020/08/30/cs/csapp/csapp-bi-ji-9-xu-ni-nei-cun/"},{"title":"数据库管理复习梗概","text":"参考书籍：《数据库系统教程》3Ed. 施伯乐 基本概念概览 数据库（DateBase，DB）：长期存储在计算机内的数据集合 数据库管理系统（DataBase Mangement System, DBMS）：管理数据库的软件，其操作包括CRUD。 数据库系统（DataBase System，DBS）：由计算机软硬件和数据资源组成的计算机系统。 实体联系（Entity Relationship，ER）模型：对实体和实体之间关系的抽象。 概念模型：对用户需要的建模，往往建立出了ER模型。 逻辑模型：表达了数据库整体逻辑的模型。最重要的是关系模型，对象模型，还包括层次模型、网状模型。 逻辑独立性：应用程序与数据库的逻辑结构保持独立，即数据库的逻辑结构由DBMS即使变化了，应用程序也无需变化。 物理独立性：应用程序与数据库的物理结构保持独立，即数据库在磁盘的保存格式有数据库管理系统设置，应用程序无需关注数据库的物理结构。 两种独立性都是将数据在磁盘中的定义和存储格式独立分离出去，因而简化应用程序编程，减少了程序维护和修改。 关系模型 关系模型：简单理解为一个二维表格 子模式：用户需要用到数据的描述（？） 记录\\元祖：表格中的一行数据 关系\\实例：元祖的集合 字段\\属性：表的一列的列本身 元数：属性的个数 基数：元祖个数 关键码\\key\\键：字段或者字段的集合 超键（super key）：可以唯一标识元祖的键 候选键（Candidate key）：不含多余属性的超键 主键（Primary key）：用户选择的候选键 外键（Foreign key）：其他关系模型的主键 完全性规则（*表示省略相同成分）： 实体：主键不可缺 参照：外键指向的元祖不可空 用户：用户可自己定义完整性 关系代数 并：两个关系模型的去重合并 差：关系模型AB相减 笛卡尔积：两个关系模型的全排列 投影：选择一个关系模型若干列 选择：选择一个关系模型的若干行 ———— 交：求两个关系模型的公共元祖 连接：筛选出符合条件的两个模型的笛卡尔积 自然连接：条件是公共字段相同的连接，并去除公共字段 除法：A/B即尽可能 包含了所有B字段的且除了B字段A字段值相同的元祖集合。（简要的记忆为寻找公因数） ———— 改名 广义投影：允许投影中使用算术运算 外连接：就是把自然连接过程中丢失的元祖加以填充空值（NULL）并加入自然连接的结果 左（右）外连接：类似于外连接，就是把单单是左（右）边的模型丢弃掉的元祖加入 半连接：自然连接后投影到一个关系模型（不残缺的那边）上 SQL语句术语 基本表：关系模式 表的三种类型： 基本表：实际存储在数据库中的表 视图：若干表和其他视图组成的表的定义，在用户面前都是一样的 导出表：查询导出的表 存储文件：存储模式（文件存储的方式） 视图：子模式 行：元祖 列：属性 SQL模式（schema）：表和约束的集合（可能有多个表） 操作模式创建：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; 模式撤销：DROP SCHEMA &lt;模式名&gt; [CASCADE | RESTRICT] ; CASCADE即级联式，撤销下属的模式中所有的基本表、视图、索引；RESTRICT即约束式，仅当模式不存在任何下属元素才允许撤销；（SCHEMA可以替换为DATABASE） 添加自定义类型：CREATE DOMAIN &lt;YOUR_DOMAIN&gt; CHAR(8)这里把CHAR(8)定义成了自定义的domain名，可直接使用 创建基本表： CREATE TABLE &lt;基本表名&gt; ( --列表类型 T# CHAR(4) NOT NULL, --默认允许空值（与主键定义冗余） TITLE CHAR(10), -- 完整性约束 PRIMARY KEY(T#) -- 定义主键 FOREIGN KEY(C#) REFERENCES S(C#) --定义外键为C#，且对应S表的主键C# ); 插入数据： INSRET 修改基本表： --增加表的列 ALTER TABLE &lt;基本表名&gt; ADD &lt;列名&gt; &lt;类型&gt; --删除表的列 ALTER TABLE &lt;基本表名&gt; DROP &lt;列名&gt; [CASCADE | RESTRICT ] -- CASCADE表明删除列的同时删除所有使用该列约束和视图 --修改列形状 ALTER TABLE &lt;基本表名&gt; MODIFY &lt;列名&gt; &lt;类型&gt; 撤销基本表： DROP TABLE &lt;基本表名&gt; [ CASCADE| RESTRICT] --同理 索引：？？ 数据查询： --- 基本sql查询语句 SELECT 属性1,属性2.....属性n FROM 表1,表2......表N WHERE 关系表达式 ---sql语句之间可以使用UNION（并） \\ INTERSECT（交） \\ EXCEPT（差） ----嵌套查询，括号中的子查询优先进行 SELECT 属性1,属性2.....属性n FROM 表1,表2......表N WHERE 关系表达式 IN ( SQL查询语句 ) ---嵌套查询的速度往往比笛卡尔积的运算速度快 待补充：更复杂的还有相关子查询（。。）、where使用的运算符,以及（P85~P101） 关系数据库的规范设计基本概念函数依赖（FD，Functional Dependency）：当一个基本表中的属性集Y是属性集X的”函数值”(即X的值可以确定出唯一的Y)，就说明了X-&gt;Y,或者说Y依赖于X，这个基本表存在函数依赖。 （函数蕴涵P120） 逻辑蕴涵：若函数依赖集合F中存在的FD X→YX→Y和Y→ZY→Z，存在X→ZX→Z成立，则可称为F逻辑蕴涵X→ZX→Z 。 闭包： 就是函数依赖集上FF所有函数依赖和逻辑蕴涵推出来的依赖关系的完整集合，即为F+F+ 闭包。 FD推理规则： A→BA→B 自反性：AA自身能确定出自身的子集，这样推导出来的FD也称平凡的FD 增广性：依赖两边可以同时增加变量 传递性：可传递（逻辑蕴涵） ———— 合并性：同时能推导出两个结果BCBC，就能推导出两个结果的和B,CB,C 分解性：与合并性相反，是将结果BCBC拆分成两个B,CB,C 伪传递性：传递过程中需要添加一个因素，X→Y,YZ→WX→Y,YZ→W 等价于XZ→WXZ→W 复合型：两个FD可以两边组成成一个FD ———— 可以使用FD的定义来定义超键和候选键 当函数依赖集的闭包相等时，函数依赖集等价。可定义最难小函数依赖集： FD右边都是单属性； 无冗余FD FD的左边的属性集不是冗余的（子集无法代替集 求出R的最小依赖集算法 分解FD的右边属性集，并去重 消除左边冗余的FD 消除R中冗余FD 模式分解特性 无损分解：把数据库模式分解为多个模式，并将分解的模式全部自然连接发现多出了元祖（寄生元祖）（也就是有损分解，实际上是信息的丢失，信息论！不确定性越大，信息量越小）。反之如果元祖不多不少就是无损分解。 上述讨论中假设模式存在一个“范关系”rr，可以分解为多个子关系rkrk。 当然也存在不存在范关系的rr，在连接过程中某个riri子关系的元祖会被丢失掉，这个被称为破环范关系的悬挂元祖 依赖保持：就是分解的模式中的依赖的并与原模式的依赖等价。 无损分解的测试方法：略（p128） 保持函数依赖的分解：略（p129） 关系模式的范式第一范式：关系模式的R的关系r的属性值都是不可分的单一的（反例“AB”） 第二范式：每个非主属性完全依赖于候选键（挺严格的）。不完全依赖也就是局部依赖意味着A→BA→B 这个条件存在BB依赖于AA的一个子集，（注意这个FD推理规则A1不一样） 主属性：关系模式中R的候选键中的属性 化解成第二范式的算法：将一个局部依赖X→YX→Y的属性XYXY提出来形成一个关系，同时在原有属性集UU形成一个新的关系U−YU−Y；重复上述动作直到没有局部依赖。 第三范式：每个非主属性都不传递依赖与候选键，即为第三范式 传递依赖就是：X→Y,Y→ZX→Y,Y→Z 且X不依赖与Y，Z不是Y的子集 BC范式： 每个主属性不都传递依赖于候选键，则为BC范式。（相比于第三范式排除了主属性对候选键的传递依赖） 分解方法：略（p134） 数据库设计和ER模式数据库设计过程： 规划：调查、可行性分析等 需求分析：分析用户活动，系统范围，分数用户数据，数据流图；数据字典(描述数据) 概念设计：数据抽象设计局部概念模型和全局概念模型（比如ER） 逻辑设计：把上一步概念模型转化符合具体DBMS的逻辑模型，比如关系模型；设计外模型（api接口）；评价模型；修正模型 物理设计：存储记录结构设计；确定存储位置；完全性和安全性考虑； ER图组成结构： 实体：数据对象 联系：实体之间的关系 元数\\度数（degree）：联系所涉及的实体个数 数值约束： （x,y）表示该实体的联系的另一方的数量限制 N或者：表示对实体在联系中的映射数量关系 参与约束： 双直线：完全参数该联系 单直线：部分参与该联系 属性：实体的特征 简单属性和复合属性：在于可不可分 单值和多值属性：在于可不可同时取多个值 替换： 多值属性替换为一个新的实体类型 用多个单值属性代替 ER转关系模型的算法： 实体直接转化为一个关系 关系的转化方法 一元关系直接转化属性 1：1关系转化为一个实体的外键和属性 1：N关系转化”N处”实体的外键和属性 N:M关系转化为两个实体的主键和一个属性 ———— 三元关系可类比二元关系的转化方法（太无聊了不看了） 数据库存储结构文件组织定长存储：连接方法和顺序方法 不定长存储解决方案： 字符串表示形式：分槽式页结构（定长的首部顺序排列并记录剩余数据的其实起始地址，不定长的二进制数据从低端生长） 变长记录的定长表现形式：预留空间、固定块的溢出块相补充、定长块的连接形式（p187） (不想看了555)","link":"/2020/08/07/cs/db/shu-ju-ku-guan-li-fu-xi-geng-gai/"},{"title":"AVL","text":"老模板了 /** This is Code of JJ Problem :AVL tree Source : Solution : AnyDetial : DateAndTime :5,18 CostofTime :17:07 **/ #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; using namespace std; struct Node{ int data, height; Node *lchild, *rchild; Node(int x) { data = x; height = 1; lchild = NULL; rchild = NULL; } }; int getHeight(Node *root) { if(!root) return 0;//! child node may be is NULL. else return root-&gt;height; } int getHeightFactor(Node *root) { return getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild); } void updateHeight(Node *root) { root-&gt;height = max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild)) + 1;//!!! add 1 } void search(Node *root, int x) { if(!root) return; if(root-&gt;data==x) { printf(&quot;%d\\n&quot;,x); } else if(root-&gt;data&gt;x) { search(root-&gt;lchild,x); } else search(root-&gt;rchild,x); } //! right rotate void r_rotate(Node *&amp;root) { cout&lt;&lt;&quot;R\\n&quot;; Node* tmpr = root-&gt;lchild; root-&gt;lchild = tmpr-&gt;rchild; tmpr-&gt;rchild = root; updateHeight(root);//!!!update the height of tree updateHeight(tmpr); root = tmpr; } //! left rotate void l_rotate(Node *&amp;root)///!!! left rotating replace root with root's right child. { cout&lt;&lt;&quot;L\\n&quot;; Node* tmpr = root-&gt;rchild; root-&gt;rchild = tmpr-&gt;lchild; tmpr-&gt;lchild = root; updateHeight(root);//!!!update the height of tree updateHeight(tmpr); root = tmpr; } void insert(Node *&amp;root, int x) { if(root==NULL) { root = new Node(x);; return; } else if(root-&gt;data&gt;x) { insert(root-&gt;lchild,x); }else{ insert(root-&gt;rchild,x); } //!!you should update the weight after changing the number or the height of root and child; updateHeight(root); if(getHeightFactor(root)==2) { if(getHeightFactor(root-&gt;lchild)==1) { r_rotate(root);//!!! change the root }else if(getHeightFactor(root-&gt;lchild)==-1) { l_rotate(root-&gt;lchild); r_rotate(root);//!!! change the root } } else if(getHeightFactor(root)==-2) { if(getHeightFactor(root-&gt;rchild)==-1) { l_rotate(root);//!!! change the root } else if(getHeightFactor(root-&gt;rchild)==1) { r_rotate(root-&gt;rchild); l_rotate(root);//!!! change the root } } } Node *create(int a[], int n) { Node * root = NULL; for(int i=0;i&lt;n;i++) { insert(root,a[i]); } return root; } void preorder(Node *root) { if(!root) return; printf(&quot;%d &quot;,root-&gt;data); preorder(root-&gt;lchild); preorder(root-&gt;rchild); } void pr(Node *root) { if(!root) return; printf(&quot;data: %3d h:%d\\n&quot;,root-&gt;data,root-&gt;height); pr(root-&gt;lchild); pr(root-&gt;rchild); } int main() { int a[10]={1,2,3,4,5,6,7,8,9,10}; Node *root = create(a,10); // preorder(root); pr(root); }","link":"/2020/08/07/cs/ds/avl/"},{"title":"二叉查找树实现","text":"二叉查找树的一个实现 尤其注意删除那一部分的逻辑！ /** This is Code of JJ Problem : Source : Solution : AnyDetial : 注意点： 1.递归边界是root为NULL 2.插入： 查找失败--NULL--即为插入点 利用插入创建时，第一个数据就是查找失败的点！ 3.层序遍历：队列里存的是地址； DateAndTime : CostofTime : **/ #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;stack&gt; using namespace std; struct Node{ int data,layer; Node *lchild,*rchild; Node() { lchild = NULL; rchild = NULL; } Node(int a) { data = a; lchild = NULL; rchild = NULL; } }; // Node* newnode(int a)//! create a node with new! { return new Node(a); } //! find those nodes whose data is x and replace those data with x; void search_node(Node* root, int key, int x) { if(root==NULL) return; if(root-&gt;data==key) root-&gt;data = x;//! a -&gt; data ! search_node(root-&gt;rchild,key,x); search_node(root-&gt;lchild,key,x); } void insert(Node *&amp;root, int x) { if(root==NULL)//! The { root = newnode(x); return; } if(root-&gt;data&gt;x) { insert(root-&gt;lchild,x); }else{ insert(root-&gt;rchild,x); } } Node* create(int a[], int n) { Node *root = NULL;//!the index begin with 0; for(int i=0;i&lt;n;i++) { insert(root,a[i]); } return root; } void preorder(Node *root) { if(root==NULL) return;! printf(&quot;%d &quot;,root-&gt;data); preorder(root-&gt;lchild); preorder(root-&gt;rchild); } //!可用于递归赋值父节点信息和遍历输出根到所有节点的路径 Node *path[1000]; int pos = -1; void preorder_withrint(Node *root) { if(root==NULL) return; path[++pos] = root; // cout&lt;&lt;pos&lt;&lt;endl; for(int i=0;i&lt;pos;i++) printf(&quot;%d &quot;,path[i]-&gt;data); printf(&quot;%d\\n&quot;,path[pos]-&gt;data); // printf(&quot;%d &quot;,root-&gt;data); preorder_withrint(root-&gt;lchild); preorder_withrint(root-&gt;rchild); pos--; } void inorder(Node *root) { if(root==NULL) return; inorder(root-&gt;lchild); printf(&quot;%d &quot;,root-&gt;data); inorder(root-&gt;rchild); } //!错误代码 ： 此代码无法识别已经某一节点右节点是否已经压入过栈，而陷入无限循环之中 void inoder_withrecursion(Node *root) { cout&lt;&lt;&quot;Worry Code!\\n&quot;; Node *q; stack&lt;Node*&gt; s; s.push(root); while(!s.empty()){ getchar() ;q = s.top(); if(q-&gt;lchild)//!一个错误点 s.push(q-&gt;lchild); else{ printf(&quot;%d &quot;,q-&gt;data); s.pop(); if(q-&gt;rchild) s.push(q-&gt;rchild); } } } void postorder(Node *root) { if(root==NULL) return; inorder(root-&gt;lchild); inorder(root-&gt;rchild); printf(&quot;%d &quot;,root-&gt;data); } void layerorder(Node* root) { if(root==NULL) return; queue&lt;Node*&gt;q; q.push(root); while(!q.empty()) { Node *t = q.front(); q.pop(); printf(&quot;%d &quot;,t-&gt;data); if(t-&gt;lchild!=NULL) q.push(t-&gt;lchild); if(t-&gt;rchild!=NULL) q.push(t-&gt;rchild); } } int layerorder_withlayer(Node* root) { if(root==NULL) return 0 ; int Nol = 0,Non = 0,maxn = 0; queue&lt;Node*&gt;q; root -&gt; layer = 1; q.push(root); while(!q.empty()) { Node *t = q.front(); if(t-&gt;layer!=Nol){ Nol = t-&gt;layer; Non = 1; cout&lt;&lt;&quot;?&quot;; }else Non ++; maxn = max(Non,maxn); q.pop(); printf(&quot;%d %d\\n&quot;,t-&gt;data,t-&gt;layer); if(t-&gt;lchild!=NULL) { t-&gt;lchild-&gt;layer = Nol + 1; q.push(t-&gt;lchild); } if(t-&gt;rchild!=NULL){ t-&gt;rchild-&gt;layer = Nol + 1; q.push(t-&gt;rchild); } } return maxn; } //!前序遍历和中序遍历重建树 Node *create_in_pre( int inorder[], int inl, int inr, int preorder[], int prel, int prer)//! in[l,r], pre[l,r], { if(inl&gt;inr || prel&gt;prer) return NULL; int pos_in = inl; for(;pos_in&lt;=inr;pos_in++) { if(inorder[pos_in]==preorder[prel])// find the index of root break; } int numleft = pos_in - inl;// the number of left tree; Node *root = newnode(preorder[prel]); root-&gt;lchild = create_in_pre(inorder, inl, pos_in-1, preorder, prel+1, prel+numleft); root-&gt;rchild = create_in_pre(inorder, pos_in+1, inr, preorder, prel+numleft+1, prer); return root; } //!后序遍历和中序遍历重建树 Node *create_in_post(int in[],int inl, int inr, int post[], int postl, int postr) { if(inl&gt;inr) return NULL; Node *root = newnode(post[postr]); int pos = inl; for(;pos&lt;inr;pos++) { if(in[pos]==root-&gt;data) break; } int k = pos - inl; root-&gt;lchild = create_in_post(in,inl,pos-1,post,postl,postl+k-1); root-&gt;rchild = create_in_post(in,pos+1,inr,post,postl+k,postr-1); return root; } int main() { int a[1000] = {1,3,-2,5,7,-10,15,0} ,n = 8; Node *root = create(a,n); // preorder(root); cout&lt;&lt;endl; inorder(root); cout&lt;&lt;endl; // inoder_withrecursion(root); preorder_withrint(root); cout&lt;&lt;endl; // postorder(root); // cout&lt;&lt;endl; // layerorder(root); // cout&lt;&lt;endl&lt;&lt;&quot;max of Layer\\n&quot;&lt;&lt; endl; // cout&lt;&lt;layerorder_withlayer(root); // cout&lt;&lt;endl; // int pre[10] = {1 ,-2 ,-10, 0, 3 ,5 ,7 ,15}; // int in[10] = {-10, -2, 0, 1, 3, 5, 7, 15}; // int post[10] = {-10 ,-2, 0, 3, 5, 7, 15 ,1}; // // Node *newroot1 = create_in_pre(in,0,7,pre,0,7); // Node *newroot2 = create_in_post(in,0,7,post,0,7); // cout&lt;&lt;&quot;!recreate!\\n&quot;; // inorder(newroot1); // cout&lt;&lt;endl; // inorder(newroot2); }","link":"/2020/08/07/cs/ds/er-cha-cha-zhao-shu-shi-xian/"},{"title":"二叉树集合","text":"（好像不怎么用心的样子呢） /** This is Code of JJ Problem : Source : Solution : AnyDetial : 注意点： 1.递归边界是root为NULL 2.插入： 查找失败--NULL--即为插入点 利用插入创建时，第一个数据就是查找失败的点！ 3.层序遍历：队列里存的是地址； DateAndTime : CostofTime : **/ #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; using namespace std; struct Node{ int data; Node *lchild,*rchild; Node() { lchild = NULL; rchild = NULL; } Node(int a) { data = a; lchild = NULL; rchild = NULL; } }; // Node* newnode(int a)//! create a node with new! { return new Node(a); } //! find those nodes whose data is x and replace those data with x; void search_node(Node* root, int key, int x) { if(root==NULL) return; if(root-&gt;data==key) root-&gt;data = x;//! a -&gt; data ! search_node(root-&gt;rchild,key,x); search_node(root-&gt;lchild,key,x); } void insert(Node *&amp;root, int x) { if(root==NULL)//! The { root = newnode(x); return; } if(root-&gt;data&gt;x) { insert(root-&gt;lchild,x); }else{ insert(root-&gt;rchild,x); } } Node* create(int a[], int n) { Node *root = NULL;//!the index begin with 0; for(int i=0;i&lt;n;i++) { insert(root,a[i]); } return root; } void preorder(Node *root) { if(root==NULL) return;! printf(&quot;%d &quot;,root-&gt;data); preorder(root-&gt;lchild); preorder(root-&gt;rchild); } void inorder(Node *root) { if(root==NULL) return; inorder(root-&gt;lchild); printf(&quot;%d &quot;,root-&gt;data); inorder(root-&gt;rchild); } void postorder(Node *root) { if(root==NULL) return; inorder(root-&gt;lchild); inorder(root-&gt;rchild); printf(&quot;%d &quot;,root-&gt;data); } void layerorder(Node* root) { if(root==NULL) return; queue&lt;Node*&gt;q; q.push(root); while(!q.empty()) { Node *t = q.front(); q.pop(); printf(&quot;%d &quot;,t-&gt;data); if(t-&gt;lchild!=NULL) q.push(t-&gt;lchild); if(t-&gt;rchild!=NULL) q.push(t-&gt;rchild); } } //!前序遍历和中序遍历重建树 Node *create_in_pre( int inorder[], int inl, int inr, int preorder[], int prel, int prer)//! in[l,r], pre[l,r], { if(inl&gt;inr || prel&gt;prer) return NULL; int pos_in = inl; for(;pos_in&lt;=inr;pos_in++) { if(inorder[pos_in]==preorder[prel])// find the index of root break; } int numleft = pos_in - inl;// the number of left tree; Node *root = newnode(preorder[prel]); root-&gt;lchild = create_in_pre(inorder, inl, pos_in-1, preorder, prel+1, prel+numleft); root-&gt;rchild = create_in_pre(inorder, pos_in+1, inr, preorder, prel+numleft+1, prer); return root; } //!后序遍历和中序遍历重建树 Node *create_in_post(int in[],int inl, int inr, int post[], int postl, int postr) { if(inl&gt;inr) return NULL; Node *root = newnode(post[postr]); int pos = inl; for(;pos&lt;inr;pos++) { if(in[pos]==root-&gt;data) break; } int k = pos - inl; root-&gt;lchild = create_in_post(in,inl,pos-1,post,postl,postl+k-1); root-&gt;rchild = create_in_post(in,pos+1,inr,post,postl+k,postr-1); return root; } int main() { int a[1000] = {1,3,-2,5,7,-10,15,0} ,n = 8; Node *root = create(a,n); preorder(root); cout&lt;&lt;endl; inorder(root); cout&lt;&lt;endl; postorder(root); cout&lt;&lt;endl; int pre[10] = {1 ,-2 ,-10, 0, 3 ,5 ,7 ,15}; int in[10] = {-10, -2, 0, 1, 3, 5, 7, 15}; int post[10] = {-10 ,-2, 0, 3, 5, 7, 15 ,1}; Node *newroot1 = create_in_pre(in,0,7,pre,0,7); Node *newroot2 = create_in_post(in,0,7,post,0,7); cout&lt;&lt;&quot;!recreate!\\n&quot;; inorder(newroot1); cout&lt;&lt;endl; inorder(newroot2); }","link":"/2020/08/07/cs/ds/er-cha-shu-ji-he/"},{"title":"堆算法和堆排序","text":"堆排序#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; #include&lt;string&gt; using namespace std; vector&lt;int&gt; a, b; int n; void adjustDown(vector&lt;int&gt; &amp;arr, int x, int len){ for(int p = 2 * x; p &lt;= len; p *= 2){ if(p &lt; len &amp;&amp; arr[p] &lt; arr[p+1]) p++; if(arr[x] &gt; arr[p]) break; swap(arr[x], arr[p]); x = p; } } int main(){ cin &gt;&gt; n; a.resize(n + 1); b.resize(n + 1); for(int i = 1;i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n; i++) cin &gt;&gt; b[i]; int p = 1, ch; while(p &lt; n &amp;&amp; b[p] &lt;= b[p + 1]) p++; for(ch = p + 1; ch &lt;= n &amp;&amp; a[ch] == b[ch]; ch++); if(ch == n + 1){ cout &lt;&lt; &quot;Insertion Sort\\n&quot;; sort(a.begin() + 1, a.begin() + 2 + p); }else{ cout &lt;&lt; &quot;Heap Sort\\n&quot;; int k = n; while(k &gt; 0 &amp;&amp; b[k] &gt; b[1]) k--; swap(b[1], b[k]); adjustDown(b, 1, k - 1); a = b; } for(int i = 1; i &lt;= n; i++) if(i == n) printf(&quot;%d\\n&quot;, a[i]); else printf(&quot;%d &quot;, a[i]); } 完全堆排序#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; const int MAXN = 1e3; int heap[MAXN] = {0,3,14,7,12,13,4,5,20}; int n = 8; ///! down void downAdjust(int p,int len){ for(int x = p * 2; x &lt;= len; x += x){ if(x &lt; len &amp;&amp; heap[x] &lt; heap[x + 1]) x++; if(heap[x] &lt; heap[p]) break; swap(heap[x], heap[p]); p = x; } } // for(int i=1;i&lt;=n/2;i++) //! 叶子的一个下标是 n/2向下取整+1 //! 必须从底部开始调整，不然不能保持之前的子堆的有序性质 void buildHeap(){ for(int i=n/2; i&gt;=1; i--) downAdjust(i,n); } ///!delete element void deleteTop(){ heap[1] = heap[n--];//! n-- downAdjust(1,n); } ///!!!up void upAdjust(int p, int len){ for(int x = p /2 ; x &gt;= 1; x /= 2){ if(heap[x] &gt; heap[p]) break; swap(heap[x], heap[p]); p = x; } } void insert(int x) { heap[++n] = x; upAdjust(n,n); } void show() { for(int i=1; i&lt;=n; i++) cout&lt;&lt;heap[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;&quot;\\n&quot;; } ///! head sort void headSort(int n) { buildHeap(); for(int i=n; i&gt;=2; i--) { swap(heap[1],heap[i]); downAdjust(1,i-1);//!! heap only have n-1 elements; } } int main() { show(); buildHeap(); insert(25); show(); headSort(n); show(); }","link":"/2020/08/07/cs/ds/dui-suan-fa-he-dui-pai-xu/"},{"title":"数据结构知识点笔记","text":"（有时候确实读黑书应该读原著，中文翻译著作时常有些令人琢磨不透的表达） 复杂度O(f(N))O(f(N))表算法复杂度T(N)T(N)的函数上限，其ff增长率≥T(N)≥T(N)的增长率。 Ω(f(N))Ω(f(N))表算法复杂度T(N)T(N)的函数下限，其ff增长率≤T(N)≤T(N)的增长率。 Θ(f(N))Θ(f(N))表 ff的增长率等于TT的增长率。 o(f(N))o(f(N))表 ff的增长率&gt;T&gt;T的增长率。 表、栈和队列表或者说线性表的特征在于一组有次序（非大小有序的有序，这里指前后次序的序）的元素。实现物理结构： 链表 带头结点的链表 双链表 循环链表 多重表 数组 栈是删除和插入都在同一端点处进行的表。物理实现同样有链表和数组。 经典题目：后缀表示式计算、中缀转后缀 队列是队尾插入，队头删除的表。物理实现： 循环数组的队列 树树实际上只有一个源节点的DAG。最常见的如二叉查找树（限制了子节点和节点的关系的二叉树）、AVL、哈夫曼树 算法： 先序遍历、中序遍历、后序遍历 二叉查找树的创建、插入、删除 AVL树的旋转（四种）、插入、删除（调整 ） 展开树（p92？） m阶B树的性质 哈夫曼树 （Haffman） 实现： 儿子链表 兄弟儿子表示法 父亲表示法 经典题目：表达式树的创建 散列散列是将关键字映射到不同的数组单元DS。三个要点： 散列函数 消除冲突 分离链接法 开放定址法 线性探测法 平方探测法 双散列 再散列是重新建表重新映射到新数组 堆优先队列是用堆实现的保持堆序性的完全二叉树。 算法: 上浮、下滤、插入、删除；注意建堆的复杂度是O(N)O(N)。 其他数据结构（我的神啊p147？）： d-堆 左式堆 斜堆 二项队列 排序 插入排序 希尔排序 堆排序 归并排序 快速排序：枢纽元的一个有效选取办法就是三数中值，随机数代价高昂 桶式排序 外部排序： 順串的产生（优先队列 + 最小元素锚定），順串的合并（归并算法） 集合并查集算法 图论数据表示：邻接表、邻接矩阵、邻接多重表（无向图）、十字链表（有向图）算法： 拓扑排序 最短路径 无权图：遍历 非负权图：Dijkstra（最小堆优化） Dijkstra复杂度： 邻接矩阵实现：O(V2)O(V2) 邻接表实现：O(V2+VE)O(V2+VE) 堆优化实现：O(V∗log(V)+Elog(V))O(V∗log(V)+Elog(V))思考复杂度真是有趣 负权值图： 遍历：DFS，BFS 网络流问题 最小生成树：Prim，Kruskal 非双连通性的无向图割点问题：DFS 有向图？ NP问题NP问题值非确定性多项式时间问题，如果可以在多项式时间内验证一个问题的所有“对”为正确，那么该问题就是NP问题。而NP-完全问题就是NP问题在的一个子集，所有NP问题都可以通过映射转化为NP-C问题，所以NP-C问题是最难的。（。。。。。。。）","link":"/2020/08/07/cs/ds/shu-ju-jie-gou-zhi-shi-dian-bi-ji/"},{"title":"anki+GD单词解决方案","text":"Anki作为一款记忆神器，丰富的插件和本身的记忆原理相得益彰。这几天学习了一下其强大的功能，作为背单词的实用工具。本身只用Anki背诵单词，那么主要采取两种方法来快速生成导入单词卡片。 GoldDict + FastWordQueryGoldDict是一款俄罗斯大佬开发的开源单词软件，支持本地词典、在线词典，网页查词查询，拥有快捷键，收藏，取词查词支持等丰富功能，基本上已经覆盖了查词的任何需求。选择单词并Ctrl+C两次可快速查词，Ctrl+E可快速收藏，收藏后的单词支持导出为txt文件。 将txt文件的单词导入Anki软件后，后续可由Anki插件FastWordQuery快速查词并制作卡片。 FastWQ插件安装码 1807206748， 使用教程 推荐配置如下： image-20200503125952535 正面卡片模板如下: &lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97876&quot;&gt; &lt;section style=&quot;margin:10px auto;text-align: center;&quot;&gt; &lt;section style=&quot;display:inline-block;color:#f28461;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;text-align:right;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:70px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;https://bdn.135editor.com/files/images/editor_styles/de6c8d76ce15363fdd1b8feccfe81302.jpg&quot; data-ratio=&quot;0.3157894736842105&quot; data-w=&quot;475&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #fcbd6b;padding-right:5px;box-sizing: border-box;margin-top:-5px;&quot;&gt; &lt;section class=&quot;135brush&quot; data-brushtype=&quot;text&quot; style=&quot;border-right:1px solid #fcbd6b;letter-spacing:1.5px;font-size:16px;padding:8px 1.2em;box-sizing: border-box;&quot;&gt; {{单词}} &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;display:flex;justify-content:flex-end;align-items:center;border:1px solid #fcbd6b;box-sizing: border-box;border-top:none;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;;width:6px;height:6px;background-color:#fcbd6b;box-sizing: border-box;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97722&quot; &gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;text-align: center;&quot;&gt; &lt;section style=&quot;display:inline-block;border-top:1px solid #7f5c32;border-bottom:1px solid #7f5c32;padding:0px 0.1em;text-align: center;&quot;&gt; &lt;section style=&quot;background-color: #fffaf3;color:#7f5c32;padding:2px 4px;&quot;&gt; &lt;section style=&quot;display: flex;justify-content:center;align-items: center;&quot;&gt; &lt;section class=&quot;135brush&quot; data-brushtype=&quot;text&quot; style=&quot;letter-spacing:1.5px;font-size:16px;text-align: center;&quot;&gt; {{发音}} &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section class=&quot;_135editor&quot; data-role=&quot;paragraph&quot;&gt; &lt;p&gt; &lt;br/&gt; &lt;/p&gt; &lt;/section&gt; 背面卡片模板如下： &lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97713&quot;&gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;;width:28px;height:28px;background-color: #fff;color:#7f5c32;text-align:center;line-height:26px;border:1px solid #b68b58;box-sizing: border-box;font-size:18px;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt; 0&lt;span class=&quot;autonum&quot; data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt; &lt;/section&gt; &lt;section style=&quot;margin-top:-20px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;display:flex;justify-content: flex-start;align-items: center;&quot;&gt; &lt;section style=&quot;background-color:#b68b58;box-sizing: border-box;height:1px;flex:1;margin-right:3px;&quot;&gt;&lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px #b68b58; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-right:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;color:#7f5c32;padding:6px 6px 0px 6px;box-sizing: border-box;&quot;&gt; &lt;section data-autoskip=&quot;1&quot; class=&quot;135brush&quot; style=&quot;padding:10px;color:#7f5c32;text-align: justify;line-height:1.75em;letter-spacing: 1.5px;font-size:14px;&quot;&gt; &lt;p&gt; {{音标}} &lt;/p&gt; &lt;p&gt; {{释义}}&lt;/span&gt; &lt;/p&gt; &lt;/section&gt; &lt;section style=&quot;text-align: right;&quot;&gt; &lt;section style=&quot;width:35px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;http://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvN1FSVHZrSzJxQzVIaWFTRjdCcEVqU1c4MnFpYkxBZTRRMHRxY3EwNHRVV3U5Q3dod3JGWWlheWZHaWN0Yzkzc24xZzFOSE9ZS1BJZ1E3R3NvM0M2V2hNejVBLzA/d3hfZm10PXBuZw==&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97713&quot;&gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;;width:28px;height:28px;background-color: #fff;color:#7f5c32;text-align:center;line-height:26px;border:1px solid #b68b58;box-sizing: border-box;font-size:18px;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt; 0&lt;span class=&quot;autonum&quot; data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/span&gt; &lt;/section&gt; &lt;section style=&quot;margin-top:-20px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;display:flex;justify-content: flex-start;align-items: center;&quot;&gt; &lt;section style=&quot;background-color:#b68b58;box-sizing: border-box;height:1px;flex:1;margin-right:3px;&quot;&gt;&lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px #b68b58; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-right:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;color:#7f5c32;padding:6px 6px 0px 6px;box-sizing: border-box;&quot;&gt; &lt;section data-autoskip=&quot;1&quot; class=&quot;135brush&quot; style=&quot;padding:10px;color:#7f5c32;text-align: justify;line-height:1.75em;letter-spacing: 1.5px;font-size:14px;&quot;&gt; &lt;p&gt; {{例子}} &lt;/p&gt; &lt;/section&gt; &lt;section style=&quot;text-align: right;&quot;&gt; &lt;section style=&quot;width:35px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;http://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvN1FSVHZrSzJxQzVIaWFTRjdCcEVqU1c4MnFpYkxBZTRRMHRxY3EwNHRVV3U5Q3dod3JGWWlheWZHaWN0Yzkzc24xZzFOSE9ZS1BJZ1E3R3NvM0M2V2hNejVBLzA/d3hfZm10PXBuZw==&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97713&quot; &gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;;width:28px;height:28px;background-color: #fff;color:#7f5c32;text-align:center;line-height:26px;border:1px solid #b68b58;box-sizing: border-box;font-size:18px;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt; 03 &lt;/section&gt; &lt;section style=&quot;margin-top:-20px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;display:flex;justify-content: flex-start;align-items: center;&quot;&gt; &lt;section style=&quot;background-color: #b68b58; box-sizing: border-box; height: 1px; flex: 1 1 0%; margin-right: 3px; overflow: hidden;&quot;&gt;&lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width: 0px; height: 6px; border-bottom: 6px solid transparent; border-left: 6px solid #b68b58; overflow: hidden; box-sizing: border-box;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width: 0px; height: 6px; border-bottom: 6px solid #b68b58; border-left: 6px solid #b68b58; overflow: hidden; box-sizing: border-box;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width: 0px; height: 6px; border-bottom: 6px solid transparent; border-right: 6px solid #b68b58; overflow: hidden; box-sizing: border-box;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;color:#7f5c32;padding:6px 6px 0px 6px;box-sizing: border-box;&quot;&gt; &lt;section data-autoskip=&quot;1&quot; class=&quot;135brush&quot; style=&quot;padding: 10px; color: #7f5c32; text-align: justify; line-height: 1.75em; letter-spacing: 1.5px; font-size: 14px; box-sizing: border-box;&quot;&gt; &lt;p&gt; {{词形变化}} &lt;/p&gt; &lt;/section&gt; &lt;section style=&quot;text-align: right;&quot;&gt; &lt;section style=&quot;width:35px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;http://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvN1FSVHZrSzJxQzVIaWFTRjdCcEVqU1c4MnFpYkxBZTRRMHRxY3EwNHRVV3U5Q3dod3JGWWlheWZHaWN0Yzkzc24xZzFOSE9ZS1BJZ1E3R3NvM0M2V2hNejVBLzA/d3hfZm10PXBuZw==&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;script type=&quot;text/javascript&quot;&gt; var initVoice = function () { var player = document.getElementById('dictVoice'); document.addEventListener('click', function (e) { var target = e.target; if (target.hasAttribute('role') &amp;&amp; target.getAttribute('role').indexOf('dict_audio_js') &gt;= 0) { var url = target.getAttribute('data-rel'); player.setAttribute('src', url); player.volume = 1; player.play(); e.preventDefault(); } }, false); }; initVoice(); &lt;/script&gt; 预览 image-20200503130008304 Anki-connect + 在线词典助手面向网页浏览的英语语境单词学习，支持在线选词同时配合Anki-connect一键生成卡片到Anki。 开发者教程 anki-connect的插件获取码 2055492159 anki-connect默认不支持同词多次插入，修改教程在此。 在线词典助手 在线词典助手配置如下 image-20200503130021147 资源anki各种资源 有道风格模板","link":"/2020/08/07/code-tools/anki/anki-gd-dan-ci-jie-jue-fang-an/"},{"title":"Hexo建站","text":"Hexo + Github Page 建站方案终于开始了建站之旅，之前都是采用信息源（知乎+B站+RSS）-&gt;onenote笔记来记录知识点。随着时间的推移也发现更开源、令人兴奋的方法是写博客。一来是对自己要求提高了不少，写博客可不像自己随手摘的笔记, 要求严谨而逻辑清楚，二来便于分享知识和交往新胖友。 陆陆续续装了好久也踩了不少的坑，在今天2020.04.26写下这篇博文，记录博客的开端吧！ 必要工具安装首先有必要说明的是，Hexo建站不可避免的是Node等工具，不得不说Linux仍是建站初最好的环境，同时Window推出的WSL可以很好的提供Linux的包管理体验——真香。本蒻姬喜欢在用VSCODE + WSL来建站，同时使用原MD文件来渲染网页的Hexo还会保留MD文件，配合WSL文件可以被WINDOW访问的功能，可以直接使用VSCODE 和 Typora 写作——不要太方便。 Node.js建议安装比较新的版本，可以看Github上下载源码（linux）并按照指示操作。以下是我安装的软件版本。 ➜ _posts node -v v10.20.1 ➜ _posts npm -v 6.14.4 ➜ _posts hexo -v hexo: 4.2.0 npm作为强大的Node包管理工具可以使用以下命令安装。推荐阅读：npm简介。 sudo apt update sudo apt install npm 接下来安装hexo框架，hexo是静态页面博客框架，拥有丰富的主题资源和活跃的开发社区，很多Github Page的都是hexo搭建的，其中使用Next风格的网站尤其多~~~~~ hexo可使用npm全局安装，如下。 sudo hexo install hexo-cli -g # -g：global 最会自行安装git并配置好ssh哦。 建站hexo的使用逻辑是一键生成文章、页面、渲染页面、部署。在你想要存放建站文件的目录下运行以下命令可以初始化hexo博客文件。 hexo init [blog] #[$name]表name cd blog #局部安装hexo的指定本目录下的package.json的依赖包所指定的包 npm install 如果一切顺利的话，可以执行以下命令启动本地hexo服务器来测试是否安装成功。 hexo s #s: serve; 可选参数 -p 50100：指定监听端口 hexo可以通过以下命令来生成新文章——在source的_post文件下生成一个md文件。实际上hexo也会用这个md文件来渲染html页面，那就是后话了。在这里我非常推荐使用vscode自带的编辑器或者typero来编辑文件，尤其在文章的图片采取本地存储的情况下，typore支持直接插入图片并书写好合适的MD语句（typore扩展也支持图片上传服务器）。 #尽量避免 图片名、MD文件名出现空格，不然容易出BUG hexo new &quot;new-post&quot; 当当！如果一切就绪，新文章也写好了，可以把本地文件部署到Github Page上去了。在Github上新建一个用户名.github.io的仓库，可以尝试去访问你的网站用户名.github.io~ deploy部署配置——在本地bog文件下的hexo配置文件_config.yml的部分内容，注意这里的配置连接最好使用SSH连接——免密输入的基操。 deploy: type: git repository: 'git@github.com:yourName/yourName.github.io.git' branch: master 使用以下命令可以把本地文件直接部署到GIthub上了,真方便啊。 # npm install hexo-deployer-git 如果不能直接d的话，装一下插件 hexo d # 先生成再部署 更方便 hexo g -d 主题找了两三个很Nice的博客主题icarus，yun 和满大街的Next。其中安装教程详见官网。推荐阅读：可能是最最完整的博客搭建教程 Post！图片本地图片无法正常显示——本地图片引用网址多出了一个.com/，直到第二次重装工具和hexo这个问题曾经困扰才解决。图片在本地的放置方案如下： 设置_config.yml中的post_asset_folder: true ，以便在新建文章的时候同时生成可以放置图片同名文件夹。在MD文章中的图片引用格式为[](./fileName/picName.png)（注意，这两个名字不要带空格，不然有非常多的BUG，可以使用-代替）， 配合hexo-asset-image插件可以让HTML渲染的地址符合变化。 npm install https://github.com/7ym0n/hexo-asset-image --save 当然也有图床和OSS的解决方案，我这里暂时不去尝试，算是留一个坑。 个性化tags和categories设置文章的tags和categories可以在文章的yaml语段中书写，具体如下，官网介绍。 yaml 形如开头和结尾为三个横杠的键值对序列语段。 --- title: Hello World date: 2013/7/13 20:46:25 --- categories: #两层categories - [Sports, Baseball] - [MLB, American League, Boston Red Sox] - [MLB, American League, New York Yankees] - Rivalries tags: - Injury - Fight - Shocking 设置博客页面tags和categories hexo new page tags hexo new page categories 强烈推荐 安装hexo-auto-category插件，使用目录自动化生成category，一劳永逸！下载 添加目录确保themes/icarus/_config.yml中有 widgets: - # Widget name type: toc # Where should the widget be placed, left or right position: left 然后在文章头部添加标签 toc: true 阅读统计详见 文章置顶功能在themes/icarus/_config.yml配置 index_generator: path: '' per_page: 10 order_by: top: -1 date: -1 修改/⁨node_modules⁩/hexo-generator-index⁩/lib⁩/generator.js var paginationDir = config.pagination_dir || 'page'; // added code posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if(a.top &amp;&amp; !b.top) { return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; }); // end var path = config.index_generator.path || ''; 修改模板中的post.md，添加top属性并设置默认值为0 /scaffolds/post.md --- title: {{ title }} date: {{ date }} tags: top: 0 --- 最后，根据大家自己的喜好在前端添加标签咯~ /themes/icarus/layout/common/article.ejs &lt;% if (post.top&gt;0) { %&gt; &lt;i class=&quot;fas fa-arrow-alt-circle-up&quot; style=&quot;color:#3273dc&quot;&gt;&lt;/i&gt; &lt;span class=&quot;level-item&quot; style=&quot;color:#3273dc&quot;&gt;&amp;nbsp;置顶&lt;/span&gt; &lt;% } %&gt; 更多阅读现在已知最省事的还是直接在md文件中添加&lt;!-- more --&gt; 域名绑定在本地_post文件的新建文件CNAME(大小写一致)，写上需要绑定的域名,比如一个二级域名blog.yourhost.xyz。在购买域名的服务商那添加CNAME解析，比如原域名为A,主记录为blog,那么博客访问的地址如XXXXX.github.io就多了一个blog.yourhost.xyz。 这里注意，如果在github setting 添加域名绑定，要注意新的版本可能会移除掉CNAME文件。 添加缩略图到你的文章你可以用两个步骤来添加缩略图到你的文章。首先，确保主题配置文件中已经开启缩略图的功能： _config.yml article: thumbnail: true 文章的front-matter中提供一个图像的链接或路径： post.md thumbnail: /gallery/thumbnails/desert.jpg --- 目录表（Table of Contents / Catalogue）要在发布页显示目录表（toc）部件，请先在你文章markdown文件的front-matter中添加toc:true： --- post.md title: Table of Contents Example toc: true --- 接着，在主题配置文件添加toc部件： _config.yml widgets: - type: toc position: left front-matter模板在scaffolds/post.md中修改为 --- title: {{ title }} date: {{ date }} tags: - categories: [] thumbnail: http://static.come2rss.xyz/尼尔机械.jpg toc: true top: 10 --- &lt;!-- more --&gt; 添加自定义域名在public文件下添加CNAME文件。内容仅为需要映射的自定义域名。 添加评论系统Matery主题自带Gittalk模块，只需要配置Gittalk参数即可。Gittalk利用GitHup的repo中ISSUE功能，实现了全部用前端代码的强大评论功能。那么需要我们创建一个OAuth应用来存储评论信息，并且添加对应信息。 Homepage:博客地址 Authorization callback URL:存储评论的库地址 详细可以查看 接下来在hexo-theme-matery文件下的配置文件_config.yml中配置相关关键词repo、clientID、clientSecret等等。 常用命令部署步骤至此，部署到GitHub的工作已经完成，之后如果我们希望对自己的博客进行修改或者需要发布新的文章时，可以按以下三步进行。 $ hexo clean # 删除已经生成的静态页面 #下面两个命令可以简写为 hexo g -d $ hexo generate $ hexo deploy 命令总结常用命令hexo new &quot;postName&quot; #新建文章 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 hexo clean; hexo g -d; #清理已生成的页面，重新生成并部署。 启动本地服务器并监视文件变化，同时编译渲染。 hexo s --watch 命令简写hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 快速在新环境下搭建网站讲本地的源码上传到github的一个新分支hexocode中，与此同时，master保存着网页源代码，实现了快速下载hexo搭建配置的要求。上传内容不多阐述，注意库中库问题就行。 更多参考知乎内容 下载分支搭建环境更换电脑操作一样的，跟之前的环境搭建一样，安装gitsudo apt-get install git设置git全局邮箱和用户名 git config --global user.name &quot;yourgithubname&quot; git config --global user.email &quot;yourgithubemail&quot; 设置s sh keyssh-keygen -t rsa -C &quot;youremail&quot; 生成后填到github和coding上（有coding平台的话）验证是否成功 ssh -T git@github.com ssh -T git@git.coding.net #(有coding平台的话) 安装nodejssudo apt-get install nodejs sudo apt-get install npm 安装hexo sudo npm install hexo-cli -g 但是已经不需要初始化了，直接在任意文件夹下， git clone git@……………… 然后进入克隆到的文件夹： cd xxx.github.io npm install npm install hexo-deployer-git --save 生成，部署： hexo g hexo d 然后就可以开始写你的新博客了hexo new newpageTips:不要忘了，每次写完最好都把源文件上传一下git add . git commit –m &quot;xxxx&quot; git push 如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了 git pull 改进可能可以使用githook，比如pre-commit完成hexo部署时自动化提交本地配置变化。现在不做过多研究。 更新2021年1月28日 22:22:06插件 hexo-enchancer 推荐hexo-enhancer是一个Hexo功能增强插件。完全可以取代之前的hexo-auto-categories插件。 此插件支持的功能较多，并且未来会继续增加，可以理解为插件包。到目前为止，此插件支持的功能如下： 自动生成title：根据文件名自动生成标题。自动生成date：根据文件名自动生成日期，具体策略类似Jekyll。自动生成abbrlink：根据标题进行base32和crc32生成短链接。自动生成categories：根据文件的路径解析文章所属分类。自动生成tags：根据配置在_config.yml中的可用tags和keywords自动扫描文章中出现的标签。","link":"/2020/08/07/code-tools/blog/hexo-jian-zhan/"},{"title":"Tag和Categories的命名","text":"Tag和Categories的命名最近博客的博文多了起来，有时候如何命名Tag和分类成一个小小烦人的问题。决定记录一下刚刚思考的结果： 先写categories后写tag 依据博文内容来源和主题，而不是目的分categoreis categories的一个分类至少或者可能有多篇博客才可以开出 categories条目应尽量少，但是应该全 应当能完全分类 Tag应包括博文的描述主题，可以从不同维度联系，以便快速查找 比如刷题的一篇博文，写算法——二分，DFS，LCA等等 尽量不要使用categorie分类高级条目，保持内容的不重叠 其内容为缩写是全大写;单个单词或者词组的第一个字母大写；","link":"/2020/08/07/code-tools/blog/tag-he-categories-de-ming-ming/"},{"title":"md文件cdn加速","text":"ypore+七牛OSS\\CDN图片快速上传需要提前准备：一个备案好的主域名A，七牛认证过的bucket。 配置七牛CDN加速上传七牛的图片需要在CDN加速的域名处下载，为此需要在七牛的域名管理中添加自定义二级域名，比如static.A 。获取了七牛提供的解析域名值后在服务商出添加CNAME解析。 CNAME解析中主机值就是static.A的static，可能服务商在等等添加CNAME过程时间比较长，be patient. 配置Typore上传七牛Typore整合了图片上传工具ipicgo的功能，提供了ipic-core直接上传功能，只需要配置即可. 官方文档，picgo-Core中文文档 包括了七牛配置。 { &quot;picBed&quot;: { &quot;uploader&quot;: &quot;qiniu&quot;, // 代表当前的默认上传图床 &quot;qiniu&quot;: { &quot;accessKey&quot;: &quot;&quot;, &quot;secretKey&quot;: &quot;&quot;, &quot;bucket&quot;: &quot;&quot;, // 存储空间名 &quot;url&quot;: &quot;&quot;, // 自定义域名 &quot;area&quot;: /&quot;z0&quot; | &quot;z1&quot; | &quot;z2&quot; | &quot;na0&quot; | &quot;as0&quot;, // 存储区域编号, 这个一定要选对，不知道多试几次 &quot;options&quot;: &quot;&quot;, // 网址后缀，比如？imgslim &quot;path&quot;: &quot;&quot; // 自定义存储路径，比如 img/， 测试后好像没法使用 } }, &quot;picgoPlugins&quot;: {} // 为插件预留 } 使用我的方案是复制图片到固定文件夹FilePath/${filename}，实现图片的本地分类管理，并在编辑框中使用typore自身功能快键上传图片的七牛，同时typore会自动获取并替换图片连接URL。 当然也可以从七牛空间管理中复制图片外链（要求空间为公共）。","link":"/2020/08/07/code-tools/blog/md-wen-jian-cdn-jia-su/"},{"title":"博客内容书写","text":"关于博客内容的书写4月份搭建的静态博客近来水了不少文章，主要是个人笔记和编程联系。但是随着POST量的增加，我也逐渐反思博客的真正意义是什么？ 以前我把博客更多当成一个资料库，一个知识记录库，更像一个在线笔记本，只需要push好写完的文章，click一下也可以搜索到过去学习的内容。而现实的Github Page上令人窒息的访问速度和Icarus主题的静态文件的缓冲时间，让我开始怀疑方案的可行性。再重新以一个读者的视角来看待博客的存在价值，简单的学习内容的堆叠、蜻蜓点水的内容覆盖，并不适合个人的学习和深入挖掘，当然也不会有人想要有深入交流的想法。 以我的观察，那么常见的博客记录类型有哪些呢？ 记录工作状态、学习生活的心得感悟、目标规划乃至对于世界各个的思考 记录工作中学习中遇到的困难和解决方案为主的技术内容 刷题、阅读论文、学习新博客的学习记录、知识总结、方案比较 对技术或者知识点的教程、讲解 其中前三点其无非就是对个人生长的规划和感悟，对学习生活的总结和分享，正是我需要发展的方向。 ;）开始重新整理博客。 记于20205月份的一个下着小雨的中午。 但是如果不在这里写，貌似都没有地方可以写笔记了。其他工具的云同步和MD语法并不是支持地非常好。","link":"/2020/08/07/code-tools/blog/bo-ke-nei-rong-shu-xie/"},{"title":"谈谈笔记","text":"最近总是因为学习资料的存放和学习地方而烦恼，一来我是一个重度MD使用患者，极度喜爱使用简洁高效的MD文件形式和快速便捷的Typore软件，二来我需要一个快速而强大搜索能力的存储器具来安全的保存我的数据、笔记。 这么一来，安全性，便捷性，支持MD文件成了我需要的三个指标。为此我参考了多个市面上的桌面端软件： 软件 数据安全 使用便捷 支持MD Onenote ✔ 云端同步 ✔ 史上最全，无需考虑图床问题。 ✖ 可通过插件弥补一点 EverNote ✔ 云端同步 ✔便捷但功简单，适合剪辑各个来源的资料 ✔ 魔改了MD格式 自建博客 ✔ 可备份 ✔ 搭建完成后 ，方便分享和大众搜索。但是搜索很慢 ✔ 完全支持原生MD Notion ✖ 数据只存储在服务器上 ✔ 未来的笔记本，美观，支持富文本动态编辑器，但是使用搜索都很慢 ✖ 不完全支持 （ 接下来是我的牢骚时间：） 其他应用暂时不予考虑。追求一款软件的尽善尽美是不可能的，也是非常痛苦的，因为你没有办法找到一款梦想中的软件，完全符合你的需求和定义。在放弃了一个8分的软件之后，你着眼于所放弃的软件所失去的2分而开始寻找下一个得心称手的工具，最后却迷失在各个工具都有他失去的2分，3分，甚至各个工具失去的分数各不相同，患得患失又期望于抉择出更好的软件。就好像不知道如何从众多男友抉择出的女生的焦虑心情（吐了~）。 在此，我重构出做决策的行为原则： 重要的事情花更多的时间去做好，次要的事情尽量通过简单的原则来判断并快速做出决断。 所谓重要的事情就是对未来和现在会产生重大的，或者不可逆的影响的事情。反之就是次要的事情。 面对必须选择多个目标中一个，如果在目前的考量下如果差不多大差不差，那就随便选择一个，然后把选择的那个变成最好的那个。 这是为了减少决策时间而带来的延误，虽然可能因为判断不够仔细，导致失误反而导致结果变差。哈哈，世事无常，安能掌握一切。譬如日日坚持读书学习，坚持锻炼身体提高精力，这些当前重要但是不紧急的行为，反而决定你未来的强大之处。 如果可以选择多个目标，那么取长补短，各自采取各自的长处就是一般来说就是最优方案。 由此，我们可以理解到，像做笔记这类工作实际上用不同的应用场景的，不同的应用场景也可以用不同的做法，比如收集咨询采用印象或者微信来剪藏；面对需要制作大量批注，或者手写标识的学习场景，快速收集网络资源，构建知识体系，可能onenote才是更好的选择；对于发发牢骚，写写感悟，畅谈一下人生，与更多人交流，抑或记录工作错误感悟，书写解题思路，才是博客应该有的功能；最后一类，对于文档或者编程知识中含有的需要高亮代码段，既可以使用onenote+插件，也可以用高亮一般的大象来构建。鉴于，知识体系的完整性和便于搜索的考量，减少软件的个数是也许是一个更明智的选择。 所以，纠结了一天，最后得出的结果还是用Onenote来制作主力知识结构笔记，用大象笔记作为编程类的知识笔记，用博客作为聊天吹水，发题解，写算法，总结思考的平台，最后用Notion作为项目管理的工具。 额外补充其实有一点害怕非MD格式的资料有点难用。这也是因为现在大多数文档都是用MD格式所编写，顺便挤掉了其他文档格式的份额，更何况Onenote格式，并不流通。所以最后还是不希望编程系统使用Onenote，虽然他很棒，在很多编程笔记的场景下，都用不太到。","link":"/2020/09/18/code-tools/blog/tan-tan-bi-ji/"},{"title":"错误：库中库","text":"Git不允许Git库中再开一个库，如果嵌套的建立库的话，（我也不知道会发生什么？）至少github上面无法打开了。解决方法是：删除小库的.git，同时清除缓存。最后重新add，commit，push即可。 git rm --cached [对应git库文件]","link":"/2020/08/07/code-tools/git/cuo-wu-ku-zhong-ku/"},{"title":"DNS防污染配置","text":"由于我国正处于发展不充分，不完全的阶段，DNS总是会出现一些莫名其妙的错误。twitter上不去，github下不了，非常尴尬。为了增进电脑使用体验，决定自己建一个DNS服务器避免DNS劫持和DNS毒化。 为啥要设置DNS为了防止毒化，设置一个优秀正确而稳定的DNS服务器是必须的。如果有梯子的同学直接连接谷歌的8.8.8.8DNS服务器，当然也可以购买一台香港的服务器当做DNS服务器也OK。 Dns jump一款的window下测量DNS使用速度的软件。随便测量了哪个世界知名的DNS服务器响应都不超过100ms，对上网影响太小了。直接推，随便选。 但是采用境外DNS服务器导致一个严重的使用体验不佳问题。访问本地网站尤其是淘宝等需要大量CDN静态内容的网站，出现长时间的卡顿以至于3分钟都无法加载。原因在于境外DNS把DNS请求转发给国内的DNS服务器，他会把离境外最近的CDN内容分发给我，这反而造成了访问速度下降。加之，三大运营商的网络之间主干道网速慢，平时的愉快的上网体验都是多运营商多服务器的多路配置提高了分发速度。DNS一出国，他就没有分配对应的运营商的服务器，进而又降低了网速。 解决思路所以就有了以下广为传播的共识：国内的网站DNS请求转给国内DNS114.114.114.114，国外的DNS请求转给8.8.8.8。如此便可以保持国内上网体验的同时，保持国外网站不会被毒化。 这就要求本地设置一个DNS软件，而且要求能够分流DNS请求。上网查阅了一番，发现不少人已经鼓捣出来了。其次分流的前提是能够分清哪些域名去国外，哪些留在国内，这就需要一个白名单，当然 GFWList也可以抽出对应域名。 不过要写脚本用Py和正则应该挺好写 更多内容 Daul DHCP DNS ServerDaul DUCP DNS Server Win环境下的方案，但是存在白名单需要手动更新~~无力维护。折腾了半天，也算失败。 安装这节内容主要摘自大佬： 下载安装好（假定在 D:\\DualServer） 进入 D:\\DualServer 目录，用文本编辑器打开 DualServer.ini 找到 [SERVICES] 项部分，默认是开启 DHCP 和 DNS 服务的，因为我只要 DNS 功能，所以只开启 DNS 功能只要去掉 ;DNS 前面的英文分号 ; 继续找到 [FORWARDING_SERVERS] 项，这里是指定默认的 DNS 服务器，这里我用 Google 的，所以加上 8.8.8.8 8.8.4.4 然后就是重点了，找到 [CHILD_ZONES]（ 注：6.95RC后改名为 [CONDITIONAL_FORWARDERS] ），这里是针对关键字自定义 DNS 服务器的地方，下面说说格式 - 拿淘宝网站来说明吧，淘宝一般的域名有：taobaocdn.com、taobao.com、tbcache.com、tdimg.com . 我们要设置这几个域名走电信的 DNS（这里我用路由器DNS代理地址——即路由器本身IP），那么格式如下 taobaocdn.com=192.168.1.1 taobao.com=192.168.1.1 tbcache.com=192.168.1.1 tdimg.com=192.168.1.1 . 如果有多个 DNS 就这样（例如广东这边电信的 DNS 一般是 202.96.134.133 和 202.96.128.166） taobaocdn.com=202.96.134.133,202.96.128.166 查看自己网卡的 IP 地址，因为 DualServer 默认会获取网卡的 IP 地址作为本地 DNS 服务器地址，不知道的可以在命令窗口敲 ipconfig 得到，这里假定是 192.168.1.100 修改连接路由器的那个网卡的 DNS 服务器地址为 192.168.1.100（自淫？网卡自己的IP……） 运行 RunStandAlone.bat，运行后会出现命令窗口显示 log，这样就OK了 PS1：如果你不想每次都要运行 RunStandAlone.bat 和看到那碍眼的命令窗口，那么你可以注册为系统服务，只要运行 DualServer.exe，然后去系统服务（命令行敲 services.msc）那里启动此服务，以后就会自动运行了，不过注意，如果你修改了 DualServer.ini 参数，需要停止再启动此服务——嫌麻烦就重新启动计算机 配置白名单在大佬文章中，我找到了一个为维护白名单的Coder。在Github上下载了他的名单后，用Python写了了脚本修改了一下地址格式，然后加到这个程序的.ini里面。 # 参考 import os import re filepath = &quot;./DualServer.ini&quot; filepath_w = filepath + &quot;_w&quot; def replace(line): restring1 = r&quot;^([a-zA-Z0-9\\.\\-]*?)/([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})$&quot; restring2 = r&quot;^server=/([a-zA-Z0-9\\.\\-]*?)/([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})$&quot; reobj1 = re.match(restring1, line) reobj2 = re.match(restring2, line) if reobj1: return reobj1.group(1)+ '=' + reobj1.group(2) + '\\n' elif reobj2: return reobj2.group(1) + '=' + reobj2.group(2)+ '\\n' else: # print(&quot;Sorry! There isn't string for match\\n&quot;, line) return line with open(filepath, 'r+') as f: with open(filepath_w, 'w') as f_w: for line in f.readlines(): newLine = replace(line) f_w.write(newLine) print(replace(&quot;sdkjf/114.223.432.11&quot;)) 使用一下发现还是挺不错的，偏偏淘宝相关的网站怎么也快不起来，结果一查DNS Log果然还是发给了国外的DNS服务器。诶毕竟了3年前的IP地址了。一个个加新域名完全加不完~~所以这也是一条死路。 DNSforwarder作为win和linux都有的DNS转发代理，做的功能已经相当齐全了, 但是同样缺少IP或者域名维护功能。详情请见DNSforwarder Github。 DNSMASQfreeDNS FreeDNS该软件可以直接在Linux上配置。集成了DNS分流和DNS请求的功能，算是一个比较好的实现。 ChinaDNS貌似问题比较多的，具体看","link":"/2020/09/02/code-tools/linux/dns-fang-wu-ran-pei-zhi/"},{"title":"Linux开机启动服务&#x2F;进程","text":"简记一下。 开机以root用户启动脚本Place the script you want to run in the /etc/init.d directory and make the script executable. chmod 755 myscript Once that is done create a symbolic link in the run level directory you would like to use, for example if you wanted to run a program in the graphical runlevel 2, the default runlevel for Ubuntu, you would place it in the /etc/rc2.d directory. You just cannot place it the directory, you must signify when it will run by indicating the startup with an “S” and the execution order is important. Place it after everything else that is in the directory by giving it a higher number. If the last script to be run is rc.local and it is named S99rc.local then you need to add your script as S99myscript. ln -s /etc/init.d/myscript /etc/rc3.d/S99myscript Each backward compatible /etc/rc*.d directory has symbolic links to the /etc/init.d/ directory. WSL开机启动服务配置方法创建启动脚本： 进入任意 WSL 发行版中，创建并编辑文件：/etc/init.wsl #! /bin/sh /etc/init.d/cron $1 /etc/init.d/ssh $1 /etc/init.d/supervisor $1 里面调用了我们希望启动的三个服务的启动脚本，设置权限为可执行，所有者为 root，这时候可以通过： sudo /etc/init.wsl [start|stop|restart] 来启停我们需要的服务，在 Windows 中，开始-运行，输入： shell:startup 按照你 WSL 使用的 Linux 发行版创建启动脚本，比如我创建的 Debian.vbs 文件： Set ws = CreateObject(&quot;Wscript.Shell&quot;) ws.run &quot;wsl -d debian -u root /etc/init.wsl start&quot;, vbhide 这个脚本就会在你登陆的时候自动在名字为 “debian” 的 wsl 发行版中执行 /etc/init.wsl 启动我们的服务了，如果你用的是 ubuntu18.04 的发行版，那么修改上面脚本里的 debian 为 ubuntu1804.vbs： Set ws = CreateObject(&quot;Wscript.Shell&quot;) ws.run &quot;wsl -d Ubuntu-18.04 -u root /etc/init.wsl start&quot;, vbhide 而如果你不知道自己的 WSL 发行版叫做什么名字，可以用 “wsl -l” 来查看。不管你用最初的 bash (ubuntu 16.04) 还是商店里下载的 debian/ubuntu1804 都能顺利启动服务了。 WSL 中有很多有用的服务，你可以按需删改 /etc/init.wsl ，但没必要塞很多东西进去影响你的启动速度，比如 mysql/mongodb 这些重度服务，可以需要的时候再启动，用完就停了。 其他参考博客linux开机自启动脚本 Linux 设置开机启动项的几种方法","link":"/2020/09/02/code-tools/linux/linux-kai-ji-qi-dong-fu-wu-jin-cheng/"},{"title":"VIM学习网课推荐","text":"VIM陡峭的学习难度永远让人头痛不已，繁多的快捷键和丰富的功能让每一个初学者瞬间失去学习的欲望。而MIT推出工具课程中的一节课中循序渐进的介绍了VIM的使用，辅以课后习题巩固扩展学习内容，让我们真正上手这款神奇。 详细内容请见此。 昨天下午撸了2个小时课程，今天早上撸了2个小时课后习题，也做完了VIMTUTOR，真是不容易。不过VIM确实挺有趣的。","link":"/2020/09/27/code-tools/linux/vim-xue-xi-wang-ke-tui-jian/"},{"title":".brshrc的作用","text":"Linux的Ubunut的用户目录下，.bashrc常被用于存储环境变量和别名语句，该文件会在Shell启动的时候自动被导入。 常见的手动导入.bashrc文件方式有source ~/.bashrc和exce bash。两者存在略微的不同，前者可能将.bashrc文件中的路径变量也导入，后者用一个新的bash替换旧的bash，可能导致bash的变量和历史命令丢失。常见的别名： alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' .bash_aliases文件默认不存在，一般用于存放别名命令，如需使用需要用户手动创建。.bashrc文件中有一段： if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi 会检查该文件是否存在，如果存在就执行","link":"/2020/08/26/code-tools/linux/brshrc-de-zuo-yong/"},{"title":"zsh安装错误","text":"简单的按oh-my-zsh官网的提示执行命令，却发现错误zsh not installed. Pleaese fisrt install zsh。 翻了翻Github，发现这个错误真的是广泛传播~最后issue被closed之后还是有很多人报错。工程师无奈只能给出用sudo apt install zsh的替代方法:smile:。","link":"/2020/08/31/code-tools/linux/zsh-an-zhuang-cuo-wu/"},{"title":"搭建RSS服务","text":"好怀念神奇又快捷的RSS功能啊。经过不懈的尝试和努力，终于在VPS-Ubuntuuh建了一个。 安装首先安装docker: sudo apt install docker.io 安装docker-compose。详细请见官网 接下来安装Awesonme-TTRSS。经过本人的多次试错，安装在Ubuntu，采取Docker-Compose的方法安装，并不修改除了SELF_URL_PATH之外的所有配置是成功的唯一方法。 把SELF_URL_PATH修改为浏览器访问的网址，并且网址最好换成域名，做好DNS解析。 docker-compose up -d #后台启动即可 如果修改了.yml配置文件，删除container然后重启即可。 docker-compose donw #删除contianer docker-compose up -d 最后安装RSSHUB，配合在浏览器上安装RSSHUB-Radar。前者可以神奇地解析不可RSS获取的内容，后者可以搜寻RSS源，查找RSSible的内容，并与RSSHUB联动获取内容，最后可方便地订阅到RSS。 后记但由于现在RSSHUB的官方文档挂掉了，好多功能有点难用了~~~","link":"/2020/09/09/code-tools/linux/da-jian-rss-fu-wu/"},{"title":"记一次自建DNS","text":"最近因为下载Github文件却总是无法获取到真实IP，经过搜索发现是DNS被污染了。于是开始快乐的自建一个DNS服务器！ 可以通过win自带的nslookup工具判断正在使用的DNS服务是否被污染。“正常”的DNS服务器可以解析出地址，如果无法解析肯定可以说明DNS被污染了。 安装Adgurd是一款开源，能够强有力拦截广告的DNS服务器软件。Docker提供了快捷的安装方式。一键安装，网页管理，可视化数据显示，Nice~ DNS-over-HTTPS为了进一步保护隐私，防止中间人窃听DNS请求来获知我的访问网站，我推荐加上TLS加密保护我自己~ 官网给出了详细安装教程。 CertbotCertbot是一款自动化，自动修改服务器配置，可获取Let's Encryption的证书，并在过期前自动更新的强大工具包。 安装过程不再赘述，但是其中有一条：Certbot要求添加一条DNS TXT记录来验证安全性？（验证啥？没再看了）可以在域名解析的DNS解析商那边添加。 最后把获取的证书的两个PEM文件内容写到管理页面的加密设置那就OK了。 使用按照管理页面的设置指导提示，可以在各个终端上使用该服务器作为DNS服务器。 不过最后迁移到ubuntu之后，因为53端口被占用了，只好作罢。","link":"/2020/08/31/code-tools/linux/ji-yi-ci-dns-fen-liu/"},{"title":"记一次DNS分流","text":"最近因为下载Github文件却总是无法获取到真实IP，经过搜索发现是DNS被污染了。于是开始快乐的自建一个DNS服务器！ 可以通过win自带的nslookup工具判断正在使用的DNS服务是否被污染。“正常”的DNS服务器可以解析出地址，如果无法解析肯定可以说明DNS被污染了。 安装Adgurd是一款开源，能够强有力拦截广告的DNS服务器软件。Docker提供了快捷的安装方式。一键安装，网页管理，可视化数据显示，Nice~ DNS-over-HTTPS为了进一步保护隐私，防止中间人窃听DNS请求来获知我的访问网站，我推荐加上TLS加密保护我自己~ 官网给出了详细安装教程。 CertbotCertbot是一款自动化，自动修改服务器配置，可获取Let's Encryption的证书，并在过期前自动更新的强大工具包。 安装过程不再赘述，但是其中有一条：Certbot要求添加一条DNS TXT记录来验证安全性？（验证啥？没再看了）可以在域名解析的DNS解析商那边添加。 最后把获取的证书的两个PEM文件内容写到管理页面的加密设置那就OK了。 使用按照管理页面的设置指导提示，可以在各个终端上使用该服务器作为DNS服务器。","link":"/2020/08/31/code-tools/linux/ji-yi-ci-zi-jian-dns/"},{"title":"记一次配置ShadowSocks","text":"用香港服务器做一个代理。网上的教程很多，只需要5分钟就可以配置好。 安装在VPS建议直接用python的pip3下载安装shadowsocks。 sudo apt install python-pip3 #ubuntu上是python3-pip pip3 install shadowsocks Win桌面下载地址 Andriod下载地址 更多下载地址 配置并启动VPS上新建 /etc/shadowsocks.json 文件, 并写入以下内容 { &quot;server&quot;:&quot;0.0.0.0&quot;, #服务器上这部分必须为0.0.0.0 &quot;server_port&quot;:443, #通信端口 &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your-passwd&quot;, #your password &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false, &quot;workers&quot;:5 } 注意修改 server 和 password, workers 表示启动的进程数量。 然后使用以下命令启动: ssserver -c /etc/shadowsocks.json -d start 另外 #命令可以快捷启动，停止和重启服务 ssserver -c /etc/shadowsocks.json -d [start]|[stop]|[restart] 按照上面设置的参数配置，可以在本地的ShadowSocks客户端添加服务器和相关参数，即可连接成功。 错误报错undefined symbol EVP_CIPHER_CTX_cleanup原文参考 错误原因是openssl1.1.0目前兼容性很不好，大部分的软件都不支持。 所以如果决定使用openssl1.1.0需要考虑很多兼容问题，必须保留1.0.2或1.0.1(不推荐，存在一些已知漏洞，最重要的是如果服务器要开http2，由于新版chrome必须使用ALPN的限制，只有1.0.2版本支持ALPN，所以必须升级到1.0.2)版本以便编译其他程序。 解决方法 ： vim打开文件openssl.py find / -name openssl.py vim /yourpath/openssl.py 路径不同根据报错路径而定 修改libcrypto.EVP_CIPHER_CTX_cleanup.argtypes :%s/cleanup/reset/ :x 重新运行ss即可 报错 Cannot assign requested address检查一下配置的服务器地址是不是0.0.0.0。 检查日志检查日志more /var/log/shadowsocks.log 最后一次的记录 tail -n 30 /var/log/shadowsocks.log 启动为服务","link":"/2020/09/06/code-tools/linux/ji-yi-ci-pei-zhi-shadowsocks/"},{"title":"Vscode笔记","text":"VS Code 使用笔记优秀插件Code Runne集成大多数语言的运行命令，一键运行。 在Setting的extension中可以设置Run Code Configuration的Run in Terminal为True，可以方便在终端中输入输出程序","link":"/2020/08/07/code-tools/vscode/vscode-bi-ji/"},{"title":"WSL杀死进程","text":"WLS2的Ubuntu18.04下没有办法直接使用kill -s 9 PID杀死进程，可是神奇的用kill -9 PID代替。","link":"/2020/08/07/code-tools/windows/wsl-sha-si-jin-cheng/"},{"title":"window工作环境","text":"都知道Window的PATH和工具包管理的缺乏是公认的难用，不巧的是Linux的系统不是那么让我喜爱，尤其很多软件在Linux兼容性不好。如今WLS的推出了让我们可以在Window下直接体验近乎原生linux的畅爽体验，(虽然说虚拟机+linux+局域网连接好像也行，就是太费资源了)。 盘一盘我的Window下安装工具和配置方式： Fluent-Terminal 工具美化原生的WSL终端和PS界面 配色方案超级多 方便调节字体、透明度、支持快捷键、标签式管理页面啧啧啧~ VSCode：刚刚入坑，听说了宇宙第一编辑器的大名久已 官方入门 可配合WSL本地远程编程， 可参考Dev in WSL VS在WSL进行开发调试 WSL：不论是WSL1，还是WSL2功能都非常的强大，诶忍不住的香 可参考Dev in WSL","link":"/2020/08/07/code-tools/windows/window-gong-zuo-huan-jing/"},{"title":"wls2折腾笔记","text":"推荐阅读官方博客 其中对WSL2介绍。基于 Hyper-V 结构，WSL2大幅改进了上一代WSL在系统层面的的I/O效率，增加了系统调用的全面性，甚至还能支持Docker,唯一遗憾的是网关上做了隔离（？）。 命令安装官网博客的配置后，应该已经能够使用WLS2了。快速摘录几条命令。更改Linux distro的WLS的运行版本： wsl --set-version &lt;Distro&gt; 2 #设置为启动WSL2 wsl --set-version &lt;Distro&gt; 1 #设置为启动WSL1 设置默认安装distr的WSL2版本： wsl --set-default-version 2 检查各个distr的WSL版本： wsl --list --verbose #or wsl -l -v 网络连接问题Linux连PC（In the initial builds of WSL2 preview）从Linux访问Windows中软件需要Linux连接主机的host ip。 获取主机LAN IP方法如下： cat /etc/resolv.comf 之后就可以使用该IP地址连接到PC的服务器上了。 PC连Linux在高于18945版本的WIN10系统可以直接访问Localhost来访问Linux Dis的服务器。对应的低于此版本的WIN10需要获取Linux虚拟机的IP地址。即可由以下命令获取： ip addr | grep eth0 迁移WSL如果你更换了电脑，如何将WSL迁移至新的电脑或windows系统中呢？ 在旧电脑或系统中输入： wsl --export distro_name file_name.tar 此时wsl系统已经被打包成tar文件，在新的电脑或系统中输入： wsl --import distro_name install_location file_name.tar 此时就完成了wsl迁移。如果想删除wsl则执行： wsl --unregister distro_name 查询wsl安装情况执行： wsl --list 上述命令在windows powershell里执行。","link":"/2020/08/07/code-tools/windows/wls2-zhe-teng-bi-ji/"},{"title":"cmake学习索引","text":"Cmake笔记Cmake是跨系统，C++现行标准构建标准的build system of build system`. 比较好的学习资源如下： understand Cmake ✅: 一个简单的接受 cmake official web ： 对各个命令有最详细的解释，当字典用 Cmake Tutorial: 💖从零基础解释CMake基础概念，看完这个再看官方教程就很简单了 cmake tutorial ✅ ：跟着做比较有意思，可以多多尝试，就是有点花时间。后面部分内容可以看看 Cmake Detailed tutorial ✅: 最详细，有很多项目经验 看完了，直接上手项目或者看其他开源项目如何管理也是有点启发滴。当然对照着一个真实项目学习Cmake也有点帮助。","link":"/2021/05/04/code-tools/build/cmake-xue-xi-suo-yin/"},{"title":"面经 题目C++list","text":"[toc] 面经 题目C++list C++面对对象c++的特性； 面向对象特点，什么是多态 面向对象六大基本原则 lambda给了一个函数将其写成lambda表达式，捕获列表中&amp;和=有什么区别，默认是什么捕获。 .lambda表达式，它应用表达式外变量的方式和区别 基本类型 int类型占多少字节？ 一个字节的int能表示多少个数？ 最大的2^8怎么表示？全为1换算后为多少？ 有符号的范围是多少？-128怎么来的？ -1怎么表示？ 怎么判断一个浮点数为0？ 判断区间怎么来的？ 怎么判断浮点数 0.1 类型 定义一个宏表示一年有多少毫秒，怎么定义？ \\#define MS_OF_YEAR (365*24*60*60*1000)UL dynamic_cast与static_cast区别 static关键字的作用；Static的使用、全局变量声明static和不声明static的区别； C++ static 修饰可以修饰构造函数？ statci成员函数 C++ 四种强制转换,static_cast和dynamic_cast分别是什么时候转的（编译、运行） Static的静态函数和普通函数的区别、在类里面的区别 extern “C”，为什么会用C语言的方式编译 讲一下inline。 说一下auto关键字的优缺点。 Const修饰词 sizeof是实现原理，是需要函数支持呢，还是操作系统支持sizeof的结果是在哪个阶段确定的让你实现sizeof的话怎么实现呢 dynamic_cast的用法，无法转换时会出现什么情况（指针返会NULL，引用抛异常） extern 作用，为什么要extern C，extern变量在哪个数据段 类的构造函数、析构函数可不可以是虚函数，为什么* 类 字节对齐问题（结构体，char,short,float,char） class A是一个空类，它里面有什么方法 ？ 移动拷贝和移动赋值，讲讲 C++11里面构造函数有几种 多态的形式 虚函数、虚表、虚指针 虚函数实现机制 父类的析构函数是否应该是虚函数，为什么 .析构函数能不能调用虚函数 多态原理；静态多态和动态多态 深浅拷贝 虚指针创建的时机。 智能指针shared_ptr的数据成员。对引用计数的修改是否要考虑线程安全？ 构造函数中调用虚函数会怎么样 定义一个空的类里面会有什么？ 构造和析构需要注意什么 重载与override（重写）区别。（返回值，参数一个可以不同，一个必须相同） ；overload 、override、overwrite 之间的区别？ 写一个shared_ptr循环引用的例子； 结构体和类的有什么去接，struct？提示：类成员区别、继承区别 对象的什么函数不能被声明为虚函数（构造函数，内联函数inline，静态函数） 常规的虚函数底层实现. 右值引用为什么会提高效率 虚函数可以是内联函数吗（inline和virtual一起用） c++三种继承 交叉继承（虚继承） 类(class)、结构体（struct）和联合（union）的区别 运行时多态和编译时多态 C++的析构函数的触发机制和调用事项是否了解？ 如何理解继承和多继承？ 虚函数表确定时期（编译期） 为什么在虚函数表在编译期确定，如果在运行时确定会怎样 声明Base对象用Derive对象赋值，会发生什么 空类会默认生成哪些（构造，析构，拷贝，operator=），面试官说还有其他的，想不到了 虚函数和纯虚函数？虚函数可以内联吗？没有被继承的类有虚函数可以内联吗（说了不可以，但是面试官说可以）？ 虚函数类的内存分布 说说虚函数，虚函数表存放在哪里 底层5.什么是内存泄露，有什么危害；内存泄漏和内存溢出的区别，有什么联系** 了解TS指令吗 栈溢出 线程的栈你觉得放哪（我答可能是进程的栈或堆栈中间的部分） 栈里除了局部变量还会存什么 什么情况下CPU会达到100% C++内存管理，简要说明C++的内存分区 调用dll的过程细节 .怎么判断机子是32位或者64位,直接手撸一个函数 内存碎片怎么处理，用过tcmalloc吗(没听过。。后面查了一下是更适用于多线程的一个malloc库) 怎么检查内存泄漏 🔓全局静态变量在什么阶段初始化。（我答：运行时吧，因为它放在.bss） 然后就顺理成章问我除了.bss 还有什么段（c++内存分区） 堆和栈哪个存储效率高，为什么？空间哪个大，为什么？ 栈和堆区别 ； 操作系统对栈的管理 函数栈 内存管理，static作用，在什么位置，有什么好处（没答上来），堆和栈为什么不能合并？ 内存泄露相关问题， Valgrind 这类工具是怎么实现的； 字节对齐的原理 什么情况下读两次？为什么读两次？ 堆的底层了解吗 堆跟栈分别存什么？为什么C#有垃圾回收机制，C++没有垃圾回收机制? 垃圾回收的原理到底是什么?（我打扫描堆上变量是否被使用，处于激活状态之类的）那怎么判断它是不是处于激活状态呢？具体的原理是什么？ 只在栈上生成对象和只能在堆上生成对象。 怎么判断大小端； 大小端知识点 C++内存分配和C语言内存分配，malloc底层实现； malloc申请8KB空间，是否连续？ 编译程序编译四个过程，预编译做哪些工作？词法分析语义分析在哪个阶段？ 静态链接与动态链接； c++静态编译和动态编译具体实现机制——被问倒了，只知道DLL之类的，乱说了一通 内联函数和宏的区别 分别在哪个阶段替换 程序编译的阶段 循环展开 链接的过程？主要做了什么？ 内联函数原理 内联的规则，不能声明为内联函数的情况 递归函数可以内联吗 不会。 词法检查、语法检查、语义检查，还能再讲的细一点吗？（不能了。。。） 程序从产生到运行的全过程；。 指针和引用指针和引用的区别 ；指针和引用的区别，一般什么情况下分别使用？指针与引用，引用底层实现 C++引用和指针的区别，引用能否为空 2.decltype的作用，他和auto有什么不同 .什么是野指针，有什么危害， shared_ptr是线程安全的吗，为什么 shared_pointer的实现方式 为什么用make_shared而不直接使用new。 现在为什么用shared_ptr而不用auto_ptr。 weak_ptr使用场景，为什么会需要weak_ptr。 都用过哪些智能指针，shared_ptr与unique_ptr有啥区别 智能指针（解决循环引用的问题）； 智能指针 要注意的地方 class A类型的指针，此时通过dynamic_cast转换为class B类型的指针，会出现什么问题，是否能通过编译，或者是否能运行（说是不能，但是编译错误还是运行错误不确定） 函数指针指针和数组的区别 char*和char[]的区别 malloc和new的区别, new失败会返回什么。 New operator和operator new 的区别； malloc和内存池的区别 指针大小 上个问题我提到了C++智能指针和引用计数，于是问了下这种方式有没有缺陷 weak_ptr会不会出现野指针的问题，因 解释解释智能指针的异同和应用场景，顺便现场手撕auto_ptr 一般给一个指针开辟空间后需要主动释放内存，如果已知一个对象的生命周期很短，如何写一个工具类能够帮助释放内存？ new 数组，delete没有写方括号，会出现什么情况？ delete 和delete[]的区别 数组指针和指针数组 指针常量和常量指针 函数指针 char * 有没有用过strcpy，memcpy，memomve，区别是什么？ 标准库map是用来干啥的，底层数据结构是啥 array 和 vector区别 STL用过吧，讲讲都用过啥 vector动态扩容讲讲 resize()与reserve()区别 我现在循环往一个vector里面插入10000个数据，一次插入一个，怎么高效，用resize()还是reserve()，为什么 迭代器什么时候会失效，哪些容器什么情况下会失效 map迭代器会失效吗，为什么 vector有大小限制吗 用过哪些STL？vector和普通的数组分别有什么优势和劣势？如果已知数据的大致大小（比如200个int），同时还想用vector，如何避免使用过程中扩容的开销？ vector和list比较 vector list set的区别 pop back不返回值的原因 C++的容器各自优缺点 stl那些底层如和实现的你知道吗？ （vector，deque，map，unorder_map全讲一遍，后两个的优缺点） set底层 Map底层实现，map和avl相比的优点 vector clear的实现原理 迭代器什么时候会失效 dequeue是怎样的数据结构？ Stack是怎样的数据结构？ Priority_queue是怎样的数据结构？ vector扩容在C++11里有什么不同——用了右值拷贝 多线程 写过多线程程序吧，讲讲线程间同步的方法吧 有哪几种锁 ++i线程安全吗，为什么 volatile，给出不能原子性场景 多线程编程，coredump怎么debug 多进程可以监听同一个端口吗？会出现什么问题（惊群）？怎么解决？多线程可以监听同一个端口吗（可以）？ 多线程编程时怎么避免死锁？ 你觉得多线程编程比较难的问题？（面试官补充了，多线程间任务不要交叉，架构要合理） 协程的理解？协程编程的注意事项？协程里面想要实现sleep怎么做？ volatile关键字的作用 异常关于C++的异常机制，具体搞忘了，反正没答出来； 其他.c++对象模型是是什么 命名空间 GDB Python和C++的区别 C++和python的内存管理说说吧 C++里的用到设计模式 Stl：stl里面栈的实现，用了什么设计模式官方名称 说一下c++的编译过程 异步日志怎么做的？ C和C++的区别 对于游戏开发，C++哪里用的多？ （底层、自研引擎、unity的库等） C语言如何实现面向对象 C++作为面向对象语言，如果理解面向对象的？（针对回答）从某中意义上讲，底层都是指令集，为什么C++能够面向对象而C不行？ （那么C与C++本质是有区别还是无区别的呢？）（针对回答提到封装）如果完全用C进行语言封装，是否能够达到C++的面向对 象的效果 gdb怎么调试一个正在运行中的进程？ 了解printf的可变参数是怎么实现的吗，从汇编层面解释一下（卒，不懂汇编） 使用过__stdcall吗？ 编译器可能对代码做哪些优化（指令重排，CPU流水线） C++11和GNU11的区别吗？ 编译器怎么删除不会执行到的无用代码段 ++i和i++的编译，一步步说 C++怎么切换版本？ .C++20有什么新东西 怎么在main函数之前和之后执行代码； 作用域作用域概念 函数调用C++函数的调用约定？ 重载怎么实现的——函数签名 函数调用过程 内存对齐.为什么要内存对齐，内存对齐的规则 计算结构体大小 program pack之后结构体的大小，这个指令有什么好处，用在什么地方，有什么坏处","link":"/2021/03/14/language/c/mian-jing-ti-mu-c-list-md-1/"},{"title":"Coroutine协程简记","text":"Coroutine，即协程。虽然名字很像线程进程，但是协程与前两者的相似之处很少。协程，顾名思义为协作合作的多任务程序。 A Simple Overview of CoroutineDefinitionWiki百科的定义比较广泛，但是它提出了协程的三个重要特征： Coroutines（协程） are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed. 运行子程序 完成协作性质任务 运行时可暂停和重新唤醒 这三点已经可以概括了协程的面貌了，为了更深入了解协程的特点，我们可以从其他相似概念，最后从python的asycio入手了解协程。 AnalogyComparison with subroutinessubroutine看似高大上，与routine有着密不可分的关系，就其定义来说就是一个A set of instructions that performs a specific task for a main routine，也可以称之为function，procedure。 子程序是协程的特例，子程序从开头执行到末尾就结束了，仅仅返回一个值而且不保存状态，但是协程不同，它的“结束形式”是调用另一个协程的，同时其内部变量依旧保存，在下次被调用时仍然可以使用。值得注意的，被调用的coroutine仍可以调用调用它的coroutine，从这个角度说，不似与一般调用方法的caller-callee关系，coroutine的关系是symmetric的。 Comparison with threads:协程与线程很相似，但是协程是合作性质的多任务，而线程是典型的抢占式多任务性质的。 协程是典型的concurrency（并发）性质的程序，而非parallelism（并发）性质的程序。也就是说协程仅仅创建了一个线程或者说一个进程。 parallism是concurrency的真子集。 BTW, threading（多线程化）是concurrency的一种实现手段，multprocessing （多处理器运行）是paralism的一种实现手段。 四者的关系如图： 协程无需进行线程切换的优势让它性能优势远超多线程进程，更加适合hard-time realtime context， GO语言的火爆也得力于此。 多线程的缺点在于线程切换涉及到系统调用和调用阻塞，大大减慢了速度；多线程的同步竞争问题也需要信号量和同步锁维护。 Comparison with generators:生成器也称之为半协程，是协程的一个子集。熟知的语言如C++、python都实现了generator的机制，可以看出generator基本符合协程的三个特征。但是对于generator来说，sysmmetric还是不太够。 其次，genenrator的yield关键词定义了generator退出和重新执行的entry，同上面所述，generator并没有主动yield(割让控制权)和重新执行的权利，他更像被动生产者，把控制权交给调用generator的caller。而coroutie可以在yield之后突然夺回控制权， Comparison with mutual recursion： 讨论到，控制权在不同subroutine之间相互交换的情况，相互调用的函数可以类比coroutine。但是有明显的不同，就如一开始Definition所说，coroutine可以保存状态，变量和execution point，而且能resume execution from execution point 而不是从头执行。 另外, mutual recursion调用的对方函数后，会增加系统函数栈的层数(stack frame)。而coroutine在传递控制权的时候，可以使用已经存在的context，并且仅仅只用一个jump来完成。 具体实现未曾探究。 Coroutines in asyncioasyncio是python的内置系异步包，其API在3.4~3.7中快速迭代，如果幸运的话，以后可能会稳定下来。 更多异步包可以用pip install --upgrade pip aiohttp aiofiles安装即可。 asyncio就是Asynchrnous IO缩写。众所周知，cpu-bound(所谓劳动密集型任😂)更需要多线程多处理器完成，IO-bound型任务需要多个线程来处理IO堵塞，或者由强大的😈协程完成。重复一遍，coroutine编程仅仅是一个单一线程单一进程的风格，他并不是parallelism，而是concurrent。更详细的说： 异步coroutine在等待一个任务完成之时可以，可以停止执行，让其他coroutines执行。这个性质非常想进程同步所说的让权等待。 为了支持异步处理，python引入了两个新key words: async and awati。前者定义异步函数，后者声明可以让权的语句。比如下面这个小程序： import asyncio async def count(): print(&quot;One&quot;) await asyncio.sleep(1) print(&quot;Two&quot;) async def main(): await asyncio.gather(count(), count(), count()) if __name__ == &quot;__main__&quot;: import time s = time.perf_counter() asyncio.run(main()) elapsed = time.perf_counter() - s print(f&quot;{__file__} executed in {elapsed:0.2f} seconds.&quot;) 三个异步执行的count()会在各自阻塞的时候让权给其他count()。可以想到，这个程序执行时间大概在1秒，而非同步执行的3秒。 END 接下的内容由于，个人水平和时间都有限，虽然做了更多的学习，但还是打算不发出来误人子弟了。","link":"/2020/10/08/language/go/coroutine-xie-cheng-jian-ji/"},{"title":"Python 代码风格 PEP8 总结","text":"Python 代码风格 PEP8 总结首先，要保持整个项目的代码风格一致，这一点甚至比遵循PEP8代码风格更加重要。 花在阅读代码的时间远远比比写代码的时间要长，提升代码的可读性readability，让整个代码风格的一致，非常重要。 总体来说： 提升代码可读性 避免对其他人写的、以前写的、支持过去的特性的的代码进行重构、或者修改 Code Lay-outIndentationUse 4 spaces per indentation level. Continuation lines should align wrapped elements either vertically using Python’s implicit line joining inside parentheses, brackets and braces, or using a hanging indent 3. When using a hanging indent the following should be considered; there should be no arguments on the first line and further indentation should be used to clearly distinguish itself as a continuation line. 应当有两种书写跨行代码的方式： 第一行带参数，并保持第二行与第一行垂直对齐 第一行不带参数，剩下的行数保持对齐 需要有更多的缩进来保持与其他代码的不同 # Aligned with opening delimiter. foo = long_function_name(var_one, var_two, var_three, var_four) # More indentation included to distinguish this from the rest. def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # Hanging indents should add a level. foo = long_function_name( var_one, var_two, var_three, var_four) # Add some extra indentation on the conditional continuation line. if (this_is_one_thing and that_is_another_thing): do_something() result = some_function_that_takes_arguments( 'a', 'b', 'c', 'd', 'e', 'f', ) Tap?Python 3 disallows mixing the use of tabs and spaces for indentation. Maximum Line LengthLimit all lines to a maximum of 79 characters. 这么做有利于： 在编辑器中可以快速浏览水平排列的多个程序文件 保持一行代码的的简洁性 Break a line from binary operator # No: operators sit far away from their operands income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 通常的二元操作符的分割方法如上所示，但是这样破环了操作符和操作数的连续性，更好的方法是把operator放在前面。 # Binary operation ## Yes: easy to match operators with operands income = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) Blank LinesSurround top-level function and class definitions with two blank lines. Method definitions inside a class are surrounded by a single blank line. Source File EncodingCode in the core Python3 distribution should always use UTF-8. Import*Imports should usually be on separate lines, e.g.: Yes: import os import sys #It’s okay to say this though: from subprocess import Popen, PIPE Imports are always put at the top of the file, just after any module comments and docstrings, and before module globals and constants. Imports should be grouped in the following order: standard library imports related third party imports local application/library specific imports You should put a blank line between each group of imports. Absolute imports are recommended, as they are usually more readable and tend to be better behaved. import mypkg.sibling from mypkg import sibling from mypkg.sibling import example However, explicit relative imports are an acceptable alternative to absolute imports, especially when dealing with complex package layouts where using absolute imports would be unnecessarily verbose: from . import sibling from .sibling import example Whitespace in Expressions and StatementsImmediately inside parentheses, brackets or braces: Yes: spam(ham[1], {eggs: 2}) No: spam( ham[ 1 ], { eggs: 2 } ) Between a trailing comma and a following close parenthesis: Yes: foo = (0,) No: bar = (0, ) Immediately before a comma, semicolon, or colon: Yes: if x == 4: print x, y; x, y = y, x No: if x == 4 : print x , y ; x , y = y , x However, in a slice the colon acts like a binary operator, and should have equal amounts on either side (treating it as the operator with the lowest priority). In an extended slice, both colons must have the same amount of spacing applied. Exception: when a slice parameter is omitted, the space is omitted. 注意下面实例中最后一个例子 Yes: ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] ham[lower:upper], ham[lower:upper:], ham[lower::step] # 和最后一个对比一下，似乎带有某种运算优先级的暗示 ham[lower+offset : upper+offset] ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)] # ham[lower + offset : upper + offset] No: ham[lower + offset:upper + offset] ham[1: 9], ham[1 :9], ham[1:9 :3] ham[lower : : upper] ham[ : upper] Immediately before the open parenthesis that starts the argument list of a function call: Yes: spam(1) No: spam (1) Immediately before the open parenthesis that starts an indexing or slicing: Yes: dct['key'] = lst[index] No: dct ['key'] = lst [index] More than one space around an assignment (or other) operator to align it with another. Yes: x = 1 y = 2 long_variable = 3 No: x = 1 y = 2 long_variable = 3 Other RecommendationsAvoid trailing whitespace anywhere. Because it’s usually invisible, it can be confusing: e. g. a backslash followed by a space and a newline does not count as a line continuation marker. Some editors don’t preserve it and many projects (like CPython itself) have pre-commit hooks that reject it. Always surround these binary operators with a single space on either side: assignment (=), augmented assignment (+=, -= etc.), comparisons (==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), Booleans (and, or, not). If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgment; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator. Don’t use spaces around the = sign when used to indicate a keyword argument or a default parameter value. 与下面第二条不同 Yes: def complex(real, imag=0.0): return magic(r=real, i=imag) No: def complex(real, imag = 0.0): return magic(r = real, i = imag) Function annotations should use the normal rules for colons and always have spaces around the -&gt; arrow if present. (See Function Annotations below for more about function annotations.) Yes: def munge(input: AnyStr): ... def munge() -&gt; AnyStr: ... No: def munge(input:AnyStr): ... def munge()-&gt;PosInt: ... When combining an argument annotation with a default value, use spaces around the = sign (but only for those arguments that have both an annotation and a default). Yes: def munge(sep: AnyStr = None): ... def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ... No: def munge(input: AnyStr=None): ... def munge(input: AnyStr, limit = 1000): ... Compound statements (multiple statements on the same line) are generally discouraged. 简洁还是简洁 Yes: if foo == 'blah': do_blah_thing() do_one() do_two() do_three() Rather not: if foo == 'blah': do_blah_thing() do_one(); do_two(); do_three() Trailing Commas commas: , Trailing commas常常用在tuple中的数据分割，我们常常推荐使用圆括号来包含数据和逗号。 FILES = ('setup.cfg',) 在List中每一项划分为一行，并把括号分割在下一行中。 FILES = [ 'setup.cfg', 'tox.ini', ] initialize(FILES, error=True, ) CommentsTips: update comments when code is changed never alter the case of identifiers be complete sentence write in English Block Comments are intended to the same level as that code starts with a # and a single space. Inline Comments Use inline comments sparingly(简洁的) Inline comments should be separated by at least two spaces from the statement. They should start with a # and a single space. Documentation StringsWrite docstrings for all public modules, functions, classes, and methods. Docstrings are not necessary for non-public methods, but you should have a comment that describes what the method does. This comment should appear after the def line. the &quot;&quot;&quot; that ends a multiline docstring should be on a line by itself, e.g.: &quot;&quot;&quot;Return a foobang Optional plotz says to frobnicate the bizbaz first. &quot;&quot;&quot; Naming ConventionsOverriding PrincipleNames that are visible to the user as public parts of the API should follow conventions that reflect usage rather than implementation. 面向外部的命名其含义远大于实施意义。 Naming Style3命名的方式多种多样。 有一种独特的命名方式，是在函数和变量前加一个short unique prefix 去聚合相关的名字函数，但是Python用对象名代替了这种功能。 Leading or trailing undrescores 下划线添加规则 _single_leading_underscore: weak “internal use” indicator. E.g. from M import * does not import objects whose name starts with an underscore. single_trailing_underscore_: used by convention to avoid conflicts with Python keyword, e.g.: Tkinter.Toplevel(master, class_='ClassName') __double_leading_underscore: when naming a class attribute, invokes name mangling (inside class FooBar, __boo becomes _FooBar__boo; see below). To avoid name clashes with subclasses, use two leading underscores to invoke Python’s name mangling rules. Python mangles these names with the class name: if class Foo has an attribute named __a, it cannot be accessed by Foo.__a. (An insistent user could still gain access by calling Foo._Foo__a.) Generally, double leading underscores should be used only to avoid name conflicts with attributes in classes designed to be subclassed. __double_leading_and_trailing_underscore__: “magic” objects or attributes that live in user-controlled namespaces. E.g. __init__, __import__ or __file__. Never invent such names; only use them as documented. Never use indistinguishable name Never use the characters ‘l’ (lowercase letter el), ‘O’ (uppercase letter oh), or ‘I’ (uppercase letter eye) as single character variable names. Package and Module NamesModules should have short, all-lowercase names. Underscores can be used in the module name if it improves readability. the C/C++ module has a leading underscore Class NamesClass names should normally use the CapWords convention. Type variable names 没懂？？？ Names of type variables introduced in PEP 484 should normally use CapWords preferring short names: T, AnyStr, Num. It is recommended to add suffixes _co or _contra to the variables used to declare covariant or contravariant behavior correspondingly. Examples from typing import TypeVar VT_co = TypeVar('VT_co', covariant=True) KT_contra = TypeVar('KT_contra', contravariant=True) Exception NamesBecause exceptions should be classes, the class naming convention applies here. However, you should use the suffix “Error” on your exception names (if the exception actually is an error). Global Variable Names 对于不想被其他文件导入的变量和函数，使用`all mechdanism或者使用prefixing an undersocre. (Let’s hope that these variables are meant for use inside one module only.) The conventions are about the same as those for functions. Modules that are designed for use via from M import * should use the __all__ mechanism to prevent exporting globals, or use the older convention of prefixing such globals with an underscore (which you might want to do to indicate these globals are “module non-public”). Function NamesFunction names should be lowercase, with words separated by underscores as necessary to improve readability. Function and method argumentsAlways use self for the first argument to instance methods. Always use cls for the first argument to class methods. If a function argument’s name clashes with a reserved keyword, it is generally better to append a single trailing underscore rather than use an abbreviation or spelling corruption. Thus class_ is better than clss. (Perhaps better is to avoid such clashes by using a synonym.) The difference between cls and self cls implies that method belongs to the class while self implies that the method is related to instance of the class,therefore member with cls is accessed by class name where as the one with self is accessed by instance of the class…it is the same concept as static member and non-static members in java if you are from java background. ConstantsConstants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include MAX_OVERFLOW and TOTAL. Designing for inheritanceAlways decide whether a class’s methods and instance variables (collectively: “attributes”) should be public or non-public. If in doubt, choose non-public; it’s easier to make it public later than to make a public attribute non-public. 如果需要暴露公共属性，必须保证向后兼容性（后来的代码），尽量设置属性为私有。 特别对于父类，需要仔细考虑代码的 Public and internal interfaces所有没有被文档记载的属性和方法都应该是私有的，也就是说文档记载的属性可以是私有的或者是公共的。 To better support introspection, modules should explicitly declare the names in their public API using the __all__ attribute. Setting __all__ to an empty list indicates that the module has no public API. Programming Recommendation少用的lambda表达式: Yes: def f(x): return 2*x No: f = lambda x: 2*x The first form means that the name of the resulting function object is specifically ‘f’ instead of the generic ‘’. This is more useful for tracebacks and string representations in general. The use of the assignment statement eliminates the sole benefit a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression). 在try语句中尽量少用的语句。坚持在函数末尾返回None或者应该有的表达式Use ''.startswith() and ''.endswith() instead of string slicing to check for prefixes or suffixes 更快 Object type comparisons should always use isinstance() instead of comparing types directly:Yes: if isinstance(obj, int): For sequences, (strings, lists, tuples), use the fact that empty sequences are false:Yes: if not seq: if seq: Don’t compare boolean values to True or False using ==:Yes: if greeting: Worse: if greeting is True:","link":"/2020/10/31/language/python/python-dai-ma-feng-ge-pep8-zong-jie/"},{"title":"opencv-python 之路径问题","text":"今天被OPEPCV-PYTHON整了，用cv2.imread(path)导入图片，结果啥都没有。查了半天发现是WINDOW下opencv在绝对路径下只支持\\作为分隔符，在相对路径上只支持/！！ 真的是气死我了，找了1个小时的bug！2020.10.22.16.30","link":"/2020/10/22/language/python/opencv-python-zhi-lu-jing-wen-ti/"},{"title":"python字符编码简记","text":"python字符集编码简记不讨论python2的情况下，python3将string分为两种类型，一种是str,另一种是bytes。前者存储unicode编码的字符串，负责存储unicode code point，后者负责按bytes存储字符串，也是就ACSII编码的code point存储。 str.encode()默认把str的unicode code point翻译成bytes编码。 bytes.decode()默认把bytes的byte code point翻译成utf-8编码。 举个例子： 特性两者不等价不可运算。 文件经典的文件字符处理方式是使用The unicode sandwich模型，模型通过接受外部字符并decode解码成unicode,最后str通过encode编码为bype。这就保证了程序内部的字符集的统一，但是外部文件的编码方式难以确定。如果使用错误的编码方式去解码，就是出现明显的乱码Mojibake。 python3的flie.read(textname, read_mode)选定了特定解码编码方式，如下图：encoding=locale.getgpreferredencoding()作为默认解码方式。","link":"/2020/10/10/language/python/python-zi-fu-bian-ma-jian-ji/"},{"title":"10. Regular Expression Matching","text":"10. Regular Expression Matching思路：hard的DP题，思路见代码。 代码：class Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false)); dp[0][0] = true; for(int j = 1; j &lt;= m; j++){ if(j &gt; 1 &amp;&amp; p[j - 1] == '*') dp[0][j] = dp[0][j - 2]; for(int i = 1; i &lt;= n; i++){ if(p[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1]; else if(p[j - 1] != '*') dp[i][j] = dp[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1]; else if(s[i - 1] != p[j - 2] &amp;&amp; p[j - 2] != '.') dp[i][j] = dp[i][j -2]; else // C* 子串可以匹配 // 1. 重复模式 C, 比如 [aa，a*] -&gt; [a，a*]，[ba，ba*] -&gt; [b，ba*] (-&gt; [b，b]) // 2. 放弃匹配 C, 比如 [b，ba*] -&gt; [b，b] // 我尝试去掉了 3 也是可以过的呵呵~ // 3. 第一次匹配 C, 比如 [a，a*] -&gt; [a ，a] //这题难就难在这, 想到状态转移方程 dp[i][j] = dp[i -1][j] || dp[i][j - 2] ;//|| dp[i][j - 1]; } } return dp[n][m]; } };","link":"/2020/12/23/shua-ti/dp/10-regular-expression-matching/"},{"title":"121. Best Time to Buy and Sell Stock","text":"121. Best Time to Buy and Sell Stock思路：记录最值。 代码：class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.size() == 0) return 0; int profit = 0; int minv = prices[0]; for(auto v : prices){ minv = min(minv, v); profit = max(profit, v - minv); } return profit; } };","link":"/2020/12/23/shua-ti/dp/121-best-time-to-buy-and-sell-stock/"},{"title":"123. Best Time to Buy and Sell Stock III","text":"123. Best Time to Buy and Sell Stock III思路： 借用简单股票的思路可以双向遍历price,获取price[0, i]和price[i, n]两个时间段各自最大的花费。 比较巧妙，用第一段操作的利润去抵消第二段购买时的花费，一次遍历。 股票的题目有很多，慢慢写。 代码：35% class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int d = prices.size(); vector&lt;int&gt; left(d, 0), right(d, 0); int maxv = prices[0], minv = prices[0], maxpro = 0; for(int i = 0; i &lt; d; ++i){ if(minv &gt; prices[i]){ maxv = minv = prices[i]; } maxv = max(maxv, prices[i]); maxpro = left[i] = max(left[i], max(maxpro, maxv - minv)); } maxv = minv = prices[d - 1], maxpro = 0; for(int i = d - 1; i &gt;= 0; --i){ if(maxv &lt; prices[i]){ maxv = minv = prices[i]; } minv = min(minv, prices[i]); maxpro = right[i] = max(right[i], max(maxpro, maxv - minv)); } int res = 0; for(int i = 0; i &lt; d; ++i){ res = max(res, left[i] + right[i]); // cout &lt;&lt; left[i] + right[i] &lt;&lt; endl; } return res; } }; 93% class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int d = prices.size(); int pro1, pro2, minp1, minp2; pro1 = pro2 = INT_MIN; minp1 = minp2 = INT_MAX; for(auto p : prices){ minp1 = min(p, minp1); pro1 = max(pro1, p - minp1); minp2 = min(minp2, p - pro1); pro2 = max(pro2, p - minp2); } return pro2; } };","link":"/2020/12/25/shua-ti/dp/123-best-time-to-buy-and-sell-stock-iii/"},{"title":"124. Binary Tree Maximum Path Sum","text":"124. Binary Tree Maximum Path Sum思路：这题有意思在DP。但算不上hard。 树上的最大路径之和可以转化为一个节点上的左右子树连起来的路径，而左右路径的最大长度分别可以通过左右子树的路径的一部分求得。考虑到子树路径之和小于0的情况，有当前节点和左右子树路径的最大长度为：DP[i] = max(max(DP[i * 2],0), max(DP[i * 2 + 1],0) + val 。同时可以求出，当前节点最长路径，pathsum = max(DP[i * 2],0) + max(DP[i * 2 + 1],0) + val。 代码： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int maxv = 0; public: int maxPathSum(TreeNode* root) { maxv = root-&gt;val; maxPathSumCore(root); return maxv; } int maxPathSumCore(TreeNode *root){ if(!root) return 0; int lv = maxPathSumCore(root-&gt;left); lv = max(0, lv); int rv = maxPathSumCore(root-&gt;right); rv = max(0, rv); maxv = max(maxv, lv + rv + root-&gt;val); return root-&gt;val + max(lv, rv); } };","link":"/2021/04/19/shua-ti/dp/124-binary-tree-maximum-path-sum/"},{"title":"1289.Minimum Falling Path Sum2","text":"1289. Minimum Falling Path Sum II思路：这题比较简单，dp做就行。 寻找最小值的时候可以直接记录，或者用堆记录前2个最小值，从而快速dp。而记录的同时可以发现，之前多余dp信息无需存储，所以可以把空间复杂度从$O(n)$降到$O(1)$。 代码：class Solution { public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; arr) { int dp[2][300] = {0}; int minp[300]; int len = arr.size(); priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq; //init for(int i = 0; i &lt; len; i++){ dp[0][i] = arr[0][i]; if(pq.size() &lt; 2) pq.push(arr[0][i]); else if(pq.top() &gt; arr[0][i]){ pq.pop(); pq.push(arr[0][i]); } } //dp for(int i = 1; i &lt; len; i++){ int nowr = i &amp; 1; int lastr = (i - 1) &amp; 1; int min2 = pq.top(); pq.pop(); int min1 = pq.top(); pq.pop(); for(int j = 0; j &lt; len; j++){ if(min1 == dp[lastr][j]) dp[nowr][j] = min2 + arr[i][j]; else dp[nowr][j] = min1 + arr[i][j]; if(pq.size() &lt; 2){ pq.push(dp[nowr][j]); } else if(dp[nowr][j] &lt; pq.top()){ pq.pop(); pq.push(dp[nowr][j]); } } } pq.pop(); return pq.top(); } };","link":"/2020/09/23/shua-ti/dp/1289-minimum-falling-path-sum2/"},{"title":"139. Word Break","text":"139. Word Break思路：动态规划：$dp[i]=1$表示s子串s.substr(0,i + 1)可以被在词典中正确切分。 代码:77% class Solution { public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { // if(s.size()) set&lt;string&gt; dict; for(auto t : wordDict) dict.insert(t); vector&lt;int&gt; dp(s.size(), 0); // int lastdo = 0; for(int i = 0;i &lt; s.size(); ++i){ if(dict.count(s.substr(0, i + 1))) dp[i] = 1; for(int j = i; j &gt; 0; j--){ if(dp[j - 1] &amp;&amp; dict.count(s.substr(j, i - j + 1))){ dp[i] = 1; break; } } } if(dp[s.size() - 1]) return true; return false; } };","link":"/2020/12/13/shua-ti/dp/139-word-break/"},{"title":"1411. Number of Ways to Paint N × 3 Grid","text":"1411. Number of Ways to Paint N × 3 Grid 题目不难，但是因为一个累加的初始化的小bug没有找出来而浪费了好多时间！ 思路：先遍历寻找可以叠放的图块，然后dp数量即可，空间状态可压缩。注意，每次dp数组后初始化问题。 当然这里也可以看成矩阵乘法。 官网的另一中解法涉及到线性递推式的优化。 代码：class Solution { public: int numOfWays(int n) { int cmap[13][13] ={0}; int posidx = 1; map&lt;int, int&gt; pos; for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ for(int k = 0; k &lt; 3; k++){ if(i == j || j == k) continue; int countR = i * 100 + j * 10 + k; if(pos[countR] == 0) pos[countR] = posidx++; for(int s = 0; s &lt; 3; s++){ for(int t = 0; t &lt; 3; t++){ for(int q = 0; q &lt; 3; q++){ if(s == t || t == q) continue; int countC = s * 100 + t * 10 + q; if(pos[countC] == 0) pos[countC] = posidx++; if(i == s || j == t || k == q) continue; cmap[pos[countR] - 1][pos[countC] - 1] = 1; } } } } } } cout &lt;&lt; posidx &lt;&lt; endl; // for(int i = 0; i &lt; 12; i++) { // for(int j = 0; j &lt; 12; j++) // cout &lt;&lt; cmap[i][j] &lt;&lt; ' '; // cout &lt;&lt; endl; // } long long dp[2][12] = {0}; long long MOD = 1e9 + 7; for(int i = 0; i &lt; 12; i++) dp[0][i] = 1; for(int i = 1; i &lt; n; i++){ int newr = i &amp; 1; int lastr = (i - 1) &amp; 1; for(int j = 0; j &lt; 12; j++){ dp[newr][j] = 0; for(int k = 0; k &lt; 12; k++) if(cmap[j][k] == 1){ dp[newr][j] = (dp[newr][j] + dp[lastr][k]) % MOD; } } // for(int t = 0; t &lt; 12; t++) // cout &lt;&lt; dp[newr][t] &lt;&lt; ' '; // cout &lt;&lt; endl; } long long sum = 0; int newr = (n - 1) &amp; 1; for(int i = 0; i &lt; 12; i++){ sum = (sum + dp[newr][i]) % MOD; } return sum; } };","link":"/2020/09/27/shua-ti/dp/1411-number-of-ways-to-paint-n-x-3-grid/"},{"title":"188. Best Time to Buy and Sell Stock IV","text":"188. Best Time to Buy and Sell Stock IV思路：把transaction拆分为买buy和卖sell，sell[i][j]代表对于第i个物品，第j次卖操作后最大利润。buy和sell的转移方程如代码所示。 形式上更像一个状态转移机。 代码：class Solution { public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { int d = prices.size(); if(d &lt; 2) return 0; k = min(k, d);// 超过n的k是没有意义的 // buy一开始啥利润都没有应该为0，但是由于购买后利润可能会为负数，所以必须初始化为-INF vector&lt;int&gt; buy(k + 1, INT_MIN), sell(k + 1, 0); for(int i = 0;i &lt; d; ++i){ for(int j = 1; j &lt;= k; ++j){ buy[j] = max(buy[j], sell[j - 1] - prices[i]); sell[j] = max(sell[j], buy[j] + prices[i]); } } return sell[k]; } }; 其中不优化空间的转移方程如下： for(int i = 0;i &lt; d; ++i){ for(int j = 1; j &lt;= k; ++j){ buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]); sell[i][j] = max(sell[i - 1][j], buy[i - 1][j] + prices[i]); } }","link":"/2020/12/25/shua-ti/dp/188-best-time-to-buy-and-sell-stock-iv/"},{"title":"198. House Robber","text":"198. House Robber思路： 将偷和不偷的两种状态分别记录到两个dp上，dp方程见代码1 如果不分解，记$dp[i]$为在房子$i$所能获得最大的金钱收益，应该可以比较偷窃第$i$房子加上之前$i-2$个房子所能偷窃的最大金额，和只偷窃前$i-1$房子的最大金额。 代码：代码1 class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; dp1(n, 0); vector&lt;int&gt; dp0(n, 0); dp0[0] = 0; dp1[0] = nums[0]; for(int i = 1; i &lt; n; ++i){ dp0[i] = max(dp0[i - 1], dp1[i - 1]); dp1[i] = dp0[i - 1] + nums[i]; } return max(dp1[n - 1], dp0[n - 1]); } }; dp2 100% class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; else if(n == 1) return nums[0]; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for(int i = 2; i &lt; n; ++i){ dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[n - 1]; } };","link":"/2020/12/07/shua-ti/dp/198-house-robber/"},{"title":"213. House Robber II","text":"213. House Robber II思路：首和尾的数字元素不能同时选择的。那么直接把列表拆分成两个$[0,…., n - 2]$和$[1,…..,n-1]$，分开DP就行了。 使用$dp[i]$表示数组在元素$i$上所能获得的最大金钱。 当然也可进行动作拆分。 代码：class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; else if(n &lt;= 1) return nums[0]; return max(getdp(nums, 0, n - 1), getdp(nums, 1, n)); } int getdp(vector&lt;int&gt; nums, int s, int e){ if(s &gt;= e) return 0; if(s + 2 &lt;= e) //初始化 nums[s + 1] = max(nums[s], nums[s + 1]); for(int i = s + 2; i &lt; e; ++i){ nums[i] = max(nums[i - 2] + nums[i], nums[i - 1]); } return nums[e - 1]; } };","link":"/2020/12/28/shua-ti/dp/213-house-robber-ii/"},{"title":"221. Maximal Square","text":"221. Maximal Square思路：$dp[i][j]$为正方形的右下角。根据行列扩展或者三个正方形可以进行dp。 代码：思考不成熟的代码 15% class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int n = matrix.size(); if(n == 0) return 0; int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; row(n, vector&lt;int&gt;(m, 0)); vector&lt;vector&lt;int&gt;&gt; col(n, vector&lt;int&gt;(m, 0)); vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0)); int maxarea = 0; for(int i = 0;i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == '1'){ row[i][j] = (i == 0) ? 1 : row[i - 1][j] + 1; col[i][j] = (j == 0) ? 1 : col[i][j - 1] + 1; int minsqu; if(i == 0 || j == 0 ) minsqu = 0; else minsqu = squ[i - 1][j - 1]; int maxl = min(col[i][j], min(row[i][j], minsqu + 1)); squ[i][j] = maxl; maxarea = max(maxarea, maxl * maxl); }else{ row[i][j] = col[i][j] = squ[i][j] = 0; } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl; } } return maxarea; } }; 真滴懒，再懒不能懒脑力。 24% class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int n = matrix.size(); if(n == 0) return 0; int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0)); int maxarea = 1; for(int i = 0;i &lt; n; ++i){ if(matrix[i][0] == '1') squ[i][0] = 1; if(matrix[0][i] == '1') squ[0][i] = 1; } for(int i = 1;i &lt; n; ++i){ for(int j = 1; j &lt; m; ++j){ if(matrix[i][j] == '1'){ int maxl = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1; squ[i][j] = maxl; maxarea = max(maxarea, maxl * maxl); }else{ squ[i][j] = 0; } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl; } } return maxarea; } }; 优化时间 98% class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if(matrix.empty()) return 0; int n = matrix.size(); int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0)); int maxl = 0; for(int i = 0;i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == '1'){ if(i &gt; 0 &amp;&amp; j &gt; 0){ squ[i][j] = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1; } else squ[i][j] = 1; if(squ[i][j] &gt; maxl ) maxl = squ[i][j]; } } } return maxl * maxl; } };","link":"/2020/12/09/shua-ti/dp/221-maximal-square/"},{"title":"279. Perfect Squares","text":"279. Perfect Squares思路： dp。均摊复杂度比较低 贪心算法，贪 bfs+贪心 代码：dp 66% class Solution { public: int numSquares(int n) { vector&lt;long long&gt; dp(n + 1, INT_MAX); dp[0] = 0; for(long long i = 1; i &lt;= n; ++i){ for(long long j = 1; j * j &lt;= i; ++j){ long long t = i - j * j; dp[i] = min(dp[i], dp[t] + 1); } } return dp[n]; } }; 贪心搜索 70% class Solution { public: vector&lt;long long&gt; dp; //数字平方搜索值 int numSquares(int n) { dp.resize(sqrt(n) + 1); for(int i = 1; i &lt; dp.size(); ++i){ dp[i - 1] = i * i; } for(int i = 1; i &lt;= n; ++i){ if(getLevel(n, i)) return i; } return 0; } bool getLevel(int n, int ssize){// ssize个平方数的和是否等于n if(ssize == 1){ if(count(dp.begin(), dp.end(), n) &gt; 0) return true; return false; } for(int i = 0; i &lt; dp.size(); ++i){ if(getLevel(n - dp[i], ssize - 1)) return true; } return false; } }; bfs搜索 17%…… unordered_set的的损耗还是太大了吗 class Solution { public: vector&lt;long long&gt; dp; int numSquares(int n) { dp.resize(sqrt(n) + 1); for(int i = 1; i &lt; dp.size() + 1; ++i){ dp[i - 1] = i * i; } int level = 1; unordered_set&lt;int&gt; que, next_que; //8%-&gt;17% que.insert(n); //层序遍历，整层树。 while(1){ } return 0; } void search(unordered_set&lt;int&gt; que, unordered_set&lt;int&gt; next_que){ for(auto t : que){ for(int i = 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;= t ; ++i){ // cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl; if(dp[i] == t) return level; next_que.insert(t - dp[i]); } } level += 1; que = next_que; next_que.clear(); } }; 再优化一下28% class Solution { public: vector&lt;long long&gt; dp; int numSquares(int n) { dp.resize(sqrt(n) + 1); for(int i = 1; i &lt; dp.size() + 1; ++i){ dp[i - 1] = i * i; } int level = 1; unordered_set&lt;int&gt; que1, que2; //8%-&gt;17% que1.insert(n); //层序遍历，整层树。 while(1){ if(level &amp; 1){ if(search(que1, que2)) return level; }else{ if(search(que2, que1)) return level; } level++; } return 0; } bool search(unordered_set&lt;int&gt; &amp;que, unordered_set&lt;int&gt; &amp;next_que){ for(auto t : que){ for(int i = 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;= t ; ++i){ // cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl; if(dp[i] == t) return true; next_que.insert(t - dp[i]); } } que.clear(); return false; } };","link":"/2020/12/10/shua-ti/dp/279-perfect-squares/"},{"title":"300. Longest Increasing Subsequence","text":"300. Longest Increasing Subsequence思路： dp，复杂度$O(n^2)$。 贪心，用$d[i]$维护长度为i的子串结尾数字的最小值。在遍历的过程中更新，增长d[i]。同时d[i]的单调性，可轻松证明。$o(nlogn)$。 如果求解的不是strictly increasing subsequence，只需要稍稍修改一下即可。 代码：dp class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; dp(n, 1); int maxl = 1; for(int i = 1; i &lt; n; i++){ for(int j = 0; j &lt; i; ++j){ if(nums[j] &lt; nums[i] &amp;&amp; dp[j] + 1 &gt; dp[i] ){ dp[i] = dp[j] + 1; maxl = max(dp[i], maxl); } } } return maxl; } }; 贪心+二分 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; d; int len = 0; for(int i = 0;i &lt; n; ++i){ if(len == 0 || d[len - 1] &lt; nums[i]){ d.push_back(nums[i]); len++; // cout &lt;&lt; len ; }else{ auto it = lower_bound(d.begin(), d.end(), nums[i]); if( *it &gt; nums[i]){ //搜索第一个j，使得nums[j - 1] &lt; d[i] &lt; nums[j],只需要两个条件lower_bound和大于号组合就行！ *it = nums[i]; } } } return len; } };","link":"/2020/12/13/shua-ti/dp/300-longest-increasing-subsequence/"},{"title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"309. Best Time to Buy and Sell Stock with Cooldown思路：无限购买，每个prices都可以设置为一个购买点。把状态按照已经购买状态$f[i][0]$、处于冷冻状态的刚卖出$f[i][1]$和不处于冷冻期的卖出状态$f[i][2]$，分成三个部分，可以写出dp转移方程：$$\\begin{split}f[i][0] &amp;= max(f[i - 1][0], f[i - 1][2] - prices[i]) \\\\f[i][1] &amp;= f[i - 1][0] + prices[i]\\\\f[i][2] &amp;= max(f[i - 1][1], f[i - 1][2]) \\\\end{split}$$初始化$f[0][0]= -prices[0]$，最后取结果$max(f[n-1])[1], f[n-1][2])$。 DP状态方程巧妙在把一个状态拆分成不同的并行状态，同时在不同状态可以相互转移，自然的添加了一次购买，一次卖出，一次等待的限制。 代码：class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int d = prices.size(); if(d &lt;= 1) return 0; vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(3)); dp[0][0] = -prices[0]; for(int i = 1; i &lt; d; ++i){ dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]); dp[i][1] = dp[i - 1][0] + prices[i]; dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]); } return max(dp[d - 1][1], dp[d - 1][2]); } };","link":"/2020/12/26/shua-ti/dp/309-best-time-to-buy-and-sell-stock-with-cooldown/"},{"title":"312. Burst Balloons","text":"312. Burst Balloons思路： Hard题做了才有收获啊！lc上题库里几道经典的具有锻炼思维和思考能力的题。 拿到手，首先映入脑海里明显应该是贪心或者分治算法：仔细思考一下，贪心发现没有依据，也没有例子；分治算法把考虑把求取问题dp(l, r)——开区间的(l,r)一组气球全部戳爆以后，可以获取最大金币数量。如果第一选取k个气球戳爆，则有子问题(l,k)和(k,r)，但是可以发现两个子问题是相互依赖的。也就是说一个问题解的选择会影响另一个问题的解的选择。所以这个思路也不行。 Amazing的是，我们可以反过来考虑问题！我们把整个过程逆序，把戳爆存在的气球，变成从一个气球都不存在，添加一个个不存在的气球。dp(l, r)问题就是在寻找，把(l, r)中的所有位置填满气球，可以获得最大金币数量。思考一下如何分解为子问题：$$dp(l, r) = max_{i = l + 1}^{r - 1}[dp(l , i) + dp(i, r) + nums[i] * nums[l] * nums[r]]$$具体计算可以用记忆化搜索和DP计算。 看了下大神的解法，居然还有用启发式搜索的！太顶了！ 代码：记忆化搜索（自顶向下搜索）： class Solution { vector&lt;vector&lt;int&gt;&gt; dp; int n = 0; public: int maxCoins(vector&lt;int&gt;&amp; nums) { nums.insert(nums.begin(), 1); nums.push_back(1); n = nums.size(); dp.resize(n, vector&lt;int&gt;(n)); search(nums, 0, n - 1); return dp[0][n - 1]; } int search(vector&lt;int&gt;&amp;nums, int l, int r){ // find max coins in search scope (left, right). if(dp[l][r]) return dp[l][r]; int maxCoins = 0; for(int i = l + 1; i &lt; r; ++i){ int amount = search(nums, l, i) + search(nums, i, r) + nums[l] * nums[r] * nums[i]; maxCoins = max(maxCoins, amount); } return dp[l][r] = maxCoins; } }; DP计算（自底向上搜索）： class Solution { vector&lt;vector&lt;int&gt;&gt; dp; int n = 0; public: int maxCoins(vector&lt;int&gt;&amp; nums) { nums.insert(nums.begin(), 1); nums.push_back(1); n = nums.size(); dp.resize(n, vector&lt;int&gt;(n)); // find max coins in search scope (left, right). // for(int len = 1; len &lt; n - 1; ++len){ // for(int i = 0; i + len + 1 &lt; n; ++i){ // int j = i + len + 1; // for(int k = i + 1; k &lt; j; ++k){ // dp[i][j] = max(dp[i][j], // dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]); // } // } // } // 更Cache一点的写法应该是 for(int j = 2; j &lt; n; ++j){ for(int i = j - 2; i &gt;= 0; --i){ for(int k = j - 1; k &gt; i; --k){ //从j出发更快~ // for(int k = i + 1; k &lt; j; ++k){ dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]); } } } return dp[0][n - 1]; } }; 考虑下cache优化计算过程","link":"/2021/05/05/shua-ti/dp/312-burst-balloons/"},{"title":"322. Coin Change","text":"322. Coin Change思路：完全背包思路，注意一下初始值。 代码：class Solution { public: const int INF = INT_MAX / 2; int coinChange(vector&lt;int&gt;&amp; coins, int amount) { vector&lt;int&gt; dp(amount + 1, INF); // 简化 初始化为-1 不好利用min 过滤;使用条件 优化方向(dp[i]--)从初始条件（dp[i] = INF）开始， // 也许更好的初始值是 amount + 2; dp[0] = 0; for(auto v : coins){ for(int i = v; i &lt;= amount; ++i){ dp[i] = min(dp[i], dp[i - v] + 1); } } return dp[amount] == INF ? -1 : dp[amount]; } };","link":"/2020/12/18/shua-ti/dp/322-coin-change/"},{"title":"337. House Robber III","text":"337. House Robber III思路：这里的dp推错了，尴尬啊。 一个简单的树上DP 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { using tii = tuple&lt;int, int&gt;; public: int rob(TreeNode* root) { tii res = stelan(root); return max(get&lt;0&gt;(res), get&lt;1&gt;(res)); } tii stelan(TreeNode* root){ if(!root) return make_tuple(0, 0); tii left = stelan(root-&gt;left); tii right = stelan(root-&gt;right); // dp 推导式： // dp[i][0] = max(dp[i * 2][1], dp[i * 2][0]) + max(dp[i * 2 + 1][1], dp[i * 2 + 1][0]) // dp[i][1] = val[i] + dp[i * 2][0] + dp[i * 2 + 1][0]; return make_tuple(max(get&lt;0&gt;(left), get&lt;1&gt;(left)) + max(get&lt;0&gt;(right), get&lt;1&gt;(right)), get&lt;0&gt;(left) + get&lt;0&gt;(right) + root-&gt;val); } };","link":"/2021/04/30/shua-ti/dp/337-house-robber-iii/"},{"title":"343. Integer Break","text":"343. Integer Break思路： dp分解为两个和为n数字，求出最大积即可。 数学方法题解 代码：class Solution { public: vector&lt;int&gt; dp; int getmaxdp(int k){ if(dp[k]) return dp[k]; int maxp = 0; for(int i = 1;i &lt;= k / 2 ; i++){ maxp = max(maxp, max(i, getmaxdp(i)) * max(k - i, getmaxdp(k - i))); } dp[k] = maxp; return maxp; } int integerBreak(int n) { dp.resize(60); dp[1] = 1; dp[2] = 1; return getmaxdp(n); } }; 更简洁的拆分方法 class Solution { public: vector&lt;int&gt; dp; int getmaxdp(int k){ if(dp[k]) return dp[k]; int maxp = 0; for(int i = 1;i &lt; k ; i++){ maxp = max(maxp, max(i * (k - i), i * getmaxdp(k - i))); // 拆出一个整数作为因子 } dp[k] = maxp; return maxp; } int integerBreak(int n) { dp.resize(60); dp[1] = 1; dp[2] = 1; return getmaxdp(n); } }; 正向dp class Solution { public: int integerBreak(int n) { vector&lt;int&gt; dp(60); dp[1] = 1; dp[2] = 1; for(int i = 3; i &lt;= n; ++i){ int cur = 1; for(int j = 1; j &lt; i; ++j){ cur = max(cur, max(j * (i - j), j * dp[i - j])); } dp[i] = cur; } return dp[n]; } }; 数学方法 class Solution { public: int integerBreak(int n) { if(n &lt; 4) return n - 1; // 2:1, 3:2 int res = 1; while(n &gt; 4){ // 尽量取3为分解因子 res *= 3; n -= 3; } if(n == 4) res *= 4; // n % 3 == 1, 取一个4作为分解因子 else res *= n; return res; } };","link":"/2020/12/29/shua-ti/dp/343-integer-break/"},{"title":"376. Wiggle Subsequence","text":"376. Wiggle Subsequence思路：注意边界，气死人。 分析问题不够仔细透彻。 代码： class Solution { public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; up(n), down(n); up[0] = down[0] = 1; for(int i = 1; i &lt; n; ++i){ if(nums[i] &gt; nums[i - 1]) up[i] = max(down[i - 1] + 1, up[i - 1]); else up[i] = up[i - 1]; if(nums[i] &lt; nums[i - 1]) down[i] = max(up[i - 1] + 1, down[i - 1]); else down[i] = down[i - 1]; } return max(up[n - 1], down[n - 1]); } }; 这道题也可以用贪心去做。取出最大波谷变化就可~","link":"/2020/12/31/shua-ti/dp/376-wiggle-subsequence/"},{"title":"413. Arithmetic Slices 2刷","text":"413. Arithmetic Slices思路： dp[i]以数字ith为结尾的最长arithmetic sequence的长度，（被包含的dp[k]==0） $dp[i]$以数字i th为结尾的arithmetic sequence的数目个数。 代码：class Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { int n = A.size(); vector&lt;int&gt; dp(n, 0); if(n &lt; 2) return 0; for(int i = 2; i &lt; n; ++i){ if(A[i - 1] - A[i - 2] == A[i] - A[i - 1]){ dp[i] = dp[i - 1] + 1; dp[i - 1] = 0; }// } int res = 0; for(int i = 2; i &lt; n; ++i){ if(dp[i]){ res += (dp[i] + 1) * dp[i] / 2; } } return res; } }; 也可以直接加 class Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { // vector&lt;int&gt; dp(A.size(), 0); int sum = 0, lsum = 0; for(int i = 2; i &lt; A.size(); i++){ if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){ lsum++;//长度为3，4，……，lsum的以A[i]为结尾的arithmetic sequence sum += lsum; }else lsum = 0; // } return sum; } };","link":"/2020/12/07/shua-ti/dp/413-arithmetic-slices-2-shua/"},{"title":"413. Arithmetic Slices","text":"413. Arithmetic Slices题目简单，倒是遇到一个bug：new一个size==0的数组会越界错误。 ez 思路：dp[i]表示以i为终点的arthmetic array的数量。 代码：class Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { int *dp = new int[0]; int sum = 0; memset(dp, 0, sizeof(dp)); for(int i = 2; i &lt; A.size(); i++){ if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){ dp[i] = dp[i - 1] + 1; sum += dp[i]; } } return sum; } }; // 3: 1 // 4: 2 + 1 = 3 // 5: 3 + 2 + 1 =6; 优化空间。 class Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { // vector&lt;int&gt; dp(A.size(), 0); int sum = 0, lsum = 0; for(int i = 2; i &lt; A.size(); i++){ if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){ lsum++; sum += lsum; }else lsum = 0; // } return sum; } }; // 3: 1 // 4: 2 + 1 = 3 // 5: 3 + 2 + 1 =6;","link":"/2020/09/28/shua-ti/dp/413-arithmetic-slices/"},{"title":"416. Partition Equal Subset Sum","text":"416. Partition Equal Subset Sum思路类似01背包的题，不过不用考虑价值。 代码 class Solution { public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum % 2) return false; int n = nums.size(); int target = sum / 2; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(target + 1, 0)); for(int i = 0; i &lt;= n; ++i){ dp[i][0] = 1; } for(int i = 1; i &lt;= n; ++i){ for(int j = nums[i - 1]; j &lt;= target; ++j){ dp[i][j] = dp[i - 1][j - nums[i - 1]] || dp[i - 1][j]; } } return dp[n][target]; } }; 空间压缩 class Solution { public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum % 2) return false; int n = nums.size(); int target = sum / 2; vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; for(int i = 1; i &lt;= n; ++i){ for(int j = target; j &gt;= nums[i - 1]; --j){//逆序 dp[j] = dp[j - nums[i - 1]] || dp[j]; } } return dp[target]; } };","link":"/2020/12/16/shua-ti/dp/416-partition-equal-subset-sum/"},{"title":"474. Ones and Zeroes","text":"474. Ones and Zeroes思路：类似于01背包，但是不同 的是有两个范围限制。属于二维dp. 代码：class Solution { public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for(auto str : strs){ auto [c1, c2] = count(str); for(int i = m; i &gt;= c1; i--){ for(int j = n; j &gt;= c2; j--){ dp[i][j] = max(dp[i][j], dp[i - c1][j - c2] + 1); } } } return dp[m][n]; } pair&lt;int, int&gt; count(string str){ int c1 = 0, c2 = 0; for(auto c : str){ if(c == '0') c1++; else c2++; } return make_pair(c1, c2); } };","link":"/2020/12/18/shua-ti/dp/474-ones-and-zeroes/"},{"title":"494. Target Sum","text":"494. Target Sum思路： 代码：class Solution { public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) { const int T = 2001; if(nums.size() == 0) return 0; int sum = 0; for(auto v : nums) sum += abs(v); if(sum &lt; abs(S)) return 0; int dp[23][T * 2]; //bugs: 20; memset(dp, 0, sizeof(dp)); dp[0][T] = 1; for(int i = 0; i &lt; nums.size(); ++i){ for(int j = 0; j &lt; T * 2; ++j){ if(dp[i][j]){ dp[i + 1][j + nums[i]] += dp[i][j]; dp[i + 1][j - nums[i]] += dp[i][j]; // cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; j + nums[i] &lt;&lt; &quot; &quot; &lt;&lt; dp[i + 1][j + nums[i]] &lt;&lt; endl; // cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; j - nums[i] &lt;&lt; &quot; &quot; &lt;&lt; dp[i + 1][j - nums[i]] &lt;&lt; endl; } } // cout &lt;&lt; &quot;#&quot; &lt;&lt; i &lt;&lt;endl; } return dp[nums.size()][S + T]; } };","link":"/2020/12/31/shua-ti/dp/494-target-sum/"},{"title":"53. Maximum Subarray","text":"53. Maximum Subarray思路： dp 线段树区间查询 以下的题解，摘录自LeetCode： 上面的时间渐进上界大概是$o(2N)$。 代码：class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n &lt;= 0 ) return 0; int maxsum = nums[0]; int adds = 0; for(int i = 0;i &lt; n; ++i){ adds += nums[i]; maxsum = max(maxsum, adds); if(adds &lt; 0){ adds = 0; } } return maxsum; } }; 线段树多段查询 class Solution { public: struct sts{ int msum, isum, lsum, rsum; }; sts pushup(sts l, sts r){ sts a; a.msum = max(max(l.msum, r.msum), l.rsum + r.lsum); a.lsum = max(l.isum + r.lsum, l.lsum); a.rsum = max(r.isum + l.rsum, r.rsum); a.isum = l.isum + r.isum; return (sts){a.msum, a.isum, a.lsum, a.rsum}; } sts get(vector&lt;int&gt; &amp;nums, int l, int r){ if(r == l){ return (sts){nums[r], nums[r], nums[r], nums[r]}; } int m = (r + l) &gt;&gt; 1; sts a = get(nums, l, m); sts b = get(nums, m + 1, r); return pushup(a, b); } int maxSubArray(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; return get(nums, 0, nums.size() - 1).msum; } };","link":"/2020/12/28/shua-ti/dp/53-maximum-subarray/"},{"title":"542. 01 Matrix","text":"542. 01 Matrix思路： 从数字0开始bfs到1的最短路 由于从数字1到最近的数字零之间的最短路径，如果不是相邻，那么必定有在路径上数字1到同样的数字0有一条最短路径。如此便可以在四个移动方向上分别dp最短路径长度即可。 代码：bfs 66% class Solution { public: int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dis(n, vector&lt;int&gt;(m , 0)); vector&lt;vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0)); queue&lt;pair&lt;int,int&gt;&gt; que; for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == 0){ que.push(make_pair(i ,j)); vis[i][j] = 1; } } } int qsize; while(que.size()){ qsize = que.size(); for(int i = 0; i &lt; qsize; ++i){ pair&lt;int,int&gt; t = que.front(); que.pop(); int x = t.first; int y = t.second; // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; for(int j = 0; j &lt; 4; ++j){ int nx = x + dx[j]; int ny = y + dy[j]; // cout &lt;&lt;&quot;@&quot; &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl; if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) continue; if(!vis[nx][ny]){ vis[nx][ny] = 1; // exclude the deplucation of elements in queue. dis[nx][ny] = dis[x][y] + 1; que.push(make_pair(nx, ny)); // cout &lt;&lt; nx &lt;&lt; ' ' &lt;&lt; ny &lt;&lt; ' ' &lt;&lt; dis[nx][ny] &lt;&lt; endl; } } } } return dis; } }; dp 97% class Solution { public: int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m , INT_MAX - 3)); //bugs: max value should be bigger than m and n. for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == 0){ dp[i][j] = 0; continue; } if(i &gt; 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1); if(j &gt; 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1); } } for(int i = n - 1; i &gt;=0; --i){ for(int j = m - 1; j &gt;= 0; --j){ if(matrix[i][j] == 0) continue; if(i != n - 1) dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1); if(j != m - 1) dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1); } } return dp; } };","link":"/2020/12/08/shua-ti/dp/542-01-matrix/"},{"title":"583. Delete Operation for Two Strings","text":"583. Delete Operation for Two Strings思路：此题可以转化为最长公共子序列（LCS）。用动态规划解决LCS即可。 代码：class Solution { public: int minDistance(string word1, string word2) { int n = word1.size(), m = word2.size(); // vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); //vector分配空间耗时很大，同时占用的空间也大 int dp[n + 1][m + 1]; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= m;- ++j){ if(word1[i - 1] == word2[j - 1]){ dp[i][j] = dp[i - 1][j - 1] + 1; }else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); } } return n + m - 2 * dp[n][m]; } }; 运行效率：leetcode的运行时间真是的迷，不过数据集太小了，确实难以准确评估。","link":"/2020/12/29/shua-ti/dp/583-delete-operation-for-two-strings/"},{"title":"594. Longest Harmonious Subsequence","text":"594. Longest Harmonious Subsequence思路：一道经典的最大递增子序列的变形题 结果用DP思路做了半天，发现越做复杂！？？？？ 怀疑人生的同时发现自己的思路还是太窄了。 代码：class Solution { public: int findLHS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); unordered_map&lt;int, int&gt; ct; int maxl = 0; for(auto &amp; v : nums){ ct[v]++; int t = max(ct[v+1], + ct[v - 1]); if(t) maxl = max(t + ct[v], maxl); } return maxl; } };","link":"/2021/01/30/shua-ti/dp/594-longest-harmonious-subsequence/"},{"title":"64. Minimum Path Sum","text":"64. Minimum Path Sum思路:dp长度 代码：class Solution { public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); if(n == 0) return 0; int m = grid[0].size(); if(m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, 0)); dp[0][0] = grid[0][0]; for(int i = 1; i &lt; m; ++i){ dp[0][i] = dp[0][i - 1] + grid[0][i]; } for(int i = 1; i &lt; n; ++i){ dp[i][0] = dp[i - 1][0] + grid[i][0]; } for(int i = 1; i &lt; n; ++i){ for(int j = 1; j &lt; m; ++j){ dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]; } } return dp[n - 1][m - 1]; } };","link":"/2020/12/08/shua-ti/dp/64-minimum-path-sum/"},{"title":"650. 2 Keys Keyboard","text":"650. 2 Keys Keyboard思路：dp[i] 为长度为i的字符串需要的最小操作数。 反推 最小质数 素数分解 代码：这个空间速度 class Solution { public: int minSteps(int n) { vector&lt;int&gt; dp( n + 1, INT_MAX); dp[1] = 0; for(int i = 1; i &lt; n; i++){ if(dp[i] != INT_MAX){ if(i + i &lt;= n){ for(int j = i * 2, k = 2; j &lt;=n; j += i, k++){ dp[j] = min(dp[i] + k, dp[j]); } } } } return dp[n]; } }; 这种思路有一点：为啥最小的j就会是dp[i]最小呢？ class Solution { public: int minSteps(int n) { vector&lt;int&gt; dp( n + 1, INT_MAX); dp[1] = 0; int h = sqrt(n); for(int i = 2; i &lt;= n; i++){ dp[i] = i; for(int j = 2; j &lt;= h; j++){ if(i % j == 0){ dp[i] = dp[j] + dp[i / j]; break; } } } return dp[n]; } }; 素数分解 class Solution { public: int minSteps(int n) { int factor = 2, ans = 0; while(n &gt; 1){ while(n % factor == 0 &amp;&amp; n &gt; 1){ n /= factor; ans += factor; //选择（复制 + 粘粘）的一个复合操作是最快的，所以用最小的素数步骤进行一次操作 //之所以是素数步骤， 是因为合数都被比他小的素数因子所分解了 } factor++; } return ans; } };","link":"/2020/12/21/shua-ti/dp/650-2-keys-keyboard/"},{"title":"70. Climbing Stairs","text":"70. Climbing Stairs思路：dp，用两个变量存储长度为N的数组优化空间 。 代码： class Solution { public: int climbStairs(int n) { int a = 1, b = 1, c = 2, k = 2; while(k &lt;= n){ c = a + b; a = b; b = c; k++; } if(n == 0) return 0; else if(n == 1) return 1; else return c; } };","link":"/2020/12/07/shua-ti/dp/70-climbing-stairs/"},{"title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"714. Best Time to Buy and Sell Stock with Transaction Fee思路：做过了309题的话，这题就非常容易解决。注意fee的费用在交易完成后结算，不然可能有手续费没有扣完的尴尬情况。 代码：空间可优化 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { int d = prices.size(); if(d &lt;= 1) return 0; vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(2)); dp[0][0] = -prices[0]; for(int i = 1; i &lt; d; ++i){ dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = max(dp[i -1][1], dp[i][0] + prices[i] - fee); } return dp[d- 1][1]; } };","link":"/2020/12/26/shua-ti/dp/714-best-time-to-buy-and-sell-stock-with-transaction-fee/"},{"title":"72. Edit Distance","text":"72. Edit Distance 思路：dp[i][j]表示子串word[0……i)和子串word[0……j)需要变化的最小次数。 非常巧妙啊，很快就可以敲出代码，注意初始化边缘值。 代码：class Solution { public: int minDistance(string word1, string word2) { int n = word1.size(); int m = word2.size(); // if(n == 0 || m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for(int i = 0; i &lt;=n; ++i){ for(int j = 0; j &lt;= m; ++j){ if(i == 0) dp[i][j] = j; else if(j == 0) dp[i][j] = i; else{ dp[i][j] = min(dp[i-1][j - 1] + (word1[i - 1] == word2[j - 1]? 0 : 1), min(dp[i - 1][j], dp[i][j - 1]) + 1); } } } return dp[n][m]; } };","link":"/2020/12/21/shua-ti/dp/72-edit-distance/"},{"title":"790. Domino and Tromino Tiling","text":"这题真的需要很多考虑 思路：DP可以进行bit dp，设置dp[status]为当前列为状态status时的拼接方法。 status = 0b00 : 上下格子都为空 status = 0b10 : 上格子填好，下格子为空 status = 0b01 : 下格子填好，上格子为空 status = 0b11 : 上下格子都填好 所以就是有以下DP方程转移方式： 注意dp[0]=0。 找规律另一种方法也是我一开始想的方法，不过想错了，没有考虑托米诺和多米诺无限增长的可能性。😑🤐 参考以为大佬的博文 代码：DPclass Solution { public: int numTilings(int N) { const int MOD = 1e9 + 7; // int[] dp= new int[]{1,0,0,0}; long *dp = new long[]{1, 0, 0, 0}; for(int i = 0; i &lt; N; ++i){ long *ndp = new long[4]; ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD; ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD; ndp[0b10] = (dp[0b01] + dp[0b00]) % MOD; ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) % MOD; delete []dp; dp = ndp; } return dp[0]; } }; 另外上述线性变换可以替换为矩阵乘法的变换形式，不过太稀疏了…… 找规律： class Solution { public: int numTilings(int N) { const int MOD = 1e9 + 7; int sum0 = 1, sum1 = 1, sum2 = 2, sum3 = 5, sum; for(int i = 4; i &lt;= N; ++i){ sum = ((sum3 * 2) % MOD + sum1) % MOD; sum1 = sum2; sum2 = sum3; sum3 = sum; } if(N == 1) return 1; else if(N == 2) return 2; else if(N == 3) return 5; return sum; } };s","link":"/2020/10/07/shua-ti/dp/790-domino-and-tromino-tiling/"},{"title":"91. Decode Ways","text":"91. Decode Ways思路：$dp[i]$表示数字字符子串$S[0…i]$所能表示的字符串数量。dp方程见代码。 注意点： $0$无法被直接表示，因此dp方程分支扩大了一倍。 为了方便初始化，可以添加前缀零。 代码： class Solution { public: int numDecodings(string s) { s = &quot;00&quot; + s; //添加前缀，方便设置dp初始值 int n = s.size(); vector&lt;int&gt;dp(n, 0); if(n == 2 || s[2] == '0') return 0; dp[0] = dp[1] = 1; for(int i = 2; i &lt; n; ++i){ if(s[i - 1] == '1' || (s[i - 1] == '2' &amp;&amp; s[i] &lt; '7')){ if(s[i] == '0') dp[i] = dp[i - 2]; else dp[i] = dp[i - 2] + dp[i - 1]; } else if(s[i] == '0') dp[i] = 0; else dp[i] = dp[i - 1]; } return dp[n - 1]; } };","link":"/2020/12/11/shua-ti/dp/91-decode-ways/"},{"title":"96. Unique Binary Search Trees","text":"96. Unique Binary Search Treess思路：理解，只要数字不重复，子树的形状可能性就与数字具体大小无关。所以可以用DP算出长度为K的子树的可能形状。 代码： class Solution { int allmount = 0; vector&lt;int&gt; dp; public: int numTrees(int n) { dp.resize(n + 1); dp[1] = 1; dp[0] = 1; return findBST(1, n); } int findBST(int L, int R){ if(dp[R - L + 1]) return dp[R - L + 1]; // if(L &gt;= R){ // return 1; // } int nums = 0; for(int i = L; i &lt;= R; ++i){ nums += findBST(L, i - 1) * findBST(i + 1, R); } // cout &lt;&lt; L &lt;&lt; ' ' &lt;&lt; R &lt;&lt; ' ' &lt;&lt; nums &lt;&lt; endl; dp[R - L + 1] = nums; return nums; } };","link":"/2021/04/29/shua-ti/dp/96-unique-binary-search-trees/"},{"title":"P1025 数的划分","text":"思路：秀的一批的dp：可以把问题分解两位子问题Q1(a), Q2(b)，其中a+b==1。 Q1(a): 将a分解为含有1的分解方案。将其中的一个1去掉，可转化其他问题。 Q2(b): 将a分解为不含有1的分解方案。将每个数都减去1，可转化为其他问题。 那么有那么dp(n,k)=dp(n-1,k-1)+dp(n-k,k)。 保持边界dp[i][1] = 1, i&gt;=1 &amp;&amp; i&lt;=n。 代码： #include&lt;bits/stdc++.h&gt; int n = 205, k = 21; int dp[205][20] ={0}; int main(){ // dp[0][0] = 1; for(int i = 0;i &lt; n; i++) dp[i][1] = 1; for(int i = 2 ; i &lt;= n; i++){ printf(&quot;%d &quot;, dp[i][1]); for(int j = 2; j &lt;= i&amp;&amp; j &lt; k; j++){ if(i &gt;= j) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j]; printf(&quot;%d &quot;, dp[i][j]); } printf(&quot;\\n&quot;); } while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) != EOF){ printf(&quot;%d\\n&quot;, dp[n][k]); } return 0; }","link":"/2020/10/18/shua-ti/dp/p1025-shu-de-hua-fen/"},{"title":"面试题 17.24. 最大子矩阵","text":"面试题 17.24. 最大子矩阵思路：本题是最大连续子数组的二维follow up. 一维情况下，可以直接使用多种算法求解： 累加数组+二维搜索左右边界， $O(N^2)$ 二维搜索左右边界同时累加数字，$O(N^2)$ 分治算法，把问题maxarr(i, j)分解为maxarr(i, mid)和maxarr(mid + 1, j)。其中子数组可能在左右两端数组中或者横跨两个段，所以从中间向两边搜索最大连续数组和Sum1，如此解决了一个基本问题，并且递归的将小问题解决，获取总的问题的解。$O(NLogN)$ 线段树做法，同样也是分治的思想，但是考虑的更多。maxarr(i, j)分解为maxarr(i, mid)和maxarr(mid + 1, j)。基本问题是arr(i, j)中的suml，sumr, sumi和summ，分别代表从左边开始的子数组的和，从右边开始的子数组的和，在中间扩展的子数组的和，和整个数组的和。而我们要大问题的sumi就是所要求的值，巧妙的地方在于问题的分解，sumi可以就是子数组的sumi和左子段的sumr与右子段的suml之和最大值。其他同理。 DP做法，以dp[i]为arr[i]为结尾的和最大的连续子数组的和。状态更新方程为$$dp[i] = max(dp[i - 1] + arr[i], arr[i])$$ 这很有趣，实际上就是舍弃掉可能为负数的dp[i - 1]， 另外在舍弃时也可以记录下数组起点。更进一步的观察，空间可以优化到O(1)。 二维情况下，虽然非常相似，但是解法一时想不到直接扩展到二维。但是问题可以化解为一维。 在确定了矩阵行数据，或者首先遍历矩阵的上下界后，顺道求出该矩阵的在各各列的和。之后便可以用一维的做法求出连续列的最大和。 复杂$O(N^3)$。 代码：class Solution { int n; int m; vector&lt;int&gt; b; public: vector&lt;int&gt; getMaxMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { n = matrix.size(); m = matrix[0].size(); b.resize(m); vector&lt;int&gt; ans(4); int maxval = matrix[0][0]; for(int i = 0; i &lt; n; ++i){ for(int j = i; j &lt; n; ++j){ // accumulate the matrix in vertical sequences. if(i == j){ for(int k = 0; k &lt; m; ++k) b[k] = matrix[i][k]; }else for(int k = 0; k &lt; m; ++k) b[k] += matrix[j][k]; int sum = 0; int begin = 0; for(int l = 0; l &lt; m; ++l){ // sum = max(b[l], b[l] + sum); if(sum &lt; 0){ sum = 0; begin = l; } sum += b[l]; if(sum &gt; maxval){ maxval = sum; ans[0] = i; ans[1] = begin; ans[2] = j; ans[3] = l; } } } } return ans; } };","link":"/2021/05/10/shua-ti/dp/mian-shi-ti-17-24-zui-da-zi-ju-zhen/"},{"title":"面试题 DP 贪心","text":"收集贪心、DP面试题 面14：剪绳子题面：将一串长为K的绳子剪成m（m&gt;=2，各段长度取整数值）段，各段的长度大于0，求出最大的各段绳子长度之积。 思路1：由乘法交换律可知绳子的乘积可以分解，提取出来。所以有f(m+n)=f(n)*f(m)，其中f(n)是长度n的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件f(1) = 1, f(2) = 2, f(3) = 3。同时在DP表示式为： f(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i) 所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。 思路2：另一种就是贪心，对于长度m大于5的绳子尽可能的剪成长度为3的绳子，同时如果m%3==1，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:$$if \\ n \\geq 53*(n-3) \\geq n2*(n-2) \\geq n3*(n -3 ) \\geq 2*(n-2)$$ 测试：2 2 , 3 2 , 5 6 , 6 9 代码：DP int maxProduct_DP(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int* products = new int[length + 1]; //初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大 products[0] = 0; products[1] = 1; products[2] = 2; products[3] = 3; for(int i = 4; i &lt;= length; i++){ int mavV = 0; for(int j = 1; j &lt;= i / 2; j++){ maxV = max(maxV, products[i - j] * products[j]); } products[i] = maxv; } int res = products[length]; //防止内存泄漏 del[] products; return res; } 贪心 int maxProduct_greedy(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int timesOf3 = length / 3; if(legnth % 3 == 1) timesOf3 -= 1; int timesOf2 = (length - timesOf3 * 3) / 2; return (int)pow(3, timeOf3) * (int)pow(2, timesOf2); } 面42：最大子数组和题面：如题 思路：DP思想。数组之间的选择与历史无关，可以采取DP的方法。记f(i)为以A[i]为结尾的最大数组和。转移方程为： f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0 当然也可以直接从数据的角度理解，代码都是相同的。 代码：int MaxSumOfSubArray(int A[], int length){ int dp[] = new int(length); int maxSum = A[0]; dp[0] = A[0]; for(int i = 1; i &lt; length; i++){ dp[i] = max(A[i], A[i] + dp[i-1]); maxSum = max(dp[i], maxSum); } delete[] dp; return maxSum; } 当然这里的dp数组也可以不要。 面45：把数字排成最小的数字题目：给定一串数字，组合成的一个数字。求出组合后最小数字的 思路：可以直接贪心+反证。按字典序排序数字即可。 代码：就不写了，直接string排序输出即可。 面46：数字翻译成字符串题目：把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。 思路：第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。 第二种用DP思想，考虑dp[i]为从0到i的字符串翻译方法。状态转移方程为： dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else 代码：int GetTranslateCount(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int dp[] = new int(length); dp[0] = 1; for(int i = 1; i &lt; length; i++){ int add = A[i - 1] * 10 + A[i]; if( add &gt; 9 &amp;&amp; add &lt; 26){ if(i &lt; 2) dp = dp[i - 1] + 1; else dp[i] = dp[i - 1] + dp[i - 2]; } else dp[i] = dp[i - 1]; } delete[] dp; return dp[length - 1]; } 面47：礼物的最大价值题目：从一在格子上装满礼物的m*n的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。 思路：明显就是DP 代码：不写了。 面48：最长不含重复字符的子字符串题目：如题 思路：暴力不可取。 采用用DP思想，考虑dp[i]为以S[i]为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断S[i]的前一个相同字符是否在上一个S[i-1]为结尾的最长不重复字符串之内。记上一个字符与S[i-1]的长度d为i - POS。 状态转移方程为： dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else 代码：int MaxSubStr(String s){ int dp[] = new int(s.length()); int pos[26]; for(int i = 0; i &lt; 26; i++) pos[[i] = -1; int maxL = 1; dp[0] = 1; for(int i = 1; i &lt; s.length(); i++){ int d = i - pos[s[i] - 'a']; if(dp[i - 1] &lt; d){ dp[i] = dp[i - 1] + 1; }else dp[i] = d; maxL = max(maxL, dp[i]); pos[s[i] - 'a'] = i; } delete[] dp; return maxL; }","link":"/2020/08/07/shua-ti/dp/mian-shi-ti-dp-tan-xin/"},{"title":"1286. Iterator for Combination","text":"想了一下全组合的写法，顺便复习了一下全排列(full permutaion)的思想。 1286. Iterator for Combination 全排列思路：官方给出了生成法，这种方法比较死板不去学习。 我依据全排列的递归生成方法，扩展到全组合的生成方法，但是需要存储。思路就是：f(s,i,len,str)递归给出已生成i位str，获取s的len及之后的全组合字符串。 大神给出了基于二进制的全组合generatorf方法。由于全组合的排列顺序在二进制看来就是相同数量的1和0的组合，因此可以由大到小排列。 比如，字典序排序应该是: ab ac ad bc bd 刚好可以对应二进制数，从大到小: 1100 1010 1001 0110 0101 0011 再利用n&amp;(n-1)计算出0bN的1的个数。 代码：全组合写法： class CombinationIterator { public: queue&lt;string&gt; que; int len = -1; CombinationIterator(string characters, int combinationLength) { len = combinationLength; printCombination(characters, 0, 0, &quot;&quot;); } // 全排列写法，combination只是组合，而非全排列 void printPer(string a, int depth){ if(depth &gt; len) return; else if(depth == len){ // cout &lt;&lt; counter++ &lt;&lt; ' ' &lt;&lt; a.substr(0, len) &lt;&lt; endl; que.push(a.substr(0, len)); return; } for(int i = depth + 1;i &lt; a.size(); i++){ printPer(a, depth + 1); swap(a[i], a[depth]); } printPer(a, depth + 1); } // combination写法 void printCombination(string a, int depth, int idx, string b){ if(depth &gt; len) return; else if(depth == len){ //cout &lt;&lt; counter++ &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; que.push(b); return; } for(int i = idx;i &lt; a.size() - len + depth + 1; i++){ printCombination(a, depth + 1, i + 1, b + a[i]); } } string next() { string res = que.front(); que.pop(); return res; } bool hasNext() { return !que.empty(); } }; /** * Your CombinationIterator object will be instantiated and called as such: * CombinationIterator* obj = new CombinationIterator(characters, combinationLength); * string param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */ bit版： class CombinationIterator { private: int cur; int sz; string chars; public: CombinationIterator(string characters, int combinationLength) { sz = combinationLength; chars = characters; cur = (1 &lt;&lt; chars.size()) - 1; } //要求输入字符串长度&lt;= 31 int countone(int n){ int res = 0; while(n){ n = n &amp; (n - 1); res ++; } return res; } string next() { while(cur &gt; 0 &amp;&amp; countone(cur) != sz) cur--; if(cur &lt;= 0) return &quot;&quot;; string res = &quot;&quot;; cout &lt;&lt; cur &lt;&lt; endl; for(int i = 0; i &lt; chars.size(); i++){ if((cur &amp; (1 &lt;&lt; i)) != 0) res = chars[chars.size() - 1 - i] + res; } cur--; return res; } bool hasNext() { while(cur &gt; 0 &amp;&amp; countone(cur) != sz) cur--; if(cur &gt; 0) return true; else return false; } }; /** * Your CombinationIterator object will be instantiated and called as such: * CombinationIterator* obj = new CombinationIterator(characters, combinationLength); * string param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */","link":"/2020/10/08/shua-ti-wei-yun-suan-1286-iterator-for-combination/"},{"title":"136. Single Number","text":"136. Single Number思路： 代码：class Solution { public: int singleNumber(vector&lt;int&gt;&amp; nums) { int key = 0; for(auto &amp;k : nums){ key = k ^ key; } return key; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-136-single-number/"},{"title":"190. Reverse Bits","text":"190. Reverse Bits思路： 代码：class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t z = 0; int k = 0; while(k &lt;= 31){ z = (z &lt;&lt; 1) | (n &amp; 1); n &gt;&gt;= 1; k++; } return z; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-190-reverse-bits/"},{"title":"260. Single Number III","text":"260. Single Number III思路：划分数组 思路非常精巧。用异或所有数组，由于异或的性质，只有两个唯一且不等的出现的数字$x$,$y$被记录下来，记为$z$。可以推测，$z$比不为零，且第一个1要么来自$x$，要么来自$y$。同时可以根据这个“第一个1”是否在其他数字上存在，将数组划分为两部分，一组是带有$x$和成对的数字，另一组类似。 如此划分数组，同时异或其中一组，就可以得到$x$或者$y$。当然也可以通过上面的$z$异或其中一个数字来得到另一个数字。 代码：class Solution { public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) { int bitmask = 0; for(auto &amp; k : nums) bitmask ^= k; long long key = (long)bitmask &amp; (-(long)bitmask); int mask = 0; cout &lt;&lt; key &lt;&lt; endl; for(auto &amp; k : nums){ if(k &amp; key){ mask ^= k; } } return {mask, bitmask ^ mask}; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-260-single-number-iii/"},{"title":"268. Missing Number","text":"268. Missing Number思路： 排序 哈希 异或位运算 高斯求和 3和4实现了$O(n)$的时间复杂度和$O(1)$的空间复杂度。 代码： class Solution { public: int missingNumber(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0 ) return 0; int lose = 0; for(auto &amp; k : nums){ lose ^= k; } for(int i = 0; i &lt;= n; ++i) lose ^= i; return lose; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-268-missing-number/"},{"title":"318. Maximum Product of Word Lengths","text":"318. Maximum Product of Word Lengths思路：为了避免查询时候的重复比较，可以将比较内容变成一个标志符，减少了比较时候的重复计算。 进一步的，可以进一步优化重复标志符的查询次数。 代码： class Solution { public: int aderator(string s){ int pic = 0; for(auto &amp;c : s){ pic |= (1 &lt;&lt; (c - 'a')); } return pic; } int maxProduct(vector&lt;string&gt;&amp; words) { vector&lt;int&gt; pics; for(auto &amp;s : words){ pics.push_back(aderator(s)); } int maxl = 0; for(int i = 0; i &lt; pics.size(); ++i){ for(int j = i + 1; j &lt; pics.size(); ++j){ if((pics[i] &amp; pics[j]) == 0){ maxl = max(maxl, int(words[i].size() * words[j].size())); } } } return maxl; } }; 在上题基础上，用hashmap记录key相同的长度最长的string，减少查询次数。 class Solution { public: int aderator(string s){ int pic = 0; for(auto &amp;c : s){ pic |= (1 &lt;&lt; (c - 'a')); } return pic; } int maxProduct(vector&lt;string&gt;&amp; words) { unordered_map&lt;int, int&gt; map; for(auto &amp;s : words){ int key = aderator(s); map[key] = max(map[key], (int)s.size()); } int maxl = 0; for(auto &amp;[key1, value1] : map){ for(auto &amp;[key2, value2] : map){ if((key1 &amp; key2) == 0){ maxl = max(maxl, int(value1 * value2)); } } } return maxl; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-318-maximum-product-of-word-lengths/"},{"title":"338. Counting Bits","text":"338. Counting Bits思路：利用二进制上数字变化，将数字计算转移。 代码：class Solution { public: vector&lt;int&gt; countBits(int nums) { vector&lt;int&gt; dp(nums + 1); for(int i = 1; i &lt;= nums; ++i){ dp[i] = (i &amp; 1) ? dp[i - 1] + 1 : dp[i &gt;&gt; 1]; } return dp; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-338-counting-bits/"},{"title":"342. Power of Four","text":"342. Power of Four思路： 判断唯一的1的位置是否在1的倍数上 检查 $log_2x$是否为偶数就能判断 x 是否为 4 的幂 代码： class Solution { public: bool isPowerOfFour(int n) { if(n &lt;= 0) return false; while(n != 1){ if((n &amp; 3)) return false; n &gt;&gt;= 2; } return true; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-342-power-of-four/"},{"title":"461. Hamming Distance","text":"461. Hamming Distance思路： 代码：class Solution { public: int hammingDistance(int x, int y) { int z = x ^ y; int ct = 0; while(z){ ct += z &amp; 1; z &gt;&gt;= 1; } return ct; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-461-hamming-distance/"},{"title":"476. Number Complement","text":"476. Number Complement思路：数字取反前把前缀零全部转化为前缀1. 代码：class Solution { public: int findComplement(int num) { int c = 1; while( (num &gt;&gt; c) ) ++c; while(c &lt;= 31){ num = num | (1 &lt;&lt; c); c++; // cout &lt;&lt; num &lt;&lt; endl; } return ~num; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-476-number-complement/"},{"title":"693. Binary Number with Alternating Bits","text":"693. Binary Number with Alternating Bits思路: 代码：class Solution { public: bool hasAlternatingBits(int n) { if(n &lt; 1) return true; int obit = n &amp; 1, bit = 0; n &gt;&gt;= 1; while(n){ bit = n &amp; 1; n &gt;&gt;= 1; if(bit == obit) return false; obit = bit; } return true; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-693-binary-number-with-alternating-bits/"},{"title":"面试题-位运算","text":"收集位运算相关的题目。 判断1的个数 题面：给出一个整数K，判断其二进制中1的个数。 思路1：典型的二进制题目，可以使用与运算判断数字K某一位是否是1。巧妙的是，既可以在运算中移位K，也可以位移flag。显然后面一种可以避免K数字为负而导致的高位填零的右移问题。 思路2：更巧妙的方法，是考虑到K-1后会把K的第一个低位1和之后的0全部取饭，此时K &amp; (K -1)相比于K会少一个低位1。如此反复操作便可统计所有1的个数。 思路扩展：判断一个数是2的整数次；对于数字m需要改变多少位才能变成数字n。 代码：思路1 int NumberOf1(int n){ int flag = 1, count = 0; while(flag){ if(flag &amp; n) count++; falg = flag &lt;&lt; 1; } return count; } 思路2 int NumberOf1(int n){ int count = 0; while(n){ count ++; n = (n - 1) &amp; n; } return count; }","link":"/2020/08/07/shua-ti-wei-yun-suan-mian-shi-ti-wei-yun-suan/"},{"title":"1025 除数博弈","text":"1025. 除数博弈难度简单 思路：可以从简单的例子入手发现，爱丽丝拿1输，拿2赢，拿3输。对于Bob则相反，如果我们可以找出小于数字N的数字x，且N-x可以整除于N，x对于bob是必输态，那么爱丽丝必胜。 也可以从另一个角度出发：从多个例子可以大胆推测，偶数必胜，奇数必输。可以用归纳法证明。那么代码就简单很多。 代码：堆维护数组 class Solution { public: bool divisorGame(int N) { if(N &lt; 1 || N &gt; 1000) return false; int* dp = new int[1005]; dp[1] = 0; dp[2] = 1; for(int i = 3; i &lt; 1001; i++){ dp[i] = 0; for(int j = 1; j &lt; i; j++){ if(i % (i - j) == 0 &amp;&amp; dp[j] == 0){ dp[i] = 1; break; } } } return dp[N]; } };","link":"/2020/08/07/shua-ti/qi-ta/1025-chu-shu-bo-yi/"},{"title":"1027 最长等差数列","text":"1027. 最长等差数列思路：求最长等差序列的长度，可以看出序列可以分解为多个序列，而且序列的选择不具有历史影响。可以可以考虑用DP做。用一个状态无法表示数列的等差量和数列的端点两个状态。所以至少得有两个状态，且可以用两个状态分别表示一个等差序列的最后两个元素下标。 DP方程可以这么写： dp[i][j]={dp[k][i]+1,if k is element of the array 2,elsedp[i][j]={dp[k][i]+1,if k is element of the array 2,else 为啥是最后两个？因为为最后两个元素组成的最长等差序列，可以给后续DP方程计算。而两个元素作为开头无法递推！ class Solution { public: int longestArithSeqLength(vector&lt;int&gt;&amp; A) { int n = A.size(); //优秀的初始化方法 // vector&lt;int&gt;(n, 2)动态生成了一个长度为n，每个元素为2的vector对象 vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 2)); map&lt;int, int&gt; idx; int maxRes = 2; for(int i = 0; i &lt; (int)A.size() - 1; i++){ for(int j = i + 1; j &lt; A.size(); j++){ int target = A[i] * 2 - A[j]; if( idx.count( target )) dp[i][j] = dp[idx[target]][i] + 1; maxRes = max(maxRes, dp[i][j]); } idx[A[i]] = i; } return maxRes; } };","link":"/2020/08/07/shua-ti/qi-ta/1027-zui-chang-deng-chai-shu-lie/"},{"title":"1143. Longest Common Subsequence","text":"1143. Longest Common Subsequence思路：dp[i][[j]为text1和text2在位置i,j的最长公共子序列。 代码：80% class Solution { public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(), m = text2.size(); if(n == 0 || m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp; dp.resize(n, vector&lt;int&gt;(m, 0)); int flag = 0; for(int i = 0; i &lt; n; i++){ if(flag || text1[i] == text2[0]){ flag = 1; dp[i][0] = 1; } } flag = 0; for(int i = 0; i &lt; m; i++){ if(flag || text1[0] == text2[i]){ flag = 1; dp[0][i] = 1; } } for(int i = 1; i &lt; n; ++i){ for(int j = 1; j &lt; m; ++j){ if(text1[i] == text2[j]){ dp[i][j] = dp[i - 1][j - 1] + 1; }else dp[i][j] = max(dp[i][j -1], dp[i - 1][j]); // cout &lt;&lt; dp[i][j] &lt;&lt; ' '; } // cout&lt;&lt; endl; } return dp[n - 1][m - 1]; } };","link":"/2020/12/15/shua-ti/qi-ta/1143-longest-common-subsequence/"},{"title":"1190. Reverse Substrings Between Each Pair of Parentheses","text":"1190.Reverse Substrings Between Each Pair of Parentheses 难度MD这个题一开始思路就错了，首先是括号匹配问题不能使用左右指针选择，其次是字符串翻转完全可以忽略掉括号（或者说连同括号一起翻转）。一共有两种思路。 思路1将栈匹配+翻转，复杂度O(n2)O(n2)。 class Solution { public: // string reverseParentheses(string s) { // string ns = &quot;&quot;; // vector&lt;int&gt; idxl, idxr; // int singbrack = 0, calbrack = 0; // for(int i = 0; i &lt; s.size(); i++){ // if(s[i] == '(' || s[i] == ')') singbrack ++; // else ns.push_back(s[i]); // } // singbrack /= 2; // for(int i = 0, j = s.size() - 1; i &lt; j;){ // while(i &lt; j &amp;&amp; s[i] != '(') i++; // while(i &lt; j &amp;&amp; s[j] != ')') j--; // idxl.push_back(i - calbrack); // idxr.push_back(j - singbrack - (singbrack - calbrack - 1)); // reverse 翻转的范围是[),这里注意01错误 // i++; // j--; // calbrack ++; // } // if(calbrack == 0) return ns; // for(int i = idxl.size() - 1; i &gt;= 0; i--){ // reverse(ns.begin() + idxl[i], ns.begin() + idxr[i]); // } // return ns; // } string reverseParentheses(string s) { string ns = &quot;&quot;; stack&lt;int&gt; sti; for(int i= 0; i &lt; s.size(); i++){ if( s[i] == '(') sti.push(i); else if(s[i] == ')'){ reverse( s.begin() + sti.top(), s.begin() + i); sti.pop(); } } for(int i = 0; i &lt; s.size(); i++){ if(s[i] == '(' || s[i] == ')' ) continue; ns.push_back(s[i]); } return ns; } }; 思路2神奇的黑魔法（这个算法局限于这个应用，感觉挺死板）","link":"/2020/08/07/shua-ti/qi-ta/1190-reverse-substrings-between-each-pair-of-parentheses/"},{"title":"122. Best Time to Buy and Sell Stock II","text":"思路：贪心做每一个可以交易的交易就行 代码：class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int sum = 0; for(int i = 0; i &lt; prices.size() - 1; ++i){ sum += (prices[i] &lt; prices[i + 1] )? prices[i + 1] - prices[i] : 0; } return sum; } };","link":"/2020/10/15/shua-ti/qi-ta/122-best-time-to-buy-and-sell-stock-ii/"},{"title":"1254. Number of Closed Islands","text":"1254. Number of Closed Islands难度MD 思路：DFS或者并查集 排除法：将所有接触过边界的0块排除掉，接下来统计所有的0块数量就是岛屿的数量啦~ 直接法：考虑成为岛屿的条件——岛屿上所有0块都不与边界相交。 接下来只需要写DFS或者BFS就👌。 考虑使用并查集 排除法 class Solution { public: //保持和第二种写法一致，add参数实际上是多余的 void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add){ if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= M || grid[x][y] == 1) return; //if(grid[x][y] == 1) add = 1; grid[x][y] = 1; findBlockOf0(x, y+1, N, M, grid, add); findBlockOf0(x, y-1, N, M, grid, add); findBlockOf0(x+1, y, N, M, grid, add); findBlockOf0(x-1, y, N, M, grid, add); return; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts, add; //排除掉那些不是island的blocks of 0 for(int i=0;i &lt; M; i++){ findBlockOf0(0,i, N, M, grid, counts); findBlockOf0(N-1,i, N, M, grid, counts); } for(int i=0;i &lt; N;i++){ findBlockOf0(i,0,N,M, grid, counts); findBlockOf0(i,M-1, N, M, grid, counts); } //接下来所有的0块都可以算作island counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; findBlockOf0(x, y, N, M, grid, add); counts += 1; } } return counts; } }; 直接法 class Solution { public: // 注意遍历的时候不能剪枝，否则就会就会出现岛屿断裂成多个“单独”岛屿而计数过多 void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add){ if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= M || grid[x][y] == 1) return; if(x == 0 || x == N-1|| y == 0 || y == M-1 ) add = 0; grid[x][y] = 1; // 这里的四个方向其实可以用FOR写的更优雅一些 findBlockOf0(x, y+1, N, M, grid, add); findBlockOf0(x, y-1, N, M, grid, add); findBlockOf0(x+1, y, N, M, grid, add); findBlockOf0(x-1, y, N, M, grid, add); return; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts; counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; int add = 1; findBlockOf0(x, y, N, M, grid, add); counts += add; } } return counts; } }; 尝试使用BFS写第二种写法~ class Solution { public: // BFS int findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid){ int dX[4] = {0, 0, -1, 1}, dY[4] = {1, -1, 0, 0}, nX, nY; int flag = 1; queue&lt; vector&lt;int&gt; &gt; que; que.push( {x, y}); grid[x][y] = 1; while( !que.empty() ){ vector&lt;int&gt; point = que.front(); que.pop(); int x = point[0], y = point[1]; //注意 所有的点都需要判断是否在边界上 if(x == 0 || x == N - 1 ||y == 0 || y == M - 1) flag = 0; for(int i=0;i &lt; 4; i++){ nX = x + dX[i]; nY = y + dY[i]; if(nY &gt;= 0 &amp;&amp; nY &lt; M &amp;&amp; nX &gt;=0 &amp;&amp; nX &lt; N &amp;&amp; grid[nX][nY] == 0){ grid[nX][nY] = 1; que.push({nX, nY}); } } } return flag; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts; counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; counts += findBlockOf0(x, y, N, M, grid); } } return counts; } }; 并查集 改日再战","link":"/2020/08/07/shua-ti/qi-ta/1254-number-of-closed-islands/"},{"title":"15 3sum","text":"思路： 简单的说，先有序化，再二重循环遍历前两个指针，第三个指针采用二分法即可。注意跳过重复值 更巧妙的解法——双指针解法。先有序化，遍历第一个数字的同时，采用双指针从两边逼近结果。 实际上这是对数组有序的利用。 二重循环 + 二分 class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt; vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); // for(int i = 0;i &lt; len; i++) // printf(&quot;%d&quot;, nums[i]); for(int i=0; i &lt; len - 2; i++){ //排除重复结果 if(i!=0 &amp;&amp; nums[i-1] == nums[i]) continue; for(int j=i + 1; j &lt; len - 1; j++){ //排除重复结果 if(j!=i+1 &amp;&amp; nums[j] == nums[j-1]) continue; int ld = j + 1, rd = len - 1, mid; while(ld &lt; rd){ mid = (ld + rd ) / 2; if( nums[mid] + nums[i] + nums[j] &gt;= 0) rd = mid; else ld = mid + 1; // 注意这里向上二分的时候， mid没有变动，同时循环可能结束。导致了mid的值可能在某种情况下雨rdld不同 ，所以循环结束最好选ld或者rd } // printf(&quot;%d &quot;, mid); if(nums[rd] + nums[i] + nums[j] == 0){ res.push_back({nums[i], nums[j], nums[rd]}); } } } return res; } }; 双指针法 class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt; vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); for(int i=0;i &lt; len - 2; i++){ // 排除重复结果 if(i !=0 &amp;&amp; nums[i] == nums[i-1]) continue; int j = i + 1, k = len - 1; while(j &lt; k){ int sum = nums[i] + nums[k] + nums[j]; // 排除重复结果 if(j != i + 1 &amp;&amp; nums[j] == nums[j-1]){ j++; continue; } if(k != len -1 &amp;&amp; nums[k] == nums[k+1]){ k--; continue; } if(sum &gt; 0) k--; else if(sum &lt; 0) j++; else{ res.push_back({nums[i], nums[j], nums[k]}); j++, k--; } } } return res; } }; #二分TWO POINTERS","link":"/2020/08/07/shua-ti/qi-ta/15-3sum/"},{"title":"240. Search a 2D Matrix II","text":"240. Search a 2D Matrix II思路：由于matrix在行和列上的递增， 在左下角和右上角有特殊的性质。在左下角有，A[i][j]比上面的数字都打， 比右边的数字都小。所以可以比较target和A[i][j]数字大小来排除，上面一列或者右边一行的所有数字。递归的下去可以搜索到应有的数字。 如果没有就会出界。 代码：class Solution { public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int x, y, n = matrix.size(); x = n - 1; y = 0; while(x != 0 || y != n -1){ if(target == matrix[x][y]) return true; else if(target &gt; matrix[x][y]) y++; else if(target &lt; matrix[x][y]) x--; if(x &lt; 0 || y &gt;= n) return false; } return false; } };","link":"/2021/01/22/shua-ti/qi-ta/240-search-a-2d-matrix-ii/"},{"title":"303. Range Sum Query - Immutable","text":"303. Range Sum Query - Immutable思路：前缀和 代码：class NumArray { vector&lt;int&gt; nums; public: NumArray(vector&lt;int&gt;&amp; _nums) : nums(_nums) { nums.insert(nums.begin(), 0); for(int i = 1; i &lt; nums.size(); ++i) nums[i] += nums[i - 1]; } int sumRange(int i, int j) { return nums[j + 1] - nums[i]; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(i,j); */","link":"/2021/01/29/shua-ti/qi-ta/303-range-sum-query-immutable/"},{"title":"304. Range Sum Query 2D - Immutable","text":"304. Range Sum Query 2D - Immutable思路：二维前缀和，不仅是计算二维矩阵之和的过程可以用二维矩阵组合起来，而且二维前缀和的计算过程也可以用之前计算的矩阵简化计算。 $o(n^2)$ 代码： class NumMatrix { vector&lt;vector&lt;int&gt;&gt; summax; public: NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size() + 1; if(n == 1) return; int m = matrix[0].size() + 1; summax.resize(n); summax[0].resize(m); for(int i = 1; i &lt; n; ++i){ summax[i].resize(m + 1); for(int j = 1; j &lt; m; ++j){ summax[i][j] = matrix[i - 1][j - 1] + summax[i - 1][j] + summax[i][j - 1] - summax[i - 1][j - 1]; // cout &lt;&lt; summax[i][j] &lt;&lt; ' '; } // cout &lt;&lt; endl; } } int sumRegion(int row1, int col1, int row2, int col2) { return summax[row2 + 1][col2 + 1] - summax[row2 + 1][col1] - summax[row1][col2 + 1] + summax[row1][col1]; // return 0; } }; /** * Your NumMatrix object will be instantiated and called as such: * NumMatrix* obj = new NumMatrix(matrix); * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2); */","link":"/2021/01/29/shua-ti/qi-ta/304-range-sum-query-2d-immutable/"},{"title":"326. Power of Three","text":"326. Power of Three直接上代码： 思路 class Solution { public: bool isPowerOfThree(int n) { if(n == 1) return true; if(n &lt; 3) return false; int newn; while(n &gt;= 3){ newn = n / 3; if(newn * 3 != n) return false; n = newn; } return n == 1; } }; 不断整除判断余数是否为零 class Solution { public: bool isPowerOfThree(int n) { if(n &lt; 1) return false; while(n % 3 == 0){ n /= 3; } return n == 1; } }; 3的k+1次幂必定可以被3的k次幂整除 class Solution { public: bool isPowerOfThree(int n) { // int maxn = pow(3,floor(log(INT_MAX) / log(3))); //1162261467 // cout &lt;&lt; maxn &lt;&lt; endl; return n &gt; 0 &amp;&amp; 1162261467 % n == 0; } }; 3进制算法：数1 class Solution { public: bool isPowerOfThree(int n) { int ct = 0, oldn = n; while(n){ ct += n % 3; if(ct &gt; 1) return false; n /= 3; } return oldn &gt; 0; } };","link":"/2021/01/08/shua-ti/qi-ta/326-power-of-three/"},{"title":"341. Flatten Nested List Iterator","text":"341. Flatten Nested List Iterator 思路：缓存lazy法 stack存储遍历空间法 代码：/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */ class NestedIterator { public: int pos = 0; queue&lt;int&gt; que; vector&lt;NestedInteger&gt; nestedList; NestedIterator(vector&lt;NestedInteger&gt; &amp;_nestedList) { // que.clear(); nestedList = _nestedList; } int next() { if(hasNext()){ int nexti = que.front(); que.pop(); return nexti; } return -1; } bool hasNext() { if(que.empty()){ if(nestedList.size() == pos){ return false; } //不要忘记pos+ while(pos != nestedList.size() &amp;&amp; que.empty()){ getInt2que(nestedList[pos++]); } } if(que.empty()) return false; else return true; } void getInt2que(NestedInteger ni){ if(ni.isInteger()){ que.push(ni.getInteger()); }else{ vector&lt;NestedInteger&gt; list = ni.getList(); for(auto item :list){ getInt2que(item); } } } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ 不够机智的实现 /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */ class NestedIterator { using nestedVecIt = vector&lt;NestedInteger&gt;::iterator; stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested; public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) { if(nestedList.size() &gt; 0) nested.push({nestedList.begin(), nestedList.end()}); } bool hasNext() { locate(); return !nested.empty(); } void locate(){ if(nested.size() == 0) return; while(nested.size()){ auto&amp; [itnested, itend] = nested.top(); if(itnested == itend) nested.pop(); else if(!itnested-&gt;isInteger()){ auto &amp; veclist = itnested-&gt;getList(); ++itnested; nested.push({veclist.begin(), veclist.end()}); } else break; } } int next() { if( hasNext()){ auto&amp; [itnested, itend] = nested.top(); int nextv = 0; if(itnested-&gt;isInteger()){ nextv = itnested-&gt;getInteger(); ++itnested; return nextv; } else{ auto &amp; nestedList = itnested-&gt;getList(); ++itnested; // 无论是数字还是数组都要向前遍历 nested.push({nestedList.begin(), nestedList.end()}); return next(); } } return -1; } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ 更优雅的实现 /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */ class NestedIterator { using nestedVecIt = vector&lt;NestedInteger&gt;::iterator; stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested; public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) { if(nestedList.size() &gt; 0) nested.push({nestedList.begin(), nestedList.end()}); } bool hasNext() { while(nested.size()){ auto&amp; [itnested, itend] = nested.top(); if(itnested == itend) nested.pop(); else if(!itnested-&gt;isInteger()){ auto &amp; veclist = itnested++-&gt;getList(); // 自增后获取 nestedList nested.push({veclist.begin(), veclist.end()}); } else break; } return !nested.empty(); } // 保证调用前 指针指向的元素存在且为数字 int next() { return nested.top().first++-&gt;getInteger(); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */","link":"/2020/09/25/shua-ti/qi-ta/341-flatten-nested-list-iterator/"},{"title":"406. Queue Reconstruction by Height","text":"思路：贪心策略，因为队列的唯一性，从头到尾reconstruct即可。 按k升序再按h降序，再按k值插入。需要在插入的同时统计维护前面身高大于h的人数即可。 代码：class Solution { public: int countBigger(int pos, vector&lt;vector&lt;int&gt;&gt; &amp;people){ int res = 0; for(int i = pos -1; i &gt;= 0; --i){ if(people[i][0] &gt;= people[pos][0]) res++; } return res; } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { sort(people.begin(), people.end(), [](vector&lt;int&gt;a, vector&lt;int&gt;b){ if(a[1] == b[1]) return a[0] &lt; b[0]; else return a[1] &lt; b[1]; }); int n = people.size(); for(int i = 0; i &lt; n; ++i){ int c = countBigger(i, people); int k = i; while(c &gt; people[k][1]){ if(people[k-1][0] &gt;= people[k][0]) c--; swap(people[k], people[k - 1]); k--; } } return people; } };","link":"/2020/10/15/shua-ti/qi-ta/406-queue-reconstruction-by-height/"},{"title":"448. Find All Numbers Disappeared in an Array","text":"448. Find All Numbers Disappeared in an Array思路：把nums当做已经出现的元素的向量表，重点是遍历的元素过程中”递归”地置位元素。 代码：class Solution { public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt; nums.size(); ++i){ int t = nums[i]; if(t &lt; 0) continue; while(nums[t - 1] &gt; 0){ int newt = nums[t - 1]; nums[t - 1] = nums[t - 1] == -1 ? -2 : -1; t = newt; } } vector&lt;int&gt; ans; for(int i = 0; i &lt; nums.size(); ++i){ if(nums[i] &gt; 0) ans.push_back(i + 1); } return ans; } };","link":"/2021/01/22/shua-ti/qi-ta/448-find-all-numbers-disappeared-in-an-array/"},{"title":"48. Rotate Image","text":"48. Rotate Image思路：原地翻转的思路：比较简单。 翻转做法。先上下翻转， 后对角线翻转 四个对应的矩阵元素作为旋转点，顺势将矩阵划分为四个旋转部分。遍历一个部分并旋转其中成组的所有元素即可。 代码：沙雕代码： class Solution { public: void rotate_ele(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;matrix){ int n = matrix.size() - 1; vector&lt;pair&lt;int, int&gt;&gt; idx; idx.push_back({x, y}); idx.push_back({y, n - x}); idx.push_back({n - x, n- y}); idx.push_back({n- y, x}); int ordv = matrix[idx[0].first][idx[0].second]; for(int i = 0; i &lt; 4; ++i){ int bi = (i + 1) % 4; int &amp;rotated = matrix[idx[bi].first][idx[bi].second]; // alias; int newv = rotated; rotated = ordv; ordv = newv; } // for(int i = 0; i &lt; n + 1; ++i){ // for(int j = 0; j &lt; n + 1; ++j){ // cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;; // } // cout &lt;&lt; endl; // } } //发现旋转规律 // 1, 0 // 0, 2 // 2, 3 // 3, 1 // 0, 0 // 0, 3 // 3, 3 // 3, 0 void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.size() == 0) return; int cerX, cerY; cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标 //划分旋转点 // 按一个点旋转对应的4个点，组成一组进行旋转。各个组的旋转起点如下： // 1 1 1 0 // 0 1 0 0 // 0 0 0 0 // 0 0 0 0 // 1 1 0 // 0 1 0 // 0 0 0 for(int i = 0; i &lt;= cerX; ++i){ for(int j = i; j &lt; matrix.size() - 1 - i; ++j){ rotate_ele(i, j, matrix); } } } }; 简化一下 class Solution { public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.size() == 0) return; int cerX, cerY, n = matrix.size() - 1; cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标 for(int i = 0; i &lt;= cerX; ++i){ for(int j = i; j &lt; matrix.size() - 1 - i; ++j){ int temp = matrix[i][j]; matrix[i][j] = matrix[n - j][i]; matrix[n - j][i] = matrix[n - i][n - j]; matrix[n - i][n - j] = matrix[j][n - i]; matrix[j][n - i] = temp; } } } }; 翻转做法 class Solution { public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.size() == 0) return; int cerX, cerY, n = matrix.size() - 1; cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标 // 上下翻转 for(int i = 0; i &lt;= cerX; ++i){ for(int j = 0; j &lt; matrix.size(); ++j){ swap(matrix[i][j], matrix[n - i][j]); } } // 对角线翻转 for(int i = 0; i &lt;= matrix.size(); ++i){ for(int j = i + 1; j &lt; matrix.size(); ++j){ swap(matrix[i][j], matrix[j][i]); } } } };","link":"/2021/01/22/shua-ti/qi-ta/48-rotate-image/"},{"title":"524. Longest Word in Dictionary through Deleting","text":"524. Longest Word in Dictionary through Deleting2020.10.22日 这题还是稍微锻炼了一下我、 思路：为了尽量降低代码复杂度，我选择了用hash保留地址法存储每个相同字符的位置。在遍历字典中每个字符中，判断每个字符串的字符合理出现位置，二分hash链式表中每个字符的可能位置即可。 代码虽然复杂一点，但是很快，时间复杂度为：$O(logL(s) * L(d[argmax\\ len(d[i])] * d.size()))$ 代码：其他人的的双指针法：很慢 class Solution { private: bool isZichuan(string target, string s) { //分别从左端开始索引，检测是否为子列 int i = 0, j = 0; while(i &lt; target.size() &amp;&amp; j &lt; s.size()) { if(target[i] == s[j]) i++; j++; } return i == target.size(); } public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) { string str = &quot;&quot;; for(int i = 0; i &lt; d.size(); i++) { int tag = str.length(); int leng = d[i].length(); //若字符串更短或者一样长且字母顺序较大的直接舍去 if(tag &gt; leng || (tag == leng &amp;&amp; str.compare(d[i]) &lt; 0)) continue; if(isZichuan(d[i], s)) { str = d[i]; } }a return str; } }; 作者：lu-guo-de-feng-2 链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/zhi-xing-yong-shi-60-ms-zai-suo-you-c-ti-jiao-zh-3/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 击败99.7% class Solution { public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) { vector&lt;int&gt; map[26]; for(int i = 0; i &lt; s.size(); i++){ map[s[i] - 'a'].push_back(i); } string maxs = &quot;&quot;; for(int i = 0; i &lt; d.size(); ++i){ int s = -1, flag = 1; for(int j = 0; j &lt; d[i].size(); ++j){ int cp = d[i][j] - 'a'; int l = 0, r = map[cp].size(), mid; while(l &lt; r){ mid = (l + r) / 2; if(map[cp][mid] &gt; s) r = mid; else l = mid + 1; } if(l == map[cp].size() || s &gt;= map[cp][l]){ flag = 0; break; } s = map[cp][l]; } // cout &lt;&lt; endl; if(flag &amp;&amp; ( maxs.size() &lt; d[i].size() || maxs.size() == d[i].size() &amp;&amp; maxs &gt; d[i])) maxs = d[i]; } return maxs; } };","link":"/2020/10/22/shua-ti/qi-ta/524-longest-word-in-dictionary-through-deleting/"},{"title":"540. Single Element in a Sorted Array","text":"540. Single Element in a Sorted Array思路：设计一个二分即可。 代码：class Solution { public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int l = 0, r = n - 1, mid; while(l &lt; r){ mid = (l + r) / 2; int ct; if(mid == 0) return nums[0]; if(nums[mid] == nums[mid + 1]) ct = mid; else if(nums[mid] == nums[mid - 1]) ct = mid - 1; else return nums[mid]; if( (n - ct) % 2 == 0) r = mid; else l = mid + 1; } return nums[l]; } };","link":"/2020/11/09/shua-ti/qi-ta/540-single-element-in-a-sorted-array/"},{"title":"560. Subarray Sum Equals K","text":"560. Subarray Sum Equals K思路：hash+ 前缀。 代码：class Solution { public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; dp(n + 1); unordered_map&lt;int, int&gt; map; int ct = 0; map[0] = 1; for(int i = 1; i &lt; n + 1; ++i) { dp[i] = dp[i - 1 ] + nums[i - 1]; ct += map[dp[i] - k]; map[dp[i]]++; } return ct; } }; //错误二分，数组不保证都为正数 // class Solution { // public: // int subarraySum(vector&lt;int&gt;&amp; nums, int k) { // int n = nums.size(); // if(n == 0) return 0; // vector&lt;int&gt; dp(n + 1); // for(int i = 1; i &lt; n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1]; // int ct = 0; // for(int i = 0; i &lt; n; ++i){ // int r = n - 1; // int l = i; // while(l &lt; r){ // int mid = (l + r) / 2; // if(dp[mid + 1] - dp[i] &gt;= k) r = mid; // else l = mid + 1; // } // if(l &lt; n &amp;&amp; dp[l + 1] - dp[i] == k) ct++; // } // return ct; // } // }; // class Solution { // public: // int subarraySum(vector&lt;int&gt;&amp; nums, int k) { // int n = nums.size(); // if(n == 0) return 0; // vector&lt;int&gt; dp(n + 1); // for(int i = 1; i &lt; n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1]; // int ct = 0; // for(int i = 0; i &lt; n; ++i){ // for(int j = i; j &lt; n; ++j) // if(k == dp[j + 1] - dp[i]) ct++; // } // return ct; // } // };","link":"/2021/01/29/shua-ti/qi-ta/560-subarray-sum-equals-k/"},{"title":"566. Reshape the Matrix","text":"566. Reshape the Matrix思路： 从今天起，有些水题就不写了。浪费时间了。 代码：class Solution { public: class Iter{ int i ,j; int n, m; public: vector&lt;vector&lt;int&gt;&gt; &amp;nums; // Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums){ Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums){ i =0, j = 0; n = nums.size(); m = (n == 0) ? 0 : nums[0].size(); } bool empty(){ return i &gt; n - 1 || i == n - 1 &amp;&amp; j &gt; m - 1; } int&amp; next(){ if(j == m){ j = 0; i = i + 1; } // cout &lt;&lt; nums[i][j] &lt;&lt; endl; return nums[i][j++]; } }; vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) { if(nums.size() == 0 || nums.size() * nums[0].size() != r * c) return vector&lt;vector&lt;int&gt;&gt;(nums); int n = nums.size(); int m = nums[0].size(); vector&lt;vector&lt;int&gt;&gt; mat(r, vector&lt;int&gt;(c)); Iter p1(nums), p2(mat); while(!p1.empty()){ p2.next() = p1.next(); } // cout &lt;&lt; p1.nums[0][0] &lt;&lt; endl; // cout &lt;&lt; p2.nums[0][0] &lt;&lt; endl; return p2.nums; } };","link":"/2021/01/30/shua-ti/qi-ta/566-reshape-the-matrix/"},{"title":"605. Can Place Flowers","text":"605. Can Place Flowers这题还是典型的贪心，不过写的时候nt； 思路：用贪心的策略尽可能先种花，这种策略不会影响结果。只需要在遍历下考虑两边和边界情况就行了。 代码： class Solution { public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int res = 0, fn = flowerbed.size(); for(int i = 0; i &lt; flowerbed.size(); ++i){ if(flowerbed[i] == 0 &amp;&amp; (i == 0 || flowerbed[i - 1] == 0) &amp;&amp; (fn - 1 == i ||flowerbed[i + 1] == 0 )){ ++res; flowerbed[i] = 1; } } return res &gt;= n; } }; 版本二： class Solution { public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int res = 0, fn = flowerbed.size(); if(fn == 1 &amp;&amp; flowerbed[0] == 0) return n &lt;= 1; for(int i = 0; i &lt; flowerbed.size(); ++i){ if(flowerbed[i] == 0 &amp;&amp; ( i == 0 &amp;&amp; flowerbed[1] == 0 || i == (fn - 1) &amp;&amp; flowerbed[fn - 2] == 0 || (i &lt; fn - 1 &amp;&amp; i &gt; 0 &amp;&amp; flowerbed[i -1] ==0 &amp;&amp; flowerbed[i + 1] == 0))){ ++res; flowerbed[i] = 1; } } return res &gt;= n; } };","link":"/2020/10/13/shua-ti/qi-ta/605-can-place-flowers/"},{"title":"697. Degree of an Array","text":"697. Degree of an Array思路：简单遍历，不过数据给的水，可以稍稍放松一下遍历的范围，就不用写这么长了0 代码：class Solution { public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) { map&lt;int, int&gt; s ,e, fre; int maxfre = 1; vector&lt;int&gt; maxnum(1, nums[0]); for(int i = 0; i &lt; nums.size(); i++){ int t = nums[i]; if(fre[t] == 0){ s[t] = i; } fre[t]++; if(maxfre &lt; fre[t]){ maxfre = fre[t]; maxnum.clear(); maxnum.push_back(t); }else if(maxfre == fre[t]) maxnum.push_back(t); e[t] = i; } int lens = 0x0fffffff; for(int i = 0;i &lt; maxnum.size(); i++){ lens = min(e[maxnum[i]] - s[maxnum[i]] + 1, lens); } return lens; } };","link":"/2020/10/11/shua-ti/qi-ta/697-degree-of-an-array/"},{"title":"747. Largest Number At Least Twice of Others","text":"747. Largest Number At Least Twice of Others EZ 思路：沙雕题目。 代码：class Solution { public: int dominantIndex(vector&lt;int&gt;&amp; nums) { int numbig = -1, numlitter= -1, idx = -1; if(nums.size() == 1) return 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] &gt; numbig){ idx = i; numlitter = numbig; numbig = nums[i]; } else if(nums[i] &gt; numlitter){ numlitter = nums[i]; } } if(numbig &gt;= numlitter * 2 ){ return idx; } else return -1; } };","link":"/2020/09/24/shua-ti/qi-ta/747-largest-number-at-least-twice-of-others/"},{"title":"769. Max Chunks To Make Sorted","text":"769. Max Chunks To Make Sorted思路：暴力法。 简单的思路， 从左到右划分chrunk，判断最左边的chrunk最大值，其值+1就是chrunk的size。 依次进行就可以获得多个chrunk的size。 代码：class Solution { public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int split = -1; int num = 0; for(int i = 0; i &lt; arr.size(); ++i){ split = arr[i]; for(int j = 0; j &lt; split + 1; ++j){ split = max(split, arr[j]); } num++; i = split; } return num; } };","link":"/2021/01/22/shua-ti/qi-ta/769-max-chunks-to-make-sorted/"},{"title":"786. 第 K 个最小的素数分数","text":"786. 第 K 个最小的素数分数难度hard 思路：明显的有A[i] &lt; A[j]，能够推出A[i]/A[j] &gt; A[i]/A[j+1]，但是不能推出A[i+1]/A[j]和A[i]/A[j+1]的关系，毫无用处。 自然可以想到要用堆来维护第K小的数，而然超时。 评论里提出一种二分的方法， 代码：堆维护数组 struct cmp{ bool operator () (pair&lt;int, int&gt; x, pair&lt;int, int&gt; y){ return x.first * 1.0 / x.second &lt; y.first * 1.0 / y.second; } }; class Solution { public: vector&lt;int&gt; kthSmallestPrimeFraction(vector&lt;int&gt;&amp; A, int K) { priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, cmp&gt; pq; for(int i = 0; i &lt; A.size() - 1; i++){ for(int j = i + 1; j &lt; A.size(); j++){ double temp = A[i] * 1.0 / A[j]; if(pq.size() &lt; K){ pq.push(make_pair(A[i], A[j])); }else if(pq.top().first * 1.0 / pq.top().second &gt; temp){ pq.pop(); pq.push(make_pair(A[i], A[j])); } } } vector&lt;int&gt; res = vector(2, 0); res[0] = pq.top().first, res[1] = pq.top().second; return res; } };","link":"/2020/08/07/shua-ti/qi-ta/786-di-k-ge-zui-xiao-de-su-shu-fen-shu/"},{"title":"79. Word Search","text":"79. Word Search思路：回溯直接k.o. 代码：官方 class Solution { public: bool check(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; s, int k) { if (board[i][j] != s[k]) { return false; } else if (k == s.length() - 1) { return true; } visited[i][j] = true; vector&lt;pair&lt;int, int&gt;&gt; directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; bool result = false; for (const auto&amp; dir: directions) { int newi = i + dir.first, newj = j + dir.second; if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size()) { if (!visited[newi][newj]) { bool flag = check(board, visited, newi, newj, s, k + 1); if (flag) { result = true; break; } } } } visited[i][j] = false; return result; } bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { int h = board.size(), w = board[0].size(); vector&lt;vector&lt;int&gt;&gt; visited(h, vector&lt;int&gt;(w)); for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { bool flag = check(board, visited, i, j, word, 0); if (flag) { return true; } } } return false; } }; 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 我滴，不过由于没有把判断条件写在dfs函数入口那，性能显得不太好。 class Solution { public: int m, n; int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, vector&lt;vector&lt;bool&gt;&gt; &amp;vis, int x, int y, int pos){ //BUGS VECTOR &amp; if(x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || vis[x][y] || pos == word.size()) return false; vis[x][y] = true; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; if(board[x][y] == word[pos]){ if(pos == word.size() - 1) return true; for(int i = 0;i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; if(dfs(board, word, vis, nx, ny, pos + 1)) return true; } } return false; } bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { m = board.size(); if(m &gt; 0){ n = board[0].size(); } for(int i = 0; i &lt; m; ++i){ for(int j = 0; j &lt; n; ++j){ if(word[0] == board[i][j]){ cout &lt;&lt; &quot;i * j&quot; ; vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, 0)); if(dfs(board, word, vis, i, j, 0)) return true; } } } return false; } };","link":"/2020/11/26/shua-ti/qi-ta/79-word-search/"},{"title":"833.字符串中的查找与替换","text":"中等题 这题坑还是很多的，如输入数据非有序，考虑在同一字符串插入时多个字符串替换时原字符串的下标维持或是可插入性。 思路1: 将indexes所标记出的下标映射为输入数据的次序，在排序indexes来有序遍历S。之后就是判断哪些S的字母可以替换并替换。 思路2（官方）： 为了顺序地构造目标字符串，先标记出S中所有可替换的位置，并顺序遍历（逆序或者正序都可以，构造方法不同罢了）。 依据题意，可以推出从后向前替换，可以避免下标变换的问题。 class Solution { public: //题目没看清,多写了一个转化大小写函数 string lowercase(string S){ // return A iterator; std::transform(S.begin(), S.end(), S.begin(), [](unsigned char c){return std::tolower(c);} ); return S; } //思路1 string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) { int idx2 = indexes.size() - 1; vector&lt;int&gt; repl( indexes.size() ); //将排序后的字符串下标映射回原来的下标 //同时不能 把排序后的index下标映射或者被映射; map&lt;int, int&gt; match; for(int i=0;i&lt;indexes.size();i++) match[ indexes[i] ] = i; sort(indexes.begin(), indexes.end()); //判断逆序判断能否替换，若可以则逆序替换； //逆序替换不影响之前的可替换性判断 for(int i=S.size()-1;i&gt;=0 &amp;&amp; idx2 &gt;=0 ;i--){ if(i == indexes[idx2]){ if(lowercase( S.substr(i, sources[match[i]].size())) == sources[match[i]] ) S.replace(i, sources[match[i]].size(), targets[match[i]]); idx2 --; } } return S; } // 思路2：官方解的实现，也是空间换时间 string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) { //对S每个字母对有效替换的判断, 并记录下标 vector&lt;int&gt; match(S.size(), -1); for(int i=0 ;i&lt;indexes.size();i++){ if( S.substr(indexes[i], sources[i].size()) == sources[i]) match[ indexes[i] ] = i; } //判断逆序判断能否替换，若可以则逆序替换； for(int i=S.size()-1;i&gt;=0 ;i--){ if(match[i] != -1){ S.replace(i, sources[match[i]].size(), targets[match[i]] ); } cout&lt;&lt; S &lt;&lt; endl; } return S; } };","link":"/2020/08/07/shua-ti/qi-ta/833-zi-fu-chuan-zhong-de-cha-zhao-yu-ti-huan/"},{"title":"88. Merge Sorted Array","text":"思路：双指针从后向前合并即可，时间复杂度为$n(o)$，空间复杂度$O(1)$。 代码：class Solution { public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int pos = m + n - 1, p1 = m - 1, p2 = n - 1; while(p1 &gt;= 0 &amp;&amp; p2 &gt;= 0){ if(nums1[p1] &gt; nums2[p2]){ nums1[pos] = nums1[p1--]; }else{ nums1[pos] = nums2[p2--]; } pos--; } while(p2 &gt;= 0){ nums1[pos--] = nums2[p2--]; } } };","link":"/2020/10/17/shua-ti/qi-ta/88-merge-sorted-array/"},{"title":"934. Shortest Bridge","text":"934. Shortest Bridge思路：一次dfs搜索一个岛屿，一次bfs搜最短路径。 代码：class Solution { public: int n, m; int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; class Point{ public: int x; int y; int dis; Point(int _dis, int _x, int _y){ x = _x; y = _y; dis = _dis; } friend bool operator &lt;(const Point &amp;a, const Point &amp;b){ return a.dis &gt; b.dis; } }; bool check(int x, int y){ return !(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n ); } void getIslang(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; vis, priority_queue&lt;Point&gt; &amp;island, int x, int y){ if( !check(x,y) || vis[x][y] || A[x][y] == 0) return; island.push(Point(0, x, y)); vis[x][y] = 1; for(int i = 0; i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; getIslang(A, vis, island, nx , ny); } } int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) { m = A.size(); if(m == 0) return -1; n = A[0].size(); vector&lt;vector&lt;int&gt;&gt; vis(m, vector&lt;int&gt;(n, 0)); priority_queue&lt;Point&gt; que; int flag = 1; for(int i = 0; flag &amp;&amp; i &lt; m; ++i){ for(int j = 0; j &lt; n; ++j){ if(A[i][j] == 1){ flag = 0; getIslang(A, vis, que, i, j); break; } } } // cout &lt;&lt; que.size() &lt;&lt; endl; while(que.size()){ Point p = que.top(); que.pop(); // cout &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; endl; for(int i = 0; i &lt; 4; ++i){ int nx = p.x + dx[i]; int ny = p.y + dy[i]; if(!check(nx, ny)) continue; if(!vis[nx][ny]){ vis[nx][ny] = 1; if(A[nx][ny] == 1){ return p.dis; }else{ que.push(Point(p.dis + 1, nx, ny)); } } } } return -1; } };","link":"/2020/11/28/shua-ti/qi-ta/934-shortest-bridge/"},{"title":"面16-数值的N次方","text":"题面：给一个浮点数，求出其数值的整数次方。 思路：主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。 代码：int power(double base, int exponent){ //无穷大的非法计算值 if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); unsigned int posExponent = (unsigned int)exponent; double mulBase = base, mulRes = 1; while(posExponent &gt; 0){ if(posExponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; posExponent = posExponent &gt;&gt; 1; } if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; } 可能降低耦合更好一点 double PowerWithUnsighedExponent(double base, unsigned int exponent){ //特判：基数为0；指数为0无需特判 if( equla(base, 0.0)) return 0.0; double mulRes = 1; while(exponent &gt; 0){ if(exponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; exponent = exponent &gt;&gt; 1; } return mulRes; } int power(double base, int exponent){ //无穷大的非法计算值 if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); double mulRes = PowerWithUnsignedExponent(base, exponent); if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; }","link":"/2020/08/07/shua-ti/qi-ta/mian-16-shu-zhi-de-n-ci-fang/"},{"title":"面试题-递归迭代","text":"收集一些经典的题目 斐波那契数列计算 三种思路：递归、dp和快速矩阵乘 dp long long Fobonacci(unsigned n){ if(n &lt;= 0) return -1; long long fibN1 = 0; long long fibN2 = 1; if(n == 1) return fibN1; else if(n == 2) return fibN2; for(int k = 2; k &lt;= n; k++){ int temp = fibN2; fibN2 = fibN2 + fibN2; fibN1 = temp; } return fibN2; } 思路扩展：青蛙跳台阶问题，1*2方块铺设问题，","link":"/2020/08/07/shua-ti/qi-ta/mian-shi-ti-di-gui-die-dai/"},{"title":"面试题44：1出现的个数","text":"广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理 题目：统计从1到N的所有数字的1的出现次数。 思路：第一种：所有人都能想出直接暴力解的算法。 第二种：参考其他人的解法。 设N = abcde ,其中abcde分别为十进制中各位上的数字。如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100199，11001199,21002199，，…，1110011199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100199，11001199,21002199，，….，1110011199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：1210012113,一共114个，等于低位数字（113）+1。③ 如果百位上数字大于1（29），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100199,11001199，21002199，…，1110011199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。——参考牛客网@藍裙子的百合魂 代码：int CounterOf1(int x){ if(x &lt;= 0) return 0; int len = 0, tempX = x, judugNum = 1; while(tempX){ tempX = tempX / 10; len ++; } int power = 10, counter = 0 ; for(int i = 0; i &lt; len; i++){ int liPower = power / 10; int num = x % power / liPower; if(num &gt; judugNum ){ counter += (x / power + 1) * liPower; }else if(num == judugNum ){ counter += (x / power) * liPower + x % liPower + 1; }else counter += x / power * liPower; power *= 10; } return counter; } 测试可见 牛客","link":"/2020/08/07/shua-ti/qi-ta/mian-shi-ti-44-1-chu-xian-de-ge-shu/"},{"title":"面试题49：丑数","text":"","link":"/2020/08/07/shua-ti/qi-ta/mian-shi-ti-49-chou-shu/"},{"title":"241. Different Ways to Add Parentheses","text":"241. 为运算表达式设计优先级思路：分解算术式子，分开计算即可。 分治法自上而下求取答案，当然可以用上记忆化的技巧。 DP自下而上求取答案，速度和内存消耗更少。 代码：class Solution { public: vector&lt;int&gt; diffWaysToCompute(string input) { vector&lt;int&gt; nums; vector&lt;char&gt; ops; int a = 0; char op = ' '; input = input + '+'; for(int i = 0; i &lt; input.size(); ++i){ if(input[i] == '+' || input[i] == '-' || input[i] == '*'){ nums.push_back(a); cout &lt;&lt; a; a = 0; op = input[i]; } else{ a *= 10; a += input[i] - '0'; if(op != ' '){ ops.push_back(op); op = ' '; } } } set&lt;int&gt; res = getDivide(nums, ops, 0, nums.size() - 1); vector&lt;int&gt; ans = {}; for(auto it = res.begin(); it != res.end(); it++) ans.push_back(*it); return ans; } set&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e){ set&lt;int&gt; temp; if(s == e){ temp.insert(nums[s]); return temp; } for(int i = s; i &lt; e; ++i){ set&lt;int&gt; res1 = getDivide( nums, ops, s, i); set&lt;int&gt; res2 = getDivide( nums, ops, i + 1, e); for(auto it1 = res1.begin(); it1 != res1.end(); it1++){ for(auto it2 = res2.begin(); it2 != res2.end(); it2++){ if(ops[i] == '+') temp.insert(*it1 + *it2); else if(ops[i] == '-') temp.insert(*it1 - *it2); else if(ops[i] == '*') temp.insert(*it1 * *it2); } } } return temp; } }; AC80% class Solution { public: vector&lt;int&gt; diffWaysToCompute(string input) { vector&lt;int&gt; nums; vector&lt;char&gt; ops; int a = 0; char op = ' '; input = input + '+'; for(int i = 0; i &lt; input.size(); ++i){ if(input[i] == '+' || input[i] == '-' || input[i] == '*'){ nums.push_back(a); // cout &lt;&lt; a; a = 0; op = input[i]; } else{ a *= 10; a += input[i] - '0'; if(op != ' '){ ops.push_back(op); op = ' '; } } } return getDivide(nums, ops, 0, nums.size() - 1); } vector&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e){ vector&lt;int&gt; temp; if(s == e){ temp.push_back(nums[s]); return temp; } for(int i = s; i &lt; e; ++i){ vector&lt;int&gt; res1 = getDivide( nums, ops, s, i); vector&lt;int&gt; res2 = getDivide( nums, ops, i + 1, e); for(auto it1 = res1.begin(); it1 != res1.end(); it1++){ for(auto it2 = res2.begin(); it2 != res2.end(); it2++){ if(ops[i] == '+') temp.push_back(*it1 + *it2); else if(ops[i] == '-') temp.push_back(*it1 - *it2); else if(ops[i] == '*') temp.push_back(*it1 * *it2); } } } return temp; } }; DP记忆化方法 100% class Solution { public: vector&lt;int&gt; diffWaysToCompute(string input) { vector&lt;int&gt; nums; vector&lt;char&gt; ops; int num; char op; istringstream ss(input + &quot;+&quot;); //! istringstream while(ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op){ nums.push_back(num); ops.push_back(op); } int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); for(int i = 0; i &lt; n; ++i){ for(int j = i; j &gt;=0; j--){ if(i == j){ dp[j][i].push_back(nums[i]); }else{ for(int k = j; k &lt; i; k++){ for(auto l : dp[j][k]){ for(auto r : dp[k+1][i]){ int val = 0; switch(ops[k]){ case '+': val = l + r; break; case '-': val = l - r; break; case '*': val = l * r; break; } dp[j][i].push_back(val); } } } } } } return dp[0][n - 1]; } };","link":"/2021/01/02/shua-ti-fen-zhi-241-different-ways-to-add-parentheses/"},{"title":"932. Beautiful Array","text":"932. Beautiful Array思路：这题的难度是怎么想出一个策略来保存漂亮数组的存在。 将1~N的数字划分为奇数和偶数，并放到数组两边，即可保证。同时可以发现仿射变化对漂亮数组的性质没有影响。$$2 *(k * a[k] + b) = k * a[i] + b + k * a[j] + b$$ 那么就有任意一边的数字都可以通过仿射变化变为1-(N/2+1/2)的问题。比如，原本左边有$(n + 1) / 2$个奇数数字，右边有$N/2$个偶数数字。那么左边的奇数数字可以通过仿射变化$a[i]’= a[i]/2 + 1/2$，右边的偶数数字可以通过仿射变化$a[i]’= a[i]/2$，将问题分解成了规模减半的两个子问题。 通过递归分治我们可以解决该问题。 代码：100% class Solution { public: vector&lt;int&gt; beautifulArray(int N) { vector&lt;int&gt; arr(N); for(int i = 0; i &lt; arr.size(); ++i) arr[i] = i + 1; f(0, N - 1, N, arr); return arr; } void f(int s, int e, int N, vector&lt;int&gt; &amp;arr){ if(s == e){ arr[s] = 1; return; } int odd = (N + 1) / 2; f(s, s + odd - 1, odd, arr); for(int i = s; i &lt; s + odd; i++) arr[i] = arr[i] * 2 - 1; f(s + odd, e, N - odd, arr); for(int i = s + odd; i &lt;= e; ++i) arr[i] = arr[i] * 2; } };","link":"/2021/01/04/shua-ti-fen-zhi-932-beautiful-array/"},{"title":"142. Linked List Cycle II","text":"思路：用快慢指针fast，slow去发现链表中的圆，再使用一个指针和p1一起遍历链表： 2(a + b) = a + b + (b + c ) *n 得到 a = c + (b + c ) *(n - 1) 如此可以推得，如果从p0从head和slow一起出发，会在环的入口处相遇。如此就可以推得算法的正确性。 另外开始验证，fast和low会在第一个low指针的第一圈相遇。 设置两个指针相遇时，low指针走了路程s1 = a + s + n(b + c)，fast指针走了路程s2 = a + s + k(b + c)。同时有s1 * 2 = s2，则有a + s = (k - 2n)(b +c)。 上面的证法不行： 设slow刚入环的时候，fast在距离环入口的位置B，慢指针走了C,最后设环长为L。 C % L = (2 *C + B) % L 等价于 C + NL = 2 * C + B C = NL - B 当N==1，有0&lt;=C&lt;=B 当然，需要另外一个推理： 两个步长分别为1和2的指针，经过必定能相遇，可以通过遍历所有状态得知。 代码/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *p1 = head, *p2 = head; int flag = 0, cyclen = 0, tlen = 0; while(p1){ p1 = p1-&gt;next; if(p1 == nullptr) return nullptr; p1 = p1-&gt;next; p2 = p2-&gt;next; if(p1 == p2) break; } if(p1 == nullptr) return nullptr; // while(1){ // p1 = p1-&gt;next-&gt;next; // p2 = p2-&gt;next; // cyclen++; // if(p1 == p2) break; // } ListNode *p0 = head; while(p0 != p1){ p0 = p0-&gt;next; p1 = p1-&gt;next; tlen++; } return p0; } };","link":"/2020/10/19/shua-ti/shuang-zhi-zhen/142-linked-list-cycle-ii/"},{"title":"167. Two Sum II - Input array is sorted","text":"思路：双指针遍历。复杂度$O(n)$。 代码：class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int n = numbers.size(); int l = 0, r = n - 1; while(l &lt; r){ int s = numbers[l] + numbers[r]; if(s &gt; target) r--; else if(s &lt; target) l++; else break; } // vector&lt;int&gt; v(2,0); // v[0] = l + 1; v[1] = r + 1; // return v; return {l + 1, r + 1}; } };","link":"/2020/10/17/shua-ti/shuang-zhi-zhen/167-two-sum-ii-input-array-is-sorted/"},{"title":"287. Find the Duplicate Number","text":"287. Find the Duplicate Number思路快慢指针算法，$o(n), o(1)$。 这题的难点是看出能把数组转化为链表，而且链表中有环。 代码class Solution { public: int findDuplicate(vector&lt;int&gt;&amp; nums) { // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2; int p1 = 0, p2 = 0; do{ p1 = nums[nums[p1]]; p2 = nums[p2]; }while(p1 != p2); p2 = 0; while(p1 != p2){ p1 = nums[p1]; p2 = nums[p2]; } return p1; // p1才是重复的数字/idx } };","link":"/2021/02/05/shua-ti/shuang-zhi-zhen/287-find-the-duplicate-number/"},{"title":"438. Find All Anagrams in a String","text":"思路：双指针，指向模式串str的子串首位s和末尾+1e。 遍历思路： 不断添加e位置上的字符c 如果c不属于p，则双指针跳过c 如果c属于p，则更新。 但是如果包括的c字符太多了，则移动s直至数量符合条件 如果所有字符数量都添加完全一致，则添加结果。移动s一位，更新即可。 看了其他题解，发现有一个条件我忽略了，指针之间的距离是相等的，也就是说这是一个滑动窗口问题~草了。 那这很简单，维护一下窗口值就行了。 可以说滑动窗口就是一个简单的双指针。 代码： class Solution { map&lt;char, int&gt; group, times;// group: [s, e) 之间的字符出现次数， time: p字符出现次数 public: vector&lt;int&gt; findAnagrams(string str, string p) { int s = 0, e = 0; for(auto c : p) ++times[c]; int groopsize = p.size(); vector&lt;int&gt; indexes; while( s &lt; str.size() &amp;&amp; e &lt; str.size()){ if(times[str[e]] == 0) { s = e + 1; group.clear(); groopsize = p.size(); }else{ ++group[str[e]]; --groopsize; // 出现次数过多， 向前收缩s while( group[str[e]] &gt; times[str[e]]){ --group[str[s]]; ++s; ++groopsize; } // [s, e)内是p的anagram if(groopsize == 0){ indexes.push_back(s); --group[str[s]]; ++s; ++groopsize; } } ++e; // cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; groopsize &lt;&lt; endl; } // cout &lt;&lt; endl; return indexes; } }; class Solution { public: vector&lt;int&gt; findAnagrams(string str, string p) { int s = 0, e = 0; vector&lt;int&gt; indexes, window, need; if(p.size()&gt;str.size()) return {}; window.resize(128); need.resize(128); for(int i = 0; i &lt; p.size(); ++i){ ++window[str[i]]; ++need[p[i]]; } e = p.size(); while(e &lt;= str.size()){ if(window == need) indexes.push_back(s); if(str.size() == e) break; window[str[e++]]++; window[str[s++]]--; } return indexes; } };","link":"/2021/04/30/shua-ti/shuang-zhi-zhen/438-find-all-anagrams-in-a-string/"},{"title":"633. Sum of Square Numbers","text":"633. Sum of Square Numbers 思路： 二分 分解质因子判断费马平方定理条件是否成立 任何一个等于两个数的平方之和的数的所有值为$(4k+3)$的因子次幂是偶数的。 双指针法遍历即可（击败100%） 代码：双指针法 class Solution { public: bool judgeSquareSum(int c) { long long sum, a = 0, b = (long long)(sqrt(c)); while(a &lt;= b ){ sum = a * a + b * b; if(sum &gt; c) b--; else if(sum &lt; c) a++; else break; } if(sum == c) return true; else return false; } }; 判断费马平方定理： class Solution { public: bool judgeSquareSum(int c) { // int d = (int)sqrt(c), ori = c ; // for(int i = 2; i &lt;= d + 1 &amp;&amp; c != 1; ++i){ for(int i = 2; i &lt;= c; ++i){ if(c % i == 0){ int t = 0; while(c % i == 0){ ++t; c /= i; } if((i + 1) % 4 == 0){ if(t &amp; 1) return false; } } } // if(c == ori &amp;&amp; (c + 1) % 4 == 0) return false; return true; } };","link":"/2020/10/24/shua-ti/shuang-zhi-zhen/633-sum-of-square-numbers/"},{"title":"680. Valid Palindrome II","text":"680. Valid Palindrome II思路：典型的贪心题 + 二指针。这题还蛮不错的。 运用题目给出的最多删一个的关键信息，就可以写出一个简单的算法：用两个指针变量遍历string两边，如果有不用的字符。尝试删除掉两个中的一个，判断剩下的字符串是否是Palindrome. 代码：class Solution { public: bool isPartialPalindrome(string &amp;s, int l, int r) { while(l &lt; r){ if(s[l] != s[r]) return false; ++l; --r; } return true; } bool validPalindrome(string s) { int l = 0, r = s.size() - 1; while(l &lt; r){ if(s[l] != s[r]){ return isPartialPalindrome(s, l + 1, r) || isPartialPalindrome(s, l , r - 1); } ++l; --r; } return true; } };","link":"/2020/10/26/shua-ti/shuang-zhi-zhen/680-valid-palindrome-ii/"},{"title":"76. Minimum Window Substring","text":"76. Minimum Window Substring思路1:经典双指针下的滑动窗口算法。滑动窗口的左右部分分别由两个指针l,r指向。 使用滑动窗口观察可能符号的条件的子串，并用unordered_map或者map来记录原字符串s和滑动窗口win中的元素个数。 其算法过程如下： 窗口的右指针向右滑动一次，并检查窗口内是否有足够元素。若是，则左指针向右收缩窗口。重复上述步骤即可。 代码： class Solution { public: map&lt;char, int&gt; cur, ori; //优化: 去除无效字符 int ahash[800] = {0}; bool check(){ for(const auto &amp;p : ori){ if(cur[p.first] &lt; p.second) return false; } return true; } string minWindow(string s, string t) { for(int i = 0; i &lt; t.size(); ++i){ ++ori[t[i]]; ahash[t[i]] = 1; } int l = 0, r = -1, maxLen = 0x7fffffff; string ans = &quot;&quot; ; while(r &lt; int(s.size())){ while(++r &lt; s.size() &amp;&amp; !ahash[s[r]]); if(r == s.size()) break; ++cur[s[r]]; // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; while(check() &amp;&amp; l &lt;= r){ if(maxLen &gt; r - l + 1){ ans = s.substr(l, r - l + 1); maxLen = r - l + 1; } //先减再移动……这个bug --cur[s[l]]; while(++l &lt;= r &amp;&amp; !ahash[s[l]]); } } return ans; } }; 思路2：更巧妙的方法： 音量模拟：想象一排音量，分别代表着每个t中元素的个数。 在滑动窗口向r指针在t向右扩展窗口中， 每遇到一个s中的元素就减去对应的音量值。如果滑动窗口中包含了s中的各个元素（包括种类和数量），那么就有音量图的每个柱子都在水平下以下或者持平，如果我们记录在水平线之上的数值变动——用cnt记录--yin[s[i]] &gt;=0的剩余次数即可。 如果cnt==0，说明窗口已经包括了所有元素，可以缩小范围，把左指针向👉右滑动。cnt的变动也是同理的。 代码如下： 代码2：class Solution { public: // 音量模拟 unordered_map&lt;char, int&gt; map; string minWindow(string s, string t){ for(int i = 0; i &lt; t.size(); ++i) ++map[t[i]]; int cnt = t.size(), l = 0, r = -1, start = l, maxl = s.size() + 1; while(r &lt; int(s.size())){ if(--map[s[++r]] &gt;= 0) --cnt; // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; while(l &lt;= r &amp;&amp; cnt == 0){ if(maxl &gt; r - l + 1){ start = l; maxl = r - l + 1; } if(++map[s[l]] &gt; 0) cnt++; l++; } } return maxl == s.size() + 1 ? &quot;&quot; : s.substr(start, maxl); } }; 代码3：（二刷）class Solution { public: // 双指针必定都搜索到所有匹配串的原因是 所有以 g为终点的符合题意的的字符串s1， // 其左端点必定可以向左移动，因为移动会包含到更多字符串 // 反过来想，从起点出发，右端点移动先尽可能包含多直到足够的字符， // 再向右移动左端点尽可能减少多余的字符，获取一个尽可能短的字符串 // 为了尝试其他结果，不断地进行以下活动 // 移动右端点一次，缩短左端点，可以搜索到其他结果 // 比较细节的是控制过程和循环结束 // string minWindow(string s, string t) { int ct[256] = {0}, allct = t.size(); string ans; // s += 'A'; for(int i = 0; i &lt; t.size(); ++i) ++ct[t[i]]; int p1 = 0, p2 = 0; // [)左闭右开空间，秒在不需要初始化 int minlen = s.size() + 1, minp1 = 0; while(p2 &lt; s.size()){ // 要么右移p2直到t字符串全部被囊括，要么试探性移动p2一个位置，进行其他位置的探索 while(p2 &lt; s.size()){ // p2 &lt;= s.size() if(ct[s[p2]] &gt; 0) --allct; // allct统计是否当前[p1, p2)是否有t的全部字符 --ct[s[p2]]; // 更新字符数量 ++p2; if(allct == 0) break; //前进一步 } while(ct[s[p1]] &lt; 0){ // 如果该字符多余了，缩小左端点 ++ct[s[p1]]; ++p1; } if(allct == 0 &amp;&amp; p2 - p1 &lt; minlen){ minp1 = p1; minlen = p2 - p1; } // cout &lt;&lt; p1 &lt;&lt; ' ' &lt;&lt; p2 &lt;&lt; ' ' &lt;&lt; allct &lt;&lt; endl; } if(minlen &gt; s.size())ans = &quot;&quot;; else ans = s.substr(minp1, minlen); return ans; } };","link":"/2020/10/23/shua-ti/shuang-zhi-zhen/76-minimum-window-substring/"},{"title":"132. Palindrome Partitioning II","text":"132. Palindrome Partitioning II思路：dp，dp[i]表示最小分割子串数，状态转移方程为： 其中子串是否为回文串可以预计算，这样就把复杂度从o(N^3)降到o(N^2)。 代码：class Solution { vector&lt;int&gt; dp; public: int minCut(string s) { int n = s.size(); dp.resize(n); for(int i = 0; i &lt; n; ++i){ dp[i] = i + 1; for(int j = i; j &gt;= 0; --j){ if(isPalindrome(s, j, i)){ dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]); } } } return dp[n - 1] - 1; } bool isPalindrome(string &amp;s, int i, int j){ if(i &gt;= j) swap(i, j); while(i != j &amp;&amp; i &lt; j){ if(s[i] != s[j]) return false; --j; ++i; } return true; } }; 预计算 class Solution { vector&lt;int&gt; dp; vector&lt;vector&lt;int&gt;&gt; isPal; public: int minCut(string s) { int n = s.size(); dp.resize(n); isPal.resize(n, vector&lt;int&gt;(n,1)); for(int i = n - 1; i &gt;= 0; --i){ for(int j = i + 1; j &lt; n; ++j){ // if(i == j) isPal[i][j] = 1; // else if(i != n- 1 &amp;&amp; j != 0) isPal[i][j] = isPal[i + 1][j - 1] &amp;&amp; s[i] == s[j]; // s[i,j]的回文需要s[i + 1, j - 1]的回文，那么反向遍历即可。 } } for(int i = 0; i &lt; n; ++i){ dp[i] = i + 1; for(int j = i; j &gt;= 0; --j){ if(isPal[j][i]){ dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]); } } } return dp[n - 1] - 1; } };","link":"/2021/03/08/shua-ti/zi-fu-chuan/132-palindrome-partitioning-ii/"},{"title":"227. Basic Calculator II","text":"227. Basic Calculator II思路经典的中缀转后缀练手题，但是我偏不。 在遍历字符串把数字和运算符存储到一个数字栈和运算栈中，考虑到运算顺序是乘除&gt;加减，且左边&gt;右边，所以在压入新运算符op前把栈中优先级大于等于op的运算法弹出，并计算。 遍历完了运算栈可能还有运算符，逆向计算即可。最后数据栈弹出结果就完事。 代码class Solution { public: using ull = unsigned long long; ull func(char c, ull num1, ull num2){ if(c == '+') return num1 + num2; if(c == '-') return num1 - num2; if(c == '*') return num1 * num2; if(c == '/') return num1 / num2; return 0; } int calculate(string s) { s += ']'; stack&lt;char&gt; op; stack&lt;ull&gt; num; map&lt;char, int&gt; pri{{'+', 1},{'-', 1},{'*', 2},{'/', 2}}; ull cal = 0; for(auto c : s){ if(isdigit(c)) cal = cal * 10 + c - '0'; else{ if(c == ' ') continue; // cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; cal &lt;&lt; endl; num.push(cal); cal = 0; if(c == ']') continue; while(op.size() &amp;&amp; pri[c] &lt;= pri[op.top()]){ int num2 = num.top(); num.pop(); int num1 = num.top(); num.pop(); num.push( func(op.top(), num1, num2) ); op.pop(); } op.push(c); } } // cout &lt;&lt; num.size() &lt;&lt; ' ' &lt;&lt; op.size() &lt;&lt; endl; while(op.size()){ int num2 = num.top(); num.pop(); int num1 = num.top(); num.pop(); num.push( func(op.top(), num1, num2) ); op.pop(); } return num.top(); } };","link":"/2021/02/12/shua-ti/zi-fu-chuan/227-basic-calculator-ii/"},{"title":"28. Implement strStr()","text":"思路：经典的字符子串匹配问题： 暴力匹配，$O(mn)$ Rabin Karp $O(n)$ KMP算法 KMP算法KMP算法的核心在于next数组，其next[i]记录了字符串str[0...i]的最长相同前后缀子串（不包括子串本身）的前缀尾下标。如此，我们在母子串在匹配i（母串Sa），j（子串Sb）失败时，子串的k = next[j - 1]记录了保证了最长Sa与Sb[0, k]可匹配成功（k不断减小，但i没有减小），重新判断Sa[i]==?Sb[k+1]即可。重复这个步骤，直到k无法缩小，或者匹配成功。若成功，++i，++j；若失败，则++i，j=0。 但在此之前，还有构造next数组。神奇的是，next[i]构造与匹配的过程极其类似。首先next[0] = -1。记k = next[i - 1]，比较Sb[k + 1] == ? Sb[i]，若成功，则Sb[i]= k + 1；若失败，则寻找更小的公共前后缀（为了寻找最长的公共前缀长度，利用了Sb[0,..,i-1]子串的最长前缀后子串，以及更短的前后缀子串！（后两者的性质保证了属于前者的后缀子串✨✨）），缩小k为next[k]，再次比较。其中k&gt;-1。如果还是失败了，明显的不存在相同的前后缀子串next[i] = -1。 代码：class Solution { public: //暴力 int strStr(string haystack, string needle) { int m = haystack.size(), n = needle.size(); if(n == 0) return 0; int k = 0, j = 0; //aaaaaf //-----fs while(k &lt;= m - n){ while(j &lt; n &amp;&amp; haystack[k] == needle[j]) ++k, ++j; if(j == n) return k - j; k = k - j + 1; j = 0; } return -1; } }; class Solution { public: //暴力 int strStr(string haystack, string needle) { auto tonum = [](char a){return a - 'a';}; int m = haystack.size(), n = needle.size(); if(n == 0) return 0; using ktype = long long; ktype base = 26, key = 0; //MOD 超过上限自然溢出? ktype point = 0, hpow = 1, MOD = 1e9 + 7; for(int i = 0; i &lt; n; ++i){ // 字符串前位权重高 key = (key * base + tonum(needle[i])) % MOD; hpow = (hpow * base) % MOD; // bugs point = (point * base + tonum(haystack[i])) % MOD; } // if(point &lt; 0 || key &lt; 0) cout &lt;&lt; &quot;+&quot;; if(key == point) return 0; for(int j = n; j &lt; m; ++j){ point = (((point * base - tonum(haystack[j - n]) * hpow) % MOD + MOD) + tonum(haystack[j])) % MOD; //疯狂使用运算符限制和e取余运算防止溢出 // if(point &lt; 0 ) cout &lt;&lt; '-'; if(key == point){ return j - n + 1; } } return -1; } }; class Solution { public: //KMP 100% int strStr(string haystack, string needle) { int n = haystack.size(), m = needle.size(); if(m == 0 ) return 0; vector&lt;int&gt; next(m, -1); //next[i] 为needle[0,...., i]相同最长前后缀的前缀末下标 for(int i = 1; i &lt; m; ++i){ int k = next[i - 1]; // needle[0,...., i - 1]相同最长前后缀的前缀末下标 while(k != -1 &amp;&amp; needle[k + 1] != needle[i]){ // 尝试扩展前后缀 needle[0, k + 1], needle[,..,i-1,i] k = next[k]; //匹配失败，缩短前后缀 } if(needle[k + 1] != needle[i]) next[i] = -1; else next[i] = k + 1; // cout &lt;&lt; next[i] &lt;&lt; endl; } int i = 0, j = 0; for(; i &lt; n; ++i ){ // i, j 为当前匹配的下标字符 while(haystack[i] != needle[j] &amp;&amp; j &gt; 0){ // 两串匹配失败，且j可压缩 j = next[j - 1] + 1; // 压缩needle串的最长相等前后缀长度， 最小为0 } if(haystack[i] == needle[j]){ ++j; if(j == m) return i - j + 1; } } return -1; } };","link":"/2021/02/15/shua-ti/zi-fu-chuan/28-implement-strstr/"},{"title":"3. Longest Substring Without Repeating Characters","text":"3. Longest Substring Without Repeating Characters思路： 暴力 双指针 可以观察到，符合题意的子串在按左端下标从小到大排序时，右端下标也是非严格递增的。 惊喜的是，双指针便可以派上用场了，i，j分别指向子串两端，并维护不重复的性质即可。 代码：暴力： class Solution { public: int lengthOfLongestSubstring(string s) { int ct= 0; for(int i = 0; i &lt; s.size(); ++i){ vector&lt;int&gt; pos(259, -1); for(int j = i; j &lt; s.size(); ++j){ if(pos[s[j]] != -1) break; pos[s[j]] = 1; ct = max(ct, j - i + 1); } } return ct; } }; 双指针 class Solution { public: int lengthOfLongestSubstring(string s) { unordered_set&lt;char&gt; hash; int i, j, ct, n = s.size(); i = j = ct = 0; while(j &lt; n){ if(!hash.count(s[j])){ ct = max(ct, j - i + 1); hash.insert(s[j++]); } else{ hash.erase(s[i++]); } } return ct; } };","link":"/2021/02/18/shua-ti/zi-fu-chuan/3-longest-substring-without-repeating-characters/"},{"title":"647. Palindromic Substrings","text":"647. Palindromic Substrings1思路：Manacher算法： 回文字符串的判断方式方式会从中心点从发向外不断扩展，Manacher算法给出了缩减了字符串判断回文的重复步骤。其核心思想在于，一段回文s上的呈对称状的左右A和B两点，B点的最小回文长度可以通过A点的回文长度和B到s边右边界的长度最小值决定。另外，为了改变回文串长度为偶数和奇数的不同，在每个字符前和后都插入一个#，如此插入后的T的最长回文串半径d，与S最长回文串半径的k有， k = [d / 2] 。 []向下取整。 代码：class Solution { public: int countSubstrings(string s) { string t = &quot;!#&quot;; // 插入哨兵 for(char c : s){ t += c + string(&quot;#&quot;); } t +=&quot;$&quot;; int amount = 0, n = t.size(); vector&lt;int&gt; f(n); int curmid = 1, right = 1; for(int i = 1; i &lt; n; ++i){ int j = curmid * 2 - i; int len = i &gt; right ? 1 : min(f[j], right - i + 1); while(t[i + len] == t[i - len]) ++len; //$ !作为哨兵自动控制边界 f[i] = len; if(i + len - 1 &gt; right){ curmid = i; right = i + len - 1; } amount += f[i] / 2; // cout&lt;&lt; f[i] &lt;&lt; &quot; &quot;; } // cout &lt;&lt; endl; return amount; } };","link":"/2021/02/14/shua-ti/zi-fu-chuan/647-palindromic-substrings/"},{"title":"215. Kth Largest Element in an Array","text":"215. Kth Largest Element in an Array复习一遍第K大算法的三 ➕ 一种经典解法 思路： 暴力排序 快速排序的Partition 建长度为k的小顶堆 ⭐⭐⭐快速指针算法, $O(N)$ 这题的算法非常巧妙！同样也是partition思想，取一个nums[k]作为pivot，并放在数组最右边作为哨兵。用两个指针i和j从左到右遍历数组，其意义在于指向比pivot小的数字区间左右闭区间。如果nums[j]&gt;pivot，则swap(nums[j++], nums[i++])。否则，j++。这一遍历动作维持了指针的性质。最后遍历结束后后，可能有[2, 1, 3, pivot, pivot, pivot, 10,9,]，其中i=4。 代码：class Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int pos = -1; int s = 0, e = nums.size(); k = (int)nums.size() - k + 1; pos = sortPartVec(nums, s, e); while(1){ // cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; pos &lt;&lt; endl; if(pos + 1 == k) return nums[pos]; else if(pos + 1 &gt; k){ s = s; e = pos; pos = sortPartVec(nums, s, e); } else{ s = pos + 1; e = e; pos = sortPartVec(nums, s, e); } } } int sortPartVec(vector&lt;int&gt;&amp; nums, int s, int e){ int len = min((int)nums.size(), e - s); if(len == 1) return s; else if(len == 0) return -1; // if(nums[len / 2] &gt; nums[0]) swap(nums[0], nums[len / 2]); int l = s, r = e - 1, pivot = nums[s]; while(l &lt; r){ while(l &lt; r &amp;&amp; nums[r] &gt; pivot) r--; nums[l] = nums[r]; while(l &lt; r &amp;&amp; nums[l] &lt;= pivot) l++; nums[r] = nums[l]; } nums[r] = pivot; return r; } }; 建堆算法 class Solution { public: vector&lt;int&gt; heap; int maxlen; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { maxlen = k + 1; heap.push_back(1); for(int i = 0; i &lt; nums.size(); ++i) insert_heap(nums[i]); return heap[1]; } void upAdjust(int p, int len){ for(int x = p / 2; x &gt;= 1; x /= 2){ if(heap[x] &lt; heap[p]) break; swap(heap[x], heap[p]); p = x; } } void downAdjust(int p, int len){ for(int x = p * 2; x &lt; len; x += x){ if(x + 1 &lt; len) x = (heap[x] &lt; heap[x + 1]) ? x : x + 1; if(heap[x] &gt;= heap[p]) break; swap(heap[x], heap[p]); p = x; } } void insert_heap(int x){ int len = heap.size(); if(len == maxlen){ if(heap[1] &lt; x){ pop_heap(); len--; } else return; } heap.push_back(x); heap[len] = x; upAdjust(len, len + 1); } void pop_heap(){ int pos = 1, len = heap.size(); heap[1] = heap[len - 1]; len--; heap.pop_back(); downAdjust(1, len); } }; 利用STL模板 class Solution { public: priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { for(int i = 0; i &lt; nums.size(); ++i){ if(que.size() == k &amp;&amp; que.top() &lt; nums[i]){ que.pop(); que.push(nums[i]); } else if(que.size() &lt; k) que.push(nums[i]); } return que.top(); } }; class Solution { public: // 最优解 快速选择算法 int findth(vector&lt;int&gt;&amp; nums, int l, int r){ swap(nums[r], nums[rand() % (r - l + 1) + l]); int i, j; i = j = 0; while(j &lt;= r){ if(nums[j] &gt; nums[r]) ++j; else{ swap(nums[j++], nums[i++]); } } // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; nums[i - 1] &lt;&lt; endl;; return i - 1; //povit } int recurfindth(vector&lt;int&gt;&amp; nums, int l, int r, int k){ int th = findth(nums, l, r); int findk = nums.size() - th; if( k == findk) return nums[th]; else if(k &lt; findk) return recurfindth(nums, th + 1, r, k); else return recurfindth(nums, l, th - 1, k); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { return recurfindth(nums, 0, nums.size() - 1, k); } };","link":"/2020/11/14/shua-ti-pai-xu-215-kth-largest-element-in-an-array/"},{"title":"451. Sort Characters By Frequency","text":"451. Sort Characters By Frequency思路：统计每个字符出现的频率， 按频率排序或者建立堆获取最大值。 击败100 代码： class Solution { public: string frequencySort(string s) { int count[258] = {0}; int len = s.size(); for(int i = 0; i &lt; len ; ++i){ count[s[i]]++; } priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, less&lt;pair&lt;int, int&gt; &gt; &gt; pq; for(int i = 0; i &lt; 258; ++i){ if(count[i] != 0) pq.push( make_pair(count[i], i)); } string ans = &quot;&quot;; while(pq.size()){ pair&lt;int, int&gt; t = pq.top(); pq.pop(); int time = t.first; int ichar = t.second; string single(time, (char)ichar); ans += single; } return ans; } };","link":"/2020/11/16/shua-ti-pai-xu-451-sort-characters-by-frequency/"},{"title":"面试题51:逆序数","text":"这道题目还是比较神奇的。 题目：在一个数组中找出所有的逆序数。 逆序数就是指前一个数字大于后一个数组的一对数字。 思路：可以暴力查找，但是复杂度是O(N)O(N)。 想尝试用DP，但是没有明确的子问题分解界线。 最优算法是分治算法。将序列递归的一分为二，直到分割成长度为1的数组。在回朔地合并相邻的两个数组，同时统计序列的逆序数。在回朔的一个合并过程中，两个数组已经保持有序，也就是说数组内部的逆序数都不存在，只统计两个数组间的逆序数。 代码：int InversePairCore(int *A, int *copy, int start, int end){ // the the len of array should be looger than 1. // for example, the function will struggle with [0, 1]. // becaues start = 0, mid = 0, end = 1. Moreover the situtaion never change. if(start + 1 &gt;= end) return 0; int mid = (end + start) / 2; int leftCount = InversePairCore(A, copy, start, mid); int rightCount = InversePairCore(A, copy, mid, end); int midCount = 0; int p1 = mid - 1, p2 = end - 1, p3 = end - 1; while(p1 &gt;= start &amp;&amp; p2 &gt;= mid){ if(A[p1] &gt; A[p2]){ copy[p3] = A[p1]; p3--; p1--; midCount += p2 - mid + 1; } else{ copy[p3] = A[p2]; p3--; p2--; } } while(p1 &gt;= start){ copy[p3] = A[p1]; p3--; p1--; } while(p2 &gt;= mid){ copy[p3] = A[p2]; p3--; p2--; } for(int i = start; i &lt; end; i++) A[i] = copy[i]; return rightCount + midCount + leftCount; } int InversePair(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int *copy = new int(length); // for(int i = 0; i &lt; length; i++) copy[i] = A[i]; return InversePairCore(A, copy, 0, length); }","link":"/2020/08/07/shua-ti-pai-xu-mian-shi-ti-51-ni-xu-shu/"},{"title":"168. Excel Sheet Column Title","text":"168. Excel Sheet Column Title从进制的根源出发可以更彻底的探究算法的本源。26进制的的10进制数值计算如下：$$s = 26^3x_3 + 26^2x_2+ 26^1x_1 + 26^0x_0$$在该题目条件下，$A-Z$分别代表$1-26$，不符合上述计算公式。一般除数取余法直接除于进制值K，（在本题中$K=26$）即可获取低位$x_i$，但是由于零的缺失，$Z=26$的情况，如下公式，除数取余法失效了。 $$s / 26 = 26^2x_3 + 26^1x_2+ 26^0x_1 + 1, if\\ x_0 = 26$$修改的话，当我们发现当前位是 26 的时候，我们应该在等式两边减去一个 1 。就可以把$$s - 1 = 26^3x_3 + 26^2x_2+ 26^1x_1 + 26^0*(x_0 -1), if\\ x_0 = 26$$ 这样两边再同时除以 26 的时候，就可以把 x1 去掉了。 这种思路的代码： class Solution { public: string convertToTitle(int n) { string ans; while(n){ int c = n % 26; if(c == 0){ //更深层次 的说，我们从商借了一个1给余数！ c = 26; --n; } ans += c - 1 + 'A'; n /= 26; } reverse(ans.begin(), ans.end()); return ans; } }; 换一种想法，举个🌰有:$$\\begin{split}54 &amp;= 26 * 2 + 2 \\27 &amp;= 26 * 1 + 1\\end{split}$$54有个位数2，十位数2，分别对应B和B，27有个数为1，十位数1，分别对应A,A。所以有 class Solution { public: string convertToTitle(int n) { string ans; while(n){ // 注意这里为什么不是 ans = (n - 1) % 26 + 'A'， 而是让 n--; // 实际上经过取余过后，后续受影响的结果只有 n % 26 == 0的情况 // 也就是说 本质上 n-- 也是为了向商了借一个数字 n--; ans += n % 26 + 'A'; n /= 26; } reverse(ans.begin(), ans.end()); return ans; } }; 感觉好简单粗暴有效啊！","link":"/2021/01/12/shua-ti-shu-xue-168-excel-sheet-column-title/"},{"title":"169. Majority Element","text":"169. Majority Element思路：Boyer-Moore 投票算法 代码：class Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return -1; int a = nums[0]; int ct = 0; for(auto k : nums){ if(k == a){ ++ct; }else if(ct &gt; 0){ --ct; }else{ a = k; ++ct; } } return a; } }; 稍微简洁一点 class Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return -1; int a = nums[0]; int ct = 0; for(auto k : nums){ if(ct == 0){ a = k; } ct += k == a ? 1 : -1; } return a; } };","link":"/2021/01/15/shua-ti-shu-xue-169-majority-element/"},{"title":"172. Factorial Trailing Zeroes","text":"思路：通过判断1 ~n所有数字因子5的个数判断尾零的数量。快速判断方法是：整除 5， 25， 125等等5的倍数的数字其商就是5的倍数的因子数量。 代码：class Solution { public: int trailingZeroes(int n) { int res = 0; while(n){ n /= 5; res += n; } return res; } };","link":"/2021/01/07/shua-ti-shu-xue-172-factorial-trailing-zeroes/"},{"title":"202. Happy Number","text":"202. Happy Number思路： set查重复数字作为重复数字的抽取方法，循环遍历 假设该步骤总会找到一个数字环，快慢指针法可以类比到该算法。值得注意的，最后happy number最后形成是的数字1的自环，必定停留在1上。而非 happy number最后形成的环一定没有1。 代码：class Solution { public: bool isHappy(int n) { unordered_set&lt;int&gt; nums; //hashset更快 while(n != 1 &amp;&amp; nums.count(n) == 0){ int newn = n,sum = 0; while(newn){ sum += (newn % 10 ) * ( newn % 10 ); newn /= 10; } nums.insert(n); n = sum; } if(n == 1) return true; else return false; } }; 快慢指针法 class Solution { public: int next(int n){ int newn = n,sum = 0; while(newn){ sum += (newn % 10 ) * ( newn % 10 ); newn /= 10; } return sum; } bool isHappy(int n) { int p1 = next(n); int p2 = next(next(n)); while(p1 != p2){ p1 = next(p1); p2 = next(next(p2)); } if(p1 == 1) return true; else return false; } };","link":"/2021/01/15/shua-ti-shu-xue-202-happy-number/"},{"title":"204. Count Primes","text":"204. Count Primes思路： 埃氏筛 $O(nloglogn)$ 线性筛$O(nlogn)$，不过由于取模的运算量太大，速度可能还不如埃氏筛 代码：埃氏筛 class Solution { public: int countPrimes(int n) { if(n &lt;= 1) return 0; vector&lt;int&gt; prime(n + 10); int idx = 0; for(int i = 2; i &lt; n; ++i){ if(prime[i] == 0){ prime[idx++] = i; if(sqrt(INT_MAX) &gt; i) for(int j = i * i; j &lt;= n; j += i) prime[j] = 1; } } return idx; } }; 线性筛 class Solution { public: int countPrimes(int n) { if(n &lt;= 1) return 0; vector&lt;int&gt; prime(n + 10); int idx = 0; for(int i = 2; i &lt; n; ++i){ if(prime[i] == 0) prime[idx++] = i; for(int j = 0; j &lt; idx &amp;&amp; prime[j] * i &lt; n; ++j){ prime[prime[j] * i] = 1; if(i % prime[j] == 0) break; } } return idx; } };","link":"/2021/01/07/shua-ti-shu-xue-204-count-primes/"},{"title":"238. Product of Array Except Self","text":"238. Product of Array Except Self思路：follow up 要求空间为$O(n)$，如果输输出数组不算空间的话，可以这是可以达到的。 代码：class Solution { public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { getProduct(0, 1, nums); return nums; } using ll = long long; ll getProduct(int i, ll lprod, vector&lt;int&gt; &amp;nums){ if(i == nums.size()) return 1; ll nprod = lprod * nums[i]; ll rprod = getProduct(i + 1, nprod, nums); int val = nums[i]; nums[i] = lprod * rprod; return val * rprod; } };","link":"/2021/01/12/shua-ti-shu-xue-238-product-of-array-except-self/"},{"title":"313. Super Ugly Number","text":"313. Super Ugly Number思路丑数的每个前身都是丑数，丑上加丑。 代码class Solution { public: int findDuplicate(vector&lt;int&gt;&amp; nums) { // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2; int p1 = 0, p2 = 0; do{ p1 = nums[nums[p1]]; p2 = nums[p2]; }while(p1 != p2); p2 = 0; while(p1 != p2){ p1 = nums[p1]; p2 = nums[p2]; } return p1; // p1才是重复的数字/idx } };","link":"/2021/02/05/shua-ti-shu-xue-313-super-ugly-number/"},{"title":"382. Linked List Random Node","text":"382. Linked List Random Node思路：让我想起来之前来宁大讲座的美国教授的出的抽取车流题目。 我们可以使用蓄水池抽样算法（Reservoir Sampling）: 考虑抽取一个样例的情况：我们从头遍历一个List，并以$1/k$的概率把第k个元素保留下来。 可以由归纳法得： 第k-1个元素的保留概率是$1/(k - 1)$，在第K个元素遍历时，第K-1次遍历是被保留的元素在这次被保留的概率是$\\frac{1}{k-1} * \\frac{k - 1}{k}= \\frac{1}{k}$ 。 这就保证了遍历一遍全部数组后，各个元素被抽取的等概率性质。 再考虑k&gt;1的情况，证明更复杂一点： 实现代码： import java.util.Random; Class Solution{ public static void main(String[] args){ int[] nums = new int[]{1, 2, 3, 4, 5}; Solution s = new Solution(); int[] ans = s.sample(nums, 3); for(int i = 0; i &lt; ans.length; i++){ System.out.printf(&quot;%d &quot;, ans[i]); } } private int[] sample(int[] nums, int n){ Random rd = new Random(); int[] ans = new int[n]; for(int i = 0; i &lt; nums.length; i++){ if(i &lt; n){ ans[i] = nums[i]; } else { if(rd.nextInt(i+1) &lt; n){ ans[rd.nextInt(n)] = nums[i]; } } } return ans; } } 代码 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private: ListNode* head; int ct = 0; public: /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* _head): head(_head) { // newp = p = head; } /** Returns a random node's value. */ int getRandom() { //蓄水池随机抽取算法 ListNode *p = head, *newp = head; int ct = 0; while(newp){ ++ct; if(rand() % ct == 0){ p = newp; } newp = newp-&gt;next; } return p-&gt;val; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(head); * int param_1 = obj-&gt;getRandom(); */","link":"/2021/01/10/shua-ti-shu-xue-382-linked-list-random-node/"},{"title":"384. Shuffle an Array","text":"思路：Fisher-Yates shuffle洗牌算法：逐个遍历交换后续随机元素。 代码反洗算法 class Solution { vector&lt;int&gt; origin; public: Solution(vector&lt;int&gt;&amp; nums) :origin(nums) {} /** Resets the array to its original configuration and return it. */ vector&lt;int&gt; reset() { return origin; } /** Returns a random shuffling of the array. */ vector&lt;int&gt; shuffle() { vector&lt;int&gt; shuffled(origin); if(origin.size() == 0) return shuffled; for(int i = origin.size() - 1; i &gt;= 0; --i){ //还可以反着洗 swap(shuffled[i], shuffled[rand() % (i + 1)]); } return shuffled; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * vector&lt;int&gt; param_1 = obj-&gt;reset(); * vector&lt;int&gt; param_2 = obj-&gt;shuffle(); */","link":"/2021/01/09/shua-ti-shu-xue-384-shuffle-an-array/"},{"title":"415. Add Strings","text":"415. Add Strings思路：一般的大数相加，不过用高位补零的方法可以大大减少代码复杂度，方便编程。 思路：class Solution { public: string addStrings(string num1, string num2) { string ans; int add = 0; int i = num1.size() - 1, j = num2.size() - 1; //低位相加 while(i &gt;= 0 &amp;&amp; j &gt;= 0){ int sum = add + num1[i--] + num2[j--] - 2 * '0'; ans = to_string(sum % 10) + ans; add = sum / 10; } string c; //剩余高位 if(i &gt;= 0) c = num1.substr(0, i + 1); if(j &gt;= 0) c = num2.substr(0, j + 1); string num3; // 高位与add相加 if(add){ int k = c.size() - 1; while(k &gt;= 0){ int sum = add + c[k--] - '0'; num3 = to_string(sum % 10) + num3;//重建一个string太耗时间了 add = sum / 10; } if(add) num3 = to_string(add) + num3; }else num3 = c; return num3 + ans; } }; 优化一下 class Solution { public: string addStrings(string num1, string num2) { string ans; int add = 0; int i = num1.size() - 1, j = num2.size() - 1; while(i &gt;= 0 || j &gt;= 0){ int a1 = i &gt;= 0 ? num1[i--] - '0' : 0; int a2 = j &gt;= 0 ? num2[j--] - '0' : 0; int sum = add + a1 + a2; ans = to_string(sum % 10) + ans; add = sum / 10; } return (add == 0 ? &quot;&quot; : &quot;1&quot;) + ans; } };","link":"/2021/01/07/shua-ti-shu-xue-415-add-strings/"},{"title":"462. Minimum Moves to Equal Array Elements II","text":"462. Minimum Moves to Equal Array Elements II 第K大思路： 第一次做，看看数据的形式似乎具有凹函数的性质，于是用三分法搜索数值。菜鸡如我，没有总结过三分，有些地方写错了，wa了一次，int超范围了一次。这题好坏啊。算法复杂度$o(nlogn)$。 还有一种思路是排序后，依照凹函数性质二分搜索也可以！复杂度$o(nlogn + nlogn)$ ，还是我快，不过我的n不是他的n。 看题解，发现寻找中位数的方法，更好更容易证明， 可以发现，奇数个数组的中位数容易的，如果在偶数个数字的数组中，中位数公式：$$mid_element = \\frac{Arr[size / 2] + Arr[size / 2 + 1]}{2}$$幸运的是，在该题意下，直接使用$Arr[size / 2]$的计算值和使用$min_element$效果一致。题意可以化简。 上题的代码，还可是使用第$k$大数字题目使用的算法来求解。 代码：1 class Solution { public: using ll = long long; //这题太坏了 ll gap(vector&lt;int&gt; &amp; nums, ll g){ ll res = 0; for(auto k : nums){ res += abs(k - g); } return res; } ll minMoves2(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int maxv = *max_element(nums.begin(), nums.end()); int minv = *min_element(nums.begin(), nums.end()); while(minv &lt; maxv){ int mid1 = (maxv - minv) / 3 + minv; int mid2 = (maxv - minv) * 2 / 3 + minv; if(mid1 == mid2) ++mid2; //[minv, maxv] = [0, 1] ll r1 =gap(nums, mid1), r2 = gap(nums, mid2); if(r1 &gt; r2){ minv = mid1 + 1; }else if(r2 &gt; r1){ maxv = mid2 - 1; }else{ if(mid1 == mid2){ minv = maxv = mid1; break; } minv = mid1 + 1; maxv = mid2 - 1; } // cout &lt;&lt; minv &lt;&lt; ' ' &lt;&lt; maxv &lt;&lt; endl; } return gap(nums, minv); } }; 2 class Solution { public: int minMoves2(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int l=0,r=nums.size()-1,mid; while(l&lt;r){ mid=(l+r)&gt;&gt;1; if(sumof(nums[mid],nums)&lt;sumof(nums[mid]+1,nums)) r=mid; //利用了凹函数的特性 else l=mid+1; } return sumof(nums[l],nums); } long sumof(int n,vector&lt;int&gt;&amp; nums){ long sum=0; for(int i=0;i&lt;nums.size();i++){ sum+=abs(nums[i]-n); } return sum; } }; 3 class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ sort(nums.begin(), nums.end()); ll sum = 0; for(auto k : nums){ sum+=abs(k - nums[nums.size() / 2]); } return sum; } }; 4 class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());//偷懒 ll sum = 0; for(auto k : nums){ sum+=abs(k - nums[nums.size() / 2]); } return sum; } }; 我的实现：效率巨低 class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ my_nth_element(nums, 0, nums.size(), nums.size() / 2); ll sum = 0; for(auto k : nums){ sum+= abs(k - nums[nums.size() / 2]); } return sum; } int partition(vector&lt;int&gt; &amp;nums, int s, int e){ int l = s, r = e - 1, temp = nums[s]; while(l &lt; r){ while(l &lt; r &amp;&amp; nums[r] &gt;= temp) --r; swap(nums[r], nums[l]); while(l &lt; r &amp;&amp; nums[l] &lt;= temp) ++l; swap(nums[r], nums[l]); } // nums[l] = temp; return l; } void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k){ if(s == e) return; int idx = partition(nums, s, e); if(idx == k) return; else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k); else my_nth_element(nums, s, idx, k); // bugs, e 是边界， 所以不能取 s - 1 } }; 第K大算法中另一种patition算法。 class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ my_nth_element(nums, 0, nums.size(), nums.size() / 2); ll sum = 0; for(auto k : nums){ sum+= abs(k - nums[nums.size() / 2]); } return sum; } // int partition(vector&lt;int&gt; &amp;nums, int s, int e){ // int l = s, r = e - 1, temp = nums[s]; // while(l &lt; r){ // while(l &lt; r &amp;&amp; nums[r] &gt;= temp) --r; // swap(nums[r], nums[l]); // while(l &lt; r &amp;&amp; nums[l] &lt;= temp) ++l; // swap(nums[r], nums[l]); // } // // nums[l] = temp; // return l; // } // 该算法基于一种朴素的想法：把小的前面，大的放后面 int partition(vector&lt;int&gt; &amp;nums, int s, int e){ int i = s, pivot = nums[e - 1]; for(int j = s; j &lt; e; ++j){ if(nums[j] &lt; pivot){ swap(nums[i], nums[j]); ++i; } } swap(nums[i], nums[e - 1]); return i; } void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k){ if(s == e) return; int idx = partition(nums, s, e); if(idx == k) return; else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k); else my_nth_element(nums, s, idx, k); // bugs, e 是边界， 所以不能取 s - 1 } };","link":"/2021/01/14/shua-ti-shu-xue-462-minimum-moves-to-equal-array-elements-ii/"},{"title":"470. Implement Rand10() Using Rand7()","text":"470. Implement Rand10() Using Rand7()思路：利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等 代码：第一次wa是因没有考虑取余后映射的数字的生成概率不等了。 // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 class Solution { public: //利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等 int rand10() { int c; do{ int a = rand7()- 1; int b = rand7() - 1; c = a * 7 + b; }while(c &gt;= 40); return c % 10 + 1; } };","link":"/2021/01/15/shua-ti-shu-xue-470-implement-rand10-using-rand7/"},{"title":"504. Base 7","text":"504. Base 7思路：利用取余和求模获取各个位的数值，要注意零，正负符号，数字大小（可能会溢出）等条件。 代码：class Solution { public: string convertToBase7(int num) { if(num == 0) return &quot;0&quot;; string res , flag; if( num &lt; 0){ flag = &quot;-&quot;; num = -num; } while(num){ int w = num % 7; num = num / 7; res = char('0' + w) + res; //这里的强制类型转换是必要的 } return flag + res; } };","link":"/2021/01/07/shua-ti-shu-xue-504-base-7/"},{"title":"528. Random Pick with Weight","text":"528. Random Pick with Weight思路：通过前缀和映射权重到数组，方便通过二分查找进行随机抽取。 代码：class Solution { vector&lt;int&gt; w; int n; int mod; public: Solution(vector&lt;int&gt;&amp; _w) : w(_w) { int sum = 0; for(auto &amp;i : w){ sum += i; i = sum; } mod = sum; n = w.size(); } int pickIndex() { int s = rand() % mod; // 在[0, sum) 随机抽取一个数，作为映射下标 auto it = lower_bound(w.begin(), w.end(), s); // find the first iterator that this element is not less the value; value &lt;= (*it) if(*it == s) it++; return it - w.begin(); } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-&gt;pickIndex(); */ 手写二分 class Solution { vector&lt;int&gt; w; int n; int mod; public: Solution(vector&lt;int&gt;&amp; _w) : w(_w) { int sum = 0; for(auto &amp;i : w){ sum += i; i = sum; } mod = sum; n = w.size(); } int pickIndex() { int s = rand() % mod; // 在[0, sum) 随机抽取一个数，作为映射下标 int l = 0, r = n - 1; while(l &lt; r){ int mid = (r - l) / 2 + l; if(w[mid] &lt;= s) l = mid + 1; else r = mid; } return r; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-&gt;pickIndex(); */","link":"/2021/01/10/shua-ti-shu-xue-528-random-pick-with-weight/"},{"title":"67. Add Binary","text":"67. Add Binary 代码：class Solution { public: string addBinary(string a, string b) { if(a == &quot;&quot; || b == &quot;&quot;) return a == &quot;&quot; ? b : a; int i = a.size() - 1, j = b.size() - 1, add = 0; string ans = &quot;&quot;; while(i &gt;= 0 || j &gt;= 0){ int numa = i &lt; 0 ? 0 : a[i] - '0'; int numb = j &lt; 0 ? 0 : b[j] - '0'; --i, --j; int sum = numa + numb + add; add = sum / 2; sum %= 2; ans.push_back(sum + '0'); } if(add){ ans.push_back(add + '0'); } reverse(ans.begin(), ans.end()); return ans; } };","link":"/2021/01/12/shua-ti-shu-xue-67-add-binary/"},{"title":"972.Equal Rational Numbers","text":"972. Equal Rational Numbers思路不止一种，老老实实敲敲代码但不想优化方法的人是没有前途的。 思路：第一种：按字符匹配模式分类讨论 两个字符串都没有重复字符串：直接去尾零比较相等值。 只有一个字符串有重复字符串：只有一种情况可以相等，就是题目中无限接近的情况，比如“0.9(9)==1.0”。当然可以用数学证明的，两者相等。用语言描述比较麻烦，意会吧。 两个字符串都有重复字符串：将重复字符串展开多次，尽可能比较相同长度内容即可。 第二种：化为数值法！ 重复模式串的数值部分可以计算,比如：$$0.00(66)=\\frac{1}{100} + \\frac{66}{100} + \\frac{66}{10000}\\cdots$$那么一般就有$$0.(s) = \\frac{s}{10^k }+ \\frac{s}{10^{2k} \\cdots} \\\\= s*(\\frac{1}{10^k} + \\frac{1}{10^{2k}} \\cdots)\\\\= s * (limt_{ \\ n\\rightarrow\\infty}\\frac{\\frac{1}{10^k}-\\frac{1}{(10^k)^n}}{1-\\frac{1}{10^k}})\\\\= s * \\frac{\\frac{1}{10^k}}{1-\\frac{1}{10^k}}\\\\which\\ k \\ is \\ the\\ len\\ of\\ s.$$非重复部分更容易计算。 那么之后用分数类来计算结果即可。 代码：老实人代码 class Solution { public: // if find() cant find the char or string, it will retunr str::string::npos; // static const size_t npos = -1; the size_t is unsigned int type. void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS){ int pointPos = input.find(&quot;.&quot;); if(pointPos != string::npos) integerS = input.substr(0, pointPos); else{ integerS = input; nonreS = reS = &quot;&quot;; return; } int parPos = input.find(&quot;(&quot;); if(parPos != string::npos){ nonreS = input.substr(pointPos + 1, parPos - pointPos - 1); reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1); }else{ nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1); reS = &quot;&quot;; } if( reS == &quot;&quot; || stol(reS) == 0){ reS = &quot;&quot;; int pos = nonreS.size() - 1; while(pos &gt;= 0 &amp;&amp; nonreS[pos] == '0') pos--; if(pos &gt;= 0) nonreS = nonreS.substr(0, pos + 1); else nonreS = &quot;&quot;; if(integerS == &quot;&quot; || stol(integerS) == 0) integerS = &quot;0&quot;; } } bool isNineNum(string S){ for(int i = 0; i &lt; S.size(); i++) { if(S[i] != '9') return false; } return true; } string strmul(string s, int time){ string res = &quot;&quot;; for(int i = 0; i &lt; time; i++){ res += s; } return res; } //must comfire reS2 == &quot;&quot; bool isfiniteEqual(string integerS1, string nonreS1, string reS1, string integerS2, string nonreS2, string reS2){ if(!isNineNum(reS1) || reS2.size() != 0) return false; int pos = nonreS1.size() - 1; for(;pos &gt;= 0; pos --){ if(nonreS1[pos] != '9') break; } if(nonreS2.size() != pos + 1) return false; int num1 = stol(integerS1 + nonreS1.substr(0, pos + 1)); int num2 = stol(integerS2 + nonreS2); if(num1 + 1 != num2) return false; return true; } bool ispartEqual(string s1, string s2){ // cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2 &lt;&lt; endl; if(s1.size() &gt; s2.size()) return false; if(s2.substr(0, s1.size()) == s1) return true; return false; } bool isRationalEqual(string S, string T) { string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2; getNum(S, integerS1, nonreS1, reS1); getNum(T, integerS2, nonreS2, reS2); if(reS1.size() == 0 &amp;&amp; reS2.size() == 0){ if(integerS1 == integerS2 &amp;&amp; nonreS1 == nonreS2) return true; } else if(reS1.size() == 0 || reS2.size() == 0){ if(isfiniteEqual(integerS1, nonreS1, reS1, integerS2, nonreS2, reS2) || isfiniteEqual(integerS2, nonreS2, reS2, integerS1, nonreS1, reS1)) return true; } else{ int l1 = reS1.size(), l2= reS2.size(); string str1 = integerS1 + nonreS1 + strmul(reS1, reS2.size() + 2); string str2 = integerS2 + nonreS2 + strmul(reS2, reS1.size() + 2); if(ispartEqual(str1, str2) || ispartEqual(str2, str1)) return true; } return false; } }; 数值计算 弱鸡的代码 typedef long long ll; class fraction{ public: ll n, d; fraction(ll _n, ll _d){ n = _n; d = _d; if(_d == 0) d = 1; } void add(fraction s){ n = n * s.d + d * s.n; d *= s.d; clear(); print(fraction(n, d)); print(s); } bool equal(fraction s){ if(s.d == d &amp;&amp; s.n == n) return true; return false; } private: ll gcd(ll a, ll b){ return b?gcd(b, a%b):a; } void clear(){ int gcdN = 1; if(n == 0) gcdN = 1; else gcdN = gcd(d , n); n /= gcdN; d /= gcdN; if(n == 0) d = 1; } }; // class Solution { public: void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS){ int pointPos = input.find(&quot;.&quot;); if(pointPos != string::npos) integerS = input.substr(0, pointPos); else{ integerS = input; nonreS = reS = &quot;&quot;; return; } int parPos = input.find(&quot;(&quot;); if(parPos != string::npos){ nonreS = input.substr(pointPos + 1, parPos - pointPos - 1); reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1); }else{ nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1); reS = &quot;&quot;; } } ll pow10(ll l){ ll ans = 1; while(l &gt; 0){ ans *= 10; l--; } return ans; } ll mystol(string s){ if(s == &quot;&quot;) return 0; else return stol(s); } fraction getFraction(string integer, string nonreS, string reS){ fraction no1 = fraction(mystol(integer), 1); int nonreLen = nonreS.size(); int reLen = reS.size(); fraction no2 = fraction(mystol(nonreS), pow10(nonreLen)); fraction no3 = fraction(mystol(reS), pow10(nonreLen) * (pow10(reLen) - 1) ); no1.add(no2); no1.add(no3); return no1; } bool isRationalEqual(string S, string T) { string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2; getNum(S, integerS1, nonreS1, reS1); getNum(T, integerS2, nonreS2, reS2); fraction frac1 = getFraction(integerS1, nonreS1, reS1); fraction frac2 = getFraction(integerS2, nonreS2, reS2); if(frac1.equal(frac2)) return true; return false; } };","link":"/2020/09/21/shua-ti-shu-xue-972-equal-rational-numbers/"},{"title":"错排问题:年会抽奖","text":"所谓错排问题就是N个1~N数字的序列都恰好不在对应位上，比如序列3 1 2 。 题目：年会抽奖今年公司年会的奖品特别给力，但获奖的规矩却很奇葩： 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中； 待所有字条加入完毕，每人从箱中取一个字条； 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？ 思路首先所有数字可能的排列顺序为$n!$，我们只需要求出所有可能出现的错排书就行。 采用排除法，记$a_i$是$i$个数字错排的数量， 通过并集计算公式，排除掉$k, 1 &lt;= k &lt;= n $个数字排列正确排列的所有情况$$P(A) = n! - n * a_{n -1} + n * (n -1) /2 * a_{n-2} …. \\\\= n! - n * (n - 1)! + \\frac{n!}{2!} - \\frac{n!}{3!} ….=\\frac{n!}{2!} - \\frac{n!}{3!} ….= \\sum_{k=2}^{n}{(-1)^k} \\frac{n!}{k!}$$上式中，1个数字排列正确的序列保护了2个数列排列正确的情况，2个数字排列正确的序列保护了3个数列排列正确的情况，所以可以使用并集公式。 换一种想法： 可以观察到，错排的序列3 4 1 2有位置对换的数字2和4，如果固定这两个数字，剩下的数字进行错排有3 1。可以观察到序列数量减少了，不由有递推的味道。 那如果最后一个数字没有与位置对换呢？如2 3 4 1 ，为了同样获取n-1个可以错排的数据（数据和坑位可以一一对应），把4排除去，我们可以把第四个数字看成被4占据的第三位，构成了2 3 1。 公式化一下： 由题意a1=0，a2=1，当n≥3时，在错排中n必不在第n位，设n放在第k位上（1≤k≤n-1），则第n位上有两种可能： （1）如果第n位上不是k，那么把第n位看作第k位，将n以外的n－1个数进行错排，错排个数是an-1； （2）如果第n位上是k，那么除n和k以外的n－2个数的错排是an-2， 所以n在第k位上的错排数共有an-1＋an-2，由于k可取1、2、3、4、……、n－1共 n -1 种取法，所以n个数的错排个数。 所以有递推公式：an= (n - 1)(an-1 + an-2)。","link":"/2021/03/10/shua-ti-shu-xue-cuo-pai-wen-ti-nian-hui-chou-jiang/"},{"title":"面16-数值的N次方","text":"题面：给一个浮点数，求出其数值的整数次方。 思路：主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。 代码：int power(double base, int exponent){ //无穷大的非法计算值 if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); unsigned int posExponent = (unsigned int)exponent; double mulBase = base, mulRes = 1; while(posExponent &gt; 0){ if(posExponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; posExponent = posExponent &gt;&gt; 1; } if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; } 可能降低耦合更好一点 double PowerWithUnsighedExponent(double base, unsigned int exponent){ //特判：基数为0；指数为0无需特判 if( equla(base, 0.0)) return 0.0; double mulRes = 1; while(exponent &gt; 0){ if(exponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; exponent = exponent &gt;&gt; 1; } return mulRes; } int power(double base, int exponent){ //无穷大的非法计算值 if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); double mulRes = PowerWithUnsignedExponent(base, exponent); if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; }","link":"/2020/08/07/shua-ti-shu-xue-mian-16-shu-zhi-de-n-ci-fang/"},{"title":"面试题 16.05. Factorial Zeros LCCI","text":"面试题 16.05. Factorial Zeros LCCI 思路：尾零个数等于所有相乘数字的5的质因子个数，比如$f(11)= 1 + 1$ 关于快速求出：可以使用整除5，25，125……$5^k$的思路求出。 代码：class Solution { public: int trailingZeroes(int n) { int numof5 = 0; while(n &gt;= 5){ n /= 5; numof5 += n; } return numof5; } };","link":"/2020/09/24/shua-ti-shu-xue-mian-shi-ti-16-05-factorial-zeros-lcci/"},{"title":"面试题-大数","text":"大数相关 面17：打印从1到最大的n位数题目：如题 思路1：明显的太简单了。坑还是在数据范围上，考虑使用大数加法模拟计算。 思路2：也可以使用全排列的思路，思考除了开头为0的n个0~9数字的排列组合就是题目所要求的的数据。 代码：大数 #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; bool isIncreaseDigit(int *numbers, char* n){ for(int i = 0; n[i] != '\\0'; i++) if(numbers[i] != n[i] - '0') return true; return false; } void PrintNumber(int *numbers, int MAXLEN){ int idx = MAXLEN - 1; while(idx &gt;= 0 &amp;&amp; numbers[idx] == 0) idx --; for(int i = idx; i &gt;= 0; --i) putchar(numbers[i] + '0'); putchar('\\n'); } void Print1ToMaxDigits(char *n){ const int MAXLEN = 1000; if(n == nullptr || strlen(n) &lt;= 0 || strlen(n) &gt;= MAXLEN) return; char test0[2] = &quot;0&quot;; if(strcmp(test0, n) == 0){ printf(&quot;0\\n&quot;); return; } //reverse the input string char *newN = new char(MAXLEN); int lenN = strlen(n); for(int i = 0; i &lt; lenN; i++) newN[lenN - i - 1] = n[i]; //big data. int *numbers = new int[MAXLEN]; memset(numbers, 0, sizeof(numbers)); //Calculate the numbers. while(isIncreaseDigit(numbers, newN)){ numbers[0]++; int idx = 0; while(numbers[idx] == 10){ numbers[idx] = 0; ++idx; numbers[idx]++; } PrintNumber(numbers, MAXLEN); } delete []numbers; } int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); char a[5] = {&quot;1239&quot;}; Print1ToMaxDigits(a); } 全排列组合 #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; bool isIncreaseDigit(int *numbers, char* n){ for(int i = 0; n[i] != '\\0'; i++) if(numbers[i] != n[i] - '0') return true; return false; } void PrintNumber(int *numbers, int MAXLEN){ int idx = MAXLEN - 1; //不输出前置零和全零 while(idx &gt;= 0 &amp;&amp; numbers[idx] == 0) idx --; if(idx == -1) return; for(int i = idx; i &gt;= 0; --i) putchar(numbers[i] + '0'); putchar('\\n'); } void Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &amp;flag){ if(flag) return; if(pos == -1) { //直接用flag剪枝 if(!isIncreaseDigit(numbers, newN)) flag = 1; PrintNumber(numbers, lenOfN); return; } if(!isIncreaseDigit(numbers, newN)) return; for(int i = 0; i &lt;= 9; i++){ numbers[pos] = i; Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag); } } void Print1ToMaxDigits(char *n){ if(n == nullptr || strlen(n) &lt;= 0) return; char test0[2] = &quot;0&quot;; if(strcmp(test0, n) == 0){ printf(&quot;0\\n&quot;); return; } //reverse the input string int lenOfN = strlen(n); char *newN = new char(lenOfN); for(int i = 0; i &lt; lenOfN; i++) newN[lenOfN - i - 1] = n[i]; newN[lenOfN] = '\\0'; //big data. int *numbers = new int[lenOfN]; memset(numbers, 0, sizeof(numbers)); //Calculate the numbers. int flag = 0; Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag); delete []numbers; } int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); // char a[5] = {&quot;1239&quot;}; // char a[5] = {&quot;0&quot;}; char a[50] = {&quot;100&quot;}; Print1ToMaxDigits(a); // int t1[5] = {1, 2}; // printf(&quot;%d&quot;, isIncreaseDigit(t1, a)); } 把自己写懵逼了，调试了好久，原来发现自己剪枝错了。 由于判断条件在变化，而剪枝条件是不变的，所以不能在更变条件后剪枝","link":"/2020/08/07/shua-ti-shu-xue-mian-shi-ti-da-shu/"},{"title":"面试题-建模","text":"收集抽象建模题目。 面60：n个骰子的点数题面：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 思路：第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。 代码：class Solution { public: int maxGV = 6; void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS){ if(currentN == 0){ prob[addS - originN]++; return; } for(int i = 1; i &lt;= maxGV; i++) calProb(prob, originN, currentN - 1, addS + i); } vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); vector&lt;int&gt; prob(n * maxGV - n + 1, 0); calProb(prob, n, n, 0); double allProb = pow(maxGV, n); vector&lt;double&gt; res(n * maxGV - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[i] / allProb; return res; } }; class Solution { public: int maxGV = 6; vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); int addLen = n * maxGV; vector&lt;int&gt;prob[2]; for(int i = 0; i &lt; 2; i++){ prob[i].resize(addLen); for(int j = 0; j &lt; addLen; j++) prob[i][j] = 0; } int calIdx = 0; for(int i = 0; i &lt; maxGV; i++) prob[1 - calIdx][i] = 1; for(int i = 0; i &lt; n - 1; i++){ for(int k = 0; k &lt; addLen; k++){ prob[calIdx][k] = 0; for(int j = max(0, k - maxGV); j &lt; k; j++){ prob[calIdx][k] += prob[1 - calIdx][j]; } } calIdx = 1 - calIdx; } double allProb = pow(maxGV, n); vector&lt;double&gt; res(addLen - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[1 - calIdx][i + n -1 ] / allProb; return res; } }; 面61：约瑟夫环这题老朋友了。 题面：0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 来源：力扣（LeetCode） 思路：数学+ 迭代。 求出n个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。 将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。 而且有$f(0,m) = 0$，可以快速用迭代计算出来。 代码： class Solution { public: int lastRemaining(int n, int m) { int res = 0; for(int i = 1;i &lt;= n; i++){ res = (res + m) % i; } return res; } };","link":"/2020/08/11/shua-ti-shu-xue-mian-shi-ti-jian-mo/"},{"title":"面试题44：1出现的个数","text":"广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理 题目：统计从1到N的所有数字的1的出现次数。 思路：第一种：所有人都能想出直接暴力解的算法。 第二种：参考其他人的解法。 设N = abcde ,其中abcde分别为十进制中各位上的数字。如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100199，11001199,21002199，，…，1110011199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100199，11001199,21002199，，….，1110011199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：1210012113,一共114个，等于低位数字（113）+1。③ 如果百位上数字大于1（29），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100199,11001199，21002199，…，1110011199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。——参考牛客网@藍裙子的百合魂 代码：int CounterOf1(int x){ if(x &lt;= 0) return 0; int len = 0, tempX = x, judugNum = 1; while(tempX){ tempX = tempX / 10; len ++; } int power = 10, counter = 0 ; for(int i = 0; i &lt; len; i++){ int liPower = power / 10; int num = x % power / liPower; if(num &gt; judugNum ){ counter += (x / power + 1) * liPower; }else if(num == judugNum ){ counter += (x / power) * liPower + x % liPower + 1; }else counter += x / power * liPower; power *= 10; } return counter; } 测试可见 牛客","link":"/2020/08/07/shua-ti-shu-xue-mian-shi-ti-44-1-chu-xian-de-ge-shu/"},{"title":"面试题49：丑数","text":"","link":"/2020/08/07/shua-ti-shu-xue-mian-shi-ti-49-chou-shu/"},{"title":"146. LRU Cache","text":"思路：LRU实现中”删除最近最少使用的数据值“表达可能会让人产生误解，更准确的意思是”删除最长时间未使用的数据值“。 硬件的实现可以用每次更新和添加元素A，累加除A之外的所有元素的计数值。 代码：class LRUCache { public: // 软件实现LRU毕竟和硬件不同，需要考虑元素的放置和组成位置； // hash + 双向链表的结构组成能够在O(1)的速度下获取元素位置 // 双向链表的支持保证了删除和在首位添加元素的速度也在O(1) using pairii = pair&lt;int,int&gt;; list&lt;pairii&gt; content; unordered_map&lt;int, list&lt;pairii&gt;::iterator&gt; hash; int capacity; LRUCache(int _capacity) : capacity(_capacity) { //如果手写 list 添加 虚拟头尾节点更佳 } int get(int key) { if(hash.find(key) == hash.end()){ return -1; } // 如果能够声明一个属于友元的 list 直接对指针进行操作 效率会更好 pairii node = *hash[key]; //慎用 删除后的iterator content.erase(hash[key]); content.emplace_front(node); hash[key] = content.begin(); return node.second; } void put(int key, int value) { pairii node{key, value}; if(hash.find(key) != hash.end()){ // 没有找到对应的value content.erase(hash[key]); }else if(content.size() == capacity){ // cache容量已满, 删除最长时间未使用的数据值 hash.erase(content.back().first); content.pop_back(); // } content.emplace_front(node); hash[key] = content.begin(); } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","link":"/2021/02/27/shua-ti-mo-ni-146-lru-cache/"},{"title":"面5：合并数组","text":"题目将一个字符串在不新建字符串的基础上将源字符串的空格替换为%20。输入字符串和总空间长度。 思路明显就是遍历一次统计空格，计算出多余的字符数，并从后向前复制字符并替换字符。 样例# # 代码void replaceBlank(char str[], int length){ int len = 0, addLen = 0; for(int i = 0; str[i] != '\\0'; i++){ if(str[i] == ' ') addlen + = 2; len ++; } int endP1 = len - 1, endP2 = len + addLen - 1; if(endP2 &gt;= length) return; for(; endP1 != endP2; endP1--, endP2-- ) if(str[endP1] == ' '){ str[endP2] = '0'; str[endP2 - 1] = '2'; str[endP2 - 2] = '0' endP2 -= 2; }else str[endP2] = str[endP1]; } return; } 相关题目比如说将一个以排序的数组插入到另一个已排序的数组，并保持有序。同样从尾部插入更快。 思维再发散一下就有归并排序中的两个数组的合并问题，不过此时是创建一个辅助数组 。","link":"/2020/08/07/shua-ti-mo-ni-mian-5-he-bing-shu-zu/"},{"title":"面试 模拟题","text":"收集一些模拟题。 面29：打印矩阵题面：给出一个N*M的矩阵，按照从里到外的顺序顺时针打印矩阵。 思路：（代码一）模拟题就是硬上。由于整个打印过程可以看成一圈圈的打印，所以按圈地打印。同时为了保持打印动作的一致行，都是打印一行或者一列差一个单元矩阵。 不考虑上面的一致性，直接考虑填涂条件的话，也就复杂一点点。 代码：一种可以优美的实现N*N的正方形矩阵填充的代码。 #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; void printNumberRect(int n, int m){ vector&lt;vector&lt;int&gt; &gt; rect; rect.resize(n); for(int i = 0; i &lt; rect.size(); i++) rect[i].resize(m); int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1; int counter = 1; while(xLeftUp &lt;= xRightDown &amp;&amp; yLeftUp &lt;= yRightDown){ for(; y &lt; yRightDown; y++){ rect[x][y] = counter; counter++; } for(; x &lt; xRightDown; x++){ rect[x][y] = counter; counter++; } for(; y &gt; yLeftUp; y--){ rect[x][y] = counter; counter++; } for(; x &gt; xLeftUp; x--){ rect[x][y] = counter; counter++; } x++; y++; xLeftUp++; yLeftUp++; xRightDown--; yRightDown--; } if(xLeftUp == xRightDown + 2 &amp;&amp; yLeftUp == yRightDown + 2 ) rect[x - 1][y - 1] = counter; for(int i = 0; i &lt; rect.size(); i++){ for(int j = 0; j &lt; rect[i].size(); j++) printf(&quot;%d &quot;, rect[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;); } int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); printNumberRect(0, 0); printNumberRect(2, 3); printNumberRect(6, 3); printNumberRect(3, 3); } 就直接填写。 void printNumberRect(int n, int m){ vector&lt;vector&lt;int&gt; &gt; rect; rect.resize(n); for(int i = 0; i &lt; rect.size(); i++) rect[i].resize(m); int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1; int counter = 1; while(xLeftUp &lt;= xRightDown &amp;&amp; yLeftUp &lt;= yRightDown){ for(; y &lt;= yRightDown; y++){ rect[x][y] = counter; counter++; } for(x++, y--; x &lt;= xRightDown; x++){ rect[x][y] = counter; counter++; } //横着画可能会重叠 for(x--, y--; y &gt;= yLeftUp &amp;&amp; x &gt; xLeftUp; y--){ rect[x][y] = counter; counter++; } //同上 for(y++, x--; x &gt; xLeftUp &amp;&amp; y &lt; yRightDown; x--){ rect[x][y] = counter; counter++; } x++; y++; xLeftUp++; yLeftUp++; xRightDown--; yRightDown--; } for(int i = 0; i &lt; rect.size(); i++){ for(int j = 0; j &lt; rect[i].size(); j++) printf(&quot;%d &quot;, rect[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;); }","link":"/2020/08/07/shua-ti-mo-ni-mian-shi-mo-ni-ti/"},{"title":"面试题-建模","text":"收集抽象建模题目。 面60：n个骰子的点数题面：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 思路：第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。 代码：class Solution { public: int maxGV = 6; void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS){ if(currentN == 0){ prob[addS - originN]++; return; } for(int i = 1; i &lt;= maxGV; i++) calProb(prob, originN, currentN - 1, addS + i); } vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); vector&lt;int&gt; prob(n * maxGV - n + 1, 0); calProb(prob, n, n, 0); double allProb = pow(maxGV, n); vector&lt;double&gt; res(n * maxGV - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[i] / allProb; return res; } }; class Solution { public: int maxGV = 6; vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); int addLen = n * maxGV; vector&lt;int&gt;prob[2]; for(int i = 0; i &lt; 2; i++){ prob[i].resize(addLen); for(int j = 0; j &lt; addLen; j++) prob[i][j] = 0; } int calIdx = 0; for(int i = 0; i &lt; maxGV; i++) prob[1 - calIdx][i] = 1; for(int i = 0; i &lt; n - 1; i++){ for(int k = 0; k &lt; addLen; k++){ prob[calIdx][k] = 0; for(int j = max(0, k - maxGV); j &lt; k; j++){ prob[calIdx][k] += prob[1 - calIdx][j]; } } calIdx = 1 - calIdx; } double allProb = pow(maxGV, n); vector&lt;double&gt; res(addLen - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[1 - calIdx][i + n -1 ] / allProb; return res; } }; 面61：约瑟夫环这题老朋友了。 题面：0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 来源：力扣（LeetCode） 思路：数学+ 迭代。 求出n个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。 将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。 而且有$f(0,m) = 0$，可以快速用迭代计算出来。 代码： class Solution { public: int lastRemaining(int n, int m) { int res = 0; for(int i = 1;i &lt;= n; i++){ res = (res + m) % i; } return res; } };","link":"/2020/08/11/shua-ti-mo-ni-mian-shi-ti-jian-mo/"},{"title":"435. Non-overlapping Intervals","text":"还是蛮经典的题，想了想就出来了。 思路：求出最少舍弃的区间，换一个角度就是留下更多的区间。为了留下的区间最多，直观上来看最好是区间长度小，起点和终点都小的区间。 通过仔细的思考，只有终点最小才能满足区间尽可能留下的条件。 代码： bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ if(a[1] == b[1]) return a[0] &lt; b[0]; else return a[1] &lt; b[1]; } class Solution { public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { // bool (Solution::*cmpabc)(vertor&lt;int&gt;, vertor&lt;int&gt;); // cmpabc = &amp;Solution::cmpab; int n = intervals.size(); // for(int i = 0; i &lt; n; i++) // intervals[i].push_back(intervals[i][1] - intervals[i][0]); sort(intervals.begin(), intervals.end(), cmp); int add = 0, start = -0x7fffffff; for(int i = 0; i &lt; n; ++i){ if(start &lt;= intervals[i][0]){ add++; start = intervals[i][1]; } } return n - add; } }; sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){return a[1] &lt; b[1];});最后的sort可以用匿名函数写写。","link":"/2020/10/12/shua-ti-tan-xin-435-non-overlapping-intervals/"},{"title":"452. Minimum Number of Arrows to Burst Balloons","text":"452. Minimum Number of Arrows to Burst Balloons类似于leetcode435贪心题 思路：用贪心的策略尽可能的射击气球末尾，可以用末尾排序，遍历增加箭数即可。 代码： 按气球开始排序，与原本思路上的思路等价 class Solution { public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { sort(points.begin(), points.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b) { if(a[0] == b[0]) return a[1] &lt; b[1]; else return a[0] &lt; b[0];} ); int num = 0; int end = -1; for(int i = 0; i &lt; points.size();){ num++; end = points[i][1]; i++; while(i &lt; points.size() &amp;&amp; end &gt;= points[i][0]){ end = min(end, points[i][1]); i++; } } return num; } };","link":"/2020/10/13/shua-ti-tan-xin-452-minimum-number-of-arrows-to-burst-balloons/"},{"title":"455. Assign Cookies","text":"455. Assign Cookies贪心 + 二分 思路：贪心 代码：class Solution { public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end(), less&lt;int&gt;()); sort(s.begin(), s.end(), less&lt;int&gt;()); vector&lt;bool&gt; vis(s.size(), 0); int ans = 0; for(int i = 0; i &lt; g.size(); ++i){ int l = 0, r = s.size(), mid; while(l &lt; r){ mid = (l + r) / 2; if(s[mid] &gt;= g[i]) r = mid; else l = mid + 1; } mid = r; while(mid &lt; s.size() &amp;&amp; vis[mid]) ++mid; if(mid &lt; s.size()){ vis[mid] = 1; ++ans; } } return ans; } }; 错误之处： sort的默认按升序拍戏，使用greater按降序排序 二分后mid为暂存值，lr才是最后目的地。","link":"/2020/10/09/shua-ti-tan-xin-455-assign-cookies/"},{"title":"5674. Largest Merge Of Two Strings","text":"周赛的题目3 算法：明显是贪心，但我贪错了！ 一开始想着比较两个字符创的开头字符，选择字典序大的字符加入。如果两个字符相等就放着比较下一个，直到有不同的就可以全部加入。然后wa了4发。 正确的思路是：比较剩下的字符串，选择字典序大的字符创的的首个字符加入即可。 代码：class Solution { public: string largestMerge(string word1, string word2) { int i, j; i = j = 0; string res; int n = word1.size(), m = word2.size(); while(i &lt; n &amp;&amp; j &lt; m){ // 贪心算法： // 直接比较 剩下子串， 选择字典的序大的子串的第一个字母加入 if(word1.substr(i) &gt; word2.substr(j)) res += word1[i++]; else res += word2[j++]; } if(i &lt; n) res += word1.substr(i); if(j &lt; m) res += word2.substr(j); return res; } };","link":"/2021/02/07/shua-ti-tan-xin-5674-largest-merge-of-two-strings/"},{"title":"665. Non-decreasing Array","text":"665. Non-decreasing Array思路：对于任意一个$A[i]&gt;A[i+1]$，$A[i]$和$A[i+1]$分别代表两个non-decreasing array，而合并两个的方法只有：A[i] = A[i - 1]和A[i +1 ] = A[i + 2]。 接下来只需要讨论边界条件和合并次数即可。 代码： class Solution { public: bool checkPossibility(vector&lt;int&gt;&amp; nums) { int ansnum = 0; int n = nums.size(); for(int i = 0; i &lt; n - 1; ++i){ if(nums[i] &gt; nums[i + 1]){ if(i ==0 || nums[i - 1] &lt;= nums[i + 1] || i == n - 2 || nums[i] &lt;= nums[i + 2]){ ansnum++; if(ansnum &gt; 1) return false; } else return false; } } return true;;;;;;;;;; } };","link":"/2020/10/16/shua-ti-tan-xin-665-non-decreasing-array/"},{"title":"763. Partition Labels","text":"思路：题目不错，贪心到最晚出现的字符就行了。 代码： class Solution { public: vector&lt;int&gt; partitionLabels(string S) { int vis[26] = {0}, num[26] = {0}; vector&lt;int&gt; par; int k = 0, n = S.size(), last = -1; for(int i = 0; i &lt; n; ++i) num[S[i] - 'a']++; while(k &lt; n){ memset(vis, 0, sizeof(vis)); for(k; k &lt; n; ++k){ int idx = S[k] - 'a'; vis[idx]++; int flag = 0; if(vis[idx] == num[idx] ){ for(int j = 0; j &lt; 26; ++j){ if(vis[j] &amp;&amp; vis[j] != num[j]){ flag = 1; break; } } if(!flag){ break; } } } par.push_back(k - last); last = k; k++; } return par; } }; py版：实现更优雅 class Solution(object): def partitionLabels(self, S): last = {c: i for i, c in enumerate(S)} j = anchor = 0 ans = [] for i, c in enumerate(S): j = max(j, last[c]) if i == j: ans.append(i - anchor + 1) anchor = i + 1 return ans 作者：LeetCode 链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2020/10/14/shua-ti-tan-xin-763-partition-labels/"},{"title":"870. Advantage Shuffle","text":"870. Advantage Shuffle思路一看就是贪心 从小到大逐个寻找B的牌b，找出一个刚刚好比b大的在A中的牌a。因为a刚刚比b大，所以最优。找出后，加入映射，最后重构数组即可。 代码下饭操作 class Solution { public: vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { int n = A.size(); vector&lt;int&gt; sortb(B); sort(A.begin(), A.end()); vector&lt;int&gt; leftA; sort(sortb.begin(), sortb.end()); // unordered_multimap&lt;int, int&gt; map; multimap&lt;int, int&gt; map; // 可以用 unorder_map&lt;int, deque&lt;int&gt;&gt; 代替， 代码更简洁 int g = 0; for(auto b : sortb){ while(g &lt; n &amp;&amp; A[g] &lt;= b) leftA.push_back(A[g++]); if(g &lt; n) map.insert({b, A[g++]}); } int k = 0; for(int i = 0; i &lt; n; ++i){ auto it = map.lower_bound(B[i]); if(it != map.end()){ auto [b, a]= *it; if(b == B[i]){ A[i] = a; map.erase(it); } } else A[i] = leftA[k++]; } return A; } };","link":"/2021/02/05/shua-ti-tan-xin-870-advantage-shuffle/"},{"title":"面试题 DP 贪心","text":"收集贪心、DP面试题 面14：剪绳子题面：将一串长为K的绳子剪成m（m&gt;=2，各段长度取整数值）段，各段的长度大于0，求出最大的各段绳子长度之积。 思路1：由乘法交换律可知绳子的乘积可以分解，提取出来。所以有f(m+n)=f(n)*f(m)，其中f(n)是长度n的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件f(1) = 1, f(2) = 2, f(3) = 3。同时在DP表示式为： f(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i) 所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。 思路2：另一种就是贪心，对于长度m大于5的绳子尽可能的剪成长度为3的绳子，同时如果m%3==1，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:$$if \\ n \\geq 53*(n-3) \\geq n2*(n-2) \\geq n3*(n -3 ) \\geq 2*(n-2)$$ 测试：2 2 , 3 2 , 5 6 , 6 9 代码：DP int maxProduct_DP(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int* products = new int[length + 1]; //初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大 products[0] = 0; products[1] = 1; products[2] = 2; products[3] = 3; for(int i = 4; i &lt;= length; i++){ int mavV = 0; for(int j = 1; j &lt;= i / 2; j++){ maxV = max(maxV, products[i - j] * products[j]); } products[i] = maxv; } int res = products[length]; //防止内存泄漏 del[] products; return res; } 贪心 int maxProduct_greedy(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int timesOf3 = length / 3; if(legnth % 3 == 1) timesOf3 -= 1; int timesOf2 = (length - timesOf3 * 3) / 2; return (int)pow(3, timeOf3) * (int)pow(2, timesOf2); } 面42：最大子数组和题面：如题 思路：DP思想。数组之间的选择与历史无关，可以采取DP的方法。记f(i)为以A[i]为结尾的最大数组和。转移方程为： f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0 当然也可以直接从数据的角度理解，代码都是相同的。 代码：int MaxSumOfSubArray(int A[], int length){ int dp[] = new int(length); int maxSum = A[0]; dp[0] = A[0]; for(int i = 1; i &lt; length; i++){ dp[i] = max(A[i], A[i] + dp[i-1]); maxSum = max(dp[i], maxSum); } delete[] dp; return maxSum; } 当然这里的dp数组也可以不要。 面45：把数字排成最小的数字题目：给定一串数字，组合成的一个数字。求出组合后最小数字的 思路：可以直接贪心+反证。按字典序排序数字即可。 代码：就不写了，直接string排序输出即可。 面46：数字翻译成字符串题目：把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。 思路：第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。 第二种用DP思想，考虑dp[i]为从0到i的字符串翻译方法。状态转移方程为： dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else 代码：int GetTranslateCount(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int dp[] = new int(length); dp[0] = 1; for(int i = 1; i &lt; length; i++){ int add = A[i - 1] * 10 + A[i]; if( add &gt; 9 &amp;&amp; add &lt; 26){ if(i &lt; 2) dp = dp[i - 1] + 1; else dp[i] = dp[i - 1] + dp[i - 2]; } else dp[i] = dp[i - 1]; } delete[] dp; return dp[length - 1]; } 面47：礼物的最大价值题目：从一在格子上装满礼物的m*n的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。 思路：明显就是DP 代码：不写了。 面48：最长不含重复字符的子字符串题目：如题 思路：暴力不可取。 采用用DP思想，考虑dp[i]为以S[i]为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断S[i]的前一个相同字符是否在上一个S[i-1]为结尾的最长不重复字符串之内。记上一个字符与S[i-1]的长度d为i - POS。 状态转移方程为： dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else 代码：int MaxSubStr(String s){ int dp[] = new int(s.length()); int pos[26]; for(int i = 0; i &lt; 26; i++) pos[[i] = -1; int maxL = 1; dp[0] = 1; for(int i = 1; i &lt; s.length(); i++){ int d = i - pos[s[i] - 'a']; if(dp[i - 1] &lt; d){ dp[i] = dp[i - 1] + 1; }else dp[i] = d; maxL = max(maxL, dp[i]); pos[s[i] - 'a'] = i; } delete[] dp; return maxL; }","link":"/2020/08/07/shua-ti-tan-xin-mian-shi-ti-dp-tan-xin/"},{"title":"面试素质","text":"面试官希望面试者所展现的素质如下： 能够清晰表达项目的具体细节和大体流程，可以流畅的表述出对技术、做法的看法 要求逻辑清晰，详略得当，重点突出，观点明确 会主动与提问者沟通项目或者问题中不清楚的地方 对于外企而言流畅的英语交流是必须的 学习能力 知识迁移能力","link":"/2020/08/07/shua-ti-qi-ta-code-neng-li-gou-tong-neng-li-mian-shi-su-zhi/"},{"title":"编程完整性","text":"编程完整性编程完整性是指代码对各种输入，条件的考虑，避免出现各种各样的程序漏洞，完成对编码的需求。可以从三个测试角度考虑，功能测试、边界测试和负面测试。功能测试就是指对代码本身需要完成的功能进行编码。边界测试就是对边界数据进行测试。负面测试就是对不符合要求的输入数据进行测试。 3中错误处理方法错误处理方法就是为了把程序出现的错误转告给函数调用者。大概有三种方法，一是定义特定函数返回值为函数运行状态，但是增加了函数调用的不便，不能直接赋值给另一个函数的参数。二是定义一个全局变量，若函数调用中出现错误就改变全局变量，相比第一种方法方便很多，但是存在函数调用不检查全局变量的安全隐患。三是抛出异常，或者使用try.....catch语句定义不同状态的运行程序，可自定义异常类型，逻辑清晰，但是某些语言可能不支持。 代码鲁邦性代码鲁棒性就是指代码对异常输入，运行错误的处理的能力。因为用户和环境的错误是可能不规范的，为了让程序正确运行，养成防御性编程习惯有利于提高代码质量。最简单最实用例子就是在函数入口检查参数。","link":"/2020/08/07/shua-ti-qi-ta-code-neng-li-dai-ma-gui-fan-bian-cheng-wan-zheng-xing/"},{"title":"218. The Skyline Problem","text":"218. The Skyline Problem思路：扫描线算法： 想像一根竖线，从左到右进行扫描，记录下当前竖线所有线段的高度（除去左端点），每遇到一个端点就挑选出最高点，并输出即可。这里可以观察到，此算法把一根直线拆分两个端点来看待，遇到右端点就记录维持该线段的高度，遇到左端点就删除该线段的高度。 具体算法，直接看代码，其中左端点的Height取负值记录非常巧妙，既利用了set集合的升序性质，同时在遍历的时优先选择了新建筑，不至于产生“建筑间的空隙”。 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) { multiset&lt;pair&lt;int, int&gt;&gt; loc; for(auto &amp;e : buildings){ loc.insert({e[0], -e[2]}); loc.insert({e[1], e[2]}); } vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; last{0,0}; multiset&lt;int&gt; height{0}; //多个高度可能相同 cout &lt;&lt; last[0] &lt;&lt; endl; for(auto &amp;[pos, h] : loc){ if(h &lt; 0) height.insert(-h); else height.erase(height.find(h)); int maxh = *height.rbegin(); // cout &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; h &lt;&lt; ' ' &lt;&lt; maxh &lt;&lt; endl; if(maxh != last[1]){ last[0] = pos; last[1] = maxh; ans.emplace_back(last); } } return ans; } };","link":"/2021/01/26/shua-ti-qi-ta-sao-miao-xian-218-the-skyline-problem/"},{"title":"126. Word Ladder II","text":"126. Word Ladder II思路： 这次的bugs很少，开心。 这题核心就是BFS（DFS）的基础上加上剪枝优化。或者TBFS 建立搜索树BFS搜索结果即可。 最好用邻接矩阵优化BFS搜索数量，同时显然的，你没法通过绕一个小弯找到最短路，这可以剪枝。 第二种思路就是双头搜索。因为题目给出了起始地点和结束地点的字符串。在搜索的时候控制一下搜索空间，搜索深度就AC了。击败96%！。 代码：// 26th样例超时 class Solution { public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; ans; int n = wordList.size(), flag = 0; for(int i = 0; i &lt; n; ++i){ if(wordList[i] == endWord) flag = 1; } if(!flag) return ans; queue&lt;SN*&gt; que; wordList.push_back(beginWord); // size++ que.push(new SN(n, -1, 0, nullptr)); int endlevel = -1; while(que.size()){ SN *p = que.front(); que.pop(); // cout &lt;&lt; wordList[p.x] &lt;&lt;&quot; &quot; &lt;&lt; p.l &lt;&lt; '#'; // if(p.plink != nullptr) // cout &lt;&lt; p.x &lt;&lt; (p.plink)-&gt;x &lt;&lt; endl; // cout &lt;&lt; (p.plink == &amp;p) &lt;&lt; endl; // bugs: p.plink == &amp;p //search the final points. if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue; if(wordList[p-&gt;x] == endWord){ endlevel = p-&gt;l; vector&lt;string&gt; tmp; SN* np = p; while(np != nullptr){ tmp.push_back(wordList[np-&gt;x]); np = np-&gt;plink; // cout &lt;&lt; np-&gt;x &lt;&lt; &quot; &quot;; } // cout &lt;&lt; endl; reverse(tmp.begin(), tmp.end()); ans.push_back(tmp); } // emplace more points. for(int j = 0; j &lt; n; ++j){ if(islink(wordList[j], wordList[p-&gt;x])){ SN* newp = new SN(j, p-&gt;x, p-&gt;l + 1, p); //bugs: 这里取的地址是变量p的地址，同时地址指向不变，但是p指向的内容会受暂存变量p赋值而变化。 这可是C++基础啊 //解决方法： 给每个变量一个新的地址即可 // cout &lt;&lt; (&amp;newp == &amp;p) &lt;&lt; endl; que.push(newp); } } } return ans; } bool islink(const string &amp;a, const string &amp;b){ int len = a.size(), t = 0; for(int i = 0; i &lt; len; ++i){ if(a[i] != b[i]) t++; if(t &gt; 1) return false; } if(t == 0) return false; return true; } class SN{ public: int x; int px; int l; SN * plink; SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){} }; }; AC //图优化版本 // 执行用时： // 644 ms // , 在所有 C++ 提交中击败了 // 61.99% // 的用户 // 内存消耗： // 19.1 MB // , 在所有 C++ 提交中击败了 // 66.81% // 的用户 class Solution { public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; ans; int n = wordList.size(), flag = 0; for(int i = 0; i &lt; n; ++i){ if(wordList[i] == endWord) flag = 1; } if(!flag) return ans; //bulid the map. wordList.push_back(beginWord); // size++ n++; vector&lt;vector&lt;int&gt;&gt; edges; edges.resize(n + 1); for(int i = 0; i &lt; n; ++i){ for(int j = i + 1; j &lt; n; ++j){ if(islink(wordList[i], wordList[j])){ edges[i].push_back(j); edges[j].push_back(i); } } } vector&lt;int&gt; cost(n, n + 1); cost[n - 1] = 0; //bfs queue&lt;SN*&gt; que; que.push(new SN(n - 1, -1, 0, nullptr)); int endlevel = -1; while(que.size()){ SN *p = que.front(); que.pop(); if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue; if(wordList[p-&gt;x] == endWord){ endlevel = p-&gt;l; vector&lt;string&gt; tmp; SN* np = p; while(np != nullptr){ tmp.push_back(wordList[np-&gt;x]); np = np-&gt;plink; } reverse(tmp.begin(), tmp.end()); ans.push_back(tmp); } // emplace more points. for(auto j : edges[p-&gt;x]){ if(cost[j] &gt; cost[p-&gt;x]){ // 没法绕一个圈子找到最短路 cost[j] = cost[p-&gt;x] + 1; SN* newp = new SN(j, p-&gt;x, p-&gt;l + 1, p); que.push(newp); } } } return ans; } bool islink(const string &amp;a, const string &amp;b){ int len = a.size(), t = 0; for(int i = 0; i &lt; len; ++i){ if(a[i] != b[i]) t++; if(t &gt; 1) return false; } if(t == 0) return false; return true; } class SN{ public: int x; int px; int l; SN * plink; SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){} //由于历史原因，px和l有点多余 }; }; 双向bfs思路学习；（未完成） class Solution { public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; path; unordered_set&lt;string&gt; dict ,q1, q2; //dict：搜索空间 q1q2:双头搜索 unordered_map&lt;string, vector&lt;string&gt;&gt; next; for(const auto &amp;p : wordList){ dict.insert(p); } if(!dict.count(endWord)) return path; dict.erase(beginWord); dict.erase(endWord); q1.insert(beginWord); q2.insert(endWord); bool reverse = false, found = false; while(!q1.empty()){ unordered_set&lt;string&gt; q; for(const auto &amp;w : q1){ string cw = w; for(size_t i = 0 ; i &lt; cw.size(); ++i){ char c = cw[i]; for(int j = 0; j &lt; 26; ++j){ cw[i] = j + 'a'; if(q2.count(cw)){ reverse ? next[cw].push_back(w) : next[w].push_back(cw); found = true; } if(dict.count(cw)){ //count 比 find好用 reverse ? next[cw].push_back(w) : next[w].push_back(cw); q.insert(cw); } } cw[i] = c; } } // for(const auto &amp;w :q) // cout &lt;&lt; w &lt;&lt; &quot; &quot;; // cout &lt;&lt; endl; //控制搜索层数 if(found) break; for(const auto &amp;w : q){ dict.erase(w); } //选择扩展范围小的开始搜索，降低搜索数量 if(q.size() &lt; q2.size()){ q1 = q; }else{ reverse = !reverse; q1 = q2; q2 = q; } } vector&lt;string&gt; oneway = {beginWord}; buildPath(next, path, oneway, beginWord, endWord); return path; } void buildPath(unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; next, vector&lt;vector&lt;string&gt;&gt;&amp; path, vector&lt;string&gt; &amp;oneway, string nword, string endWord){ if(nword == endWord){ path.push_back(oneway); return; } for(const auto &amp;w : next[nword]){ oneway.push_back(w); buildPath(next, path, oneway, w, endWord); oneway.pop_back(); } } };","link":"/2020/11/29/shua-ti-sou-suo-bfs-126-word-ladder-ii/"},{"title":"22. Generate Parentheses","text":"思路：正确的迭代方式是，从左到右的遍历中，每一个正确序列都有左括号的数量大于等于右括号的数量。而每一处符号要么是左括号，要么是右括号，后者符号都有选择的生成即可。 如何便可以递归生成所有符合题意的括号。 代码：class Solution { vector&lt;string&gt; ans; set&lt;string&gt; sset; public: vector&lt;string&gt; generateParenthesis(int n) { generateParenthesisCore(0, 0, n, &quot;&quot;); for(string s : sset) ans.push_back(s); return ans; } void generateParenthesisCore(int left, int right, int n, string str){ if(left == n){ ans.push_back(str + string((n - right), ')')); return; } generateParenthesisCore(left + 1, right, n, str + &quot;(&quot;); if(left &gt; right){ generateParenthesisCore(left, right + 1, n, str + &quot;)&quot;); } } };","link":"/2021/04/26/shua-ti-sou-suo-bfs-22-generate-parentheses/"},{"title":"130. Surrounded Regions","text":"130. Surrounded Regions思路：如果用普通dfs搜索所有区域是速度有点慢的。 但只是反过来思考，如果只所搜索所有不被包围的O并标记，同时翻转所有剩下的X，最后把所有的P翻转回来是不是会更快。 不搞特例的话，一般都是后者快。 代码：class Solution { public: int n, m; int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; void fill(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; vis,vector&lt;pair&lt;int, int&gt;&gt; &amp;path, int &amp;isea, int x , int y){ // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; vis[x][y] = 1; path.push_back(make_pair(x, y)); for(int i = 0; i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m){ isea = 1; continue; } if(!vis[nx][ny] &amp;&amp; board[nx][ny] == 'O'){ fill(board, vis, path, isea, nx, ny); } } } void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) { n = board.size(); if(n == 0) return; m = board[0].size(); vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m, false)); for(int i = 0; i &lt; n; ++i){ for(int j = 0;j &lt; m; ++j){ if(!vis[i][j] &amp;&amp; board[i][j] == 'O'){ vector&lt;pair&lt;int, int&gt;&gt; path; int isea = 0; fill(board, vis, path, isea, i, j); if(isea) continue; // bugs: forgets to clear path for(auto p : path){ board[p.first][p.second] = 'X'; } } } } } }; 16ms范例 class Solution { public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) { // 给出一个二维数组，找到被 x 包围的 o，然后将其转换为x // dfs if(board.empty()) return; int m = board.size(), n = board[0].size(); if (m == 1 || n == 1) return ; // 反过来思考，只改变和边界直接相连的元素 // 首先检查第一行和最后一行的 O for(int i = 0;i&lt;m;i+=m-1) for(int j = 0;j&lt;n;j++) if(board[i][j] == 'O') dfs(board,i,j,m,n); // 再检查第一列和最后一列的 O for(int j = 0;j&lt;n;j+=n-1) for(int i = 0;i&lt;m;i++) if(board[i][j] == 'O') dfs(board,i,j,m,n); // 将 board 中的 O 改为 X // 再将 board 中的 P 改为 O for (auto &amp;i:board) replace(i.begin(),i.end(),'O','X'); for (auto &amp;i:board) replace(i.begin(),i.end(),'P','O'); } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp;board,int i, int j,int m, int n) { if(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp; board[i][j] == 'O') { board[i][j] = 'P'; dfs(board,i+1,j,m,n); dfs(board,i,j+1,m,n); dfs(board,i-1,j,m,n); dfs(board,i,j-1,m,n); } } };","link":"/2020/12/01/shua-ti-sou-suo-dfs-130-surrounded-regions/"},{"title":"417. Pacific Atlantic Water Flow","text":"417. Pacific Atlantic Water Flow思路：按着题目的意思顺着流向DFS有以下问题。做了正向的代码发现有个DFS依赖问题。 网上大神给出了**逆流**DFS的思路。 代码：class Solution { public: int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; int m, n; // 顺流dfs搜索得色5re'rs'ze'd [re'rong'ze'dui] // 回流依赖问题： when height[x, y] == height[nx, ny] : // type[x ,y] =&gt; type[dx, dy], type[dx ,dy] =&gt; type[x, y] , 同时DFS式的遍历方式保证了了每个 // 节点只被访问一次，所以存在类型相互依赖关系 // 即存在一个鸡生蛋，蛋生鸡的问题。 // 解决方法是：没想出来 int flow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type, int x, int y){ // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; if(x &lt; 0 || y &lt; 0 ) return -1; else if( x &gt;= m || y &gt;= n) return -2; if(type[x][y] != 0) return type[x][y]; type[x][y] = 4; // the visited point. int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1; for(int i = 0; i &lt; 4; ++i){ nx = x + dx[i]; ny = y + dy[i]; if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;= m || ny &gt;= n) || matrix[nx][ny] &lt;= matrix[x][y]){ //bugs: nx, ny t = flow(matrix, type, nx, ny); if(t == -1 || t == 1 || t == 3) f1 = 1; if(t == -2 || t == 2 || t == 3) f2 = 1; } } if(f1 &amp; f2) type[x][y] = 3; else if(f1) type[x][y] = 1; else if(f2) type[x][y] = 2; // type[x][y] = f1 &amp; f2; // bugs 1 &amp; 1 return type[x][y]; } int flow2(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type, int x, int y){ // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; if(x &lt; 0 || y &lt; 0 ) return -1; else if( x &gt;= m || y &gt;= n) return -2; int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1; for(int i = 0; i &lt; 4; ++i){ nx = x + dx[i]; ny = y + dy[i]; if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;= m || ny &gt;= n) || matrix[nx][ny] &lt;= matrix[x][y]){ //bugs: nx, ny t = flow(matrix, type, nx, ny); if(t == -1 || t == 1 || t == 3) f1 = 1; if(t == -2 || t == 2 || t == 3) f2 = 1; } } if(f1 &amp; f2) type[x][y] = 3; else if(f1) type[x][y] = 1; else if(f2) type[x][y] = 2; // type[x][y] = f1 &amp; f2; // bugs 1 &amp; 2 ： 1 | 2 return type[x][y]; } // 题解：逆流写法 void reflow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type, int x, int y, int wtype){ type[x][y] = type[x][y] | wtype; int nx, ny; for(int i = 0; i &lt; 4; ++i){ nx = x + dx[i]; ny = y + dy[i]; if(nx &gt;=0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) if(matrix[x][y] &lt;= matrix[nx][ny] &amp;&amp; ((type[nx][ny] &amp; wtype) == 0)) reflow(matrix, type, nx, ny, wtype); } } vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { m = matrix.size(); if(m == 0) return matrix; //return empty vector; n = matrix[0].size(); vector&lt; vector&lt;int&gt;&gt; type(m, vector&lt;int&gt;(n, 0)), ans; for(int i = 0; i &lt; m; ++i){ reflow(matrix, type, i, 0, 1); reflow(matrix, type, i, n - 1, 2); } for(int i = 0; i &lt; n; ++i){ reflow(matrix, type, 0, i, 1); reflow(matrix, type, m - 1, i, 2); } for(int i = 0; i &lt; m; ++i){ for(int j = 0; j &lt; n; ++j){ // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; type[i][j] &lt;&lt; endl; if(type[i][j] == 3){ ans.emplace_back( vector&lt;int&gt;({i, j})); // bugs initialize vector&lt;int&gt; a(n, i) } } } return ans; } };","link":"/2020/11/24/shua-ti-sou-suo-dfs-417-pacific-atlantic-water-flow/"},{"title":"547. Friend Circles","text":"547. Friend Circles思路：dfs搜索人头就行。 代码：class Solution { public: int n; void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; M, vector&lt;int&gt;&amp; vis,int x){ vis[x] = 1; for(int i = 0; i &lt; n; ++i){ if(!vis[i] &amp;&amp; M[x][i]){ colorize(M, vis, i); } } } int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) { n = M.size(); vector&lt;int&gt; vis(n, 0); int ct = 0; for(int i = 0; i &lt; n; ++i){ if(!vis[i]){ ct++; colorize(M, vis, i); } } return ct; } };","link":"/2020/11/22/shua-ti-sou-suo-dfs-547-friend-circles/"},{"title":"547. Number of Provinces","text":"547. Number of Provinces思路：多次dfs判断连通团即可 代码：class Solution { public: int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { int res = 0, n = isConnected.size(); vector&lt;int&gt; vis(n); for(int i = 0; i &lt; n; ++i){ if(!vis[i]){ ++res; dfs(vis, isConnected, i); } } return res; } void dfs(vector&lt;int&gt; &amp;vis, vector&lt;vector&lt;int&gt;&gt; &amp;g, int k){ if(vis[k]) return; vis[k] = 1; for(int i = 0; i &lt; g.size(); ++i){ if(g[k][i]) dfs(vis, g, i); } } };","link":"/2021/01/07/shua-ti-sou-suo-dfs-547-number-of-provinces/"},{"title":"695. Max Area of Island","text":"695. Max Area of Island、 思路：深度优先搜索 代码： class Solution { public: int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, 1, -1}; int n, m; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if(grid[0].size() == 0) return 0; n = grid.size(), m = grid[0].size(); vector&lt; vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0)); int maxA = 0; for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ int tempA = 0; if(grid[i][j] == 1 &amp;&amp; vis[i][j] == 0){ area(grid, i, j, vis, tempA); maxA = max(maxA, tempA); } } } return maxA; } void area(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; vis, int &amp;ct){//bug // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; if( x &lt; 0 || x &gt;=n || y &lt; 0 || y &gt;= m || vis[x][y] == 1 || grid[x][y] == 0 ) return;//bug vis[x][y] = 1; //bug ct += 1; for(int k = 0; k &lt; 4; ++k) area(grid, x + dx[k], y + dy[k], vis, ct); } };","link":"/2020/11/19/shua-ti-sou-suo-dfs-695-max-area-of-island/"},{"title":"37. Sudoku Solver","text":"37. Sudoku Solver思路：dfs搜索，可以用位运算优化，懒得看了 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; col, row, cell; vector&lt;pair&lt;int, int&gt;&gt; blank; // int dx[4] = {0, 0, -1, 1}; // int dy[4] = {-1, 1, 0, 0}; int n; int flag = 0; int getC(int x, int y){ return (x / 3) * 3 + y / 3; } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { n = board.size(); row = cell = col = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0)); //bugs: num -&gt; idx // cout &lt;&lt; row[0][0]; for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; n; ++j){ if(board[i][j] == '.') { blank.push_back(make_pair(i, j)); continue; } int t = board[i][j] - '0'; row[i][t] = 1; col[j][t] = 1; cell[getC(i, j)][t] = 1; } } dfs(board, 0); } void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board, int pos){ // cout &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; blank.size() &lt;&lt; endl; if(flag || pos == blank.size()){ flag = 1; return; } int x = blank[pos].first; int y = blank[pos].second; // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; if(board[x][y] == '.'){ for(int i = 1; i &lt;= 9; ++i){ if(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[getC(x, y)][i]){ // cout &lt;&lt; i &lt;&lt; &quot;@&quot; &lt;&lt; endl; row[x][i] = 1; col[y][i] = 1; cell[getC(x, y)][i] = 1; board[x][y] = i + '0'; dfs(board, pos + 1); if(flag) return; row[x][i] = 0; col[y][i] = 0; cell[getC(x, y)][i] = 0; board[x][y] = '.'; } } } } };","link":"/2020/12/05/shua-ti-sou-suo-hui-su-37-sudoku-solver/"},{"title":"37.解数独","text":"37 解数独 - 位运算 回溯编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。空白格用 ‘.’ 表示。 思路：回溯。 错误想法：模拟平时玩数独的方法，寻找可能性最小的格子并确定，这种方法反而实现复杂，难以查找BUG。 简单方法反而最有效 扩展：如何计算复杂度？ 代码：1A //错误代码 class Solution { public: const static int len = 9; void print(vector&lt;vector&lt;char&gt;&gt; &amp;board){ static int sum = 1; printf(&quot;-----------------\\n%d \\n&quot;, sum++); if(sum &lt; 5) return; for(int i = 0; i &lt; len; i++){ for(int j = 0; j &lt; len; j++) printf(&quot;%c &quot;, board[i][j]); printf(&quot;\\n&quot;); } } void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, vector&lt;char&gt; poss[][len], int &amp;flag){ int minPoss = 20; int x = -1, y = -1; //print print(board); if(flag == 0) return; for(int i = 0; i &lt; len; i++) for(int j = 0; j &lt; len; j++){ int size = poss[i][j].size(); if(size == 1){ // do it. board[i][j] = poss[i][j][0]; poss[i][j].clear(); // remove the impossible number. for(int t = 0; t &lt; len; t++){ vector&lt;char&gt; &amp;rowP = poss[i][t]; vector&lt;char&gt; &amp;colP = poss[t][j]; rowP.erase(remove(rowP.begin(), rowP.end(), board[i][j]), rowP.end()); colP.erase(remove(colP.begin(), colP.end(), board[i][j]), colP.end()); } // int block = (i % 3) * 3 + j / 3; int x = i / 3 * 3; int y = j % 3 * 3; for(int p = x; p &lt; x + 3; p++) for(int q = y; q &lt; y + 3; q++) { vector&lt;char&gt; &amp;vecP = poss[p][q]; vecP.erase(remove(vecP.begin(), vecP.end(), board[i][j]), vecP.end()); } solveSudokuCore(board, poss, flag); return; } // This is a bad path. else if( size == 0 &amp;&amp; board[i][j] == '.'){ printf(&quot;[End point]:%d %d\\n&quot;, i, j); return; } // Find the minimum possibly grid; else if(minPoss &gt; size &amp;&amp; size &gt; 1){ minPoss = size; x = i; y = j; } } //The no more possbility. End the Search. if(minPoss == 20){ flag = 0; return; } // there are none grid that has only one possible result. vector&lt;char&gt; ans = poss[x][y]; poss[x][y].clear(); for(int i = 0; i &lt; ans.size(); i++){ poss[x][y].push_back(ans[i]); solveSudokuCore(board, poss, flag); poss[x][y].clear(); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { vector&lt;char&gt; pos[len][len]; bool hasNum[len + 1] = {0}; for(int i=0; i &lt; len; i++) for(int j=0; j &lt; len; j++){ if(board[i][j] == '.'){ memset(hasNum, 0, sizeof(bool) * (len + 1)); for(int k = 0; k &lt; len; k++){ if(board[k][j] != '.') hasNum[board[k][j] -'0'] = 1; if(board[i][k] != '.') hasNum[board[i][k] -'0'] = 1; } int x = i / 3 * 3; int y = j / 3 * 3; for(int p = x; p &lt; x + 3; p++) for(int q = y; q &lt; y + 3; q++) { if(board[p][q] != '.') hasNum[board[p][q] - '0'] = 1; } for(int l = 1; l &lt; len + 1; l++) if(hasNum[l] == 0) pos[i][j].push_back(l + '0'); } } int flag = 1; solveSudokuCore(board, pos, flag); } }; //1A class Solution { public: const static int len = 9; void print(vector&lt;vector&lt;char&gt;&gt; &amp;board, int x, int y){ static int sum = 1; printf(&quot;-----------------\\n%d %d %d;\\n&quot;, sum++, x, y); if(sum &lt; 8) return; for(int i = 0; i &lt; len; i++){ for(int j = 0; j &lt; len; j++) printf(&quot;%c &quot;, board[i][j]); printf(&quot;\\n&quot;); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { int rowNum[len][len] = {0}; int colNum[len][len] = {0}; int cubeNum[len][len] = {0}; memset(rowNum, 0, sizeof(int) * len * len); memset(colNum, 0, sizeof(int) * len * len); memset(cubeNum, 0, sizeof(int) * len * len); for(int i=0; i &lt; len; i++) for(int j=0; j &lt; len; j++){ if(board[i][j] != '.'){ rowNum[i][board[i][j] - '0' - 1] = 1; colNum[j][board[i][j] - '0' - 1] = 1; int cube = i / 3 * 3 + j / 3; cubeNum[cube][board[i][j] - '0' - 1] = 1; } } int flag = 0; solveSudokuCore(board, rowNum, colNum, cubeNum, 0, 0, flag); } void changeXY(int x , int y, int &amp;nx, int &amp;ny){ y++; if(y == 9){ y = 0; x++; } nx = x; ny = y; } void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, int rowNum[][len], int colNum[][len], int cubeNum[][len], int x, int y, int &amp;flag){ //回溯剪枝 // if(x == 8) // print(board, x, y); if(x == 9){ flag = 1; return; } int nx, ny; if(board[x][y] == '.'){ for(int i = 0; i &lt; len; i++){ int cube = (x / 3 * 3 + y / 3); if(!rowNum[x][i] &amp;&amp; !colNum[y][i] &amp;&amp; !cubeNum[cube][i]){ board[x][y] = i + 1 + '0'; rowNum[x][i] = 1; colNum[y][i] = 1; cubeNum[cube][i] = 1; changeXY(x, y, nx, ny); solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag); //回溯剪枝 if(flag) return; board[x][y] = '.'; rowNum[x][i] = 0; colNum[y][i] = 0; cubeNum[cube][i] = 0; } } } else{ changeXY(x, y, nx, ny); solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag); } } }; 位运算版本 class Solution { private: int line[9]; int column[9]; int block[3][3]; bool valid; vector&lt;pair&lt;int, int&gt;&gt; spaces; public: void flip(int i, int j, int digit) { line[i] ^= (1 &lt;&lt; digit); column[j] ^= (1 &lt;&lt; digit); block[i / 3][j / 3] ^= (1 &lt;&lt; digit); } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) { if (pos == spaces.size()) { valid = true; return; } auto [i, j] = spaces[pos]; int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) &amp; 0x1ff; for (; mask &amp;&amp; !valid; mask &amp;= (mask - 1)) { int digitMask = mask &amp; (-mask); int digit = __builtin_ctz(digitMask); flip(i, j, digit); board[i][j] = digit + '0' + 1; dfs(board, pos + 1); flip(i, j, digit); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { memset(line, 0, sizeof(line)); memset(column, 0, sizeof(column)); memset(block, 0, sizeof(block)); valid = false; for (int i = 0; i &lt; 9; ++i) { for (int j = 0; j &lt; 9; ++j) { if (board[i][j] == '.') { spaces.emplace_back(i, j); } else { int digit = board[i][j] - '0' - 1; flip(i, j, digit); } } } dfs(board, 0); } }; 位运算技巧： ​ 取出最低位的1，其他位为零：x &amp; (-x) ​ 消除最低位的1：x &amp; (x - 1 ) ​ 变换第pos位：x ^ (1 &lt;&lt; pos) 得到最低位1的序数（低位零的个数）：__builtin_ctz(unsigned_int x) 优化class Solution { private: int line[9]; int column[9]; int block[3][3]; bool valid; vector&lt;pair&lt;int, int&gt;&gt; spaces; public: void flip(int i, int j, int digit) { line[i] ^= (1 &lt;&lt; digit); column[j] ^= (1 &lt;&lt; digit); block[i / 3][j / 3] ^= (1 &lt;&lt; digit); } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) { if (pos == spaces.size()) { valid = true; return; } auto [i, j] = spaces[pos]; int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) &amp; 0x1ff; for (; mask &amp;&amp; !valid; mask &amp;= (mask - 1)) { int digitMask = mask &amp; (-mask); int digit = __builtin_ctz(digitMask); flip(i, j, digit); board[i][j] = digit + '0' + 1; dfs(board, pos + 1); flip(i, j, digit); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { memset(line, 0, sizeof(line)); memset(column, 0, sizeof(column)); memset(block, 0, sizeof(block)); valid = false; for (int i = 0; i &lt; 9; ++i) { for (int j = 0; j &lt; 9; ++j) { if (board[i][j] != '.') { int digit = board[i][j] - '0' - 1; flip(i, j, digit); } } } int len = 9; bool flag = true; while(flag){ flag = false; for(int i = 0; i &lt; len; i++){ for(int j = 0; j &lt; len; j++){ if(board[i][j] != '.') continue; int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) &amp; 0x1FF; if( !(mask &amp; (mask - 1))){ int digitnum = __builtin_ctz(mask &amp; (-mask)) ; flip(i, j, digitnum); board[i][j] = digitnum + '0' + 1; flag = true; } } } } for (int i = 0; i &lt; 9; ++i) { for (int j = 0; j &lt; 9; ++j) { if (board[i][j] == '.') { spaces.emplace_back(i, j); } } } dfs(board, 0); } };","link":"/2020/09/17/shua-ti-sou-suo-hui-su-37-jie-shu-du/"},{"title":"39. Combination Sum","text":"39. Combination Sum 在dfs搜索题中，形象化一个dfs搜索树是一个非常有趣的，形象的描述方法。比如下面这个没有剪枝的dfs搜索树。也可以比较一下，下面两种解法的dfs搜索树的不同之处。 思路：dfs搜索剪枝代码。非常标准的一道搜索题。 官方给出的时间复杂度分析 代码：66% class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); //sort优化顺序 33%-&gt;47% vector&lt;int&gt; aim; dfsCombinate(candidates, aim, target, 0); return res; } void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos){ if(pos == candidates.size()) return; if(target &lt;=0){ if(target == 0){ res.push_back(aim); } return; } aim.push_back(candidates[pos]); dfsCombinate(candidates, aim, target - candidates[pos], pos); aim.pop_back(); dfsCombinate(candidates, aim, target, pos + 1); } }; 99% class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); //sort优化顺序 33%-&gt;47% vector&lt;int&gt; aim; dfsCombinate(candidates, aim, target, 0); return res; } void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos){ if(target == 0){ res.push_back(aim); return; } for(int i = pos;i &lt; candidates.size(); ++i){ //for循环代替递归寻找，减少函数调用，增加效率 if(candidates[i] &gt; target) break; if(i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) continue; // 重复数字无需再判断 aim.push_back(candidates[i]); dfsCombinate(candidates, aim, target - candidates[i],i); aim.pop_back(); } } };","link":"/2020/12/04/shua-ti-sou-suo-hui-su-39-combination-sum/"},{"title":"40. Combination Sum II","text":"40. Combination Sum II思路： 用map记录数字出现次数，转化为普通的dfs 避免在填充idx数字的时候，遍历到重复数字，即可。无需map记录数字。是一种成熟的避免重复数字的方法。 代码：40% class Solution { public: unordered_map&lt;int, int&gt; ct; vector&lt;int&gt; arr; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); for(auto i : candidates){ ct[i]++; if(ct[i] == 1) arr.push_back(i); } vector&lt;int&gt; aim; dfs(aim, 0, target); return res; } void dfs(vector&lt;int&gt; &amp;aim, int pos, int target){ if(target == 0){ res.push_back(aim); return; } for(int i = pos; i &lt; arr.size(); ++i){ if(arr[i] &gt; target) break; if(ct[arr[i]] == 0) continue; //ct[arr[i]]必行存在 aim.push_back(arr[i]); ct[arr[i]]--; dfs(aim, i, target - arr[i]); ct[arr[i]]++; aim.pop_back(); } } }; 98% class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); vector&lt;int&gt; aim; dfs(candidates,aim, 0, target); return res; } void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; &amp;aim, int pos, int target){ // for(auto i : aim){ // cout &lt;&lt; i &lt;&lt; ' ' ; // } // cout &lt;&lt; endl; if(target == 0){ res.push_back(aim); return; } for(int i = pos; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;= target; ++i){ //在一层的搜索中选择不重复的数字，同时巧妙的维持了可搜索上一层数字的状态 if(i &gt; 0 &amp;&amp; i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) continue; aim.push_back(candidates[i]); dfs(candidates, aim, i + 1, target - candidates[i]); aim.pop_back(); } } };","link":"/2020/12/04/shua-ti-sou-suo-hui-su-40-combination-sum-ii/"},{"title":"46. Permutations","text":"46. Permutations2思路：回溯法确定全排列。复杂度$o(n*n!)$，（复制 * permute调用次数）。 代码：class Solution { public: void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int pos){ int n = nums.size(); if(n - 1 &lt; pos){ res.push_back(nums); return; } for(int i = pos; i &lt; n; ++i){ swap(nums[pos], nums[i]); permuteCore(nums, res, pos + 1); swap(nums[pos], nums[i]); } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; permuteCore(nums, res, 0); return res; } };","link":"/2020/11/24/shua-ti-sou-suo-hui-su-46-permutations/"},{"title":"47. Permutations II","text":"47. Permutations II2思路：保证idx位的元素不重复即可。 可以用set去重nums[idx] 用set去重res 代码：66% class Solution { public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; permute; permuteUniqueCore(permute, nums, 0); return permute; } void permuteUniqueCore(vector&lt;vector&lt;int&gt;&gt; &amp;permute, vector&lt;int&gt;&amp;nums, int pos){ if(nums.size() == 0 ) return; if(pos == nums.size() - 1){ permute.push_back(nums); return; } // set无脑去重，空间有点大 unordered_set&lt;int&gt; vis; for(int i = pos; i &lt; nums.size(); ++i){ if(pos != i &amp;&amp; vis.count(nums[i])) continue; vis.insert(nums[i]); swap(nums[pos], nums[i]); permuteUniqueCore(permute, nums, pos + 1); swap(nums[pos], nums[i]); } } }; 88% class Solution { public: vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); vector&lt;int&gt; vis(nums.size()); permuteCore(nums, vis, 0); return res; } void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;int&gt; &amp;vis, int pos){ if(pos == nums.size()){ res.push_back(temp); return; } for(int i = 0; i &lt; nums.size(); i++){ if(vis[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i -1] &amp;&amp; !vis[i - 1])) continue; vis[i] = 1; temp.push_back(nums[i]); permuteCore(nums, vis, pos + 1); temp.pop_back(); vis[i] = 0; } } };","link":"/2020/12/03/shua-ti-sou-suo-hui-su-47-permutations-ii/"},{"title":"51. N-Queens","text":"51. N-Queens思路:八皇后问题，经典问题。回溯解决。 代码：class Solution { public: void generate(vector&lt;vector&lt;string&gt;&gt; &amp;outs, vector&lt;int&gt; &amp;chess, vector&lt;int&gt; &amp;hashorpos, int depth, int n){ if(n == depth){ vector&lt;string&gt; res(n, string(n, '.')); for(int i = 0; i &lt; n; ++i){ res[i].replace(chess[i], 1, &quot;Q&quot;); // cout &lt;&lt; chess[i] &lt;&lt; ' ' ; } // cout &lt;&lt; endl; outs.emplace_back(res); return; } for(int i = 0; i &lt; n; ++i){ int flag = 1; if(!hashorpos[i]){ #这部分判断代码可以优化，但是很麻烦，可以用hasverpos代表一层中被禁止的位置,需要标记左右方向，很麻烦。考虑到n的数量直接遍历就行，可以当做一个不变量。 for(int j = 1; j &lt;= depth ; ++j){ if(chess[depth - j] == i - j || chess[depth - j] == i + j){ flag = 0; break; } } if(!flag) continue; chess[depth] = i; hashorpos[i] = 1; generate(outs, chess, hashorpos, depth + 1, n); chess[depth] = -1; hashorpos[i] = 0; } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;vector&lt;string&gt;&gt; outs; vector&lt;int&gt; chess(n, -1), hashorpos(n, 0); generate(outs, chess, hashorpos, 0, n); return outs; } };","link":"/2020/11/27/shua-ti-sou-suo-hui-su-51-n-queens/"},{"title":"77. Combinations","text":"77. Combinations思路：回溯，获取搭配数组， $s &lt;= n - k + 1$ 代码: class Solution { public: void getKnumber(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt; &amp;addt, int n, int k, int s){ if(addt.size() == k){ ans.push_back(addt); return; } if(s &gt; n) return; for(int i = s; i &lt;= n - k + addt.size() + 1; ++i){ addt.push_back(i); getKnumber(ans, addt, n, k, i + 1); addt.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; addt; getKnumber(res, addt, n, k, 1); return res; } };","link":"/2020/11/25/shua-ti-sou-suo-hui-su-77-combinations/"},{"title":"面试题-回溯DFs","text":"收集回溯相关题目 面13 面12和13很相似，不重复写了。 题面：在一个字符矩阵中寻找一条路径，路径上的字符从头到尾排列起来是给定的字符串s。判断有无这么一条路径。 思路：DFS或者说和回朔直接暴力搜。 代码：bool hasPathCore(char *matrix, int rows, int cols, int row, int col, char *str, int strIdx, int &amp;isFound){ if(strIdx &lt; 0){ isFound = 1; return true; } if(isFound) return true; visited[row * cols + col] = 1; int dX[] = {0, 0, -1, 1}, dY[] = {-1, 1, 0, 0}; for(int i = 0; i &lt; 4; ++i){ int nX = dX[i] + row, nY = dY[i] + col, p = row * cols + col; if( nX &gt;= 0 &amp;&amp; nY &gt;= 0 &amp;&amp; nX &lt; rows &amp;&amp; nY &lt; cols &amp;&amp; !visited[p] &amp;&amp; str[strIdx] == matrix[p]) hashPathCore(matrix, rows, cols, row, col, str, strIdx - 1); } } bool hasPath(char *matrix, int rows, int cols, char *str, int length){ if(str == nullptr || matrix == nullptr) throw new std::exception(&quot;Invalid parameters.&quot;); int visited = new int[rows * cols], isFound = 0; memset(visited, 0, sizeof(visited)); for(int i = 0; i &lt; rows; ++i) for(int j = 0; j &lt; cols; ++j) if( hasPathCore(matrix, rows, cols, i, j, str, length - 1, isFound)){//倒着搜 del[] visited; return true; } }","link":"/2020/08/07/shua-ti-sou-suo-hui-su-mian-shi-ti-hui-su-dfs/"},{"title":"1340. Jump Game V","text":"这个题目还是蛮入门的…… 思路：这题如果采用DP的思想去做，很难。第一，如果设$dp[t][i]$为第i个数字为终点,最多移动t步的情况下最大经过的数字个数，那么DP转移方程就涉及到搜索上一层合理数字，复杂度大增（离线可计算，但是还是不快）。 后面给的第二种算法就是该版本。 第二，如果$dp[t][i]$为第i个数字为起点,最多走t步的最大经过的数字个数，虽然由于顺着题目的意思，相比上一种方法减少了搜索上一层的合理数字，但还是不够快。可以从DP版本1中看出来，许多状态转移的计算都是无谓的。时间复杂度为$O(N^2D)$，即使有一点点剪枝也没法AC。 第三，通过记忆化搜索的方法，可以大幅减少重复计算。 代码：class Solution { public: // f[i]:从i开始最多可以visit的数字 vector&lt;int&gt; f; void dfs(vector&lt;int&gt; &amp;arr, int id, int d, int n){ if(f[id] != -1) return; f[id] = 1; for(int i = id + 1; i &lt; id + d + 1 &amp;&amp; i &lt; n &amp;&amp; arr[id] &gt; arr[i]; i++){ dfs(arr, i, d, n); f[id] = max(f[id], f[i] + 1); } for(int i = id - 1; i &gt; id - d - 1 &amp;&amp; i &gt;= 0 &amp;&amp; arr[id] &gt; arr[i]; i--){ dfs(arr, i, d, n); f[id] = max(f[id], f[i] + 1); } } int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int len = arr.size(); f.resize(len, -1); for(int i = 0;i &lt; len; i++){ dfs(arr, i, d ,len); } return *max_element(f.begin(), f.end()); } }; DP版本1： class Solution { public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int len = arr.size(); vector&lt;int&gt; dp[2]; dp[0].resize(len, 1); dp[1].resize(len, 0); int maxstep = 0, flag = 1; int newl = 0, oldl = 1; while(flag){ flag = 0; swap(newl, oldl); for(int i = 0; i &lt; len; i++){ for(int j = i + 1; j &lt; d + i + 1 &amp;&amp; j &lt; len &amp;&amp; arr[j] &lt; arr[i]; ++j){ int newv = dp[oldl][j] + 1; if(newv &gt; dp[newl][i]){ dp[newl][i] = newv; flag = 1; } } for(int j = i - 1; j &gt; i - d - 1 &amp;&amp; j &gt;= 0 &amp;&amp; arr[j] &lt; arr[i]; --j){ int newv = dp[oldl][j] + 1; if(newv &gt; dp[newl][i]){ dp[newl][i] = newv; flag = 1; } } } } int v = -1; // for(int i = 0; i &lt; len; ++i) // v = max(v, dp[newl][i]); for(int i = 0; i &lt; len; ++i) v = max(v, dp[oldl][i]); return v; } }; DP版本2： class Solution { public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int len = arr.size(); vector&lt;vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(len, 0)); vector&lt;vector&lt;int&gt; &gt; bigger(len,vector&lt;int&gt;(0,0)); vector&lt;int&gt; ischanged(len, 1); for(int i = 0;i &lt; len; i++){ int low = max(0, i - d); int high = min(len - 1, i + d); for(int j = i - 1; j &gt;= low; j--) if(arr[i] &gt; arr[j]) bigger[j].push_back(i); else break; for(int j = i + 1; j &lt;= high; j++) if(arr[i] &gt; arr[j]) bigger[j].push_back(i); else break; } int maxstep = 0, flag = 1; int newl = 0, oldl = 1; while(flag){ flag = 0; swap(newl, oldl); for(int i = 0; i &lt; len; i++){ if(ischanged[i] == 0) continue; ischanged[i] = 0; for(int j = 0; j &lt; bigger[i].size(); j++){ int newv = dp[oldl][bigger[i][j]] + 1; if(newv &gt; dp[newl][i]){ dp[newl][i] = newv; flag = 1; ischanged[i] = 1; } // dp[newl][i] = max(dp[newl][i], dp[oldl][bigger[i][j]] + 1); } maxstep = max(dp[newl][i], maxstep); } } return maxstep + 1; } };","link":"/2020/10/05/shua-ti-sou-suo-ji-yi-hua-sou-suo-1340-jump-game-v/"},{"title":"135. Candy","text":"这题还行吧，一般一般。 135. Candy思路：简单思路：记忆化搜索candy[i]。 更有技巧性：从左到右遍历更新candy[i],再从右到左遍历更新candy. 更大的脑洞：按峰值和谷值计算机总值。 代码：class Solution { public: vector&lt;int&gt; candys; int len; int getcandys(int pos, vector&lt;int&gt;&amp; ratings){ if(candys[pos] == -1){ if(pos == 0 &amp;&amp; ratings[pos] &gt; ratings[pos + 1]) candys[pos] = getcandys(pos + 1, ratings) + 1; else if(pos == len - 1 &amp;&amp; ratings[pos] &gt; ratings[pos - 1]) candys[pos] = getcandys(pos - 1, ratings) + 1; else if(pos &lt; len - 1 &amp;&amp; pos &gt; 0 &amp;&amp; ratings[pos] &gt; min(ratings[pos -1], ratings[pos + 1])){ if(ratings[pos] &gt; ratings[pos - 1]) candys[pos] = getcandys(pos - 1, ratings) + 1; if(ratings[pos] &gt; ratings[pos + 1]) candys[pos] = max(getcandys(pos + 1, ratings) + 1, candys[pos]); } else candys[pos] = 1; } cout &lt;&lt; pos &lt;&lt; candys[pos] &lt;&lt; endl; return candys[pos]; } int candy(vector&lt;int&gt;&amp; ratings) { len = ratings.size(); candys.resize(len, -1); int res = 0; if(len &gt; 1) for(int i = 0;i &lt; len; i++){ res += getcandys(i, ratings); } else return 1; return res; } };","link":"/2020/10/10/shua-ti-sou-suo-ji-yi-hua-sou-suo-135-candy/"},{"title":"154. Find Minimum in Rotated Sorted Array II","text":"154. Find Minimum in Rotated Sorted Array II思路：这题非常具有启发性质，hard~ 虽然还是二分，但是题目条件更加复杂。 话题可视化还是不错的分析方法，可惜我太懒了…… 注意题目的被旋转数组部分可能长度为零。 借用答案的分析思路： 由于数组“右边”的数字一定是未被旋转的，那么一定有$$nums[mid] &lt; num[right] -&gt; 右边有序\\nums[mid] &gt; num[right] -&gt; 左边有序$$ 如此便可以二分，其他情况下，可能存在$$nums[mid] == nums[l] == nums[r]$$无法进行二分，但可以发现，num[r]等于nums[mid]，所以r是可以缩减范围的。 图形化描述见官方题解 代码：class Solution { public: int findMin(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1, mid; if(r &lt; 0) return -1;//bug //加个判断击败14%-&gt;98%,说明大多数人还是直接复制粘粘答案的 if(nums[l] &lt; nums[r]) return nums[l]; while(l &lt; r){ mid = l + (r - l) / 2; if(nums[mid] &lt; nums[r]) r = mid; else if(nums[mid] &gt; nums[r]) l = mid + 1; else r--; } return nums[l]; } };","link":"/2020/11/01/shua-ti-sou-suo-er-fen-154-find-minimum-in-rotated-sorted-array-ii/"},{"title":"81. Search in Rotated Sorted Array II","text":"81. Search in Rotated Sorted Array II思路：这题好像是33题的follow up。 增添了各个元素可能相等的条件。 没做出来。 如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 nums[mid]==nums[l]那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。 跳出这层，能不能直接在二分搜索呢？ 参考题解 // 失败的二分 // class Solution { // public: // bool search(vector&lt;int&gt;&amp; nums, int target) { // int n = nums.size(); // int l = 0, r = n, mid, start = l; // while(l &lt; r){ // mid = (l + r) / 2; // if(nums[mid] &lt; nums[start]) r = mid; // else if(nums[mid] == nums[start]) start++; // else l = mid + 1; // // cout &lt;&lt; l &lt;&lt; endl; // } // // cout &lt;&lt; l &lt;&lt; endl; // vector&lt;int&gt;::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target); // vector&lt;int&gt;::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target); // if( iter1 != nums.end() &amp;&amp; *iter1 == target || iter2 != nums.end() &amp;&amp; *iter2 == target) // return true; // else return false; // } // }; class Solution { public: bool search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int l = 0, r = n - 1, mid, start = l; while(l &lt;= r){ mid = ( r + l) / 2; if(nums[mid] == target) return true; else if(nums[mid] &gt; nums[l]){ if(nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) r = mid - 1; else l = mid + 1; } else if(nums[mid] &lt; nums[l]){ if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) l = mid + 1; else r = mid - 1; } else if(nums[mid] == nums[l]) l++; } return false; } };","link":"/2020/10/30/shua-ti-sou-suo-er-fen-2020-10-30-81-search-in-rotated-sorted-array-ii/"},{"title":"34. Find First and Last Position of Element in Sorted Array","text":"34. Find First and Last Position of Element in Sorted Array 思路：二分 代码：class Solution { public: int getFirst(vector&lt;int&gt; nums, int l, int r, int tar){ if(nums.size() == 0) return -1; int mid ; while(l &lt; r){ mid = (r + l) / 2; if(nums[mid] &lt; tar) l = mid + 1; else r = mid; } // 临界判断需要小心 return l != nums.size() &amp;&amp; nums[l] == tar ? l : -1; } int getLast(vector&lt;int&gt; nums, int l, int r, int tar){ if(nums.size() == 0) return -1; int mid ; while(l &lt; r){ mid = (r + l) / 2; if(nums[mid] &lt;= tar) l = mid + 1; else r = mid; } return l != 0 &amp;&amp; nums[l - 1] == tar ? l - 1 : -1; } vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int s = -1 , e = -1, l = 0, r = nums.size(); vector&lt;int&gt; res({getFirst(nums, 0, nums.size(), target) , getLast(nums, 0, nums.size(), target) }); return res; } };","link":"/2020/10/28/shua-ti-sou-suo-er-fen-34-find-first-and-last-position-of-element-in-sorted-array/"},{"title":"4. Median of Two Sorted Arrays","text":"4. Median of Two Sorted Arrays - 第K大 + 二刷思路：将查找中位数扩大为更广义的解法：求解第$K$位的数字。每次在A,B两个数组中划分出两个k/2个元素，并排除划分出的最后一个数字比较小的数组，然后减去对应的排除的数组的数字个数，更新$K$值。直到$K==1$，或者其中一个数组为空。 详细题解如下 代码：class Solution { public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len1 = nums1.size(), len2 = nums2.size(); int alllen = len1 + len2; if(alllen % 2 == 1){ return findKthNum(nums1, nums2, alllen / 2 + 1); }else return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2; } double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k){ int idx1 = 0, idx2 = 0; int len1 = nums1.size(), len2 = nums2.size(); while(1){ if(idx1 == len1) return nums2[idx2 + k - 1]; if(idx2 == len2) return nums1[idx1 + k - 1]; if(k == 1) return min(nums1[idx1], nums2[idx2]); int half = k / 2; int newidx1 = min(idx1 + half, len1) - 1; int newidx2 = min(idx2 + half, len2) - 1; if(nums1[newidx1] &gt; nums2[newidx2]){ k -= newidx2 - idx2 + 1; idx2 = newidx2 + 1; }else{ k -= newidx1 - idx1 + 1; idx1 = newidx1 + 1; } } } }; // 思考一下follow up // 如果K组有序数据，要选出第K大数据你怎么计算呢？ 扩展一下就可以了！ //以下是二刷，不是followup class Solution { public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len1 = nums1.size(), len2 = nums2.size(); int alllen = len1 + len2; if(alllen % 2 == 1){ return findKthNum(nums1, nums2, alllen / 2 + 1); }else return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2; } // k： 第K个数据（‘第’默认从1开始数起 ） double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k){ int n = nums1.size(), m = nums2.size(); int idx1 = 0, idx2 = 0; while(1){ if(idx1 == n) return nums2[idx2 + k - 1]; // 判断临界点 if(idx2 == m) return nums1[idx1 + k - 1]; if(k == 1) return min(nums1[idx1], nums2[idx2]); // k &gt;= 2 int newidx1 = min(k / 2 + idx1, n) - 1; // min 防止溢出 int newidx2 = min(k / 2 + idx2, m) - 1; if(nums1[newidx1] &gt; nums2[newidx2]){// 结尾数字小的可以直接忽略前串 k -= newidx2 - idx2 + 1; idx2 = newidx2 + 1; // 多进一个数字 }else{ k -= newidx1 - idx1 + 1; idx1 = newidx1 + 1; } } } };","link":"/2020/11/12/shua-ti-sou-suo-er-fen-4-median-of-two-sorted-arrays/"},{"title":"69. Sqrt(x)","text":"这题还是蛮不错的，二分和牛顿迭代法的练习入门题。 69. Sqrt(x) 二分 - 牛顿迭代法思路：二分x或者牛顿迭代计算都可。 代码： class Solution { public: int mySqrt(int x) { long l = 0, r = x, mid; while(l &lt; r){ mid = (l + r) / 2; if(mid * mid &lt; x) l = mid + 1; else r = mid; } if(l * l == x) return l; else return l - 1; } }; ​ 牛顿迭代法 // 牛顿迭代法 class Solution { public: //写的时候瞎想的 挺好用 int mySqrt(int x) { double ans = x, last = ans + 1; double gap = 1e-3; if(x == 0) return 0; while(abs(ans - last) &gt; gap){ last = ans; ans = ans - (ans * ans - x) / (double)(2 * ans); } return int(ans); } }; //上一个方法的公式简化版， 击败100% //而且考虑到了double运算速度慢，精度要求不高，可以使用long来代替，且保证不会遗漏答案。 class Solution { public: int mySqrt(int x) { long res = x; while(res * res &gt; x){ res = (res + x/ res ) /2; } return res; } };","link":"/2020/10/27/shua-ti-sou-suo-er-fen-69-sqrt-x/"},{"title":"75. Sort Colors","text":"75. Sort Colors彩虹题 思路： 直接桶排 有趣的三指针算法。 代码：桶排 class Solution { public: void sortColors(vector&lt;int&gt;&amp; nums) { int count[3] = {0}; for(int i = 0; i &lt; nums.size(); ++i){ count[nums[i]]++; } int k = 0; for(int i = 0; i &lt; 3; ++i){ while(count[i] &gt; 0){ nums[k++] = i; count[i]--; } } } }; 三指针 class Solution { public: void sortColors(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int p0 = 0, p1 = n - 1; for(int i = 0; i &lt;= p1; ++i){ while(nums[i] == 2 &amp;&amp; p1 &gt;= i){ swap(nums[i], nums[p1]); p1--; } if(nums[i] == 0){ swap(nums[p0], nums[i]); p0++; } } } };","link":"/2020/11/17/shua-ti-sou-suo-er-fen-75-sort-colors/"},{"title":"81. Search in Rotated Sorted Array II","text":"81. Search in Rotated Sorted Array II思路：这题好像是33题的follow up。 增添了各个元素可能相等的条件。 没做出来。 如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 nums[mid]==nums[l]那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。 跳出这层，能不能直接在二分搜索呢？ 参考题解 // 失败的二分 // class Solution { // public: // bool search(vector&lt;int&gt;&amp; nums, int target) { // int n = nums.size(); // int l = 0, r = n, mid, start = l; // while(l &lt; r){ // mid = (l + r) / 2; // if(nums[mid] &lt; nums[start]) r = mid; // else if(nums[mid] == nums[start]) start++; // else l = mid + 1; // // cout &lt;&lt; l &lt;&lt; endl; // } // // cout &lt;&lt; l &lt;&lt; endl; // vector&lt;int&gt;::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target); // vector&lt;int&gt;::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target); // if( iter1 != nums.end() &amp;&amp; *iter1 == target || iter2 != nums.end() &amp;&amp; *iter2 == target) // return true; // else return false; // } // }; class Solution { public: bool search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int l = 0, r = n - 1, mid, start = l; while(l &lt;= r){ mid = ( r + l) / 2; if(nums[mid] == target) return true; else if(nums[mid] &gt; nums[l]){ if(nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) r = mid - 1; else l = mid + 1; } else if(nums[mid] &lt; nums[l]){ if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) l = mid + 1; else r = mid - 1; } else if(nums[mid] == nums[l]) l++; } return false; } };","link":"/2021/01/28/shua-ti-sou-suo-er-fen-81-search-in-rotated-sorted-array-ii/"},{"title":"面试题-二分","text":"收集查找二分查找相关题目 面11：旋转数组 题面：旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。 思路：一种就是直接遍历。 更快地可是使用二分法查找元素。依据二分法，记指针有A，B，mid；。若有数组array[mid]&gt;=array[A]则有mid在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则mid在后一个移动过的区间，应该向前半部分二分。 但是由于题面说数据可能不是递增的，所以可能出现array[A]=array[mid]=array[B]的情况，这时如果mid指向移动过的区间就会出现错误，比如1,0,1,1,1，A=0,B=4,mid=2。如何避免呢？只能是直接遍历。 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了array[mid]&lt;=array[A]且array[mid]&gt;array[B]，这个假设一提出来就显得非常的荒谬了。 样例：4,5,6,7,1,2,3 1,1,0,1,1,1,1 1,1,1,1,0,1,1 代码:int Min(int* numbers, int length){ if(numbers == null || length &lt;= 0) throw new std::exception(&quot;Invalid parameters&quot;); int start = 0, end = length - 1, mid; while(start &lt; end){ int mid = ((end - start) &gt;&gt; 1) + start; if(numbers[start] == numbers[mid] == numbers[end] ){ int minNum = numbers[0]; for(int i = 1; i &lt; length; i++) if( numbers[i] &lt; minNum) minNum = numbers[i]; return minNum; } if(numbers[mid] &gt;= numbers[start]) start = mid + 1; else end = mid; } return numbers[end]; } 面53:(待完成)题面：旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。 思路：一种就是直接遍历。 更快地可是使用二分法查找元素。依据二分法，记指针有A，B，mid；。若有数组array[mid]&gt;=array[A]则有mid在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则mid在后一个移动过的区间，应该向前半部分二分。 但是由于题面说数据可能不是递增的，所以可能出现array[A]=array[mid]=array[B]的情况，这时如果mid指向移动过的区间就会出现错误，比如1,0,1,1,1，A=0,B=4,mid=2。如何避免呢？只能是直接遍历。 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了array[mid]&lt;=array[A]且array[mid]&gt;array[B]，这个假设一提出来就显得非常的荒谬了。 样例：4,5,6,7,1,2,3 1,1,0,1,1,1,1 1,1,1,1,0,1,1 代码:","link":"/2020/08/07/shua-ti-sou-suo-er-fen-mian-shi-ti-er-fen/"},{"title":"面试题53 - II. 0～n-1中缺失的数字","text":"好菜啊，二分都不会了写了出了三个bug，还好检查的快。 Leecode的无调试debug还是相当锻炼人的。 简单思路：hash一下每个数据，找出空白值即可。 二分思路：依据前半部分有nums[i] == i的性质，和后半部分nums[i] ！= i的不同可以二分数据，从而找出错位的第一个数据。但是错位的数据不一定是缺少的数据，如果i==len(nums)就可能有缺失数据n−1n−1的可能性。 cpp class Solution { public: // int missingNumber(vector&lt;int&gt;&amp; nums) { // int len = nums.size(); // int *hs = new int[len + 1]; // //未初始化，或者说函数中new的数组初始状态非零 // memset(hs,0, sizeof(int) * (len + 1) ); // for(int i = 0;i &lt; len ; ++i) hs[nums[i]] = 1; // for(int i = 0;i &lt; len + 1; ++i) // if( hs[i] == 0) // return i; // return 0; // } // }; int missingNumber(vector&lt;int&gt;&amp; nums) { int right = nums.size() - 1, left = 0, mid = right; //bug1 边界情况 if(nums[right] == right) return right + 1; while(left &lt; right){ mid = (left + right) / 2; //bug2 二分错误 if( nums[mid] == mid ) left = mid + 1; else if( nums[mid] != mid) right = mid; } //bug3 mid值没被更新, 而 left 和 right 都可以 return left; w } };","link":"/2020/08/07/shua-ti-sou-suo-er-fen-mian-shi-ti-53-ii-0-n-1-zhong-que-shi-de-shu-zi/"},{"title":"1. Two Sum","text":"1. Two Sum思路：hash即可 练习一下 STL。 代码：class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_set&lt;int&gt; sset; map&lt;int, int&gt; ridx; for(int i = 0; i &lt; nums.size(); ++i){ int k = nums[i]; if(sset.count(target - k)){ return {ridx[target - k], i}; } sset.insert(k); ridx[k] = i; } return {0 , 0}; } }; 直接用map更好 class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { map&lt;int, int&gt; ridx; for(int i = 0; i &lt; nums.size(); ++i){ int k = nums[i]; if(ridx.count(target - k)){ return {ridx[target - k], i}; } ridx[k] = i; } return {0 , 0}; } };","link":"/2021/01/25/shua-ti-shu-ju-jie-gou-set-1-two-sum/"},{"title":"128. Longest Consecutive Sequence","text":"128. Longest Consecutive Sequence思路： sort排序 用set去重，在序列的第一个数字上搜索连续数字长度值！ 代码：sort class Solution { public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; sort(nums.begin(), nums.end()); int mlen = 1, len = 1; for(int i = 1; i &lt; nums.size(); ++i){ if(nums[i] == nums[i - 1] + 1){ len++; }else if(nums[i] != nums[i - 1]) len = 1; mlen = max(mlen, len); } return mlen; } }; set优化 class Solution { public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int mlen = 1; unordered_set&lt;int&gt; sset; for(auto &amp;v : nums) sset.insert(v); for(auto &amp;v : sset){ if(sset.count(v - 1)) continue; // 只有连续序列的第一个数才能计算后续长度 int len = 1; while(sset.count(len + v)){ len++; } mlen = max(mlen, len); // cout &lt;&lt; v &lt;&lt; ' ' &lt;&lt; len; // unordered_set 遍历的数字不是有序的 } return mlen; } };","link":"/2021/01/25/shua-ti-shu-ju-jie-gou-set-128-longest-consecutive-sequence/"},{"title":"23. Merge k Sorted Lists","text":"23. Merge k Sorted Lists思路：优先队列排node就行。 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { class Node{ public: ListNode *p; Node(ListNode *_p): p(_p){} friend bool operator &lt; (Node p1, Node p2){ return p1.p-&gt;val &gt; p2.p-&gt;val; } // friend bool operator &lt; (string s1, string s2){ // return s1.name &lt; s2.name; // } }; priority_queue&lt;Node&gt; pq; public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { for(auto &amp;p : lists) if(p) pq.push(Node(p)); ListNode *root , *p, *oldp; p = nullptr; oldp = root = new ListNode(); while(pq.size()){ p = pq.top().p; pq.pop(); if(p-&gt;next) pq.push(Node(p-&gt;next)); oldp-&gt;next = p; oldp = p; } return root-&gt;next; } };","link":"/2021/01/24/shua-ti-shu-ju-jie-gou-you-xian-dui-lie-23-merge-k-sorted-lists/"},{"title":"149. Max Points on a Line","text":"149. Max Points on a Line思路：思路差不多，但是走歪了。害~ 整体思路是两层嵌套的for循环。两点可以确定一条直线，那么选择固定一个点，求其他点与固定点的斜率，如果斜率相同，那么斜率相同的点在同一条直线上。同时要考虑，斜率可能为无穷大，也有可能两个点为同一个点。键值应该为斜率。 通过dup记录这一次内层循环中与p1相同的点。通过one_round_res统计每一次内层for循环的结果。将斜率无穷大定义为FLT_MAX。 键值key为斜率，其数据类型选择为long double即可通过vector&lt;vector&lt;int&gt;&gt; points = { {0,0},{94911150,94911151},{94911151,94911152} };来源：力扣（LeetCode） 代码：class Solution { public: int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if(points.size() == 0 ) return 0; int maxct = 1; for(int i = 0; i &lt; points.size(); ++i){ // 记录经过一个点所有直线，即使斜率为无穷大 // 因为只有一个点，无需记录直线公式中的x = c 和 x = k * y + b 中的 c, b unordered_map&lt;long double, int&gt; record; int ct = 1; int depu = 0; for(int j = i + 1; j &lt; points.size(); ++j){ auto p1 = points[i]; auto p2 = points[j]; if(p1 == p2){ // 重合点 ++depu; continue; } if(p1[0] &gt; p2[0]) swap(p1, p2); if(p2[0] == p1[0]){ ct = max(ct, ++record[DBL_MAX] + 1); }else{ long double k = (long double)(p2[1] - p1[1]) / (p2[0] - p1[0]); // double b = p2[1] - k * p2[0]; ct = max(ct, ++record[k] + 1); } } maxct = max(maxct, ct + depu); } return maxct; } };","link":"/2021/01/27/shua-ti/shu-ju-jie-gou/ha-xi/149-max-points-on-a-line/"},{"title":"210. Course Schedule II (Medium)","text":"210. Course Schedule II思路： dfs + 判环 + 回溯 入度 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; stack&lt;int&gt; track; vector&lt;int&gt; vis; int flag = 0; vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { map.resize(numCourses); vis.resize(numCourses); for(auto e : prerequisites){ int u = e[0], v = e[1]; map[v].emplace_back(u); } for(int i = 0; i &lt; numCourses; ++i) if(!vis[i]) dfs(i); vector&lt;int&gt; ans; while(!track.empty()){ ans.emplace_back(track.top()); track.pop(); } if(flag) return {}; else return ans; } void dfs(int u){ vis[u] = -1; for(auto v : map[u]){ if(!vis[v]){ dfs(v); }else if(vis[v] == -1){ // 如果第一次遍历到一个环，那么这个环一定会被全部遍历到 flag = 1; } } vis[u] = 1; track.push(u); } }; class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; indegrees; queue&lt;int&gt; que; int flag = 0; vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { map.resize(numCourses); indegrees.resize(numCourses); for(auto e : prerequisites){ int u = e[0], v = e[1]; map[v].emplace_back(u); ++indegrees[u]; } for(int i = 0; i &lt; numCourses; ++i) if(!indegrees[i]) que.push(i); vector&lt;int&gt; ans; while(!que.empty()){ int t = que.front(); ans.push_back(t); que.pop(); for(auto v : map[t]){ --indegrees[v]; if(indegrees[v] == 0) que.push(v); } } if(ans.size() != numCourses) return {}; else return ans; } };","link":"/2021/02/27/shua-ti-shu-ju-jie-gou-tu-210-course-schedule-ii-medium/"},{"title":"332. Reconstruct Itinerary","text":"332. Reconstruct Itinerary图论补充知识： 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。 具有欧拉回路的无向图称为欧拉图。 具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。 因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。 如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地： 对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。 对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2个奇度顶点。 对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。 对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且 恰有一个顶点的出度与入度差为 1； 恰有一个顶点的入度与出度差为 1； 所有其他顶点的入度和出度相同。 思路：首先，以站点为点，tickets为单向边，可建有向图。 题目保证了欧拉图的存在，我们需要在图上寻找一条字母序最小的欧拉通路。我们可以使用Hierholzer 算法求出该通路，其中优先遍历字母序最小的站点即可。 Hierholzer 算法算法流程如下： 从某点开始出发，遍历该图 每次移动后，删除刚刚经过的边（DFS） 当遍历该节点结束后，也就是没有其他路径可走，把节点记录下来。 因为每次记录的节点都是当时遍历时最后退出的节点，所以必定比之前压入的节点在欧拉图前，同时由于删边的性质和起点是欧拉通路的起点，保证了路径的有效性。所以一定能搜到。 一开始把票当成点，相同的点当成边，把简单的欧拉问题变成了复杂的旅行商问题，我干！ 代码：class Solution { public: map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;&gt; vec; vector&lt;string&gt; path; void dfs(string curr){ while(vec.count(curr) &amp;&amp; vec[curr].size()){ string tmp = vec[curr].top(); vec[curr].pop(); dfs(tmp); } path.emplace_back(curr); } vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) { for(auto &amp;item : tickets){ vec[item[0]].push(item[1]); } dfs(&quot;JFK&quot;); reverse(path.begin(), path.end()); return path; } };","link":"/2021/01/28/shua-ti-shu-ju-jie-gou-tu-332-reconstruct-itinerary/"},{"title":"785. Is Graph Bipartite?","text":"785. Is Graph Bipartite?思路：二分图染色问题，实际是就是判断任意一条边的形式是否有矛盾。 $O(E +N )$ 代码：class Solution { public: int flag = 0; vector&lt;int&gt; color; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); color.resize(n, 0); for(int i = 0;i &lt; n; ++i){ if(color[i] == 0) colorize(graph, i, 1); if(flag) return false; } return true; } void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u, int ctype){ if(color[u]){ if(color[u] * ctype == -1) flag = 1; return; } color[u] = ctype; for(auto v : graph[u]) colorize(graph, v, -ctype); } };","link":"/2021/02/24/shua-ti-shu-ju-jie-gou-tu-785-is-graph-bipartite/"},{"title":"847. 访问所有节点的最短路径","text":"847. 访问所有节点的最短路径思路：旅行商问题~真难！ DFS搜索dfs搜索回溯貌似可行，但是没有明确的停止条件 BFS搜索bfs搜索状态state(cover, head)可行。其中cover用位状态表示搜索过的节点的集合，head表示当前遍历的头结点。搜索的更新的new cover = cover | 1 &lt;&lt; newhead。 代码巧妙在于直接存储节点，而非路径，压缩了搜索范围。 实践发现如此简单的思路还是会超时！ 考虑用dist[cover][head]记录最短路状态，减少搜索范围。 DAG化DP计算在上述思路的前提下，dist[cover][head]在更新之后总有newcover&gt;=cover。把dist当成一个图，而这个图保证了DAG的性质成立，那我们可以用DP方法计算最短路。在正向遍历cover到1&lt;&lt;N，遍历时尝试用不同的边进行更新。 注意，更新计算可能会更新到相同cover集，即重复遍历了节点，那么需要再次尝试更新！ 复杂度说明一共有$2^N*N$种状态，而每种状态的更新最多N次计算。所以复杂度是O(2^N*N^2) 代码： class Solution { queue&lt;pair&lt;int, int&gt;&gt; que; // queue of statue and head. public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int times = 0;; int n = graph.size(), visall = (1 &lt;&lt; n) - 1; vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, n * n)); for(int i = 0; i &lt; n; ++i){ que.push({1 &lt;&lt; i, i}); dist[1 &lt;&lt; i][i] = 0; } while(que.size()){ auto [cover, head] = que.front(); que.pop(); int d = dist[cover][head]; if(cover == visall) return d; for(auto v : graph[head]){ int newcover = cover | 1 &lt;&lt; v; if(d + 1 &lt; dist[newcover][v]){ que.push({newcover, v}); dist[newcover][v] = d + 1; } } } return 0; } }; class Solution { vector&lt;int&gt; trace; vector&lt;int&gt; newtrace; map&lt;pair&lt;int, int&gt;, int&gt; linker; set&lt;int&gt; intarce; int n; public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { n = graph.size(); for(int i = 0; i &lt; n; ++i){ // cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; endl; dfs(graph, i); } return trace.size() - 1; } inline pair&lt;int, int&gt; minpair(int a, int b){ if(a &gt; b ) return {b, a}; return {a, b}; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u){ newtrace.push_back(u); intarce.insert(u); // for(auto c : newtrace) cout &lt;&lt; c &lt;&lt; ' ' ; // cout &lt;&lt; endl; if(intarce.size() == n){ if(trace.size() == 0 || trace.size() &gt; newtrace.size()){ trace = newtrace; } }else{ for(auto v : graph[u]){ if(++linker[minpair(u, v)] &lt;= 4){ dfs(graph, v); } --linker[minpair(u, v)]; } } newtrace.erase(newtrace.end() - 1); intarce.erase(u); } }; DAG class Solution { queue&lt;pair&lt;int, int&gt;&gt; que; // queue of statue and head. public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int times = 0;; int n = graph.size(), visall = (1 &lt;&lt; n) - 1; const int maxlen = n * n; vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, maxlen)); for(int i = 0; i &lt; n; ++i){ dist[1 &lt;&lt; i][i] = 0; } for(int cover = 1; cover &lt;= visall; ++cover){ bool repeat = true; while(repeat){ repeat = false; for(int u = 0; u &lt; n; ++u){ if(dist[cover][u] == maxlen) continue; // jump over the states no exist. int d = dist[cover][u]; for(auto v : graph[u]){ int newcover = cover | (1 &lt;&lt; v); if(d + 1 &lt; dist[newcover][v]){ dist[newcover][v] = d + 1; if(newcover == cover) repeat = true; // if visited node set is the same as last set, just update again. } } } } } int minans = maxlen; for(auto c : dist[visall]) minans = min(minans, c); return minans; } };","link":"/2021/05/08/shua-ti-shu-ju-jie-gou-tu-847-fang-wen-suo-you-jie-dian-de-zui-duan-lu-jing/"},{"title":"882. Reachable Nodes In Subdivided Graph","text":"思路：subdivision nodes可以化为路径的长度，将此问题转化为可以用dijstra求解的问题。 每次遍历到最新最短的节点都可以进行求出此点相连的边的可以累加subdivistion nodes的个数，但是需要控制重复累加比较麻烦。最后采用记录下每条边可到达的点，最后统一累计即可。 代码：class Solution { public: vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; road; vector&lt;int&gt; vis, dis; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; map&lt;pair&lt;int, int&gt;, int&gt; used; // 其实dijsktra算法对于是可以做到每subdivision nodes只更新一次的，但是不好计算; int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { road.resize(n); vis.resize(n); dis.resize(n, INT_MAX); for(auto e : edges){ road[e[0]].emplace_back(e[1], e[2] + 1); road[e[1]].emplace_back(e[0], e[2] + 1); // node, subdivision nodes + 1 = distantce } pq.push({0, 0}); // distance, node; dis[0] = 0; int sumnode = 0; while(pq.size()){ auto [_, u] = pq.top(); pq.pop(); // cout &lt;&lt; u &lt;&lt; endl; if(vis[u]) continue; if(dis[u] &gt; maxMoves) break; vis[u] = 1; ++sumnode; for(auto [v, len] : road[u]){ if(dis[v] &gt; dis[u] + len){ dis[v] = dis[u] + len; pq.push({dis[v], v}); } used[{u, v}] = min(dis[u] + len, maxMoves) - dis[u]; } } for(auto edges : edges){ int u = edges[0], v = edges[1], len = edges[2]; sumnode += min(used[{u, v}] + used[{v, u}], len); } return sumnode; } };","link":"/2021/03/02/shua-ti-shu-ju-jie-gou-tu-882-reachable-nodes-in-subdivided-graph/"},{"title":"二分图匹配","text":"二分图匹配二分图匹配是个经典问题——两组节点在图上尽可能的匹配。 匈牙利算法以不断寻找增光路的方式，寻找更多的匹配; 思想如下： 从未匹配的点c开始寻找链接的点v，如果v也是未匹配，则匹配成功。如果该点已经匹配了u，则递归尝试让u匹配其他节点。 如果v匹配失败，那就找找c的其他点。 题解参考 模板写法const int N=605; const int n=105; vector&lt;int&gt; g[N]; int from[N], tot=0; bool use[N]; bool match(int x){ for(int i=0; i&lt;g[x].size(); ++i) if(!use[g[x][i]]){ use[g[x][i]]=true; if(from[g[x][i]]==-1 || match(from[g[x][i]])){ from[g[x][i]]=x; return true; } } return false; } int hungary(){ tot=0; memset(from, -1, sizeof from); for(int i=1; i&lt;=n; ++i){ memset(use, 0x00, sizeof use); if(from[i] != -1 &amp;&amp; match(i)) ++tot; } return tot; } 二分图染色问题785. 判断二分图思路：炫酷的lambda写法~ 代码：class Solution { public: int flag = 0; vector&lt;int&gt; color; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); int colors[n]; memset(colors, -1, sizeof colors); function&lt;bool(int, int)&gt; dfs = [&amp;](int node, int color) -&gt; bool { colors[node] = color; for(auto c : graph[node]){ if(colors[c] == -1 &amp;&amp; !dfs(c, 1 - color)) return false; if(colors[c] == color) return false; } return true; }; for(int i = 0; i &lt; n; ++i) if(colors[i] == -1 &amp;&amp; !dfs(i, 1)) return false; return true; } }; 棋盘覆盖思路：棋盘就是个抽象的图。 二分图思路做下来就行。 代码：#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int N = 105; using PII = pair&lt;int,int&gt;; int n, m; bool maze[N][N]; PII match[N][N]; // 直接存储匹配量，比较方便~ bool vis[N][N]; int dx[] = {-1, 0, 0, 1}; //1 与 4 对应 int dy[] = {0, 1, -1, 0}; // 2与3 对应 bool find(int x, int y){ // vis[x][y] = 1; for(int i = 0 ;i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;&amp; nx &lt;= n &amp;&amp; ny &amp;&amp; ny &lt;= n &amp;&amp; !maze[nx][ny] &amp;&amp; !vis[nx][ny]){ // 访问有效的，不在该次扩展中访问过的节点 vis[nx][ny] = 1; // 该节点已经访问 auto t1 = match[nx][ny].first; auto t2 = match[nx][ny].second; if(t1 == -1 || find(t1, t2)){ // 如果该节点未匹配或者该节点的匹配被更新了 match[x][y] = {nx, ny}; match[nx][ny] = {x, y}; return true; } } } return false; } int main(){ int a, b; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while(m--){ scanf(&quot;%d%d&quot;, &amp;a, &amp;b); maze[a][b] = 1; } memset(match, -1, sizeof match); int cnt = 0; for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= n; ++j){ // if((i+j)&amp;0x01 &amp;&amp; !maze[i][j]){ // 为什么不排除已匹配成功的节点 if(match[i][j].first != -1 &amp;&amp; !maze[i][j]){ // 为什么不排除已匹配成功的节点 memset(vis, 0x00, sizeof vis); if(find(i, j)) cnt++; } } } printf(&quot;%d&quot;, cnt); return 0; }","link":"/2021/05/09/shua-ti-shu-ju-jie-gou-tu-er-fen-tu-pi-pei/"},{"title":"割点算法","text":"割点算法Tarjan割点算法 引入了建立在DFS生成树的遍历节点的时间戳概念，如果一个节点u的子节点v可以找到一条不经过u以外的路径到达u的祖先，那么显然有一条通路可以回到u的祖先。反之，如果存在v找不到这么一条路径回到u的祖先，那么显然u是一个割点，他分割了v所在的子树和其他子树（如果u不是根的话，包括祖先所在子树）。 那么一个割点有多少子树呢？首先，一个割点的对应的v是独立在各个子树的吗？是的，如果存在v1和v2都找到路径，且在一个子树中，那么必然有v1可以通过v2找到u，那么在DFS搜索的时候，必定会一次遍历v1和v2。所以每个割点对应的子树只会搜索到一个v。扩展一下， 那么经过去掉割点的图最多有几个连通块？ POJ 2117 Electricity 参考解答 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int N = 10005; const int M = 30005; int tot; int to[M], nxt[M], head[M]; // graph 链式前向星存储方式 int dfn[N]; int low[N]; int ts; int n, m; int bp, cnt; int root; void add(int u, int v){ // connstruct graph; ++tot; to[tot] = v; nxt[tot] = head[u]; head[u] = tot; } void tarjan(int u){ // cout &lt;&lt; u &lt;&lt; ' '; int subtree = 0; dfn[u] = low[u] = ++ts; for(int i = head[u]; i; i = nxt[i]){ int v = to[i]; if(dfn[v]) low[u] = min(low[u], dfn[v]); else{ tarjan(v); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) ++subtree;; // 节点u是割点，且割点对应的子节点v是在一个被分割子树中 } } if( u != root) ++subtree; bp = max(bp, subtree); } int main(){ while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m){ ts = tot = bp = cnt = 0; memset(head, 0x00, sizeof head); // to 和 edge 不需要重置 memset(dfn, 0x00, sizeof dfn); memset(low, 0x00, sizeof low); int a ,b; while(m--){ scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); add(b, a); } for(root = 0; root &lt; n; ++root){ if(!dfn[root]){ tarjan(root); cnt++; } } printf(&quot;%d\\n&quot;, cnt + bp - 1); } return 0; } 补充知识点 前向星 链式前向星 前向星不过是把边按出发点排序并顺序存储下来， 通过记录首部位置来遍历；链式前向星更进一步，通过在头部位置记录边的地点，同时以静态方式存储边，在静态边中存储下下条边的地址。 最后还有常用的对拍程序： #!/bin/sh g++ $1 -o ./a.out ./a.out &lt; input &gt; myoutput diff myoutput output -s -u","link":"/2021/05/09/shua-ti-shu-ju-jie-gou-tu-ge-dian-suan-fa/"},{"title":"347. Top K Frequent Elements","text":"思路:map记录出现初次， 堆维护前K大 代码： class Solution { public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end()); map&lt;int, int&gt; counter; map&lt;int, int&gt;::iterator iter; priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int,int&gt; &gt; &gt; pq; for(auto i : nums) counter[i]++; iter = counter.begin(); pair&lt;int, int&gt; tp; int s1, s2, e1, e2; // cout &lt;&lt; counter.size() &lt;&lt; endl; while(iter != counter.end()){ s1 = iter-&gt;first; s2 = iter-&gt;second; if(pq.size() == k){ tp = pq.top(); e2 = tp.first; e1 = tp.second; if(e2 &lt; s2){ pq.pop(); pq.push(make_pair(s2, s1)); } }else pq.push(make_pair(s2, s1)); iter++; } vector&lt;int&gt; ans; while(pq.size() &gt; 0){ ans.push_back(pq.top().second); pq.pop(); } return ans; } };","link":"/2020/11/15/shua-ti-shu-ju-jie-gou-dui-347-top-k-frequent-elements/"},{"title":"380. Insert Delete GetRandom O(1)","text":"思路：要求插入，删除，随机获取元素用$O(1)$ 不要求数据有序，也不要要求数据按原序。 hash + 动态数组即可。 删除的时候，交换待删除元素到动态数组末就行了。 代码： class RandomizedSet { vector&lt;int&gt; arr; unordered_map&lt;int, int&gt; idx; public: /** Initialize your data structure here. */ RandomizedSet() { } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { if(idx.count(val)){ return false; } arr.push_back(val); idx[val] = arr.size() - 1; return true; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { if(!idx.count(val)) return false; int pos = idx[val]; idx[arr[arr.size() - 1]] = pos; swap(arr[pos], arr[arr.size() - 1]); arr.pop_back(); idx.erase(val); return true; } /** Get a random element from the set. */ int getRandom() { return arr[random() % arr.size()]; } }; /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj-&gt;insert(val); * bool param_2 = obj-&gt;remove(val); * int param_3 = obj-&gt;getRandom(); */","link":"/2021/03/03/shua-ti/shu-ju-jie-gou/fu-za-shu-ju-jie-gou/380-insert-delete-getrandom-o-1/"},{"title":"706. Design HashMap","text":"思路思路： hash table 配置 STL强大的API包装完成了。 代码：class MyHashMap { vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; data; static const int base = 1931; static int hash(int key){ return key % base; } auto findit(int key, int pos){ auto iskey = [key](pair&lt;int, int&gt; item){return item.first == key;}; return find_if(data[pos].begin(), data[pos].end(), iskey); } public: /** Initialize your data structure here. */ MyHashMap() { data.resize(1931); // erase不会检查尾指针 // int key = 0, pos = 0; // auto it = findit(key, pos); // cout &lt;&lt; &quot;start&quot; &lt;&lt; key &lt;&lt; endl; // data[pos].erase(it); } /** value will always be non-negative. */ void put(int key, int value) { int pos = hash(key); auto it = findit(key, pos); if(it == data[pos].end()) data[pos].insert(it, {key, value}); else it-&gt;second = value; } /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) { int pos = hash(key); auto it = findit(key, pos); // cout &lt;&lt; &quot;find&quot; &lt;&lt; key &lt;&lt; endl; return it == data[pos].end() ? -1 : (*it).second; } /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) { int pos = hash(key); auto it = findit(key, pos); // cout &lt;&lt; &quot;remove&quot; &lt;&lt; key &lt;&lt; endl; if(it != data[pos].end()) data[pos].erase(it); } }; /** * Your MyHashMap object will be instantiated and called as such: * MyHashMap* obj = new MyHashMap(); * obj-&gt;put(key,value); * int param_2 = obj-&gt;get(key); * obj-&gt;remove(key); */","link":"/2021/03/15/shua-ti/shu-ju-jie-gou/fu-za-shu-ju-jie-gou/706-design-hashmap/"},{"title":"155. Min Stack","text":"155. Min Stack思路：用另一个栈保存另一个栈的各个元素插入，删除后的最小值。 他利用这么一个现象：后插入的大元素不会影响这个栈的最小值，反之小元素会改变。那么只要把此时小元素插入到最小栈即可，同理删除元素的时候也按值删除。 代码：class MinStack { stack&lt;int&gt; s1, mins; public: /** initialize your data structure here. */ MinStack() { } void push(int x) { s1.push(x); if(mins.empty() || mins.top() &gt;= x){ mins.push(x); } } void pop() { if(s1.size()){ int f = s1.top(); s1.pop(); if(mins.size() &amp;&amp; f == mins.top()){ mins.pop(); } } } int top() { return s1.top(); } int getMin() { return mins.top(); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */","link":"/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/155-min-stack/"},{"title":"20. Valid Parentheses","text":"20. Valid Parentheses思路：用栈判断即可。 代码：class Solution { stack&lt;char&gt; sta; public: bool isValid(string s) { for(auto c : s){ if(c == '(' || c == '[' || c == '{'){ sta.push(c); continue; } if(sta.size()){ char topc = sta.top(); switch(topc){ case '(' : if(c == ')') sta.pop(); else return false; break; case '[' : if(c == ']') sta.pop(); else return false; break; case '{' : if(c == '}') sta.pop(); else return false; break; } }else return false; } if(sta.empty()) return true; else return false; } }; map简洁写法 class Solution { stack&lt;char&gt; sta; public: bool isValid(string s) { map&lt;char, char&gt; pairs = { {'[',']'}, {'(', ')'}, {'{', '}'} }; for(auto c : s){ if(pairs.count(c)){ sta.push(c); } else{ if(sta.empty() || pairs[sta.top()] != c) return false; sta.pop(); } } return sta.empty(); } };","link":"/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/20-valid-parentheses/"},{"title":"225. Implement Stack using Queues","text":"225. Implement Stack using Queues思路：其实我想到了，但是这个效率真的差。 代码：class MyStack { queue&lt;int&gt; q1, q2; public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { q2.push(x); while(q1.size()){ q2.push(q1.front()); q1.pop(); } swap(q1 ,q2); } /** Removes the element on top of the stack and returns that element. */ int pop() { int temp = q1.front(); q1.pop(); return temp; } /** Get the top element. */ int top() { return q1.front(); } /** Returns whether the stack is empty. */ bool empty() { return q1.size() == 0; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */","link":"/2021/01/30/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/225-implement-stack-using-queues/"},{"title":"232. Implement Queue using Stacks","text":"232. Implement Queue using Stacks思路：两个队列一个入队元素，一个出队元素。 代码：class MyQueue { stack&lt;int&gt; s1, s2; public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { s1.push(x); // cout &lt;&lt; x &lt;&lt; endl; } /** Removes the element from in front of queue and returns that element. */ int pop() { if(s2.size() == 0){ while(s1.size()){ s2.push(s1.top()); s1.pop(); } } if(s2.size() == 0) return -1; int t = s2.top(); s2.pop(); return t; } /** Get the front element. */ int peek() { if(s2.size() == 0){ while(s1.size()){ s2.push(s1.top()); s1.pop(); } } return s2.top(); } /** Returns whether the queue is empty. */ bool empty() { return s1.size() == 0 &amp;&amp; s2.size() == 0; } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */","link":"/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/232-implement-queue-using-stacks/"},{"title":"239. Sliding Window Maximum","text":"239. Sliding Window Maximum思路：想了三种方法： 朴素地确认最大值是否在窗口内 使用优先队列维护窗口中的最值，但是需要注意最值是否还在窗口内 使用单调双头队列维护窗口内的单调队列 方法3的单调队列其实和单调栈的性质如出一辙，只不过换了个队列的性质。 代码：tle class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(k &gt; n) return vector&lt;int&gt;(); vector&lt;int&gt; ans(n - k + 1); auto p = max_element(nums.begin(), nums.begin() + k); ans[0] = *p; for(int i = 1; i &lt; n - k + 1; ++i){ if(nums[i - 1] == *p){ p = max_element(nums.begin() + i, nums.begin() + i + k); } if(*(nums.begin() + i + k - 1) &gt; *p) p = nums.begin() + i + k - 1; ans[i] = *p; } return ans; } }; 优先队列 $o(nlogn)$ class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(k &gt; n) return vector&lt;int&gt;(); vector&lt;int&gt; ans(n - k + 1); priority_queue&lt;pair&lt;int, int&gt;&gt; pq; for(int i = 0; i &lt; k; ++i) pq.push({nums[i], i}); ans[0] = pq.top().first; for(int i = 1; i &lt; n - k + 1; ++i){ pq.push({nums[i + k - 1], i + k - 1}); auto [val, idx] = pq.top(); while(idx &lt; i){ pq.pop(); val = pq.top().first; idx = pq.top().second; } ans[i] = val; } return ans; } }; 双头单调队列！ class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(k &gt; n) return vector&lt;int&gt;(); vector&lt;int&gt; ans(n - k + 1); deque&lt;int&gt; que; // 单调递减的队列 for(int i = 0; i &lt; n; ++i){ if(i &gt;= k &amp;&amp; nums[i - k] == que.front()){ // 特定元素删除pop que.pop_front(); } int t = nums[i]; while(que.size() &amp;&amp; que.back() &lt; t){ // 很像单调栈的维护过程 que.pop_back(); } que.push_back(t); if(i &gt;= k - 1) ans[i - k + 1] = que.front(); // 记录 } return ans; } };","link":"/2021/01/25/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/239-sliding-window-maximum/"},{"title":"32. Longest Valid Parentheses","text":"思路：栈验证匹配括号很简单，但是用如何获取多个匹配成功的括号组合长度就很麻烦！ 难的是想到，连续的有效括号()())()()只需要记录一个最先未匹配的位置。具体做法是，在栈中存储一个最后没有匹配到的右括号下标。 代码class Solution { public: int longestValidParentheses(string s) { int maxlen = 0; stack&lt;int&gt; st; st.push(-1); // 压入一个最后未匹配的)。 for(int i = 0; i &lt; s.size(); ++i){ if(s[i] == ')'){ st.pop(); if(!st.empty()){ // 刚刚的）匹配成功，可以计算最长匹配 maxlen = max(maxlen, i - st.top()); }else st.push(i); // 说明该)没有匹配到，是新的最后的最右括号 }else st.push(i); } return maxlen; } };","link":"/2021/04/25/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/32-longest-valid-parentheses/"},{"title":"503. Next Greater Element II","text":"503. Next Greater Element II思路：单调栈！比较更大值的神。 遍历数组维护单调栈，在排除栈中更小的元素时，就已经为他们找到了更大值。为了保证数组是环形查找的，可以插入两次数组元素。 代码：class Solution { public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; bigger(n, -1); stack&lt;pair&lt;int, int&gt;&gt; sta; for(int i = 0; i &lt; 2; ++i){ for(int j = 0; j &lt; n; ++j){ while(sta.size() &amp;&amp; sta.top().second &lt;nums[j]){ auto [pos, num] = sta.top(); sta.pop(); if(bigger[pos] == -1 )bigger[pos] = nums[j]; } sta.push({j, nums[j]}); } } return bigger; } };","link":"/2021/01/30/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/503-next-greater-element-ii/"},{"title":"98. Validate Binary Search Tree","text":"98. Validate Binary Search Tree思路：不要把二叉树的性质搞错了，是任一个节点的值大于其所有左节点的值，小于等于所有右节点的值，而非左节点。 如此直接验证所有节点的是否大于左子树的最大值，小于右子树的最小值即可。 代码/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ // class Solution { // public: // bool isValidBST(TreeNode* root) { // if(!root) return true; // bool flag = (root-&gt;right ? (root-&gt;val &lt; root-&gt;right-&gt;val) : true) // &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; root-&gt;left-&gt;val) : true); // return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left); // } // }; class Solution { public: inline TreeNode* minNode(TreeNode* root){ while(root-&gt;left) root = root-&gt;left; return root; } inline TreeNode* maxNode(TreeNode* root){ while(root-&gt;right) root = root-&gt;right; return root; } bool isValidBST(TreeNode* root) { if(!root) return true; bool flag = (root-&gt;right ? (root-&gt;val &lt; minNode(root-&gt;right)-&gt;val) : true) &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; maxNode(root-&gt;left)-&gt;val) : true); return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left); } };","link":"/2021/04/22/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/98-validate-binary-search-tree/"},{"title":"面试题-栈和队列","text":"收集了栈和队列相关题目。 面试9：两个栈实现队列 题面：如题 思路：栈是FILO结构，将两个栈的结合起来就可以达到FIFO的效果。 代码：template &lt;typename T&gt; class CQueue { public: CQueue(void); ~CQueue(void); void appendTail(const T&amp; node){ stack2.push(node); } T deleteHead(){ if(stack1.empty()){ while(!stack2.empty()){ stack1.push(stack2.top()); stack2.pop(); } } //弹空栈应抛出异常 if(stack1.empty()) throw new exception(&quot;queue is empty.&quot;); T topValue = stack1.top(); stack1.pop(); return topValue; } private: stack&lt;T&gt; stack1, stack2; } 面试题9相关题：两个队列实现栈//思考了一下只能用一个队列循序存储数据，在插入操作时直接插入。删除时把一个队列的除了最后一个其他数据顺序放到临时存储队列，最后删除最后一个数据。 包含min函数的栈题面：给定栈的数据结构，要求实现对栈的操作min，push，pop，并且复杂度为O(1)O(1)。 思路：这题的难度不在于思维，而在于一种思想。为了保持栈FILO的特性，必须有一个栈负责存储原数据。但是如何实现min？一开始的想法是维护一个递增的栈，但是明显的复杂度高，且不易维护。简单如我没有想到可以直接维护一个每一个元素都代表着当前被压入栈时的栈的最小值的状态栈。也就是说在数据压入栈的时候求出之前记录的最小值和被压入元素的最小值，然后压入状态栈。pop的时候也很简单，直接两个栈都pop就ok。 可以这么做的理由，是栈的min值是与将来无关的，仅与过去有关，换句话说就是状态值仅与当前栈的内容有关。 好优雅。 class StackMin{ private: stack&lt;int&gt; s, sMin; public: void push(int x){ if(sMin.size() &gt; 0) sMin.push(min(x, sMin.top())); else sMin.push(x); s.push(x); } void pop(){ if(sMin.size() == 0) return; sMin.pop(); s.pop(); } int min(){ if(sMin.size() &gt; 0) return sMin.top(); else throw new exception(); } } 错误：没有检查栈的元素数量。 面31：合法的栈的弹出序列题面：给出一个按增序的数字序列1，2，3，4……压入栈的序列， 同时给出一个对应数字的弹出序列，判断弹出序列是否是压入序列的弹出序列。 思路：不考虑数据的错误输入的话。一个简单而自然的思路就是模拟，建立一个辅助栈。对于弹出序列的当前数据，如果比栈顶数据大或者栈没有数据，则压入数据，直到栈顶和当前弹出序列的值一样大。如果等于栈顶数据，弹出栈顶。如果比栈顶数据小，则序列错误。如果正常运行结束则序列正确。 不太容易讲清楚，最好举个例子。 想了一丢丢，终于讲清楚了。重点在于判断模拟过程的条件需要缕清。 样例：true: 1,2,3 1,2,3 1,2,3 3,2,1 1,2,3 3,1,2 1,2,3,4,5,6 3,4,2,5,1,6 1,2,3,4,5,6 3,4,2,6,1,5 代码：bool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop){ stack&lt;int&gt; s; int pushMax = 0; if(lenPush != lenPop) return false; for(int i = 0; i &lt; lenPush; i++){ if(s.empty() || aPush[i] &gt; s.top()){ int k = pushMax + 1; while(k &lt;= aPush[i]){ s.push(k); k++; } pushMax = k - 1; } if(s.top() == aPush[i]){ s.pop(); }else{ return false; } } return true; } 面59 题二：队列的最大值题面：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 思路：第一种肯定会想到把一个队列拆成两个栈来做；第二种比较巧妙，通过分析滑动窗口内元素最大值的变化，可以写出类似的如下代码。具体思路，是用双头队列维护队列最大值。 代码：class MaxQueue { public: deque&lt;int&gt; value; deque&lt;int&gt; maxValue; MaxQueue() { value.clear(); maxValue.clear(); } int max_value() { if(value.size() &gt; 0){ return maxValue.front(); } else // throw new exception; return -1; } void push_back(int number) { value.push_back(number); while(maxValue.size() &gt; 0 &amp;&amp; maxValue.back() &lt; number){ maxValue.pop_back(); } maxValue.push_back(number); } int pop_front() { if(value.size() &gt; 0){ int popValue = value.front(); if(maxValue.front() == popValue){ maxValue.pop_front(); } value.pop_front(); return popValue; }else // throw new exception; return -1; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-&gt;max_value(); * obj-&gt;push_back(value); * int param_3 = obj-&gt;pop_front(); */","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/mian-shi-ti-zhan-he-dui-lie/"},{"title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"hello world 106. Construct Binary Tree from Inorder and Postorder Traversal 思路：递归的将中序遍历的序列分开，并建立中间节点的值 代码：递归。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* buildTreeCore(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int ins, int inend, int posts, int poste){ if(ins &gt;= inend || posts &gt;= poste) return NULL; TreeNode *node = new TreeNode(postorder[poste - 1]); int pos = ins; while(inorder[pos] != postorder[poste - 1]){ pos++; } node-&gt;left = buildTreeCore(inorder, postorder, ins, pos, posts, posts + pos - ins); node-&gt;right = buildTreeCore(inorder, postorder, pos + 1, inend, posts + pos - ins, poste - 1); return node; } TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { return buildTreeCore(inorder, postorder, 0, inorder.size(), 0, postorder.size()); } };","link":"/2020/09/25/shua-ti/shu-ju-jie-gou/shu/106-construct-binary-tree-from-inorder-and-postorder-traversal/"},{"title":"109. Convert Sorted List to Binary Search Tree","text":"思路：链表实际上给出的是二叉树前序的结果，因为AVL树任意左右子树高度不超过1，我们可以选择链表中点，并将链表的长度尽可能一样长的两部分划分到左右子树，所以高度性质可以维持住。 在中序遍历链表，控制子树长度，即可构建符合题意的AVL树。 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedListToBST(ListNode* head) { int len = sizeOfList(head); return sortedListToBSTCore(head, 0, len - 1); } int sizeOfList(ListNode* head){ ListNode *p = head; int len = 0; while(p){ p = p-&gt;next; ++len; } return len; } TreeNode* sortedListToBSTCore(ListNode* &amp;head, int lhs, int rhs) { if(lhs &gt; rhs) return nullptr; int mid = (lhs + rhs + 1) / 2; TreeNode* lchild = sortedListToBSTCore(head, lhs, mid - 1); TreeNode* root = new TreeNode(head-&gt;val); head = head-&gt;next; TreeNode* rchild = sortedListToBSTCore(head, mid + 1, rhs); root-&gt;left = lchild; root-&gt;right = rchild; return root; } };","link":"/2021/03/04/shua-ti/shu-ju-jie-gou/shu/109-convert-sorted-list-to-binary-search-tree/"},{"title":"1609. Even Odd Tree","text":"思路:层序遍历。记录边界即可。 代码： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isEvenOddTree(TreeNode* root) { if(root == nullptr ) return false; queue&lt;TreeNode *&gt; que; vector&lt;int&gt; a; int level = 0, num = 1, nextn = 0;; que.push(root); while(!que.empty()){ TreeNode *t = que.front(); que.pop(); a.push_back(t-&gt;val); num--; if(t-&gt;left){ que.push(t-&gt;left); nextn++; } if(t-&gt;right){ que.push(t-&gt;right); nextn++; } if(num == 0){ num = nextn; nextn = 0; int flag = 1; if(a.size() &lt; 1) continue; if(level &amp; 1){ for(int i = 1; i &lt; a.size(); i++){ if(a[i] &gt;= a[i - 1] || a[i]%2 == 1 ) flag = 0; } if(a[0]%2 == 1) flag = 0; } else{ for(int i = 1; i &lt; a.size(); i++){ if(a[i] &lt;= a[i - 1] || a[i]%2 == 0) flag = 0; } if(a[0]%2 == 0) flag = 0; } a.clear(); level ++; if(!flag) return false; } } return true; } };","link":"/2020/10/18/shua-ti/shu-ju-jie-gou/shu/1609-even-odd-tree/"},{"title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"235. Lowest Common Ancestor of a Binary Search Tree 思路：搜索树的LCA比较简单，利于二分性质即可。 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root-&gt;val &lt; min(p-&gt;val, q-&gt;val)){ return lowestCommonAncestor(root-&gt;right, p, q); }else if(root-&gt;val &gt; max(p-&gt;val, q-&gt;val) ){ return lowestCommonAncestor(root-&gt;left, p, q); }else{ return root; } } };","link":"/2020/09/27/shua-ti/shu-ju-jie-gou/shu/235-lowest-common-ancestor-of-a-binary-search-tree/"},{"title":"236. Lowest Common Ancestor of a Binary Tree","text":"思路： 递归搜索，判断左右子树已经当前节点是否有p和q。 记录下父节点，转化为两条链表的公共子节点。 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode *target; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return target; } int dfs(TreeNode* root, TreeNode* p, TreeNode* q){ if(!root) return 0; int leftRes = dfs(root-&gt;left, p, q); int rightRes = dfs(root-&gt;right, p, q); int midRes = 0; if(root == p) midRes = 1; else if(root == q) midRes = 2; if(!target &amp;&amp; (root == p &amp;&amp; root == q || leftRes + rightRes + midRes == 3)) target = root; return leftRes + rightRes + midRes; } }; /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode *target; unordered_map&lt;TreeNode*, TreeNode*&gt; fa; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, nullptr); TreeNode* p1 = p, *p2 = q; while(p1 != p2){ p1 = fa[p1] ? fa[p1] : q; p2 = fa[p2] ? fa[p2] : p; } return p1; } void dfs(TreeNode* root, TreeNode* father){ if(!root) return; fa[root] = father; dfs(root-&gt;left, root); dfs(root-&gt;right, root); } };","link":"/2021/03/04/shua-ti/shu-ju-jie-gou/shu/236-lowest-common-ancestor-of-a-binary-tree/"},{"title":"297. Serialize and Deserialize Binary Tree","text":"297. Serialize and Deserialize Binary Tree思路：对于二叉树序列化，leetcode已经给出了很好的示范。思考一下，完整前缀遍历（包括空节点信息）能否构建二叉树？可以，从根到子节点前缀遍历的同时构建二叉树。同理后缀也可以。 这里我采用层序遍历的方式，构建序列化和解序列化。 下面的代码有一个小技巧，把迭代器的设计思想融入到代码里：把遍历的功能独立出来，只提供接口，以便快速判断有无剩余节点，该节点是否有效。 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { string ser; int pos; // decoded pos. public: // Encodes a tree to a single string. string serialize(TreeNode* root) { queue&lt;TreeNode*&gt; que; que.push(root); while(que.size()){ TreeNode* pnode = que.front(); que.pop(); if(pnode){ ser += to_string(pnode-&gt;val) + &quot;,&quot;; que.push(pnode-&gt;left); que.push(pnode-&gt;right); } else ser += &quot;null,&quot;; } if(ser != &quot;&quot;) ser.erase(ser.size() - 1); // cout &lt;&lt; ser &lt;&lt; endl; return ser; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { ser = data; TreeNode *root = nullptr, *p = root; pos = 0; queue&lt;TreeNode*&gt; que; if(_isvalue()){ root = new TreeNode(_next()); que.push(root); } else return nullptr; while(que.size()){ p = que.front(); // 为该节点构造左右节点 que.pop(); // cout &lt;&lt; p-&gt;val &lt;&lt; ' '; if(!_hasnext()) break; if(_isvalue()){ p-&gt;left = new TreeNode(_next()); que.push(p-&gt;left); }else _next(); // 该节点的左子树为空 if(_isvalue()){ p-&gt;right = new TreeNode(_next()); que.push(p-&gt;right); }else _next(); // 该节点的右子树为空 } //cout &lt;&lt; endl; return root; } bool _isvalue(){ if(!_hasnext()) return false; if(isdigit(ser[pos]) || ser[pos] == '-') return true; return false; } inline bool _hasnext(){ return !(pos &gt;= ser.size()); } int _next(){ bool isnum = _isvalue(); int t = pos; while(t &lt; ser.size() &amp;&amp; ser[t] != ',') ++t; int pre = pos; pos = t + 1; // 把pos移到下一个空节点null或者数字开头处 if(isnum) return stoi(ser.substr(pre, t - pre)); else return -1; } }; // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root));","link":"/2021/04/26/shua-ti/shu-ju-jie-gou/shu/297-serialize-and-deserialize-binary-tree/"},{"title":"307. Range Sum Query - Mutable","text":"307. Range Sum Query - Mutable思路线段树 + lazy操作 代码线段树累加操作（代码应该正确，顺手写一写） class NumArray { public: int n = 0, m = 0; vector&lt;int&gt; d, b, a; void build(int l, int r, int no){ int m = (l + r) / 2; if(l == r){ d[no] = a[l]; return; } else { build(l, m, no * 2), build(m + 1, r, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } } void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated if(s &lt;= l &amp;&amp; r &lt;= t){ d[no] += (r - l + 1) * c; b[no] += c; return; } int mid = (l + r) / 2; if(b[no] &amp;&amp; l != r){ d[no * 2] += (mid - l + 1) * b[no]; d[no * 2 + 1] += (r - mid) * b[no]; b[no * 2] += b[no]; b[no * 2 + 1] += b[no]; b[no] = 0; } if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2); if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } int query_big(int l, int r, int s, int t, int no){ // [s, t] is queried. if(s &lt;= l &amp;&amp; r &lt;= t){ return d[no]; } int mid = (l + r) / 2; if(b[no] &amp;&amp; l != r){ d[no * 2] += (mid - l + 1) * b[no]; d[no * 2 + 1] += (r - mid) * b[no]; b[no * 2] += b[no]; b[no * 2 + 1] += b[no]; b[no] = 0; } int sum = 0; if(s &lt; mid + 1) sum += query_big(l, mid, s, t, no * 2); if(t &gt; mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1); return sum; } NumArray(vector&lt;int&gt;&amp; nums) { m = nums.size(); n = m * 2 + 10; d.resize(n); b.resize(n); a = nums; build(0, m - 1, 1); } void update(int index, int val) { update_big(0, m, index, index, val, 1); } int sumRange(int left, int right) { return query_big(0, m, left, right, 1); // return 0; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ 线段树更新为定值（AC ） 17% class NumArray { public: int n = 0, m = 0; vector&lt;int&gt; d, b, a, isb; void build(int l, int r, int no){ int m = (l + r) / 2; if(l == r){ d[no] = a[l]; return; } else { build(l, m, no * 2), build(m + 1, r, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } } void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated if(s &lt;= l &amp;&amp; r &lt;= t){ d[no] = (r - l + 1) * c; b[no] = c; isb[no] = 1; return; } int mid = (l + r) / 2; if(l &lt; r &amp;&amp; isb[no]){ d[no * 2] = (mid - l + 1) * b[no]; d[no * 2 + 1] = (r - mid) * b[no]; b[no * 2] = b[no]; b[no * 2 + 1] = b[no]; isb[no * 2] = isb[no * 2] = 1; b[no] = isb[no] = 0; } if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2); if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } int query_big(int l, int r, int s, int t, int no){ // [s, t] is queried. if(s &lt;= l &amp;&amp; r &lt;= t){ return d[no]; } int mid = (l + r) / 2; if(l &lt; r &amp;&amp; b[no]){ d[no * 2] = (mid - l + 1) * b[no]; d[no * 2 + 1] = (r - mid) * b[no]; b[no * 2] = b[no]; b[no * 2 + 1] = b[no]; isb[no * 2] = isb[no * 2] = 1; b[no] = isb[no] = 0; } int sum = 0; if(s &lt; mid + 1) sum += query_big(l, mid, s, t, no * 2); if(t &gt; mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1); return sum; } NumArray(vector&lt;int&gt;&amp; nums) { m = nums.size(); n = m * 4 + 10; // n * 2 开太小了 d.resize(n); b.resize(n); isb.resize(n); a = nums; build(0, m - 1, 1); } void update(int index, int val) { update_big(0, m - 1, index, index, val, 1); } int sumRange(int left, int right) { return query_big(0, m - 1, left, right, 1); // return 0; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */","link":"/2021/02/05/shua-ti/shu-ju-jie-gou/shu/307-range-sum-query-mutable/"},{"title":"310. Minimum Height Trees","text":"310. Minimum Height Trees思路： （超时）bfs 拓扑排序变形。从图的边缘点逆向追溯到中心点，可以直接获取到目标点。又有题目性质猜得，没有孤立点（除非n=1），没有环。那么目标点至多只有两个。 s class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { map.resize(n); for(int i = 0; i &lt; edges.size(); ++i){ int x = edges[i][0]; int y = edges[i][1]; map[x].emplace_back(y); map[y].emplace_back(x); } int minl = n - 1; vector&lt;int&gt; root; for(int i = 0; i &lt; n; ++i){ vector&lt;bool&gt; vis(n, false); int len = dfs(i, vis, 0); if(len &lt; minl){ root.clear(); minl = len; } if(len == minl){ root.push_back(i); } } return root; } int dfs(int v, vector&lt;bool&gt;&amp;vis, int len){ vis[v] = 1; int maxlen = len; for(auto u : map[v]){ if(!vis[u]){ // cout &lt;&lt; v &lt;&lt; ' ' &lt;&lt; u &lt;&lt; ' ' &lt;&lt; len &lt;&lt; endl; maxlen = max(maxlen, dfs(u, vis, len + 1)); // bugs: maxv = max(maxv, dfs(maxv + 1)); } } return maxlen; } }; 拓扑AC class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; degree; vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { map.resize(n); degree.resize(n); for(int i = 0; i &lt; edges.size(); ++i){ int x = edges[i][0]; int y = edges[i][1]; map[x].emplace_back(y); map[y].emplace_back(x); degree[x]++; degree[y]++; } queue&lt;int&gt; que; int m = 0; for(int i = 0;i &lt; n; ++i){ if(degree[i] == 1){ que.push(i); } if(degree[i] &gt; 0) ++m; } vector&lt;int&gt; root; while(que.size()){ m -= que.size(); if(m == 0) break; // cout &lt;&lt; m &lt;&lt; endl; while(que.size()){ int u = que.front(); que.pop(); for(auto v : map[u]){ degree[v]--; degree[u]--; if(degree[v] == 0) root.push_back(v); } } for(int i = 0; i &lt; n; ++i){ if(degree[i] == 1){ que.push(i); } } } if(root.size() == 0) while(que.size()){ root.push_back(que.front()); que.pop(); } if(n == 1) root.push_back(0); return root; } }; 利用性质优化一下 class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; degree; vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { map.resize(n); degree.resize(n); for(int i = 0; i &lt; edges.size(); ++i){ int x = edges[i][0]; int y = edges[i][1]; map[x].emplace_back(y); map[y].emplace_back(x); degree[x]++; degree[y]++; } queue&lt;int&gt; que; int m = n; for(int i = 0;i &lt; n; ++i){ if(degree[i] == 1){ que.push(i); } } vector&lt;int&gt; root; while(m &gt; 2){ m -= que.size(); int size = que.size(); for(int i = 0; i &lt; size; ++i){ int u = que.front(); que.pop(); for(auto v : map[u]){ degree[v]--; if(degree[v] == 1){ que.push(v); } } } } if(root.size() == 0) while(que.size()){ root.push_back(que.front()); que.pop(); } if(n == 1) root.push_back(0); return root; } };","link":"/2020/12/06/shua-ti/shu-ju-jie-gou/shu/310-minimum-height-trees/"},{"title":"331. Verify Preorder Serialization of a Binary Tree","text":"331. Verify Preorder Serialization of a Binary Tree思路： 按照字符串提供的数据按前序遍历伪建树，如果用完了所有字符就建树成功。 前序遍历允许我们的用栈记录当前节点以及之前节点应该生长的分支数，比如碰到一个数字，上一个节点的减一分支数，插入一个当点节点的分支数2。遍历过程中，栈为空或者遍历后，字符数还有剩余，显然建树失败。 代码：class Solution { public: bool isValidSerialization(string preorder) { int pos = 0; // if(preorder) return isValidSerializationCore(preorder, pos) &amp;&amp; pos == preorder.size() - 1; //完成条件：可以构建出一棵树，并且每个字符都使用到 } bool isValidSerializationCore(string &amp;preorder, int &amp;pos) { cout &lt;&lt; pos &lt;&lt; endl; if(preorder.size() &lt;= pos) return false; if(preorder[pos] == '#') return true; while(isdigit(preorder[++pos])); --pos; //跳到数字的最后一个char的pos if(isValidSerializationCore(preorder, pos += 2) &amp;&amp; isValidSerializationCore(preorder, pos += 2)) return true; return false; } }; class Solution { public: bool isValidSerialization(string preorder) { int pos = 0; stack&lt;int&gt; post; post.push(1); while(pos &lt; preorder.size()){ cout &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; post.size() &lt;&lt; endl; if(post.size() == 0) return false; if(preorder[pos] == ',') ++pos; else if(preorder[pos] == '#'){ ++pos; if(--post.top() == 0){ post.pop(); } }else if(isdigit(preorder[pos])){ if(--post.top() == 0){ post.pop(); } post.push(2); while(isdigit(preorder[++pos])); } } return post.size() == 0; } };","link":"/2021/03/12/shua-ti/shu-ju-jie-gou/shu/331-verify-preorder-serialization-of-a-binary-tree/"},{"title":"450. Delete Node in a BST","text":"思路：删除一个只有一个子节点，或者没有子节点的节点，比较简单。 删除有两个子节点的节点A，需要把找一个比A大的最小子节点B来替换该A。那么同时也需要递归的删除节点B。 代码：如果二叉树结构是父子儿子结构代码会更简单。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void print(TreeNode* root){ if(!root) return; print(root-&gt;left); cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot; ; print(root-&gt;right); } TreeNode* deleteNode(TreeNode* root, int key) { if(!root) return nullptr; // print(root); cout &lt;&lt; root-&gt;val &lt;&lt; endl; if(key &gt; root-&gt;val){ root-&gt;right = deleteNode(root-&gt;right, key); return root; } if(key &lt; root-&gt;val){ root-&gt;left = deleteNode(root-&gt;left, key); return root; } //delete the note without right child. if(!root-&gt;right){ TreeNode *temp = root-&gt;left; delete root; return temp; } //delete the node with right child. TreeNode* rightMinP = getMinNode(root-&gt;right); TreeNode* newp = new TreeNode(rightMinP-&gt;val); // recursively delete the minimum node. root-&gt;right = deleteNode(root-&gt;right, rightMinP-&gt;val); //Because of updating left child link //bugs // cout &lt;&lt; &quot;@&quot; &lt;&lt; root-&gt;val &lt;&lt; endl; // print(root); // cout &lt;&lt; &quot;$&quot; &lt;&lt; newp-&gt;val &lt;&lt; endl; newp-&gt;left = root-&gt;left; newp-&gt;right = root-&gt;right; delete root; return newp; } TreeNode * getMinNode(TreeNode* root){ if(!root) return nullptr; TreeNode* p = root; while(p-&gt;left){ p = p-&gt;left; } return p; } };","link":"/2021/03/03/shua-ti/shu-ju-jie-gou/shu/450-delete-node-in-a-bst/"},{"title":"653. Two Sum IV - Input is a BST","text":"思路：利用BST性质， 前序遍历数据的同时，搜索对应的k - val。 当然可以搜索一遍，同时hash遍历的数据，转化为一般的两数之和。 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool findTarget(TreeNode* root, int k) { int flag = 0; findSum(root, root, k, flag); return flag; } void findSum(TreeNode* root, TreeNode* head, int k, int &amp;flag){ if(!root) return; findSum(root-&gt;left, head, k, flag); if(root-&gt;val &gt; (k + 1) / 2) return; //剪枝 TreeNode* p = findT(head, k - root-&gt;val); if(p != nullptr &amp;&amp; p != root){ flag = 1; return; } findSum(root-&gt;right, head, k, flag); } TreeNode* findT(TreeNode* root, int T){ if(!root) return nullptr; if(root-&gt;val == T) return root; if(root-&gt;val &lt; T) return findT(root-&gt;right, T); else return findT(root-&gt;left, T); } };","link":"/2021/03/03/shua-ti/shu-ju-jie-gou/shu/653-two-sum-iv-input-is-a-bst/"},{"title":"654. 最大二叉树","text":"一个基础的递归建树就可以解决。 以递归的思想处理每一个新数组，先找出最大值所在并以此值一分数组为2个数组，同时递归建树即可。 Note：注意边界错误，如right到底没有没值 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { return constructBT(nums, 0, nums.size() - 1); } TreeNode* constructBT(vector&lt;int&gt;&amp; nums, int left, int right){ if(left &gt; right) return NULL; int index = left, nmax = nums[left]; for(int i = left + 1; i &lt;= right; i++){ if(nmax &lt; nums[i]){ nmax = nums[i]; index = i; } } TreeNode* root = new TreeNode(nmax); root-&gt;left = constructBT(nums, left, index - 1); root-&gt;right = constructBT(nums, index + 1, right); return root; } };","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/654-zui-da-er-cha-shu/"},{"title":"897. Increasing Order Search Tree","text":"思路前序遍历 + 建树 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* head; TreeNode* increasingBST(TreeNode* root) { TreeNode* p = nullptr; increasingBSTCore(root, p); return head; } TreeNode* increasingBSTCore(TreeNode* root, TreeNode* &amp;pre) { if(!root) return nullptr; increasingBSTCore(root-&gt;left, pre); root-&gt;left = nullptr; if(pre) pre-&gt;right = root; else head = root; // The list of head; pre = root; increasingBSTCore(root-&gt;right, pre); return root; } };","link":"/2021/03/04/shua-ti/shu-ju-jie-gou/shu/897-increasing-order-search-tree/"},{"title":"PAT 1043 二叉树重建","text":"搜索二叉树的前序列推出整个二叉树或者推出后序列思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点； 难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界； PAT 1043 其实有点意思 柳神的代码比我的构思好多了 vector&lt;int&gt;pre,post; bool isMirror; void checkPre(int root,int tail)//【root，tail】 { if(root&gt;tail) return;//! 空节点退出 int i=root+1,j=tail; if(!isMirror) { //!while退出之时 就是到了另一个子树序列的开头与结尾 while(i&lt;=tail&amp;&amp;pre[root]&gt;pre[i]) i++; while(j&gt;root&amp;&amp;pre[root]&lt;=pre[j]) j--;//!若该序列是二叉搜索树则必有i==j+1 } else { while(i&lt;=tail&amp;&amp;pre[root]&lt;=pre[i]) i++; while(j&gt;root&amp;&amp;pre[root]&gt;pre[j]) j--; } if(i-j!=1) return;//!由于树可能不存在 需要处理异常情况 checkPre(root+1,j); checkPre(i,tail); post.push_back(pre[root]);//!前序遍历压入当前根节点； } int main() { int n, flag = 1; scanf(&quot;%d&quot;,&amp;n); pre.resize(n+1); for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;pre[i]); checkPre(0,n-1); if(post.size()!=n)//! 不为二、 printf(&quot;YES\\n&quot;); for(int i=0; i&lt;n; i++) { printf(&quot;%d&quot;,post[i]); printf(&quot;%c&quot;,i!=n-1?' ':'\\n'); } } else printf(&quot;NO\\n&quot;); }","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/pat-1043-er-cha-shu-chong-jian/"},{"title":"PAT风格二叉树总结","text":"总结一下PAT出现的所有树的套路 前序中序转后序int post[40], n, pos = 0; vector&lt;int&gt; pre, in; stack&lt;int&gt;s; void dfs(int l1, int h1, int l2, int h2){ if(l1 &gt; h1) return; int k = l2; for(;in[k]!=pre[l1];k++); dfs(l1 + 1, l1 + k - l2, l2 , k - 1); dfs(l1 + k - l2 + 1, h1, k + 1, h2); post[pos++] = pre[l1]; } int main(){ int t; cin &gt;&gt; n; for(int i =0 ;i &lt; 2 * n; i++){ string a; cin &gt;&gt; a; if(a[1] == 'u'){ cin &gt;&gt; t; s.push(t); pre.push_back(t); }else{ in.push_back(s.top()); s.pop(); } } dfs(0, n - 1, 0, n - 1); for(int i = 0;i &lt; n; i++){ if(i == n - 1) cout &lt;&lt; post[i]; else cout &lt;&lt; post[i] &lt;&lt; ' ' ; } } BST + CMT 转层序int cbst[2000], n, pos = 1, in[2000]; int dfs(int u){ if(u &gt; n ) return 0; dfs(u * 2); cbst[u] = in[pos++]; dfs(u * 2 + 1); } int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; in[i]; } sort(in + 1, in + n + 1); dfs(1); for(int i = 1;i &lt;= n; i++){ if(i == n ) printf(&quot;%d&quot;, cbst[i]); else printf(&quot;%d &quot;, cbst[i]); } } 前序中序转后序vector&lt;int&gt; in, post, pre; int n, flag = 1; void dfs(int l1, int h1, int l2, int h2){ if(l1 &gt;= h1){ if(l1 == h1) in.push_back(pre[l1]); // l1 &gt; h1时 才能压入 否则是错误的 return; } int k = l1 + 1; while(k &lt;= h1 &amp;&amp; pre[k] != post[h2 - 1]) k++; if(k == l1 + 1) flag = 0; dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2 ); in.push_back(pre[l1]); dfs(k, h1, l2 + k - l1 - 1, h2 - 1 ); } int main(){ cin &gt;&gt; n; post.resize(n); pre.resize(n); for(int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; dfs(0, n - 1, 0 , n - 1); if(flag) cout &lt;&lt; &quot;Yes\\n&quot;; else cout &lt;&lt; &quot;No\\n&quot;; for(int i = 0; i &lt; n; i++) if(i == n - 1) printf(&quot;%d\\n&quot;, in[i]); else printf(&quot;%d &quot;, in[i]); } 层序中序转前序后序这个问题也非常的巧妙，本来是一个层次遍历划分出一个父节点，但是下一步左右子树划分却成了问题，这个算法有一次刷新了我的世界观。使用中序遍历的思想，在层次遍历中查询每一个节点的归属父节点的左子树还是右子树 const ll mod = 1000000007; int tree[40][2], val[40], n; int in[40]; vector&lt;int&gt; pre, post, lay; int build(vector&lt;int&gt; lay, int l, int r){ if(l &gt; r) return 0; int k = 1; while(lay[0] != in[k]) k++; vector&lt;int&gt; llay, rlay; for(int i = 1;i &lt; lay.size(); i++){ int isl = 0; for(int j = l; j&lt; k; j++) if(lay[i] == in[j]){ isl = 1; break; } if(isl) llay.push_back(lay[i]); else rlay.push_back(lay[i]); } pre.push_back(in[k]); tree[k][0] = build(llay, l, k - 1); tree[k][1] = build(rlay, k + 1, r); post.push_back(in[k]); return k; } int main(){ cin &gt;&gt; n; lay.resize(n); int root = 0; for(int i = 0;i &lt; n; i++) cin &gt;&gt; lay[i]; for(int i = 0;i &lt; n; i++) cin &gt;&gt; in[i + 1]; root = build(lay, 1, n); for(int i = 0;i &lt; n;i++) if(i == n - 1) printf(&quot;%d\\n&quot;, pre[i]); else printf(&quot;%d &quot;, pre[i]); for(int i = 0;i &lt; n;i++) if(i == n - 1) printf(&quot;%d\\n&quot;, post[i]); else printf(&quot;%d &quot;, post[i]); } 判断完全二叉树int tree[200][2], n, ingree[200], root, lastnood, flag = 1; int bfs(int u){ int tn = 1; queue&lt;int&gt; que; que.push(u); while(que.size()){ int v = que.front(); que.pop(); lastnood = v; if(tree[v][0] == -1){ if(tn != n) flag = 0; }else{ que.push(tree[v][0]); tn++; } if(tree[v][1] == -1){ if(tn != n) flag = 0; }else{ que.push(tree[v][1]); tn++; } } } int main(){ fill(tree[0], tree[0] + 200 * 2 , - 1 ); cin &gt;&gt; n; for(int i = 0;i &lt; n; i++) { string a, b; cin &gt;&gt; a &gt;&gt; b; if(a != &quot;-&quot;){ int v = atoi(a.c_str()); tree[i][0] = v; ingree[v] ++; } if(b != &quot;-&quot;) { int v = atoi(b.c_str()); tree[i][1] = v; ingree[v] ++; } } for(int i = 0; i &lt; n ;i++) if(ingree[i] == 0) root = i; bfs(root); if(flag) cout &lt;&lt; &quot;YES &quot; &lt;&lt; lastnood; else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root; } 静态链表建树int tree[2000][3], lay[2000], n, depest, ct = 0; int insert(int u, int val, int dep){ depest = max(depest,dep); // cout &lt;&lt; u &lt;&lt; endl; if(u == 0){ lay[dep] ++; tree[++ct][2] = val; return ct; }else if(val &lt;= tree[u][2]){ tree[u][0] = insert(tree[u][0], val, dep + 1); }else if(val &gt; tree[u][2]){ tree[u][1] = insert(tree[u][1], val, dep + 1); } return u; } int main() { int root = 0, tmp; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++){ cin &gt;&gt; tmp; root = insert(root, tmp, 1); } cout &lt;&lt; lay[depest ] &lt;&lt; &quot; + &quot; &lt;&lt; lay[depest - 1] &lt;&lt; &quot; = &quot; &lt;&lt; lay[depest] + lay[depest - 1] &lt;&lt; endl; } 判断树晴神的一道题1016 int tree[100][3], val[40], n, ingree[20]; int navln, layer[23], isct = 1, switime; stack&lt;int&gt; s; //avl int ctavl(int root){ if(root == 0) return 0; int h1 = ctavl(tree[root][0]); int h2 = ctavl(tree[root][1]); if( abs(h1 - h2) &gt; 1) navln ++; return max(h1, h2) + 1; } //层序遍历同时存储 逆层序遍历的顺序以便调整堆！ void isctree(int root){ int nt = 1; queue&lt;int&gt; que, lay; que.push(root); lay.push(1); while(que.size()){ int u = que.front(); que.pop(); int ll = lay.front(); lay.pop(); s.push(u); layer[ll] ++; // cout &lt;&lt; u &lt;&lt; endl; if( tree[u][0] ){ que.push(tree[u][0]); lay.push(ll + 1); nt ++; }else if(nt != n) isct = 0; if( tree[u][1] ){ que.push(tree[u][1]); lay.push(ll + 1); nt ++; }else if(nt != n) isct = 0; } } // 向下调整 大顶堆 void downAdjust(int root){ for(int p = tree[root][0];p !=0; p = tree[root][0]){ int pp = tree[root][1]; if(val[pp] &gt; val[p]) p = pp; if(val[p] &lt; val[root]) break; swap( val[root], val[p]); switime ++; root = p; } } int main(){ string s1, s2; cin &gt;&gt; n; for(int i = 0;i &lt; n; i++){ cin &gt;&gt; val[i]; } for(int i = 1;i &lt;= n; i++){ cin &gt;&gt; s1 &gt;&gt; s2; if(s1 != &quot;-&quot;){ tree[i][0] = atoi(s1.c_str()); ingree[atoi(s1.c_str())]++; } if(s2 != &quot;-&quot;){ tree[i][1] = atoi(s2.c_str()); ingree[atoi(s2.c_str())]++; } } int rt = -1; for(int i = 0;i &lt; n; i++) if( ingree[i] == 0) rt = i; // cout &lt;&lt; rt ; ctavl(rt); if(navln != 0) cout &lt;&lt; &quot;NOT AVL TREE!!!\\n&quot; &lt;&lt; navln &lt;&lt; endl; else{ isctree(rt); int p = 1, noden = 1; while(noden == layer[p]){ noden *= 2; p++; } if(!isct) cout &lt;&lt; &quot;NOT COMPLETE TREE!!!\\n&quot; &lt;&lt; p - 1 &lt;&lt; endl; else{ while(s.size()){ int u = s.top(); s.pop(); downAdjust(u); } cout &lt;&lt; &quot;OHHHHH HEAP!!!\\n&quot; &lt;&lt; switime &lt;&lt; endl; } } }","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/pat-feng-ge-er-cha-shu-zong-jie/"},{"title":"面试题 04.09. BST Sequences LCCI","text":"面试题 04.09. BST Sequences LCCI懵树下你和我，快乐刷刷题 思路二叉树的构建，是从根节点开始的，每构建的一个节点，就添加了一个可能两个新扩展节点，我们可以在其中任意选择一个节点新构建，如此递归下去，完成整棵树的构建。 那么，我们需要模拟整棵树的构建遍历过程，用deque存储每次构建时可以选择的节点，递归构造。如果deque为空，说明建构完成，把记录构建顺序的path加入答案即可。建构完成后回溯进行下一个节点的构建。 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { vector&lt;vector&lt;int&gt;&gt; ansSet; vector&lt;int&gt; path; deque&lt;TreeNode*&gt; que; public: vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root){ if(root) que.push_back(root); BSTSequencesCore(); return ansSet; } void BSTSequencesCore() { if(que.size() == 0){ ansSet.push_back(path); return; } for(int i = 0, size = que.size(); i &lt; size; ++i){ auto node = que.front(); que.pop_front(); path.push_back(node-&gt;val); if(node-&gt;left) que.push_back(node-&gt;left); if(node-&gt;right) que.push_back(node-&gt;right); // 选择有效节点，进入递归 BSTSequencesCore(); // 回溯状态 path.pop_back(); if(node-&gt;left) que.pop_back(); if(node-&gt;right) que.pop_back(); que.push_back(node); // 回溯状态要逆序‘’ } } };","link":"/2021/04/01/shua-ti/shu-ju-jie-gou/shu/mian-shi-ti-04-09-bst-sequences-lcci/"},{"title":"148. 排序链表","text":"148. 排序链表我写过最累最烦的链表题，循环归并排序思路比较好想，但是容易错，非常容易错，哈哈。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* midNode(ListNode* head, ListNode* end = nullptr){ ListNode* fastp = head, *slowp = head; while(fastp){ fastp = fastp-&gt;next; if(fastp) fastp = fastp-&gt;next; slowp = slowp-&gt;next; } return slowp; } ListNode *split(ListNode* node, int nums){ ListNode* p = node; if(p == nullptr) return nullptr; int k = 1; while(k &lt; nums &amp;&amp; p-&gt;next){ p = p-&gt;next; ++k; } ListNode *ans = p-&gt;next; p-&gt;next = nullptr; return ans; } ListNode* merger(ListNode* heada, ListNode* headb, ListNode* &amp;pre) { ListNode *p1 = heada, *p2 = headb, *head = new ListNode(), *p = head; if(!p1 &amp;&amp; !p2){ pre-&gt;next = nullptr; return nullptr; } while(p1 &amp;&amp; p2){ if(p1-&gt;val &lt; p2-&gt;val){ p-&gt;next = p1; p1 = p1-&gt;next; }else{ p-&gt;next = p2; p2 = p2-&gt;next; } p = p-&gt;next; } p-&gt;next = p1 ? p1 : p2; while(p-&gt;next) p = p-&gt;next; // link prenode and endnode. if(pre) pre-&gt;next = head-&gt;next; pre = p; // return merged list head; p = head-&gt;next; delete head; //print(p, &quot;p-&gt;next&quot;); return p; } ListNode* sortList(ListNode* head) { ListNode* p1 = head, *p2 = head; ListNode * prehead = new ListNode(); prehead-&gt;next = head; int flag = 1; for(int i = 1; flag; i *= 2){ ListNode* pre = prehead; ListNode * nextp1 = prehead-&gt;next; // #bug: nextp1 = head； but head has be reset. flag = 0; p2 = prehead; // @reset p2 //print(prehead, &quot;@&quot;); while(p2){ flag++; p1 = nextp1; p2 = split(p1, i); nextp1 = split(p2, i); // print(p1, &quot;p1&quot;); // print(p2, &quot;p2&quot;); merger(p1, p2, pre); // merge and link. // print(prehead, &quot;#&quot;); if(p1 == prehead-&gt;next &amp;&amp; !p2 &amp;&amp; flag == 1) flag = 0; } } head = prehead-&gt;next; delete prehead; return head; } void print(ListNode* head, string s = &quot;@&quot;){ cout &lt;&lt; s + &quot;:&quot; ; while(head){ cout &lt;&lt; head-&gt;val &lt;&lt; ' '; head = head-&gt;next; } cout &lt;&lt;endl; } };","link":"/2021/03/31/shua-ti-shu-ju-jie-gou-lian-biao-148-pai-xu-lian-biao/"},{"title":"42. Trapping Rain Water","text":"42. Trapping Rain Water思路：这题蛮hard的，挺考验思路； 思考一下，下雨的过程，水往低处流，一点一点汇聚起来，逐渐逐渐升高水面。我们是否可以在先求出低水平面的水量，在此之上求出高水平面的水量。 43234中就有两个水沟：2上的1*1的水沟，和323上的3*1水沟。 用这种想法，我们只需要遍历得到一个水平面的右边界，记录该水平面的左边界，获取低水平面的高度，填充下新水平面的水量即可。 最小值单调栈S可以帮助我们维持左边界的pos，记S的栈顶元素指向的高度为a，a之下的元素指向的高度为b。其性质必然有a &gt; b。遍历到高度c， 若c &lt; a，则对蓄水没有影响。 如果c &gt; b，则三者形成了一个水沟，计算🦁式子见代码，并且该水沟可能可以继续往上“看看”，在适当条件上看看单调栈，循环填充高水位水沟。 如果c==a，则显然应该替换掉a，因为单调栈维持的是等高水沟的最新端，试想33323。 经过上述填充过程，单调栈的性质也要维护一下，详细见代码。 代码： class Solution { public: int trap(vector&lt;int&gt;&amp; height) { if(height.size() &lt;= 1) return 0; stack&lt;int&gt; sck; int amount = 0; for(int i = 0; i &lt; height.size(); ++i){ while(sck.size() &gt;= 2 &amp;&amp; height[sck.top()] &lt;= height[i]){ int lowh = height[sck.top()]; sck.pop(); amount += (i - sck.top() - 1) * (min(height[i], height[sck.top()]) - lowh); // cout &lt;&lt; amount &lt;&lt; endl; } while(!sck.empty() &amp;&amp; height[sck.top()] &lt;= height[i]) sck.pop(); // &lt;= 按次序出现的等高的山峰A,B， 明显的有AB填充了水量，下一个被填充的应该是B,所以A必须被pop if(sck.empty() || height[i] &lt; height[sck.top()]) sck.push(i); } return amount; } };","link":"/2021/04/16/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-42-trapping-rain-water/"},{"title":"739. Daily Temperatures","text":"739. Daily Temperatures思路： 单调栈；用单调栈维护从后往前遍历当前元素的最大值，便可以轻松获取当前元素之后的最大值下标，即可以更新下一个更大元素的时间差。 KMP失败匹配算法；从后往前遍历，当前元素的更大值要么是当前元素的下一个元素，要么是下一个元素的更大值，要么是下一个元素的更大值的更大值……如此“递归”查找可得下一个最大值。如果查找不到，就不存在最大值。 思路：class Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { int n = T.size(); stack&lt;int&gt; pos, val; vector&lt;int&gt; day(n); for(int i = n - 1; i &gt;= 0; --i){ if(!val.empty()){ while(val.size() &amp;&amp; val.top() &lt;= T[i]){ val.pop(); pos.pop(); } } if(val.empty()) day[i] = 0; else day[i] = pos.top() - i; if(val.empty() || val.top() &gt;= T[i]){ pos.push(i); val.push(T[i]); } } return day; } }; 简化版 class Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { int n = T.size(); stack&lt;int&gt; pos, val; vector&lt;int&gt; day(n); for(int i = n - 1; i &gt;= 0; --i){ while(val.size() &amp;&amp; val.top() &lt;= T[i]){ val.pop(); pos.pop(); } if(val.size())day[i] = pos.top() - i; if(val.empty() || val.top() &gt;= T[i]){ // 取smaller元素加入队列，也可以直接添加，毕竟上面有pop; pos.push(i); val.push(T[i]); } } return day; } }; // KPM构造数组思路启发得来 class Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { int n = T.size(); vector&lt;int&gt; day(n); for(int i = n - 2; i &gt;= 0; --i){ int pos = i + 1; while(T[pos] &lt;= T[i]){ // 尽量从day偏移更多元素 if(day[pos] == 0) break; // 此后没有更大的元素 pos += day[pos]; } if(T[pos] &gt; T[i]) day[i] = pos - i; } return day; } };","link":"/2021/01/23/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-739-daily-temperatures/"},{"title":"84. Largest Rectangle in Histogram","text":"84. Largest Rectangle in Histogram思路： 遍历高度数组的同时，维护形成的矩阵，并更新最大面积。 观察，矩阵的面积可以不严格递增的情况下在从左到右扩展的，再严格递减的情况下可以确定出矩阵面积。正向数据缓存，逆向面积计算-&gt; 单调栈。read more 代码：class Solution { map&lt;int, pair&lt;int,int&gt;&gt; reg; public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int maxarea = 0; for(int i = 0; i &lt; heights.size(); ++i){ for(auto &amp;item : reg){ auto high = item.first; auto &amp;pii = item.second; auto l = pii.first; auto &amp;r = pii.second; if(high &gt; heights[i]){ reg.insert({heights[i], {l, i}}); maxarea = max(maxarea, heights[i] *(i - l + 1)); reg.erase(reg.find(high), reg.end()); break; } else if(high &lt;= heights[i]){ r = i; maxarea = max(high * (r - l + 1), maxarea); } } if(reg.count(heights[i]) == 0){ reg.insert({heights[i], {i, i}}); maxarea = max(maxarea, heights[i]); } } return maxarea; } }; class Solution { stack&lt;int&gt; s; public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int maxarea = 0; heights.push_back(0); // 为了计算所有面积 for(int i = 0; i &lt; heights.size(); ++i){ if(s.empty()) s.push(i); else if(heights[s.top()] &lt; heights[i]) s.push(i); else if(heights[s.top()] == heights[i]) s.top() = i; // 如果相邻的高度相同，则更新；因为不更新单调栈中矩阵左边界会扩展更多 else if(heights[s.top()] &gt; heights[i]){ while(!s.empty() &amp;&amp; (heights[s.top()] &gt; heights[i])){ int high = heights[s.top()]; s.pop(); int temparea = ( i - (s.empty() ? -1 : s.top()) - 1) * high; maxarea = max(maxarea, temparea); } s.push(i); } } return maxarea; } }; 当然，这里也可以添加一个哨兵，不过没什么影响。","link":"/2021/04/30/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-84-largest-rectangle-in-histogram/"},{"title":"CSAPP笔记7：链接","text":"链接是将各种代码和数据片段手机并组合成为一个单一文件的过程。链接方式从编译时（compile time）的静态链接，到加载时的共享库的动态链接，发展到运行时的共享库的动态链接。 这章的内容比较严谨，对知识的连续性要求较高。最好细细品读，尽可能理解大部分内容，这对后续学习帮助较大。 学习链接能够帮助我们： 帮助理解大型软件的构建过程。 避免编程中的错误。 理解语言的作用域规则。 理解计算机系统的诸如虚拟内存、分页、加载和运行程序的概念。 帮助使用共享库。 编译过程编译驱动程序，比如常见的GUN的GCC工具，调用预处理器，编译器，汇编器和连接器，将目标代码翻译成可执行二进制文件。 其翻译过程如下图，预处理器将源文件main.c处理成main.iASCII中间文件，编译器将mian.i编译成ASCII汇编文件main.s，再由汇编器将main.s翻译成一个可重定位目标文件main.o。同理sum.c也是编译成sum.o。最后由连接器将两个汇编文件链接，创建出一个可执行目标文件prog。shell在执行过程中调用加载器的函数，将可执行文件的代码和数据复制到内存，最后把控制转移到这个程序的开头。 ​ 静态链接上述描述是一种静态链接过程，连接器将一组可重定位目标文件和命令参数作为输入，以完全链接的，可加载和运行的可执行目标文件作为输出。为了完成链接，连接器主要完成两个任务： 符号解析。可重定位目标文件定义并引用符号，其符号可能是全局变量，静态变量，或者一个函数。连接器的任务就是将符号和符号引用对应起来。 重定位。编译器和汇编器生成都的是从0开始的数据节和代码节。链接器通过符号定义与一个内存位置相关联，从而重定位这些节，修改所有对符号的引用，指向对应内存位置。 有趣的基础事实，目标文件包含不同的字节块，是程序代码，或者程序数据，抑或引导连接器和加载器的数据结构。链接器不了解目标机器，这部分内容由编译器和汇编器干的差不多了。 目标文件目标文件有三种类型: 可重定位目标文件：包含二进制代码和数据。 共享目标文件：特殊的的可重定位目标文件，可在加载或者运行时被动态加载到内存并连接 可执行目标文件：包含二进制代合数据，可直接被复制到内存并执行。 CSAPP以ELF目标文件格式为代表，进行叙述。 可重定位目标文件ELF文件格式解析如下： ELF header：包含了系统信息，即系统字的大小，字节顺序。剩下的内容帮助连接器分析，如ELF头大小，目标文件类型，机器类型，节头部表的偏移以及节头部表中条目的大小和数量。 Section header table（节头部表）：描述目标文件的节。 这种之间的都是节。典型节如下： .text：编译后的机器代码。 .rodata：只读数据。 .data：已初始化的全局和静态C变量。 .bss：未初始化的全局和静态C变量，以及初始为零的全局变量和静态变量。但是此节仅仅是一个“占位符”。 .symtab：一个符号表，存放在程序中定义和引用的函数和全局变量的信息。 .rel.text：一个.text节（代码）中位置的列表，当把这个文件和其他目标文件相链接，需要修改。注意，可执行目标文件由于不需要重定位，所以不需要此节。 .rel.data：被模块引用或者定义的所有全局变量的重定位信息， .debug：调试符号表，包含局部变量和类型定义，定义和引用的全局变量，以及原始C源文件。-g为参数调用编译驱动程序才能获得。 .line：原始C源程序中的行号和.text节机器指令之间的映射，同样需要-g。 .strtab：字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。 符号和符号表 在C中，文件代表了一个模块，static关键字所修饰的函数和全局变量表示该模块私有，其他模块无法访问。如同C++和java中的private。尽可能用static来保护你的变量和函数是很好的编程习惯。 可重定位目标模块$m$的符号表包含三种符号： 由模块$m$生成的并可被其他模块所引用的全局符号，即非静态的C函数和全局变量。 被其他模块定义且被模块$m$引用的全局符号，称之为外部符号。与上一种符号对称。 只被模块$m$定义的和引用的局部符号。他们对应于带static属性的C函数和全局变量。 可以知道，连接器对于本地非静态变量（非静态本地变量）没有兴趣，这是因为这是由栈管理的！那么带有static修饰的本地过程变量并非用栈管理，而是在.data和.bss分配空间，并在符号变创建一个有唯一名字的本地连接器符号。 符号表是汇编器构造的，使用编译器输输出到汇编语言的.s文件的符号。.symtab节中包含ELF符号表，这种符号表包含一个符号条目的数组。具体内容如下： 使用工具GNU READELF可以方便的查看目标文件内容。可以对应两张图片查看。 每个符号都分配到一个节中，并用section字段以索引的形式表示。 值得注意的是，可重定位目标文件存在三个伪节（pseudo-section）。它们没有节头部表对应的条目。 ABS：存放补钙被重定位的符号。 UNDEF：未被定义的符号，也就是在本目标模块所引用但是在其他地方的符号。 COMMON：表示未被分配位置的未初始化的数据目标。 COMMON和.bss很相似，GCC以一种绝对化的方式存放符号： COMMON：未初始化的全局变量。 .bss：未初始化的静态变量，以及初始化为0的全局或静态变量。 .bss和COMMON的存放内容非常相似，但仍有不同。编译器把弱符号放到COMMON中，因为可能存在其他目标文件也定义了同一个弱符号，编译器把符号连接权给连接器。对于初始化的全局变量和静态变量，他们都属于强符号，可以自信的放入.bss和.data。 符号解析链接器所做的符号解析就把符号和一组输入目标文件的符号表中的一个符号定义关联起来。对于局部符号，汇编器会保证其命名的唯一。但是对于全局变量，如果编译器碰到一个在当面模块没有定义的符号（变量或者函数名），就会生成一个链接器符号表条目，并由链接器在所有输入目标文件中查找被引用符号的定义。如果没有查找到，就报错。 更复杂的情况，在于全局符号的重复定义。 C++和java支持方法的重载，其通过链接符号的重整（mangling）来区分极其相似的函数的区别。重整也就是把唯一的方法和参数，或者类名进行编码，使之独一无二。 链接器解析多重定义的全局符号编译器通过符号的强弱关系来处理多重定义的符号。函数和已初始化的全局变量是强符号，未初始化的全局变量的是弱符号。规则如下： 不允许有同名的多个强符号 如果有一个强符号和多个弱符号，那么选择强符号。 如果有多个弱符号，那么随机选择一个弱符号。 但是规则2和规则3容易显露出一个非常难以察觉的错误：如果有两个未被初始化的同名变量被定义，尤其两个变量类型不同，那么将会可能导致变量类型被覆盖的错误。 /* foo5.c */ #include &lt;stdio.h&gt; void f(void); int y = 15212; int x = 15213; int main(){ f(); printf(&quot;x = 0x%x y = 0x%x \\n&quot;, 12 x, y); return 0; } /* bar5.c */ double x; void f(){ x = -0.0; } 与静态库连接所有编译系统都支持一种机制——将所有的目标模块打包成一个单独文件.a（称为存档archive，有一个头部描述各个成员模块的位置和大小），称为静态库，并作为链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。静态库机制的出现不仅仅减少因为使用标准函数所带来的代码多余，而且方便迭代所引用的目标模块，再链接一次即可。 C编译器驱动默认传递libc.a库文件给链接器。 典型链接过程： #创建静态库 linux&gt; gcc -c addvec.c multvec.c linux&gt; ar rcs libvector.a addvec.o multvec.o #编译链接 linux&gt; gcc -c main2.c linux&gt; gcc -static -o prog2c main2.o -L. -lvector #-static 静态编译 #or equivalently linux&gt; gcc -static -o prog2c main2.o ./libvector.a 链接器用静态库来解析引用解析静态库的算法概括一下就是：从左到右遍历一次所有文件；对于可重定位目标文件，记录下符号引用，并解析记录下的符号引用；对于静态库，单单只是解析符号引用。 所以如果一个包含了符号定义的文件排在引用其符号的文件之前，链接器无法对这个符号进行解析，导致直接报错。一般关于库的准则是将他们放在命令行的结尾。当然也可重复写库名来应对多个文件循环调用的情况。 重定位一旦链接器完成了符号连接过程，接下来就是重定位： 重定位节和符号定义：把相同类型的节聚合在一起，由此可以计算出所有聚合节的地址。然后，链接器将运行时内存地址赋给聚合节以及输出模块定义的每个符号。这样每个指令和全局变量都有唯一的内存地址了。 重定位节中的符号引用：链接器修改代码节和数据节对每个符号的引用，使其指向正确的运行时地址。 重定位节和符号定义给出所有节和符号定义的运行时地址，这就给了重定位节的符号引用带来了方便。符号引用有两种方式一种是重定位PC相对引用，另一种是重定位绝对引用。第一种很熟悉，譬如JUMP或者RET等常用的跳转函数提供的控制流，其计算过程需要考虑下一条指令地址的值。第二种更简单，直接加就ok。 重定位完成后，就生成了可执行目标文件的.data和.text节。加载器可以直接把这些节复制到内存中，不再进行任何修改的执行这些指令。 可执行二进制文件二进制组成的可执行二进制文件类似于目标文件格式。略有不同的是，增加了一个带有初始化功能的_init()函数的.init，同时也不需要.rel节。 加载过程 程序加载的内存映像 首先，什么叫做内存映像呢？ 进程的内存映像，指的是内核在内存中如何存放可执行程序文件。注意了，这里的可执行程序文件和内存映像是有区别的，具体是： 可执行程序是位于硬盘上的，而内存映像位于内存上； 可执行程序没有堆栈，因为只有当程序被加载到内存上的时候才会分配相应的堆栈 可执行程序是静态的，因为它还没运行，但是内存映像是动态的，数据是随着运行过程改变的； 注意，由于.data有对齐要求，所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆栈运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR），所以每次程序运行的这些区域地址都会变化。 加载时动态链接上节中静态库具有明显的两个缺点：无法快速更新静态库，必须显式地重新链接；多个程序使用同一份静态库的代码会导致内存的极大浪费。共享库（shared library）致力于解决这两个问题。共享库是也称共享目标，程序在运行或加载时可以加载到任意的内存地址，与其他不同的程序链接起来。这个过程称为动态链接（dynamic linking）。 linux常用.so作为动态目标文件后缀，微软操作系统称之为DLL（动态链接库）。 链接过程如下： 链接过程中，仅仅执行一些链接，复制一些共享库的重定位和符号表信息，使之能在运行时解析对共享库的代码和数据的引用。 加载器加载程序到内存中，找到动态链接的节，加载和运行动态链接器。 动态链接器重定位共性库的文本和数据到某个内存中；然后重定位程序中对共享库的程序和数据的符号引用。（修改了目标文件的代码，算不上位置无关代码） 动态链接命令：#生成动态库 linux&gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c #-fpic 指示编译器产生位置无关代码 -shared指示链接器创建一个共享的目标文件 #编译 linux&gt; gcc -o prog2l main2.c ./libvector.so 运行时动态链接这种技术支持了应用无需在编译和链接是将库链接到应用中，是一项非常强大的技术。比如，分发共享库的新版本来更新软件；Web服务器通过生成动态内容的共享库，并将其存储在内存中，达到快速调用的目的，而无需生成一个线程或者进程，减少了开销，提高了性能。更进一步的说，无需停止服务器，而可以更新已经存在的函数，以及添加新的函数！ 栗子：Linux提供了动态链接库的简单接口dlopne，dlerror，dlclose和dlsym。 位置无关代码可以加载但是无需重定位的代码叫做位置无关代码，GCC使用-fpic选项指示GNU编译系统生成PIC代码。 同一个共享库中的全局变量和函数调用的容易解决，即通过统一模块中引用和定义相对位置不变的特性构造一个GOT（Global Offset Table，全局偏移量表）。GOT属于调用模块的数据段内容，其记录了每个全局数据目标（过程或者全局变量）都有一个重定位记录。加载时，动态链接器会重定位GOT的每个条目，使其包含正确的绝对地址。在访问引用时，利用数据段和代码段相对位置不变的特性可以计算出对应条目和调用指令的下一条指令的距离，并用PC相对跳转给出GOT条目地址，这部分由链接器构造共享库时完成。 那么，对于调用模块引用共享库的符号定义时，上述解决方法便失效了。这时我们引入延迟绑定的概念——将过程地址的绑定推迟到第一次调用该过程（理论上，当然可以一次绑定完所有的引用，但是这种方法避免了动态绑定器在第一次调用时消耗大量时间）。我们在调用模块中加入数据段的GOT，代码段的PIT（Procedure Linkage table）。GOT保存着动态链接器和其他函数的绝对化地址（动态链接器链接完成以后），PIT保存着调用动态链接器代码，调用共享库模块所需要的“初始化”代码。PIT和GOT联动的算法还是比较巧妙的，先尝试调用引用地址，没有初始化就压参数调用动态链接器，再初始化参数，最后把控制权返回给原来模块再调用一次共享库引用。 库打桩机制库打桩技术就是把调用函数替换成其他函数，一般用包装函数来代替原来的函数，用于追踪数据，记录调用情况，甚至直接替换成另一个实现。有三种不同的打桩机制： 编译时打桩拥有源代码，保证不修改源代码的情况下，最好添加一个#define func() myfunc()和函数声明的源文件，一个函数定义的.h文件。在编译选项中添加-I参数进行打桩，告诉C预处理器先在本地目录寻找malloc.h。 linux&gt; gcc -DCOMPILETIME -c mymalloc.c linux&gt; gcc -I. -o intc int.c mymalloc.o 链接时打桩Linux静态编译器支持在链接过程中--wrap f标志来打桩，链接器会把f解析成__wrap_f，把__real_f解析成f。 linux&gt; gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o # -Wl 把`,--wrap,malloc`替换成` --wrap malloc`传递给静态链接器 那么只要编写一个wrap和free字符包装过的函数声明和定义就Ok了。而且仅仅只需要可重定位目标文件就行了！ 运行时打桩如果程序使用的共享库的函数是我们想要打桩的，直接修改动态链接器的LD_PRELOAD环境变量为当前打桩的所替换的共享库路径即可。动态链接器会先去那个路径寻找共享库，从而自动替换打桩函数。但是需要创建共享库，而且被替换函数之前得是共享库函数。 #创建共享库 linux&gt; gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl #编译 linux&gt; gcc -o intr int.c #修改环境变量 linux&gt; LD_PRELOAD=&quot;./mymalloc.so&quot; ./intr 工具小结ar. Creates static libraries, and inserts, deletes, lists, and extracts members. strings. Lists all of the printable strings contained in an object ﬁle. strip. Deletes symbol table information from an object ﬁle. nm. Lists the symbols deﬁned in the symbol table of an object ﬁle. size. Lists the names and sizes of the sections in an object ﬁle. readelf. Displays the complete structure of an object ﬁle, including all of the information encoded in the ELF header. Subsumes the functionality of size and nm. objdump. The mother of all binary tools. Can display all of the information in an object ﬁle. Its most useful function is disassembling the binary instructions in the .text section.Linux systems also provide the ldd program for manipulating shared libraries:ldd: Lists the shared libraries that an executable needs at run time.","link":"/2020/08/28/cs/csapp/csapp-bi-ji-7-lian-jie/"},{"title":"python decorators in detial","text":"简单介绍一下python装饰器的写法，妙处和应用。原文英文链接 首先要知道：Python’s functions are first-class objects. def be_awesome(name): return f&quot;Yo {name}, together we are the awesomest!&quot; def greet_bob(greeter_func): return greeter_func(&quot;Bob&quot;) &gt;&gt;&gt; greet_bob(be_awesome) 'Yo Bob, together we are the awesomest!' Inner FunctionsIt’s possible to define functions inside other functions. Such functions are called inner functions. def parent(): print(&quot;Printing from the parent() function&quot;) def first_child(): print(&quot;Printing from the first_child() function&quot;) first_child() inner function 调用顺序如同 parent()所做的效果，同时inner function只有在parent()被调用之后才会被定义成一个local variable in parent local scope。 Returning Functions From FunctionsPython also allows you to use functions as return values. # 当然这里的 fisrt_child也可以被传入 def parent(): def first_child(): return &quot;Hi, I am Emma&quot; # return a reference to the function. return first_child &gt;&gt;&gt; first = parent() &gt;&gt;&gt; first &lt;function parent.&lt;locals&gt;.first_child at 0x7f599f1e2e18&gt; &gt;&gt;&gt;first() 'Hi, I am Emma' Introspection一个好的函数需要有know about its own attributes at runtime. &gt;&gt;&gt; print &lt;built-in function print&gt; &gt;&gt;&gt; print.__name__ 'print' &gt;&gt;&gt; help(print) Help on built-in function print in module builtins: print(...) &lt;full help message&gt; decorator 本质上还是一种 syntactic sugar Simply, decorator wrap a function, modifying its behavior. def my_decorator(func): def wrapper_do_twice(*args, **kwargs): func(*args, **kwargs) return func(*args, **kwargs) return wrapper_do_twice @my_decorator def say_whee(args): print(&quot;whell!&quot;) return f&quot;This is My {args}&quot; &gt;&gt;&gt; say_whee(&quot;Adam&quot;) whell whell This is My Adam 这种等价的声明方式，代替了： say_wapper = my_decorator(say_whee) 这种说明方式虽然方便，但是减少了一定程度的代码灵活性。同时，import对于该语法糖定义的函数也是有效的。 这就是语法糖吗？ 注意say_whee函数接受参数的情况下同样需要wrapper_do_twice传递参数。 Introspectionimport functools # 显示消耗时间 def timer(func): &quot;&quot;&quot;Print the runtime of the decorated function&quot;&quot;&quot; @functools.wraps(func) def wrapper_timer(*args, **kwargs): start_time = time.perf_counter() # 1 value = func(*args, **kwargs) end_time = time.perf_counter() # 2 run_time = end_time - start_time # 3 print(f&quot;Finished {func.__name__!r} in {run_time:.4f} secs&quot;) return value return wrapper_timer # 显示输入输出信息 def debug(func): &quot;&quot;&quot;Print the function signature and return value&quot;&quot;&quot; @functools.wraps(func) def wrapper_debug(*args, **kwargs): args_repr = [repr(a) for a in args] # 1 kwargs_repr = [f&quot;{k}={v!r}&quot; for k, v in kwargs.items()] # 2 signature = &quot;, &quot;.join(args_repr + kwargs_repr) # 3 print(f&quot;Calling {func.__name__}({signature})&quot;) value = func(*args, **kwargs) print(f&quot;{func.__name__!r} returned {value!r}&quot;) # 4 return value return wrapper_debug # 经过装饰的函数，的help信息显示的是装饰函数的inner function &gt;&gt;&gt; say_whee &lt;function do_twice.&lt;locals&gt;.wrapper_do_twice at 0x7f43700e52f0&gt; &gt;&gt;&gt; say_whee.__name__ 'wrapper_do_twice' &gt;&gt;&gt; help(say_whee) Help on function wrapper_do_twice in module decorators: wrapper_do_twice() # decorators 采用functools.wraps decorator 保存关于原来函数的信息 import functools def do_twice(func): @functools.wraps(func) def wrapper_do_twice(*args, **kwargs): func(*args, **kwargs) return func(*args, **kwargs) return wrapper_do_twice &gt;&gt;&gt; say_whee &lt;function say_whee at 0x7ff79a60f2f0&gt; &gt;&gt;&gt; say_whee.__name__ 'say_whee' &gt;&gt;&gt; help(say_whee) Help on function say_whee in module whee: say_whee() Technical Detail: The @functools.wraps decorator uses the function functools.update_wrapper() to update special attributes like __name__ and __doc__ that are used in the introspection. examples倒计时 import functools import time def slow_down(func): &quot;&quot;&quot;Sleep 1 second before calling the function&quot;&quot;&quot; @functools.wraps(func) def wrapper_slow_down(*args, **kwargs): time.sleep(1) return func(*args, **kwargs) return wrapper_slow_down @slow_down def countdown(from_number): if from_number &lt; 1: print(&quot;Liftoff!&quot;) else: print(from_number) countdown(from_number - 1) &gt;&gt;&gt; countdown(3) 3 2 1 Liftoff! 注册者 import random PLUGINS = dict() def register(func): &quot;&quot;&quot;Register a function as a plug-in&quot;&quot;&quot; PLUGINS[func.__name__] = func return func @register def say_hello(name): return f&quot;Hello {name}&quot; @register def be_awesome(name): return f&quot;Yo {name}, together we are the awesomest!&quot; def randomly_greet(name): greeter, greeter_func = random.choice(list(PLUGINS.items())) print(f&quot;Using {greeter!r}&quot;) return greeter_func(name) 用户登录 from flask import Flask, g, request, redirect, url_for import functools app = Flask(__name__) def login_required(func): &quot;&quot;&quot;Make sure user is logged in before proceeding&quot;&quot;&quot; @functools.wraps(func) def wrapper_login_required(*args, **kwargs): if g.user is None: return redirect(url_for(&quot;login&quot;, next=request.url)) return func(*args, **kwargs) return wrapper_login_required @app.route(&quot;/secret&quot;) @login_required def secret(): ... Decorating Classes有两种方法可以在classes使用装饰器，一种对methods使用，另一种对class使用。 methodclass Circle: def __init__(self, radius): self._radius = radius # 不可修改的属性 @property def radius(self): &quot;&quot;&quot;Get value of radius&quot;&quot;&quot; return self._radius #可设置的属性 @radius.setter def radius(self, value): &quot;&quot;&quot;Set radius, raise error if negative&quot;&quot;&quot; if value &gt;= 0: self._radius = value else: raise ValueError(&quot;Radius must be positive&quot;) # 无需实例调用，常用于工厂方法 @classmethod def unit_circle(cls): &quot;&quot;&quot;Factory method creating a circle with radius 1&quot;&quot;&quot; return cls(1) # 可在实例或者类中使用，可直接调用 @staticmethod def pi(): &quot;&quot;&quot;Value of π, could use math.pi instead though&quot;&quot;&quot; return 3.1415926535 ## exmaple 2 # 也可以从之前的代码库中调用 方法来decorate from decorators import debug, timer class TimeWaster: @debug def __init__(self, max_num): self.max_num = max_num @timer def waste_time(self, num_times): for _ in range(num_times): sum([i**2 for i in range(self.max_num)]) classdecorator用在class上面的语法和方法装饰器一样，可以注意到上面方法@timer装饰器在class上的作用等同于timer = warpper_time(TimeWaster)，也就是返回一个Timewaster对象地同时计算init()花费时间。 @timer class TimeWaster: def __init__(self, max_num): self.max_num = max_num def waste_time(self, num_times): for _ in range(num_times): sum([i**2 for i in range(self.max_num)]) 当然可以把callable function当成decorator装饰给函数。 import functools class CountCalls: def __init__(self, func): functools.update_wrapper(self, func) self.func = func self.num_calls = 0 def __call__(self, *args, **kwargs): self.num_calls += 1 print(f&quot;Call {self.num_calls} of {self.func.__name__!r}&quot;) return self.func(*args, **kwargs) @CountCalls def say_whee(): print(&quot;Whee!&quot;) sya_whee()等价于func = CountCalls(say_whee)，func就是调用CountCalls.__call___()。这就实现了class decorator的功能，同时由于class属性，自动完成了状态存储的功能。 Nest Decorators神经的装饰器居然还可以Nesting的，这可比函数调用方便多了！ from decorators import debug, do_twice @debug @do_twice def greet(name): print(f&quot;Hello {name}&quot;) &gt;&gt;&gt; greet(&quot;Eva&quot;) Calling greet('Eva') Hello Eva Hello Eva 'greet' returned None Think about this as the decorators being executed in the order they are listed. In other words, @debug calls @do_twice, which calls greet(), or debug(do_twice(greet())): Decorators with argument带着参数的decorateor要求对装饰器理解要更上一层楼了： @method指向是一个返回装饰器函数对象的函数，@method(arsg=args)指向是的一个带着参数的返回返回装饰器函数对象的函数对象。 #!/usr/bin/python3 import functools def repeat(times): def decorate_repeate(func): @functools.wraps(func) def inner_repeat(*args, **kwargs): for _ in range(times): value = func(*args, **kwargs) return value return inner_repeat return decorate_repeat @repeat(times=4) def print_whee(): print(&quot;whee!&quot;) print_whee() print: whee! whee! whee! whee! 对比以下： def do_twice(func): @functools.wraps(func) def wrapper_do_twice(*args, **kwargs): for x in args: print(&quot;This args of func is:&quot;x) func(*args, **kwargs) return func(*args, **kwargs) return wrapper_do_twice 我认为之前的带参数的decorator的语法糖等价形式可以写成这样： #!/usr/bin/python3 import functools def repeat(times): def decorate_repeat(func): @functools.wraps(func) def inner_repeat(*args, **kwargs): for x in args: print(&quot;This args of func is:&quot;, x) for _ in range(times): value = func(*args, **kwargs) return value return inner_repeat return decorate_repeat def print_whee(*args, **kwargs): print(&quot;whee!&quot;) # 对调用的函数返回的函数对象进行调用！ # fisrt class NB! repeat_print_whee = repeat(times=4)(print_whee) print(repeat_print_whee) # print(inner_repeat) print(print_whee) print(repeat(times=4)) repeat_print_whee(*['hello', 'world']) 也就说，装饰器首先调用了repeat(time)，返回一个decorate_repeat(print_whee)的装饰器函数！接下来的步骤和之前相同。 optional argument本质上来说，repeat(time)只不过是套了层调用的decoreate_repeat(func)，也就是说 def repeat(_func, *, times=times): def decorate_repeat(func): @functools.wraps(func) def inner_repeat(*args, **kwargs): for x in args: print(&quot;This args of func is:&quot;, x) for _ in range(times): value = func(*args, **kwargs) return value return inner_repeat #调用函数 return decorate_repeat(_func) 这就可以引入 可以带参数或者不带参数的decorator： # * 表示后面的 following parameters are keyword-only. def repeat(_func=None, *, num_times=2): def decorator_repeat(func): @functools.wraps(func) def wrapper_repeat(*args, **kwargs): for _ in range(num_times): value = func(*args, **kwargs) return value return wrapper_repeat # 如果decorator带非函数参数，语法糖就会写成 # repeat(num_time)(func)(*args……) # = wrapper_repeat(*ars ……) if _func is None: return decorator_repeat # 如果decorator不带参数，decorator会直接调用warpped的函数 # 返回 wrapper_repeat函数 else: return decorator_repeat(_func) Stateful decorators有状态的decorator与之前所述的decorator的输出依赖于输入的情况，恰恰相反，它依赖于当前的状态。这也于函数式编程的理念不同。不过这里简单运用了function attributs #!/usr/bin/python3 import functools def count_calls(func): @functools.wraps(func) def wrapper_count_calls(*args, **kwargs): wrapper_count_calls.num_calls += 1 print(f&quot;Call {wrapper_count_calls.num_calls} of {func.__name__!r}&quot;) return func(*args, **kwargs) wrapper_count_calls.num_calls = 0 return wrapper_count_calls @count_calls def say_whee(): print(&quot;Whee!&quot;) say_whee() say_whee() say_whee() say_whee() print(say_whee.num_calls)) print: Call 1 of 'say_whee' Whee! Call 2 of 'say_whee' Whee! Call 3 of 'say_whee' Whee! Call 4 of 'say_whee' Whee! 4 更好的方式就是使用class作为装饰器来修饰方法，他保存状态更加方便！ 上文有相关内容。 更多真实例子delayimport functools import time def slow_down(_func=None, *, rate=1): &quot;&quot;&quot;Sleep given amount of seconds before calling the function&quot;&quot;&quot; def decorator_slow_down(func): @functools.wraps(func) def wrapper_slow_down(*args, **kwargs): time.sleep(rate) return func(*args, **kwargs) return wrapper_slow_down if _func is None: return decorator_slow_down else: return decorator_slow_down(_func) @slow_down(rate=2) def countdown(from_number): if from_number &lt; 1: print(&quot;Liftoff!&quot;) else: print(from_number) countdown(from_number - 1) Singleton用装饰器实现单例模式！用了stateful decorator的知识点 A singleton is a class with only one instance. There are several singletons in Python that you use frequently, including None, True, and False. It is the fact that None is a singleton that allows you to compare for None using the is keyword, like you saw in the Both Please section: Using is returns True only for objects that are the exact same instance. #!/usr/bin/python3 import functools def singlenton(cls): @functools.wraps(cls) def wrap_function(*args, **kwargs): if not wrap_function.instance: wrap_function.instance = cls(*args, **kwargs) return wrap_function.instance # 设置是必要的 wrap_function.instance = None return wrap_function @singlenton class iden(object): ... singlenton.instance = &quot;a&quot; print(singlenton.instance) cls1 = iden() cls2 = iden() print(id(cls1)) print(id(cls2)) Caching Return Value当然也可以使用stateful decorator来计数、甚至cache！ #!/usr/bin/python3 import functools def count_calls(func): @functools.wraps(func) def wrap_timers(*args, **kwargs): wrap_timers.times += 1 print(&quot;This is {:^5} times when the function excuted.&quot;.format(wrap_timers.times)) return func(*args, **kwargs) wrap_timers.times = 0 return wrap_timers def cache(func): @functools.wraps(func) def wrap_fibonacci(*args, **kwargs): dic = wrap_fibonacci.cache for arg in args: if dic.get(arg) == None: dic[arg] = func(*args, **kwargs) return dic[arg] wrap_fibonacci.cache = {} return wrap_fibonacci # @cache @count_calls def fibonacci(nums): if nums == 1 or nums == 0: return nums else : return fibonacci(nums - 1) + fibonacci(nums - 2) print(fibonacci(5)) 注意，如果去掉@cache，调用次数不同的哦. 对象转化我们可以方便地添加function的attri，甚至直接把返回值替换成一个其他对象，减少操作的步骤。比如与和pintpython库就是。 #!/usr/bin/python3 import math import functools import pint # 设置 unit function def set_unit(entity): def get_add_unit(func): func.unit = entity # @functools.wraps() # def wrap_unit(*args, **kwargs): # func.unit = entity # return func(*args, **kwargs) return func return get_add_unit # 利用修饰符 设置unit @set_unit(&quot;m^2&quot;) def calM(radius): return math.pi * radius ** 2 print(calM(3)) print(calM.unit) # 单位转化过程 ureg = pint.UnitRegistry() vol = calM(4) * ureg(calM.unit) print(vol) print(vol.to(&quot;inches ^2 &quot;)) # Magnitude # 利用decarotor设置unit, 返回 Quantity 对象！减少转化步骤 def use_unit(unit): use_unit.unit = pint.UnitRegistry() def decorate_use_unit(func): @functools.wraps(func) def wrap_use_unit(*args, **kwargs): return func(*args, **kwargs) * use_unit.unit(unit) return wrap_use_unit return decorate_use_unit @use_unit(&quot;meters per hour&quot;) def average_speed(dis, time): return dis / time speed = average_speed(10, 29) print(speed.to(&quot;km per hour&quot;)) Validating JSON检验JSON请求中是否有某些字段. # 原始 @app.route(&quot;/grade&quot;, methods=[&quot;POST&quot;]) def update_grade(): json_data = request.get_json() if &quot;student_id&quot; not in json_data: abort(400) # Update database return &quot;success!&quot; from flask import Flask, request, abort import functools app = Flask(__name__) # 验证decorator def validate_json(*expected_args): # 1 def decorator_validate_json(func): @functools.wraps(func) def wrapper_validate_json(*args, **kwargs): json_object = request.get_json() for expected_arg in expected_args: # 2 if expected_arg not in json_object: abort(400) return func(*args, **kwargs) return wrapper_validate_json return decorator_validate_json @app.route(&quot;/grade&quot;, methods=[&quot;POST&quot;]) @validate_json(&quot;student_id&quot;) def update_grade(): json_data = request.get_json() # Update database. return &quot;success!&quot; wrappper function 把验证部分从原代码中抽离出来，交给了验证decorator，而剩下的功能更加纯粹。","link":"/2020/10/21/language/python/python-decorators-in-detial/"},{"title":"面试题 二叉树","text":"收集二叉树相关题目，相关测试代码见此。 sCmd = ‘C:; cd C:\\Users\\xusx\\Sumo\\SUMO\\bin; duarouter -n xsxlankershim.net.xml –route-files xsx.flow.xml -o rou.rou.xml’os.system(sCmd) 结构struct BinaryTreeNode{ double dbValue; BinaryTreeNode *pLeft; BinaryTreeNode *pRight; } 面7：中序遍历和前序遍历序列来重建二叉树BinaryTreeNode* ConstructNode(int *startPreorder, int *endPreordrer, int *startInorder, int *endInorder){ //这个代码健壮性就很好！对空值和非法输出进行了区分。 if(startPreorder &gt; endPreorder || startInorder &gt; endInorder ){ if(startPreorder == endPreorder - 1 &amp;&amp; startInorder == endInorder - 1) return nullptr; else throw std::exception(&quot;Invalid Input.\\n&quot;); } //寻找中序遍历中的根节点值坐标 int nodeValue = startPreordre[0]; int *rootInorder = startInorder; for(; rootInorder &lt;= enInorder &amp;&amp; *rootInordre != nodevalue; rootInorder++); //健壮一下 if(enInorder &lt; rootInorder){ throw std::exception(&quot;Invalid input!\\n&quot;); } //构建左右子树 BinaryTreeNode* pNode = new BinaryTreeNode(); int lNodeNum = rootInorder - startInorder; pNode-&gt;pLeft = ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1); pNode-&gt;pRight = ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder); pNode-&gt;value = nodeValue; return pNode; } BinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length){ //length == 0的代码的健壮性显然不如 length &lt;= 0 if(preorder == null || inorder == null || length &lt;= 0) return nullptr; return ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1); } 面8：二叉树的下一个节点第一次考虑的时候居然还想错了，分析不够全面。从二叉树中序遍历来看，若一个节点有右子树，则下一个节点就是其右子树的最左节点。倘若没有，则必然是考虑父亲节点。如果该节点是父亲节点的左子节点，那么下一个节点就是父亲节点，不然可以溯源查找其父辈节点是左子树的祖父节点。这个过程可以使用父亲节点和迭代完成。 BinaryTreeNode *GetNext(BinaryTreeNode *pNode){ if(pNode == nullptr) return; if(pNode-&gt;pRight){ BinaryTreeNode* pChild = pNode-&gt;pRight; while(pChild-&gt;pLeft != nullptr) pChild = pChild-&gt;pRight; return pChild; }else{ BinaryTreeNode* pParent = pNode-&gt;pParent, *pCurrent = pNode; //循环控制条件有点像哨兵，没有找到的话pParent自然就是unllptr,代码更加简洁了 while(pParent != nullptr &amp;&amp; pParent-&gt;pRight != pCurrent){ pCurrent = pParent; pParent = pParent-&gt;pParent; } return pParent; } return nullptr; } 相比之前的代码这个写法差一点点 while(pParent-&gt;pParent != nullptr &amp;&amp; pParent-&gt;pRight != pCurrent){ pCurrent = pParent; pParent = pParent-&gt;pParent; } if(pParent-&gt;pRight == pCurrent){ return pParent; } 面26：树的子结构题面：输入两棵树A和B，判断B是否是A的子结构。B是A的子结构子结构定义为A的一部分和B完全相同。 思路：递归的判断对A的每一个节点判断该节点下的是否有B的结构。 代码：bool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot2 == nullptr) return true; else if(pRoot1 == nullptr) return false; if(equal(pRoot1-&gt;dbValue, pRoot2-&gt;dbValue)){ if(pRoot2-&gt;pRight == nullptr &amp;&amp; pRoot2-&gt;pLeft == nullptr) return true; return judgeSameTree(pRoot1-&gt;pLeft, pRoot2-&gt;pLeft) &amp;&amp; judgeSameTree(pRoot2-&gt;pRight, pRoot2-&gt;pRight); } return false; } bool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot1){ if(judgeSameTree(pRoot1, pRoot2)) return true; else return HasSubtreeCore(pRoot1-&gt;pLeft, pRoot2) || HasSubtreeCore(pRoot1-&gt;pRight, pRight); } return false; } bool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot2 == nullptr) return true; if(pRoot1 == nullptr) return false; return HasSubtreeCore(pRoot1, pRoot2); } 测试：参见 面27：翻转二叉树题面：给出一棵二叉树并返回其镜像二叉树。 思路：直接交换节点的左右指针节点即可。 代码：BinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode){ if(pNode == nullptr) return nullptr; BinaryTreeNode *pTemp = pNode-&gt;pRight; pNode-&gt;pRight = pNode-&gt;pLeft; pNode-&gt;pLeft = pTemp; MirrorRecursively(pNode-&gt;pLeft); MirrorRecursively(pNode-&gt;pRight); return pNode; } 面28：对称二叉树题面：判断一棵树是否对称。 思路：从第一个节点左子树开始递归的判断，其右子树的节点是否完全相同。只需要一边对另一边镜像操作就ok。 代码：bool isSymmetrical(BinaryTreeNode* pHead){ if(pHead == nullptr) return true; return isSymmetricalCore(pHead-&gt;pLeft, pHead-&gt;pRight); } bool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2){ if(p1 == nullptr &amp;&amp; p2 == nullptr) return true; if(p1 == nullptr &amp;&amp; p2 != nullptr || p2 == nullptr &amp;&amp; p1 != nullptr || p1-&gt;value != p2-&gt;value) return false; return isSemmetricalCore(p1-&gt;left, p2-&gt;right) &amp;&amp; isSemmetricalCore(p1-&gt;right, p2-&gt;left); } 有趣的是，我这种写法也可以看成前序遍历序列和对称前序遍历序列的比较。 面32：层序遍历二叉树题面：如标题 思路：层序遍历 代码：void PrintByLayer(BinaryTreeNode* pHead){ if(pHead == nullptr) return; queue&lt;BinaryTreeNode*&gt; que; que.push(pHead); while(que.size()){ BinaryTreeNode *pNode = que.front(); que.pop(); printf(&quot;%.2f &quot;, pNode-&gt;dbValue); if(pNode-&gt;pLeft) que.push(pNode-&gt;pLeft); if(pNode-&gt;pRight) que.push(pNode-&gt;pRight); } printf(&quot;\\n&quot;); } 面32相关题：分行打印层序遍历二叉树题面：如标题 思路：在层序遍历的基础上，有两种解题思路：一是记录当前层未打印的节点数量和下一层的需要打印的节点数量，二是在队列中添加一个一层的节点末端的标志符、 代码：void PrintByLayerSparate(BinaryTreeNode* pHead){ if(pHead == nullptr) return; queue&lt;BinaryTreeNode*&gt; que; que.push(pHead); int printValue = 1, nextValue = 0; while(que.size()){ BinaryTreeNode *pNode = que.front(); que.pop(); printValue--; printf(&quot;%.2f &quot;, pNode-&gt;dbValue); if(pNode-&gt;pLeft){ que.push(pNode-&gt;pLeft); nextValue++; } if(pNode-&gt;pRight){ que.push(pNode-&gt;pRight); nextValue++; } if(printValue == 0){ printValue = nextValue; nextValue = 0; printf(&quot;\\n&quot;); } } } 面32相关题：之字形打印二叉树题面：如标题 思路：一种方法就是分层层序遍历+栈逆序存储并输出。 第二种方法就用栈把一层的节点逆序输出，并将下一层的节点记录在另一个栈中，如此循环，输出所有的层。 代码：void PirntZhi(BinaryTreeNode *pHead){ if(pHead == nullptr) return; stack&lt;BinaryTreeNode*&gt; s[2]; int cur = 0; s[cur].push(pHead); BinaryTreeNode *pNode = nullptr; while(s[cur].size()){ while(s[cur].size()){ pNode = s[cur].top(); s[cur].pop(); printf(&quot;%.2 &quot;, pNode-&gt;dbValue); if(cur == 0){ if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft); if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight); }else{ if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight); if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft); } } printf(&quot;\\n&quot;); cur = 1- cur; } } 103. Binary Tree Zigzag Level Order Traversal/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { if(!root) return {}; stack&lt;TreeNode*&gt; cur1, cur2; cur1.push(root); vector&lt;vector&lt;int&gt;&gt; zigarr; int flag = 1; while(cur1.size() || cur2.size()){ if(flag) zigview(cur1, cur2, zigarr, flag), flag = 1 - flag ; else zigview(cur2, cur1, zigarr, flag), flag = 1 - flag; } return zigarr; } void zigview(stack&lt;TreeNode*&gt;&amp; now, stack&lt;TreeNode*&gt;&amp; next, vector&lt;vector&lt;int&gt;&gt; &amp;zigarr, int flag){ vector&lt;int&gt; arr; while(!now.empty()){ arr.push_back(now.top()-&gt;val); if(flag){ if(now.top()-&gt;left) next.push(now.top()-&gt;left); if(now.top()-&gt;right) next.push(now.top()-&gt;right); now.pop(); }else{ if(now.top()-&gt;right) next.push(now.top()-&gt;right); if(now.top()-&gt;left) next.push(now.top()-&gt;left); now.pop(); } } zigarr.push_back(arr); } }; 面33:判断后序遍历序列有效性题面：给定一颗二叉搜索树的后续遍历序列，判断该后序遍历序列是否合法。 思路：依据后续遍历的定义，可以把序列依据最后一个元素K分成两半，且满足前一部分全部小于K的值，后一部分全部大于K的值，若不符合这个结论，则该后序遍历不可能存在一颗二叉树与之对应。递归的判断这两部分是否符合这些定义。 代码：bool isPostSequenceCore(int sequence[], int start, int end){ if(start &gt;= end) return true; int key = sequence[end - 1]; int split = start; while(sequence[split] &lt; key) split++; for(int i = split; i &lt; end; i++){ if(sequence[i] &lt; key) return false; } return isPostSequenceCore(sequence, start, split) &amp;&amp; isPostSequenceCore(sequence, split, end - 1); } bool isPostSequence(int sequence[], int len){ if(sequence == nullptr || len &lt;= 0) return false; return isPostSequenceCore(sequence, 0, len); } 如果是c++的话，也可以直接用指针代替start。 面34：树的路径的元素之和题面：打印出树的路径上的值之和与给定数字相同的所有路径。路径从根到叶子。 思路：dfs遍历 + 记录路径即可。 代码：void PrintPathCore(BinaryTreeNode* pNode, stack&lt;int&gt; &amp;s, int add, int expectedSum){ s.push((int)pNode-&gt;dbValue); add += (int)(pNode-&gt;dbValue); if(pNode-&gt;pLeft == nullptr &amp;&amp; pNode-&gt;pRight == nullptr){ if(add == expectedSum){ stack&lt;int&gt; sTemp; while(s.size()){ sTemp.push(s.top()); s.pop(); } while(sTemp.size()){ printf(&quot;%d-&gt;&quot;, sTemp.top()); s.push(sTemp.top()); sTemp.pop(); } printf(&quot;\\n&quot;); } // printf(&quot;%d, %d, %d\\n&quot;, expectedSum, add, s.size()); s.pop(); return; } if(pNode-&gt;pLeft) PrintPathCore(pNode-&gt;pLeft, s, add, expectedSum); if(pNode-&gt;pRight) PrintPathCore(pNode-&gt;pRight, s, add, expectedSum); s.pop(); } void PrintPath(BinaryTreeNode* pHead, int expectedSum){ if(pHead == nullptr) return; stack&lt;int&gt; s; PrintPathCore(pHead, s, 0, expectedSum); printf(&quot;\\n&quot;); } 中午时间不要打代码，太困了 437. Path Sum III 路径之和类似，但不相同。 前缀和 + 递归 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int count = 0; int pathSum(TreeNode* root, int sum) { add(root, 0); findNode(root, sum, 0); return count; } void findNode(TreeNode* root, int num, int presum){ if(!root) return; cal(root, num, presum); findNode(root-&gt;left, num, root-&gt;val); findNode(root-&gt;right, num, root-&gt;val); } void cal(TreeNode* root, int target, int presum){ if(!root) return; if(root-&gt;val - presum == target) count++; cal(root-&gt;left, target, presum); cal(root-&gt;right, target, presum); } void add(TreeNode* root, int presum){ if(!root) return; root-&gt;val += presum; add(root-&gt;left, root-&gt;val); add(root-&gt;right, root-&gt;val); } }; 写法二：提供一种递归的小小思路 class Solution { public: int count = 0; int pathSum(TreeNode* root, int sum) { if(!root) return 0; return cal(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); } int cal(TreeNode* root, int sum){ if(!root) return 0; sum -= root-&gt;val; return (sum == 0) + cal(root-&gt;left, sum) + cal(root-&gt;right, sum); } }; 最优解法：前缀和 + 回溯 + 维护前缀和出现的次数：times[presum] 突然想到3数之和。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map&lt;int, int&gt; ct = {{0,1}}; int pathSum(TreeNode* root, int sum) { int amount = 0; dfs(root, 0, sum, amount); return amount; } void dfs(TreeNode *root, int presum, int sum, int &amp;amount){ if(!root) return; root-&gt;val += presum; amount += ct[root-&gt;val - sum]; ++ct[root-&gt;val]; dfs(root-&gt;left, root-&gt;val, sum, amount); dfs(root-&gt;right, root-&gt;val, sum, amount); --ct[root-&gt;val]; } }; 面36：把二叉搜索树转化为双向链表（同链表中的内容）题面：如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。 思路：可以从递归的角度入手。对于一个节点A，中序遍历到A，则A的左子树已经转化为了链表，连接好A和A的左子树的最大节点（前一个指针）的指针则连接完成。 那对于A的右子树的最小节点B与A之间的连接，也可以看成B与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。 注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。 对于一个节点A的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点B的指针，并设置好B的右指针和A的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是NULL，所以无需修改。 代码：void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead){ if(pRoot == nullptr) return; AdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead); if(pHead == nullptr) pHead = pRoot; pRoot-&gt;pLeft = preNode; if(preNode) preNode-&gt;pRight = pRoot; preNode = pRoot; AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead); } BinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){ BinaryTreeNode *preNode = nullptr; BinaryTreeNode *pHead = nullptr; AdjustLinkCore(pRoot, preNode, pHead); return pHead; } 面36：序列化和反序列化二叉树题面：序列化定义： 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。 二叉树的序列化可以把非空节点的值序列化，把空节点序列化为$。 思路：由于序列化把空节点的信息也包含进来了，所以无需添加更多序列。 这题更像流的应用题 代码：void Serialize(BinaryTreeNode *pRoot, ostream&amp; stream){ if(pRoot == nullptr){ stream &lt;&lt; '$'; return; } stream &lt;&lt; pRoot-&gt;value &lt;&lt; ','; Serialize(pRoot-&gt;pLeft); Serialize(pRoot-&gt;pRight); } void Deserialize(BinaryTreeNode *&amp;pRoot, istream&amp; stream){ int number; if(ReadSteam(stream, &amp;number)){ pRoot = new BinaryTreeNode(); pNew-&gt;pLeft = nullptr; pNew-&gt;pRight = nullptr; pNew-&gt;value = number; } Deserialize(pRoot-&gt;pLeft, stream); Deserialize(pRoot-&gt;pRight, steam); }","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/mian-shi-ti-er-cha-shu/"},{"title":"面试题 链表相关","text":"所有关于链表的题目都会总结在这里。假设这些题目的链表的头结点都是带有效值的 定义链表struct ListNode{ int Value; ListNode* pNext; }; 尾插入节点注意第一个参数是指针的指针，因为有可能需要修改第一个链表节点。 void AddToTail(ListNode **pHead, int value){ if(pHead == null) return; ListNode *pNew = new ListNode(); pNew-&gt;Value = value; pNew-&gt;pNext = nullptr; if(*pHead == null){ *pHead = pNew; }else{ ListNode* pNode = *pHead; while(pNode-&gt;pNext != null){ pNode = pNode-&gt;pNext; } *pNode-&gt;pNext = pNew; } } 删除第一个对应值的链表viod RemoveNode(ListNode** pHead, int value){ if(pHead == nullptr || *pHead == nullptr) return; ListNode *pToDeleted = nullptr; if((*pHead)-&gt;value == value){ pToDeleted = *pHead; *pHead = (*pHead)-&gt;pNext; }else{ ListNode *pNode = *pHead; //pNode指向检查节点的前一个节点 while((*pNode)-&gt;pNext != null &amp;&amp; (*pNode)-&gt;pNext-&gt;value != value){ pNode = pNode-&gt;pNext; } if((*pNode)-&gt;pNext != null &amp;&amp; (*pNode)-&gt;pNext-&gt;value == value){ pToDeleted = (*pNode)-&gt;pNext; } } if(pToDeleted != nullptr){ delte pToDelted; pToDelted = nullptr; //释放内存后，即使是不需要使用的指针，也要做好清除工作，不然不容易维护 } } pToDeleted = *pNode-&gt;pNext;上面遍历链表中代码不应该用pToDeleted来记录链表值，否然容易出现代码指针值意义混乱，造成不该删的指针却删掉了。 面试题6 从尾到头打印链表假如对空间复杂度在O(N)O(N)之上，那么可以使用栈或者递归。 栈代码如下 void PrintListReversingly_Iteratively(ListNode* pHead){ //使用指针类型的STACK更省内存？ std::stack&lt;ListNode*&gt; nodes; ListNode* pNode = pHead; while(pNode != nullptr){ nodes.push(pNode); pNode = pNode-&gt;pNext; } while(!nodes.empty()){ pNode = nodes.top(); printf(&quot;%d\\n&quot;, pNode-&gt;value); nodes.pop(); } } 递 归代码 void PrintListReversingly_Recursively(ListNode* pHead){ if(pHead == nullptr) return; PrintListReversingly_Recursively(pHead-&gt;pNext); printf(&quot;%d\\n&quot;, pHead-&gt;pNext); } 面试18：删除一个链表节点题面：给定一个单向链表的头结点指针和一个指向待删除的节点的指针，要求用O(N)O(N)时间删除节点。 思路：教科书上的链表删除都是遍历得到上一个待删除的节点的指针，时间复杂度O(N)O(N)。显然不行，也可以直接把待删除的节点K的下一个节点J的内容复制到K上，再删除J，就可以快速删除。考虑边界上，如果没有下一个节点则需要从头遍历；如果只有一个头结点且删除的是头结点，那么只能把头结点置nullptr。 其时间复杂度为(n−1)∗O(1)+O(N)(n−1)∗O(1)+O(N)。 代码：void DeleteNode(ListNode **pHead, ListNode *pToBeDeleted){ if(pHead == nullptr || (*phead) == nullptr || (*pToBeDeleted) == nullptr ) return; ListNode *pFree = nullptr; if(pToBeDeleted-&gt;pNext){ pFree = ToBeDeleted-&gt;pNext; pToBeDeleted-&gt;value = pToBeDeleted-&gt;pNext-&gt;value; pToBeDeleted-&gt;pNext = pToBeDeleted-&gt;pNext-&gt;pNext; } //删除节点无后继节点，且是头结点 else if( *pHead == pToBeDeleted){ pFree = *pHead; *pHead = nullptr; } // 链表中多个节点，且删除节点在末尾 else{ ListNode *pCur = *pHead for(; pCur-&gt;pNext-&gt;pNext != nullptr; pCur = pCur-&gt;pNext); pFree = pCur-&gt;pNext; pCur-&gt;pNext = nullptr; } Delete pFree; } 错误点： the properiry of “*” &gt; the properity of “==” 链表插入和删除后没有设置指针 注意点： 这个函数假设了待删除的节点一定在链表中； 头结点可能删除掉，所以设置了头结点为指针的指针。 面18（题目二）：删除重复值的链表节点题面：删除一条已排序的链表中的所有的其值重复出现的节点。 思路：在上面学习的基础上，连续删除就行，应该是比较简单的。 代码：void DeleteDuplication(ListNode **pHead){ if(pHead == nullptr || *pHead == nullptr) return; ListNode *pCur = *pHead, *pPre = nullptr, *pFree = nullptr; //定义一个头结点，避免不同情况的删除 ListNode *pKid = new ListNode(); pKid-&gt;pNext = *pHead; pPre = pKid; while(pCur != nullptr){ int value = pCur-&gt;value, isDuplication = 0; //删除后面的重复节点 while(pCur-&gt;pNext &amp;&amp; pCur-&gt;pNext-&gt;value == value){ pFree = pCur-&gt;pNext; pCur-&gt;pNext = pFree-&gt;pNext; delete pFree; isDuplication = 1; } //若重复，则删除第一个重复节点 if(isDuplication){ pFree = pCur; pCur = pCur-&gt;pNext; pPre-&gt;pNext = pCur; delete pFree; // if(pFree) printf(&quot;@&quot;); } //不重复则下移 else{ pPre = pPre-&gt;pNext; pCur = pCur-&gt;pNext; } } *pHead = pKid-&gt;pNext; delete pKid; } 测试参见 面22：倒数第K个节点题面：给出一个链表，返回倒数第K个节点。 思路：最直观的思路是遍历到终点，反向遍历K-1次，但是对单链表无可奈何，而且效率不高。 第二种思路可以遍历一次求链表的长度L，第二次遍历L - K + 1个节点。但是需要遍历两次链表。 三种思路更秒，采用双指针，第一个指针先遍历K个节点，随后两个节点一起遍历，直到第一个指针为空，第二个指针就指向了倒数第K个节点。 代码：ListNode *FindKthToTail(ListNode *pHead, unsigned int K){ if(pHead == nullptr) return nullptr; ListNode *p1 = pHead, *p2 = pHead; for(int i = 0; i &lt; K; i++){ if(p1 == nullptr) return nullptr; p1 = p1-&gt;pNext; } while(p1!=nullptr){ p1 = p1-&gt;pNext; p2 = p2-&gt;pNext; } return p2; } 这代码写的比剑指offer代码写的优美多了 相关扩展：相关题目有找出链表的中间节点；判断一个链表是否有环；更难一点判断链表的环的入口节点！ 其思路宗旨都是使用两个进度不一样的指针指向不同的节点来解决问题！ 面23：链表中的环的入口节点题面：给出一个链表，求出其成环的入口节点。 思路：首先得判断有环，可以使用一个快一慢的两只指针（移动速度分别为2和1）指向链表头。如果链表有环，则快慢指针就一定会相遇。 那么对于有环的链表如何确定其入口节点呢？假设环的中节点有K个，快指针从头先遍历K次之后，快慢指针同时开始遍历，正好两个指针会在入口节点上汇合！ 如何确定环中节点呢？这个！可以直接在确定有环后，记录下该节点的位置，再继续遍历直到重新到该节点同时统计经过的节点数量即可。 amazing啊 代码：ListNode *FindCycleNode(ListNode* pHead){ if(pHead == nullptr) return nullptr; ListNode *pSlow, *pQuick, *pRecord = nullptr ; //判断有没有环 pSlow = pQuick = pHead; while(pQuick != nullptr){ pQuick = pQuick-&gt;pNext; if(pQuick) pQuick = pQuick-&gt;pNext; if(pSlow) pSlow = pSlow-&gt;pNext; if(pSlow == pQuick) break; } if(pQuick == nullptr) return nullptr; //确定环内数量 pRecord = pSlow; int numberOfCycle = 0; while(pRecord != pSlow){ numberOfCycle++; pSlow = pSlow-&gt;pNext; } //确定环的入口节点 pSlow = pQuick = pHead; for(int i = 0; i &lt; numberOfCycle; i++){ pQuick = pQuick-&gt;pNext; } while(pSlow != pQuick){ pQuick = pQuick-&gt;pNext; pSlow = pSlow-&gt;pNext; } return pSlow; } 面24：反转链表题面：输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。 思路：在反转过程中，假设有三个顺序排列的待反转的链表i，j，k，其中j是待反转的链表。初始化，i为空指针，j为头节点，k为头结点的下一个指针指向的内容（可能为空），并把i的指针指空。在链表反转过程如下：j的指针指向i，然后把i，j，k分别按次序向后移动。重复执行上述步骤直到j为空。 代码：ListNode *ReverseList(ListNode *pHead){ if(pHead == nullptr) return nullptr; ListNode *p1 = nullptr, *p2 = pHead, *p3 = pHead-&gt;pNext; while(p2 != nullptr){ p2-&gt;pNext = p1; p1 = p2; p2 = p3; if(p3) p3 = p3-&gt;next; } return p2; } 面25：合并链表题面：将两个链表增序合并成一条链表。 思路：用两个指针指向两条链表的头结点，用合并数组的思路合并即可。注意一条链表为空后，另一条不为空的链表可以直接连上去。 代码：ListNode *Merge(ListNode *pHead1, ListNode *pHead2){ if( pHead1 == nullptr &amp;&amp; pHead2 == nullptr){ return nullptr; }else if(pHead1 == nullptr) return pHead2; else if(pHead2 == nullpr) return pHead1; ListNode *p1 = pHead1, *p2 = pHead2, *pHead3 = new ListNode(), *p3 = pHead3; while(p1 &amp;&amp; p2){ if(p1-&gt;value &lt;= p2-&gt;value){ p3-&gt;pNext = p1; p3 = p1; p1 = p1-&gt;pNext; }else{ p3-&gt;pNext = p2; p3 = p2; p2 = p2-&gt;pNext; } } p3-&gt;pNext = nullptr; if(p1){ p3-&gt;pNext = p1; }else if(p2){ p3-&gt;pNext = p2; } ListNode *pFree = pHead3; pHead3 = pHead-&gt;pNext; delete pFree; return pHead3; } 测试参见 面35：复杂链表的分解题面：给出一个有两个指针的链表数据结构，一个指针1指向下一个节点，另一个指针2可指向任意一个节点，或者为空。将给出的链表复制并返回头结点。 思路：这题目还是挺不错的！属于比较复杂的题目，而且有思考空间。 将复制的过程分解为两个部分，第一步先不管指针2，复制整个链表；第二步再设置指针2。第一步需要的复杂度为O(N)O(N)。第二步再复制的过程中需要确定复制链表中指针2指向的节点的的位置。 第一种确定位置的思路：就是从原链表遍历寻找原指针指向的节点位置，同样的在复制链表上一起遍历。复杂度为O(N2)O(N2)。 第二种确定位置的思路：直接用hash表记录下原链表中节点和复制链表中对应节点的映射关系。复杂度为O(N)O(N)。是用了空间换时间的思路。 害怕碰撞。 脱离上面的方案的限制，更巧妙的方法来了。链表的顺序遍历远远比随机遍历方便很多，而且指针指向的节点的位置不随链表节点而变化。可以考虑把复制节点直接插入到被复制节点的后面。全部复制完成后，由于原节点的指针2指向的节点的后一个节点就是复制节点的指针2指向的节点，所以可以直接指向。复杂度为O(N)O(N)，空间复杂度为O(1)O(1)。 代码：struct ComplexListNode{ int value; ComplexListNode *pNext; ComplexListNode *pSibling; } void CopyNode(ComplexListNode *pHead){ if(pHead == nullptr) return null; ComplexListNode *pNode = pHead; while(pNode){ ComplexListNode *pNew = new ComplexListNode(); pNew-&gt;value = pNode-&gt;value; pNew-&gt;pNext = pNode-&gt;pNext; pNew-&gt;pSibling = nullptr; pNode-&gt;pNext = pNew; pNode = pNew-&gt;pNext; } } void SetSiblingLink(ComplexListNode * pHead){ if(pHead == nullptr )return nullptr; ComplexListNode *pNode = pHead; while(pNode){ ComplexListNode *pNext = pNode-&gt;pNext; pNext-&gt;pSibling = pNode-&gt;pSibliing-&gt;pNext; pNode = pNext-&gt;pNext; } } ComplexListNode *GetComplexList(ComplexListNode *pHead){ if(pHead == nullptr) return nullptr; ComplexListNode *pNode = pHead; ComplexListNode *pClonedHead = pNode-&gt;pNext; ComplexListNode *pClonedNode = pNode-&gt;pNext; pNode-&gt;next = pClonedNode-&gt;next; pNode = pClneNode-&gt;next; while(pNode){ pClonedNode-&gt;pNext = pNode-&gt;pNext; pNode-&gt;pNext = pNode-&gt;pNext-&gt;pNext; pClonedNode = pNode-&gt;pNext; pNode = pClonedNode-&gt;pNext; /* //we can write in this way. pClonedNode-&gt;pNext = pNode-&gt;pNext; pClonedNode = pClonedNode-&gt;pNext; pNode-&gt;pNext = pClonedNode-&gt;pNext; pNode = pNode-&gt;pNext; */ } return pClonedHead; } ComplexListNode *Clone(ComplexListNode* pHead){ CopyNode(pHead); SetSiblingLink(pHead); return GetComplexList(pHead); } 面36：把二叉搜索树转化为双向链表题面：如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。 思路：可以从递归的角度入手。对于一个节点A，中序遍历到A，则A的左子树已经转化为了链表，连接好A和A的左子树的最大节点（前一个指针）的指针则连接完成。 那对于A的右子树的最小节点B与A之间的连接，也可以看成B与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。 注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。 对于一个节点A的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点B的指针，并设置好B的右指针和A的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是NULL，所以无需修改。 代码：void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead){ if(pRoot == nullptr) return; AdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead); if(pHead == nullptr) pHead = pRoot; pRoot-&gt;pLeft = preNode; if(preNode) preNode-&gt;pRight = pRoot; preNode = pRoot; AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead); } BinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){ BinaryTreeNode *preNode = nullptr; BinaryTreeNode *pHead = nullptr; AdjustLinkCore(pRoot, preNode, pHead); return pHead; } 面52：两个链表的第一个公共节点题面：如题。 思路：明显地，可以用栈来存储两个链表遍历过程。空间复杂度和时间复杂度都是O(N)O(N)。 换一种想法，能不能直接遍历就使两个链表同时遍历到第一个公共节点。定义两个指针来遍历两条链表。只要让一个指向长链表的节点的指针多走多出的节点，就可以让两个节点同时同序的遍历到公共节点。时间复杂度为O(N+M)O(N+M)，空间复杂度O(1)O(1)。 代码：int GetLenOfList(ListNode *pHead){ int len = 0; ListNode *pNode = pHead; while(pNode){ pNode = pNode-&gt;pNext; len++; } return len; } ListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2){ if(pHead1 == nullptr || pHead2 == nullptr) return nullptr; int len1 = GetLenOfList(pHead1); int len2 = GetLenOfList(pHead2); if(len1 &lt; len2){ swap(pHead1, pHead2); swap(len1, len2); } int step = len1 - len2; ListNode *pNode1 = pHead1; ListNode *pNode2 = pHead2; while(step){ pNode1 = pNode-&gt;pNext; step--; } while(pNode1 != pNode2){ pNode1 = pNode1-&gt;pNext; pNode2 = pNode1-&gt;pNext; } //two pNodes maybe refer to null or the first common node. return pNode1; } 更简单的解法： 双指针遍历两条链表，遍历到结尾则跳到另一条链表上。路径长度的相等一定会有两个指针相遇。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p1 = headA, *p2 = headB; while(p1 != p2){ p1 = p1 == nullptr ? headB : p1-&gt;next; p2 = p2 == nullptr ? headA : p2-&gt;next; } return p1; } }; 链表回文判断234. Palindrome Linked List O(n)时间，O(1)空间 思路：朴素的思路：先用快慢指针找到链表中间节点，之后翻转后半部分链表。判断两个链表是否相同。 其中奇数个节点链表需要考虑一下。 代码/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { ListNode *slow ,*quick; slow = quick = head; while(quick &amp;&amp; quick-&gt;next){ slow = slow-&gt;next; quick = quick-&gt;next-&gt;next; } ListNode *p2 = reverseList(slow), *p1 = head; while(p1 &amp;&amp; p2){ if(p1-&gt;val != p2-&gt;val) return false; p1 = p1-&gt;next; p2 = p2-&gt;next; } return true; } ListNode *reverseList(ListNode* head){ if(head == nullptr) return head; ListNode *per = nullptr, *cur = head, *next = head-&gt;next; while(cur){ cur-&gt;next = per; per = cur; cur = next; if(next) next = next-&gt;next; } return per; } }; 奇偶链表节点分解非常容易写复杂的题目。 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* oddEvenList(ListNode* head) { if(!(head &amp;&amp; head-&gt;next)) return head; // ListNode *p1 = head, *p2 = new ListNode(), *evenHead = p2, *pre = nullptr; // while(p1 &amp;&amp; p1-&gt;next){ // p2-&gt;next = p1-&gt;next; // p2 = p2-&gt;next; // p1-&gt;next = p2-&gt;next; // pre = p1; // p1 = p2-&gt;next; // } // p2-&gt;next = nullptr; // p1 = p1 ? p1 : pre; // p1-&gt;next = evenHead-&gt;next; // delete evenHead; // return head; ListNode *evenHead = head-&gt;next, *odd = head, *even = head-&gt;next; while(even &amp;&amp; even-&gt;next){ odd-&gt;next = even-&gt;next; odd = odd-&gt;next; even-&gt;next = odd-&gt;next; even = even-&gt;next; } odd-&gt;next = evenHead; return head; } }; 删除倒数第N个节点/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode node, *pre = &amp;node; pre-&gt;next = head; ListNode *quick, *slow; quick = slow = pre; for(int i = 0; i &lt; n; ++i) quick = quick-&gt;next; while(quick-&gt;next){ quick = quick-&gt;next; slow = slow-&gt;next; } ListNode *fordel = slow-&gt;next; slow-&gt;next = fordel-&gt;next; if(fordel == head){ //删除节点 务必小心：1.删了头结点，需要重置头结点 2.考虑后续节点 head = fordel-&gt;next; } delete fordel; return head; } };","link":"/2020/08/07/shua-ti-shu-ju-jie-gou-lian-biao-mian-shi-ti-lian-biao-xiang-guan/"},{"title":"最大值减去最小值小于或等于num的子数组数量","text":"最大值减去最小值小于或等于num的子数组数量超级复合怪 思路： n^3解法暴力 尝试用滑动窗口的思路去做。相邻子数组最大最小的值，可用双头队列的最大栈和最小栈进行维护。先扩展右边，根据性质维护左边，即可。发现每个符合性质的子数组都可提取新的(j - i + 1)个以右起点为右端点的新数组。综合计算复杂度$O(N)$。 #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;deque&gt; using namespace std; int res = 0; int main(){ int n, num; cin &gt;&gt; n &gt;&gt; num; vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; ++i) cin &gt;&gt; arr[i]; deque&lt;int&gt; maxv, minv; int i = 0, j = -1; while( ++j &lt; n ){ while(maxv.size() &amp;&amp; arr[maxv.back()] &lt;= arr[j]){ maxv.pop_back(); } while(minv.size() &amp;&amp; arr[minv.back()] &gt;= arr[j]){ minv.pop_back(); } minv.push_back(j); maxv.push_back(j); while(maxv.size() &amp;&amp; minv.size() &amp;&amp; arr[maxv.front()] - arr[minv.front()] &gt; num){ if(maxv.front() == i) maxv.pop_front(); if(minv.front() == i) minv.pop_front(); ++i; } res += j - i + 1; // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; res &lt;&lt; endl; } cout &lt;&lt; res &lt;&lt; endl; }","link":"/2021/06/17/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/zui-da-zhi-jian-qu-zui-xiao-zhi-xiao-yu-huo-deng-yu-num-de-zi-shu-zu-shu-liang/"},{"title":"最大子矩阵","text":"类似于面试题17.24； 不过是每个单元的元素只是一，可以把问题转化为求取面积。 直接用单调栈求取从一个柱子可扩展的的最大面积即可。 代码#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;stack&gt; using namespace std; int n , m; vector&lt;int&gt; height; int maxarea = 0; void caculateArea(vector&lt;int&gt;&amp;area){ for(int i = 0; i &lt; area.size(); ++i){ if(area[i]) height[i] += area[i]; else height[i] = 0; } stack&lt;int&gt; st; height.push_back(0); for(int i = 0; i &lt; height.size(); ++i){ while(st.size() &amp;&amp; height[st.top()] &gt;= height[i]){ int hei = height[st.top()]; st.pop(); int l = st.size() ? st.top() : -1; maxarea = max(maxarea, (i - 1 - l)* hei); // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; maxarea &lt;&lt; ' ' &lt;&lt; i - 1 &lt;&lt; ' ' &lt;&lt; hei&lt;&lt; endl; } st.push(i); } height.erase(height.end() - 1); } int main(){ cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; maze(m); height.resize(m); for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j) cin &gt;&gt; maze[j]; caculateArea(maze); } cout &lt;&lt; maxarea &lt;&lt; endl; return 0; }","link":"/2021/05/26/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/zui-da-zi-ju-zhen/"},{"title":"1239. 串联字符串的最大长度","text":"思路：二进制化 + 二位搜索 代码： class Solution { queue&lt;int&gt; que; public: int maxLength(vector&lt;string&gt;&amp; arr) { int onehot , maxlen = 0; // 2^n算法 for(string s : arr ) { int onehot; if(!w2i(s, onehot)) continue; que.push(onehot); int n = que.size(); while(n--) { int v = que.front(); que.pop(); que.push(v); if((v &amp; onehot) == 0) { que.push(v | onehot); } } } while(que.size()) { int v = que.front(); que.pop(); maxlen = max(maxlen, onehotLen(v)); } return maxlen; } int onehotLen(int v) { int t = 0; while(v) { if(v &amp; 1) ++t; v &gt;&gt;= 1; } return t; } bool w2i(string s, int &amp;onehot) { set&lt;char&gt; setc; onehot = 0; for(auto c : s){ if(setc.count(c) == 1) { return false; }else{ onehot |= (1 &lt;&lt; (c - 'a')); setc.insert(c); } } return true; } };","link":"/2021/06/19/shua-ti-wei-yun-suan-1239-chuan-lian-zi-fu-chuan-de-zui-da-chang-du/"},{"title":"人生的不幸","text":"人生中最痛苦不是身体残疾，目不能视，耳不能听；也不是原生家庭带来性格扭曲，从小的身微言轻，家境清贫；更不是高考落榜，身陷囹圄，工作遇阻。而是无法接受现状，不能认清自我的能力的边界，贪求不能现在得到的欲望，终日惶惶思索财路，入睡夜夜欲求不止。这种终身收自己精神折磨的人，从不愿意放自己一马的人，才是不幸的人。那些绝望求死的人，至少还有死的勇气。 伤口会自己长好，伤疤会慢慢消除，一切要建立在你先接受自己如果不完美的前提下。如果你每天把自己的伤口翻出来给自己看，给别人看，那么她不仅愈合不了，还可能感染加重。很多时候，无休止的自怜，求怜，反而加重了心态对人的控制。 有时候，挡在我们面前的墙都是我们自己砌上去的，只要你愿意，你就能把他轻轻推倒。只是你愿不愿意的问题。其实人生很简单，只要能去除不必要的负担，和自己将和，摆脱精神的折磨，自主掌握命运。 现在城市里很多年轻父母为了子女不输在起跑线上而操碎了心，实际上，一个人能跑多远，更多地取决于他对自己人生有多大的掌控能力，而这个掌控能力，其中最重要的部分是处理挫折和失败的能力。有时候你觉得自己不成功，并不是环境和机遇的问题，而是你修炼不够。","link":"/2021/06/19/ren-sheng-de-bu-xing/"}],"tags":[{"name":"折腾","slug":"折腾","link":"/tags/%E6%8A%98%E8%85%BE/"},{"name":"反思","slug":"反思","link":"/tags/%E5%8F%8D%E6%80%9D/"},{"name":"bugs","slug":"bugs","link":"/tags/bugs/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"}],"categories":[{"name":"刷题","slug":"刷题","link":"/categories/%E5%88%B7%E9%A2%98/"},{"name":"随谈","slug":"随谈","link":"/categories/%E9%9A%8F%E8%B0%88/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Code tools","slug":"Code-tools","link":"/categories/Code-tools/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"DL","slug":"AI/DL","link":"/categories/AI/DL/"},{"name":"Algorithms","slug":"CS/Algorithms","link":"/categories/CS/Algorithms/"},{"name":"CN","slug":"CS/CN","link":"/categories/CS/CN/"},{"name":"CSAPP","slug":"CS/CSAPP","link":"/categories/CS/CSAPP/"},{"name":"DB","slug":"CS/DB","link":"/categories/CS/DB/"},{"name":"DS","slug":"CS/DS","link":"/categories/CS/DS/"},{"name":"Anki","slug":"Code-tools/Anki","link":"/categories/Code-tools/Anki/"},{"name":"Blog","slug":"Code-tools/Blog","link":"/categories/Code-tools/Blog/"},{"name":"Git","slug":"Code-tools/Git","link":"/categories/Code-tools/Git/"},{"name":"Linux","slug":"Code-tools/Linux","link":"/categories/Code-tools/Linux/"},{"name":"VScode","slug":"Code-tools/VScode","link":"/categories/Code-tools/VScode/"},{"name":"Windows","slug":"Code-tools/Windows","link":"/categories/Code-tools/Windows/"},{"name":"build","slug":"Code-tools/build","link":"/categories/Code-tools/build/"},{"name":"C++","slug":"Language/C","link":"/categories/Language/C/"},{"name":"Go","slug":"Language/Go","link":"/categories/Language/Go/"},{"name":"Python","slug":"Language/Python","link":"/categories/Language/Python/"},{"name":"DP","slug":"刷题/DP","link":"/categories/%E5%88%B7%E9%A2%98/DP/"},{"name":"位运算","slug":"刷题/位运算","link":"/categories/%E5%88%B7%E9%A2%98/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"其他","slug":"刷题/其他","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96/"},{"name":"分治","slug":"刷题/分治","link":"/categories/%E5%88%B7%E9%A2%98/%E5%88%86%E6%B2%BB/"},{"name":"双指针","slug":"刷题/双指针","link":"/categories/%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"字符串","slug":"刷题/字符串","link":"/categories/%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"排序","slug":"刷题/排序","link":"/categories/%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/"},{"name":"数学","slug":"刷题/数学","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E5%AD%A6/"},{"name":"模拟","slug":"刷题/模拟","link":"/categories/%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/"},{"name":"贪心","slug":"刷题/贪心","link":"/categories/%E5%88%B7%E9%A2%98/%E8%B4%AA%E5%BF%83/"},{"name":"~其他code能力","slug":"刷题/其他code能力","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96code%E8%83%BD%E5%8A%9B/"},{"name":"搜索","slug":"刷题/搜索","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/"},{"name":"数据结构","slug":"刷题/数据结构","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"沟通能力","slug":"刷题/其他code能力/沟通能力","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96code%E8%83%BD%E5%8A%9B/%E6%B2%9F%E9%80%9A%E8%83%BD%E5%8A%9B/"},{"name":"代码规范","slug":"刷题/其他code能力/代码规范","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96code%E8%83%BD%E5%8A%9B/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"扫描线","slug":"刷题/其他/扫描线","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"bfs","slug":"刷题/搜索/bfs","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/bfs/"},{"name":"dfs","slug":"刷题/搜索/dfs","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/dfs/"},{"name":"回溯","slug":"刷题/搜索/回溯","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/%E5%9B%9E%E6%BA%AF/"},{"name":"记忆化搜索","slug":"刷题/搜索/记忆化搜索","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"二分","slug":"刷题/搜索/二分","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86/"},{"name":"set","slug":"刷题/数据结构/set","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/set/"},{"name":"优先队列","slug":"刷题/数据结构/优先队列","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"哈希","slug":"刷题/数据结构/哈希","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/"},{"name":"图","slug":"刷题/数据结构/图","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"},{"name":"堆","slug":"刷题/数据结构/堆","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"},{"name":"复杂数据结构","slug":"刷题/数据结构/复杂数据结构","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈和队列","slug":"刷题/数据结构/栈和队列","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"name":"树","slug":"刷题/数据结构/树","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"},{"name":"链表","slug":"刷题/数据结构/链表","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"},{"name":"单调栈","slug":"刷题/数据结构/栈和队列/单调栈","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/"}]}