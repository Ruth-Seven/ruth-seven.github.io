{"pages":[],"posts":[{"title":"DeepLearning 读书笔记","text":"DeepLearning读书笔记（1）数学符号英语名词: Identity matrix：单位矩阵 Moore–Penrose pseudo inverse：摩尔－彭若斯广义逆 Determinant：行列式 Partial derivative ：偏微分 Gradient ：梯度 Definate integral：定积分 Variance：方差 Covariance：协方差 Shannon entropy：香农熵 Kullback-Leibler divergence：KL散度 Composition of the funcitions：函数的组合 parametrize：参数化 softplus： 公式如下 log(1+ex)log(1+ex) The empirical distribution：经验分布（往往有训练集定义的） 疑惑处： (P14) jocabian matrix 和 The Hessian matrix. 绪论人类作为的地球上最智能的灵长类动物，可以高效地处理许多非形式化任务——难以用数学公式描述的问题，而计算机与人类正好相反，擅长处于规则化问题。AI(artificial intelligence)拥有从数据或者世界中学习模式的能力，这称之为machine learning。 简单模型的学习能力极大的依赖于数据特征。对于复杂的特征工作，表示学习 （representation learning）可以从复杂的数据中学习到远远优于人类所做出的的特征表示，仅需要稍稍的人工干预。表示学习一个典型代表就是自动编码器（autoencoder）。学习特征或者设计特征的算法的目的就是为了分离出factors of variation——影响事物变化的因素，比如识别车任务中的车轮，识别语音中的讲话人的年龄、性别。","link":"/2020/08/07/AI/DL/DeepLearning-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"LCA问题","text":"LCA问题即最近公共祖先问题 常见解法有递归法，向上","link":"/2020/08/07/CS/Algorithms/LCA%E9%97%AE%E9%A2%98/"},{"title":"中缀式计算","text":"中缀表示式计算分为两个步骤，一是中缀转后缀，二是后缀表达式计算； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std;stack&lt;char&gt; stop; // 符号栈map&lt;char, int&gt; opp; // 运算符 映射到优先级 the priority of operatorsstack&lt;double&gt; stn;// 数字栈string mid2Post(string s){ string res; for(int i = 0; i &lt; s.size(); i++){ if(isdigit(s[i]) || s[i] == '.') res += s[i]; else{ if(s[i] == ' ') continue; //去空格 if(s[i] == '(') stop.push(s[i]); else if(s[i] == ')'){ while(stop.top() != '('){ res += stop.top(); stop.pop(); } stop.pop(); }else{ int pro = opp[s[i]]; //为运算符两旁数字插入空格,否则无法区分数字 res += ' '; //pop出运算优先级高的运算操作符 while( !stop.empty() &amp;&amp; pro &lt;= opp[stop.top()]){ //注意这里stack要有数据, res += stop.top(); stop.pop(); } stop.push(s[i]); } } } while(!stop.empty()){ res += stop.top(); stop.pop(); } return res;}// 获取正数（可有小数点）double getNum(string &amp;str, int &amp;pos){ int k = pos, flag = 1;// flag = 1表计算正整数 double inter = 0, fac = 0, pow10 = 10; while(isdigit(str[k]) || str[k] == '.'){ if( str[k] == '.') flag = 0; else if(flag == 1){ //计算正整数 inter = inter * 10 + (double)(str[k] - '0'); //地址？ }else{ // 计算小数 fac += (double)(str[k]-'0') / pow10; pow10 *= 10; } k++; if(k &gt;= str.size() ) break; } pos = k; return inter + fac;}//计算后缀表达式的值double calPost(string pStr){ if(pStr.size() == 0) return 0; for(int i = 0; i &lt; pStr.size(); i++){ if(isdigit(pStr[i])){ //对于数字 double t = getNum(pStr, i); i--; //多加了一次i printf(\"%f\\n\", t); stn.push(t); }else if(pStr[i] == '+' || pStr[i] == '-' || pStr[i] == '*' || pStr[i] == '/') { // 对于运算符（不包括小数，理论上规范的格式中应该被数据包裹着） double op2 = stn.top(); stn.pop(); //注意压栈后 数据顺序是反的 double op1 = stn.top(); stn.pop(); if(pStr[i] == '+') stn.push(op1 + op2); else if(pStr[i] == '-') stn.push(op1 - op2); else if(pStr[i] == '*') stn.push(op1 * op2); else if(pStr[i] == '/') stn.push(op1 / op2); //不做非零判断了 } } if( stn.size() != 1){ printf(\"error! the size of stck of num isn't 1.\\n\"); return -1; } return stn.top();}int main(){ //freopen(\"data.in\", \"r\", stdin); string str; getline(cin, str); cout &lt;&lt; str &lt;&lt; endl; opp['+'] = opp['-'] = 1; opp['/'] = opp['*'] = 2; opp['('] = 0; //'(' 特殊处理 string pStr = mid2Post(str); cout &lt;&lt; pStr &lt;&lt; endl; double calRes = calPost(pStr); printf(\"%.2lf\\n\", calRes);} 细节上也可以再改动，比如在识别数字的时候就把它提取出来并用结构体的形式存储下来。","link":"/2020/08/07/CS/Algorithms/%E4%B8%AD%E7%BC%80%E5%BC%8F%E8%AE%A1%E7%AE%97/"},{"title":"关键路径","text":"​ ``` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;const int mss = 1e3 + 100;const int INF = 0x3fffffff;int edge[mss][mss], n, m;int ve[mss], vl[mss], e[mss][mss], l[mss][mss];int ingree[mss], maxtime;stack&lt;int&gt; stk;vector&lt;int&gt; activity[mss], tempp;int topu(){ queue&lt;int&gt; que; for(int i = 1;i &lt;= n;i++) if(ingree[i] == 0) que.push(i); while(que.size()){ int u = que.front(); que.pop(); stk.push(u); for(int i = 1; i &lt;= n;i++){ if(edge[u][i] != INF){ ingree[i] --; if(ingree[i] == 0) que.push(i); ve[i] = max(ve[i], ve[u] + edge[u][i]);// 拓扑排序兵同时计算 每个节点的最早开始时间// cout &lt;&lt; ve[u] &lt;&lt; endl; } } } if(stk.size() == n) return true; else return false;}int critical_path(){ //初始化汇点 int maxv = 0; for(int i = 1;i &lt;= n; i++) if( maxv &lt; ve[i]) maxv = ve[i]; for(int i = 1;i &lt;= n; i++) vl[i] = maxv; maxtime = maxv; //逆拓扑排序地计算每个节点的最晚开始时间 while(stk.size()){ int u = stk.top(); stk.pop(); for(int i = 1;i &lt;= n;i++){ if(edge[u][i] != INF) vl[u] = min( vl[u], vl[i] - edge[u][i]); } } // 查找关键路径 for(int i = 1;i &lt;= n;i ++){ for(int j = 1;j &lt;= n;j ++){ if(edge[i][j] != INF){ e[i][j] = ve[i]; l[i][j] = vl[j] - edge[i][j]; if(e[i][j] == l[i][j]){//插入path 以便查询所关键路径 activity[i].push_back(j); } } } } //排序以保证按序输出 for(int i = 0;i &lt;= n; i++){ sort(activity[i].begin(), activity[i].end()); }}int dfs(int u){//输出所有关键路径 tempp.push_back(u);// cout &lt;&lt; u &lt;&lt; endl; if(activity[u].size() == 0){ for(int i =0 ;i &lt; tempp.size() ;i++){ cout &lt;&lt; tempp[i]; if(i + 1 != tempp.size()) cout &lt;&lt; \"-&gt;\"; else cout &lt;&lt; \"\\n\"; } }else { for(int i = 0;i &lt; activity[u].size(); i++) dfs( activity[u][i]); } tempp.pop_back();}int main(){ fill(edge[0], edge[0] + mss * mss, INF); int u, v, w; cin &gt;&gt; n &gt;&gt; m; for(int i = 0;i &lt; m;i++){ cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge[u][v] = w; ingree[v]++; } if(!topu()){ cout &lt;&lt; \"NO\\n\"; return 0; } cout &lt;&lt; \"YES\\n\"; critical_path(); int q; cin &gt;&gt; q; for(int i = 0;i &lt; q;i++){ cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; e[u][v] &lt;&lt; ' ' &lt;&lt; l[u][v] &lt;&lt; endl; } cout &lt;&lt; maxtime &lt;&lt; endl; for(int i = 1;i &lt;= n;i++) if( activity[i].size() &amp;&amp; ve[i] == 0) dfs(i); //一个关键路径的起点的后序存在节点的 且最早开始时间为0}","link":"/2020/08/07/CS/Algorithms/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"},{"title":"双指针法","text":"双指针算法作为编程中的一种思想，利用了数据有序性，有效减少了算法复杂度。比如在两数之和的题目，可达到O(n)O(n)复杂度，而非O(n2)O(n2)。在序列递增的数组中找两个数之和为aim。 对于a[i]+a[j]==Ma[i]+a[j]==M, 结果成立； 对于a[i]+a[j]&lt;Ma[i]+a[j]&lt;M，则有a[i−1]+a[j]&lt;Ma[i−1]+a[j]&lt;M成立，但是a[i+1]+a[j]a[i+1]+a[j]大小未知。尝试ii向上移动 对于a[i]+a[j]&gt;Ma[i]+a[j]&gt;M，则有a[i]+a[j+1]&gt;Ma[i]+a[j+1]&gt;M成立，但是a[i]+a[j−1]a[i]+a[j−1]大小未知。尝试jj向上移动 上面的算法推导有一个不太严谨的地方：没有证明[0,i−1]和[j+1,n−1][0,i−1]和[j+1,n−1]之间的元素的任何搭配不成立。 诶好像可以用归纳法！ 1234567891011int aim, i = 0, j = n - 1;while(i&lt;j){ int sum = arr[i] + arr[j]; if(sum ==aim){ pirntf(\"%d,%d\\n\", arr[i], arr[j]); i++; j--; } if(sum &lt; aim){ i++ }else j--; } 其他例子，如两个数列合并的双指针例子。","link":"/2020/08/07/CS/Algorithms/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"},{"title":"字符串hash","text":"滚动哈希：O(n+m)时间内完成字符串匹配；实现：选取两个台适的互素数$b$和h(l&lt;b&lt;h)，假设字符串 C=clc2c3…CmC=clc2c3…Cm，定义哈希函数：$$H(C)=(C_1b_{m−1}+C_2b_{m−2}+⋯+C_mb_0)$$ 其中b是基数。 可以得出O(n)的时间复杂度就可以计算得到一个串的Hash值。而由取余性质 $$(A+B)$$ 以滚动计算hash值，可实现以复杂度O(1)O(1)计算每个母串的长度为nn子串的hash值。最后再O(n+m)时间内完成字符串匹配。在实现时，可以使用64位无符号整数计算哈希值，并取M等于264264，通过自然溢出省去求模运算。 1234567891011121314151617181920212223typedef unsigned long long ull;const ull b=100000007;//哈希的基数；//C是否在S中出现bool contain(string C,string S){ int m = C.length(), n = S.length(); if(m &gt; n) return false; //计算b的m次方 ull t=1; for(int i = 0;i &lt; m; i++) t *= b; //计算C和S长度为m的前缀对应的哈希值 ull Chash=0, Shash=0; for(int i = 0;i &lt; m; i++) Chash = Chash * b + C[i]; for(int i = 0; i &lt; m; i++) Shash = Shash * b + S[i]; //对S不断右移一位，更新哈希值并判断 for(int i = 0; i + m &lt; n; i++){ if(Chash == Shash) return true;//S从位置i开始长度为m的字符串子串等于C； Shash = Shash * b - S[i] * t + S[i+m]; } return false;}","link":"/2020/08/07/CS/Algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/"},{"title":"快速幂","text":"快速幂算法，也称二分幂。 递归写法： 123456789typedef long long ll;ll binaryPow(ll a, ll b, ll m){ if(b == 0) return 1; if(b &amp; 1) return a * binaryPow(a, b - 1, m) % m; else{ ll mul = binaryPow(a, b / 2, m); return mul * mul % m; }} 迭代写法： 1234567891011typedef long long ll;ll binaryPow(ll a, ll b, ll m){ ll res = 1， pow = a; while(b){ if(b &amp; 1) res = res * pow % m; //注意这两个地方的取余 pow = pow * pow % m; b &gt;&gt; 1; } return res;}","link":"/2020/08/07/CS/Algorithms/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"title":"拓扑排序","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** This is Code of JJProblem :拓扑排序Source :Solution :AnyDetial :DateAndTime :2.26CostofTime :**/#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;using namespace std;const int N = 1e3;vector&lt;int&gt;adj[N];int indegree[N],dvis[N];int n,m;vector&lt;int&gt;res;bool topu(){ int sortnum = 0; queue&lt;int&gt;q; for(int i=0;i&lt;n;i++) { if(indegree[i]==0) q.push(i); } while(!q.empty()) { int u = q.front(); cout&lt;&lt; u &lt;&lt; endl; q.pop(); for(int j=0;j&lt;adj[u].size();j++) { int k = adj[u][j]; indegree[k]--; if(indegree[k]==0) { q.push(k); } } sortnum++; } if(sortnum==n) return true; else return false;}//dfs 逆序输出拓扑排序stack&lt;int&gt; s;int vis[N];void dfs(int u){ vis[u] = 1; for(int i=0;i&lt;adj[u].size();i++){ int v = adj[u][i]; if(!vis[v]){ dfs(v); } } s.push(u); cout&lt;&lt;u&lt;&lt;endl;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); int c1, c2, w; for(int j=0;j&lt;m;j++) { scanf(\"%d%d\",&amp;c1,&amp;c2); adj[c1].push_back(c2); indegree[c2] ++; } topu();}/*5 50 11 33 40 22 4*/w","link":"/2020/08/07/CS/Algorithms/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"title":"排序总结","text":"交换类？选择排序不具有稳定性，复杂度稳定在O(n2)O(n2)。 存在不同元素大范围交换，所以不稳定。 1234567891011121314151617181920int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[6] = {5, 3, 2, 1, 7, 2}, n = 6; for(int i = 0; i &lt; n; i++){ int mp = i; for(int j = i + 1; j &lt; n; j++){ if(c[j] &lt; c[mp]){ mp = j; } } int temp = c[mp]; c[mp] = c[i]; c[i] = temp; } for(int i=0; i &lt; n; i++){ printf(&quot;%d &quot;, c[i]); } printf(&quot;\\n&quot;); return 0;} 冒泡排序具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。 123456789101112131415161718192021int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[6] = {5, 3, 2, 1, 7, 2}, n = 6; for(int i=0; i &lt; n-1; i++){ int flag = 0; for(int j=0; j &lt; n - 1 - i; j++){ if(c[j] &gt; c[j+1]){ int temp = c[j]; c[j] = c[j + 1]; c[j + 1 ] = temp; flag = 1; } } if(!flag) break; } for(int i=0; i &lt; n; i++){ printf(&quot;%d &quot;, c[i]); } printf(&quot;\\n&quot;); return 0;} ？？插入排序具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。 1234567891011121314151617int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[6] = {5, 3, 2, 1, 7, 2}, n = 6; for(int i = 1; i &lt; n; i++){ int j = i, t = c[j]; while(j &gt; 0 &amp;&amp; t &lt; c[j - 1]){ c[j] = c[j - 1]; j--; } c[j] = t; } for(int i=0; i &lt; n; i++){ printf(&quot;%d &quot;, c[i]); } printf(&quot;\\n&quot;); return 0;} 归并排序稳定，复杂度为O(nlgn)O(nlgn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int printArr(int A[], int r, int l){ for(int i=r; i &lt; l + 1; i++){ printf(&quot;%d &quot;, A[i]); } printf(&quot;\\n&quot;);}const int maxn = 100;int merge(int arr[], int l1, int r1, int l2, int r2){ int i = l1, j = l2, k = 0; int temp[maxn]; while(i &lt;= r1 &amp;&amp; j &lt;= r2){ if(arr[i] &lt; arr[j]) temp[k++] = arr[i++]; else if(arr[i] &gt;= arr[j]) temp[k++] = arr[j++]; } while(i &lt;= r1) temp[k++] = arr[i++]; while(j &lt;= r2) temp[k++] = arr[j++]; for(int i = l1, k = 0; i &lt;= r2; i++, k++) arr[i] = temp[k];}//递归写法int mergeSort_re(int A[], int l, int r){ if(l &lt; r){ int mid = (l + r) / 2; mergeSort_re(A, l, mid); mergeSort_re(A, mid + 1, r); merge(A, l, mid, mid + 1, r); }}// 迭代写法int mergeSort_for(int A[], int l, int r){ if(l &lt; r){ int n = r - l + 1; //step为组内元素个数 for(int step = 1; step &lt;= n; step *= 2){ for(int i = 0; i &lt; n; i += 2*step){ //这么写行不行？测试一下A[5] // 事实证明这种写法很优美! merge(&amp;A[l], i, i + step - 1, i + step, min(i + 2 * step - 1, n - 1)); } printArr(A, l, r); } }}int main(){ // freopen(&quot;./data.in&quot;, &quot;r&quot;, stdin); int c[10] = {5, 3, 2, 1, 7, 2, 10, 3, 5, -1}, n = 10; // mergeSort_re(c, 0, n - 1); mergeSort_for(c, 5, n - 1); printArr(c, 0, n - 1); return 0;} 快速排序不稳定，复杂度为O(nlgn)O(nlgn)到O(n2)O(n2)，最广泛使用的排序算法。 12345678910111213141516171819202122232425262728//挖沙法 分割int Partition(int A[], int l, int r){ //三个数取最小值 int minp = l; if(A[r] &lt; A[minp]) minp = r; if(A[(r + l) / 2] &lt; A[minp]) minp = (r + l) / 2; int temp = A[minp]; A[minp] = A[l]; A[l] = temp; int i = l, j = r; while(i &lt; j){ while(i &lt; j &amp;&amp; temp &lt; A[j]) j--; A[i] = A[j]; while(i &lt; j &amp;&amp; temp &gt;= A[i]) i++; A[j] = A[i]; } A[j] = temp; return j;}void quickSort(int A[], int l, int r){ if(l &gt;= r) return; int mid = partition(A, l, r); printArr(A, 0, 9); printf(&quot;%d\\n&quot;, mid); quickSort(A, l, mid - 1); // 如果这里取mid - 1, 可能会导致mid为右侧最小值的情况时，无限partition！（没错，微妙的递归） quickSort(A, mid + 1, r);}","link":"/2020/08/07/CS/Algorithms/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"},{"title":"最大公约数——欧几里得算法","text":"欧几里得算法又称碾转相除法，其算法基于以下定理： gcd(a,b)=gcd(b,agcd(a,b)=gcd(b,a 其中gcd(a, b)表示a除于b的余数。 1234int gcd(int a, int b){ return b? gcd(b, a % b) : a;}","link":"/2020/08/07/CS/Algorithms/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"},{"title":"最短路","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int INF = 0x3ffffff;const int MX = 500;int n, m, l, cap, s, t;int dis[MX], vis[MX], bvis[MX], edge[MX][MX], fushe[MX];int bec = -1 , becfu = INF, allp;double rate = 1;vector&lt;int&gt; path[MX], bepath, nwpath;int disjk(){ fill(dis,dis + MX, INF); dis[s] = 0; for(int i = 0;i &lt; n;i++){ int u = -1, minv = INF; for(int j = 0;j &lt; n; j++){ if(!vis[j] &amp;&amp; dis[j] &lt; minv){ minv = dis[j]; u = j; } } if(u == -1 ) break; vis[u] = 1; for(int v = 0; v &lt; n;v++){ if( edge[u][v] != INF &amp;&amp; !vis[v]){//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点 //! 但是之前已经放缩的节点是绝对不会再被放缩的。。因为无负权// if( edge[u][v] != INF ){//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点 if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + edge[u][v] ){ dis[v] = dis[u] + edge[u][v]; path[v].clear(); path[v].push_back(u); }else if( dis[v] == dis[u] + edge[u][v]){ path[v].push_back(u); }// } } }}int bfs(){ queue&lt;int&gt; que, lay; que.push(s); lay.push(0); bvis[s] = 1; while(que.size()){ int u = que.front(), layer = lay.front(); que.pop(), lay.pop(); if(layer &lt; l) fushe[u] += (int)(ceil(1.0 * fushe[u] * (l - layer) / l)); for(int i = 0; i &lt; n;i++) if(edge[u][i] != INF &amp;&amp; !bvis[i]){//! que.push(i); bvis[i] = 1; lay.push( layer + 1); } }}int dfs(int u){ nwpath.push_back(u); if(u == s){ allp ++; int npc = 0, npfushe = 0; for(int i = 0;i &lt; nwpath.size(); i++){ npc += fushe[nwpath[i]]; if(i &lt; nwpath.size() / 2) npfushe += fushe[nwpath[i]]; } npc = npc % cap; if(npc &gt; bec || npc == bec &amp;&amp; npfushe &lt; becfu){ //! npc &gt;= bec bepath = nwpath; bec = npc; becfu = npfushe; } }else{ for(int i = 0;i &lt; path[u].size(); i++) dfs(path[u][i]); } nwpath.pop_back();} int main(){ fill(edge[0], edge[0] + MX * MX , INF);//! init int c1, c2, tmp; cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; cap &gt;&gt; s &gt;&gt; t; for(int i = 0;i &lt; n;i ++) cin &gt;&gt; fushe[i] ; for(int i = 0; i &lt; m;i++){ scanf(\"%d%d%d\",&amp;c1, &amp;c2, &amp;tmp); edge[c1][c2] = edge[c2][c1] = tmp; } bfs(); disjk(); dfs(t); if( !bvis[t]) printf(\"-1\\n\"); else{ printf(\"%d %d %d %d\\n\", allp, dis[t], bec, becfu); reverse(bepath.begin(), bepath.end());// if(bepath.size()) printf(\"%d\", bepath[0]);//! runtime error for(int i = 0;i &lt; bepath.size(); i++) if(i + 1 == bepath.size()) printf(\"%d\", bepath[i]); else printf(\"%d-&gt;\", bepath[i]); } return 0;}","link":"/2020/08/07/CS/Algorithms/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"title":"素数","text":"用素数性质简单判断1234567bool isPrime(int n){ if(n &lt;= 1) return false; int sqr = (int)sqrt(1.0 * n); for(int i = 2; i &lt;= sqr; i++) if(n % i == 0) return false; return true;} 打素数表经典的埃氏筛法 1234567891011121314const int maxn = 1e5;int prime[maxn], pNum = 0;void findPrime(){ for(int i = 2; i &lt; maxn; i++){ if(prime[i] == 0){ prime[pNum++] = i; for(int j = i * 2; j &lt; maxn; j += i) prime[j] = 1; printf(&quot;%d\\n&quot;, i); } }} 素数表的经典应用就是分解质因子，在有了素数表的情况下分解一个数字的因子的复杂度为O(n−−√)O(n)","link":"/2020/08/07/CS/Algorithms/%E7%B4%A0%E6%95%B0/"},{"title":"CNAME和A记录","text":"域名解析中A记录、CNAME记录的区别和联系域名解析就是域名申请后做的到IP地址的转换过程。域名的解析工作由DNS服务器完成。 A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。 CNAME记录即：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就 “","link":"/2020/08/07/CS/CN/CNAME%E5%92%8CA%E8%AE%B0%E5%BD%95/"},{"title":"CSAPP笔记1","text":"Programmer’s Perspective )–3th edition考完了研究生，浪荡了许久，终于肯安下心来钻研提升内功，就从这本书开始吧，抄录两端话送给自己的激励！ 读完了本书以后你将成为极少数的“牛人”，这些“牛人”知道事情是怎么运作的，也知道当事情出现故障是如何修复。你写的程序将能更好利用操作系统和系统软件提供的功能，对各种操作条件和运行时的参数都能正确操作，运行起来更快，并避免出现使得成型容易受到网络攻击的缺陷。同时你也要做好更深入探究的准备。研究像编译器，计算机体系结构，操作系统，嵌入式系统、网络互连和网络安全这样高级题目。——译者序 We cover data representations, mechine level representations of C programs, processor architecture, program optimizations, the memory hierarchy, exceptional control flow(exceptions, interrupts, processes, and Unix signals), virtual memory and memory management, system-level I/O, basic network programming, and concurrent programming. THes concepts are suppeorted by series of fun and hands-on lab assignments. —— CSAPP online. 正如书籍的题目，此书的编写者考虑到大多数人都不会编写一个OS或者制作一个CPU，那么从一个程序员的角度可以更具体而实用的理解类似于C语言是怎么编译成汇编语言，不同的设置是如何影响计算机性能的，代理是如何工作的计算机基础内容。此书着手于x86处理器机器和Linux类系统，并用C作为工具来实操，提供了多个Lab。 CHAPTER 1 The wonder of computer system伟大的编译器一个最基本的C源文件是由N个ASCII码组成的数据串，将以文件的形式存储在计算机磁盘中。而每个ASCII都有由8bit组成，或者说是一字节组成，容易忽视的是，文本每一行的末尾都有\\n符号，其编码为10，或者是00001010。 中文的注释计算机将怎么处理？猜测可能有文件保存读取编码方式有关。 在linux环境下每一个C源文件都会被编译驱动(compiler driver)所编译为machine-language instructions 组成的可执行程序。 image-20200503124858005 Pre-processor：预处理器 Assembler：汇编器 Linker：链接器 gcc -o hello hello.c 运作四个步骤：Preprocessing phase将#include&lt;stdio.h&gt;的语句所标记的系统头文件stdio.h内容插入到程序文本中，并形成hello.i；Compilation phase:将hello.i翻译成assembly-language program(汇编程序)； 汇编语言作用之处在于给多种高层次语句的不同编译器提供同一个低层次的输出语言。 Assembly phase： 汇编器将汇编程序hello.s翻译成机器及的二进制relocatable object program(可重定位程序)。 GCC是伟大的自由(free speach的自由)软件思想主导的运动GUN（GUN’s Not Unix, hh递归的）的产物，其功能强大，能够支持多种语言。同样的GUN产物还有GDB debugger，EMACS editor。 Linking phase：linker将预编译好的printf.o文件链接到可重定位文件hello.o形成了最终的可执行文件hello。 重视编译器的效率问题作为现代工具的使用者，我们程序员无需重造一个编译器或者了解其中的构造，但是更有意义的是去了解如何编写代码才能让编译器翻译出更有效率的代码。书中提出了几个例子：if-else是否比switch更有效？for和while哪个效率更高？pointer referenes 是否比数组下标更快？为什么简单的重新放置算数表达式参数(arithmetic expression)可以提高效率？ 处理器读取和接触存储在内存中的指令commmand-line interpreter ——shell 可以接受指令并运行，如果输入的指令一个word不是built-in shell command，那么shell就会默认该字符为可执行文文件并load和执行,如./hello将执行可执行文件hello，shell会等待程序结束(terminate)，之后输出提示符(a prompt)。 系统硬件组织 image-20200503124915375 一个Inter风格的硬件组织图 总线(Buses)类似人体血管的贯通系统内部传输固定大小电子信息比特的管道(conduits)，通常这个大小的值不固定。 I/O 设备(I/O Devices)I/O设备是计算机系统负责接收发送给外部世界的设备，通过控制器(contrlllers)和适配器(adapter)连接到I/O总线。控制器和适配器的目的为了传输信息，但是控制器是由计算机原有的芯片控制的或者说是在母板(motherboard)上的电路印刷而成的，适配器是可以插入母板插槽的芯片卡。常见的外部设备有磁盘、显示器和鼠标键盘。 主存(Main Memory)主存是系统在运行程序时的暂时存放数据和指令的空间。物理上，其一般有动态随机存储芯片(dynamic random access memory, DRAM)芯片组成。逻辑上说内存实际就是一个地址从零开始的线性字节数组。另外系统指令可由多个比特组成，数据项大小随数据类型不同而变化。 原句： In general, each of the machine instructions that constitute a program can consist of a variable number of bytes 处理器(Processor)中央处理器(central processing unit)是计算机的心脏，负责解释(interpet)和执行(execute)从内存运送到CPU的IR(instrruction register)的指令。简单的说，CPU包括了其运算器部分（如ALU，寄存器等）和控制器部分（如PC，IR等等）。在CPU运行过程中，CPU解释PC指向的指令，根据指令执行操作并更新PC值。 简单来说，指令包括了Load、Store、Operate(数据运算)和Jump类。 运行hello程序从硬件底层在理解一次刚刚的运行过程，在我们打入./hello命令指示，shell程序将键盘输入的字符通过寄存器和总线存储到内存中，当输入Enter1后shell开始执行shell程序。 有趣！ image-20200503124936718 shell将原本存储在Disk中的代码和数据复制到内存中。系统借助了直接存储器存储器(direct memory access, DMA)而无需通过CPU传输数据直达主存。 image-20200503124954066 最后，CPU运行hello程序，执行对应指令，并把数据hello,world\\n复制到寄存器并打印到屏幕。 image-20200503125006147 其中必然包括了中断技术。 高速缓存至关重要从上文的例子看到程序运行过程中存在大量数据和指令移动，而现有的机械结构却造成了存储器速度和容量之间的取舍难题。往往速度快的存储器（比如寄存器）容量却很小，相反的容量大的存储器比如磁盘、光盘存储速度都很慢。为了解决这一难题，现在计算机配备了高速缓存(cache)，甚至是多级高速缓存。其运用了局部性原理(locality)。这对程序性能有着重要影响。 locality:程序会倾向于使用局部区域的代码和数据 image-20200503125016708 cache的加入让我们有一个更美妙的想法：存储器层次结构(memory hierarchy)，这种结构从上到下，速度逐渐变慢，价格变低，同时容量上升。更有趣的是，上层可以视为相邻下层的缓存，相邻下层可以视为上层的存储，比如分布式系统中的本地磁盘就是远程存储系统的缓存。 操作系统管理硬件hello程序运行中时，外部数据的输入和打印屏幕这些操作硬件的举动都不是源程序或者shell所做的，都是使用了操作系统所提供的接口。操作系统是计算机硬件和应用软件之间的管理层，一方面负责保护硬件不直接受到应用软件的操作，另一方面提供给所有应用软件统一且简单的接口。 image-20200503125027579 操作系统通过几个抽象的功能来实现对计算机资源的管理，如下图。 确实抽象，Processes本身带着运行程序的位置信息、进程信息和源程序信息，也就是说Processes是对三者的管理。其他类似 image-20200503125035839 进程(Processes)即使是单核处理器(uniprocessor)计算机也可以同时（宏观）运行多个进程，操作系统在记录并控制了所有进程的上下文(content)。操作系统通过保存当前的进程上下文，并载入一个新进程的上下文可以实现进程切换。 image-20200503125045850 一个正在运行的进程可以通过系统调用来调用操作系统的功能，比如读写磁盘，执行另一个程序创建新进程。 线程(Threads)线程作为“轻量级”的进程，能快速访问同进程下的共享资源，占有更少的内存空间，运行效率更高，可以充分利用多核计算机的计算效能。 虚拟内存（Virutual Memory）顾名思义，虚拟内存是操作系统在内存的基础上虚拟空间。对于软件来说虚拟内存唯一可以接触到的空间，物理内存对他们是透明的。 image-20200503125120329 从低地址到高地址所存放的内容分别是： 程序的代码和数据 读写数据 堆(heap)：可以由进程通过程序malloca，new动态创建 分享库(shared libraries)：比如C++的math库 栈：在用户调用函数增长，返回函数时减小， 内核虚拟内存：保留给内核程序的空间。用户应用程序无法读取这部分内容，也无法直接掉调用。 文件(Files)至少在Unix I/O上，file系统将各式的外设输入输出设备、甚至网络建模成一个文件。统一的文件形式给系统操作员极大的方便。 linux: a complex, Posix-compliant version of the Unix operating system. posix，Portable Operating System Interface X——可移植操作系统接口 网络：计算机与其他系统的沟通桥梁 讲的太粗略，不计 重要主题 This concludes our initial whirlwind tour of systems. An important idea to take away from this discussion is that a system is more than just hardware. It is a collection of intertwined hardware and systems software that must cooperate in order to achieve the ultimate goal of running application programs. Amdahl’s LawAmdahl’s Law假设简单系统的各个部件线性工作，提升一个部件的效率其实对整齐来说提升并不明显。 image-20200503125132267 并发(Concurrency)和并行(Parallelism)并发是对计算机同时运行多个事件的广义概念。并行是指？？？ 在分时(time-sharing)操作系统上，所谓的并发仅仅只是一种模拟(simulated)，通过不断的切换进程（在进程(Process-Level Concurrency)级别上 ）让电脑同时相应多个用户的操作。而在线程级别(Threa-Level)上，即时在单核对一个单一的进程也有执行的多重控制流。 随着由多个有单独的操作系统内核管理的单个处理器组成的多核处理器(multiple processors)的到来，多核操作系统诞生了，随之而来的是超线程(hyperthreading)！ image-20200503125144846 image-20200503125157325 超线程（也称为sinultaneous multi-threading）是一种允许一个核同时执行的多个控制流，涉及了部分硬件的多分设计，比如PC(program countes)，寄存器文件，而其余硬件只设一份，比如浮点数计算。可以说，在并发概念提出50年的铺垫后，多核处理器和超线程的出现才引爆了对多线程编程应用和并行的极大热情。（Eng. P55） 指令级并行通过多核处理的多核处理能力，以及现代流水线架构来实现。 单指令多数据(SIMD，single-instruction, multile-data)并行是通过特殊硬件允许一条指令同时进行多重操作。常常用于处理图像、声音等数据。 抽象(abstraction)的重要性 计算机最重要的两个概念——抽象和局部性原理 抽象在计算机领域无处不在，提供给调用者的统一的函数接口API(Application program inteface)是函数的抽象，文件本身就是输出输入设备和物理数据的抽象，虚拟内存是内存和文件的抽象，进程是指令和数据的抽象，而计算机本身也是一个运行在硬件上的虚拟机(可见开头图) 终于读完了一个综述，开心 :heart: :happy::happy::happy:~~于2020.04.27.10:17","link":"/2020/08/07/CS/CSAPP/CSAPP%E7%AC%94%E8%AE%B01/"},{"title":"CSAPP笔记2","text":"程序结构和执行过程本章主要讲解程序在机器级代码上的执行过程以及程序编译翻译过程。 信息存储相比人类熟悉的代表了十指的十进制，二进制的稳定性、表达形态少、对硬件芯片的友好性是建造计算机的更优选择。典型的二进制应用就是记录数值，float-point encoding 和 Unsigned encoding就是代表。 有趣的是，计算机的算术运算过程即使是对溢出运算也会满足结合律(associative) 数值组成的bit有限就造成了数据表达的有限，从而引出的计算溢出，甚至安全问题都是编程者需要考虑的。 虚拟空间(virtual memory)是计算机操作系统提供的虚拟空间，以C语言的指针举例，一个C pointer指向的一定是一个数据类型(int, float, or structure)的第一个字节的虚拟地址。C语言本身会组织类型信息(type information)以便获取指针指向的数据内容，但是在机器级的代码中所有的程序对象都是一样的bit。(p63) C语言在早期计算机语言发展占据重要的位置，比如提供了内存分配器（memory allocator）——the malloc library function。C语言的编译可以对GCC（Gun Compiler Collection）添加参数以控制编译版本 gcc -std=c11 prog.c 指定了C11标准版本 -std=c99指定了C99版本 -ansi和-std=c89指定了C90版本 -std=gnu11指定了GNU项目的开发的一个版本，包括了ISO C11的内容 C语言支持向后兼容（backward compliale，“后”就是指过去，而非口语所说的“以后”），那么C语言编译的32bit的程序也可以在64位机子上跑。但是64bit的程序不能在32位的机子上跑。 gcc -m32 prog.c 设置了编译的位数，同理-m64设置了64bits C的指针有两个方面——值和类型，值指向了指针指向的内容的地址，类型指出了指向的地址的存放的信息的种类。 十六进制计数 （Hexadecimal Notation） image-20200503124826544 1000多页是时候考虑时间问题了，有更值得去做事情去干，暂时读的话还不读英文版了。","link":"/2020/08/07/CS/CSAPP/CSAPP%E7%AC%94%E8%AE%B02/"},{"title":"数据库管理复习梗概","text":"参考书籍：《数据库系统教程》3Ed. 施伯乐 基本概念概览 数据库（DateBase，DB）：长期存储在计算机内的数据集合 数据库管理系统（DataBase Mangement System, DBMS）：管理数据库的软件，其操作包括CRUD。 数据库系统（DataBase System，DBS）：由计算机软硬件和数据资源组成的计算机系统。 实体联系（Entity Relationship，ER）模型：对实体和实体之间关系的抽象。 概念模型：对用户需要的建模，往往建立出了ER模型。 逻辑模型：表达了数据库整体逻辑的模型。最重要的是关系模型，对象模型，还包括层次模型、网状模型。 逻辑独立性：应用程序与数据库的逻辑结构保持独立，即数据库的逻辑结构由DBMS即使变化了，应用程序也无需变化。 物理独立性：应用程序与数据库的物理结构保持独立，即数据库在磁盘的保存格式有数据库管理系统设置，应用程序无需关注数据库的物理结构。 两种独立性都是将数据在磁盘中的定义和存储格式独立分离出去，因而简化应用程序编程，减少了程序维护和修改。 关系模型 关系模型：简单理解为一个二维表格 子模式：用户需要用到数据的描述（？） 记录\\元祖：表格中的一行数据 关系\\实例：元祖的集合 字段\\属性：表的一列的列本身 元数：属性的个数 基数：元祖个数 关键码\\key\\键：字段或者字段的集合 超键（super key）：可以唯一标识元祖的键 候选键（Candidate key）：不含多余属性的超键 主键（Primary key）：用户选择的候选键 外键（Foreign key）：其他关系模型的主键 完全性规则（*表示省略相同成分）： 实体：主键不可缺 参照：外键指向的元祖不可空 用户：用户可自己定义完整性 关系代数 并：两个关系模型的去重合并 差：关系模型AB相减 笛卡尔积：两个关系模型的全排列 投影：选择一个关系模型若干列 选择：选择一个关系模型的若干行 ———— 交：求两个关系模型的公共元祖 连接：筛选出符合条件的两个模型的笛卡尔积 自然连接：条件是公共字段相同的连接，并去除公共字段 除法：A/B即尽可能 包含了所有B字段的且除了B字段A字段值相同的元祖集合。（简要的记忆为寻找公因数） ———— 改名 广义投影：允许投影中使用算术运算 外连接：就是把自然连接过程中丢失的元祖加以填充空值（NULL）并加入自然连接的结果 左（右）外连接：类似于外连接，就是把单单是左（右）边的模型丢弃掉的元祖加入 半连接：自然连接后投影到一个关系模型（不残缺的那边）上 SQL语句术语 基本表：关系模式 表的三种类型： 基本表：实际存储在数据库中的表 视图：若干表和其他视图组成的表的定义，在用户面前都是一样的 导出表：查询导出的表 存储文件：存储模式（文件存储的方式） 视图：子模式 行：元祖 列：属性 SQL模式（schema）：表和约束的集合（可能有多个表） 操作模式创建：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; 模式撤销：DROP SCHEMA &lt;模式名&gt; [CASCADE | RESTRICT] ; CASCADE即级联式，撤销下属的模式中所有的基本表、视图、索引；RESTRICT即约束式，仅当模式不存在任何下属元素才允许撤销；（SCHEMA可以替换为DATABASE） 添加自定义类型：CREATE DOMAIN &lt;YOUR_DOMAIN&gt; CHAR(8)这里把CHAR(8)定义成了自定义的domain名，可直接使用 创建基本表： 12345678910CREATE TABLE &lt;基本表名&gt; ( --列表类型 T# CHAR(4) NOT NULL, --默认允许空值（与主键定义冗余） TITLE CHAR(10), -- 完整性约束 PRIMARY KEY(T#) -- 定义主键 FOREIGN KEY(C#) REFERENCES S(C#) --定义外键为C#，且对应S表的主键C# ); 插入数据： 1INSRET 修改基本表： 1234567--增加表的列ALTER TABLE &lt;基本表名&gt; ADD &lt;列名&gt; &lt;类型&gt;--删除表的列ALTER TABLE &lt;基本表名&gt; DROP &lt;列名&gt; [CASCADE | RESTRICT ] -- CASCADE表明删除列的同时删除所有使用该列约束和视图--修改列形状ALTER TABLE &lt;基本表名&gt; MODIFY &lt;列名&gt; &lt;类型&gt; 撤销基本表： 1DROP TABLE &lt;基本表名&gt; [ CASCADE| RESTRICT] --同理 索引：？？ 数据查询： 123456789101112131415--- 基本sql查询语句SELECT 属性1,属性2.....属性n FROM 表1,表2......表NWHERE 关系表达式---sql语句之间可以使用UNION（并） \\ INTERSECT（交） \\ EXCEPT（差）----嵌套查询，括号中的子查询优先进行SELECT 属性1,属性2.....属性n FROM 表1,表2......表NWHERE 关系表达式 IN ( SQL查询语句 ) ---嵌套查询的速度往往比笛卡尔积的运算速度快 待补充：更复杂的还有相关子查询（。。）、where使用的运算符,以及（P85~P101） 关系数据库的规范设计基本概念函数依赖（FD，Functional Dependency）：当一个基本表中的属性集Y是属性集X的”函数值”(即X的值可以确定出唯一的Y)，就说明了X-&gt;Y,或者说Y依赖于X，这个基本表存在函数依赖。 （函数蕴涵P120） 逻辑蕴涵：若函数依赖集合F中存在的FD X→YX→Y和Y→ZY→Z，存在X→ZX→Z成立，则可称为F逻辑蕴涵X→ZX→Z 。 闭包： 就是函数依赖集上FF所有函数依赖和逻辑蕴涵推出来的依赖关系的完整集合，即为F+F+ 闭包。 FD推理规则： A→BA→B 自反性：AA自身能确定出自身的子集，这样推导出来的FD也称平凡的FD 增广性：依赖两边可以同时增加变量 传递性：可传递（逻辑蕴涵） ———— 合并性：同时能推导出两个结果BCBC，就能推导出两个结果的和B,CB,C 分解性：与合并性相反，是将结果BCBC拆分成两个B,CB,C 伪传递性：传递过程中需要添加一个因素，X→Y,YZ→WX→Y,YZ→W 等价于XZ→WXZ→W 复合型：两个FD可以两边组成成一个FD ———— 可以使用FD的定义来定义超键和候选键 当函数依赖集的闭包相等时，函数依赖集等价。可定义最难小函数依赖集： FD右边都是单属性； 无冗余FD FD的左边的属性集不是冗余的（子集无法代替集 求出R的最小依赖集算法 分解FD的右边属性集，并去重 消除左边冗余的FD 消除R中冗余FD 模式分解特性 无损分解：把数据库模式分解为多个模式，并将分解的模式全部自然连接发现多出了元祖（寄生元祖）（也就是有损分解，实际上是信息的丢失，信息论！不确定性越大，信息量越小）。反之如果元祖不多不少就是无损分解。 上述讨论中假设模式存在一个“范关系”rr，可以分解为多个子关系rkrk。 当然也存在不存在范关系的rr，在连接过程中某个riri子关系的元祖会被丢失掉，这个被称为破环范关系的悬挂元祖 依赖保持：就是分解的模式中的依赖的并与原模式的依赖等价。 无损分解的测试方法：略（p128） 保持函数依赖的分解：略（p129） 关系模式的范式第一范式：关系模式的R的关系r的属性值都是不可分的单一的（反例“AB”） 第二范式：每个非主属性完全依赖于候选键（挺严格的）。不完全依赖也就是局部依赖意味着A→BA→B 这个条件存在BB依赖于AA的一个子集，（注意这个FD推理规则A1不一样） 主属性：关系模式中R的候选键中的属性 化解成第二范式的算法：将一个局部依赖X→YX→Y的属性XYXY提出来形成一个关系，同时在原有属性集UU形成一个新的关系U−YU−Y；重复上述动作直到没有局部依赖。 第三范式：每个非主属性都不传递依赖与候选键，即为第三范式 传递依赖就是：X→Y,Y→ZX→Y,Y→Z 且X不依赖与Y，Z不是Y的子集 BC范式： 每个主属性不都传递依赖于候选键，则为BC范式。（相比于第三范式排除了主属性对候选键的传递依赖） 分解方法：略（p134） 数据库设计和ER模式数据库设计过程： 规划：调查、可行性分析等 需求分析：分析用户活动，系统范围，分数用户数据，数据流图；数据字典(描述数据) 概念设计：数据抽象设计局部概念模型和全局概念模型（比如ER） 逻辑设计：把上一步概念模型转化符合具体DBMS的逻辑模型，比如关系模型；设计外模型（api接口）；评价模型；修正模型 物理设计：存储记录结构设计；确定存储位置；完全性和安全性考虑； ER图组成结构： 实体：数据对象 联系：实体之间的关系 元数\\度数（degree）：联系所涉及的实体个数 数值约束： （x,y）表示该实体的联系的另一方的数量限制 N或者：表示对实体在联系中的映射数量关系 参与约束： 双直线：完全参数该联系 单直线：部分参与该联系 属性：实体的特征 简单属性和复合属性：在于可不可分 单值和多值属性：在于可不可同时取多个值 替换： 多值属性替换为一个新的实体类型 用多个单值属性代替 ER转关系模型的算法： 实体直接转化为一个关系 关系的转化方法 一元关系直接转化属性 1：1关系转化为一个实体的外键和属性 1：N关系转化”N处”实体的外键和属性 N:M关系转化为两个实体的主键和一个属性 ———— 三元关系可类比二元关系的转化方法（太无聊了不看了） 数据库存储结构文件组织定长存储：连接方法和顺序方法 不定长存储解决方案： 字符串表示形式：分槽式页结构（定长的首部顺序排列并记录剩余数据的其实起始地址，不定长的二进制数据从低端生长） 变长记录的定长表现形式：预留空间、固定块的溢出块相补充、定长块的连接形式（p187） (不想看了555)","link":"/2020/08/07/CS/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0%E6%A2%97%E6%A6%82/"},{"title":"AVL","text":"老模板了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/** This is Code of JJProblem :AVL treeSource :Solution :AnyDetial :DateAndTime :5,18CostofTime :17:07**/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct Node{ int data, height; Node *lchild, *rchild; Node(int x) { data = x; height = 1; lchild = NULL; rchild = NULL; }};int getHeight(Node *root){ if(!root) return 0;//! child node may be is NULL. else return root-&gt;height;}int getHeightFactor(Node *root){ return getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild);}void updateHeight(Node *root){ root-&gt;height = max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild)) + 1;//!!! add 1}void search(Node *root, int x){ if(!root) return; if(root-&gt;data==x) { printf(\"%d\\n\",x); } else if(root-&gt;data&gt;x) { search(root-&gt;lchild,x); } else search(root-&gt;rchild,x);}//! right rotatevoid r_rotate(Node *&amp;root){ cout&lt;&lt;\"R\\n\"; Node* tmpr = root-&gt;lchild; root-&gt;lchild = tmpr-&gt;rchild; tmpr-&gt;rchild = root; updateHeight(root);//!!!update the height of tree updateHeight(tmpr); root = tmpr;}//! left rotatevoid l_rotate(Node *&amp;root)///!!! left rotating replace root with root's right child.{ cout&lt;&lt;\"L\\n\"; Node* tmpr = root-&gt;rchild; root-&gt;rchild = tmpr-&gt;lchild; tmpr-&gt;lchild = root; updateHeight(root);//!!!update the height of tree updateHeight(tmpr); root = tmpr;}void insert(Node *&amp;root, int x){ if(root==NULL) { root = new Node(x);; return; } else if(root-&gt;data&gt;x) { insert(root-&gt;lchild,x); }else{ insert(root-&gt;rchild,x); } //!!you should update the weight after changing the number or the height of root and child; updateHeight(root); if(getHeightFactor(root)==2) { if(getHeightFactor(root-&gt;lchild)==1) { r_rotate(root);//!!! change the root }else if(getHeightFactor(root-&gt;lchild)==-1) { l_rotate(root-&gt;lchild); r_rotate(root);//!!! change the root } } else if(getHeightFactor(root)==-2) { if(getHeightFactor(root-&gt;rchild)==-1) { l_rotate(root);//!!! change the root } else if(getHeightFactor(root-&gt;rchild)==1) { r_rotate(root-&gt;rchild); l_rotate(root);//!!! change the root } }} Node *create(int a[], int n) { Node * root = NULL; for(int i=0;i&lt;n;i++) { insert(root,a[i]); } return root; } void preorder(Node *root) { if(!root) return; printf(\"%d \",root-&gt;data); preorder(root-&gt;lchild); preorder(root-&gt;rchild); } void pr(Node *root) { if(!root) return; printf(\"data: %3d h:%d\\n\",root-&gt;data,root-&gt;height); pr(root-&gt;lchild); pr(root-&gt;rchild); }int main(){ int a[10]={1,2,3,4,5,6,7,8,9,10}; Node *root = create(a,10);// preorder(root); pr(root);}","link":"/2020/08/07/CS/DS/AVL/"},{"title":"二叉查找树实现","text":"二叉查找树的一个实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248尤其注意删除那一部分的逻辑！/** This is Code of JJProblem :Source :Solution :AnyDetial :注意点：1.递归边界是root为NULL2.插入： 查找失败--NULL--即为插入点 利用插入创建时，第一个数据就是查找失败的点！3.层序遍历：队列里存的是地址；DateAndTime :CostofTime :**/#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;struct Node{ int data,layer; Node *lchild,*rchild; Node() { lchild = NULL; rchild = NULL; } Node(int a) { data = a; lchild = NULL; rchild = NULL; }}; //Node* newnode(int a)//! create a node with new!{ return new Node(a);}//! find those nodes whose data is x and replace those data with x;void search_node(Node* root, int key, int x){ if(root==NULL) return; if(root-&gt;data==key) root-&gt;data = x;//! a -&gt; data ! search_node(root-&gt;rchild,key,x); search_node(root-&gt;lchild,key,x);}void insert(Node *&amp;root, int x){ if(root==NULL)//! The { root = newnode(x); return; } if(root-&gt;data&gt;x) { insert(root-&gt;lchild,x); }else{ insert(root-&gt;rchild,x); }}Node* create(int a[], int n){ Node *root = NULL;//!the index begin with 0; for(int i=0;i&lt;n;i++) { insert(root,a[i]); } return root;}void preorder(Node *root){ if(root==NULL) return;! printf(\"%d \",root-&gt;data); preorder(root-&gt;lchild); preorder(root-&gt;rchild);}//!可用于递归赋值父节点信息和遍历输出根到所有节点的路径Node *path[1000];int pos = -1;void preorder_withrint(Node *root){ if(root==NULL) return; path[++pos] = root;// cout&lt;&lt;pos&lt;&lt;endl; for(int i=0;i&lt;pos;i++) printf(\"%d \",path[i]-&gt;data); printf(\"%d\\n\",path[pos]-&gt;data);// printf(\"%d \",root-&gt;data); preorder_withrint(root-&gt;lchild); preorder_withrint(root-&gt;rchild); pos--;}void inorder(Node *root){ if(root==NULL) return; inorder(root-&gt;lchild); printf(\"%d \",root-&gt;data); inorder(root-&gt;rchild);}//!错误代码 ： 此代码无法识别已经某一节点右节点是否已经压入过栈，而陷入无限循环之中void inoder_withrecursion(Node *root){ cout&lt;&lt;\"Worry Code!\\n\"; Node *q; stack&lt;Node*&gt; s; s.push(root); while(!s.empty()){ getchar() ;q = s.top(); if(q-&gt;lchild)//!一个错误点 s.push(q-&gt;lchild); else{ printf(\"%d \",q-&gt;data); s.pop(); if(q-&gt;rchild) s.push(q-&gt;rchild); } }}void postorder(Node *root){ if(root==NULL) return; inorder(root-&gt;lchild); inorder(root-&gt;rchild); printf(\"%d \",root-&gt;data);}void layerorder(Node* root){ if(root==NULL) return; queue&lt;Node*&gt;q; q.push(root); while(!q.empty()) { Node *t = q.front(); q.pop(); printf(\"%d \",t-&gt;data); if(t-&gt;lchild!=NULL) q.push(t-&gt;lchild); if(t-&gt;rchild!=NULL) q.push(t-&gt;rchild); }}int layerorder_withlayer(Node* root){ if(root==NULL) return 0 ; int Nol = 0,Non = 0,maxn = 0; queue&lt;Node*&gt;q; root -&gt; layer = 1; q.push(root); while(!q.empty()) { Node *t = q.front(); if(t-&gt;layer!=Nol){ Nol = t-&gt;layer; Non = 1; cout&lt;&lt;\"?\"; }else Non ++; maxn = max(Non,maxn); q.pop(); printf(\"%d %d\\n\",t-&gt;data,t-&gt;layer); if(t-&gt;lchild!=NULL) { t-&gt;lchild-&gt;layer = Nol + 1; q.push(t-&gt;lchild); } if(t-&gt;rchild!=NULL){ t-&gt;rchild-&gt;layer = Nol + 1; q.push(t-&gt;rchild); } } return maxn;}//!前序遍历和中序遍历重建树Node *create_in_pre( int inorder[], int inl, int inr, int preorder[], int prel, int prer)//! in[l,r], pre[l,r],{ if(inl&gt;inr || prel&gt;prer) return NULL; int pos_in = inl; for(;pos_in&lt;=inr;pos_in++) { if(inorder[pos_in]==preorder[prel])// find the index of root break; } int numleft = pos_in - inl;// the number of left tree; Node *root = newnode(preorder[prel]); root-&gt;lchild = create_in_pre(inorder, inl, pos_in-1, preorder, prel+1, prel+numleft); root-&gt;rchild = create_in_pre(inorder, pos_in+1, inr, preorder, prel+numleft+1, prer); return root;}//!后序遍历和中序遍历重建树Node *create_in_post(int in[],int inl, int inr, int post[], int postl, int postr){ if(inl&gt;inr) return NULL; Node *root = newnode(post[postr]); int pos = inl; for(;pos&lt;inr;pos++) { if(in[pos]==root-&gt;data) break; } int k = pos - inl; root-&gt;lchild = create_in_post(in,inl,pos-1,post,postl,postl+k-1); root-&gt;rchild = create_in_post(in,pos+1,inr,post,postl+k,postr-1); return root;}int main(){ int a[1000] = {1,3,-2,5,7,-10,15,0} ,n = 8; Node *root = create(a,n);// preorder(root); cout&lt;&lt;endl; inorder(root); cout&lt;&lt;endl;// inoder_withrecursion(root); preorder_withrint(root); cout&lt;&lt;endl;// postorder(root);// cout&lt;&lt;endl;// layerorder(root);// cout&lt;&lt;endl&lt;&lt;\"max of Layer\\n\"&lt;&lt; endl;// cout&lt;&lt;layerorder_withlayer(root);// cout&lt;&lt;endl;// int pre[10] = {1 ,-2 ,-10, 0, 3 ,5 ,7 ,15};// int in[10] = {-10, -2, 0, 1, 3, 5, 7, 15};// int post[10] = {-10 ,-2, 0, 3, 5, 7, 15 ,1};//// Node *newroot1 = create_in_pre(in,0,7,pre,0,7);// Node *newroot2 = create_in_post(in,0,7,post,0,7);// cout&lt;&lt;\"!recreate!\\n\";// inorder(newroot1);// cout&lt;&lt;endl;// inorder(newroot2);}","link":"/2020/08/07/CS/DS/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0/"},{"title":"二叉树集合","text":"（好像不怎么用心的样子呢） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** This is Code of JJProblem :Source :Solution :AnyDetial :注意点：1.递归边界是root为NULL2.插入： 查找失败--NULL--即为插入点 利用插入创建时，第一个数据就是查找失败的点！3.层序遍历：队列里存的是地址；DateAndTime :CostofTime :**/#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;struct Node{ int data; Node *lchild,*rchild; Node() { lchild = NULL; rchild = NULL; } Node(int a) { data = a; lchild = NULL; rchild = NULL; }}; //Node* newnode(int a)//! create a node with new!{ return new Node(a);}//! find those nodes whose data is x and replace those data with x;void search_node(Node* root, int key, int x){ if(root==NULL) return; if(root-&gt;data==key) root-&gt;data = x;//! a -&gt; data ! search_node(root-&gt;rchild,key,x); search_node(root-&gt;lchild,key,x);}void insert(Node *&amp;root, int x){ if(root==NULL)//! The { root = newnode(x); return; } if(root-&gt;data&gt;x) { insert(root-&gt;lchild,x); }else{ insert(root-&gt;rchild,x); }}Node* create(int a[], int n){ Node *root = NULL;//!the index begin with 0; for(int i=0;i&lt;n;i++) { insert(root,a[i]); } return root;}void preorder(Node *root){ if(root==NULL) return;! printf(\"%d \",root-&gt;data); preorder(root-&gt;lchild); preorder(root-&gt;rchild);}void inorder(Node *root){ if(root==NULL) return; inorder(root-&gt;lchild); printf(\"%d \",root-&gt;data); inorder(root-&gt;rchild);}void postorder(Node *root){ if(root==NULL) return; inorder(root-&gt;lchild); inorder(root-&gt;rchild); printf(\"%d \",root-&gt;data);}void layerorder(Node* root){ if(root==NULL) return; queue&lt;Node*&gt;q; q.push(root); while(!q.empty()) { Node *t = q.front(); q.pop(); printf(\"%d \",t-&gt;data); if(t-&gt;lchild!=NULL) q.push(t-&gt;lchild); if(t-&gt;rchild!=NULL) q.push(t-&gt;rchild); }}//!前序遍历和中序遍历重建树Node *create_in_pre( int inorder[], int inl, int inr, int preorder[], int prel, int prer)//! in[l,r], pre[l,r],{ if(inl&gt;inr || prel&gt;prer) return NULL; int pos_in = inl; for(;pos_in&lt;=inr;pos_in++) { if(inorder[pos_in]==preorder[prel])// find the index of root break; } int numleft = pos_in - inl;// the number of left tree; Node *root = newnode(preorder[prel]); root-&gt;lchild = create_in_pre(inorder, inl, pos_in-1, preorder, prel+1, prel+numleft); root-&gt;rchild = create_in_pre(inorder, pos_in+1, inr, preorder, prel+numleft+1, prer); return root;}//!后序遍历和中序遍历重建树Node *create_in_post(int in[],int inl, int inr, int post[], int postl, int postr){ if(inl&gt;inr) return NULL; Node *root = newnode(post[postr]); int pos = inl; for(;pos&lt;inr;pos++) { if(in[pos]==root-&gt;data) break; } int k = pos - inl; root-&gt;lchild = create_in_post(in,inl,pos-1,post,postl,postl+k-1); root-&gt;rchild = create_in_post(in,pos+1,inr,post,postl+k,postr-1); return root;}int main(){ int a[1000] = {1,3,-2,5,7,-10,15,0} ,n = 8; Node *root = create(a,n); preorder(root); cout&lt;&lt;endl; inorder(root); cout&lt;&lt;endl; postorder(root); cout&lt;&lt;endl; int pre[10] = {1 ,-2 ,-10, 0, 3 ,5 ,7 ,15}; int in[10] = {-10, -2, 0, 1, 3, 5, 7, 15}; int post[10] = {-10 ,-2, 0, 3, 5, 7, 15 ,1}; Node *newroot1 = create_in_pre(in,0,7,pre,0,7); Node *newroot2 = create_in_post(in,0,7,post,0,7); cout&lt;&lt;\"!recreate!\\n\"; inorder(newroot1); cout&lt;&lt;endl; inorder(newroot2);}","link":"/2020/08/07/CS/DS/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9B%86%E5%90%88/"},{"title":"堆算法和堆排序","text":"堆排序1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;vector&lt;int&gt; a, b;int n;void adjustDown(vector&lt;int&gt; &amp;arr, int x, int len){ for(int p = 2 * x; p &lt;= len; p *= 2){ if(p &lt; len &amp;&amp; arr[p] &lt; arr[p+1]) p++; if(arr[x] &gt; arr[p]) break; swap(arr[x], arr[p]); x = p; }}int main(){ cin &gt;&gt; n; a.resize(n + 1); b.resize(n + 1); for(int i = 1;i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n; i++) cin &gt;&gt; b[i]; int p = 1, ch; while(p &lt; n &amp;&amp; b[p] &lt;= b[p + 1]) p++; for(ch = p + 1; ch &lt;= n &amp;&amp; a[ch] == b[ch]; ch++); if(ch == n + 1){ cout &lt;&lt; \"Insertion Sort\\n\"; sort(a.begin() + 1, a.begin() + 2 + p); }else{ cout &lt;&lt; \"Heap Sort\\n\"; int k = n; while(k &gt; 0 &amp;&amp; b[k] &gt; b[1]) k--; swap(b[1], b[k]); adjustDown(b, 1, k - 1); a = b; } for(int i = 1; i &lt;= n; i++) if(i == n) printf(\"%d\\n\", a[i]); else printf(\"%d \", a[i]);} 完全堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int MAXN = 1e3;int heap[MAXN] = {0,3,14,7,12,13,4,5,20};int n = 8;///! downvoid downAdjust(int p,int len){ for(int x = p * 2; x &lt;= len; x += x){ if(x &lt; len &amp;&amp; heap[x] &lt; heap[x + 1]) x++; if(heap[x] &lt; heap[p]) break; swap(heap[x], heap[p]); p = x; }}// for(int i=1;i&lt;=n/2;i++) //! 叶子的一个下标是 n/2向下取整+1 //! 必须从底部开始调整，不然不能保持之前的子堆的有序性质void buildHeap(){ for(int i=n/2; i&gt;=1; i--) downAdjust(i,n);}///!delete elementvoid deleteTop(){ heap[1] = heap[n--];//! n-- downAdjust(1,n);}///!!!upvoid upAdjust(int p, int len){ for(int x = p /2 ; x &gt;= 1; x /= 2){ if(heap[x] &gt; heap[p]) break; swap(heap[x], heap[p]); p = x; }}void insert(int x){ heap[++n] = x; upAdjust(n,n);}void show(){ for(int i=1; i&lt;=n; i++) cout&lt;&lt;heap[i]&lt;&lt;\" \"; cout&lt;&lt;\"\\n\";}///! head sortvoid headSort(int n){ buildHeap(); for(int i=n; i&gt;=2; i--) { swap(heap[1],heap[i]); downAdjust(1,i-1);//!! heap only have n-1 elements; }}int main(){ show(); buildHeap(); insert(25); show(); headSort(n); show();}","link":"/2020/08/07/CS/DS/%E5%A0%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"数据结构知识点笔记","text":"（有时候确实读黑书应该读原著，中文翻译著作时常有些令人琢磨不透的表达） 复杂度O(f(N))O(f(N))表算法复杂度T(N)T(N)的函数上限，其ff增长率≥T(N)≥T(N)的增长率。 Ω(f(N))Ω(f(N))表算法复杂度T(N)T(N)的函数下限，其ff增长率≤T(N)≤T(N)的增长率。 Θ(f(N))Θ(f(N))表 ff的增长率等于TT的增长率。 o(f(N))o(f(N))表 ff的增长率&gt;T&gt;T的增长率。 表、栈和队列表或者说线性表的特征在于一组有次序（非大小有序的有序，这里指前后次序的序）的元素。实现物理结构： 链表 带头结点的链表 双链表 循环链表 多重表 数组 栈是删除和插入都在同一端点处进行的表。物理实现同样有链表和数组。 经典题目：后缀表示式计算、中缀转后缀 队列是队尾插入，队头删除的表。物理实现： 循环数组的队列 树树实际上只有一个源节点的DAG。最常见的如二叉查找树（限制了子节点和节点的关系的二叉树）、AVL、哈夫曼树 算法： 先序遍历、中序遍历、后序遍历 二叉查找树的创建、插入、删除 AVL树的旋转（四种）、插入、删除（调整 ） 展开树（p92？） m阶B树的性质 哈夫曼树 （Haffman） 实现： 儿子链表 兄弟儿子表示法 父亲表示法 经典题目：表达式树的创建 散列散列是将关键字映射到不同的数组单元DS。三个要点： 散列函数 消除冲突 分离链接法 开放定址法 线性探测法 平方探测法 双散列 再散列是重新建表重新映射到新数组 堆优先队列是用堆实现的保持堆序性的完全二叉树。 算法: 上浮、下滤、插入、删除；注意建堆的复杂度是O(N)O(N)。 其他数据结构（我的神啊p147？）： d-堆 左式堆 斜堆 二项队列 排序 插入排序 希尔排序 堆排序 归并排序 快速排序：枢纽元的一个有效选取办法就是三数中值，随机数代价高昂 桶式排序 外部排序： 順串的产生（优先队列 + 最小元素锚定），順串的合并（归并算法） 集合并查集算法 图论数据表示：邻接表、邻接矩阵、邻接多重表（无向图）、十字链表（有向图）算法： 拓扑排序 最短路径 无权图：遍历 非负权图：Dijkstra（最小堆优化） Dijkstra复杂度： 邻接矩阵实现：O(V2)O(V2) 邻接表实现：O(V2+VE)O(V2+VE) 堆优化实现：O(V∗log(V)+Elog(V))O(V∗log(V)+Elog(V))思考复杂度真是有趣 负权值图： 遍历：DFS，BFS 网络流问题 最小生成树：Prim，Kruskal 非双连通性的无向图割点问题：DFS 有向图？ NP问题NP问题值非确定性多项式时间问题，如果可以在多项式时间内验证一个问题的所有“对”为正确，那么该问题就是NP问题。而NP-完全问题就是NP问题在的一个子集，所有NP问题都可以通过映射转化为NP-C问题，所以NP-C问题是最难的。（。。。。。。。）","link":"/2020/08/07/CS/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/"},{"title":"anki+GD单词解决方案","text":"Anki作为一款记忆神器，丰富的插件和本身的记忆原理相得益彰。这几天学习了一下其强大的功能，作为背单词的实用工具。本身只用Anki背诵单词，那么主要采取两种方法来快速生成导入单词卡片。 GoldDict + FastWordQueryGoldDict是一款俄罗斯大佬开发的开源单词软件，支持本地词典、在线词典，网页查词查询，拥有快捷键，收藏，取词查词支持等丰富功能，基本上已经覆盖了查词的任何需求。选择单词并Ctrl+C两次可快速查词，Ctrl+E可快速收藏，收藏后的单词支持导出为txt文件。 将txt文件的单词导入Anki软件后，后续可由Anki插件FastWordQuery快速查词并制作卡片。 FastWQ插件安装码 1807206748， 使用教程 推荐配置如下： image-20200503125952535 正面卡片模板如下: 123456789101112131415161718192021222324252627282930313233343536373839&lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97876&quot;&gt; &lt;section style=&quot;margin:10px auto;text-align: center;&quot;&gt; &lt;section style=&quot;display:inline-block;color:#f28461;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;text-align:right;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:70px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;https://bdn.135editor.com/files/images/editor_styles/de6c8d76ce15363fdd1b8feccfe81302.jpg&quot; data-ratio=&quot;0.3157894736842105&quot; data-w=&quot;475&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #fcbd6b;padding-right:5px;box-sizing: border-box;margin-top:-5px;&quot;&gt; &lt;section class=&quot;135brush&quot; data-brushtype=&quot;text&quot; style=&quot;border-right:1px solid #fcbd6b;letter-spacing:1.5px;font-size:16px;padding:8px 1.2em;box-sizing: border-box;&quot;&gt; {{单词}} &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;display:flex;justify-content:flex-end;align-items:center;border:1px solid #fcbd6b;box-sizing: border-box;border-top:none;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;;width:6px;height:6px;background-color:#fcbd6b;box-sizing: border-box;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97722&quot; &gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;text-align: center;&quot;&gt; &lt;section style=&quot;display:inline-block;border-top:1px solid #7f5c32;border-bottom:1px solid #7f5c32;padding:0px 0.1em;text-align: center;&quot;&gt; &lt;section style=&quot;background-color: #fffaf3;color:#7f5c32;padding:2px 4px;&quot;&gt; &lt;section style=&quot;display: flex;justify-content:center;align-items: center;&quot;&gt; &lt;section class=&quot;135brush&quot; data-brushtype=&quot;text&quot; style=&quot;letter-spacing:1.5px;font-size:16px;text-align: center;&quot;&gt; {{发音}} &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;_135editor&quot; data-role=&quot;paragraph&quot;&gt; &lt;p&gt; &lt;br/&gt; &lt;/p&gt;&lt;/section&gt; 背面卡片模板如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97713&quot;&gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;;width:28px;height:28px;background-color: #fff;color:#7f5c32;text-align:center;line-height:26px;border:1px solid #b68b58;box-sizing: border-box;font-size:18px;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt; 0&lt;span class=&quot;autonum&quot; data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt; &lt;/section&gt; &lt;section style=&quot;margin-top:-20px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;display:flex;justify-content: flex-start;align-items: center;&quot;&gt; &lt;section style=&quot;background-color:#b68b58;box-sizing: border-box;height:1px;flex:1;margin-right:3px;&quot;&gt;&lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px #b68b58; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-right:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;color:#7f5c32;padding:6px 6px 0px 6px;box-sizing: border-box;&quot;&gt; &lt;section data-autoskip=&quot;1&quot; class=&quot;135brush&quot; style=&quot;padding:10px;color:#7f5c32;text-align: justify;line-height:1.75em;letter-spacing: 1.5px;font-size:14px;&quot;&gt; &lt;p&gt; {{音标}} &lt;/p&gt; &lt;p&gt; {{释义}}&lt;/span&gt; &lt;/p&gt; &lt;/section&gt; &lt;section style=&quot;text-align: right;&quot;&gt; &lt;section style=&quot;width:35px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;http://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvN1FSVHZrSzJxQzVIaWFTRjdCcEVqU1c4MnFpYkxBZTRRMHRxY3EwNHRVV3U5Q3dod3JGWWlheWZHaWN0Yzkzc24xZzFOSE9ZS1BJZ1E3R3NvM0M2V2hNejVBLzA/d3hfZm10PXBuZw==&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97713&quot;&gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;;width:28px;height:28px;background-color: #fff;color:#7f5c32;text-align:center;line-height:26px;border:1px solid #b68b58;box-sizing: border-box;font-size:18px;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt; 0&lt;span class=&quot;autonum&quot; data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/span&gt; &lt;/section&gt; &lt;section style=&quot;margin-top:-20px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;display:flex;justify-content: flex-start;align-items: center;&quot;&gt; &lt;section style=&quot;background-color:#b68b58;box-sizing: border-box;height:1px;flex:1;margin-right:3px;&quot;&gt;&lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px #b68b58; border-left:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width:0px; height:0px; border-bottom:solid 6px transparent; border-right:solid 6px #b68b58;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;color:#7f5c32;padding:6px 6px 0px 6px;box-sizing: border-box;&quot;&gt; &lt;section data-autoskip=&quot;1&quot; class=&quot;135brush&quot; style=&quot;padding:10px;color:#7f5c32;text-align: justify;line-height:1.75em;letter-spacing: 1.5px;font-size:14px;&quot;&gt; &lt;p&gt; {{例子}} &lt;/p&gt; &lt;/section&gt; &lt;section style=&quot;text-align: right;&quot;&gt; &lt;section style=&quot;width:35px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;http://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvN1FSVHZrSzJxQzVIaWFTRjdCcEVqU1c4MnFpYkxBZTRRMHRxY3EwNHRVV3U5Q3dod3JGWWlheWZHaWN0Yzkzc24xZzFOSE9ZS1BJZ1E3R3NvM0M2V2hNejVBLzA/d3hfZm10PXBuZw==&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;_135editor&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;97713&quot; &gt; &lt;section style=&quot;margin:10px auto;&quot;&gt; &lt;section style=&quot;;width:28px;height:28px;background-color: #fff;color:#7f5c32;text-align:center;line-height:26px;border:1px solid #b68b58;box-sizing: border-box;font-size:18px;transform: rotate(0deg);-webkit-transform: rotate(0deg);-moz-transform: rotate(0deg);-o-transform: rotate(0deg);&quot;&gt; 03 &lt;/section&gt; &lt;section style=&quot;margin-top:-20px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;display:flex;justify-content: flex-start;align-items: center;&quot;&gt; &lt;section style=&quot;background-color: #b68b58; box-sizing: border-box; height: 1px; flex: 1 1 0%; margin-right: 3px; overflow: hidden;&quot;&gt;&lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width: 0px; height: 6px; border-bottom: 6px solid transparent; border-left: 6px solid #b68b58; overflow: hidden; box-sizing: border-box;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width: 0px; height: 6px; border-bottom: 6px solid #b68b58; border-left: 6px solid #b68b58; overflow: hidden; box-sizing: border-box;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;display:inline-block;box-sizing: border-box;margin-left:3px;&quot;&gt; &lt;section class=&quot;assistant&quot; style=&quot;width: 0px; height: 6px; border-bottom: 6px solid transparent; border-right: 6px solid #b68b58; overflow: hidden; box-sizing: border-box;&quot;&gt;&lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section style=&quot;border:1px solid #b68b58;color:#7f5c32;padding:6px 6px 0px 6px;box-sizing: border-box;&quot;&gt; &lt;section data-autoskip=&quot;1&quot; class=&quot;135brush&quot; style=&quot;padding: 10px; color: #7f5c32; text-align: justify; line-height: 1.75em; letter-spacing: 1.5px; font-size: 14px; box-sizing: border-box;&quot;&gt; &lt;p&gt; {{词形变化}} &lt;/p&gt; &lt;/section&gt; &lt;section style=&quot;text-align: right;&quot;&gt; &lt;section style=&quot;width:35px;display:inline-block;&quot;&gt; &lt;img class=&quot;assistant&quot; style=&quot;width:100%;display:block;&quot; src=&quot;http://image2.135editor.com/cache/remote/aHR0cHM6Ly9tbWJpei5xbG9nby5jbi9tbWJpel9wbmcvN1FSVHZrSzJxQzVIaWFTRjdCcEVqU1c4MnFpYkxBZTRRMHRxY3EwNHRVV3U5Q3dod3JGWWlheWZHaWN0Yzkzc24xZzFOSE9ZS1BJZ1E3R3NvM0M2V2hNejVBLzA/d3hfZm10PXBuZw==&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;54&quot; data-width=&quot;100%&quot;/&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt;&lt;/section&gt;&lt;script type=&quot;text/javascript&quot;&gt;var initVoice = function () { var player = document.getElementById('dictVoice'); document.addEventListener('click', function (e) { var target = e.target; if (target.hasAttribute('role') &amp;&amp; target.getAttribute('role').indexOf('dict_audio_js') &gt;= 0) { var url = target.getAttribute('data-rel'); player.setAttribute('src', url); player.volume = 1; player.play(); e.preventDefault(); } }, false);};initVoice();&lt;/script&gt; 预览 image-20200503130008304 Anki-connect + 在线词典助手面向网页浏览的英语语境单词学习，支持在线选词同时配合Anki-connect一键生成卡片到Anki。 开发者教程 anki-connect的插件获取码 2055492159 anki-connect默认不支持同词多次插入，修改教程在此。 在线词典助手 在线词典助手配置如下 image-20200503130021147 资源anki各种资源 有道风格模板","link":"/2020/08/07/Code%20tools/Anki/anki-GD%E5%8D%95%E8%AF%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"Tag和Categories的命名","text":"Tag和Categories的命名最近博客的博文多了起来，有时候如何命名Tag和分类成一个小小烦人的问题。决定记录一下刚刚思考的结果： 先写categories后写tag 依据博文内容来源和主题，而不是目的分categoreis categories的一个分类至少或者可能有多篇博客才可以开出 categories条目应尽量少，但是应该全 应当能完全分类 Tag应包括博文的描述主题，可以从不同维度联系，以便快速查找 比如刷题的一篇博文，写算法——二分，DFS，LCA等等 尽量不要使用categorie分类高级条目，保持内容的不重叠 其内容为缩写是全大写;单个单词或者词组的第一个字母大写；","link":"/2020/08/07/Code%20tools/Blog/Tag%E5%92%8CCategories%E7%9A%84%E5%91%BD%E5%90%8D/"},{"title":"Hexo建站","text":"Hexo + Github Page 建站方案终于开始了建站之旅，之前都是采用信息源（知乎+B站+RSS）-&gt;onenote笔记来记录知识点。随着时间的推移也发现更开源、令人兴奋的方法是写博客。一来是对自己要求提高了不少，写博客可不像自己随手摘的笔记, 要求严谨而逻辑清楚，二来便于分享知识和交往新胖友。 陆陆续续装了好久也踩了不少的坑，在今天2020.04.26写下这篇博文，记录博客的开端吧！ 必要工具安装首先有必要说明的是，Hexo建站不可避免的是Node等工具，不得不说Linux仍是建站初最好的环境，同时Window推出的WSL可以很好的提供Linux的包管理体验——真香。本蒻姬喜欢在用VSCODE + WSL来建站，同时使用原MD文件来渲染网页的Hexo还会保留MD文件，配合WSL文件可以被WINDOW访问的功能，可以直接使用VSCODE 和 Typora 写作——不要太方便。 Node.js建议安装比较新的版本，可以看Github上下载源码（linux）并按照指示操作。以下是我安装的软件版本。 123456➜ _posts node -vv10.20.1➜ _posts npm -v6.14.4➜ _posts hexo -vhexo: 4.2.0 npm作为强大的Node包管理工具可以使用以下命令安装。推荐阅读：npm简介。 12sudo apt updatesudo apt install npm 接下来安装hexo框架，hexo是静态页面博客框架，拥有丰富的主题资源和活跃的开发社区，很多Github Page的都是hexo搭建的，其中使用Next风格的网站尤其多~ hexo可使用npm全局安装，如下。 12sudo hexo install hexo-cli -g# -g：global 最会自行安装git并配置好ssh哦。 建站hexo的使用逻辑是一键生成文章、页面、渲染页面、部署。在你想要存放建站文件的目录下运行以下命令可以初始化hexo博客文件。 1234hexo init [blog] #[$name]表namecd blog#局部安装hexo的指定本目录下的package.json的依赖包所指定的包npm install 如果一切顺利的话，可以执行以下命令启动本地hexo服务器来测试是否安装成功。 1hexo s #s: serve; 可选参数 -p 50100：指定监听端口 hexo可以通过以下命令来生成新文章——在source的_post文件下生成一个md文件。实际上hexo也会用这个md文件来渲染html页面，那就是后话了。在这里我非常推荐使用vscode自带的编辑器或者typero来编辑文件，尤其在文章的图片采取本地存储的情况下，typore支持直接插入图片并书写好合适的MD语句（typore扩展也支持图片上传服务器）。 12#尽量避免 图片名、MD文件名出现空格，不然容易出BUGhexo new &quot;new-post&quot; 当当！如果一切就绪，新文章也写好了，可以把本地文件部署到Github Page上去了。在Github上新建一个用户名.github.io的仓库，可以尝试去访问你的网站用户名.github.io~ deploy部署配置——在本地bog文件下的hexo配置文件_config.yml的部分内容，注意这里的配置连接最好使用SSH连接——免密输入的基操。 1234deploy: type: git repository: 'git@github.com:yourName/yourName.github.io.git' branch: master 使用以下命令可以把本地文件直接部署到GIthub上了,真方便啊。 1234# npm install hexo-deployer-git 如果不能直接d的话，装一下插件hexo d# 先生成再部署 更方便hexo g -d 主题找了两三个很Nice的博客主题icarus，yun 和满大街的Next。其中安装教程详见官网。推荐阅读：可能是最最完整的博客搭建教程 Post！图片本地图片无法正常显示——本地图片引用网址多出了一个.com/，直到第二次重装工具和hexo这个问题曾经困扰才解决。图片在本地的放置方案如下： 设置_config.yml中的post_asset_folder: true ，以便在新建文章的时候同时生成可以放置图片同名文件夹。在MD文章中的图片引用格式为[](./fileName/picName.png)（注意，这两个名字不要带空格，不然有非常多的BUG，可以使用-代替）， 配合hexo-asset-image插件可以让HTML渲染的地址符合变化。 1npm install https://github.com/7ym0n/hexo-asset-image --save 当然也有图床和OSS的解决方案，我这里暂时不去尝试，算是留一个坑。 个性化tags和categories设置文章的tags和categories可以在文章的yaml语段中书写，具体如下，官网介绍。 yaml 形如开头和结尾为三个横杠的键值对序列语段。 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 12345678910categories:#两层categories - [Sports, Baseball]- [MLB, American League, Boston Red Sox]- [MLB, American League, New York Yankees]- Rivalriestags:- Injury- Fight- Shocking 设置博客页面tags和categories 12hexo new page tagshexo new page categories 添加目录确保themes/icarus/_config.yml中有 123456widgets: - # Widget name type: toc # Where should the widget be placed, left or right position: left 然后在文章头部添加标签 1toc: true 阅读统计详见 文章置顶功能在themes/icarus/_config.yml配置 123456index_generator: path: '' per_page: 10 order_by: top: -1 date: -1 修改/⁨node_modules⁩/hexo-generator-index⁩/lib⁩/generator.js 12345678910111213141516171819var paginationDir = config.pagination_dir || 'page';// added codeposts.data = posts.data.sort(function(a, b) {if(a.top &amp;&amp; b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top;}else if(a.top &amp;&amp; !b.top) { return -1;}else if(!a.top &amp;&amp; b.top) { return 1;}else return b.date - a.date;});// endvar path = config.index_generator.path || ''; 修改模板中的post.md，添加top属性并设置默认值为0 1234567/scaffolds/post.md---title: {{ title }}date: {{ date }}tags:top: 0--- 最后，根据大家自己的喜好在前端添加标签咯~ 123456/themes/icarus/layout/common/article.ejs&lt;% if (post.top&gt;0) { %&gt;&lt;i class=&quot;fas fa-arrow-alt-circle-up&quot; style=&quot;color:#3273dc&quot;&gt;&lt;/i&gt;&lt;span class=&quot;level-item&quot; style=&quot;color:#3273dc&quot;&gt;&amp;nbsp;置顶&lt;/span&gt;&lt;% } %&gt; 更多阅读现在已知最省事的还是直接在md文件中添加&lt;!-- more --&gt; 域名绑定在本地_post文件的新建文件CNAME(大小写一致)，写上需要绑定的域名,比如一个二级域名blog.yourhost.xyz。在购买域名的服务商那添加CNAME解析，比如原域名为A,主记录为blog,那么博客访问的地址如XXXXX.github.io就多了一个blog.yourhost.xyz。 这里注意，如果在github setting 添加域名绑定，要注意新的版本可能会移除掉CNAME文件。 添加缩略图到你的文章你可以用两个步骤来添加缩略图到你的文章。首先，确保主题配置文件中已经开启缩略图的功能： 123_config.ymlarticle: thumbnail: true 文章的front-matter中提供一个图像的链接或路径： 123post.mdthumbnail: /gallery/thumbnails/desert.jpg--- 目录表（Table of Contents / Catalogue）要在发布页显示目录表（toc）部件，请先在你文章markdown文件的front-matter中添加toc:true： 12345---post.mdtitle: Table of Contents Exampletoc: true--- 接着，在主题配置文件添加toc部件： 12345_config.ymlwidgets: - type: toc position: left front-matter模板在scaffolds/post.md中修改为 1234567891011121314---title: {{ title }}date: {{ date }}tags:-categories: []thumbnail: http://static.come2rss.xyz/尼尔机械.jpgtoc: truetop: 10---&lt;!-- more --&gt; 常用命令部署步骤至此，部署到GitHub的工作已经完成，之后如果我们希望对自己的博客进行修改或者需要发布新的文章时，可以按以下三步进行。 1234$ hexo clean # 删除已经生成的静态页面#下面两个命令可以简写为 hexo g -d$ hexo generate$ hexo deploy 命令总结常用命令123456hexo new &quot;postName&quot; #新建文章hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 启动本地服务器并监视文件变化，同时编译渲染。 1hexo s --watch 命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy","link":"/2020/08/07/Code%20tools/Blog/hexo%E5%BB%BA%E7%AB%99/"},{"title":"md文件cdn加速","text":"ypore+七牛OSS\\CDN图片快速上传需要提前准备：一个备案好的主域名A，七牛认证过的bucket。 配置七牛CDN加速上传七牛的图片需要在CDN加速的域名处下载，为此需要在七牛的域名管理中添加自定义二级域名，比如static.A 。获取了七牛提供的解析域名值后在服务商出添加CNAME解析。 CNAME解析中主机值就是static.A的static，可能服务商在等等添加CNAME过程时间比较长，be patient. 配置Typore上传七牛Typore整合了图片上传工具ipicgo的功能，提供了ipic-core直接上传功能，只需要配置即可. 官方文档，picgo-Core中文文档 包括了七牛配置。 123456789101112131415{ &quot;picBed&quot;: { &quot;uploader&quot;: &quot;qiniu&quot;, // 代表当前的默认上传图床 &quot;qiniu&quot;: { &quot;accessKey&quot;: &quot;&quot;, &quot;secretKey&quot;: &quot;&quot;, &quot;bucket&quot;: &quot;&quot;, // 存储空间名 &quot;url&quot;: &quot;&quot;, // 自定义域名 &quot;area&quot;: /&quot;z0&quot; | &quot;z1&quot; | &quot;z2&quot; | &quot;na0&quot; | &quot;as0&quot;, // 存储区域编号, 这个一定要选对，不知道多试几次 &quot;options&quot;: &quot;&quot;, // 网址后缀，比如？imgslim &quot;path&quot;: &quot;&quot; // 自定义存储路径，比如 img/， 测试后好像没法使用 } }, &quot;picgoPlugins&quot;: {} // 为插件预留} 使用我的方案是复制图片到固定文件夹FilePath/${filename}，实现图片的本地分类管理，并在编辑框中使用typore自身功能快键上传图片的七牛，同时typore会自动获取并替换图片连接URL。 当然也可以从七牛空间管理中复制图片外链（要求空间为公共）。","link":"/2020/08/07/Code%20tools/Blog/md%E6%96%87%E4%BB%B6cdn%E5%8A%A0%E9%80%9F/"},{"title":"博客内容书写","text":"关于博客内容的书写4月份搭建的静态博客近来水了不少文章，主要是个人笔记和编程联系。但是随着POST量的增加，我也逐渐反思博客的真正意义是什么？ 以前我把博客更多当成一个资料库，一个知识记录库，更像一个在线笔记本，只需要push好写完的文章，click一下也可以搜索到过去学习的内容。而现实的Github Page上令人窒息的访问速度和Icarus主题的静态文件的缓冲时间，让我开始怀疑方案的可行性。再重新以一个读者的视角来看待博客的存在价值，简单的学习内容的堆叠、蜻蜓点水的内容覆盖，并不适合个人的学习和深入挖掘，当然也不会有人想要有深入交流的想法。 以我的观察，那么常见的博客记录类型有哪些呢？ 记录工作状态、学习生活的心得感悟、目标规划乃至对于世界各个的思考 记录工作中学习中遇到的困难和解决方案为主的技术内容 刷题、阅读论文、学习新博客的学习记录、知识总结、方案比较 对技术或者知识点的教程、讲解 其中前三点其无非就是对个人生长的规划和感悟，对学习生活的总结和分享，正是我需要发展的方向。 ;）开始重新整理博客。 记于20205月份的一个下着小雨的中午。 但是如果不在这里写，貌似都没有地方可以写笔记了。其他工具的云同步和MD语法并不是支持地非常好。","link":"/2020/08/07/Code%20tools/Blog/%E5%8D%9A%E5%AE%A2%E5%86%85%E5%AE%B9%E4%B9%A6%E5%86%99/"},{"title":"DockerCompose笔记","text":"Docker Compose工具是为了加快多个Docker容器部署工具，可以一键部署、启动、暂停多个容器。 命令docker-compose up -d 后台启动当前目录下的docker-compose.yml文件的容器","link":"/2020/08/07/Code%20tools/Docker/DockerCompose/"},{"title":"Docker基础速记和架构","text":"Docker是现代软件开发微服务的一个重要支柱，他让复杂多变的服务和系统能在仅一次调试和配置之后稳定运行——Build once, Vonfigure Once, and Run Auywhere.Docker具有轻量、隔离的特性。Docker相比于虚拟化技术所需要的部署虚拟系统所要承担的巨大代价不同，Docker只需要将软件和依赖打包在一个镜像中，并与系统相隔离。Docker的图标的集装箱暗示了Container的作用——将软件打包起来，更快更方便的部署环境，消除了开发测试和生产环境的不一致性。 入门安装(官方在Ubuntu下的安装和升级教程，当然我更喜欢的是WIn10下WLS2中的Docker官方安装（可见WSL2折腾笔记）和VSCode的教程。 这里我配合WSL2和Window下的Docker安装，成功在PS中开启了Docker命令，同时在WSL2的Linux dis开启了Docker进程，并且可以通过Localhost访问~按照VsCode教程来说这样已经可以通过VSCode直接访问（access）WLS中的容器了。 测试PS运行，可以访问localhost查看服务器，里面有docker更多教程。 1docker run -dp 80:80 docker/getting-started Linux Dis 运行： 1docker ps # 如果成功，可以看到getting-started的容器正在运行！ Windows10下的配合WLS2的Docker使用建议： docker文题最好运行在Linux目录下，而非挂载在/mnt下的Win文件 VHDX文件的大小限制WSL tooling built into Windows. CPU和内存限制WSL 2 utility VM 安装桌面版Docker之前最好删除Linux Dis下的Docker版本 加速为了提升镜像的安装速度，可以在daocloud.io中注册账户并点击顶部菜单的加速器，获取加速器命令，长得像这个样子`culr -sSl httpxxxxx | sh -s``。执行后，重启docker deamon即可获取飞一般的感觉。 1systemctl restart docker.service #WSL2环境不支持此命令 Docker架构Docke以C/S为架构，组成部分为：Docker Clinet（docker命令启动）、Docker Server（Docker daemon）、Docker image、Registry和Docker Container。 用户通过Docker Clinet启动Docker，用命令来制作下载Docker镜像并运行。Docker daemon是服务器组建，以Linux后台服务的方式运行，负责创建、运行、监控容器、构建和存储镜像。 默认情况下Docker deamon只能监听本地host的客户端请求，如果需要远程客户端请求，可以添加配置（具体Google）。 Docker images和Docker container的关系就像模子和陶瓷，可以通过Docker images创建Docker containers。镜像的制作方法有三种：（1）从头创建；（2）下载并使用其他人的现成镜像；（3）在一个镜像基础上创建一个新的镜像。 Docker container作为Docker images的运行实例，可以通过CLI（命令行接口）和API启动。 Registry是存放Docker镜像的仓库，分为公有和默认的，其中Docker Hub( https://hub.docker.com/)就是Docker公司维护的公有镜像库。 例子如果第一次安装Docker，运行这条命令 1docker run -dp 80:80 httpd 实际上Docker是这么处理的： 常用命令 ID一般都是指容器的ID，当然ID也可用其他值代替，比如系统取的随机名称。 镜像 docker build -t imagename . 在.构建imagename为名的docker镜像， -t为命名参数，-f可指定Dockerfile位置。 docker images imagename 查看docker images 信息 docker history imagename可以获取镜像的构建历史 docker tag imagename username/image:tag实际上tag更像是一个改镜像名命令（原来image还保持原样） docker rmi imagename 仅仅删除Docker host中的镜像。或者说删除某一个tag的镜像，当然如果一个镜像有多个tag，直到删除最后一个tag，这个镜像才被删干净。 容器docker run imagename 运行docker images ，并输出容器的lID（长ID） -it 交互模式进入容器 -d 后台运行 -p 端口映射 --name显式命名镜像，不加就会自动为镜像命名 --restart=always容器“停止运行”（包括正常退出）时，总是重启容器 也可以--restart=on-failure:3最多重启三次 长期运行容器示例：docker run imagename /bin/bash -c &quot;while true; do sleep 1; done&quot; 资源限制 -m或者--memory 设置内存使用额度，如 -m 200M --memory-swap=300M设置了20M内存和300MSWAP磁盘额度。若参数为-1表示没有限制。 --vm n开启n个内存工作线程 --vm-bytes 280M 每个线程分配280M -c 2048 设置单个容器分配CPU权重（CPU share），其CPU share决定了该容器CPU分配时间占所有容器的权重，也就是算比例。默认参数为1024。 限制读写 可以查询block IO。 docker create imagename创建容器 docker start id启动容器 docker pause id `docker unpause id` 停止\\恢复容器 docker stop id 停止容器 docker kill id 杀死容器 docker attach id attach到容器启动进程的终端 docker exec id 进入容器中并启动新进程 1docker ps` 显示运行中的容器。等价于`docker container ls -a 显示所有状态的容器，包括运行结束的镜像 docker logs -f id 持续打印输出 -f持续打印 系统docker login -u username 登陆Docker docker push imagename 上传镜像到Docker hub。其镜像不用加tag就是上传统一repository中的所有镜像。 docker pull imagename下载对应镜像 docker search imagename 搜索镜像","link":"/2020/08/07/Code%20tools/Docker/Docker%E5%9F%BA%E7%A1%80%E9%80%9F%E8%AE%B0%E5%92%8C%E6%9E%B6%E6%9E%84/"},{"title":"Docker容器","text":"值得注意的是，命令中指定容器不同于镜像，需要指出名字。指定容器可以使用ps中显示的名称 和sID和docker run返回的lID（长ID）。 ID一般都是指容器的ID，当然ID也可用其他值代替，比如系统取的随机名称。 进入容器（看吐了Orz） 有两种方法可以进入容器，一种是docker attch ID，另一种是docker exec -it id bash|sh。 前者直径进入容器启动命令的终端，只适用于查看输出，适用性一般，而且可以使用docker logs -f id代替；后者会在容器中开启一个新进程并可以启动其他进程，除了查看输出优先推荐使用。 前者使用ctrl+p + ctrl+q组合推出终端，后者使用exit推出终端。 容器操作容器其实是docker host上的一个进程。 docker stop id 停止容器——向该进程发送SIGTERM信号。 docker kill id 杀死容器——向该进程发送SIGKILL信号。 docker start id 重启容器，当然会保留第一次启动时运行的参数。 docker restart id重启容器，就是stop和start的组合。 docker pasuse id 暂时停止工作，容器不再占据CPU资源；docker unpasuse id 恢复工作； docker rm id 删除容器； 批量删除： 1docker rm -v $(docker ps -aq -f status=exited) 容器声明周期 docker-life-machine 注意两个点： 容器可以先creat再start，也可指直接run。 从这张图看kill和stop命令效果相同。 只有当容器正常退出和非正常退出，除了kill和stop之外都会依据--restart判断是否要重启 Docker底层Docker技术采用了cgroup来配置容器的各个性能限制的额度，用namespace来实现各个容器的共享和相互隔离同一个或多个设备、网络、文件和用户。","link":"/2020/08/07/Code%20tools/Docker/Docker%E5%AE%B9%E5%99%A8/"},{"title":"Docker网络","text":"这部分涉及了具体的Linux网络部分，理解的不是特别透彻 Docker网络分为单host网络和多host网络，单host网络又分为无网络、host网络、 bridge网络和user-definer网络。 单host网络单host网络实际上就是仅在一个主机上的多容器的网络，相反的多host网络定义就呼之欲出了。 无网络无网络即没有任何网络可以连接，适用于安全要求高无网络连接需要的容器，可以通过docker run --network=none中指定。 host网络host网络即直接使用host主机上的网络配置，与主机配置一样，但是容易出现端口占用而冲突。通过--network=host指定。 bridge网络docker安装时会创建一个名为docker0的Linux bridge。不指定--network默认创建的容器都会连接到docker0上。 新建的容器连接到网桥上会建立一个interfaces，容器自身会建立一个网卡eho@xxx，容器的网卡会连接到docker0网桥上的interfaces。其拓扑结构如下： image-20200511125601000 （接下来的内容就非常的计算机网络了！，不同的网桥为啥不能通信？如果加上路由器（网管）就能通信了吗？希望以后读过TCP/IP之后再去学习）","link":"/2020/08/07/Code%20tools/Docker/Docker%E7%BD%91%E7%BB%9C/"},{"title":"Docker镜像","text":"Dockerfile是镜像的描述文件，定义了如何构建镜像。 镜像中最基础的镜像是base镜像，不依赖于其他镜像，同时可以提供给其他镜像作为基础来扩展。那对应的Base镜像从Scratch构建。通常来说Base镜像是那些提供操作系统平台的镜像。 Linux的空间由内核空间（kernel）和用户空间（/dev,/proc等文件）组成。Linux启动时会加载bootfs文件系统，之后卸载掉bootfs，载入rootfs。对于base镜像而言，他底层使用的是Host的kernel，自身提供rootfs，比如基本命令、工具和程序库。也就是说对于镜像而言，内部他的kernel和host的kernel一致，而且无法修改。如果镜像对kernel有要求，可能使用虚拟机会更好一点。 如下图，两个不同Base镜像可以在同一个host共用底层kernel。 容器的分层结构构建一个新容器如下图dockfile所示，docker按照命令构建了多层级的叠加起来的容器。 一个重要的原因就是共享资源，也就是说Docker会共享不同镜像中的相同层的资源，避免重复载入。同时Docker最后添加一个可写层（称为容器层，其之下都称为镜像层）到每一个镜像的顶部，所有镜像的修改都会记录到Writable Container。 其操作如下： 添加文件：直接添加到容器层。 读取文件：从上到下依次到各个镜像寻找此文件 修改文件：同上查找文件并复制到容器层，然后修改（这称之为Copy-on-write） 删除文件：同上查找文件并在容器层中记录下删除记录 构建镜像有两种方式创建新镜像。一种是docker commit命令，另一种是写Dockerfile。 docker commit这种方法不推荐使用，对其他人不知晓其构建方法，不透明，不安全，重现性差。 具体步骤： 运行容器 安装软件 保存为新镜像并重命名 12docker ps #查看docker名字old_namedocker commit old_name new_name Dockerfile编写可以在/root目录下构建一个Dockerfile文件，内容如下： 12FROM ubuntuRUN apt-get update &amp;&amp; apt-get install -y vim 构建在Dockerfile文件夹下运行以下命令即可完成构建。 1docker build -t ubuntu-with-vi-dockerfile . 在.构建imagename为名的docker镜像， -t为命名参数，-f可指定Dockerfile位置。其中.表示build context为当前目录。Docker默认从bulid context中查找Dockerfile文件，并通过ADD，COPY命令将Build context中的文件添加到镜像。 ---&gt;20983rfjehwuh0e就是表示docker构建了一个新的镜像，其iD为那串数字。 ---&gt;Running in s132fj1142dSf就是表示docker临时构建了一个镜像。 缓存Docker会缓存已有的镜像的镜像层，比如包含RUN apt-get update &amp;&amp; apt-get install -y vim的新Dockerfile文件在构建时会直接利用已经存在的镜像，可以通过--no-cache禁用cache。 同时Dockfile的镜像层都是上层依赖下层的，所以只有之前一层的发生变化，镜像层的缓存就会失效。 在Docker下载上传镜像之时也会检查之前相同的docker镜像层来减少下载量。 调试进入在构建镜像失败之前的成功的镜像进行调试。 Run vs CMD vs ENTRYPOINT三种命令有两种编写格式：Shell和Exec。 Shell格式比较简单。他会调用底层shell来执行命令，同时解析掉环境变量。其形如： 12&lt;instruction&gt; &lt;command&gt;ENV name Cloun Man ENTRYPOINT echo &quot;Hello ,$name&quot; #输出 Hello, Cloud man Exec更易读。默认不解析而是直接调用命令, 当然也可以通过调用sh来解析环境变量，形如： 123&lt;instruction&gt; [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;,...]ENV name Cloud Man ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;] #输出：Hello, $nameENV name Cloud Man ENTRYPOINT [&quot;/bin/sh&quot;,&quot;-c&quot; &quot;Hello, $name&quot;] #输出：Hello, Cloud man RUN命令会执行命令并创建新的镜像层，常常用于安装软件包。注意要把sudo apt-get update &amp;&amp; apt-get insatll -y\\package放在一起，不然分层的特性可能导致更新的那层是很久之前构建的。 CMD命令将在容器运行初（docker run）执行命令，有三种格式： 推荐的Exec：CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] 为ENRTYPOINT提供参数，此时必须使用Exec：CMD [&quot;param1&quot;, &quot;param2&quot;] Shell格式：CMD command param1 param2 注意CMD命令会被docker run指定的命令所代替，且只有最后一个CMD命令会生效 ENTRYPOINT类似于CMD的执行命令格式，但是他不会被docker run指定的命令代替。同样的ENTRYPOINT有两种命令格式，但是不同的上面也讲了。ENTRYPOINT的参数一定都会被使用，同时可以由CMD提供参数，当然CMD参数也可以在容器启动是被动态替换掉。 RUN安装应用和服务；CMD设置默认启动命令；``ENTRYPOINT运行服务和应用，同时用CMD`提供动态可变参数。 其他Dockefile参数（待学习） 分发镜像特定镜像名字格式：[image name] = [registry]:[port]/[username]/[repository]:[tag] 默认tag值为latest，如果build -t imagename:tag中tag没有指明就会默认使用latest。registry默认为hub.docker.com，port默认为5000。 Docker Hub的repository的Tag命令方式如下： imagename:1指向1这个分支中最新版本； imagename:1.2指向1.2这个分支中最新版本； imagename:1.2.3指向1.2.3这个分支中的版本； imagename:latest指向最新版本； 用户上传的镜像的完整命名需要包含用户名字，形如username/imagename:tag。（官方维护的image没有名字）。而当用户上传到自己的registry是记得加registry:post。 构建自己的Registry官网上已经开源了repository的docker，可以直接安装。 注意对自己建立的registry上传的image上传、下载时，需要写成完整正确的image名字","link":"/2020/08/07/Code%20tools/Docker/Docker%E9%95%9C%E5%83%8F/"},{"title":"Git分支详细笔记","text":"很神奇 很有趣 仔细做了笔记 很有收获 何谓分支 Tips：简而言之 分支都是指向commit的指针，每一个分支都随着commit的提交而向新commit移动 Git 保存的不是文件差异或者变化量，而只是一系列文件快照。 在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。 为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域： 12$ git add README test.rb LICENSE$ git commit -m 'initial commit of my project' 当使用 git commit 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。 现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图 3-1 所示： image-20200425191333714 图 3-1. 单个提交对象在仓库中的数据结构 作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成图 3-2 的样子： image-20200425191533650 图 3-2. 多个提交对象之间的链接关系 Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。 image-20200425191623606 图 3-3. 分支其实就是从某个提交对象往回看的历史 创建和增长分支那么，Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 git branch 命令： 1$ git branch testing 这会在当前 commit 对象上新建一个分支指针 其实答案也很简单，它保存着一个名为 HEAD 的特别指针。它指向你正在工作中的本地分支。运行 git branch 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作（参考图 3-5）。 image-20200425191947610 图 3-5. HEAD 指向当前所在的分支 要切换到其他分支，可以执行 git checkout 命令。我们现在转换到新建的 testing 分支： 1$ git checkout testing 这样 HEAD 就指向了 testing 分支（见图3-6）。 image-20200425192041060 图 3-6. HEAD 在你转换分支时指向新的分支 这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次： 12$ vim test.rb$ git commit -a -m 'made a change' 图 3-7 展示了提交后的结果。 image-20200425192314264 图 3-7. 每次提交后 HEAD 随着分支一起向前移动 非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 git checkout 时所在的 commit 对象。现在我们回到 master 分支看看： 1$ git checkout master 图 3-8 显示了结果。 image-20200425192426649 图 3-8. HEAD 在一次 checkout 之后移动到了另一个分支 这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。 我们作些修改后再次提交： 12$ vim test.rb$ git commit -a -m 'made other changes' 现在我们的项目提交历史产生了分叉（如图 3-9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要 branch 和 checkout 这两条命令就可以完成。 image-20200425192554108 图 3-9. 不同流向的分支历史 由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即 parent 对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障。 分支操作git branch 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单： 1234$ git branch iss53* master testing 若要详细查看信息，运行 git branch -v： 1234$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes 要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 --merged 和 --no-merged 选项。 12345$ git branch --merged iss53* master$ git branch --no-merged testing 一般来说，列表中没有 * 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。对应的，如果简单地用 git branch -d 删除未合并的分支会提示错误，因为那样做会丢失数据： 123$ git branch -d testingerror: The branch 'testing' is not fully merged.If you are sure you want to delete it, run 'git branch -D testing'. 不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 -D 强制执行，就像上面提示信息中给出的那样。 git branch -r查看远程分支。 分支例子 官方内容写的很好，我进行一些简单的概括，官方链接（不过廖老师的例子和官方的好像啊 hhh） 现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程： 开发某个网站。 为实现某个新的需求，创建一个分支。 在这个分支上开展工作.。 假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理： 返回到原先已经发布到生产服务器上的分支。 为这次紧急修补建立一个新分支，并在其中修复问题。 通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 切换到之前实现新需求的分支，继续工作。 分支的新建与切换首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图 3-10）。 image-20200425193307440 图 3-10. 一个简短的提交历史 现在，你决定要修补问题追踪系统上的 #53 问题。把新建的分支取名为 iss53。要新建并切换到该分支，运行 git checkout 并加上 -b 参数： 12$ git checkout -b iss53Switched to a new branch 'iss53' 这相当于执行下面这两条命令： 12$ git branch iss53$ git checkout iss53 图 3-11 示意该命令的执行结果。 image-20200425193327729 图 3-11. 创建了一个新分支的指针 接着你开始尝试修复问题，在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53，见图 3-12）： 12$ vim index.html$ git commit -a -m 'added a new footer [issue 53]' image-20200425193347879 图 3-12. iss53 分支随工作进展向前推进 现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回 master 分支。 不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。目前已经提交了所有的修改，所以接下来可以正常转换到 master 分支： 12$ git checkout masterSwitched to branch 'master' 此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。 接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到搞定（见图 3-13）： 123456$ git checkout -b hotfixSwitched to a new branch 'hotfix'$ vim index.html$ git commit -a -m 'fixed the broken email address'[hotfix 3a0874c] fixed the broken email address 1 files changed, 1 deletion(-) image-20200425193421149 图 3-13. hotfix 分支是从 master 分支所在点分化出来的 有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 git merge 命令来进行合并： 123456$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward README | 1 - 1 file changed, 1 deletion(-) 请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix分支的直接上游，Git 只需把 master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。 现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了（见图 3-14）。 image-20200425193448731 图 3-14. 合并之后，master 分支和 hotfix 分支指向同一位置。 在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以 hotfix 已经完成了历史使命，可以删掉了。使用 git branch 的 -d 选项执行删除操作： 12$ git branch -d hotfixDeleted branch hotfix (was 3a0874c). 现在回到之前未完成的 #53 问题修复分支上继续工作（图 3-15）： 123456$ git checkout iss53Switched to branch 'iss53'$ vim index.html$ git commit -a -m 'finished the new footer [issue 53]'[iss53 ad82d7a] finished the new footer [issue 53] 1 file changed, 1 insertion(+) image-20200425193514085 图 3-15. iss53 分支可以不受影响继续推进。 值得注意的是之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果需要纳入此次修补，可以用 git merge master 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将 iss53 分支中的更新并入 master。 分支的合并在问题 #53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到 master 分支，运行 git merge 命令指定要合并进来的分支： 123456$ git checkout master$ git merge iss53Auto-merging READMEMerge made by the 'recursive' strategy. README | 1 + 1 file changed, 1 insertion(+) 请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象： image-20200425193538900 图 3-16. Git 为分支合并自动识别出最佳的同源合并点。 这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。 值得一提的是 Git 可以自己裁决哪个共同祖先才是最佳合并基础；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。 image-20200425193934126 图 3-17. Git 自动创建了一个包含了合并结果的提交对象。 既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。 1$ git branch -d iss53 遇到冲突时的分支合并有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了 hotfix 中修改的部分，将得到类似下面的结果： 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 git status 查阅： 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53 可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决： 123&lt;div id=&quot;footer&quot;&gt;please contact us at email.support@github.com&lt;/div&gt; 这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行。在解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行 git mergetool，它会调用一个可视化的合并工具并引导你解决所有冲突： 12345678910111213$ git mergetoolThis message is displayed because 'merge.tool' is not configured.See 'git mergetool --tool-help' or 'git help config' for more details.'git mergetool' will now attempt to use one of the following tools:opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emergeMerging:index.htmlNormal merge conflict for 'index.html': {local}: modified file {remote}: modified fileHit return to start merge resolution tool (opendiff): 如果不想用默认的合并工具（Git 为我默认选择了 opendiff，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。 退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。 再运行一次 git status 来确认所有冲突都已解决： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: index.html 如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。提交的记录差不多是这样： 12345678910Merge branch 'iss53'Conflicts: index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git/MERGE_HEAD# and try again.# 如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。 远程分支远程分支（ remote branch ）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。 我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时 master 分支的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。 可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为 origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作 如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动（见图 3-23）。 可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上（见图 3-24）。 image-20200425194111488 图 3-24. git fetch 命令会更新 remote 索引。 为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用（见图 3-25）。 image-20200425194159710 图 3-25. 把另一个服务器加为远程仓库 现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 teamone/master 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e（见图 3-26）。 image-20200425194223404 图 3-26. 你在本地有了一个指向 teamone 服务器上 master 分支的索引。 推送本地分支要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。 如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 git push (远程仓库名) (分支名): 1234567$ git push origin serverfixCounting objects: 20, done.Compressing objects: 100% (14/14), done.Writing objects: 100% (15/15), 1.74 KiB, done.Total 15 (delta 5), reused 0 (delta 0)To git@github.com:schacon/simplegit.git * [new branch] serverfix -&gt; serverfix 这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍 refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serverfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。 接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/serverfix，并指向服务器上 serverfix 所指向的版本: 1234567$ git fetch originremote: Counting objects: 20, done.remote: Compressing objects: 100% (14/14), done.remote: Total 15 (delta 5), reused 0 (delta 0)Unpacking objects: 100% (15/15), done.From git@github.com:schacon/simplegit * [new branch] serverfix -&gt; origin/serverfix 值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的 serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。 合并远程分支或者分化如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来: 123$ git checkout -b serverfix origin/serverfixBranch serverfix set up to track remote branch refs/remotes/origin/serverfix.Switched to a new branch &quot;serverfix&quot; 这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。 跟踪远程分支从远程分支 checkout 出来的本地分支，称为**跟踪分支(tracking branch)**。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。 在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]。如果你有 1.6.2 以上版本的 Git，还可以用–track选项简化: 123$ git checkout --track origin/serverfixBranch serverfix set up to track remote branch refs/remotes/origin/serverfix.Switched to a new branch &quot;serverfix&quot; 要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字: 123$ git checkout -b sf origin/serverfixBranch sf set up to track remote branch refs/remotes/origin/serverfix.Switched to a new branch &quot;sf&quot; 现在你的本地分支 sf 会自动将推送和抓取数据的位置定位到 origin/serverfix 了。 删除远程分支如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支，运行下面的命令: 123$ git push origin :serverfixTo git@github.com:schacon/simplegit.git - [deleted] serverfix 咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 git push [远程名] [本地分支]:[远程分支]语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。 经过查阅资料发现，高版本的git也可以这么删除分支。 1git push origin --delete Chapater6","link":"/2020/08/07/Code%20tools/Git/Git%E5%88%86%E6%94%AF%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/"},{"title":"Git笔记","text":"基础概念 七个非常非常常用的命令如下图所示。 提交\\查看\\删除命令.git文件就是版本库（Repository），一般的目录就是工作区（Working Directory） image-20200425184450980 git init初始化Git仓库（也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的） git add把多个文件添加到stage; git add fiilename可单独添加文件。git add的工作就是要提交的所有修改放到暂存区（Stage） git commit -m &quot;comment it&quot; 次性把暂存区的所有修改提交到分支。（ Note：add之后的修改是不会被commit上去的; 要使用双引号而不是引号。 git status查看仓库当前的状态 Note:一般有三种状态untracked(文件没被添加）,Changes not staged for commit:（修改存没有存放在stage中），Changes to be committed:（修改已经添加到stage但是没有提交）、nothing to commit, working tree clean(全部已提交)；changes中也有几种状态modified,deleted等等。 git diff 查可以查看工作区和版本库里面最新版本的区别：git diff HEAD -- readme.txt可指定文件 Note：diff好像是按行比较的， @@ -1,2 +1,7 @@表示变化的开始和结束的行数和变化号（？）git diff --cached针对暂存区查看差别。 git rm filename可以删除暂存区和工作区中的的文件。 Note: 若有误删，只能使用reset HEAD filename恢复到最新提交的版本，而commited之后的修改都会丢失，即存在数据丢失的情况。 版本控制git log查看commit的日志；--pretty=oneline参数可简化输出。 如1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL 1094adb7b9b3807259d8cb349e7df1d4d6477073 是commit id(版本号) git log --all --graph --decorate: visualizes history as a DAG git reflog 查看使用的每一条commit和reset [ren’e’san’tian]命令，可用来查找从新版本回退的到旧版本之时的新版本的ID号。 首先在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，也可以写成HEAD~DIFF_VERSION_NUMBER。 image-20200425184637910 git checkout --filename可以丢弃工作区的修改或者rm的删除 （这里很有意思！），这个文件回到最近一次git commit或git add时的状态。 Note:git checkout -- file没有--，就变成了“切换到另一个分支”的命令； git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 git reset HEAD filename可以把暂存区的修改和删除撤销掉，重新放回工作区。（状态从to be committed 变成了 changes）。用于应对提交了错误代码或者git rm到stage，操作完后再用上述checkout命令改回原来的代码。 Note：git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区 git reset --hard HEAD 回退到上一个版本。也可以这么写git reset --hard 1022a,这个例子中1022a是所需要回退的版本的ID前几位（长度足够长而不至于重了就行）。 Note: 如果在没有把已经commit的错误代码推送到远程库中，可在本地版本库中版本回退。 git mergetool: use a fancy tool to help resolve merge conflicts git rebase: rebase set of patches onto a new base Git学习资源推荐Miscellaneous GUIs: there are many GUI clients out there for Git. We personally don’t use them and use the command-line interface instead. Shell integration: it’s super handy to have a Git status as part of your shell prompt (zsh, bash). Often included in frameworks like Oh My Zsh. Editor integration: similarly to the above, handy integrations with many features. fugitive.vim is the standard one for Vim. Workflows: we taught you the data model, plus some basic commands; we didn’t tell you what practices to follow when working on big projects (and there are many different approaches). GitHub: Git is not GitHub. GitHub has a specific way of contributing code to other projects, called pull requests. Other Git providers: GitHub is not special: there are many Git repository hosts, like GitLab and BitBucket. Resources Pro Git is highly recommended reading. Going through Chapters 1–5 should teach you most of what you need to use Git proficiently, now that you understand the data model. The later chapters have some interesting, advanced material. Oh Shit, Git!?! is a short guide on how to recover from some common Git mistakes. Git for Computer Scientists is a short explanation of Git’s data model, with less pseudocode and more fancy diagrams than these lecture notes. Git from the Bottom Up is a detailed explanation of Git’s implementation details beyond just the data model, for the curious. How to explain git in simple words Learn Git Branching is a browser-based game that teaches you Git. 远程仓库Github允许使用了HTTP和SSH两种方式使用GIT，设置SSH能免去HTTP的权限和输入密码等限制。 sshssh — Secure Shell 工具是与远程服务器沟通的渠道。我们不仅可以使用 ssh 登录远程服务器，还可以利用 ssh 在不输入 GitHub 账户密码的情况下将 Git 仓库内容推送至 GitHub 远程仓库。 ssh 登录 GitHub下面配置与 GitHub 连接的 SSH 密钥（linux） 在 WSL 下生成 SSH 公钥 — 私钥对，此时生成的 SSH 密钥默认位于 ~/.ssh 路径下，公钥为 id_rsa.pub，私钥为 id_rsa： windows下的私钥放在个人用户的文件夹下.ssh。 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 打开 ssh-agent 使之在后台运行： 1eval &quot;$(ssh-agent -s)&quot; 将私钥添加到 ssh-agent 之中： 1ssh-add ~/.ssh/id_rsa 查看公钥并将之复制到剪贴板： 12345# 查看公钥内容cat ~/.ssh/id_rsa.pub# 将公钥复制到剪贴板cat ~/.ssh/id_rsa.pub | clip.exe 将复制好的公钥添加到 GitHub 账户密钥里面[2] 测试sshssh -T git@github.com测试ssh是否能连接到github上 ssh -T -p 443 git@ssh.github.com换端口测试 编辑~/.ssh/config文件（没有则创建一个），然后补充下面的代码： 123Host github.comHostname ssh.github.comPort 443 新建仓库远程仓无内容：在本地仓上新建一个仓库名与远程仓一样的仓库，记得add\\\\commit 123git remote add origin git@github.com:michaelliao/learngit.git#push after commiting your code.git push -u origin master 我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来。以后可以使用git push origin master推送最新修改。 git push --set-upstream [origin_source] [origin brance] 也可以把本地分支追踪到远程分支。 本地仓无内容：（最好）新建一个远程仓，在clone下来，使用$ git clone git@github.com:michaelliao/gitskills.git。如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 命令实例： 12345678//显示remote仓库git remote -v//添加远程仓库git remote add &lt;shortname&gt; https://github.com/paulboone/ticgitgit pull &lt;remote&gt;git push &lt;remote&gt; &lt;branch&gt;//设置远程仓库上游分支git push --set-upstream origin master 如果远程仓库已经提交过代码在本地和远程仓库都提交了至少一次commit之后，无法直接push上去代码，只能先pull下来（我观察）。可使用以下命令 12345#git pull origin master # 允许无相关历史的代码合并git pull origin master --allow-unrelated-histories ` 多人协作由于涉及到一些多人操作，所以暂时不学了 等待下一个机会 廖老师的多人协作 一些错误win10可能未开启ssh服务， 在powershell中测试并打开, Get-Service ssh-agent可获取openssh服务运行状态，Get-Service -Name ssh-agent | Set-Service -StartupType Manual开启ssh服务。SO的答案 ssh -T git@github.com可用于测试ssh秘钥是否连接正常；一定要输入yes不然会一直报错。。。 分支管理传统的工作分支示例: 一人对应一个支线，每个feature对应一个新支线。 image-20200425185348609 廖雪峰关于GIT分支管理的讲述很清晰，精彩；连接如下 本质上，每一个所谓的分支都是一个指针，每一个指针指向都是个提交的节点，创建和删除一个新的分支只不过是添加删除了一个指针。而一个新的提交commit也不过需要额外再移动一下指针罢了。而HEAD更是一个指向当前工作区的分支的指针。如图 image-20200425185438219 基操友情提示：每次在一个分支做的修改一定要commit之后，再去switch分支,不然出现会出现内容混乱的现象。保存现场参见下文。 git brabch列出所有分支，当前分支前面会标一个*号 git switch -c dev 创建（-c create）和切换到一个新的分支。相当于 1234创建：git branch dev 切换：git checkout dev 或者 git switch dev Note: git chechout -c dev作用等同。 git branch -d dev (合并完成后，当然不是必须的，只是从工程目的上讲),可以删除dev分支了。git branch -D dev 可删除没有合并的分支，即强行删除（-D）。因为该分支没有被合并，如果删除，就会失去修改。 git merge dev 把dev分支合并到master（现在所在的分支,这里有两个信息，一个是隐含的）分支上。dev的修改就合并到了master上。 Note：Fast-forward意味着“快进模式”，也就是直接把master指向dev的当前提交，合并速度非常快。但这种模式下，删除分支后，会丢掉分支信息。请使用--no-ff参数，表示禁用Fast forward： 分支冲突分支冲突出现在两个在同一文件下修改相同地方的分支合并之时。（那都得是commit过了） image-20200425185901715 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 。修改源文件，解决冲突后，提交过可得； image-20200425185942196 git log --graph --pretty=oneline --abbrev-commit可以以图形化方式查看提交合并结果；git log本身也能查看结果。 保存现场以及修改BUG如果当前任务没有完成，不能commit。则可以把未被追踪过的文件（即没有被add过）git add（追踪后），使用git stash保存现场。而Git把stash内容存在某个地方了，恢复现场有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除。另一种方式是用git stash pop，恢复的同时把stash内容也删了。 很像堆栈思想的上下文恢复 git stash list可以查看 git保存的工作现场的内容。 应用：工作中突然发现在过去的分支就出现一个bug，补救方法如下：廖雪峰教程 如果不能直接把当前的工作commit掉，只能先stash,在切换分支、开分支、修bug然后commit，merge, 删除分支；如果后来开发的支线也有主线的bug，可以方便的使用` git cherry_pick commit-id可在当前分支“复制”一次commit-id所修改的内容，他会自动提交一次commit。可以方便的解决不同支线相同bug的处理问题。 其他操作配置别名git config --global alias.st status就把git st就等价于git status。实例： 12#花里胡哨的命令！git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit 配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。每个仓库的Git配置文件都放在.git/config文件中： 12345678910111213141516$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： 123456789$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com 忽略文件忽略特殊文件： 有时必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，每次git status都会显示Untracked files ...。解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 Note:.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理；不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览 编写忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 对被忽略的文件，可以用-f强制添加到Git： 1$ git add -f App.class 可以用git check-ignore命令检查.gitignore忽略某文件的某行： 12$ git check-ignore -v App.class.gitignore:3:*.class App.class git 设置代理1$ git config --global http.proxy http://proxyUsername:proxyPassword@proxy.server.com:port 例如设置本地无认证的socks5代理，端口1080 1$ git config --global http.proxy socks5://127.0.0.1:1080 常识首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。所以版本控制是无法追踪WORD之类的二进制文件的。","link":"/2020/08/07/Code%20tools/Git/Git%E7%AC%94%E8%AE%B0/"},{"title":"jupyter笔记","text":"设置默认工作目录Jupyter notebook 只能在打开的工作目录下工作（创建文件，运行代码），所以十分有必要修改默认代码目录。 在Anaconda Prompt中生成配置文件打开Anaconda Prompt，输入如下命令： 1jupyter notebook --generate-config1 打开配置文件根据显示的路径，打开配置文件jupyter_notebook_config.py，全文搜索【notebook_dir】，找到后填入自己的工作路径并保存。（注意：工作路径不能出现中文，否则无法打开Jupyter Notebook） image-20200503125317705 修改JupyterNotebook快捷方式的目标属性(如果用Prompt也许就不用了)右击JupyterNotebook快捷方式，选择【属性】，删除【目标】属性中的【%USERPROFILE%】，点击【应用】–【确定】。","link":"/2020/08/07/Code%20tools/Jupyter/jupyter%E7%AC%94%E8%AE%B0/"},{"title":"Linux笔记","text":"基础命令uname -r 查看内核版本 sudo lsb_release -a 查看系统系统版本 cp 复制 sudo -i 提权， 使用 root 权限登录 su user 切换为user用户， 如果验证失败，可能原因是root密码未设置，（好像ubuntu的root密码每次开机都会变化，需要重新设置。系统不希望大家一直变身root） sudo passwd user 更改user密码 Ubuntu /debian 系操作Ubuntu /debian 系最大的好处就是可以使用「软件源」进行软件安装，使用 Ubuntu 自带的 deb 包管理系统APT安装软件可以减少直接下载源码编译的麻烦，所以这里就要用到「apt-get」系列命令了。 注意APT与命令apt、apt-get是不同的，apt-get和apt是高层的APT的命令API。 更换 Linux 子系统的软件源并更新软件因为默认的软件源是 Ubuntu 的官方源，我们可以选择替换为国内的软件源，比如说阿里云镜像的软件源。 sudo -i 提权， 使用 root 权限登录 1cp /etc/apt/sources.list /etc/apt/sources.list.old 不难看出管理源的文件就是 sources.list。所以命令是： 1vim /etc/apt/sources.list 阿里云源 12345678910deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 输入apt-get update Ubuntu 的软件源切换到阿里云的源了。apt-get upgrade 对当前系统的软件和类库进行来更新。 update 是同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。 upgrade是升级已安装的所有软件包，升级之后的版本就是本地索引里的，因此，在执行 upgrade 之前一定要执行 update, 这样才能是最新的。 APTAPT - Ubuntu’s Advanced Packaging Tool 是 Ubuntu 默认包管理工具。使用 Ubuntu 等 Linux 发行版时，我们往往都会使用 APT 等相似的包管理工具来安装、更新我们的软件包。命令 apt 和 apt-get 与 APT 不同，它们是用来和 APT 进行交互的高层命令执行工具。请大家清楚二者的区别。 其中，在 Ubuntu 16.04 中 Ubuntu 引入了 apt 命令来代替曾经老用户熟悉的 apt-get，提供了更用户友好的操作和命令行界面，对软件包 cache 缓存的处理也更为优雅。这里我推荐大家使用 apt 命令来与 APT 包管理工具交互，安装、管理和更新软件和依赖，接下来的文档中，我也都会使用 apt 命令进行介绍。 推荐阅读：Difference Between apt and apt-get Explained - It’s FOSS bash下载安装的 Windows Subsystem for Linux 默认就是 bash 的 Shell 环境。bash 是 Unix shell 的一种，是我们开发环境的基础。不过 bash 本身仅提供一个非常基础的命令行交互功能，没有类似 zsh 或 fish 等 Shell 的自动补全、命令提示等高阶功能。因此，这里推荐大家继续阅读，安装 zsh 或 fish 来替代 bash。 zsh 和 fish，都是 Unix-like 系统中不可或缺的好 Shell，它们都极大的拓展了我们命令行界面的交互体验。在命令行的世界中： fish 更加注重「开箱即用」的体验，让我们安装完成即拥有一个包含了命令高亮、自动补全等强大功能的 Shell 环境 zsh 则更加重视拓展性，借助于社区中优秀的 zsh 插件系统 oh-my-zsh 以及无数优秀的插件，zsh 同样能有比肩 fish 甚至比 fish 更高阶的功能和体验 zsh安装、配置安装 zsh 并将之设置为默认 Shell： 利用 apt 安装 zsh 1sudo apt install zsh 下载安装 oh-my-zsh，可能是市面上最好的 zsh 配置管理工具： 运行命令下载安装 1sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 将 zsh 作为默认的 Shell 环境（如果刚刚安装脚本没有这样做的话）： 1chsh -s $(which zsh) fish开箱即用的 fish 无需安装以上 zsh 中繁琐的插件就能拥有几乎全部上面提到的功能。如果你觉得 zsh 的配置繁琐无趣，那么 fish 可能更符合你的口味。 同样使用 Ubuntu 包管理工具安装 fish： 1sudo apt install fish 将 fish 作为默认 Shell： 1chsh -s $(which fish) 配置未经任何配置的 fish 即直接支持了诸多优秀的命令行交互特性。上图的例子中，我们可以看到 fish 开箱自带的几个功能： 输入命令的实时高亮，错误命令标红 历史命令的记忆，对输入命令的实时补全 对 *.png 等通配符（Wildcard character）的支持 相对 decent 的命令提示符（Prompt） fish 的配置文件位于 ~/.config/fish/config.fish，这一文件之于 fish 就像 .zshrc 之于 zsh、.bashrc 之于 bash 一样。 有关 fish 的配置方法推荐大家查看其官方文档：fish tutorial - fish shell 安装PipUbuntu16.04系统默认Python3，安装Pip如下。 12curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载安装脚本sudo python3 get-pip.py # 运行安装脚本。 判断是否安装 1pip --version 升级 pip 1pip install -U pip","link":"/2020/08/07/Code%20tools/Linux/Linux%E7%AC%94%E8%AE%B0/"},{"title":"linux有趣的工具","text":"这是慕课上的作业笔记，网站以后再补。 编辑器 VIM 命令和CLI工具见shell命令学习和Linux常用工具的笔记。 数据处理| 管道，典型的案例就是查看远程服务器历史记录。 12$ ssh myserver 'journalctl | grep sshd | grep &quot;Disconnected from&quot;' &gt; ssh.log$ less ssh.log sed数据流编辑器在ed编辑器上发展而来，可以使用命令来修改文件。 1234ssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed 's/.*Disconnected from //' The s command is written on the form: s/REGEX/SUBSTITUTION/, where REGEX is the regular expression you want to search for, and SUBSTITUTION is the text you want to substitute matching text with. 更多关于正则表达式的内容可参见Regular Expressions akw一个可以处理数据的编程语言 R和bc可以计算数据 gnuplot可以方便的画图 xrags可安装或者卸载包 ffmpeg可获取并处理图像数据 进程处理killing a processesCtrl-C可以停止执行当前执行的进程。它会发送一个SIGINT信号给正在执行的进程。 Ctrl-\\ 让进程退出执行，它会发送一个SIGQUIT信号给正在执行的进程。 Note that ^ is how Ctrl is displayed when typed in the terminal. kill -TERM &lt;PID&gt;会杀死一个进程，它会发送一个SIGTERMsignal给进程。 Pausing and backgrounding processesCtrl-Z可暂停一个进程，会发送一个SIGTSTP信号给进程。 fg and bg分别可以在前台运行和在后台运行程序（唤醒程序或者启动程序）。 可配合Ctrl-Z将已经运行的程序暂停，再放到后台运行。 jobs command lists the unfinished jobs associated with the current terminal session.You can refer to those jobs using their pid (you can use pgrep to find that out) To refer to the last backgrounded job you can use the $! special parameter. &amp;作为运行命令后缀，可使命令在后台运行，但是其提示信息仍会使用terminal的STDOUT，也就是说这些信息还是会显示在屏幕上。 注意上面的操作中，运行的程序还是terminal的子程序，也就是说terminal关闭时，也会发送一个SIGHUP给子程序，从而结束程序的运行。可以使用nohup忽略该信号，或者针对已经运行的进程使用disown。 SIGKILL总是可以杀死进程，但是无法杀死其进程的子进程。所以可能产生orphaned children processes。 You can learn more about these and other signals here or typing man signal or kill -t. 例子123456789101112131415161718192021222324252627282930313233343536373839404142$ sleep 1000^Z[1] + 18653 suspended sleep 1000$ nohup sleep 2000 &amp;[2] 18745appending output to nohup.out$ jobs[1] + suspended sleep 1000[2] - running nohup sleep 2000# &quot;%&quot; 表示的后面的数字是jobs显示进程的对应数字$ bg %1[1] - 18653 continued sleep 1000$ jobs[1] - running sleep 1000[2] + running nohup sleep 2000$ kill -STOP %1[1] + 18653 suspended (signal) sleep 1000$ jobs[1] + suspended (signal) sleep 1000[2] - running nohup sleep 2000# 给第一个进程发了一个SIGHUP信号，自然死掉了$ kill -SIGHUP %1[1] + 18653 hangup sleep 1000$ jobs[2] + running nohup sleep 2000$ kill -SIGHUP %2# 给第二个进程发了一个SIGHUP信号，但是由于忽略掉了该信号，所以没有死掉$ jobs[2] + running nohup sleep 2000$ kill %2[2] + 18745 terminated nohup sleep 2000$ jobs 命令行环境Terminal Multiplexerstmux可以方便的在一个terminal上操作多个对话窗口，便捷的令人惊叹。每个tmux的sesstion都可有window,每个window可以有多个plane。tmux创建出来的进程和原本的shell进程分离，所以不受原来进程关闭的影响，不同session之间也是独立的。他的强大之处在于方便快捷的切换到不同的window，并提供类似于vim的同一个window不同plane的排列方式。 （非常非常的令人惊喜，噢立给！） tmux expects you to know its keybindings, and they all have the form &lt;C-b&gt; x where that means (1) press Ctrl+b, (2) release Ctrl+b, and then (3) press x. tmux has the following hierarchy of objects: Sessions - a session is an independent workspace with one or more windows tmux starts a new session. tmux new -s NAME starts it with that name. tmux ls lists the current sessions Within tmux typing &lt;C-b&gt; d detaches the current session tmux a attaches the last session. You can use -t flag to specify which Windows - Equivalent to tabs in editors or browsers, they are visually separate parts of the same session &lt;C-b&gt; c Creates a new window. To close it you can just terminate the shells doing &lt;C-d&gt; &lt;C-b&gt; N Go to the N th window. Note they are numbered &lt;C-b&gt; p Goes to the previous window &lt;C-b&gt; n Goes to the next window &lt;C-b&gt; , Rename the current window &lt;C-b&gt; w List current windows Panes - Like vim splits, panes let you have multiple shells in the same visual display. &lt;C-b&gt; &quot; Split the current pane horizontally &lt;C-b&gt; % Split the current pane vertically &lt;C-b&gt; &lt;direction&gt; Move to the pane in the specified direction. Direction here means arrow keys. &lt;C-b&gt; z Toggle zoom for the current pane &lt;C-b&gt; [ Start scrollback. You can then press &lt;space&gt; to start a selection and &lt;enter&gt; to copy that selection. &lt;C-b&gt; &lt;space&gt; Cycle through pane arrangements. For further reading, here is a quick tutorial on tmux and this has a more detailed explanation that covers the original screen command. You might also want to familiarize yourself with screen, since it comes installed in most UNIX systems. Aliasesalias 提供了将命令行替换为一个别名的功能。 赋值”=”旁中不可有空格 12345678910111213141516171819202122232425262728# Make shorthands for common flagsalias ll=&quot;ls -lh&quot;# Save a lot of typing for common commandsalias gs=&quot;git status&quot;alias gc=&quot;git commit&quot;alias v=&quot;vim&quot;# Save you from mistypingalias sl=ls# Overwrite existing commands for better defaultsalias mv=&quot;mv -i&quot; # -i prompts before overwritealias mkdir=&quot;mkdir -p&quot; # -p make parent dirs as neededalias df=&quot;df -h&quot; # -h prints human readable format# Alias can be composedalias la=&quot;ls -A&quot;alias lla=&quot;la -l&quot;# To ignore an alias run it prepended with \\\\ls# Or disable an alias altogether with unaliasunalias la# To get an alias definition just call it with aliasalias ll# Will print ll='ls -lh' Note that aliases do not persist shell sessions by default. To make an alias persistent you need to include it in shell startup files, like .bashrc or .zshrc, which we are going to introduce in the next section. DotfilesDotfiles就是文件名前面带点的文件，即隐藏文件。 For bash, editing your .bashrc or .bash_profile will work in most systems. Here you can include commands that you want to run on startup, like the alias we just described or modifications to your PATH environment variable. In fact, many programs will ask you to include a line like export PATH=&quot;$PATH:/path/to/program/bin&quot; in your shell configuration file so their binaries can be found. Some other examples of tools that can be configured through dotfiles are: bash - ~/.bashrc, ~/.bash_profile git - ~/.gitconfig vim - ~/.vimrc and the ~/.vim folder ssh - ~/.ssh/config tmux - ~/.tmux.conf Dotfiles文件管理是使用版本管理工具方便快捷地管理多个Dotfils。只需几个命令，就能在一台新机子上安装和以前一模一样的文件和软件，真是诱惑。资源、 现在暂时不尝试 image-20200526182325028 SSH这内容是真的丰富 Dubugging and Profiling明天继续吧","link":"/2020/08/07/Code%20tools/Linux/linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B7%A5%E5%85%B7/"},{"title":"shell命令笔记","text":"Shell Tools and Scripting 前面部分参考课程 简单规则赋值：foo=bar 赋值语句中不可添加空格 &quot;和'的区别：Strings in bash can be defined with ' and &quot; delimiters but they are not equivalent. Strings delimited with ' are literal strings and will not substitute variable values whereas &quot; delimited strings will. 12345foo=barecho &quot;$foo&quot;# prints barecho '$foo'# prints $foo 函数体定义：As with most programming languages, bash supports control flow techniques including if, case, while and for. Similarly, bash has functions that take arguments and can operate with them. Here is an example of a function that creates a directory and cds into it. 1234mcd () { mkdir -p &quot;$1&quot; cd &quot;$1&quot;} 变量名定义：Here $1 is the first argument to the script/function. Unlike other scripting languages, bash uses a variety of special variables to refer to arguments, error codes and other relevant variables. Below is a list of some of them. A more comprehensive list can be found here. $0 - Name of the script $1 to $9 - Arguments to the script. $1 is the first argument and so on. $@ - All the arguments $# - Number of arguments $? - Return code of the previous command $$ - Process Identification number for the current script !! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions, then you can quickly execute it with sudo by doing sudo !! $_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by . Commands will often return output using STDOUT, errors through STDERR and a Return Code to report errors in a more script friendly manner. Return code or exit status is the way scripts/commands have to communicate how execution went. A value of 0 usually means everything went OK, anything different from 0 means an error occurred. 神奇的脚本符号： false || echo &quot;opes its false&quot; ||语句会在第一个命令执行失败后执行第二条。 The true program will always have a 0 return code and the false command will always have a 1 return code. 注意仅当返回值为0时命令 true &amp;&amp; echo &quot;Things went well&quot; 那就是仅在第一条命令执行成功后，第二条命令才会继续执行 command1 ; command2 就是无论如何都会按顺序执行两条命令 !! 一个神奇的命令，可以获取上一条运行过的完整的命令，可以使用在再次调用Sudo上，可用tap或者enter获取。 foo=$(pwd) （command substitution）等号两边不可加空格，因为他不是命令。其次$(pwd)是获取命令的返回值的意思。再其次，echo $foo才能打印出变量$foo的结果。 &lt;( CMD )(process substitution), will execute CMD and place the output in a temporary file and substitute the &lt;() with that file’s name. This is useful when commands expect values to be passed by file instead of by STDIN. For example, diff &lt;(ls foo) &lt;(ls bar) will show differences between files in dirs foo and bar. Wildcards - Whenever you want to perform some sort of wildcard matching you can use ? and * to match one or any amount of characters respectively. For instance, given files foo, foo1, foo2, foo10 and bar, the command rm foo? will delete foo1 and foo2 whereas rm foo* will delete all but bar. Curly braces {} - Whenever you have a common substring in a series of commands you can use curly braces for bash to expand this automatically. This comes in very handy when moving or converting files. 12345678# Globbing techniques can also be combinedmv *{.py,.sh} folder# Will move all *.py and *.sh filesmkdir foo bar# This creates files foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/htouch {foo,bar}/{a..h}touch foo/x bar/y 例子,grep for the string foobar and append it to the file as a comment if it’s not found. 123456789101112131415#!/bin/bashecho &quot;Starting program at $(date)&quot; # Date will be substitutedecho &quot;Running program $0 with $# arguments with pid $$&quot;for file in $@; do grep foobar $file &gt; /dev/null 2&gt; /dev/null # When pattern is not found, grep has exit status 1 # We redirect STDOUT and STDERR to a null register since we do not care about them if [[ $? -ne 0 ]]; then echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fidone In the comparison we tested whether $? was not equal to 0. Bash implements many comparisons of this sort, you can find a detailed list in the manpage for test. When performing comparisons in bash try to use double brackets [[ ]] in favor of simple brackets [ ]. Chances of making mistakes are lower although it won’t be portable to sh. A more detailed explanation can be found here. shell检查工具：Writing bash scripts can be tricky and unintuitive. There are tools like shellcheck that will help you find out errors in your sh/bash scripts. scripts： Python脚本使用shebang（下面例子中的#!开头的句子）来确定Python脚本语言的执行解释器。更灵活的写法是使用env命令，比如#!/usr/local/bin/env python 1234#!/usr/local/bin/pythonimport sysfor arg in reversed(sys.argv[1:]): print(arg) Some differences between shell functions and scripts that you should keep in mind are: 函数定义以后就会载入，执行时无需再载入，速度快。 函数可以在当前shell环境执行，但是脚本运行在他们的进程中；所以函数可以改变环境变量，比如进入目录，然而脚本不能。Scripts will be passed by value environment variables that have been exported using export As with any programming language functions are a powerful construct to achieve modularity, code reuse and clarity of shell code. Often shell scripts will include their own function definitions. Shell Tools命令帮助12-h`或者`-helpman command TLDR pages are a nifty complementary solution that focuses on giving example use cases of a command so you can quickly figure out which options to use. （推荐！） Finding filesfind 即时查找文件，强大的文本属性描述，可支持对文件执行命令。 123456789101112# Find all directories named srcfind . -name src -type d# Find all python files that have a folder named test in their pathfind . -path '**/test/**/*.py' -type f# Find all files modified in the last dayfind . -mtime -1# Find all zip files with size in range 500k to 10Mfind . -size +500k -size -10M -name '*.tar.gz'# Delete all files with .tmp extensionfind . -name '*.tmp' -exec rm {} \\;# Find all PNG files and convert them to JPGfind . -name '*.png' -exec convert {} {.}.jpg \\; 在数据库支持下的文件搜索程序，速度更快，但是由于数据库更新频率限制，可能结果不完整。 locate uses a database that is updated using updatedb. In most systems updatedb is updated daily via cron. Therefore one trade-off between the two is speed vs freshness. A more in depth comparison between find and locate can be found here. Finding codegrep, a generic tool for matching patterns from the input text. It is an incredibly valuable shell tool and we will cover it more in detail during the data wrangling lecture. -C for getting Context（上下文） around the matching line -v for inverting the match, i.e. print all lines that do not match the pattern. -R since it will Recursively go into directories and look for text files for the matching string. 其他grep的升级版 ack, ag and rg. All of them are fantastic but pretty much cover the same need. For now I am sticking with ripgrep (rg) given how fast and intuitive it is. Some examples: 12345678# Find all python files where I used the requests libraryrg -t py 'import requests'# Find all files (including hidden files) without a shebang linerg -u --files-without-match &quot;^#!&quot;# Find all matches of foo and print the following 5 linesrg foo -A 5# Print statistics of matches (# of matched lines and files )rg --stats PATTERN Note that as with find/fd, it is important that you know that these problems can be quickly solved using one of these tools, while the specific tools you use are not as important. Finding shell commandsup arrow（方向向上键）可以查找历史命令 history ：可以显示运行过的命令，可以配合grep使用，如 history | grep find will print commands with the substring “find”. Ctrl+R ：perform backwards search through your history.zsh也可以使用上下方向键来搜索。fzf提供更强大的模糊搜索命令功能。可见fzf、zsh。 fish: fish shell, this feature dynamically autocompletes your current shell command with the most recent command that you typed that shares a common prefix with it. It can be enabled in zsh and it is a great quality of life trick for your shell. 消除敏感信息：If you make the mistake of not adding the leading space you can always manually remove the entry by editing your .bash_history or .zhistory. Directory Navigationfasd: 支持将命令重命名，支持使用文件名的子串并填充为完整文件。 fasd Fasd ranks files and directories by frecency, that is, by both frequency and recency. The most straightforward use is autojump which adds a z command that you can use to quickly cd using a substring of a frecent directory. E.g. if you often go to /home/user/files/cool_project you can simply z cool to jump there. More complex tools exist to quickly get an overview of a directory structure tree, broot or even full fledged file managers like nnn or ranger shell学习笔记基础和变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/bin/bash# string , variable readonly your=&quot;Ruth_name&quot; #readonly# unset your:delete 'your'#echoecho &quot;Hi Guys!&quot; &quot;Welcome to my world!&quot;# this a variablename1=&quot;HU, hahahaha&quot;# string :strcat;echo &quot;$name1:&quot;${name1}&quot;!&quot;# string len echo ${#name1}# string substringecho `expr index &quot;${name1}&quot; ha`# string substringstring_cat=&quot;aaaaaaaaaaaaa&quot;string_cat=${string_cat:1:5}echo $string_cat############################array array_name=(1 2 3 4 5 6)array_name[7]=7echo ${array_name[7]}# 取得数组元素的个数length=${#array_name[@]}length=${#array_name[*]}# 取得数组单个元素的长度lengthn=${#array_name[n]}###################### :&lt;&lt;EOF注释内容...EOF#########################a=10;b=20;val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;#乘号(*)前边必须加反斜杠(\\)才能实现乘法运算；val=`expr $a \\* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;#条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]if [ $a == $b ]then echo &quot;a 等于 b&quot;fiif [ $a != $b ]then echo &quot;a 不等于 b&quot;fiif [ $a -eq $b ]then echo &quot;$a -eq $b : a 等于 b&quot;else echo &quot;$a -eq $b: a 不等于 b&quot;fiif [ $a -ne $b ]then echo &quot;$a -ne $b: a 不等于 b&quot;else echo &quot;$a -ne $b : a 等于 b&quot;fiif [ $a -gt $b ]then echo &quot;$a -gt $b: a 大于 b&quot;else echo &quot;$a -gt $b: a 不大于 b&quot;fiif [ $a -lt $b ]then echo &quot;$a -lt $b: a 小于 b&quot;else echo &quot;$a -lt $b: a 不小于 b&quot;fiif [ $a -ge $b ]then echo &quot;$a -ge $b: a 大于或等于 b&quot;else echo &quot;$a -ge $b: a 小于 b&quot;fiif [ $a -le $b ]then echo &quot;$a -le $b: a 小于或等于 b&quot;else echo &quot;$a -le $b: a 大于 b&quot;fi 逻辑运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#!/bin/bash#----------------------------导论----------------------:&lt;&lt;EOFShell 和其他编程语言一样，支持多种运算符，包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：EOFval=`expr 2 + 2`echo &quot;两数之和为 : $val&quot;#表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。#完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。#----------------------------运算----------------------:&lt;&lt;EOF+ 加法 `expr $a + $b` 结果为 30。- 减法 `expr $a - $b` 结果为 -10。* 乘法 `expr $a \\* $b` 结果为 200。/ 除法 `expr $b / $a` 结果为 2。% 取余 `expr $b % $a` 结果为 0。= 赋值 a=$b 将把变量 b 的值赋给 a。== 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。!= 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。EOFa=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \\* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;#----------------------------关系运算符----------------------:&lt;&lt;EOF 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：运算符 说明 举例-eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。-ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。-gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。-lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。-ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。-le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。布尔运算符下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：运算符 说明 举例! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。-o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。-a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:运算符 说明 举例&amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false|| 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;：运算符 说明 举例= 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。!= 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。-z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。-n 检测字符串长度是否为0，不为0返回 true。 [ -n &quot;$a&quot; ] 返回 true。str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。属性检测描述如下：操作符 说明 举例-b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。-d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。-p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。-r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。-w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。-x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。实例变量 file 表示文件&quot;/var/www/runoob/test.sh&quot;，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：#!/bin/bashEOF 函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172:&lt;&lt;EOFshell 函数linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。shell中函数的定义格式如下：[ function ] funname [()]{ action; [return int;]}1.可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithReturn(){ echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))}funWithReturnecho &quot;输入的两个数字之和为 $? !&quot;#函数返回值在调用该函数后通过 $? 来获得。#------------------------------------函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...带参数的函数示例：#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithParam(){ echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 ${10} !&quot; echo &quot;第十一个参数为 ${11} !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;}funWithParam 1 2 3 4 5 6 7 8 9 34 73注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。另外，还有几个特殊字符用来处理参数：参数处理 说明$# 传递到脚本的参数个数$* 以一个单字符串显示所有向脚本传递的参数$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。EOF 特殊函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171# ----------------------echo#这里的双引号完全可以省略，以下命令与上面实例效果一致：echo &quot;It is a test&quot;echo It is a test#2.显示转义字符echo &quot;\\&quot;It is a test\\&quot;&quot;&quot;It is a test&quot;#--------------------read#read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量:&lt;&lt;EOFread name echo &quot;$name It is a test&quot;以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:[root@www ~]# sh test.shOK #标准输入OK It is a test #输出EOF#------------------换行#4.显示换行echo -e &quot;OK! \\n&quot; # -e 开启转义echo &quot;It is a test&quot;#5.显示不换行echo -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行echo &quot;It is a test&quot;#--------------结果定向至文件echo &quot;It is a test&quot; &gt; myfile#---原样输出字符串，不进行转义或取变量(用单引号)echo '$name\\&quot;'#----显示命令执行结果echo `date`#注意： 这里使用的是反引号 `, 而不是单引号 '。#-----------结果将显示当前日期#Thu Jul 24 10:08:46 CST 2014 #------------------------------------------------#------------------------------------------------#------------------------------------------------#------------------------------------------------#------------------------------------------------#------------------------------------------------# ------------------printf-----------------------:&lt;&lt;EOFrintf 命令的语法：printf format-string [arguments...]参数说明：format-string: 为格式控制字符串arguments: 为参数列表。EOFprintf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234 printf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543 printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876:&lt;&lt;EOF%s %c %d %f都是格式替代符%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。%-4.2f 指格式化为小数，其中.2指保留2位小数。\\a 警告字符，通常为ASCII的BEL字符\\b 后退\\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略\\f 换页（formfeed）\\n 换行\\r 回车（Carriage return）\\t 水平制表符\\v 垂直制表符\\\\ 一个字面上的反斜杠字符\\ddd 表示1到3位数八进制值的字符。仅在格式字符串中有效\\0ddd 表示1到3位的八进制值字符EOF #------------------------------------------------#------------------------------------------------#------------------------------------------------#------------------------------------------------#------------------------------------------------#------------------------------------------------# ------------------test-----------------------:&lt;&lt;EOFShell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。数值测试参数 说明-eq 等于则为真-ne 不等于则为真-gt 大于则为真-ge 大于等于则为真-lt 小于则为真-le 小于等于则为真EOFnum1=100num2=100if test $[num1] -eq $[num2]then echo '两个数相等！'else echo '两个数不相等！'fi#代码中的 [] 执行基本的算数运算，a=5b=6result=$[a+b] # 注意等号两边不能有空格echo &quot;result 为： $result&quot;:&lt;&lt;EOF字符串测试参数 说明= 等于则为真!= 不相等则为真-z 字符串 字符串的长度为零则为真-n 字符串 字符串的长度不为零则为真实例演示：num1=&quot;ru1noob&quot;num2=&quot;runoob&quot;if test $num1 = $num2then echo '两个字符串相等!'else echo '两个字符串不相等!'fi文件测试参数 说明-e 文件名 如果文件存在则为真-r 文件名 如果文件存在且可读则为真-w 文件名 如果文件存在且可写则为真-x 文件名 如果文件存在且可执行则为真-s 文件名 如果文件存在且至少有一个字符则为真-d 文件名 如果文件存在且为目录则为真-f 文件名 如果文件存在且为普通文件则为真-c 文件名 如果文件存在且为字符型特殊文件则为真-b 文件名 如果文件存在且为块特殊文件则为真另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!&quot;最高，&quot;-a&quot;次之，&quot;-o&quot;最低。例如：cd /binif test -e ./notFile -o -e ./bashthen echo '至少有一个文件存在!'else echo '两个文件都不存在'fiEOF 重定向123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172:&lt;&lt;EOFshell 函数linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。shell中函数的定义格式如下：[ function ] funname [()]{ action; [return int;]}1.可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithReturn(){ echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))}funWithReturnecho &quot;输入的两个数字之和为 $? !&quot;#函数返回值在调用该函数后通过 $? 来获得。#------------------------------------函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...带参数的函数示例：#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithParam(){ echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 ${10} !&quot; echo &quot;第十一个参数为 ${11} !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;}funWithParam 1 2 3 4 5 6 7 8 9 34 73注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。另外，还有几个特殊字符用来处理参数：参数处理 说明$# 传递到脚本的参数个数$* 以一个单字符串显示所有向脚本传递的参数$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。EOF 监控系统信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/bin/bash#Get system infomation(sys_time=$(date +&quot;%Y-%m-%d %k:%M:%S&quot;)#os_version=$(lsb_release -a | sed -n '/Description/p' | awk -F '[:]' '{print $2}' | sed 's/^[[:space:]]*//')os_version=$(cat /etc/issue | grep Linux)kernel_release=$(uname -r)netcard_num=$(ifconfig -a | grep eth | wc -l)echo &quot;[public_info]&quot;echo -e &quot;sys_time=$sys_time\\t#系统时间&quot;echo -e &quot;os_version=$os_version\\t#操作系统版本&quot;echo -e &quot;kernel-release=$kernel_release\\t#内核版本&quot;#########NETCADE INFOMATION##########echo echo &quot;[netcard_info]&quot;echo &quot;netcard_num=$netcard_num&quot;echo &quot;#网卡名字|IP|MAC|网卡驱动|网卡速率|网卡发送流量(bytes)|网卡接收流量(bytes)|网卡总流量(bytes)&quot;for((n=0;n&lt;$netcard_num;n++))doReceive_byte=$(cat /proc/net/dev | grep eth$n | awk '{print$2}')Send_byte=$(cat /proc/net/dev | grep eth$n | awk '{print$10}')echo &quot;netcard_$((n+1))=eth$n|\\$(ifconfig eth$n | grep &quot;inet addr&quot; | awk '{print$2}' | awk -F'[:]' '{print$2}')|\\$(ifconfig -a | grep eth$n | awk '{print$5}')|\\$(ethtool eth$n | grep Speed | awk '{print$2}' | sed 's/^[[:space:]]*//')|\\${Receive_byte}|\\${Send_bytei}|\\$(($Receive_byte + $Send_byte))&quot;done##########CPU INFOMATION##############cpu_phical_count=$(cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l)cpu_model=$(cat /proc/cpuinfo | grep &quot;model name&quot; | uniq | awk -F'[:]' '{print$2}')cpu_core_num=$(cat /proc/cpuinfo | grep cores | uniq | awk -F'[:]' '{print $2}' | sed 's/^[[:space:]]*//')cpu_process_num=$(cat /proc/cpuinfo | grep process | wc -l)cpu_frequency=$(cat /proc/cpuinfo |grep MHz|uniq | awk -F'[:]' '{print $2}' | sed 's/^[[:space:]]*//')cache_size=$(cat /proc/cpuinfo | grep &quot;cache size&quot; | uniq | awk -F'[:]' '{print$2}')cpu_idle=$(mpstat | grep all | awk '{print$11}')cpu_used=$(mpstat | grep all | awk '{print$3}')echoecho &quot;[cpu_info]&quot;echo -e &quot;cpu_model=$cpu_model\\t#cpu型号&quot;echo -e &quot;cpu_core_num=$cpu_core_num\\t#cpu核数&quot;echo -e &quot;cpu_phical_count=$cpu_phical_count\\t#cpu个数&quot;echo -e &quot;cpu_frequendy=$cpu_frequency\\t#主频/单个&quot;echo -e &quot;cache_size=${cache_size}*$cpu_process_num\\t#缓存&quot;echo -e &quot;cpu_idle=${cpu_idle}%\\t#空闲率&quot;echo -e &quot;cpu_used=${cpu_used}%\\t#使用率&quot;###########memeber info###############echoecho &quot;[mem_info]&quot;echo -e &quot;mem_total=$(free -m | grep Mem | awk '{print$2}')\\t#总内存&quot;echo -e &quot;mem_used=$(free -m | grep buffers/cache | awk '{print$3}')\\t#已使用&quot;echo -e &quot;mem_free=$(free -m | grep buffers/cache | awk '{print$4}')\\t#可使用&quot;###########hard info ##################file_system_num=$(df -Ph | grep / | wc -l)echoecho &quot;[hard_info]&quot;echo &quot;file_system_num=$file_system_num&quot;echo &quot;#磁盘总容量(单位M)|已用容量(单位M)|可用流量(单位M)|已用百分比（%）|挂载目录&quot;df -Pm | grep / | awk '{print$2&quot;|&quot;$3&quot;|&quot;$4&quot;|&quot;$5&quot;|&quot;$6}'exit 0) &gt;system_infomation.txt","link":"/2020/08/07/Code%20tools/Linux/shell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"},{"title":"ssh笔记","text":"这内容是真的丰富 Secure Shell(SSH) 是由 IETF(The Internet Engineering Task Force) 制定的建立在应用层基础上的安全网络协议。它是专为远程登录会话(甚至可以用Windows远程登录Linux服务器进行文件互传)和其他网络服务提供安全性的协议，可有效弥补网络中的漏洞。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。 ssh安全机制SSH之所以能够保证安全，原因在于它采用了非对称加密技术(RSA)加密了所有传输的数据。传统的网络服务程序，如FTP、Pop和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。 但并不是说SSH就是绝对安全的，因为它本身提供两种级别的验证方法： 第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人攻击”这种方式的攻击。 第二种级别（基于密钥的安全验证）：你必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公钥，然后把它和你发送过来的公钥进行比较。如果两个密钥一致，服务器就用公钥加密“质询”(challenge)并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私钥在本地解密再把它发送给服务器完成登录。与第一种级别相比，第二种级别不仅加密所有传输的数据，也不需要在网络上传送口令，因此安全性更高，可以有效防止中间人攻击。 原文链接 ssh基本操作安装查看安装包 1dpkg -l | grep ssh 安装本地的ssh的服务器和客户端 12sudo apt-get install openssh-client #连其他人sudo apt-get install openssh-server #让别人连 启动启动ssh服务 1234# -e identail to -A select all processeps -e | grep ssh #如果有sshd 表示ssh已经启动#没有则启动sshsudo /etc/init.d/ssh start 停止和重启ssh服务 12sudo /etc/init.d/ssh stop #server停止ssh服务 sudo /etc/init.d/ssh restart #server重启ssh服务 登陆口令登陆12345678910ssh name@ip#调用图形界面ssh -X name@ip#如何客户机和服务器的登陆用户名相同可以省略用户名ssh ip#设置端口, 默认22 ssh -p port name@ip 如果是第一次登陆还需要把服务器的IP加入可信列表。之后输入密码即可登陆 公钥登陆本机生成密钥对 12ssh-keygen -t rsa # -t 表示密钥类型#密钥生成后存在放 /home/用户名/.ssh,其中私钥为id_rsa, 公钥为 id_rsa.pub 上传密钥到远程主机 12345ssh-copy-id name@ip#或者ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote#再或者cat .ssh/id_ed25519.pub | ssh foobar@remote 'cat &gt;&gt; ~/.ssh/authorized_keys' 之后就可以直接使用ssh登陆而无需输入密码了 退出12exit#或者按 Ctrl + D 运行程序当我们利用ssh在远程主机上跑程序的时候，只要关闭了终端就会中断ssh连接，然后远程主机上正在跑的程序或者服务就会自动停止运行。我们可以利用 nohup + 需要运行的程序 使运行的程序在切断ssh连接的时候仍然能够继续在远程主机中运行。nohup即no hang up(不挂起)。 Executing commandsAn often overlooked feature of ssh is the ability to run commands directly. ssh foobar@server ls will execute ls in the home folder of foobar. It works with pipes, so ssh foobar@server ls | grep PATTERN will grep locally the remote output of ls and ls | ssh foobar@server grep PATTERN will grep remotely the local output of ls 注意两个命令的区别 参考文章： (基本内容)[https://blog.csdn.net/li528405176/article/details/82810342], (进阶)[https://blog.csdn.net/pipisorry/article/details/52269785]","link":"/2020/08/07/Code%20tools/Linux/ssh%E7%AC%94%E8%AE%B0/"},{"title":"Matlab笔记","text":"待学习的内容 绘图大量的笔记 常用函数disp(Var) 打印很方便 数据常量123&gt;&gt;a = pi; %pi = pai &gt;&gt; disp(sprintf('2 decimals: %0.6f', a)) %字符串拼接和显示2 decimals: 3.141593 :happy: :kissing_heart: :carousel_horse: 矩阵创建 逗号和分号的运算起了标志行的作用 123456789101112131415&gt;&gt; v = [1 2 3]v = 1 2 3&gt;&gt; v = [1 ; 2; 3;]v = 1 2 3&gt;&gt; v = 1:0.1:2v = 1.0000 1.1000 1.2000 1.3000 1.4000 1.5000 1.6000 1.7000 1.8000 1.9000 2.0000 常见函数： ones(shape) zeroe(shape) rand(shape) randi(shape) % shape 代表数字列， 如2，3，5，1。 randn(shape) %正态分布的随机数 Gussses rand? eye(K) % 单位矩阵 矩阵运算： 常见的有矩阵乘法和矩阵点乘，点除，点方。 matlab不主持类似python的numpy的广播机制，但是仍然支持数字 + 矩阵的模式，同时 不同维度的矩阵无法相加减。 广播 只要阵列具有“兼容大小”，就允许在阵列之间进行上述二进制操作。当一个数组中的每个维度正好等于另一个数组中的相同维度，或者等于1时，大小被认为是“兼容的”。比如。 123456&gt;&gt; magic(3) + (1:3)ans = 9 3 9 4 7 10 5 11 5 描述 第一个数组大小 第二个数组大小 结果大小 矢量和标量 [3x1] [1x1] [3x1] 行和列向量 [1x3] [2x1] [2x3] 矢量和二维矩阵 [1x3] [5x3] [5x3] ND和KD阵列 [1x3x3] [5x3x1x4x2] [5x3x3x4x2] 复制扩展 repmat( A , m , n ) : 将向量／矩阵在垂直方向复制为m倍，在水平方向复制为n倍。 求和以及其他函数 引出一个matlab与python极为类似的但略有不同的概念，axis。常常在函数计算中起到指定运算方向的作用，如axis=1，则计算沿着竖直方向计算。 如sum(A, axis) 1581927781476 其他函数 如mean() max() 也是如此。 索引以及选择matlab的数据索引从1开始。对于矩阵可以使用[C]进行矩阵的数据合并，(C)进行索引。对于cell元胞可以通过{}索引。 Boolean索引 是一个非常强大的功能，通过逻辑表达式的组合可以删选出复杂的规则条件下的数据。而矩阵的逻辑运算一般都是扩展到各个元素的，这就方便了通过一个条件判断矩阵来索引出真正数据的操作。 下标索引 拿一维矩阵来举例，常见的操作有 单一索引A(1), 范围索引A(1:end), 间隔索引 A(1:2:end) , 向量索引A([1,3,5], :)。如果其他维度的数据需要索引最好把其他维度索引也写上，不管是不是需要全部索引。（这些索引名字 我自己想的~~ ）:kiss: :kiss: 数据管理1234567891011121314&gt;&gt; length(A) % give the longest dimension.&gt;&gt; who % 查看变量您的变量为:A I a ans c v w &gt;&gt; whos % 查看变量 Name Size Bytes Class Attributes A 2x3 48 double I 4x4 128 double %保存&gt;&gt; save test % 保存所有变量 当然也可以用laod 载入mat&gt;&gt; save test2.mat Y % 保存单个变量&gt;&gt; save test2.txt Y -ascii % save as test(ASCII) 运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304% 乘法&gt;&gt; A = [1 2 ; 3 4 ; 5 6];&gt;&gt; B = [2 3 ; 4 5];&gt;&gt; c = A * B c = 10 13 22 29 34 45 % element-wise operation% 一个3*1的矩阵和一个3*2的矩阵相乘类似于两个3 * 2的矩阵element-wise乘， 但是只要一个矩阵不是n*1或是1*n，或者两个矩阵维度不一样，那么就会无法element-wise乘。&gt;&gt; D = A .* c D = 10 26 66 116 170 270 &gt;&gt; A.^2 % element-wise operationans = 1 4 9 16 25 36&gt;&gt; 1./A % element-wise operation ans = 1.0000 0.5000 0.3333 0.2500 0.2000 0.1667&gt;&gt; v &lt; 3 % every element is judged.ans = 1×6 logical 数组 1 1 0 0 0 0%% such as log(), abs() and exp() is element-wise opetation too.%add&gt;&gt; A + ones(3,2)ans = 2 3 4 5% 也可直接➕1&gt;&gt; A + 1ans = 2 3 4 5 6 7 %transpose&gt;&gt; A'ans = 1 3 5 2 4 6 %max&gt;&gt; AA = 1 2 3 4 5 6&gt;&gt; max(A) % if A is matrix, output is column-wiseans = 5 6 &gt;&gt; [val, idx] = max([1 2 3 4 7 6])val = 7idx = 5 &gt;&gt; max([1 2 3 4 7 6])ans = 7 &gt;&gt; R1 = rand(3) % element-wise maxR1 = 0.4873 0.4805 0.8880 0.6459 0.1431 0.3434 0.8356 0.6037 0.5764&gt;&gt; R2 = rand(3)R2 = 0.2988 0.6937 0.2178 0.3194 0.7549 0.4476 0.6043 0.2309 0.6584&gt;&gt; max(R1, R2)ans = 0.4873 0.6937 0.8880 0.6459 0.7549 0.4476 0.8356 0.6037 0.6584&gt;&gt; max(A, [], 1) % 1 means that get the max column-wise value. ans = 5 6&gt;&gt; AA = 1 2 3 4 5 6&gt;&gt; max(A, [], 2) % 2 is ans = 2 4 6&gt;&gt; max(A(:))ans = 6&gt;&gt; max(max(A))ans = 6 %%find&gt;&gt; vv = 1 2 3 4 5 6&gt;&gt; find(v &lt; 3) % to vectorans = 1 2 &gt;&gt; M = magic(3) % to matrix M = 8 1 6 3 5 7 4 9 2&gt;&gt; find(M &lt; 7) ans = 2 3 4 5 7 9&gt;&gt; [r, c] = find(M &lt; 7) % anther way to get indexr = 2 3 1 2 1 3c = 1 1 2 2 3 3 % 其他函数&gt;&gt; a = [1, 15, 0.5, 2.5]a = 1.0000 15.0000 0.5000 2.5000%sum&gt;&gt; sum(a)ans = 19A = 1 2 3 4 5 6&gt;&gt; sum(A,1) % 以列为单位相加ans = 9 12&gt;&gt; sum(A,2) % 以行为单位相加ans = 3 7 11&gt;&gt; prod(a)%ans = 18.7500&gt;&gt; floor(a)ans = 1 15 0 2&gt;&gt; ceil(a)ans = 1 15 1 3%flipud&gt;&gt; sum(sum( flipud(eye(9)) .* magic(9)) ) %矩阵上下翻转ans = 369% identity matrix&gt;&gt; M = magic(3)M = 8 1 6 3 5 7 4 9 2&gt;&gt; N = pinv(M)N = 0.1472 -0.1444 0.0639 -0.0611 0.0222 0.1056 -0.0194 0.1889 -0.1028&gt;&gt; N * Mans = 1.0000 0.0000 -0.0000 -0.0000 1.0000 0.0000 0.0000 -0.0000 1.0000 字符串字符串本质来说只是带字符的向量，可以进行多种类似向量的操作，比如索引、拼接之类。 比较 strcmptf = strcmp(s1,s2) 比较 s1 和 s2，如果二者相同，则返回 1 (true)，否则返回 0 (false)。如果文本的大小和内容相同，则它们将视为相等。返回结果 tf 的数据类型为 logical。 格式化 sprintfstr = sprintf(formatSpec,A1,...,An) 使用 formatSpec 指定的格式化操作符格式化数组 A1,...,An 中的数据，并在 str 中返回结果文本。sprintf 函数按列顺序格式化 A1,...,An 中的值。如果 formatSpec 是字符串，则输出 str 也是字符串。否则，str 是字符向量。 比如 1234formatSpec = 'The array is %dx%d.';A1 = 2;A2 = 3;str = sprintf(formatSpec,A1,A2) 打印字符串 fprintf直接格式化并打印字符串到显示器上，其中格式方式同sprintf。 字符串拼接 三种方法12345678方法一：用中括号将str1和str2像矩阵元素一样包含起来：&gt;&gt; SC=[str1,str2]方法二：用strcat函数&gt;&gt; SB=strcat(str1,str2) % 其他用途 &gt;&gt; strcat({'Red','Yellow'},{'Green','Blue'})方法三：利用sprintf函数&gt;&gt; number=123;&gt;&gt; STR=sprintf('%s%d',str1,number) 画图强大的绘图功能是Matlab的特点之一，Matlab提供了一系列的绘图函数，用户不需要过多的考虑绘图的细节，只需要给出一些基本参数就能得到所需图形，这类函数称为高层绘图函数。此外，Matlab还提供了直接对图形句柄进行操作的低层绘图操作。这类操作将图形的每个图形元素（如坐标轴、曲线、文字等）看做一个独立的对象，系统给每个对象分配一个句柄，可以通过句柄对该图形元素进行操作，而不影响其他部分 PLOT 基本用法： 一组向量对 1234&gt;&gt; plot(t,y);&gt;&gt; hold on;&gt;&gt; z = pi * cos(t);&gt;&gt; plot(t,z); 多组向量对 1234%plot函数可以包含若干组向量对，每一组可以绘制出一条曲线。含多个输入参数的plot函数调用格式为：plot(x1，y1，x2，y2，…，xn，yn)%如下列命令可以在同一坐标中画出3条曲线。&gt;&gt; x=linspace(0,2*pi,100);&gt;&gt; plot(x,sin(x),x,2*sin(x),x,3*sin(x)) 当输入参数有矩阵形式时，配对的x,y按对应的列元素为横坐标和纵坐标绘制曲线，曲线条数等于矩阵的列数 绘图选项 线型 颜色 标记符号 - 实线 b蓝色 . 点 s 方块 : 虚线 g绿色 o 圆圈 d 菱形 -. 点划线 r红色 × 叉号 ∨朝下三角符号 – 双划线 c青色 + 加号 ∧朝上三角符号 m品红 * 星号 &lt;朝左三角符号 y黄色 &gt;朝右三角符号 k黑色 p 五角星 w白色 h 六角星 坐标控制 想要精密的控制坐标轴的表现，需要下面多条命令的操作。 123456xlim([2, 46]);%只设定x轴的绘制范围ylim([0, 132]);%只设定x轴的绘制范围set(gca,'XTick',[2:2:46]) %改变x轴坐标间隔显示 这里间隔为2%以上就可以对x轴做很好的控制了，y轴类似。axis([2,46,0,2]) % axis([xmin,xmax,ymin,ymax])，用这个语句可以对x，y轴的上限与下限绘制范围一起做控制，但是间隔还是要用上面的set来改 其他注释 123xlabel('x name');% x轴名称ylabel('y name');legend('xxx'); %线条注释,多条的话: legend('xxx','xxx2','xxx3'） 文字注释 text可以接受向量化的数据输入，从而同时注释多个点的文字。 1234xt = [-2 2];yt = [16 -16];str = {'local max','local min'};text(xt,yt,str) hold on 维持画布不变化； figure 新开两个figure画板。subplot在同一个窗口上开多个子画板。 123456&gt;&gt; subplot(1,2,1); plot(t,z);&gt;&gt; subplot(1,2,2); plot(t,y);&gt;&gt; axis([5 10 0 4]) % X轴范围为[5,10],y轴范围为[0,4];&gt;&gt; clf - 清除当前图窗窗口 此 MATLAB 函数 从当前图窗中删除其句柄未隐藏的所有图形对象（即它们的 HandleVisibility 属性设置为 on）。 SCATTER还是看官方文档 画圆12345678910111213function [x,y] = circle(R,cx,cy,nb_pts)%%%%%%%%%%%%%%%%%%%% 画圆函数%%%%%%%%%%%%%%%%%%%alpha=0:pi/nb_pts:2*pi;%角度[0,2*pi]%R=2;%半径x=R*cos(alpha)+cx;y=R*sin(alpha)+cy;plot(cx,cy,'r+',x,y);grid on;axis equal;end IMAGESC 涂色123&gt;&gt; figure(3)&gt;&gt; imagesc(magic(15)),colorbar, colormap gray% imagesc 生成一个对应于矩阵数值和数量的‘像素块’图像 控制语句123456789101112131415161718for i = 1:10, %这里也可遍历矩阵w = w + 5;if( i &gt; 5) break;end;end;&gt;&gt; ww = 35&gt;&gt; if( v == 2)disp(&quot;dsf is the strongest person in the confusing world!&quot;)else v = 0 ;end;v = 3 函数123function [value1, value2] = Function_name(par1, par2)value1 = value2 = 其他操作typing ctrl-c to quit the running program. 文件操作保存与载入程序数据非常使用的两个函数，不过我一般只用来保存临时变量。 save('FILENAME', 'VARIABLES') load('FILENAME', 'VARIABLES') 的括号可以去掉 Excel文件的导入与导出12[num, txt, raw] = xlsread('文件名.xls','工作表', '数据范围')status = xlswrite(‘filename.xls’, ‘数据’, ‘工作表’, ‘指定区域’) 混合文本读入（目前可用csv）一般来说，最难读入是这种文办，数据内容比较复杂，常常带有数字、字符串等内容。 1textscan(fid, 'format', N, 'param', value); 其中，fid为文件句柄；format为读取格式；N表示用该格式读取N次数据；param,value（可选项）指定分隔符和值对。 N其实也是可选项。 注意：使用textscan之前，必须先用fopen打开要读入的文件；函数textread用法类似。 12345fid=fopen('data6.txt','r'); %打开文件句柄C=textscan(fid, '%s%s%f32%d8%u%f%f%s%f'); %按格式读入元胞数组Cfclose(fid); %关闭文件句柄 向量化编程 可见图中的两个更新公式中，仅有xixi的部分是不同的。把多个xixi座位一个整体，那么就可以得到一个简洁的公式： （图中各个符号的维度如图所示） 其他函数12345678910111213141516171819202122232425262728293031323334353637383940%标准差std&gt;&gt; help stdstd - 标准差 此 MATLAB 函数 返回 A 沿大小不等于 1 的第一个数组维度的元素的标准差。 如果 A 是观测值的向量，则标准差为标量。 如果 A 是一个列为随机变量且行为观测值的矩阵，则 S 是一个包含与每列对应的标准差的行向量。 %help&gt;&gt; help meanmean - 数组的均值 此 MATLAB 函数 返回 A 沿大小不等于 1 的第一个数组维度的元素的均值。 M = mean(A) M = mean(A,dim) M = mean(___,outtype) M = mean(___,nanflag) 另请参阅 median, mode, std, sum, var mean 的参考页 名为 mean 的其他函数&gt;&gt; M = magic(5);&gt;&gt; mean(M,1)ans = 13 13 13 13 13&gt;&gt; mean(M,2)ans = 13 13 13 13 13 高阶操作STRING 命令化主要应对多个重复但无法向量化处理的操作，比如多个不同长度的数据的绘图任务，不可以直接塞给plot一个矩阵完事，会有多与少数据掺杂进去的。 其实现方式是通过eval执行命令的string。eval函数的功能是将字符串转换为matlab可执行语句。 比如重复执行导入随名次变化的名字的mat文件。 12345for i=1:100 eval([‘load ’ num2str(i) ‘.mat’]) end % 当然也可以使用 sprintf打印字符串； Note：string中不能含有’，也就是说遇到’，需要特殊处理比如， 12% 执行 plot(nii, 'LineWidth', '2');eval(['plot(n',num2str(ii),char(39),'LineWidth', char(39), ',2'); 像素点级画图出自Andrew的第四周编程练习PlotPic。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function [h, display_array] = displayData(X, example_width)%DISPLAYDATA Display 2D data in a nice grid% [h, display_array] = DISPLAYDATA(X, example_width) displays 2D data% stored in X in a nice grid. It returns the figure handle h and the % displayed array if requested.% Set example_width automatically if not passed inif ~exist('example_width', 'var') || isempty(example_width) example_width = round(sqrt(size(X, 2)));end% Gray Imagecolormap(gray);% Compute rows, cols[m n] = size(X);example_height = (n / example_width);% Compute number of items to displaydisplay_rows = floor(sqrt(m));display_cols = ceil(m / display_rows);% Between images paddingpad = 1;% Setup blank display% 画板display_array = - ones(pad + display_rows * (example_height + pad), ... pad + display_cols * (example_width + pad));% Copy each example into a patch on the display arraycurr_ex = 1;for j = 1:display_rows for i = 1:display_cols if curr_ex &gt; m, break; end % Copy the patch % Get the max value of the patch % 格子作画： reshape改变图片像素排列方式 max_val = max(abs(X(curr_ex, :))); display_array(pad + (j - 1) * (example_height + pad) + (1:example_height), ... pad + (i - 1) * (example_width + pad) + (1:example_width)) = ... reshape(X(curr_ex, :), example_height, example_width) / max_val; curr_ex = curr_ex + 1; end if curr_ex &gt; m, break; endend% Display Image% 每个元素代表了一个像素点h = imagesc(display_array, [-1 1]);% Do not show axisaxis image offdrawnow;end 系统操作编辑文件: edit file ： 可同时创建文件 工作路径12345678your path here')`这条语句就可以把此路径加入到matlab工作路径中。比如一些基本的 `cd`, `pwd`, `ls`都可以使用。​```matlab&gt; &gt; pwd % give the path where worksans = ‘G:\\Matlab\\bin’​``` cd ‘H:\\重要文件\\在校学习比赛\\学习资料\\机器学习\\机器学习 Andrew’ls Linear Regression with multiple variables.md2 Linear Regression with multiple variables.assets 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190# 错误笔记$n*1$的矢量相加或相减与一个$1*n$的矢量得到的确实一个$n*n$的矩阵！## # 快捷键MATLAB 命令栏显示处理的常用命令清屏：clc紧凑显示格式：format compact宽松显示格式：format loose数据高精度显示：format longG数据低精度显示：format short**编辑器窗口（Editor）下的常用快捷键：**自动对齐程序（整理缩进）-自动整理代码 用鼠标选中代码行，按Ctrl + I**快速注释**代码段 拖动鼠标选中需要注释的代码行，按Ctrl + R快速取消注释代码段 拖动鼠标选中已经注释的代码行，按Ctrl + T撤销改动 Ctrl + Z取消撤销（撤销过多时使用） Ctrl + Y多行代码增加缩进（代码段右移） 选中代码段，按 Tab键 或 Ctrl + ]多行代码减少缩进（代码段左移） 选中代码段，按 Shift+Tab键 或 Ctrl + [自动补全命令（记不全函数名时使用） 输入函数的前几个字母，再按Tab查找或替换变量名、函数名 Ctrl + F关闭当前的程序文本（.m）文件 Ctrl + W在Editor窗体中**切换**Ctrl + PageUp/PageDownCtrl+PgUp表示编辑器窗口向左切换文件Ctrl+PgDn表示编辑器窗口向右切换文件 Ediotor\\命令行**窗口切换**：ctrl+Tab**代码调试常用快捷键：**运行 F5可保存并直接运行程序执行选中代码段 F9单步执行 F10F11 表示step in，即当遇见子函数时，使用此快捷键，进入函数内部Shift + F11 表示step out，即使用此快捷键，执行完子函数的剩余程序，并跳出子函数设置或取消断点的方法有两种(1) 在要设置断点的行左侧的-处单击；(2) 可按F12设置断点。直接跳至某行 Ctrl + G， 强制中断程序的运行 Ctrl + C命令窗口（Command Window）下的常用快捷键与命令：再现历史命令上下光标键↑↓ ，在命令窗口中，上下光标键可以调用Matlab最近使用过的历史命令，便于快速重新执行。 如果输入命令的前几个字母，再使用光标键，则只会选择以这些字母开始的命令。 上下箭头寻找此前和此后输入的命令，每次一条。快速退出MATLAB Ctrl + Q清除输入的命令 Esc将光标处至结尾之间的代码删除 Ctrl + Kwhat 显示当前工作路径中的所有代码文件type 代码文件名 显示代码文件的内容edit 启动编辑器，并新建一个空白文件edit 代码文件名 打开相应代码文件whatsnew 列出MATLAB新版本更新的内容**切换窗口快捷键：**Ctrl+0 命令行窗口（Command Window）Ctrl + Shift + 0 编辑器窗口（Editor）Ctrl + 1 历史命令窗口（Command History）Ctrl + 2 当前工作窗口（Current Folder）Ctrl + 3**工作空间（Workspace）**初学者要把下面的基本使用规则，牢记于心：1. 输入时，标点必须是英文状态下的2. 大多数情况下，MATLAB对空格不予处理3. 小括号代表运算级别，中括号用于生成矩阵，大括号用于构成单元数组4. 分号 ; 的作用：不显示运算结果（抑制输出），但对图形窗口不起作用。分号也用于区分行。5. 逗号 , 的作用：函数参数分隔符，也用于区分行，显示运算结果，当然不加标点也显示运算结果6. 冒号 : 多用于数组7. 续行号 ... 不能放在等号后面使用，不能放在变量名中间使用，起作用时默认显蓝色8. 双引号 'string' 是字符串的标识符9. 感叹号 ! 用于调用操作系统运算10. 百分号 % 是注释符号，对于百分号后面直到行末的语句，matlab跳过执行。另外还可用于代码块注释，即对多行代码一次注释， 格式为：（注意%{ 和%}都要单独成行11. 乘号 * 总是不能省略的，除了表示复数，比如2+3i时可以省略12. 除号有 / 或 \\ ，它两个的关系是：a除以b表示为a/b，或 b\\a13. 等号 = 用于赋值14. == 表示数学意义上的等号15. 主窗口（Command Window）里面，输入时，换行用Shift+Enter16. 主窗口（Command Window）里面，运行程序，执行命令用Enter17. 矩阵中用圆括号表示下标，单元数组（cell）用大括号表示下标18. 对变量名的基本要求：区分大小写，不超过63个字符，以字母开头，只能是字母，数字和下划线19. clc clear command（命令窗口中清除所有代码）（清屏）， clf clear figure（清理图形窗口）（并非关闭figure窗口） close 关闭最近的figure窗口 close all 关闭所有figure窗口 clear 清理工作空间（workspace）中的所有变量 clear+变量名 清理工作空间中的指定变量（如果是多个变量，用空格隔开） edit+函数名 查看或编辑源文件 who 显示工作空间中的所有变量名（仅展示出变量的名字） whos 显示工作空间中的所有变量名及其属性（大小、字节数、数据类型，等等） which+函数名 证实该函数是否在当前路径 what 列出当前路径的所有matlab文件 load 加载外部文件 save 保存变量到外部文件。如果save后面没有任何东西，则默认将工作空间中的所有变量保存在文件matlab.mat中。 save 文件名 指定变量列表——将指定变量保存在文件中（其中文件名不需要用单引号括起来，文件名的 .mat 后缀也可省略）。（具体地，可以执行doc save来查看save如何使用。） 例如： \\&gt;&gt;save var2 x y ; —— 将变量x和y保存在文件var2.mat中。 \\&gt;&gt;load var2 在 save 和 load 命令中，文件名、变量名可以用字符串来表示，这时将 save 和 load 看作函数来调用：（推荐使用这种形式） \\&gt;&gt;save( 'var2', 'x', 'y' ); % 功能与 save var2 x y ; 相同。 \\&gt;&gt;s = 'var2'; \\&gt;&gt;load( s ) % 功能与 load var2 相同。20. MATLAB的帮助函数： help help+函数名 或 help+函数类名 精确查询 helpwin 打开帮助窗口 helpwin+函数名 精确查询 helpdesk 打开帮助窗口 doc 打开帮助窗口 doc+函数名 打开帮助窗口， 精确查询 lookfor+关键字 matlab中的谷歌，模糊查询21. 函数式M文件的文件名，在MATLAB主窗口下不区分大小写， 函数式M文件中，变量都是局部变量 脚本式M文件中，变量都是全局变量22. MATLAB搜索路径 MATLAB通过搜索路径来查找M文件。因此，MATLAB的系统文件、Toolboxes工具箱函数、用户自己编写的M文件等都应该保存在搜索路径中。当用户输入一个标识符（例如Value）时，MATLAB按下列步骤处理： （1）检查 Value 是否为变量 （2）检查 Value 是否为内部函数 （3）在当前的工作目录下是否存在 Value.m 文件 （4）在MATLAB搜索路径中是否存在 Value.m 文件 如果在搜索路径中存在多个 Value.m 文件，则只执行第一个 Value.m 文件；如果找不到这一文件，则报错。23. eps —— 在MATLAB编程中，对于除法运算，为了避免分母为零的情况出现，将分母的数与eps相加。（直接在命令窗口输入eps，再回车，会返回eps的值——2.2204e-16）。准确讲，eps表示数1.0到与它相邻的最大的双精度浮点数。简单记，就是代表一个特别小的数。","link":"/2020/08/07/Code%20tools/Matlab/Matlab%E7%AC%94%E8%AE%B0/"},{"title":"Pycharm笔记","text":"足够的搜索能力和优秀英文阅读能力才是驾驭一个优秀的IED的不二法宝。 虚拟空间血的教训 不要随便改项目文件的路径，不然可能导致项目的terminal无法使用正确的解释器 升级包的两种方法：命令升级；Setting中的点击特定package并在新页面中选定特定版本Install即可。 其他工具Terminal 可以在setting的tools里调整Terminal的解释器。 Terminal检查解释器和激活虚拟空间 1234567在Terminal中进入文件，并激活cd ./venv/Scriptsactivate检查：创建文件test，内容如下import pip;print(pip.__file__)运行后查看路径是否在虚拟环境即可判断 Pycharm快捷键作者：意气相许的许 PyCharm3.0默认快捷键 1、编辑（Editing） Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Shift + F1 外部文档 Ctrl + 鼠标 简介 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 全局查找 Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Alt + Up/Down跳转到上一个、下一个方法 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(’)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(’)快速切换当前计划 Ctrl + Alt + S 打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换 一些常用设置： pycharm默认是自动保存的，习惯自己按ctrl + s 的可以进行如下设置： .file -&gt; Setting -&gt; General -&gt; Synchronization -&gt; Save files on frame deactivation 和 Save files automatically if application is idle for .. sec 的勾去掉 file -&gt;Setting -&gt; Editor -&gt; Editor Tabs -&gt; Mark modified tabs with asterisk 打上勾 Alt + Enter: 自动添加包 对于常用的快捷键，可以设置为visual studio(eclipse…)一样的： file -&gt; Setting -&gt; Keymap -&gt; Keymaps -&gt; vuisual studio -&gt; Apply Pycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在file -&gt; Setting -&gt;Editor-〉Mouse中设置 要设置Pycharm的字体，要先在file -&gt; Setting -&gt;Editor-〉Editor中选择一种风格并保存，然后才可以改变 在setting中搜索theme可以改变主题，所有配色统一改变","link":"/2020/08/07/Code%20tools/Pycharm/Pycharm/"},{"title":"Vscode笔记","text":"VS Code 使用笔记优秀插件Code Runne集成大多数语言的运行命令，一键运行。 在Setting的extension中可以设置Run Code Configuration的Run in Terminal为True，可以方便在终端中输入输出程序","link":"/2020/08/07/Code%20tools/VScode/Vscode%E7%AC%94%E8%AE%B0/"},{"title":"WSL杀死进程","text":"WLS2的Ubuntu18.04下没有办法直接使用kill -s 9 PID杀死进程，可是神奇的用kill -9 PID代替。","link":"/2020/08/07/Code%20tools/Windows/WSL%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B/"},{"title":"win10基本技巧","text":"WIN10基本技巧运行指令cmd 运行cmd Terminal services.msc 打开服务窗口（也可以通过任务管理器的服务页打开，或者计算机管理的 “服务和应用程序/服务”打开）。 shell:startup打开开机自启动软件的文件夹。 msinfo32显示系统详细信息 CMD指令TreeTREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。（带扩展名） /A 使用 ASCII 字符，而不使用扩展字符。 12345678910111213141516171819202122tree -f &gt; list.txt -- 将带扩展名的文件目录输出到list.txt文件中卷 资料 的文件夹 PATH 列表卷序列号为 70BA-EEC3H:.│ README.md│ README.txt│ ├─grangerData│ ├─Airdata1│ │ 1226A_filled.csv│ │ 1239A_filled.csv│ │ 1241A_filled.csv│ │ 1243A_filled.csv│ │ 1247A_filled.csv│ │ 1260A_filled.csv│ │ │ ├─matched│ │ 1226A_58457_filled.csv│ │ 1239A_58569_filled.csv│ │ 1241A_58239_filled.csv│ │ 1243A_58752_filled.csv│ Ver显示系统版本信息。 其他进入安全模式在锁屏界面点击电源，按下shift键，再点击重启。在弹出的蓝色界面中依次选择“疑难解惑”-“高级方案”-“重启”-“安全模式”（有点记不清了）","link":"/2020/08/07/Code%20tools/Windows/win10%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/"},{"title":"window工作环境","text":"都知道Window的PATH和工具包管理的缺乏是公认的难用，不巧的是Linux的系统不是那么让我喜爱，尤其很多软件在Linux兼容性不好。如今WLS的推出了让我们可以在Window下直接体验近乎原生linux的畅爽体验，(虽然说虚拟机+linux+局域网连接好像也行，就是太费资源了)。 盘一盘我的Window下安装工具和配置方式： Fluent-Terminal 工具美化原生的WSL终端和PS界面 配色方案超级多 方便调节字体、透明度、支持快捷键、标签式管理页面啧啧啧~ VSCode：刚刚入坑，听说了宇宙第一编辑器的大名久已 官方入门 可配合WSL本地远程编程， 可参考Dev in WSL VS在WSL进行开发调试 WSL：不论是WSL1，还是WSL2功能都非常的强大，诶忍不住的香 可参考Dev in WSL","link":"/2020/08/07/Code%20tools/Windows/window%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"},{"title":"wls2折腾笔记","text":"推荐阅读官方博客 其中对WSL2介绍。基于 Hyper-V 结构，WSL2大幅改进了上一代WSL在系统层面的的I/O效率，增加了系统调用的全面性，甚至还能支持Docker,唯一遗憾的是网关上做了隔离（？）。 命令安装官网博客的配置后，应该已经能够使用WLS2了。快速摘录几条命令。更改Linux distro的WLS的运行版本： 12wsl --set-version &lt;Distro&gt; 2 #设置为启动WSL2wsl --set-version &lt;Distro&gt; 1 #设置为启动WSL1 设置默认安装distr的WSL2版本： 1wsl --set-default-version 2 检查各个distr的WSL版本： 1wsl --list --verbose #or wsl -l -v 网络连接问题Linux连PC（In the initial builds of WSL2 preview）从Linux访问Windows中软件需要Linux连接主机的host ip。 获取主机LAN IP方法如下： 1cat /etc/resolv.comf 之后就可以使用该IP地址连接到PC的服务器上了。 PC连Linux在高于18945版本的WIN10系统可以直接访问Localhost来访问Linux Dis的服务器。对应的低于此版本的WIN10需要获取Linux虚拟机的IP地址。即可由以下命令获取： 1ip addr | grep eth0","link":"/2020/08/07/Code%20tools/Windows/wls2%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"title":"C++STL笔记","text":"本篇文章中所指的区间，若无特殊说明，就是指半闭半开区间。 vector 定义 12345678910#include&lt;vector&gt;// 一维vector&lt; typename &gt; v1;// 二维vector&lt; vector&lt; typename&gt; &gt; v2;vector&lt; typename&gt; v3[arraySize];// vector&lt;int&gt;(n, 2)动态生成了一个长度为n，每个元素为2的vector对象vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 2)); 访问 123456789//下标v1.[i];//迭代器vector&lt; typename &gt;::iterator it = v1.begin();for(it; it &lt; v1.end(); it++) // 迭代器实现了加法 和 自加 printf(&quot;%d&quot;, *(it));for(int i = 0; i &lt; v1.size(); i++) printf(&quot;%d&quot;, *(it + i)); 常用函数 123456789101112131415161718//添加元素v1.push_back(2);//删除末尾元素v1.pop_back();// 个数v1.size(); // return a unsigned value.//清空v1.clear();//插入元素v1.insert(it, x); //在it处插入一个元素x, O(n)// 删除v1.earse(it); // 删除一个在it的元素v1.earse(v1.begin(), v1.end() ); // 删除一个[beign(), end())范围内的区间所有元素 set集合，一个内部自动按升序排序且不含重复元素的容器。 定义 123#include&lt;set&gt;set&lt;typename&gt; s1;set&lt;typename&gt; s2[arraySize]; 访问 1c++ //set只能使用迭代器访问 set&lt; typename&gt;::iterator it = s1.begin(); for.... 常用函数 1234567891011121314151617181920212223242526272829//插入元素x，并自动排序，去重 O(logN)s1.insert(x);//查找value对应的迭代器 O(logN)s1.find(value);// 个数s1.size();//清空s1.clear();//删除s1.earse(it); //删除一个it对应的元素s1.earse(value); //删除一个元素values1.earse(s1.begin(), s1.end()); // 删除一个[beign(), end())范围内的区间所有元素​```c++## string**定义**​```c++#include&lt;string&gt;string str;string str = &quot;hello world&quot;; 访问 123456//下标str[i];// 迭代器string::iterator it = str.begin();*(it); 输出输入 1234567//标准cin &gt;&gt; str;cout &lt;&lt; str;//转为为cstrprintf(&quot;%s&quot;, str.c_str()); 常用操作 12345678// += 自加str += str;// + 加法str2 = str + str;// compare operator 按字典序比较，比如 ==, !=, &lt;, &gt;,&lt;=等str == str2; 常用函数 123456789101112131415161718192021222324252627282930// 个数str.size();str.length();//插入 O(N)str.insert(pos, string);str.insert(itPos, itInsertBegin, itInsertEnd); //在itPos中插入一个区间上的字符串// 删除str.erase(it); //删除单个元素str.erase(itFirst, itEnd); //删除区间元素str.erase(pos, length); //删除长度为length从pos开始的字符子串// 清除str.clear();//子串str.substr(pos, len); //返回长度为length从pos开始的字符子串//常数string::npos == -1 ;// 为unsigned_int类型，可大概4e9大小或者说-1//查找 find 返回子串的第一处出现的位置，或者返回npos（没有这个子串）str.find(str1);str.find(str1, pos);// 从pos处开始查找资源//替换str.replace(pos, len, str2); //把从pos开始的长为len的str子串替换为str2str.replace(it1, it2, str2); //把[it1, it2)区间上的子串替换为str2 map定义 12#include&lt;map&gt;map&lt;typename, typename&gt; mp; //map不可使用char数组作为键或者值； 访问 1234567891011121314//下标访问mp['c'] = 2 // 访问并赋值//迭代器map&lt;char, int&gt;::iterator it = mp.begin();for(it; it &lt; mp.end(); it++) printf(&quot;%c %d\\n&quot;, it-&gt;first, it-&gt;second); // 使用迭代器访问键和值​```c++**查找**​```c++map&lt;char, int&gt;::iterator it = mp.find(key); //返回 键为key 的元素的迭代器 删除 123mp.erase(it); //删除迭代器指向里的映射 O(1)mp.erase(key); //删除键对应的映射mp.erase(mp.begin(), mp.end()) //删除迭代器指向的区间上元素 常用函数 123451// 个数mp.size();// 清除mp.clear(); 更多的类型有unoderde_map和multimap。 queue定义 12#include&lt;queue&gt;queue&lt;typename&gt; que; 访问 123//只能访问队尾和队首que.back();que.front(); 常用函数 1234567891011//向队尾插入元素que.push();//删除队首元素，无返回队首元素que.pop();//判空que.empty(); // 判断que是否为空// 个数que.size(); priority_queue底层由堆实现。 定义 12#include&lt;queue&gt;priority_queue&lt;typename&gt; pq; 常用函数 1234567891011121314//插入元素pq.push(value); // O(logN)//获取队首元素pq.top(); //若队空，则会导致报错//队首出队pq.pop();//判空pq.empty();//个数pq.size(); 优先级设置 12345678910111213141516171819202122232425262728//一般数据结构priority_queue&lt;int&gt; pq; //默认优先级大的在顶部（数字大）priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; pq; // 数字逐步减少，优先级大的在顶部priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; // 数字逐步增加，优先级小的在顶部//结构体 设置1struct str{ string name; int price; //友元函数重载&quot;&lt;&quot;符号，函数判断了两个str的优先级，name字典序大的的优先级高 // 即name字典序高的排前面 // 同理可以设置 return s1.name &gt; s2.name; 达到字典序小的优先级高的效果 frind bool operator &lt; (str s1, str s2){ return s1.name &lt; s2.name; }}//结构体 设置2struct str{ string name; int price;}// 效果类似，不过还是移出来struct cmp{ bool operator () (str s1, str s2){ return s1.name &lt; s2.name; }} 为了提高效率和速度，可以在函数传参的时，添加const和&amp;符号 123456friend bool operator &lt; (const fruit &amp;f1, const fruit &amp;f2){ return f1.price &lt; f2.price;}friend bool operator () (const fruit &amp;f1, const fruit &amp;f2){ return f1.price &lt; f2.price;} stack定义 12#include&lt;stack&gt;stack&lt; typename &gt; name; 访问 1st.top(); //只能访问顶部数据 常用函数 1234567891011//入栈st.push();//弹出st.pop();//空st.empty();//个数st.size(); pair定义 123456789#include&lt;utility&gt;pari&lt;typename1, typename2&gt; name;//初始化pair&lt;string, int&gt; p(&quot;nihe&quot;, 5);//临时使用p = pair&lt;string,int&gt;(&quot;haha&quot;, 5);p = make_pair(&quot;haha&quot;, 5); 访问 123//结构体方式p.first; //访问第一个元素p.second;//访问第二个元素 比较 12//先判断pair的first元素，在判断second元素。p1 &lt; p1 //等等 常见用法 12345//构造二元结构体, 减少时间p = make_pair(&quot;niha&quot;, 34);//作为map的键值插入mp.insert(p); algorithmsreverse(itBegin, itEnd) 翻转容器中从[itBegin,itEnd)[itBegin,itEnd)的元素。 swap(x,y)交换元素 next_permutation(BidirectionalIterator itBegin, BidirectionalIterator itEnd) 把[itBegin,itEnd)[itBegin,itEnd)的元素排列为下一个排列。(指向数组的指针应该也行，了解不深) fill(ForwardIterator itBegin, ForwardIterator itEnd, const T&amp; val) 逐个遍历 并赋值[itBegin,itEnd)[itBegin,itEnd)的元素 12345sort(itBegin, itEnd[, cmp])//cmp例程， 数据从小到大排序；结构体同理bool cmp(int a, int b){ return a &lt; b; } lower_bound(itFirst, itEnd, val) 返回在有序容器中的第一个大于等于val的元素的位置（迭代器或者指针）。 upper_bound(itFisrt, itEnd, val)返回有序容器中第一个大于val的元素的位置（迭代器或者指针）。 获取下标： 123//至少对于数组指针来说pos = upper_bound(it1, it2, 3);index = pos - a' //减去数组首地址可得下标 #STL","link":"/2020/08/07/Language/C++/C--STL%E7%AC%94%E8%AE%B0/"},{"title":"C&#x2F;C++笔记","text":"基础变量范围 image-20200507125512740 宏定义替换 1234567//定义常量#define 标识量 常量//定义语句#define ADD(a,b) ((a) + (b))const double eps = 1e-8;#define Equ(a,b) ((fabs((a) - (b))) &lt; (eps)) //fabs 对double取绝对值 , included math.h 类型别名 12//如typedef long long LL 常量 1const 数据类型 变量名 = 常量 位运算 123456&lt;&lt; //左移&gt;&gt; //右移&amp; //位与| //位或^ //位异或~ //位取反 如~a 动态申请 1234567891011121314151617//C malloc//一个intint *p = (int*)malloc(sizeof(int));//一维intint *p = (int*)malloc(1000 * sizeof(int));//C free 释放内存变量free(p);//c++ new//一个int *p = new int;//一维int *p = new int[10000];//C++ delete delete(p); 输入输出(C)对double的输入格式为%lf,输出格式为%f。 %d、%s等输入格式都会自动把空格、换行当成结束判断标志的，同时不把空格当做输入量，而%c会“吸收”掉空格。 1234scanf(&quot;%d%c%s&quot;, &amp;b, &amp;c, a);printf(&quot;b=%d,c=%c,s=%s, \\n&quot;, b, c, a);//I：123 A hello//O:b=123,c= ,s=A, 输出格式 %md 空格补齐不足m位数字的高位 %0md 0补齐不足m位数字的高位 %.mf 保留m位数字的浮点数 字符串 只有gets和%s会自动添加\\0（空字符NULL，ASCII码为0），同样的puts和%s通过识别\\0来输出字符串。所以需要在非上述两个字符串输入函数得到的字符串后面加上\\0。 其他常用函数 getchar、putchar输入输出单个字符。 gets（好像不太安全，不推荐使用），puts输出字符串 + 换行符。 sscanf(str, &quot;%d&quot;, &amp;n)将数据从字符串str中输入 。sprintf(str, &quot;%d&quot;, n)将数据从字符串str中输出 。 多组输入 1234while( scanf(&quot;%d&quot;, &amp;n) != EOF){ if( condition == True) break;}while( T--) 输入输出（C++）12cin&gt;&gt;b&gt;&gt;d`cout&lt;&lt;b&lt;&lt;d 控制double精度可用#include&lt;iomanip&gt;， 1cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; 123.45456 &lt;&lt; endl; cin.getline(str, 100) 读入整行字符串到str[100]中。 总结一下 输入一行 Char a[] String a cin.getline(a,10000） 10000表输入限制1000个字符以内 getline(cin,a) 输入一个字符 Char a cin.get(a,10000) getchar() Array定义 1234567891011// 静态定义// 一维int a[10] = {1, 2, 3 ,4 }// 数字不足用零补充char str[20] = { 'a', 'b', 'c'};char str[20] = 'abc';// 二维int a[5][6] = {{1, 3, 4, 5, 6}, {5, 6}, {}, {2, 3, 5 }};/*C++函数（包括主函数）定义的变量都是定义在系统栈中，容易溢出。定义为全局变量可以放到静态存储区中。*/ 初始化 12345// 按字节赋值， value最好只使用0，或者-1（0xFFFFFFFF）memset( Array, value, sizeof(Array));//fillvector&lt;int&gt; arr;fill(arr.begin(), arr.end(), value) // C++风格的fill 传参 12345//传址引用// 一维int f(int a[]) {} //一维无需数组大小// 二维int f(int a[][5]) {} //二维需要第二纬度大小 字符数组（C风格）常用函数 1strlen(s) strcmp(s1,s2) 按字典序比较，两个字符串相等返回0，前者大于后者返回正整数，否则返回负整数。 strcpy(s1, s2) 把s2复制给s1 strcat(s1, s2)把s2拼接到s1后面 指针基础 1234567891011121314151617//定义和初始化int *p1, *p2; // 注意变量名是p1, p2,而非*p1,*p2; int作为int*的基类型，p1无法指向int以外的类型元素int a, *p3 = &amp;a;//引用int c = *p1;// 运算p1++ // p1自增，自动指向下一个int元素p1 + i // p1指向下面i个元素p3 - p1 // 得到的是p3和p1之间的int为单位的距离，但是p3和p1的本身的值是以Byte为计量的 //数组int a[5] = {};a + i //a表示指向a数组首地址&amp;a[2] // 表示指向数组a的第3个元素的地址 C指针的一个优美的写法，常常在函数中面对不从零开始的数组需要加上一个增量数字，但是可以通过&amp;A[add + i]来获取A[add+i]的地址并传参，就好像传进去了一个从新开始的数组。 1merge(&amp;A[l], i, i + step - 1, i + step, min(i + 2 * step - 1, n - 1)); 引用（C++）引用变量相当于给变量增加了一个别名，对引用变量的操作就是对原变量的操作。 注意常量无法使用引用 12int f(int &amp;c)//引用int f(int* &amp;c)//指针引用 结构体1234567891011//定义struct Name{ int a, b, c; Name(){} //构造函数1 Name(int _a, int _b, int _c):a(_a), b(_b), c(_c) {} //构造函数1}instance1, instanceN[N], *p; //声明变量instance和instance数组以及 Name类型的指针。//访问instance.a // 实例(*p).a //指针p-&gt;a // 指针 sort排序sort包括在algorithm.h包中 12345678910//法1struct Stu{ int score, no;};//先按score升序排序，再按no升序排序。bool cmp(Stu a, Stu b){ if(a.score == b.score) return a.no &lt; b.no; return a.screo &lt; b.score;} 运算符优先级 优先级 运算符 描述 结合性 1 :: 作用域解析 从左到右 2 a++ a-- 后缀自增与自减 *type*() *type*{} 函数风格转型 a() 函数调用 a[] 下标 . -&gt; 成员访问 3 ++a --a 前缀自增与自减 从右到左 +a -a 一元加与减 ! ~ 逻辑非和逐位非 (*type*) C 风格转型 *a 间接（解引用） &amp;a 取址 sizeof 取大小[注 1] co_await await 表达式 (C++20) new new[] 动态内存分配 delete delete[] 动态内存分配 4 .* -&gt;* 成员指针 从左到右 5 a*b a/b a%b 乘法、除法与余数 6 a+b a-b 加法与减法 7 &lt;&lt; &gt;&gt; 逐位左移与右移 8 &lt;=&gt; 三路比较运算符(C++20 起) 9 &lt; &lt;= 分别为 &lt; 与 ≤ 的关系运算符 &gt; &gt;= 分别为 &gt; 与 ≥ 的关系运算符 10 == != 分别为 = 与 ≠ 的关系运算符 11 a&amp;b 逐位与 12 ^ 逐位异或（互斥或） 13 ` ` 逐位或（可兼或） 14 &amp;&amp; 逻辑与 15 ` ` 16 a?b:c 三元条件[注 2] 从右到左 throw throw 运算符 co_yield yield 表达式 (C++20) = 直接赋值（C++ 类默认提供） += -= 以和及差复合赋值 *= /= %= 以积、商及余数复合赋值 &lt;&lt;= &gt;&gt;= 以逐位左移及右移复合赋值 &amp;= ^= ` =` 以逐位与、异或及或复合赋值 17 , 逗号 从左到右 注意&amp;的优先级比==小。","link":"/2020/08/07/Language/C++/C-C-%E7%AC%94%E8%AE%B0/"},{"title":"C++指针问题","text":"a、&amp;a与 &amp;a+11.正确解C语言指针中的 &amp;a+1，假设a为一个数组 123int a[5]={1,2,3,4,5};int p=(int)(&amp;a+1); printf(&quot;%d&quot;,*(p-1)); 答案为什么是5？这个问题的关键是理解 &amp;a。a是一个数组名，也就是数组的首地址。对a进行取地址运算符，得到的是一个指向数组的指针！！！！这句话尤为重要！也就相当于int (*p) [5] = &amp;a; p 是一个指向数组的指针，它指向的是一个包含 5 个 int 元素的数组！！ 那么执行 &amp;a+1 后，p 移动了一个数组的距离，p 的偏移量相当于 p + sizeof(int) * 5，指向 a 数组最后一个元素的后一位 ！！ 而程序中强制将指针p转换成一个int*，那么 p -1 其实就是 p - sizeof(int)所以，p -1 指向了数组中的最后一个元素，也就是 5 以下输出分别是多少？ 12345678#include &lt;stdio.h&gt;int main(){ int a[5] = {1,2,3,4,5}; int *ptr = (int *)( &amp;a + 1); printf(&quot;%d, %d, \\n&quot;, *(a+1), *(ptr-1) ); return 0;} 答案：2, 5解释： a 为大小为5的数组，a表示数组的首地址，&amp;a表示数组a的地址，&amp;a+1表示移动了一个a数组的大小的距离，ptr + sizeof(int) * 5, 因此 ptr是一个指向a的最后一个元素的后一位的指针（ptr跨过了a的所有元素）。因此， （1）(a+1) 表示 a 的首地址之后的一个元素，即 a[1]=2; C 语言和 Python都是 0-index;（2）(ptr-1) 表示指针 ptr 移动了一位，ptr - sizeof(int), 因此指向a的最后一个元素a[4]=5;（3）因此输出为2和5。 这里的关键在于区分 a + 1 和 &amp;a + 1中移动的“1”是不同的，前者只移动 sizeof(int)，后者移动sizeof(int) * sizeof(a)。 数组名 a 的特殊之处：&amp;a ： 代指 数组的整体 的地址，这里的 a是数组整体a： 代指 数组的第一个成员，这里的 a是数组首地址 3.已知语句 int a=6, 则执行了语句 a+=a-=a\\*a 后，变量a 的值为多少？解：只有C语言才会有可读性这么神奇的表述。程序是从右到左执行的，a的初始值为6：（1）第一步：a=a-a*a=6-6*6=-30，此时 a=-30；（2）第二步：a=a+（a-a*a)=(-30)+(-30)=-60，此时 a=-60。 注意：在开发过程中，写这种语句的程序员是要被枪击的（手动滑稽）~ **, a Pointer to PointerThe double asterisk \\ define what is known as a Pointer to Pointer. This is a simple concept, a pointer is an independent entity. It can point to anything i.e it can point to a variable or it can point to a pointer which in-turn points to something else. This concept is not limited to only a “POINTER TO POINTER”.You can have a chain of pointers.In the following case ” x ” is a variable having value 23, “ y ” contains the address of ” x ” , and “ z ” contains the address of “ y “. 123456789int x = 23;int *y;int **z;y = &amp;x;z = &amp;y;std::cout&lt;&lt;x&lt;&lt;endl; //23std::cout&lt;&lt;*y&lt;&lt;endl; //23std::cout&lt;&lt;**z&lt;&lt;endl; //23 The *****(asterisk) is called a de-referencing operator to access the value the pointer points to. You can check out more atC++ Pointer to Pointer (Multiple Indirection) Thanks :-)","link":"/2020/08/07/Language/C++/C-%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/"},{"title":"Go笔记","text":"go学习 在一个悲伤的日子打开一个特殊语言的入门学习之路。 Go is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multicore and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It’s a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language. 安装去该页面寻找安装包入口，安装后把路径加入环境变量。 1export PATH=$PATH:/usr/local/go/bin tour1234567891011package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { fmt.Println(&quot;Welcome to the playground!&quot;) fmt.Println(&quot;The time is&quot;, time.Now())} 导入包有两种方式，一是： 1234import ( &quot;fmt&quot; &quot;math/rand&quot;) 抑或： 12import &quot;fmt&quot;import &quot;math&quot; Exported namesgo中包中Capital Word开头的变量都是Exported names，Exported names顾名思义就是可以被暴露给调用者的。应对的Unexported names都是对于调用包的都是unaccessible。 12345678910package main/import ( &quot;fmt&quot; &quot;math/rand&quot;)func main() { fmt.Println(&quot;My favorite number is&quot;, rand.Intn(10))}","link":"/2020/08/07/Language/Go/Go%E7%AC%94%E8%AE%B0/"},{"title":"安装java","text":"Install Oracle Java in WSL Oracle Java至此已经发布到了14.01版本，已知的安装方法有两种。一种直接下载JKD，另一种采用包管理工具来管理JAVA的安装和升级。但是由于版权问题，后者对JAVA的版本支持只能到10。 直接下载JKD可以直接去官网，下载对应版本的JDK。需要注册Oracle账号，值得注意的是，我在初次注册的时候发现原有密码必须改变一次才能登陆。 黑人问号？.jpg 下载对应版本后解压到/opt文件夹下，并把JKD文件下的bin文件路径加入PATH。 12tar -xzvf JKDFILE.tar.gz -C /optexport PATH=/opt/JKDFILE/bin:$PATH 测试运行，结果正确即可。 12java --versionjavac --verison 包管理方法具体操作参考博文。 OpenJava其实也可以直接下载开源的JAVA版本。","link":"/2020/08/07/Language/Java/%E5%AE%89%E8%A3%85java/"},{"title":"Numpy笔记","text":"基础概念axis常常用于指定函数的计算方式，如sum(x,axis=0)会得到一个row array,而不是按行计算的column array。 image-20200503125336529 乘法首先 矩阵乘法 符号 说明 Np matmul . 矩阵乘法 np.dot(M1,M2) Hadamard product ⊙⊙ element-wise乘法，逐元素对应相乘 np.multiply(M1,M2)或者M1*M2 Kronecker product ⊗⊗ 任意形状矩阵相乘 ? 不太明朗的第三个乘法举例： image-20200503125443492 向量乘法 符号 说明 Np Inner Product,dot product .. 运算结果为标量(A scalar) np.dot(L1,L2) outer product ⊗⊗ 结果是矩阵 np.outer(a1,a2)或者 cross product ×× 结果是向量 ? 上两表中‘Li’表示列表，‘Mi’表示矩阵，‘Ai’表示向量Array 上表中 np.multiple以及np.outer都可以接受矩阵（nArray）、向量（nArray)以及列表（LIST），唯有np.dot在接受nArray是表现为矩阵乘法，在接受LIST表现为向量内积。 dot product，即点积或者内积。 image-20200503125432138 点乘的几何意义：点乘可以用来计算两个向量的夹角 image-20200503125425021 Outer production或``，即外积，在线性代数中一般指两个向量的张量积，结果为一个矩阵。可调用np.outer(x1,x2)。例子如下： image-20200503125416187 向量叉积(Cross product)：叉乘的结果是一个向量，使用符号 [ [公式] ，举例 image-20200503125406301 索引对于一个多维Array,使用单一的数组索引会产生一定意义上的语义模糊。如果索引单个元素，就要写上所有维度的索引。比如 12c = np.zeors((1,3))print(c[0,1]) #两个维度 常用函数1np.exp() np.square() return the element-wise square of the input. 1np.sum(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;) axis : None or int or tuple of ints, optional Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis. If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before. 1234np.random.randn(a,n）`(‘np.’以下全省略）`.array(LIST)` 新建一个numpy array。`.exp().reshape()` 类似`array.reshape .dot(X1,X2) 矩阵乘法 .zeros(shape, dtype=float, order='C') Return a new array of given shape and type, filled with zeros. shape: int or tuple of ints Shape of the new array, e.g., (2, 3) or 2 .squeeze() Remove single-dimensional（单维度条目，即shape=1的条目） entries from the shape of an array. image-20200212162003524 .divide(x1,x2） returna true division of the input, elelment-wise. .copy(a, order='K') Return an array copy of the given object.(真复制) .linspace(start,stop,num=50) Return evenly spaced numbers over a specified interval. num 表示产生的列表的数字个数。 np.random.shuffle(x), 把x本身shuffle一下，注意不返回值。 1.savetxt('new.csv', my_matrix, delimiter = ',') 将数组或者矩阵存储为csv文件 Array用法Array.reshap()（以下省略array） 1.reshape() .shape[i] 访问shape元祖中的第i个数。 新建np.array(list/tuple) 1np.ndarray() shape：数组的形状。 dtype：数据类型。 buffer：对象暴露缓冲区接口。 offset：数组数据的偏移量。 strides：数据步长。 order：{'C'，'F'}，以行或列为主排列顺序。 初始化可以使用array对list，或者DF进行初始化。 稍稍注意一下， python中的(3)是一个INT对象，而（3，）是一个tuple对象 In [12]: 12print(a.shape)(1, 3) In [13]: 123a = np.array([1, 2, 3])print(a.shape)(3,) In [17]: 1234a = np.array([[1], [2], [3]])print(a.shape)(3, 1) In [19]: 123a = np.array([1,2,3], ndmin = 2)print(a.shape)(1, 3) In [22]: 123a = np.array([1, 2, 3], ndmin = 1)print(a.shape)(3,) 库np.linalglinalg = linear + algebra np.linalg.inv() 矩阵求逆np.linalg.det()矩阵求行列式（标量 np.linalg.norm 求范数； norm(x, ord=None, axis=None, keepdims=False) ord表示范数种类 axis: If axis is an integer, it specifies the axis of *x* along which to compute the vector norms. keepdims: If this is set to True, the axes which are normed over are left in the result as dimensions with size one.(好像是保留大小为1的维度) Note: 标准化可使用norm，xnormalized=x∥xnorm∥xnormalized=x‖xnorm‖ np.randomnumpy.random.normal(loc=0.0, scale=1.0, size=None) Draw random samples from a normal (Gaussian) distribution. loc : the meanof the distribution. scale Standard deviation (width) of the distribution. size a int or tuple of ints, optional. If size is none, single value is returned if loc and scale are both scalars. (也就说 loc 和 scale 支持 array-like 参数) numpy的优点在numpy中矩阵、向量和数值都是numpy array, 不管他是啥。 numpy可以轻松的进行numpy array和数值之间的+-*/甚至np.exp()的高级运算，而list不行。 其他： np.dot(X1, X2)为矩阵乘法 np.sum（x1, axis）为求和, axis = 0 为竖直方向求和，axis=1为水平方向，默认竖直方向 X1.T表示X1的转置 c = np.dot(a,b) #dot是矩阵乘法 *是element-wise product 有用的操作nArray中的True/Flase转化为1/0. 1234C = [0.5, 0.6, 0.1]c = np.array(C) &gt; 0.5print(c)print(c + 0) 数据筛选Df.fillna(value, inplace) 把NaN数据替换成value。 Na[~np.isnan(Na)] 可以通过判判断条件选择数据 [x+1 for x in list if x &lt; 5] list可以以列表表达式来生成新列。 增加数据维度numpy中包含的newaxis可以给原数组增加一个维度 np.newaxis放的位置不同，产生的新数组也不同 一维数组 12345678910111213141516171819x = np.random.randint(1, 8, size=5)xOut[48]: array([4, 6, 6, 6, 5])x1 = x[np.newaxis, :]x1Out[50]: array([[4, 6, 6, 6, 5]])x2 = x[:, np.newaxis]x2Out[52]: array([[4], [6], [6], [6], [5]])","link":"/2020/08/07/Language/Python/Numpy%E7%AC%94%E8%AE%B0/"},{"title":"PIL笔记","text":"Python Image Library别名Pillow 教程参见：翻译版 基础概念Image 类PIL最重要的类是 Image class, 你可以通过多种方法创建这个类的实例；你可以从文件加载图像，或者处理其他图像, 或者从 scratch 创建。 要从文件加载图像，使用 open() 函数， 在 Image 模块: 12&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; im = Image.open(&quot;lena.ppm&quot;) 加载成功将返回一个 Image 对象。 你现在可以使用示例属性检查文件内容: 123&gt;&gt;&gt; from __future__ import print_function&gt;&gt;&gt; print(im.format, im.size, im.mode)PPM (512, 512) RGB format 这个属性标识了图像来源。如果图像不是从文件读取它的值就是None。size属性是一个二元tuple，包含width和height（宽度和高度，单位都是px）。 mode 属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes 有 “L” (luminance) 表示灰度图像, “RGB” 表示真彩色图像, and “CMYK” 表示出版图像。 如果文件打开错误，返回 IOError 错误。 只要你有了 Image 类的实例，你就可以通过类的方法处理图像。比如，下列方法可以显示图像: 1&gt;&gt;&gt; im.show() 读写图像PIL 模块支持大量图片格式。使用在 Image 模块的 open() 函数从磁盘读取文件。你不需要知道文件格式就能打开它，这个库能够根据文件内容自动确定文件格式。 要保存文件，使用 Image 类的 save() 方法。保存文件的时候文件名变得重要了。除非你指定格式，否则这个库将会以文件名的扩展名作为格式保存。 转换文件格式到JPEG123456789101112from __future__ import print_functionimport os, sysfrom PIL import Imagefor infile in sys.argv[1:]: f, e = os.path.splitext(infile) outfile = f + &quot;.jpg&quot; if infile != outfile: try: Image.open(infile).save(outfile) except IOError: print(&quot;cannot convert&quot;, infile) save() 方法的第二个参数可以指定文件格式，如果你使用非标准的扩展名你必须这样做： 创建 JPEG 缩略图123456789101112131415from __future__ import print_functionimport os, sysfrom PIL import Imagesize = (128, 128)for infile in sys.argv[1:]: outfile = os.path.splitext(infile)[0] + &quot;.thumbnail&quot; if infile != outfile: try: im = Image.open(infile) im.thumbnail(size) im.save(outfile, &quot;JPEG&quot;) except IOError: print(&quot;cannot create thumbnail for&quot;, infile) 很重要的一点是这个库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图片大小和压缩方式无关。下面是一个简单的脚本用来快速验证大量图片。 验证图像文件12345678910from __future__ import print_functionimport sysfrom PIL import Imagefor infile in sys.argv[1:]: try: with Image.open(infile) as im: print(infile, im.format, &quot;%dx%d&quot; % im.size, im.mode) except IOError: pass 剪切，粘贴，合并图像Image 类包含的方法允许你操作图像部分选区。使用:py:meth:~PIL.Image.Image.crop 方法获取图像的一个子矩形选区。 从图像中复制出一个矩形选区12box = (100, 100, 400, 400)region = im.crop(box) 矩形选区有一个4元元组定义，分别表示左、上、右、下的坐标。这个库以左上角为坐标原点，单位是px，所以上诉代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。 处理复制的矩形选区并粘贴到原图12region = region.transpose(Image.ROTATE_180)im.paste(region, box) 当你粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而你不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色（参看下面的 颜色变换 部分），下面是一个例子： Rolling an image1234567891011121314def roll(image, delta): &quot;Roll an image sideways&quot; xsize, ysize = image.size delta = delta % xsize if delta == 0: return image part1 = image.crop((0, 0, delta, ysize)) part2 = image.crop((delta, 0, xsize, ysize)) image.paste(part2, (0, 0, xsize-delta, ysize)) image.paste(part1, (xsize-delta, 0, xsize, ysize)) return image For more advanced tricks, the paste method can also take a transparency mask as an optional argument. In this mask, the value 255 indicates that the pasted image is opaque in that position (that is, the pasted image should be used as is). The value 0 means that the pasted image is completely transparent. Values in-between indicate different levels of transparency. The Python Imaging Library also allows you to work with the individual bands of an multi-band image, such as an RGB image. The split method creates a set of new images, each containing one band from the original multi-band image. The merge function takes a mode and a tuple of images, and combines them into a new image. The following sample swaps the three bands of an RGB image: 分离和合并颜色通道12r, g, b = im.split()im = Image.merge(&quot;RGB&quot;, (b, g, r)) Note that for a single-band image, split() returns the image itself. To work with individual color bands, you may want to convert the image to “RGB” first. 几何变换The PIL.Image.Image class contains methods to resize() and rotate() an image. The former takes a tuple giving the new size, the latter the angle in degrees counter-clockwise. 简单的几何变换12out = im.resize((128, 128))out = im.rotate(45) # degrees counter-clockwise To rotate the image in 90 degree steps, you can either use the rotate() method or the transpose() method. The latter can also be used to flip an image around its horizontal or vertical axis. 旋转图像12345out = im.transpose(Image.FLIP_LEFT_RIGHT)out = im.transpose(Image.FLIP_TOP_BOTTOM)out = im.transpose(Image.ROTATE_90)out = im.transpose(Image.ROTATE_180)out = im.transpose(Image.ROTATE_270) There’s no difference in performance or result between transpose(ROTATE) and corresponding rotate() operations. A more general form of image transformations can be carried out via the transform() method. 颜色变换The Python Imaging Library allows you to convert images between different pixel representations using the convert() method. 颜色模式转换1im = Image.open(&quot;lena.ppm&quot;).convert(&quot;L&quot;) The library supports transformations between each supported mode and the “L” and “RGB” modes. To convert between other modes, you may have to use an intermediate image (typically an “RGB” image). 颜色增强The Python Imaging Library provides a number of methods and modules that can be used to enhance images. 过滤器The ImageFilter module contains a number of pre-defined enhancement filters that can be used with the filter() method. 应用过滤器12from PIL import ImageFilterout = im.filter(ImageFilter.DETAIL) 点操作The point() method can be used to translate the pixel values of an image (e.g. image contrast manipulation). In most cases, a function object expecting one argument can be passed to the this method. Each pixel is processed according to that function: 应用点操作12# multiply each pixel by 1.2out = im.point(lambda i: i * 1.2) Using the above technique, you can quickly apply any simple expression to an image. You can also combine the point() and paste() methods to selectively modify an image: 处理个别bands12345678910111213141516# split the image into individual bandssource = im.split()R, G, B = 0, 1, 2# select regions where red is less than 100mask = source[R].point(lambda i: i &lt; 100 and 255)# process the green bandout = source[G].point(lambda i: i * 0.7)# paste the processed band back, but only where red was &lt; 100source[G].paste(out, None, mask)# build a new multiband imageim = Image.merge(im.mode, source) Note the syntax used to create the mask: 1imout = im.point(lambda i: expression and 255) Python only evaluates the portion of a logical expression as is necessary to determine the outcome, and returns the last value examined as the result of the expression. So if the expression above is false (0), Python does not look at the second operand, and thus returns 0. Otherwise, it returns 255. 增强For more advanced image enhancement, you can use the classes in the ImageEnhance module. Once created from an image, an enhancement object can be used to quickly try out different settings. You can adjust contrast, brightness, color balance and sharpness in this way. 增强图形1234from PIL import ImageEnhanceenh = ImageEnhance.Contrast(im)enh.enhance(1.3).show(&quot;30% more contrast&quot;)","link":"/2020/08/07/Language/Python/PIL%E7%AC%94%E8%AE%B0/"},{"title":"Python基础-函数速记和基础内容","text":"python特点 动态类型 简洁的语法（伪代码） 强大的扩展库和开源社区 解释性语言 快速开发 执行速度不如C，C++语言 值得看的部分：变量中对不可变和可变对象的讲述以及函数传递参数中对不同类型对象传递参数的处理差别。 什么是动态语言？要了解什么是动态语言，要首先了解“类型检查”。 类型检查是验证类型约束的过程，编译器或解释器通常在编译阶段或运行阶段做类型检查。 类型检查就是查看“变量”和它们的”类型”，然后判断表达式是否合理。例如，不能拿一个 string 类型变量除以浮点数变量。 如果类型检查发生在程序运行阶段（run time），那么它便是“动态类型语言”（dynamically typed languages）。常见的动态语言包括： Python JavaScrpit PHP 类型检查发生在“编译阶段”（compile time）的是“静态类型语言”（statically typed languages）。常见的静态类型语言包括： C C++ Java C# Scala 什么是强类型语言？强类型语言是指：不管是在编译阶段还是运行阶段，一旦某种类型绑定到变量后，此变量便会持有此类型，并且不能同其他类型在计算表达式时，混合使用。 例如，在交互式工具 IPython 中输入如下两行代码： 12In [1]: a = 5In [2]: a = a + 's' 程序会抛出 TypeError 异常： 1unsupported operand type(s) for +: 'int' and 'str' 意思是不支持 int 变量和 str 变量相加。 常见的强类型语言有： Python Java C# Scala 与之对应的是弱类型语言，弱类型语言容易与其他类型混合计算。弱类型语言代表 JavaScript。 支持如下操作： 12var data = 5data = data + 'xiaoming' //string 和 int 结合自动转化为 string 常见的弱类型语言有： C C++ PHP Javascript 如下，按照是否为静态/动态语言，弱类型/强类型两个维度，总结常用的语言分类。 image-20200205155429583 函数手册range(start, stop, step)从start到stop-1每step个元素的元素迭代器。 read(),readlines(),readline()文件对象提供了三个“读”方法： .read()每次读取整个文件，它通常用于将文件内容放到一个字符串变量中，但是需要考虑文件的大小。.readline()和 .readlines()非常相似。它们都在类似于以下的结构中使用 123fh = open( 'c:\\\\autoexec.bat')for line in fh.readlines(): print line.readline( .readlines()之间的差异是后者一次读取整个文件，像.read()一样。.readlines()自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for... in ...结构进行处理。另一方面，.readline()每次只读取一行，通常比 .readlines()慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用.readline()。 writeline()是输出后换行，下次写会在下一行写。.write()是输出后光标在行末不会换行，下次写会接着这行写 zip(L1, L2, L3,[...Ln]) 可以把N个输入的相同位置捆绑起来合成一个list 12345x = [1, 2, 3]y = [4, 5, 6]z = [7, 8, 9]xyz = zip(x, y, z) # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]nstr = str.join(*ostr) 所有的ostr和str合并成一个新的字符串 repr（）将任何对象转换为一对python友好的字符串 str()将任何对象转换为一对python友好的字符串 is(A,B)判断对象相等 进阶语法列表生成式生成list的三种方法： 1 12345#以下三种方式等效L = list（range(1,11)） ## 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]for x in range(1, 11): L.append(x * x)L = [x * x for x in range(1, 11)] 列表生成式扩展 123#加上if判断 [x * x for x in range(1, 11) if x % 2 == 0] [m + n for m in 'ABC' for n in 'XYZ'] 比如 1&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 深浅拷贝lst2 位于全局帧栈中，其中三个元素内存中的可视化图如下所示： 1574820784839 1sku_deep = lst2[2].copy() 注意，copy 函数，仅仅实现对内嵌对象的一层拷贝，属于 shallow copy。 此时可视化图为如下，因为拷贝 lst2[2]，所以 sku_deep 位于栈帧中指向一块新的内存空间： 1574820818329 深拷贝，英文叫 deepcopy，又有什么不同？ 请看下面例子，a 是内嵌一层 list 的列表，对其浅拷贝生成列表 ac，修改 ac 的第三个元素，也就是列表 [3,4,5] 中的第二个元素为 40： 1234a = [1,2,[3,4,5]]ac = a.copy()ac[0] = 10ac[2][1] = 40 修改后，分别测试两个值的相等性。 两个对象内存地址相同即相同 1print(a[0] == ac[0]) 返回 False，证明实现拷贝 1print(a[2][1] == ac[2][1]) 返回 True，进一步证明是浅拷贝，不是深拷贝。 如下图所示：copy 只完成了一层 copy，即 [1,2, id([3,4,5])] 复制一份，而复制后，仍然指向 [3,4,5] 所在的内存空间： img 要想实现深度拷贝，需要使用 copy 模块的 deepcopy 函数： 12345678from copy import deepcopya = [1,2,[3,4,5]]ac = deepcopy(a)ac[0] = 10ac[2][1] = 40print(a[0] == ac[0])print(a[2][1] == ac[2][1]) 打印结果，都为 False，结合下图，也能看出内嵌的 list 全部完成复制，都指向了不同的内存区域。 img 基础语法标志符在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。 Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。 Python 可以同一行显示多条语句，方法是用分号 ; 分开。 行和缩进学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。 缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。 建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 多行语句Python语句中一般以新行作为语句的结束符。 但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示 123total = item_one + \\ item_two + \\ item_three 语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例： 12days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] 引号Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。 其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。 注释python中单行注释采用 # 开头。 python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。 if-else简洁表达求列表的最后一个元素，同样列表为空时，返回 None。 12In [20]: def tail(lst): ...: return lst[-1] if len(lst) &gt; 0 else None Python空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 运算符不需要的输出值在此记录一下：parameters_values, _ = dictionary_to_vector(parameters) 中的_表示函数中的多个输出的该个位置的数据不需要了。 算术运算符以下假设变量： a=10，b=20： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 Python比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等。python3 已废弃。 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 Python赋值运算符 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a Python位运算符 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 Python逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符Python还支持成员运算符， 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 Python身份运算符（很有意思）身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 is 与 == 区别： is 用于判断两个变量引用对象是否为**同一个(同一块内存空间)**， == 用于判断引用变量的值是否相等。 值得注意的是b = a[:] #截取一个新的list属于创建了一个新的内存空间的情况. Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 Python pass 语句Python pass 是空语句，是为了保持程序结构的完整性。 pass 不做任何事情，一般用做占位语句。因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。 函数定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号**()**。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 参数传递(写的太好了) 在 python 中，类型属于对象，变量是没有类型的： a=[1,2,3] a=”Runoob” 以上代码中，**[1,2,3]** 是 List 类型，“Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。 函数注释123456789def is_rotation(s1: str, s2: str) -&gt; bool:#将参数和返回值的类型注明，增强了可读性和可维护性 if s1 is None or s2 is None: return False if len(s1) != len(s2): return False def is_substring(s1: str, s2: str) -&gt; bool: return s1 in s2 return is_substring(s1, s2 + s2) 可更改(mutable)与不可更改(immutable)对象在 python 中，strings,tuples,和 numbers 是不可更改的对象，而 list,dic等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型： 类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型： 类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 Python传不可变对象的实例 1 12345def ChangeInt( a ): a = 10b = 2ChangeInt(b)print b # 结果是 2 Python传可变对象的实例 123456def changeme( mylist ): mylist.append([1,2,3,4]) print &quot;函数内取值: &quot;, mylistmylist = [10,20,30]changeme( mylist )print &quot;函数外取值: &quot;, mylist 实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4] 参数以下是调用函数时可使用的正式参数类型： 必备参数 关键字参数 默认参数 不定长参数 必备参数必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 1def printme( str ): 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 123def printinfo( name, age ): passprintinfo( age=50, name=&quot;miki&quot; ) 默认参数调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入： 1def printinfo( name, age = 35 ): 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： 123def functionname([formal_args,] *var_args_tuple ): for var in vartuple: print var 匿名函数python 使用 lambda 来创建匿名函数。 lambda只是一个表达式，函数体比def简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 语法lambda函数的语法只包含一个语句，如下： 1234lambda [arg1 [,arg2,.....argn]]:expression#比如sum = lambda arg1, arg2: arg1 + arg2print &quot;相加后的值为 : &quot;, sum( 10, 20 ) 变量作用域一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下： 全局变量 局部变量 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。","link":"/2020/08/07/Language/Python/Python%E5%9F%BA%E7%A1%80/"},{"title":"matplotlib笔记","text":"基本库pyplot matplotlib.pyplot is a state-based interface to matplotlib. It provides a MATLAB-like way of plotting. pyplot is mainly intended for interactive plots and simple cases of programmatic plot generation: 123456import numpy as npimport matplotlib.pyplot as pltx = np.arange(0, 5, 0.1)y = np.sin(x)plt.plot(x, y) 常用函数引入import matplotlib as plt plt.scatter(x, y, [s=None, c=None,...] ) A scatter plot of y vs x with varying marker size and/or color. plt.semilogy(x, y,) 画出y轴取log的图像。 画图设置嵌入项目%matplotlib inline 设置图画大小1234def set_figsize(figsize=(3.5, 2.5)): plt.rcParams['figure.figsize'] = figsizeset_figsize() 矢量图表示123456789def use_svg_display(): # 用矢量图显示 %config InlineBackend.figure_format = 'svg'#输入为tsdef xyplot(x_vals, y_vals, name): set_figsize(figsize=(5, 2.5)) plt.plot(x_vals.numpy(), y_vals.numpy()) plt.xlabel('x') plt.ylabel(name + '(x)') 一行画多张图123456789#images is a list of matrixes of pictures, and label is the text about the pictures.def show_fashion_mnist(images, labels): _, figs = plt.subplots(1, len(images), figsize=(12, 12)) for f, img, lbl in zip(figs, images, labels): f.imshow(img.reshape((28, 28))) f.set_title(lbl) f.axes.get_xaxis().set_visible(False) f.axes.get_yaxis().set_visible(False) plt.show() 多子图121表示1 * 2 的图像中占据第1个图像位置 123456789101112131415iters = range(len(hist.history['loss'])) # trainplt.subplot(121)plt.plot(iters, hist.history['mae'], 'r', label='train mae')plt.legend()plt.plot(iters, hist.history['val_mae'], 'b', label='val mae')plt.legend()# valplt.subplot(122)plt.plot(iters, hist.history['loss'], 'g', label='train loss')plt.legend()plt.plot(iters, hist.history['val_loss'], 'k', label='val loss')plt.legend()plt.show()","link":"/2020/08/07/Language/Python/matplotlib%E7%AC%94%E8%AE%B0/"},{"title":"pandas笔记","text":"常用函数1pandas.read_excel(io, sheet_name, dtype) 神奇的函数：io可使用多种URL，如http、ftp、file、path。 sheet_name 指定读取的工作簿 dtype：以dict的形式指定多列的数据类型 DataFrame以及Df对象记一个DataFrame对象为df， 当然一个Narray对象为Na。 pd.DataFrame() 创建一个Df对象 如下例 123456df = pd.DataFrame([('bird', 389.0),... ('bird', 24.0),... ('mammal', 80.5),... ('mammal', np.nan)],... index=['falcon', 'parrot', 'lion', 'monkey'],... columns=('class', 'max_speed')) df.values 为一个Narray对象（实现从Df转化Na） 同样也有pd。DataFrame(na), 即从Narray转化为Df。 df.dropna(inplace=True, how='any'， axis=0) 删除一行中带有Nan的 一行数据（how=‘any’， axis=0）。其中axis可为1，即从列中寻找，how=‘all’，即一个数据集中必须都为Nan。 inplace参数经常出现，若为True表示直接对源对象修改，不返回一个新对象。False表示生成一个新对象，并只对新对象进行修改。 如 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; df=pd.DataFrame(np.random.randn(4,3),columns=[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])&gt;&gt;&gt; df.loc[1, 'A'] = np.nan&gt;&gt;&gt; df A B C0 1.184976 0.757937 -1.4039581 NaN -0.459589 0.7741412 -1.522429 0.789742 -0.4868413 -0.188630 0.511300 1.807077&gt;&gt;&gt; x = df.dropna(axis=0, inplace=True, how='any')&gt;&gt;&gt; x&gt;&gt;&gt; df A B C0 1.184976 0.757937 -1.4039582 -1.522429 0.789742 -0.4868413 -0.188630 0.511300 1.807077&gt;&gt;&gt; df=pd.DataFrame(np.random.randn(4,3),columns=[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])&gt;&gt;&gt; df.loc[1, 'A'] = np.nan&gt;&gt;&gt; x = df.dropna(axis=0, inplace=False, how='any')&gt;&gt;&gt; x A B C0 0.999307 -1.473423 -0.2554392 2.322430 0.228044 -1.3839753 -0.734672 0.643534 1.203060&gt;&gt;&gt; df A B C0 0.999307 -1.473423 -0.2554391 NaN 0.438706 0.2789762 2.322430 0.228044 -1.3839753 -0.734672 0.643534 1.203060&gt;&gt;&gt; df.drop类似与df.dropna()都是删除之用。 df.reset_index(drop=True, inplace=True) 用来重新生成index（行的索引）。drop=True表示重新生成index，否则则保留原来的index。 索引df.loc[:, [col1, col2] ]（尤其是修改df原本数据时）可以有效选择数据。 df.index 返回df的index ranger df.values返回一个Narray。 df.columns返回df的columns的list。 添加一行12df = pd.DataFrame(columns=['A', 'B'], data = [[1,2],[3,4]]) df.loc['B'] = dict 文件IOExcelWriter(path, ) 返回一个ExcelWriter，配合就多个df.to_excle(Ewriter,sheet_name)写入DataFrame的数据，并用EecelWriter.save()来写入文件。 1234&gt;&gt;&gt; writer = pd.ExcelWriter('output.xlsx')&gt;&gt;&gt; df1.to_excel(writer,'Sheet1')&gt;&gt;&gt; df2.to_excel(writer,'Sheet2')&gt;&gt;&gt; writer.save()","link":"/2020/08/07/Language/Python/pandas%E7%AC%94%E8%AE%B0/"},{"title":"python基础学习笔记-import和命名空间","text":"模块Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。 模块让你能够有逻辑地组织你的 Python 代码段。 把相关的代码分配到一个模块里能让你的代码更好用，更易懂。 模块能定义函数，类和变量，模块里也能包含可执行的代码。 import 语句模块的引入模块定义好后，我们可以使用 import 语句来引入模块，语法如下： 1import module1[, module2[,... moduleN]] 比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用： 1模块名.函数名 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。 搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端： 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。 from…import 语句Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下： 1from modname import name1[, name2[, ... nameN]] 例如，要导入模块 fib 的 fibonacci 函数，使用如下语句： 1from fib import fibonacci 这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。 from…import* 语句把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： 1from modname import * 这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。 例如我们想一次性引入 math 模块中所有的东西，语句如下： 1from math import * 搜索路径当你导入一个模块，Python 解析器对模块位置的搜索顺序是： 1、当前目录 2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。 3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。 模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 PYTHONPATH 变量作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。 在 Windows 系统，典型的 PYTHONPATH 如下： 1set PYTHONPATH=c:\\python27\\lib; 在 UNIX 系统，典型的 PYTHONPATH 如下： 1set PYTHONPATH=/usr/local/lib/python 命名空间和作用域变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。 一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。 每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。 Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。 因此，如果要给函数内的全局变量赋值，必须使用 global 语句。 global VarName 的表达式会告诉 Python， `VarName 1是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。 例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。","link":"/2020/08/07/Language/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-import%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"title":"python基础学习笔记-进阶","text":"速记listls表示一个list函数。 ls.pop(i) 删除指定下标的内容。（可以用来删除str内容） 1234list_str = list(string)list_str.pop(1)#join 可以合并一整个list！list_str = ''.join(list_str) dictdict.has_key('name') 若有此键，则返回True，否则返回False。 同样的，也可以使用in判断，print ‘name’ in d.keys() STR函数str表示一个字符串对象。 str.upper() 返回一个大写字母的字符串。 str.atoi() 别python删掉了 str.join(str2)返回两个字符串连接的新字符串 #join 可以合并一整个list！ str.replace(old, new[, max]) 返回把str中的old换成new的字符串。在（最多换max次） 也可以使用正则表示式中的sub来替换符合正则表达式的子串。 1re.sub(pattern, repl, string, count=0, flags=0) repl: 为新字符串 string：为原字符串 str.strip(str) 删除头尾指定字符 。参数为空时，默认去除ss字符串中头尾\\r, \\t, \\n, 空格等字符。 ss.lstrip()删除ss字符串开头处的指定字符，ss.rstrip()删除ss结尾处的指定字符。 迭代器和生成器Zip(x,y) 返回一个将两个迭代器或者list，tuple啥的一一对应的组合成新样本的迭代器，其内容长度为最短的一个。 12345678910&gt;&gt;&gt;c = [1, 3, 4 ]&gt;&gt;&gt;b = [4, 3 ,2] &gt;&gt;&gt;Zip = zip(c,b)&gt;&gt;&gt;Zip&lt;zip at 0x1fb0cd1f248&gt;&gt;&gt;&gt;for x, y in Zip:&gt;&gt;&gt;print(x, y)1 43 34 2 利用 *** 号操作符**，可以将二维数据重组为形式等价于转置的数据。 这个题目就使用了该技巧 123456789&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; c = [4,5,6,7,8]&gt;&gt;&gt; zipped = zip(a,b) # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(a,c) # 元素个数与最短的列表一致[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*zipped) # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式[(1, 2, 3), (4, 5, 6)] enumerate(thing) 注意他返回的是一个迭代器 enumerate(thing), where thing is either an iterator or a sequence, returns a iterator that will return(0, thing[0]),(1, thing[1]),(2, thing[2])`, and so forth. forenumerate 可在迭代中得到遍历值和下标for inx, val in enumerate(['uyy', 'dfdf']):。 类型转化list(), str(), float(),int() 比比皆是。 注意Python没有char类型，str字符串也不能和数字相减。 isinstance(instance, Object) 判断一个实例是否是一个对象是否是该类型本身，或者位于该类型的父继承链上。 123456&gt;&gt;&gt; isinstance('a', str)True&gt;&gt;&gt; isinstance(123, int)True&gt;&gt;&gt; isinstance(b'a', bytes)True type() 判断对象的类型，也可判断其他情况如是否是函数、lambda表示式等等。可参见types自定义的常量。 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue dir() 如果要获得一个对象的所有属性和方法，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法： 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的： 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; 'ABC'.__len__()3 getattr()、setattr()以及hasattr() 获取属性、设置属性、是否拥有属性。 1234567&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？True&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'19&gt;&gt;&gt; obj.y # 获取属性'y'19 如果试图获取不存在的属性，会抛出AttributeError的错误。 可以传入一个default参数，如果属性不存在，就返回默认值： 12&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404404 获取对象的方法！ 也可以获得对象的方法： 12345678910111213&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？True&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81def readImage(fp): if hasattr(fp, 'read'): return readData(fp) return None 假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。 请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。 奇妙的编程去重并建立索引1234#使用set 取出corpus_chars 中唯一不重复的部分。idx_to_char = list(set(corpus_chars))# 对唯一的数据生成键值对的tuple，并转化为dictchar_to_idx = dict([(char, i) for i, char in enumerate(idx_to_char)]) Max和Lambdamax 函数是 Python 的内置函数 max 有一个 key 参数，指定如何进行值得比较。 下面案例，求出现频次最多的元素： 1234In [13]: def mode(lst): if lst is None or len(lst)==0: return None ...: return max(lst, key=lambda v: lst.count(v)) 出镜最多的元素有多个时，按照以上方法，默认只返回一个。 下面，支持返回多个： 12345678910111213In [34]: def mode(lst): ...: if lst is None or len(lst)==0: ...: return None ...: max_freq_elem = max(lst, key=lambda v: lst.count(v)) ...: max_freq = lst.count(max_freq_elem) # 出现最多次数 ...: ret = [] ...: for i in lst: ...: if i not in ret and lst.count(i)==max_freq: ...: ret.append(i) ...: return retIn [35]: mode([1,1,2,2,3,2,1])Out[35]: [1, 2] 多个list带有一个 * 的参数为可变的位置参数，意味着能传入任意多个位置参数。 key 函数定义怎么比较大小：lambda 的参数 v 是 lists 中的一个元素。 12In [15]: def max_len(*lists): ...: return max(*lists, key=lambda v: len(v)) 调用 max_len，传入三个列表，正是 v 可能的三个取值。 123In [17]: r = max_len([1, 2, 3], [4, 5, 6, 7], [8]) ...: print(f' 更长的列表是 {r}')更长的列表是 [4, 5, 6, 7] 关于 lambda 函数，在此做图形演示。 max_len 函数被传入三个实参，类型为 list，如下图所示，lists 变量指向最下面的 tuple 实例。 image-20200219203830985 程序运行到下一帧，会出现 lambda 函数，它的父函数为 f1，也就是 max_len 函数。 有些读者可能不理解两点，这种用法中： 参数 v 取值到底是多少？ lambda 函数有返回值吗？如果有，返回值是多少？ 通过下面图形，非常容易看出，v 指向 tuple 实例的第一个元素，指向的线和箭头能非常直观地反映出来。 image-20200219204141898 下面示意图中，看到返回值为 3，也就是 len(v) 的返回值，其中 v = [1,2,3]。 image-20200219204920052 然后，v 指向 tuple 中的下一个元素，返回值为 4。 img 然后，v 指向 tuple 的最后一个元素 [8]，返回值为 1。 image-20200219205408391 根据 key 确定的比较标准，max 函数的返回值为红色字体指向的元素，也就是返回 [4,5,6,7]。 img 高级篇容器对象在某些对象中会包含对其它对象的引用，这样的对象被称作容器(containers)。因此，我们可以把容器视作用于组织各种元素的数据结构。 下面是一些常见的容器对象： list, deque, … set, frozensets, … dict, defaultdict, OrderedDict, Counter, … tuple, namedtuple, … str 详细内容见链接 切片对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。 比如： 12345def trim(s): whlie s[:1] == ' ': s = s[1：] whlie s[-1] == ' ': s = s[:-1] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 迭代更详细的补充汗颜 迭代器定义：对于list、string、tuple、dict等这些容器对象,使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数。iter()是python内置函数。iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内的元素。next()也是python内置函数。在没有后续元素时，next()会抛出一个StopIteration异常，通知for语句循环结束。 迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数的时候，调用的就是迭代器对象的_next_方法（Python3中是对象的_next_方法，Python2中是对象的next()方法）。所以，我们要想构造一个迭代器，就要实现它的_next_方法。但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现_iter_方法，而_iter_方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的_iter_方法返回自身self即可。 术语解释 1，迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。 2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。 3，for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束 容器对象化为迭代器 123456789101112131415161718# 随便定义一个listlistArray=[1,2,3]# 使用iter()函数iterName=iter(listArray)print(iterName)# 结果如下：是一个列表list的迭代器# &lt;list_iterator object at 0x0000017B0D984278&gt;print(next(iterName))print(next(iterName))print(next(iterName))print(next(iterName))#没有迭代到下一个元素，直接抛出异常# 1# 2# 3# Traceback (most recent call last):# File &quot;Test07.py&quot;, line 32, in &lt;module&gt;# StopIteration 自定义迭代器 1234567891011121314151617181920212223class Fib(object): def __init__(self, max): super(Fib, self).__init__() self.max = max def __iter__(self): self.a = 0 self.b = 1 return self def __next__(self): fib = self.a if fib &gt; self.max: raise StopIteration self.a, self.b = self.b, self.a + self.b return fib# 定义一个main函数，循环遍历每一个菲波那切数def main(): # 20以内的数 fib = Fib(20) for i in fib: print(i) 在本类的实现中，定义了一个iter(self)方法，这个方法是在for循环遍历时被iter()调用，返回一个迭代器。因为在遍历的时候，是直接调用的python内置函数iter()，由iter()通过调用iter(self)获得对象的迭代器。有了迭代器，就可以逐个遍历元素了。而逐个遍历的时候，也是使用内置的next(）函数通过调用对象的next(self)方法对迭代器对象进行遍历。所以要实现iter(self)和next(self)这两个方法。 而且因为实现了next(self)方法，所以在实现iter(self)的时候，直接返回self就可以。 总结一句话就是：在循环遍历自定义容器对象时,会使用python内置函数iter()调用遍历对象的iter(self)获得一个迭代器,之后再循环对这个迭代器使用next()调用迭代器对象的next(self)。 注意点：iter(self)只会被调用一次,而next(self)会被调用 n 次，直到出现StopIteration异常。 判断可迭代可使用Iterable类型来判断。 123from collections import Iterableisinstance('abc', Iterable) #判断 'abc' 是否可迭代# True 生成器生成器是一类特殊的迭代器。生成器是只能遍历一次的 延迟操作。也就是在需要的时候才产生结果，不是立即产生结果。 第一类：生成器函数：还是使用 def 定义函数，但是，使用yield而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次从它离开的地方继续执行。 如下案例加以说明： 123456789101112131415161718# 菲波那切数列def Fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return '亲！没有数据了...'# 调用方法，生成出10个数来f=Fib(10)# 使用一个循环捕获最后return 返回的值，保存在异常StopIteration的value中while True: try: x=next(f) print(&quot;f:&quot;,x) except StopIteration as e: print(&quot;生成器最后的返回值是：&quot;,e.value) break 第二类：生成器表达式：类似于列表推导，只不过是把一对大括号[]变换为一对小括号()。但是，生成器表达式是按需产生一个生成器结果对象，要想拿到每一个元素，就需要循环遍历。 如下案例加以说明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 一个列表xiaoke=[2,3,4,5]# 生成器generator，类似于list，但是是把[]改为()gen=(a for a in xiaoke)for i in gen: print(i)#结果是：2345#也可以使用next调用generatorgenerator_ex = (x*x for x in range(10))print(next(generator_ex))print(next(generator_ex))print(next(generator_ex))print(next(generator_ex))print(next(generator_ex))print(next(generator_ex))print(next(generator_ex))0149162536# 为什么要使用生成器？因为效率。# 使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。# 如果你构造一个列表(list)的目的仅仅是传递给别的函数,# 比如 传递给tuple()或者set(), 那就用生成器表达式替代吧!# 本案例是直接把列表转化为元组kk=tuple(a for a in xiaoke)print(kk)#结果是：(2, 3, 4, 5)# python内置的一些函数，可以识别这是生成器表达式，外面有一对小括号，就是生成器，中括号就列表生成式result1=sum(a for a in range(3))print(result1)# 列表推导式result2=sum([a for a in range(3)])print(result2) 列表生成器列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 12[x * x for x in range(1, 11)][x * x for x in range(1, 11) if x % 2 == 0] 还可以使用两层循环，可以生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 三层和三层以上的循环就很少用到了。 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： 123&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode'] for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value： 123&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]['y=B', 'x=A', 'z=C'] Note： 在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else。也就是说for后面不能加else，而for前面if必须加else。 装饰器类中的属性可以通过方法的包装来防止外露，但是直接调用方法不如直接写属性简介明白。程序员们想出了装饰器@property个东西来修饰方法，是其可以方法可以如同属性一样使用、赋值。当然Python最后会把它转化为等价的方法调用形式？ 如 123456789101112131415161718class Student(object): #定义了一个只读的属性 @property def score(self): return self._score #定义了一个可读也可写的属性 @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value # 仅定义@property的方法是定义了一个只读属性 @property def age(self): return self.age 多重继承假设在为了每个功能而专门设计一个类并同时作为一个父亲类，那么类数量可能会指数型增长而且类的层次变得更加复杂。 image-20200503125546752 为了解决这一个问题，多重继承的概念就此引出，即一个类可以继承多个类，那么只需要把需要添加的功能写成类，并继承给相应需要的类即可。 123#比如给Dog添加Runable， Carnivorous 的功能class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass 自定义类 magic function的天下我们先定义一个Student类，打印一个实例： 123456&gt;&gt;&gt; class Student(object):... def __init__(self, name):... self.name = name...&gt;&gt;&gt; print(Student('Michael'))&lt;__main__.Student object at 0x109afb190&gt; 看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。 __slots__我们已经知道怎么用了，__len__()方法我们也知道是为了能让class作用于len()函数。 除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。 __str__() __repr__() __len__() __iter__ __getitem__ __setitem__()__str__()可在print(class)时调用，并显示出内容。 如果不定义的话，一般都是这样子的打印出一堆&lt;__main__.Student object at 0x109afb190&gt;，不好看。 __repr__()在直接敲变量的被调用，同样也可以自定义来输出的好看一点，也可以偷懒一点__repr__ = __str__。 __len__() 可在__len__()时调用。 __iter__ 该方法返回一个迭代对象以供for循环使用。然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。我们以斐波那契数列为例，写一个Fib类，可以作用于for循环： 123456789101112class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 现在，试试把Fib实例作用于for循环： 1234567891011&gt;&gt;&gt; for n in Fib():... print(n)...11235...4636875025 Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素： 1234&gt;&gt;&gt; Fib()[5]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'Fib' object does not support indexing __getitem__ 可以实现按元素寻址。 123456class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return a 现在，就可以按下标访问数列的任意一项了： 123&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1 但是list有个神奇的切片方法： 12&gt;&gt;&gt; list(range(100))[5:10][5, 6, 7, 8, 9] 对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断： 12345678910111213141516171819class Fib(object): def __getitem__(self, n): if isinstance(n, int): # n是索引 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): # n是切片 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a, b = b, a + b return L 现在试试Fib的切片： 12345&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0:5][1, 1, 2, 3, 5]&gt;&gt;&gt; f[:10][1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 但是没有对step参数作处理： 12&gt;&gt;&gt; f[:10:2][1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] 也没有对负数作处理，所以，要正确实现一个__getitem__()还是有很多工作要做的。 此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str。 与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。 总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。 __getattr__一般来说，如果调用一个不存在的属性，会爆出错误，提示没有这个attribute。要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。 1234567891011class Student(object): def __init__(self): self.name = 'Michael' def __getattr__(self, attr): if attr=='score': return 99 # 返回函数也是完全可以的： if attr=='age': return lambda: 25 python对于调用的不存在的类的函数和属性会都使用__getattr__() 1234567&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name'Michael'&gt;&gt;&gt; s.score99&gt;&gt;&gt; s.age()25 Note: 只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。 注意到任意调用__getattr__也未定义的属性都会返回None，这是因为我们定义的__getattr__默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误： 123456class Student(object): def __getattr__(self, attr): if attr=='age': return lambda: 25 raise AttributeError('Student object has no attribute %s % attr) 这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。 举个例子： 现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似： http://api.server/user/friends http://api.server/user/timeline/list 如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。 利用完全动态的__getattr__，我们可以写出一个链式调用： 12345678910111213class Chain(object): def __init__(self, path=''): self._path = path def __getattr__(self, path): #返回一个Chain对象，而且path随着新的对象而动态增长了！ return Chain('%s/%s' % (self._path, path)) def __str__(self): return self._path __repr__ = __str__ 试试： 123#一开始`chain()`的`_path`为空！&gt;&gt;&gt; Chain().status.user.timeline.list'/status/user/timeline/list' 这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！ 还有些REST API会把参数放到URL中，比如GitHub的API： 1GET /users/:user/repos 调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用： 1Chain().users('michael').repos 就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。 __call__任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例： 123456789class Student(object): def __init__(self, name): self.name = name def __call__(self): print('My name is %s.' % self.name)&gt;&gt;&gt; s = Student('Michael')&gt;&gt;&gt; s() # self参数不要传入My name is Michael. __call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。 如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。 那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call__()的类实例.通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。 12345678910&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable('str')False 枚举类Enum枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。 123from enum import Enum#返回`Month`类型的枚举类Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) 可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员： 12for name, member in Month.__members__.items(): print(name, '=&gt;', member, ',', member.value) 如果需要更精确地控制枚举类型，可以从Enum派生出自定义类： 1234567891011from enum import Enum, unique#@unique装饰器可以帮助我们检查保证没有重复值。@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类型的方法归纳： 123456789101112131415161718192021222324252627282930313233#引用##属性&gt;&gt;&gt; day1 = Weekday.Mon&gt;&gt;&gt; print(day1)Weekday.Mon##下标&gt;&gt;&gt; print(Weekday['Tue'])Weekday.Tue##方法调用，（必须是int）&gt;&gt;&gt; print(Weekday(1))Weekday.Mon#属性具有值&gt;&gt;&gt; print(Weekday.Tue.value)2#属性之间可以比较&gt;&gt;&gt; print(day1 == Weekday.Mon)True&gt;&gt;&gt; print(day1 == Weekday.Tue)False#遍历&gt;&gt;&gt; for name, member in Weekday.__members__.items():... print(name, '=&gt;', member)...Sun =&gt; Weekday.SunMon =&gt; Weekday.MonTue =&gt; Weekday.TueWed =&gt; Weekday.WedThu =&gt; Weekday.ThuFri =&gt; Weekday.FriSat =&gt; Weekday.Sat Callback函数在我的理解下，Callback是可以指函数A可以作为参数传入一个函数B并在函数B中调用A，即A是Callbackable的。 123456789101112131415161718192021#callbackdef cb(value): if value % 130 == 0: return (True, value) elif value &gt; 100000: return (True, None) return (False ,None)def fibonacci_call(func): values = [] while(True): if len(values) &lt; 2: values.append(1) else: values = [values[-1], values[-2] + values[-1]] res = func(values[-1] ) print(values[-1]) if res[0]: return res[1] fibonacci_call(cb) Python的对象说明Python的一切都是一个对象，当传参给函数的时候传的是一个对象的指针！那么在函数内部进行改变变量的指向的时候，原数据是不会受到影响的！如： 123456a = 10def test(a): a = a + 1 print(a)test(a)print(a) 1110​``` 123456789所以只能不改变原来的指向，直接改变原来的值！如​```pythona = [1]def test(a): a[0] = 2 print(a)test(a)print(a) [1][1]​``` 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869## 元类MateClass看不太懂，溜了溜了 https://www.liaoxuefeng.com/wiki/1016959663602400/1017592449371072## 引用顺序以及关键字### 命名空间命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。一般有三种命名空间：- **内置名称（built-in names**）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。- **全局名称（global names）**，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。- **局部名称（local names）**，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）**命名空间的生命周期**：命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。因此，我们无法从外部命名空间访问内部命名空间的对象。### 作用域作用域就是一个 Python 程序可以直接访问命名空间的正文区域。Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：有四种作用域：- **L（Local）**：最内层，包含局部变量，比如一个函数/方法内部。- **E（Enclosing）**：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。- **G（Global）**：当前脚本的最外层，比如当前模块的全局变量。- **B（Built-in）**： 包含了内建的变量/关键字等。，最后被搜索**查找变量的顺序：**python引用变量的顺序： 当前作用域局部变量（此函数）-&gt;外层作用域变量-&gt;当前模块中的全局变量-&gt;python内置变量![image-20200503125603390](http://static.come2rss.xyz/image-20200503125603390.png)**全局变量和局部变量**定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。局部变量只能在其被声明的函数内部**访问**，而全局变量可以在整个程序范围内访问。调用函数时，**所有在函数内声明的变量名称都将被加入到作用域中**。### global 和 nonlocal关键字当内部作用域想**修改**外部作用域的变量时，就要用到global和nonlocal关键字了。如果要修改**嵌套**作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：​```pythondef a(): var = 1 def b(): nonlocal var #注意这里var的nonlocal的声明不可以接后续的东西 var = 2 面对对象编程面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。在Python中，定义类是通过class关键字： class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名()实现的： 面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 12345&gt;&gt;&gt; bart = Student()&gt;&gt;&gt; bart&lt;__main__.Student object at 0x10a67a590&gt;&gt;&gt;&gt; Student&lt;class '__main__.Student'&gt; 可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。 可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性： 123&gt;&gt;&gt; bart.name = 'Bart Simpson'&gt;&gt;&gt; bart.name'Bart Simpson' 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去： 12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 注意：特殊方法“init”前后分别有两个下划线！！！ 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 数据封装面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩： 12345&gt;&gt;&gt; def print_score(std):... print('%s: %s' % (std.name, std.score))...&gt;&gt;&gt; print_score(bart)Bart Simpson: 59 但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法： 12345678class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入： 12&gt;&gt;&gt; bart.print_score()Bart Simpson: 59 这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。 封装的另一个好处是可以给Student类增加新的方法，比如get_grade： 12345678910class Student(object): ... def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' 同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节： 访问限制 在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。 私有变量（private）是类中属性的名称前加上两个下划线__的属性，在Python中，实例的变量名如果以__开头，所以，我们把Student类改一改： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。 但是如果外部代码要获取和修改name和score怎么办？可以给Student类增加get_name和get_score这样的方法： 12345678910class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score def set_score(self, score): self.__score = score 在这种方法中，可以对参数做检查，避免传入无效的参数： 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 原理：双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 12&gt;&gt;&gt; bart._Student__name'Bart Simpson' 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。 最后注意下面的这种错误写法： 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！&gt;&gt;&gt; bart.__name'New Name' 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试： 12&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name'Bart Simpson' 要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量： 123def run_twice(animal): animal.run() animal.run() 当我们传入Animal的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running... 当我们传入Dog的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running... 当我们传入Cat的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Cat())Cat is running...Cat is running... 看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生： 123class Tortoise(Animal): def run(self): print('Tortoise is running slowly...') 当我们调用run_twice()时，传入Tortoise的实例： 123&gt;&gt;&gt; run_twice(Tortoise())Tortoise is running slowly...Tortoise is running slowly... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树： 1234567891011121314151617 ┌───────────────┐ │ object │ └───────────────┘ │ ┌────────────┴────────────┐ │ │ ▼ ▼ ┌─────────────┐ ┌─────────────┐ │ Animal │ │ Plant │ └─────────────┘ └─────────────┘ │ │ ┌─────┴──────┐ ┌─────┴──────┐ │ │ │ │ ▼ ▼ ▼ ▼┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐│ Dog │ │ Cat │ │ Tree │ │ Flower │└─────────┘ └─────────┘ └─────────┘ └─────────┘ 静态语言 vs 动态语言对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 123class Timer(object): def run(self): print('Start...') 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 小结继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。 实例属性和类属性由于Python是动态语言，根据类创建的实例可以任意绑定属性。 给实例绑定属性的方法是通过实例变量，或者通过self变量： 123456class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90 但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有： 12class Student(object): name = 'Student' 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。 12345678910111213141516&gt;&gt;&gt; class Student(object):... name = 'Student'...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 小结：python可以动态绑定实例属性，但是最好别和类属性重合，不然会会覆盖掉类属性。 Python高级面对对象编程添加对象和属性Python这种动态类型语言可以在运行过程中动态添加定义给类和实例添加方法和属性。但是给实例添加的属性和方法是无法对新建的实例生效的，或者说无法改变类。 如 123456789101112131415161718192021222324252627282930class Student(object): pass&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'Michael' # 动态给实例绑定一个属性&gt;&gt;&gt; print(s.name)Michael &gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法... self.age = age...&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(25) # 调用实例方法&gt;&gt;&gt; s.age # 测试结果25&gt;&gt;&gt; s2 = Student() # 创建新的实例&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法,#可以见到给一个实例添加的方法是不对另一个实例起作用的Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'set_age'&gt;&gt;&gt; def set_score(self, score):... self.score = score...&gt;&gt;&gt; Student.set_score = set_score # 给类绑定方法 使用__slots__限制类的属性可以使用特殊变量__slots__来限制类的属性。 123456789class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 &gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; 可以看到age由于没有被__slots__包括在内，所以不可被绑定。 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 函数式编程 Functional Programming函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。 而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。 我们首先要搞明白计算机（Computer）和计算（Compute）的概念。 在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。 而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。 对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。 高阶函数函数名也是变量函数名其实就是指向函数的变量！对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数！ 12345&gt;&gt;&gt; abs = 10&gt;&gt;&gt; abs(-10)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'int' object is not callable 把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！要恢复abs函数，请重启Python交互环境。 注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。 传入函数既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 12def add(x, y, f): return f(x) + f(y) 当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为： 12345x = -5y = 6f = absf(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11return 11 Map/ReductPython内建了map()和reduce()函数。 如果你读过Google的那篇大名鼎鼎的论文“MapReduce: Simplified Data Processing on Large Clusters”，你就能大概明白map/reduce的概念。 我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 123456&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做”累积”。其实这么描述并不够详细， 参考 reduce操作是函数式编程中的重要技术之一，其作用是通过对一个集合的操作，可以从中生成一个值。比如最常见的求和，求最大值、最小值等都是reduce操作的典型例子。python通过内置reduce函数对reduce操作提供了很好的支持。 函数语法： reduce(function, iterable[,initializer]) 函数参数含义如下： 1、function 需要带两个参数，1个是用于保存操作的结果，另一个是每次迭代的元素。 2、iterable 待迭代处理的集合 3、initializer 初始值，可以没有。 reduce函数的运作过程是，当调用reduce方法时： 1、如果存在initializer参数，会先从iterable中取出第一个元素值，然后initializer和元素值会传给function处理； 接着再从iterable中取出第二个元素值，与function函数的返回值 再一起传给function处理，以此迭代处理完所有元素。最后一次处理的function返回值就是reduce函数的返回值。 2、如果不存在initializer参数，会先从iterable中取出第一个元素值作为initializer值，然后以此从iterable取第二个元素及以后的元素进行处理。特殊情况下，如果集合只有一个元素，则无论function如何处理，reduce返回的都是第一个元素的值。 下面我们通过具体的例子来说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from functools import reduceCHAR_TO_FLOAT = { '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '.': -1}def str2float(s): nums = map(lambda y: CHAR_TO_FLOAT[y], s) point = 0 def add(sum, x): nonlocal point if x == -1 : point = 1; return sum elif point == 0: return sum* 10 + x else: point = point * 10 return sum + x/point return reduce(add, nums)def str2float_ini(s): nums = map(lambda y: CHAR_TO_FLOAT[y], s) point = 0 def add(sum, x): nonlocal point if x == -1 : point = 1; return sum elif point == 0: return sum* 10 + x else: point = point * 10 return sum + x/point return reduce(add, nums,999)t = str2float_ini('2132.213')print(t)t = str2float_ini('2132.213')print(t) 2132.2139992132.213​``` 12345678910111213### filterPython内建的`filter()`函数用于过滤序列。和`map()`类似，`filter()`也接收一个函数和一个序列。`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素。**注意**到`filter()`函数返回的是一个`Iterator`，也就是一个惰性序列，所以要强迫`filter()`完成计算结果，需要用`list()`函数获得所有结果并返回list。### sortPython内置的`sorted()`函数就可以对list进行排序： sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] 123此外，`sorted()`函数也是一个高阶函数，它还可以接收一个`key`函数来实现自定义的排序。key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过`key=abs`处理过的list：我们再看一个字符串排序的例子： sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’])[‘Credit’, ‘Zoo’, ‘about’, ‘bob’] 12345默认情况下，对字符串排序，是按照ASCII的大小比较的，由于`'Z' &lt; 'a'`，结果，大写字母`Z`会排在小写字母`a`的前面。现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。xx这样，我们给`sorted`传入key函数，即可实现忽略大小写的排序： sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower)[‘about’, ‘bob’, ‘Credit’, ‘Zoo’] ``` 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True： 正则表达式这个坑以后再填 https://www.runoob.com/regexp/regexp-rule.html","link":"/2020/08/07/Language/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E9%98%B6/"},{"title":"python系统操作","text":"安装库镜像库123456 #华中科技的很快https://pypi.mirrors.ustc.edu.cn/simple/ #清华的一般 https://pypi.tuna.tsinghua.edu.cn/simple some-package #豆瓣也OK https://pypi.douban.com/simple/ 临时使用1234pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package#有些模块只能在官方的站点下？pip install tensorflow -i https://pypi.org/simple 注意，simple 不能少, 是 https 而不是 http 设为默认升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置（如果是WIN，记得用管理员身份运行CMD）： 12pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip： 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U 连接超时1pip --default-timeout=100 install -U tensorflow-gpu # 设置超时时间 PYTHON 包安装更新在PYcharm中，双击pip后面的蓝色升级箭头按钮。 image-20200503125713771 会出现如图所示，Specify version要打对勾。然后install package即可。 或者使用命令操作：--upgrade 1pip install --upgrade tensorflow -i https://pypi.org/simple 有时候由于一些环境上的问题，导致pip无法及时更新，所以采取另一种更新方法更有效 12#强制更新python3 -m pip install -U --force-reinstall pip PIP使用pip 当前内建命令并不支持升级所有已安装的Python模块。 列出当前安装的包： 1pip list 列出可升级的包： 1pip list --outdate 升级一个包： 1pip install --upgrade requests // mac,linux,unix 在命令前加 sudo -H 升级所有可升级的包： 12$ pip freeze --local | grep -v '^-e' | cut -d = -f 1 | xargs -n1 pip install -Upip list -o --format legacy|awk '{print $1}'` ; do pip install --upgrade $i; done 显示包的信息 1pip show numpy 删除包 1pip uninstall numpy pip默认源由于墙，所以速度很慢，可使用第三源提高速度： 12345678910vim ~/.pip/pip.conf[global]trusted-host = mirrors.aliyun.comindex-url = http://mirrors.aliyun.com/pypi/simple","link":"/2020/08/07/Language/Python/python%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"},{"title":"random笔记","text":"wrandom常用函数 sample(list, simpleSize)从list中抽simpleSize个元素 1234567In [33]: from random import randint,sample ...: lst = [randint(0,50) for _ in range(100)] ...: print(lst[:5]) ...: lst_sample = sample(lst,10) ...: print(lst_sample)[0, 38, 31, 33, 43][9, 43, 31, 22, 31, 30, 14, 47, 14, 1] shuffle(lst)随机打乱顺序 值得注意，shuffle 是对输入列表就地（in place）洗牌，节省存储空间。 12345In [34]: from random import shuffle ...: lst = [randint(0,50) for _ in range(100)] ...: shuffle(lst) ...: print(lst[:5]) [22, 49, 34, 9, 38] uniform(a,b) 生成 [a,b) 内的一个随机数。 12from random import uniform x, y = [i for i in range(100)], [round(uniform(0, 10), 2) for _ in range","link":"/2020/08/07/Language/Python/random%E7%AC%94%E8%AE%B0/"},{"title":"1025 除数博弈","text":"1025. 除数博弈难度简单 思路：可以从简单的例子入手发现，爱丽丝拿1输，拿2赢，拿3输。对于Bob则相反，如果我们可以找出小于数字N的数字x，且N-x可以整除于N，x对于bob是必输态，那么爱丽丝必胜。 也可以从另一个角度出发：从多个例子可以大胆推测，偶数必胜，奇数必输。可以用归纳法证明。那么代码就简单很多。 代码：堆维护数组 1234567891011121314151617181920class Solution {public: bool divisorGame(int N) { if(N &lt; 1 || N &gt; 1000) return false; int* dp = new int[1005]; dp[1] = 0; dp[2] = 1; for(int i = 3; i &lt; 1001; i++){ dp[i] = 0; for(int j = 1; j &lt; i; j++){ if(i % (i - j) == 0 &amp;&amp; dp[j] == 0){ dp[i] = 1; break; } } } return dp[N]; }};","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"},{"title":"1027 最长等差数列","text":"1027. 最长等差数列思路：求最长等差序列的长度，可以看出序列可以分解为多个序列，而且序列的选择不具有历史影响。可以可以考虑用DP做。用一个状态无法表示数列的等差量和数列的端点两个状态。所以至少得有两个状态，且可以用两个状态分别表示一个等差序列的最后两个元素下标。 为啥是最后两个？因为为最后两个元素组成的最长等差序列，可以给后续DP方程计算。而两个元素作为开头无法递推！ DP方程可以这么写： dp[i][j]={dp[k][i]+1,if k is element of the array 2,elsedp[i][j]={dp[k][i]+1,if k is element of the array 2,else 123456789101112131415161718192021class Solution {public: int longestArithSeqLength(vector&lt;int&gt;&amp; A) { int n = A.size(); //优秀的初始化方法 // vector&lt;int&gt;(n, 2)动态生成了一个长度为n，每个元素为2的vector对象 vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 2)); map&lt;int, int&gt; idx; int maxRes = 2; for(int i = 0; i &lt; (int)A.size() - 1; i++){ for(int j = i + 1; j &lt; A.size(); j++){ int target = A[i] * 2 - A[j]; if( idx.count( target )) dp[i][j] = dp[idx[target]][i] + 1; maxRes = max(maxRes, dp[i][j]); } idx[A[i]] = i; } return maxRes; }};","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1027-%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"},{"title":"1190. Reverse Substrings Between Each Pair of Parentheses","text":"1190.Reverse Substrings Between Each Pair of Parentheses 难度MD这个题一开始思路就错了，首先是括号匹配问题不能使用左右指针选择，其次是字符串翻转完全可以忽略掉括号（或者说连同括号一起翻转）。一共有两种思路。 思路1将栈匹配+翻转，复杂度O(n2)O(n2)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: // string reverseParentheses(string s) { // string ns = &quot;&quot;; // vector&lt;int&gt; idxl, idxr; // int singbrack = 0, calbrack = 0; // for(int i = 0; i &lt; s.size(); i++){ // if(s[i] == '(' || s[i] == ')') singbrack ++; // else ns.push_back(s[i]); // } // singbrack /= 2; // for(int i = 0, j = s.size() - 1; i &lt; j;){ // while(i &lt; j &amp;&amp; s[i] != '(') i++; // while(i &lt; j &amp;&amp; s[j] != ')') j--; // idxl.push_back(i - calbrack); // idxr.push_back(j - singbrack - (singbrack - calbrack - 1)); // reverse 翻转的范围是[),这里注意01错误 // i++; // j--; // calbrack ++; // } // if(calbrack == 0) return ns; // for(int i = idxl.size() - 1; i &gt;= 0; i--){ // reverse(ns.begin() + idxl[i], ns.begin() + idxr[i]); // } // return ns; // } string reverseParentheses(string s) { string ns = &quot;&quot;; stack&lt;int&gt; sti; for(int i= 0; i &lt; s.size(); i++){ if( s[i] == '(') sti.push(i); else if(s[i] == ')'){ reverse( s.begin() + sti.top(), s.begin() + i); sti.pop(); } } for(int i = 0; i &lt; s.size(); i++){ if(s[i] == '(' || s[i] == ')' ) continue; ns.push_back(s[i]); } return ns; }}; 思路2神奇的黑魔法（这个算法局限于这个应用，感觉挺死板）","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses/"},{"title":"1254. Number of Closed Islands","text":"1254. Number of Closed Islands难度MD 思路：DFS或者并查集 排除法：将所有接触过边界的0块排除掉，接下来统计所有的0块数量就是岛屿的数量啦~ 直接法：考虑成为岛屿的条件——岛屿上所有0块都不与边界相交。 接下来只需要写DFS或者BFS就👌。 考虑使用并查集 排除法 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: //保持和第二种写法一致，add参数实际上是多余的 void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add){ if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= M || grid[x][y] == 1) return; //if(grid[x][y] == 1) add = 1; grid[x][y] = 1; findBlockOf0(x, y+1, N, M, grid, add); findBlockOf0(x, y-1, N, M, grid, add); findBlockOf0(x+1, y, N, M, grid, add); findBlockOf0(x-1, y, N, M, grid, add); return; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts, add; //排除掉那些不是island的blocks of 0 for(int i=0;i &lt; M; i++){ findBlockOf0(0,i, N, M, grid, counts); findBlockOf0(N-1,i, N, M, grid, counts); } for(int i=0;i &lt; N;i++){ findBlockOf0(i,0,N,M, grid, counts); findBlockOf0(i,M-1, N, M, grid, counts); } //接下来所有的0块都可以算作island counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; findBlockOf0(x, y, N, M, grid, add); counts += 1; } } return counts; }}; 直接法 1234567891011121314151617181920212223242526272829class Solution { public: // 注意遍历的时候不能剪枝，否则就会就会出现岛屿断裂成多个“单独”岛屿而计数过多 void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add){ if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= M || grid[x][y] == 1) return; if(x == 0 || x == N-1|| y == 0 || y == M-1 ) add = 0; grid[x][y] = 1; // 这里的四个方向其实可以用FOR写的更优雅一些 findBlockOf0(x, y+1, N, M, grid, add); findBlockOf0(x, y-1, N, M, grid, add); findBlockOf0(x+1, y, N, M, grid, add); findBlockOf0(x-1, y, N, M, grid, add); return; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts; counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; int add = 1; findBlockOf0(x, y, N, M, grid, add); counts += add; } } return counts; }}; 尝试使用BFS写第二种写法~ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: // BFS int findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid){ int dX[4] = {0, 0, -1, 1}, dY[4] = {1, -1, 0, 0}, nX, nY; int flag = 1; queue&lt; vector&lt;int&gt; &gt; que; que.push( {x, y}); grid[x][y] = 1; while( !que.empty() ){ vector&lt;int&gt; point = que.front(); que.pop(); int x = point[0], y = point[1]; //注意 所有的点都需要判断是否在边界上 if(x == 0 || x == N - 1 ||y == 0 || y == M - 1) flag = 0; for(int i=0;i &lt; 4; i++){ nX = x + dX[i]; nY = y + dY[i]; if(nY &gt;= 0 &amp;&amp; nY &lt; M &amp;&amp; nX &gt;=0 &amp;&amp; nX &lt; N &amp;&amp; grid[nX][nY] == 0){ grid[nX][nY] = 1; que.push({nX, nY}); } } } return flag; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts; counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; counts += findBlockOf0(x, y, N, M, grid); } } return counts; }}; 并查集 改日再战","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1254-Number-of-Closed-Islands/"},{"title":"15 3sum","text":"思路： 简单的说，先有序化，再二重循环遍历前两个指针，第三个指针采用二分法即可。注意跳过重复值 更巧妙的解法——双指针解法。先有序化，遍历第一个数字的同时，采用双指针从两边逼近结果。 实际上这是对数组有序的利用。 二重循环 + 二分 12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt; vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); // for(int i = 0;i &lt; len; i++) // printf(&quot;%d&quot;, nums[i]); for(int i=0; i &lt; len - 2; i++){ //排除重复结果 if(i!=0 &amp;&amp; nums[i-1] == nums[i]) continue; for(int j=i + 1; j &lt; len - 1; j++){ //排除重复结果 if(j!=i+1 &amp;&amp; nums[j] == nums[j-1]) continue; int ld = j + 1, rd = len - 1, mid; while(ld &lt; rd){ mid = (ld + rd ) / 2; if( nums[mid] + nums[i] + nums[j] &gt;= 0) rd = mid; else ld = mid + 1; // 注意这里向上二分的时候， mid没有变动，同时循环可能结束。导致了mid的值可能在某种情况下雨rdld不同 ，所以循环结束最好选ld或者rd } // printf(&quot;%d &quot;, mid); if(nums[rd] + nums[i] + nums[j] == 0){ res.push_back({nums[i], nums[j], nums[rd]}); } } } return res; }}; 双指针法 12345678910111213141516171819202122232425262728293031323334class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt; vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); for(int i=0;i &lt; len - 2; i++){ // 排除重复结果 if(i !=0 &amp;&amp; nums[i] == nums[i-1]) continue; int j = i + 1, k = len - 1; while(j &lt; k){ int sum = nums[i] + nums[k] + nums[j]; // 排除重复结果 if(j != i + 1 &amp;&amp; nums[j] == nums[j-1]){ j++; continue; } if(k != len -1 &amp;&amp; nums[k] == nums[k+1]){ k--; continue; } if(sum &gt; 0) k--; else if(sum &lt; 0) j++; else{ res.push_back({nums[i], nums[j], nums[k]}); j++, k--; } } } return res; }}; #二分TWO POINTERS","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/15-3sum/"},{"title":"654. 最大二叉树","text":"一个基础的递归建树就可以解决。 以递归的思想处理每一个新数组，先找出最大值所在并以此值一分数组为2个数组，同时递归建树即可。 Note：注意边界错误，如right到底没有没值 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { return constructBT(nums, 0, nums.size() - 1); } TreeNode* constructBT(vector&lt;int&gt;&amp; nums, int left, int right){ if(left &gt; right) return NULL; int index = left, nmax = nums[left]; for(int i = left + 1; i &lt;= right; i++){ if(nmax &lt; nums[i]){ nmax = nums[i]; index = i; } } TreeNode* root = new TreeNode(nmax); root-&gt;left = constructBT(nums, left, index - 1); root-&gt;right = constructBT(nums, index + 1, right); return root; } };","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"786. 第 K 个最小的素数分数","text":"786. 第 K 个最小的素数分数难度hard 思路：明显的有A[i] &lt; A[j]，能够推出A[i]/A[j] &gt; A[i]/A[j+1]，但是不能推出A[i+1]/A[j]和A[i]/A[j+1]的关系，毫无用处。 自然可以想到要用堆来维护第K小的数，而然超时。 评论里提出一种二分的方法， 代码：堆维护数组 123456789101112131415161718192021222324252627struct cmp{ bool operator () (pair&lt;int, int&gt; x, pair&lt;int, int&gt; y){ return x.first * 1.0 / x.second &lt; y.first * 1.0 / y.second; }};class Solution {public: vector&lt;int&gt; kthSmallestPrimeFraction(vector&lt;int&gt;&amp; A, int K) { priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, cmp&gt; pq; for(int i = 0; i &lt; A.size() - 1; i++){ for(int j = i + 1; j &lt; A.size(); j++){ double temp = A[i] * 1.0 / A[j]; if(pq.size() &lt; K){ pq.push(make_pair(A[i], A[j])); }else if(pq.top().first * 1.0 / pq.top().second &gt; temp){ pq.pop(); pq.push(make_pair(A[i], A[j])); } } } vector&lt;int&gt; res = vector(2, 0); res[0] = pq.top().first, res[1] = pq.top().second; return res; } };","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/"},{"title":"833.字符串中的查找与替换","text":"中等题 这题坑还是很多的，如输入数据非有序，考虑在同一字符串插入时多个字符串替换时原字符串的下标维持或是可插入性。 思路1: 将indexes所标记出的下标映射为输入数据的次序，在排序indexes来有序遍历S。之后就是判断哪些S的字母可以替换并替换。 思路2（官方）： 为了顺序地构造目标字符串，先标记出S中所有可替换的位置，并顺序遍历（逆序或者正序都可以，构造方法不同罢了）。 依据题意，可以推出从后向前替换，可以避免下标变换的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: //题目没看清,多写了一个转化大小写函数 string lowercase(string S){ // return A iterator; std::transform(S.begin(), S.end(), S.begin(), [](unsigned char c){return std::tolower(c);} ); return S; } //思路1 string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) { int idx2 = indexes.size() - 1; vector&lt;int&gt; repl( indexes.size() ); //将排序后的字符串下标映射回原来的下标 //同时不能 把排序后的index下标映射或者被映射; map&lt;int, int&gt; match; for(int i=0;i&lt;indexes.size();i++) match[ indexes[i] ] = i; sort(indexes.begin(), indexes.end()); //判断逆序判断能否替换，若可以则逆序替换； //逆序替换不影响之前的可替换性判断 for(int i=S.size()-1;i&gt;=0 &amp;&amp; idx2 &gt;=0 ;i--){ if(i == indexes[idx2]){ if(lowercase( S.substr(i, sources[match[i]].size())) == sources[match[i]] ) S.replace(i, sources[match[i]].size(), targets[match[i]]); idx2 --; } } return S; } // 思路2：官方解的实现，也是空间换时间 string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) { //对S每个字母对有效替换的判断, 并记录下标 vector&lt;int&gt; match(S.size(), -1); for(int i=0 ;i&lt;indexes.size();i++){ if( S.substr(indexes[i], sources[i].size()) == sources[i]) match[ indexes[i] ] = i; } //判断逆序判断能否替换，若可以则逆序替换； for(int i=S.size()-1;i&gt;=0 ;i--){ if(match[i] != -1){ S.replace(i, sources[match[i]].size(), targets[match[i]] ); } cout&lt;&lt; S &lt;&lt; endl; } return S; } };","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/833-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%9B%BF%E6%8D%A2/"},{"title":"面试题53 - II. 0～n-1中缺失的数字","text":"好菜啊，二分都不会了写了出了三个bug，还好检查的快。 Leecode的无调试debug还是相当锻炼人的。 简单思路：hash一下每个数据，找出空白值即可。 二分思路：依据前半部分有nums[i] == i的性质，和后半部分nums[i] ！= i的不同可以二分数据，从而找出错位的第一个数据。但是错位的数据不一定是缺少的数据，如果i==len(nums)就可能有缺失数据n−1n−1的可能性。 123456789101112131415161718192021222324252627282930313233cppclass Solution {public:// int missingNumber(vector&lt;int&gt;&amp; nums) {// int len = nums.size();// int *hs = new int[len + 1];// //未初始化，或者说函数中new的数组初始状态非零// memset(hs,0, sizeof(int) * (len + 1) );// for(int i = 0;i &lt; len ; ++i) hs[nums[i]] = 1;// for(int i = 0;i &lt; len + 1; ++i)// if( hs[i] == 0) // return i; // return 0;// }// }; int missingNumber(vector&lt;int&gt;&amp; nums) { int right = nums.size() - 1, left = 0, mid = right; //bug1 边界情况 if(nums[right] == right) return right + 1; while(left &lt; right){ mid = (left + right) / 2; //bug2 二分错误 if( nums[mid] == mid ) left = mid + 1; else if( nums[mid] != mid) right = mid; } //bug3 mid值没被更新, 而 left 和 right 都可以 return left; w }};","link":"/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9853-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"PAT 1043 二叉树重建","text":"搜索二叉树的前序列推出整个二叉树或者推出后序列思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点； 难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界； PAT 1043 1234567891011121314151617181920212223242526272829303132333435363738394041其实有点意思柳神的代码比我的构思好多了vector&lt;int&gt;pre,post;bool isMirror;void checkPre(int root,int tail)//【root，tail】{ if(root&gt;tail) return;//! 空节点退出 int i=root+1,j=tail; if(!isMirror) { //!while退出之时 就是到了另一个子树序列的开头与结尾 while(i&lt;=tail&amp;&amp;pre[root]&gt;pre[i]) i++; while(j&gt;root&amp;&amp;pre[root]&lt;=pre[j]) j--;//!若该序列是二叉搜索树则必有i==j+1 } else { while(i&lt;=tail&amp;&amp;pre[root]&lt;=pre[i]) i++; while(j&gt;root&amp;&amp;pre[root]&gt;pre[j]) j--; } if(i-j!=1) return;//!由于树可能不存在 需要处理异常情况 checkPre(root+1,j); checkPre(i,tail); post.push_back(pre[root]);//!前序遍历压入当前根节点；}int main(){ int n, flag = 1; scanf(&quot;%d&quot;,&amp;n); pre.resize(n+1); for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;pre[i]); checkPre(0,n-1); if(post.size()!=n)//! 不为二、 printf(&quot;YES\\n&quot;); for(int i=0; i&lt;n; i++) { printf(&quot;%d&quot;,post[i]); printf(&quot;%c&quot;,i!=n-1?' ':'\\n'); } } else printf(&quot;NO\\n&quot;);}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/PAT/PAT-1043-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%8D%E5%BB%BA/"},{"title":"PAT风格二叉树总结","text":"总结一下PAT出现的所有树的套路 前序中序转后序1234567891011121314151617181920212223242526272829303132int post[40], n, pos = 0;vector&lt;int&gt; pre, in;stack&lt;int&gt;s;void dfs(int l1, int h1, int l2, int h2){ if(l1 &gt; h1) return; int k = l2; for(;in[k]!=pre[l1];k++); dfs(l1 + 1, l1 + k - l2, l2 , k - 1); dfs(l1 + k - l2 + 1, h1, k + 1, h2); post[pos++] = pre[l1];}int main(){ int t; cin &gt;&gt; n; for(int i =0 ;i &lt; 2 * n; i++){ string a; cin &gt;&gt; a; if(a[1] == 'u'){ cin &gt;&gt; t; s.push(t); pre.push_back(t); }else{ in.push_back(s.top()); s.pop(); } } dfs(0, n - 1, 0, n - 1); for(int i = 0;i &lt; n; i++){ if(i == n - 1) cout &lt;&lt; post[i]; else cout &lt;&lt; post[i] &lt;&lt; ' ' ; }} BST + CMT 转层序12345678910111213141516171819int cbst[2000], n, pos = 1, in[2000];int dfs(int u){ if(u &gt; n ) return 0; dfs(u * 2); cbst[u] = in[pos++]; dfs(u * 2 + 1);}int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; in[i]; } sort(in + 1, in + n + 1); dfs(1); for(int i = 1;i &lt;= n; i++){ if(i == n ) printf(&quot;%d&quot;, cbst[i]); else printf(&quot;%d &quot;, cbst[i]); }} 前序中序转后序12345678910111213141516171819202122232425262728vector&lt;int&gt; in, post, pre;int n, flag = 1;void dfs(int l1, int h1, int l2, int h2){ if(l1 &gt;= h1){ if(l1 == h1) in.push_back(pre[l1]); // l1 &gt; h1时 才能压入 否则是错误的 return; } int k = l1 + 1; while(k &lt;= h1 &amp;&amp; pre[k] != post[h2 - 1]) k++; if(k == l1 + 1) flag = 0; dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2 ); in.push_back(pre[l1]); dfs(k, h1, l2 + k - l1 - 1, h2 - 1 );}int main(){ cin &gt;&gt; n; post.resize(n); pre.resize(n); for(int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; dfs(0, n - 1, 0 , n - 1); if(flag) cout &lt;&lt; &quot;Yes\\n&quot;; else cout &lt;&lt; &quot;No\\n&quot;; for(int i = 0; i &lt; n; i++) if(i == n - 1) printf(&quot;%d\\n&quot;, in[i]); else printf(&quot;%d &quot;, in[i]);} 层序中序转前序后序这个问题也非常的巧妙，本来是一个层次遍历划分出一个父节点，但是下一步左右子树划分却成了问题，这个算法有一次刷新了我的世界观。使用中序遍历的思想，在层次遍历中查询每一个节点的归属父节点的左子树还是右子树 12345678910111213141516171819202122232425262728293031323334353637383940const ll mod = 1000000007;int tree[40][2], val[40], n;int in[40];vector&lt;int&gt; pre, post, lay;int build(vector&lt;int&gt; lay, int l, int r){ if(l &gt; r) return 0; int k = 1; while(lay[0] != in[k]) k++; vector&lt;int&gt; llay, rlay; for(int i = 1;i &lt; lay.size(); i++){ int isl = 0; for(int j = l; j&lt; k; j++) if(lay[i] == in[j]){ isl = 1; break; } if(isl) llay.push_back(lay[i]); else rlay.push_back(lay[i]); } pre.push_back(in[k]); tree[k][0] = build(llay, l, k - 1); tree[k][1] = build(rlay, k + 1, r); post.push_back(in[k]); return k;}int main(){ cin &gt;&gt; n; lay.resize(n); int root = 0; for(int i = 0;i &lt; n; i++) cin &gt;&gt; lay[i]; for(int i = 0;i &lt; n; i++) cin &gt;&gt; in[i + 1]; root = build(lay, 1, n); for(int i = 0;i &lt; n;i++) if(i == n - 1) printf(&quot;%d\\n&quot;, pre[i]); else printf(&quot;%d &quot;, pre[i]); for(int i = 0;i &lt; n;i++) if(i == n - 1) printf(&quot;%d\\n&quot;, post[i]); else printf(&quot;%d &quot;, post[i]);} 判断完全二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int tree[200][2], n, ingree[200], root, lastnood, flag = 1;int bfs(int u){ int tn = 1; queue&lt;int&gt; que; que.push(u); while(que.size()){ int v = que.front(); que.pop(); lastnood = v; if(tree[v][0] == -1){ if(tn != n) flag = 0; }else{ que.push(tree[v][0]); tn++; } if(tree[v][1] == -1){ if(tn != n) flag = 0; }else{ que.push(tree[v][1]); tn++; } }}int main(){ fill(tree[0], tree[0] + 200 * 2 , - 1 ); cin &gt;&gt; n; for(int i = 0;i &lt; n; i++) { string a, b; cin &gt;&gt; a &gt;&gt; b; if(a != &quot;-&quot;){ int v = atoi(a.c_str()); tree[i][0] = v; ingree[v] ++; } if(b != &quot;-&quot;) { int v = atoi(b.c_str()); tree[i][1] = v; ingree[v] ++; } } for(int i = 0; i &lt; n ;i++) if(ingree[i] == 0) root = i; bfs(root); if(flag) cout &lt;&lt; &quot;YES &quot; &lt;&lt; lastnood; else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root;} 静态链表建树12345678910111213141516171819202122232425int tree[2000][3], lay[2000], n, depest, ct = 0;int insert(int u, int val, int dep){ depest = max(depest,dep);// cout &lt;&lt; u &lt;&lt; endl; if(u == 0){ lay[dep] ++; tree[++ct][2] = val; return ct; }else if(val &lt;= tree[u][2]){ tree[u][0] = insert(tree[u][0], val, dep + 1); }else if(val &gt; tree[u][2]){ tree[u][1] = insert(tree[u][1], val, dep + 1); } return u; } int main() { int root = 0, tmp; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++){ cin &gt;&gt; tmp; root = insert(root, tmp, 1); } cout &lt;&lt; lay[depest ] &lt;&lt; &quot; + &quot; &lt;&lt; lay[depest - 1] &lt;&lt; &quot; = &quot; &lt;&lt; lay[depest] + lay[depest - 1] &lt;&lt; endl; } 判断树晴神的一道题1016 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586int tree[100][3], val[40], n, ingree[20];int navln, layer[23], isct = 1, switime;stack&lt;int&gt; s;//avlint ctavl(int root){ if(root == 0) return 0; int h1 = ctavl(tree[root][0]); int h2 = ctavl(tree[root][1]); if( abs(h1 - h2) &gt; 1) navln ++; return max(h1, h2) + 1;}//层序遍历同时存储 逆层序遍历的顺序以便调整堆！void isctree(int root){ int nt = 1; queue&lt;int&gt; que, lay; que.push(root); lay.push(1); while(que.size()){ int u = que.front(); que.pop(); int ll = lay.front(); lay.pop(); s.push(u); layer[ll] ++;// cout &lt;&lt; u &lt;&lt; endl; if( tree[u][0] ){ que.push(tree[u][0]); lay.push(ll + 1); nt ++; }else if(nt != n) isct = 0; if( tree[u][1] ){ que.push(tree[u][1]); lay.push(ll + 1); nt ++; }else if(nt != n) isct = 0; }}// 向下调整 大顶堆void downAdjust(int root){ for(int p = tree[root][0];p !=0; p = tree[root][0]){ int pp = tree[root][1]; if(val[pp] &gt; val[p]) p = pp; if(val[p] &lt; val[root]) break; swap( val[root], val[p]); switime ++; root = p; }}int main(){ string s1, s2; cin &gt;&gt; n; for(int i = 0;i &lt; n; i++){ cin &gt;&gt; val[i]; } for(int i = 1;i &lt;= n; i++){ cin &gt;&gt; s1 &gt;&gt; s2; if(s1 != &quot;-&quot;){ tree[i][0] = atoi(s1.c_str()); ingree[atoi(s1.c_str())]++; } if(s2 != &quot;-&quot;){ tree[i][1] = atoi(s2.c_str()); ingree[atoi(s2.c_str())]++; } } int rt = -1; for(int i = 0;i &lt; n; i++) if( ingree[i] == 0) rt = i;// cout &lt;&lt; rt ; ctavl(rt); if(navln != 0) cout &lt;&lt; &quot;NOT AVL TREE!!!\\n&quot; &lt;&lt; navln &lt;&lt; endl; else{ isctree(rt); int p = 1, noden = 1; while(noden == layer[p]){ noden *= 2; p++; } if(!isct) cout &lt;&lt; &quot;NOT COMPLETE TREE!!!\\n&quot; &lt;&lt; p - 1 &lt;&lt; endl; else{ while(s.size()){ int u = s.top(); s.pop(); downAdjust(u); } cout &lt;&lt; &quot;OHHHHH HEAP!!!\\n&quot; &lt;&lt; switime &lt;&lt; endl; } }}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/PAT/PAT%E9%A3%8E%E6%A0%BC%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/"},{"title":"编程完整性","text":"编程完整性编程完整性是指代码对各种输入，条件的考虑，避免出现各种各样的程序漏洞，完成对编码的需求。可以从三个测试角度考虑，功能测试、边界测试和负面测试。功能测试就是指对代码本身需要完成的功能进行编码。边界测试就是对边界数据进行测试。负面测试就是对不符合要求的输入数据进行测试。 3中错误处理方法错误处理方法就是为了把程序出现的错误转告给函数调用者。大概有三种方法，一是定义特定函数返回值为函数运行状态，但是增加了函数调用的不便，不能直接赋值给另一个函数的参数。二是定义一个全局变量，若函数调用中出现错误就改变全局变量，相比第一种方法方便很多，但是存在函数调用不检查全局变量的安全隐患。三是抛出异常，或者使用try.....catch语句定义不同状态的运行程序，可自定义异常类型，逻辑清晰，但是某些语言可能不支持。 代码鲁邦性代码鲁棒性就是指代码对异常输入，运行错误的处理的能力。因为用户和环境的错误是可能不规范的，为了让程序正确运行，养成防御性编程习惯有利于提高代码质量。最简单最实用例子就是在函数入口检查参数。","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E7%BC%96%E7%A8%8B%E5%AE%8C%E6%95%B4%E6%80%A7/"},{"title":"面16-数值的N次方","text":"题面：给一个浮点数，求出其数值的整数次方。 思路：主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。 代码：12345678910111213141516int power(double base, int exponent){ //无穷大的非法计算值 if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); unsigned int posExponent = (unsigned int)exponent; double mulBase = base, mulRes = 1; while(posExponent &gt; 0){ if(posExponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; posExponent = posExponent &gt;&gt; 1; } if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes;} 可能降低耦合更好一点 123456789101112131415161718192021double PowerWithUnsighedExponent(double base, unsigned int exponent){ //特判：基数为0；指数为0无需特判 if( equla(base, 0.0)) return 0.0; double mulRes = 1; while(exponent &gt; 0){ if(exponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; exponent = exponent &gt;&gt; 1; } return mulRes;}int power(double base, int exponent){ //无穷大的非法计算值 if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); double mulRes = PowerWithUnsignedExponent(base, exponent); if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes;}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A216-%E6%95%B0%E5%80%BC%E7%9A%84N%E6%AC%A1%E6%96%B9/"},{"title":"面5：合并数组","text":"题目将一个字符串在不新建字符串的基础上将源字符串的空格替换为%20。输入字符串和总空间长度。 思路明显就是遍历一次统计空格，计算出多余的字符数，并从后向前复制字符并替换字符。 样例1# # 代码123456789101112131415161718void replaceBlank(char str[], int length){ int len = 0, addLen = 0; for(int i = 0; str[i] != '\\0'; i++){ if(str[i] == ' ') addlen + = 2; len ++; } int endP1 = len - 1, endP2 = len + addLen - 1; if(endP2 &gt;= length) return; for(; endP1 != endP2; endP1--, endP2-- ) if(str[endP1] == ' '){ str[endP2] = '0'; str[endP2 - 1] = '2'; str[endP2 - 2] = '0' endP2 -= 2; }else str[endP2] = str[endP1]; } return;} 相关题目比如说将一个以排序的数组插入到另一个已排序的数组，并保持有序。同样从尾部插入更快。 思维再发散一下就有归并排序中的两个数组的合并问题，不过此时是创建一个辅助数组 。","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A25%EF%BC%9A%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84/"},{"title":"面试 模拟题","text":"收集一些模拟题。 面29：打印矩阵题面：给出一个N*M的矩阵，按照从里到外的顺序顺时针打印矩阵。 思路：（代码一）模拟题就是硬上。由于整个打印过程可以看成一圈圈的打印，所以按圈地打印。同时为了保持打印动作的一致行，都是打印一行或者一列差一个单元矩阵。 不考虑上面的一致性，直接考虑填涂条件的话，也就复杂一点点。 代码：一种可以优美的实现N*N的正方形矩阵填充的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;void printNumberRect(int n, int m){ vector&lt;vector&lt;int&gt; &gt; rect; rect.resize(n); for(int i = 0; i &lt; rect.size(); i++) rect[i].resize(m); int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1; int counter = 1; while(xLeftUp &lt;= xRightDown &amp;&amp; yLeftUp &lt;= yRightDown){ for(; y &lt; yRightDown; y++){ rect[x][y] = counter; counter++; } for(; x &lt; xRightDown; x++){ rect[x][y] = counter; counter++; } for(; y &gt; yLeftUp; y--){ rect[x][y] = counter; counter++; } for(; x &gt; xLeftUp; x--){ rect[x][y] = counter; counter++; } x++; y++; xLeftUp++; yLeftUp++; xRightDown--; yRightDown--; } if(xLeftUp == xRightDown + 2 &amp;&amp; yLeftUp == yRightDown + 2 ) rect[x - 1][y - 1] = counter; for(int i = 0; i &lt; rect.size(); i++){ for(int j = 0; j &lt; rect[i].size(); j++) printf(&quot;%d &quot;, rect[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;);}int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); printNumberRect(0, 0); printNumberRect(2, 3); printNumberRect(6, 3); printNumberRect(3, 3);} 就直接填写。 1234567891011121314151617181920212223242526272829303132333435363738394041void printNumberRect(int n, int m){ vector&lt;vector&lt;int&gt; &gt; rect; rect.resize(n); for(int i = 0; i &lt; rect.size(); i++) rect[i].resize(m); int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1; int counter = 1; while(xLeftUp &lt;= xRightDown &amp;&amp; yLeftUp &lt;= yRightDown){ for(; y &lt;= yRightDown; y++){ rect[x][y] = counter; counter++; } for(x++, y--; x &lt;= xRightDown; x++){ rect[x][y] = counter; counter++; } //横着画可能会重叠 for(x--, y--; y &gt;= yLeftUp &amp;&amp; x &gt; xLeftUp; y--){ rect[x][y] = counter; counter++; } //同上 for(y++, x--; x &gt; xLeftUp &amp;&amp; y &lt; yRightDown; x--){ rect[x][y] = counter; counter++; } x++; y++; xLeftUp++; yLeftUp++; xRightDown--; yRightDown--; } for(int i = 0; i &lt; rect.size(); i++){ for(int j = 0; j &lt; rect[i].size(); j++) printf(&quot;%d &quot;, rect[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;);}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95-%E6%A8%A1%E6%8B%9F%E9%A2%98/"},{"title":"面试素质","text":"面试官希望面试者所展现的素质如下： 沟通能力 能够清晰表达项目的具体细节和大体流程，可以流畅的表述出对技术、做法的看法 要求逻辑清晰，详略得当，重点突出，观点明确 会主动与提问者沟通项目或者问题中不清楚的地方 对于外企而言流畅的英语交流是必须的 学习能力 知识迁移能力","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E7%B4%A0%E8%B4%A8/"},{"title":"面试题 DP 贪心","text":"收集贪心、DP面试题 面14：剪绳子题面：将一串长为K的绳子剪成m（m&gt;=2，各段长度取整数值）段，各段的长度大于0，求出最大的各段绳子长度之积。 思路1：由乘法交换律可知绳子的乘积可以分解，提取出来。所以有f(m+n)=f(n)*f(m)，其中f(n)是长度n的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件f(1) = 1, f(2) = 2, f(3) = 3。同时在DP表示式为： f(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i) 所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。 思路2：另一种就是贪心，对于长度m大于5的绳子尽可能的剪成长度为3的绳子，同时如果m%3==1，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:$$if \\ n \\geq 53*(n-3) \\geq n2*(n-2) \\geq n3*(n -3 ) \\geq 2*(n-2)$$ 测试：123456789101122,32,56,69 代码：DP 12345678910111213141516171819202122int maxProduct_DP(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int* products = new int[length + 1]; //初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大 products[0] = 0; products[1] = 1; products[2] = 2; products[3] = 3; for(int i = 4; i &lt;= length; i++){ int mavV = 0; for(int j = 1; j &lt;= i / 2; j++){ maxV = max(maxV, products[i - j] * products[j]); } products[i] = maxv; } int res = products[length]; //防止内存泄漏 del[] products; return res;} 贪心 123456789int maxProduct_greedy(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int timesOf3 = length / 3; if(legnth % 3 == 1) timesOf3 -= 1; int timesOf2 = (length - timesOf3 * 3) / 2; return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);} 面42：最大子数组和题面：如题 思路：DP思想。数组之间的选择与历史无关，可以采取DP的方法。记f(i)为以A[i]为结尾的最大数组和。转移方程为： f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0 当然也可以直接从数据的角度理解，代码都是相同的。 代码：123456789101112int MaxSumOfSubArray(int A[], int length){ int dp[] = new int(length); int maxSum = A[0]; dp[0] = A[0]; for(int i = 1; i &lt; length; i++){ dp[i] = max(A[i], A[i] + dp[i-1]); maxSum = max(dp[i], maxSum); } delete[] dp; return maxSum; } 当然这里的dp数组也可以不要。 面45：把数字排成最小的数字题目：给定一串数字，组合成的一个数字。求出组合后最小数字的 思路：可以直接贪心+反证。按字典序排序数字即可。 代码：就不写了，直接string排序输出即可。 面46：数字翻译成字符串题目：把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。 思路：第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。 第二种用DP思想，考虑dp[i]为从0到i的字符串翻译方法。状态转移方程为： dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else 代码：123456789101112131415int GetTranslateCount(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int dp[] = new int(length); dp[0] = 1; for(int i = 1; i &lt; length; i++){ int add = A[i - 1] * 10 + A[i]; if( add &gt; 9 &amp;&amp; add &lt; 26){ if(i &lt; 2) dp = dp[i - 1] + 1; else dp[i] = dp[i - 1] + dp[i - 2]; } else dp[i] = dp[i - 1]; } delete[] dp; return dp[length - 1]; } 面47：礼物的最大价值题目：从一在格子上装满礼物的m*n的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。 思路：明显就是DP 代码：不写了。 面48：最长不含重复字符的子字符串题目：如题 思路：暴力不可取。 采用用DP思想，考虑dp[i]为以S[i]为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断S[i]的前一个相同字符是否在上一个S[i-1]为结尾的最长不重复字符串之内。记上一个字符与S[i-1]的长度d为i - POS。 状态转移方程为： dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else 代码：12345678910111213141516171819int MaxSubStr(String s){ int dp[] = new int(s.length()); int pos[26]; for(int i = 0; i &lt; 26; i++) pos[[i] = -1; int maxL = 1; dp[0] = 1; for(int i = 1; i &lt; s.length(); i++){ int d = i - pos[s[i] - 'a']; if(dp[i - 1] &lt; d){ dp[i] = dp[i - 1] + 1; }else dp[i] = d; maxL = max(maxL, dp[i]); pos[s[i] - 'a'] = i; } delete[] dp; return maxL; }","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-DP-%E8%B4%AA%E5%BF%83/"},{"title":"面试题-二分","text":"收集查找二分查找相关题目 面11：旋转数组 题面：旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。 思路：一种就是直接遍历。 更快地可是使用二分法查找元素。依据二分法，记指针有A，B，mid；。若有数组array[mid]&gt;=array[A]则有mid在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则mid在后一个移动过的区间，应该向前半部分二分。 但是由于题面说数据可能不是递增的，所以可能出现array[A]=array[mid]=array[B]的情况，这时如果mid指向移动过的区间就会出现错误，比如1,0,1,1,1，A=0,B=4,mid=2。如何避免呢？只能是直接遍历。 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了array[mid]&lt;=array[A]且array[mid]&gt;array[B]，这个假设一提出来就显得非常的荒谬了。 样例：1234,5,6,7,1,2,31,1,0,1,1,1,11,1,1,1,0,1,1 代码:123456789101112131415161718int Min(int* numbers, int length){ if(numbers == null || length &lt;= 0) throw new std::exception(&quot;Invalid parameters&quot;); int start = 0, end = length - 1, mid; while(start &lt; end){ int mid = ((end - start) &gt;&gt; 1) + start; if(numbers[start] == numbers[mid] == numbers[end] ){ int minNum = numbers[0]; for(int i = 1; i &lt; length; i++) if( numbers[i] &lt; minNum) minNum = numbers[i]; return minNum; } if(numbers[mid] &gt;= numbers[start]) start = mid + 1; else end = mid; } return numbers[end]; } 面53:(待完成)题面：旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。 思路：一种就是直接遍历。 更快地可是使用二分法查找元素。依据二分法，记指针有A，B，mid；。若有数组array[mid]&gt;=array[A]则有mid在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则mid在后一个移动过的区间，应该向前半部分二分。 但是由于题面说数据可能不是递增的，所以可能出现array[A]=array[mid]=array[B]的情况，这时如果mid指向移动过的区间就会出现错误，比如1,0,1,1,1，A=0,B=4,mid=2。如何避免呢？只能是直接遍历。 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了array[mid]&lt;=array[A]且array[mid]&gt;array[B]，这个假设一提出来就显得非常的荒谬了。 样例：1234,5,6,7,1,2,31,1,0,1,1,1,11,1,1,1,0,1,1 代码:","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%8C%E5%88%86/"},{"title":"面试题 二叉树","text":"收集二叉树相关题目，相关测试代码见此。 sCmd = ‘C:; cd C:\\Users\\xusx\\Sumo\\SUMO\\bin; duarouter -n xsxlankershim.net.xml –route-files xsx.flow.xml -o rou.rou.xml’os.system(sCmd) 结构12345struct BinaryTreeNode{ double dbValue; BinaryTreeNode *pLeft; BinaryTreeNode *pRight; } 面7：中序遍历和前序遍历序列来重建二叉树1234567891011121314151617181920212223242526272829303132333435BinaryTreeNode* ConstructNode(int *startPreorder, int *endPreordrer, int *startInorder, int *endInorder){ //这个代码健壮性就很好！对空值和非法输出进行了区分。 if(startPreorder &gt; endPreorder || startInorder &gt; endInorder ){ if(startPreorder == endPreorder - 1 &amp;&amp; startInorder == endInorder - 1) return nullptr; else throw std::exception(&quot;Invalid Input.\\n&quot;); } //寻找中序遍历中的根节点值坐标 int nodeValue = startPreordre[0]; int *rootInorder = startInorder; for(; rootInorder &lt;= enInorder &amp;&amp; *rootInordre != nodevalue; rootInorder++); //健壮一下 if(enInorder &lt; rootInorder){ throw std::exception(&quot;Invalid input!\\n&quot;); } //构建左右子树 BinaryTreeNode* pNode = new BinaryTreeNode(); int lNodeNum = rootInorder - startInorder; pNode-&gt;pLeft = ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1); pNode-&gt;pRight = ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder); pNode-&gt;value = nodeValue; return pNode; }BinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length){ //length == 0的代码的健壮性显然不如 length &lt;= 0 if(preorder == null || inorder == null || length &lt;= 0) return nullptr; return ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1); } 面8：二叉树的下一个节点第一次考虑的时候居然还想错了，分析不够全面。从二叉树中序遍历来看，若一个节点有右子树，则下一个节点就是其右子树的最左节点。倘若没有，则必然是考虑父亲节点。如果该节点是父亲节点的左子节点，那么下一个节点就是父亲节点，不然可以溯源查找其父辈节点是左子树的祖父节点。这个过程可以使用父亲节点和迭代完成。 1234567891011121314151617BinaryTreeNode *GetNext(BinaryTreeNode *pNode){ if(pNode == nullptr) return; if(pNode-&gt;pRight){ BinaryTreeNode* pChild = pNode-&gt;pRight; while(pChild-&gt;pLeft != nullptr) pChild = pChild-&gt;pRight; return pChild; }else{ BinaryTreeNode* pParent = pNode-&gt;pParent, *pCurrent = pNode; //循环控制条件有点像哨兵，没有找到的话pParent自然就是unllptr,代码更加简洁了 while(pParent != nullptr &amp;&amp; pParent-&gt;pRight != pCurrent){ pCurrent = pParent; pParent = pParent-&gt;pParent; } return pParent; } return nullptr;} 相比之前的代码这个写法差一点点 12345678while(pParent-&gt;pParent != nullptr &amp;&amp; pParent-&gt;pRight != pCurrent){ pCurrent = pParent; pParent = pParent-&gt;pParent; } if(pParent-&gt;pRight == pCurrent){ return pParent; } 面26：树的子结构题面：输入两棵树A和B，判断B是否是A的子结构。B是A的子结构子结构定义为A的一部分和B完全相同。 思路：递归的判断对A的每一个节点判断该节点下的是否有B的结构。 代码：12345678910111213141516171819202122232425bool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot2 == nullptr) return true; else if(pRoot1 == nullptr) return false; if(equal(pRoot1-&gt;dbValue, pRoot2-&gt;dbValue)){ if(pRoot2-&gt;pRight == nullptr &amp;&amp; pRoot2-&gt;pLeft == nullptr) return true; return judgeSameTree(pRoot1-&gt;pLeft, pRoot2-&gt;pLeft) &amp;&amp; judgeSameTree(pRoot2-&gt;pRight, pRoot2-&gt;pRight); } return false;}bool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot1){ if(judgeSameTree(pRoot1, pRoot2)) return true; else return HasSubtreeCore(pRoot1-&gt;pLeft, pRoot2) || HasSubtreeCore(pRoot1-&gt;pRight, pRight); } return false;}bool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot2 == nullptr) return true; if(pRoot1 == nullptr) return false; return HasSubtreeCore(pRoot1, pRoot2); } 测试：参见 面27：翻转二叉树题面：给出一棵二叉树并返回其镜像二叉树。 思路：直接交换节点的左右指针节点即可。 代码：123456789BinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode){ if(pNode == nullptr) return nullptr; BinaryTreeNode *pTemp = pNode-&gt;pRight; pNode-&gt;pRight = pNode-&gt;pLeft; pNode-&gt;pLeft = pTemp; MirrorRecursively(pNode-&gt;pLeft); MirrorRecursively(pNode-&gt;pRight); return pNode; } 面28：对称二叉树题面：判断一棵树是否对称。 思路：从第一个节点左子树开始递归的判断，其右子树的节点是否完全相同。只需要一边对另一边镜像操作就ok。 代码：12345678910111213bool isSymmetrical(BinaryTreeNode* pHead){ if(pHead == nullptr) return true; return isSymmetricalCore(pHead-&gt;pLeft, pHead-&gt;pRight);}bool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2){ if(p1 == nullptr &amp;&amp; p2 == nullptr) return true; if(p1 == nullptr &amp;&amp; p2 != nullptr || p2 == nullptr &amp;&amp; p1 != nullptr || p1-&gt;value != p2-&gt;value) return false; return isSemmetricalCore(p1-&gt;left, p2-&gt;right) &amp;&amp; isSemmetricalCore(p1-&gt;right, p2-&gt;left); } 有趣的是，我这种写法也可以看成前序遍历序列和对称前序遍历序列的比较。 面32：层序遍历二叉树题面：如标题 思路：层序遍历 代码：12345678910111213void PrintByLayer(BinaryTreeNode* pHead){ if(pHead == nullptr) return; queue&lt;BinaryTreeNode*&gt; que; que.push(pHead); while(que.size()){ BinaryTreeNode *pNode = que.front(); que.pop(); printf(&quot;%.2f &quot;, pNode-&gt;dbValue); if(pNode-&gt;pLeft) que.push(pNode-&gt;pLeft); if(pNode-&gt;pRight) que.push(pNode-&gt;pRight); } printf(&quot;\\n&quot;);} 面32相关题：分行打印层序遍历二叉树题面：如标题 思路：在层序遍历的基础上，有两种解题思路：一是记录当前层未打印的节点数量和下一层的需要打印的节点数量，二是在队列中添加一个一层的节点末端的标志符、 代码：123456789101112131415161718192021222324252627void PrintByLayerSparate(BinaryTreeNode* pHead){ if(pHead == nullptr) return; queue&lt;BinaryTreeNode*&gt; que; que.push(pHead); int printValue = 1, nextValue = 0; while(que.size()){ BinaryTreeNode *pNode = que.front(); que.pop(); printValue--; printf(&quot;%.2f &quot;, pNode-&gt;dbValue); if(pNode-&gt;pLeft){ que.push(pNode-&gt;pLeft); nextValue++; } if(pNode-&gt;pRight){ que.push(pNode-&gt;pRight); nextValue++; } if(printValue == 0){ printValue = nextValue; nextValue = 0; printf(&quot;\\n&quot;); } } } 面32相关题：之字形打印二叉树题面：如标题 思路：一种方法就是分层层序遍历+栈逆序存储并输出。 第二种方法就用栈把一层的节点逆序输出，并将下一层的节点记录在另一个栈中，如此循环，输出所有的层。 代码：123456789101112131415161718192021222324void PirntZhi(BinaryTreeNode *pHead){ if(pHead == nullptr) return; stack&lt;BinaryTreeNode*&gt; s[2]; int cur = 0; s[cur].push(pHead); BinaryTreeNode *pNode = nullptr; while(s[cur].size()){ while(s[cur].size()){ pNode = s[cur].top(); s[cur].pop(); printf(&quot;%.2 &quot;, pNode-&gt;dbValue); if(cur == 0){ if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft); if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight); }else{ if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight); if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft); } } printf(&quot;\\n&quot;); cur = 1- cur; } } 面33:判断后序遍历序列有效性题面：给定一颗二叉搜索树的后续遍历序列，判断该后序遍历序列是否合法。 思路：依据后续遍历的定义，可以把序列依据最后一个元素K分成两半，且满足前一部分全部小于K的值，后一部分全部大于K的值，若不符合这个结论，则该后序遍历不可能存在一颗二叉树与之对应。递归的判断这两部分是否符合这些定义。 代码：12345678910111213141516bool isPostSequenceCore(int sequence[], int start, int end){ if(start &gt;= end) return true; int key = sequence[end - 1]; int split = start; while(sequence[split] &lt; key) split++; for(int i = split; i &lt; end; i++){ if(sequence[i] &lt; key) return false; } return isPostSequenceCore(sequence, start, split) &amp;&amp; isPostSequenceCore(sequence, split, end - 1);}bool isPostSequence(int sequence[], int len){ if(sequence == nullptr || len &lt;= 0) return false; return isPostSequenceCore(sequence, 0, len);} 如果是c++的话，也可以直接用指针代替start。 面34：树的路径的元素之和题面：打印出树的路径上的值之和与给定数字相同的所有路径。路径从根到叶子。 思路：dfs遍历 + 记录路径即可。 代码：12345678910111213141516171819202122232425262728293031323334void PrintPathCore(BinaryTreeNode* pNode, stack&lt;int&gt; &amp;s, int add, int expectedSum){ s.push((int)pNode-&gt;dbValue); add += (int)(pNode-&gt;dbValue); if(pNode-&gt;pLeft == nullptr &amp;&amp; pNode-&gt;pRight == nullptr){ if(add == expectedSum){ stack&lt;int&gt; sTemp; while(s.size()){ sTemp.push(s.top()); s.pop(); } while(sTemp.size()){ printf(&quot;%d-&gt;&quot;, sTemp.top()); s.push(sTemp.top()); sTemp.pop(); } printf(&quot;\\n&quot;); } // printf(&quot;%d, %d, %d\\n&quot;, expectedSum, add, s.size()); s.pop(); return; } if(pNode-&gt;pLeft) PrintPathCore(pNode-&gt;pLeft, s, add, expectedSum); if(pNode-&gt;pRight) PrintPathCore(pNode-&gt;pRight, s, add, expectedSum); s.pop();}void PrintPath(BinaryTreeNode* pHead, int expectedSum){ if(pHead == nullptr) return; stack&lt;int&gt; s; PrintPathCore(pHead, s, 0, expectedSum); printf(&quot;\\n&quot;);} 中午时间不要打代码，太困了 面36：把二叉搜索树转化为双向链表（同链表中的内容）题面：如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。 思路：可以从递归的角度入手。对于一个节点A，中序遍历到A，则A的左子树已经转化为了链表，连接好A和A的左子树的最大节点（前一个指针）的指针则连接完成。 那对于A的右子树的最小节点B与A之间的连接，也可以看成B与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。 注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。 对于一个节点A的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点B的指针，并设置好B的右指针和A的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是NULL，所以无需修改。 代码：1234567891011121314151617void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead){ if(pRoot == nullptr) return; AdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead); if(pHead == nullptr) pHead = pRoot; pRoot-&gt;pLeft = preNode; if(preNode) preNode-&gt;pRight = pRoot; preNode = pRoot; AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead);}BinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){ BinaryTreeNode *preNode = nullptr; BinaryTreeNode *pHead = nullptr; AdjustLinkCore(pRoot, preNode, pHead); return pHead;} 面36：序列化和反序列化二叉树题面：序列化定义： 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。 二叉树的序列化可以把非空节点的值序列化，把空节点序列化为$。 思路：由于序列化把空节点的信息也包含进来了，所以无需添加更多序列。 这题更像流的应用题 代码：123456789101112131415161718192021void Serialize(BinaryTreeNode *pRoot, ostream&amp; stream){ if(pRoot == nullptr){ stream &lt;&lt; '$'; return; } stream &lt;&lt; pRoot-&gt;value &lt;&lt; ','; Serialize(pRoot-&gt;pLeft); Serialize(pRoot-&gt;pRight); }void Deserialize(BinaryTreeNode *&amp;pRoot, istream&amp; stream){ int number; if(ReadSteam(stream, &amp;number)){ pRoot = new BinaryTreeNode(); pNew-&gt;pLeft = nullptr; pNew-&gt;pRight = nullptr; pNew-&gt;value = number; } Deserialize(pRoot-&gt;pLeft, stream); Deserialize(pRoot-&gt;pRight, steam); }","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"面试题-位运算","text":"收集位运算相关的题目。 判断1的个数 题面：给出一个整数K，判断其二进制中1的个数。 思路1：典型的二进制题目，可以使用与运算判断数字K某一位是否是1。巧妙的是，既可以在运算中移位K，也可以位移flag。显然后面一种可以避免K数字为负而导致的高位填零的右移问题。 思路2：更巧妙的方法，是考虑到K-1后会把K的第一个低位1和之后的0全部取饭，此时K &amp; (K -1)相比于K会少一个低位1。如此反复操作便可统计所有1的个数。 思路扩展：判断一个数是2的整数次；对于数字m需要改变多少位才能变成数字n。 代码：思路1 12345678int NumberOf1(int n){ int flag = 1, count = 0; while(flag){ if(flag &amp; n) count++; falg = flag &lt;&lt; 1; } return count;} 思路2 12345678int NumberOf1(int n){ int count = 0; while(n){ count ++; n = (n - 1) &amp; n; } return count;}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"面试题-回溯DFs","text":"收集回溯相关题目 面13 面12和13很相似，不重复写了。 题面：在一个字符矩阵中寻找一条路径，路径上的字符从头到尾排列起来是给定的字符串s。判断有无这么一条路径。 思路：DFS或者说和回朔直接暴力搜。 代码：12345678910111213141516171819202122232425262728bool hasPathCore(char *matrix, int rows, int cols, int row, int col, char *str, int strIdx, int &amp;isFound){ if(strIdx &lt; 0){ isFound = 1; return true; } if(isFound) return true; visited[row * cols + col] = 1; int dX[] = {0, 0, -1, 1}, dY[] = {-1, 1, 0, 0}; for(int i = 0; i &lt; 4; ++i){ int nX = dX[i] + row, nY = dY[i] + col, p = row * cols + col; if( nX &gt;= 0 &amp;&amp; nY &gt;= 0 &amp;&amp; nX &lt; rows &amp;&amp; nY &lt; cols &amp;&amp; !visited[p] &amp;&amp; str[strIdx] == matrix[p]) hashPathCore(matrix, rows, cols, row, col, str, strIdx - 1); }}bool hasPath(char *matrix, int rows, int cols, char *str, int length){ if(str == nullptr || matrix == nullptr) throw new std::exception(&quot;Invalid parameters.&quot;); int visited = new int[rows * cols], isFound = 0; memset(visited, 0, sizeof(visited)); for(int i = 0; i &lt; rows; ++i) for(int j = 0; j &lt; cols; ++j) if( hasPathCore(matrix, rows, cols, i, j, str, length - 1, isFound)){//倒着搜 del[] visited; return true; }}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9B%9E%E6%BA%AFDFs/"},{"title":"面试题-大数","text":"大数相关 面17：打印从1到最大的n位数题目：如题 思路1：明显的太简单了。坑还是在数据范围上，考虑使用大数加法模拟计算。 思路2：也可以使用全排列的思路，思考除了开头为0的n个0~9数字的排列组合就是题目所要求的的数据。 代码：大数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;bool isIncreaseDigit(int *numbers, char* n){ for(int i = 0; n[i] != '\\0'; i++) if(numbers[i] != n[i] - '0') return true; return false;}void PrintNumber(int *numbers, int MAXLEN){ int idx = MAXLEN - 1; while(idx &gt;= 0 &amp;&amp; numbers[idx] == 0) idx --; for(int i = idx; i &gt;= 0; --i) putchar(numbers[i] + '0'); putchar('\\n');}void Print1ToMaxDigits(char *n){ const int MAXLEN = 1000; if(n == nullptr || strlen(n) &lt;= 0 || strlen(n) &gt;= MAXLEN) return; char test0[2] = &quot;0&quot;; if(strcmp(test0, n) == 0){ printf(&quot;0\\n&quot;); return; } //reverse the input string char *newN = new char(MAXLEN); int lenN = strlen(n); for(int i = 0; i &lt; lenN; i++) newN[lenN - i - 1] = n[i]; //big data. int *numbers = new int[MAXLEN]; memset(numbers, 0, sizeof(numbers)); //Calculate the numbers. while(isIncreaseDigit(numbers, newN)){ numbers[0]++; int idx = 0; while(numbers[idx] == 10){ numbers[idx] = 0; ++idx; numbers[idx]++; } PrintNumber(numbers, MAXLEN); } delete []numbers; }int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); char a[5] = {&quot;1239&quot;}; Print1ToMaxDigits(a);} 全排列组合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;bool isIncreaseDigit(int *numbers, char* n){ for(int i = 0; n[i] != '\\0'; i++) if(numbers[i] != n[i] - '0') return true; return false;}void PrintNumber(int *numbers, int MAXLEN){ int idx = MAXLEN - 1; //不输出前置零和全零 while(idx &gt;= 0 &amp;&amp; numbers[idx] == 0) idx --; if(idx == -1) return; for(int i = idx; i &gt;= 0; --i) putchar(numbers[i] + '0'); putchar('\\n');}void Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &amp;flag){ if(flag) return; if(pos == -1) { //直接用flag剪枝 if(!isIncreaseDigit(numbers, newN)) flag = 1; PrintNumber(numbers, lenOfN); return; } if(!isIncreaseDigit(numbers, newN)) return; for(int i = 0; i &lt;= 9; i++){ numbers[pos] = i; Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag); }} void Print1ToMaxDigits(char *n){ if(n == nullptr || strlen(n) &lt;= 0) return; char test0[2] = &quot;0&quot;; if(strcmp(test0, n) == 0){ printf(&quot;0\\n&quot;); return; } //reverse the input string int lenOfN = strlen(n); char *newN = new char(lenOfN); for(int i = 0; i &lt; lenOfN; i++) newN[lenOfN - i - 1] = n[i]; newN[lenOfN] = '\\0'; //big data. int *numbers = new int[lenOfN]; memset(numbers, 0, sizeof(numbers)); //Calculate the numbers. int flag = 0; Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag); delete []numbers; }int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); // char a[5] = {&quot;1239&quot;}; // char a[5] = {&quot;0&quot;}; char a[50] = {&quot;100&quot;}; Print1ToMaxDigits(a); // int t1[5] = {1, 2}; // printf(&quot;%d&quot;, isIncreaseDigit(t1, a));} 把自己写懵逼了，调试了好久，原来发现自己剪枝错了。 由于判断条件在变化，而剪枝条件是不变的，所以不能在更变条件后剪枝","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%A7%E6%95%B0/"},{"title":"面试题-字符串","text":"收集字符串相关题目。 面19：正则表达式匹配题面：用一个模式串来匹配一个字符串。其中模式串中的”.”可以匹配一个任意字符，“*”表示该字符的前一个字符可以出现任意次。 思路：这题挺难的，需要有一种状态的分析角度来入手。定义一下匹配：两个串的中字符。 首先对于模式串A的字符a和字符串B的字符b的一次匹配中，记a后面的一个字符是c。假设前面的字符匹配完成。 当前有若有a=='.'且c!=*，则可以匹配任意b字符，那么模式串和字符串都继续匹配下一个字符； 若有a==char（非.和*的合法字符）且c!=*，则只能匹配成功唯一的对应的b字符，否则就匹配失败； 若有c==*且字符串中有字符可以匹配，情况变得复杂一些，从匹配的全局上讲ac可以匹配多次，一次或者不匹配，结果体现的在代码中。 若有c==*且字符串无字符可以匹配，那么ac只能什么都不匹配。 匹配失败的条件是模式串匹配完了但是字符串却没有匹配（明显的这个条件成立。而对于模式串没有匹配完成字符串匹配结束的状态不算匹配失败这是因为模式串可能有多余的*。），成功就是两个字符串同时匹配结束。 按照上面的思路，可以画出一个例子的非确定有限状态机。 image-20200525090812718 上述思路的代码可以使用递归的方式搜索可行解。 代码12345678910111213141516171819202122232425262728bool match(char *str, char *pattern){ if( str == nullptr || pattern == nullptr) return false; return matchCore(str, pattern); }bool matchCore(char *str, char *pattern){ if(*str == '\\0' &amp;&amp; *pattern == '\\0') return true; if(*str != '\\0' &amp;&amp; *pattern == '\\0') return false; if( *( pattern + 1) == '*'){ //可以匹配字符串 if(*pattern == '.' &amp;&amp; *str != '\\0' || *str == *pattern)) //不匹配 return matchCore(str, pattern + 2) || //匹配一次 matchCore(str + 1, pattern + 2) || //匹配至少一次 matchCore(str + 1, pattern); else //不匹配 return matchCore(str, pattern + 2); } else if( *pattern == '.' &amp;&amp; *str !='\\0' || *pattern == *str) return matchCore(str + 1, pattern + 1); else return false;} 错误点： 字符串匹配结束，但模式串仍未匹配结束不意味着失败，可能还有多的*。 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;bool matchCore(char *str, char *pattern){ if(*str == '\\0' &amp;&amp; *pattern == '\\0') return true; if(*str != '\\0' &amp;&amp; *pattern == '\\0') return false; if( *( pattern + 1) == '*'){ //可以匹配字符串 if(*pattern == '.' &amp;&amp; *str != '\\0' || *str == *pattern) //不匹配 return matchCore(str, pattern + 2) || //匹配一次 matchCore(str + 1, pattern + 2) || //匹配至少一次 matchCore(str + 1, pattern); else //不匹配 return matchCore(str, pattern + 2); } else if( *pattern == '.' &amp;&amp; *str !='\\0' || *pattern == *str) return matchCore(str + 1, pattern + 1); else return false;}bool match(char *str, char *pattern){ if( str == nullptr || pattern == nullptr) return false; return matchCore(str, pattern); }int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); char str[] = &quot;123145&quot;; char pattern[] = &quot;1.3*145*2&quot;; printf(&quot;%d\\n&quot;, match(str, pattern));} 面20：表示数值的字符串题面：请实现一个函数判断一个字符串是否包含一个数值，数值的合法表达方式有0.123e23、.123E1、-122。 思路：题目主要难在总结出统一的形式化表达式。首先： 数字(基数和指数）前面正负号可有可无 基数的整数和小数部分可由无，但是两个必须有一个；小数点可以出现也可以不出现 表底数符号可取e或者E，底数符号后面必须跟数字 可以总结出形式A[E|eC]，其中A都可以取模式[+|-]D[.F]或者[+|-].F，其中D和F都是整数模式。C只能取整数模式D 代码：我的思路（错误代码） 没有考虑E后面的数字不能为小数。 123456789101112131415161718192021222324252627282930313233bool findANumber(char *&amp; str){ if(isdigit(*str)){ while( isdigit(*str)) str++; return true; } return false; }bool findNumber(char *&amp; str){ if(*str == '+' || *str == '-') str++; if(*str == '.'){ str++; return findANumber(str); }else{ if(findANumber(str)){ if(*str == '.'){ str++; return findANumber(str); }else return true; } } return false;}bool isNumber(char *str){ if(findNumber(str)){ if(*str == 'E' || *str == 'e'){ str++; return findNumber(str); }else if(*str== '\\0') return true; } return false;} 对应测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;bool findANumber(char *&amp; str){ if(isdigit(*str)){ while( isdigit(*str)) str++; return true; } return false; }bool findNumber(char *&amp; str){ if(*str == '+' || *str == '-') str++; if(*str == '.'){ str++; return findANumber(str); }else{ if(findANumber(str)){ if(*str == '.'){ str++; return findANumber(str); }else return true; } } return false;}bool isNumber(char *str){ if(findNumber(str)){ if(*str == 'E' || *str == 'e'){ str++; return findNumber(str); }else if(*str== '\\0') return true; } return false;}int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); char str1[] = &quot;123145&quot;; char str2[] = &quot;-45.123&quot;; char str3[] = &quot;-.123&quot;; char str4[] = &quot;-123e-.120&quot;; char str5[] = &quot;-123B-.120&quot;; printf(&quot;%d\\n&quot;, isNumber(str5));} 书上的思路(耦合更低点) 123456789101112131415161718192021222324252627bool scanUnsignedInteger(char *&amp;str){ char *preStr = str; while(*str != '\\0' &amp;&amp; *str &gt;= '0' &amp;&amp; *str &lt;= '9') str++; return str &gt; preStr; }bool scanInteger(char *&amp;str){ if(*str == '+' || *str == '-' ) str++; return scanUnsignegInteger(str); }bool isNumberic(char *str){ bool numberic = scanInteger(str); if(*str == '.'){ str++; bool isFactor = scanUnsignedInteger(str); //小数点前后至少有一个数字 numberic = numberic || isFactor; } if(*str == 'E' || *str == 'e'){ str++; bool hasSignedNumber = scanInteger(str); //E的前后都必须要有数字 numberic = numberic &amp;&amp; hasSignedNumber; } return numberic &amp;&amp; *str == '\\0'; } 他是一种的流程化的思路来写的。 面38：字符串排列题面：给出一条字符串，打印出他的全排列。 思路：直接用递归的方法做。把字符串分成两个部分，前半部分固定，求出后半部分全排列，将两部分的内容组合起来可以得到所有字符串的全排列。 对于长度为K的字符串中后面M个字 符（0&lt;=M&lt;K），打印前半部分的字符串长和后半部分字符串的所有的全排列。递归边界为M==0。 数字(基数和指数）前面正负号可有可无 基数的整数和小数部分可由无，但是两个必须有一个；小数点可以出现也可以不出现 表底数符号可取e或者E，底数符号后面必须跟数字 可以总结出形式A[E|eC]，其中A都可以取模式[+|-]D[.F]或者[+|-].F，其中D和F都是整数模式。C只能取整数模式D 代码：1234567891011void PermutationCore(string &amp;s, int k){ if(k == s.size()) cout&lt;&lt; s &lt;&lt; endl; for(int i = k + 1; i &lt; s.size(); i++){ swap(s[i], s[k]); PermutationCore(s, k + 1); swap(s[i], s[k]); } }void Permutation(string &amp;s){ Permutation(s, 0);} 相关题目：八皇后","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"面试题-排序","text":"收集排序相关题目。 面21：调整数组使奇数位于偶数前面题面：如题 思路：一可以使用插入排序的算法，不够复杂度有点高。 二可以使用双指针，交换奇偶数即可。 代码：12345678910int ReorderOddEven(int *array, int length){ int start = 0, end = length - 1, tmp = array[0]; while(start &lt; end){ while(start &lt; end &amp;&amp; (array[end] &amp; 1 == 0)) end--; array[start] = array[end]; while(start &lt; end &amp;&amp; (array[end] &amp; 1 == 1)) start++; array[end] = array[start]; } array[start] = tmp; } 思路扩展：解耦写法 123456789101112131415161718192021bool isEven(int p){ return !(p &amp; 1); }bool isDivide3(int p){ return (p % 3);}//提供接口bool func(int p){ return isDivide3(p);}void ReorderOddEven(int *array, int length){ int start = 0, end = length - 1, tmp = array[0]; while(start &lt; end){ while(start &lt; end &amp;&amp; func(array[end])) end--; array[start] = array[end]; while(start &lt; end &amp;&amp; !func(array[start])) start++; array[end] = array[start]; } array[start] = tmp; } 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;bool isEven(int p){ return !(p &amp; 1); }bool isDivide3(int p){ return (p % 3);}bool func(int p){ return isDivide3(p);}void ReorderOddEven(int *array, int length){ int start = 0, end = length - 1, tmp = array[0]; while(start &lt; end){ while(start &lt; end &amp;&amp; func(array[end])) end--; array[start] = array[end]; while(start &lt; end &amp;&amp; !func(array[start])) start++; array[end] = array[start]; } array[start] = tmp; }int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); int c[] = {3, 0, 2, 4, 5, 6, 2, 3,5, 8}, len = sizeof(c) / 4; ReorderOddEven(c, len); for(int i = 0; i &lt; len; i++) printf(&quot;%d &quot;, c[i]); printf(&quot;\\n&quot;); }","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8E%92%E5%BA%8F/"},{"title":"面试题 数组","text":"收集一些有关于数组的问题 面试题3：数组中重复出现的数字题面：n个数据的数组有数据范围为0~n-1的数字，数组中的数字可能重复，请判断是否存在重复数字。 思路分析：简单的算法可以直接排序，时间复杂度为O(NlogN)O(NlogN)，空间复杂度为O(1)O(1)。 另一个简单的算法是直接使用hash思想，记录每一个数字的出现频次，时间复杂度为O(N)O(N)，但是空间复杂度位O(N)O(N)。 最巧妙的算法是利用分析出n个元素的数组正好排满数据范围在0~n-1的数字，且数字大小标识了升序排序的下标。可以设计出：。对于值为m元素i，若i==m,则该数字放置正确，遍历下一个数字，否则与下标为m的数字交换，交换后如果发现交换数字相同，则有重复数据。重复该过程。而因为一个数字最多被交换两次，所以时间复杂度依然是O(N)O(N)，空间复杂度为O(1)O(1)。 测试用例： 空数组 不包含重复数字的数组 包含重复数字的数组 代码：12345678910111213bool findDecEle(int array[], int arraySize){ if(array == null) return true; for(int i = 0; i &lt; arraySize; i++){ while(i != array[i]){ int temp = array[i]; array[i] = array[temp]; array[temp] = temp; if(array[i] == array[temp]) return true; } return false; } } 面试题3相关n+1个数据的数组有数据范围为0~n-1的数字，数组中的数字可能重复，请找到重复数字。同时不能改写原数组。 思路一个简单的算法就是创建一个辅助数组，并使用之前的算法——hash或者交换，时间和空间复杂度都是O(n)O(n)。 由于数据范围给定，而且这个题目背景下一定存在重复数字，可以尝试使用二分缩小重复数字所在的范围并找到它。在数字大小范围0~n-1中分出一部分数据范围为0~mid，判断数组中在该范围中的数字个数是否大于mid - 0 + 1，若是则该范围存在重复数字（也不意味这另一部分不存在重复数字），直接继续在该范围二分，否则在另一个范围二分。由于二分范围复杂度为O(logN)O(logN)，同时每次遍历判断需要O(N)O(N)所以时间复杂度共计需要O(NlogN)O(NlogN)，空间复杂度O(1)O(1)。 样例 空数组 符合题意的带重复数据的数组[1,2,2,3] 代码123456789101112131415161718192021int findDupInt(int array[], int n){ //增加鲁棒性 if(array == null || n == 0) return false; if(n &lt; 0) return -1; int start = 0, end = n - 1, mid; while(start &lt;= end){ mid = (start + end) / 2; int ct = 0; for(int i = 0; i &lt; n; i++){ if(array[i] &lt;= mid &amp;&amp; array[i] &gt;= start) ct++; } //防止有异常数据输入 if(start == end){ if(ct &gt; 1) return end; else break; } if(ct &gt; mid + 1 - start) end = mid; else start = mid + 1; } return -1; } 面试题39 数组中超过一半的数字题面：找出一个数组中数量超过一半的数字。 思路：第一种想法：排序，但是复杂度过高O(NlogN)O(NlogN)。 第二种想法：hash记录数字的出现个数，并维护最大值。但是空间开销变大了，时间O(N)O(N)。 第三种想法：快速排序中的Partition算法。时间复杂度O(N)O(N)。 第四种想法：根据题目数据性质，若存在该数据，则其出现次数多于数组长的一半。可以想到即使单单一个数据的出现次数大于其他数据出现次数之和。 那么遍历该数组，维护数字的出现次数K。 若K==0，则记录数字M，k++。 若K&gt;0，且数字与M不同，则k–。 若K&gt;0，数字与M相同，则k++。 根据上述分析，若存在则一定有M有效。时间复杂度O(N)O(N)。 重在分析和理清思路 代码：Partition 12345678910111213141516171819202122232425262728293031int Partition(int A[], int start, int end){ int temp = A[start]; while(start &lt; end){ while(start &lt; end &amp;&amp; A[end] &gt;= temp) end--; A[start] = A[end]; while(start &lt; end &amp;&amp; A[start] &lt; temp) start++; A[end] = A[start]; } A[start] = temp; return start;}int MoreThanHalfNum(int A[], int len){ if(A == nullptr || len &lt;= 0) throw new exception(); int start = 0, end = len - 1, mid = -1; while(mid != len / 2){ mid = Partition(A, start, end); if(mid &lt; len / 2) start = mid + 1; else end = start - 1; } //check the times of number whether more that the len of Array. int num = A[len / 2], counter = 0; for(int i = 0; i &lt; len; i++){ if(A[i] == num) counter++; } if(counter &gt; len / 2) return num; else throw new exception(); } 推论 123456789101112131415161718192021int MoreThanHalfNum(int A[], int len){ if(A == nullptr || len &lt;= 0) throw new exception(); int counter = 0, num = 0; for(int i = 0; i &lt; len; i++){ if(counter == 0){ counter++; num = A[i]; }else if(A[i] == num) counter++; else counter--; } //check the times of number whether more that the len of Array. int num = A[len / 2], counter = 0; for(int i = 0; i &lt; len; i++){ if(A[i] == num) counter++; } if(counter &gt; len / 2) return num; else throw new exception(); } 面试题40 最小的K个数题面：找出一个数组中第K小的数字。 思路：第一种想法：Partition。时间复杂度O(N)O(N)。 第二种想法：用堆维护一个容量为K的大顶堆。时间复杂的O(NlogK)O(NlogK)。 无需修改数组适合海量数据，但是K小的情况。 代码：Partition 123456789101112131415161718192021222324int Partition(int A[], int start, int end){ int temp = A[start]; while(start &lt; end){ while(start &lt; end &amp;&amp; A[end] &gt;= temp) end--; A[start] = A[end]; while(start &lt; end &amp;&amp; A[start] &lt; temp) start++; A[end] = A[start]; } A[start] = temp; return start;}int FindKthNumber(int A[], int k, int len){ if(A == nullptr || len &lt;= 0) throw new exception(); int start = 0, end = len - 1, mid = -1; while(mid != k - 1){ mid = Partition(A, start, end); if(mid &lt; len / 2) start = mid + 1; else end = start - 1; } return A[k-1];} 大顶堆 123456789101112131415161718int FindKthNumber(int A[], int k, int len){ if(A == nullptr || len &lt;= 0) throw new exception(); // priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; pq; priority_queue&lt;int&gt; pq; for(int i = 0; i &lt; len; i++){ if(pq.size() &lt; k) pq.push(A[i]); else{ if(pq.top() &gt; A[i]){ pq.pop(); pq.push(A[i]); } } } return pq.top();} 面试题41 数据流中的中位数题面：在线查询一个数据流种的中位数。若数组长度为偶数，则中位数为中间的两个数字的平均值。若数组长度为奇数，则中位数为中间数字。 在线查询即意味着数据会变动。 思路： 这题的精华在于思考了多种解法的可能性。 需要考虑的问题有承载数据的数据结构和查询方法。 数组 + partition。插入O(1)O(1)，查询O(N)O(N)。 排序好的数组 + 直接查询。插入O(N)O(N)，查询O(1)O(1)。 按顺序排列的链表 + 两个指向中间节点的指针。插入O(N)O(N)，查询O(1)O(1)。 理想状态的，添加子树节点数量信息的二叉树 + 查询。插入 O(logN)O(logN) ，查询 O(logN)O(logN) 。 同样的可以考虑AVL树，但是实现很慢，容易出错。 将数组看成两个部分，用一个大顶堆维护前半部分的最大值，一个小顶堆维护后半部分的最小值。插入O(logN)O(logN)，查询O(1)O(1)。 最佳算法 代码：由于是在线算法，免不了外部的数据结构，直接实现一个类也是不错的选择。 12345678910111213141516171819202122232425262728293031class MidianArray{ private: priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; minQ; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; maxQ; public: void insert(int x){ int size = minQ.size() + maxQ.size(); if ((size &amp; 1) == 0){ if(!minQ.empty() &amp;&amp; x &gt; minQ.top()){ maxQ.push(minQ.top()); minQ.pop(); minQ.push(x); }else maxQ.push(x); }else{ if(!maxQ.empty() &amp;&amp; x &lt; maxQ.top()){ minQ.push(maxQ.top()); maxQ.pop(); maxQ.push(x); }else minQ.push(x); } } int getMid(){ int size = minQ.size() + maxQ.size(); if(size == 0) throw new exception(); if( (size &amp; 1) == 0) return (minQ.top() + maxQ.top()) / 2; else return maxQ.top(); }}; 注意&amp;的优先级小于==。 我这个bug生产者。 面53:在排序数组中查找数字题面： 二分查找有序数组中数字K出现次数。C++实现可用函数指针试试。 思路：还是蛮简单的。 不过函数指针第一次使用，其中类中的非静态函数指针写法比较复杂，直接把函数改成静态了。 代码123456789101112131415161718192021222324252627class Solution {public: static int firstKJudge(int x, int K){ return x &lt; K; } static int firstGKJudge(int x, int K){ return x &lt;= K; } int binary_find(int (*judge)(int, int), vector&lt;int&gt; A, int len, int K){ int start = 0, end = len, mid ; while(start &lt; end){ mid = (start + end) / 2; if(judge(A[mid], K)) start = mid + 1; else end = mid; } return end; } int search(vector&lt;int&gt;&amp; nums, int target) { // typedef int (Solution::*fp)(int x, int K); // fp func = &amp;Solution::firstKJudge; int startIdx = binary_find(Solution::firstKJudge, nums, nums.size(), target); int endIdx = binary_find(Solution::firstGKJudge, nums, nums.size(), target); return endIdx - startIdx; }}; 面53 题目二:缺失的数字题面：大小在0~n-1的不同且有序的n-1个数字中，查找缺失的数字。 思路：二分查找即可 代码12345678910111213class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int mid, start = 0, end = nums.size(); while(start &lt; end){ mid = (start + end) / 2; if(nums[mid] == mid) start = mid + 1; else end = mid; } return end; }};","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%95%B0%E7%BB%84/"},{"title":"面试题-栈和队列","text":"收集了栈和队列相关题目。 面试9：两个栈实现队列 题面：如题 思路：栈是FILO结构，将两个栈的结合起来就可以达到FIFO的效果。 代码：1234567891011121314151617181920212223242526template &lt;typename T&gt; class CQueue{ public: CQueue(void); ~CQueue(void); void appendTail(const T&amp; node){ stack2.push(node); } T deleteHead(){ if(stack1.empty()){ while(!stack2.empty()){ stack1.push(stack2.top()); stack2.pop(); } } //弹空栈应抛出异常 if(stack1.empty()) throw new exception(&quot;queue is empty.&quot;); T topValue = stack1.top(); stack1.pop(); return topValue; } private: stack&lt;T&gt; stack1, stack2;} 面试题9相关题：两个队列实现栈1//思考了一下只能用一个队列循序存储数据，在插入操作时直接插入。删除时把一个队列的除了最后一个其他数据顺序放到临时存储队列，最后删除最后一个数据。 包含min函数的栈题面：给定栈的数据结构，要求实现对栈的操作min，push，pop，并且复杂度为O(1)O(1)。 思路：这题的难度不在于思维，而在于一种思想。为了保持栈FILO的特性，必须有一个栈负责存储原数据。但是如何实现min？一开始的想法是维护一个递增的栈，但是明显的复杂度高，且不易维护。简单如我没有想到可以直接维护一个每一个元素都代表着当前被压入栈时的栈的最小值的状态栈。也就是说在数据压入栈的时候求出之前记录的最小值和被压入元素的最小值，然后压入状态栈。pop的时候也很简单，直接两个栈都pop就ok。 可以这么做的理由，是栈的min值是与将来无关的，仅与过去有关，换句话说就是状态值仅与当前栈的内容有关。 好优雅。 12345678910111213141516171819202122class StackMin{ private: stack&lt;int&gt; s, sMin; public: void push(int x){ if(sMin.size() &gt; 0) sMin.push(min(x, sMin.top())); else sMin.push(x); s.push(x); } void pop(){ if(sMin.size() == 0) return; sMin.pop(); s.pop(); } int min(){ if(sMin.size() &gt; 0) return sMin.top(); else throw new exception(); }} 错误：没有检查栈的元素数量。 面31：合法的栈的弹出序列题面：给出一个按增序的数字序列1，2，3，4……压入栈的序列， 同时给出一个对应数字的弹出序列，判断弹出序列是否是压入序列的弹出序列。 思路：不考虑数据的错误输入的话。一个简单而自然的思路就是模拟，建立一个辅助栈。对于弹出序列的当前数据，如果比栈顶数据大或者栈没有数据，则压入数据，直到栈顶和当前弹出序列的值一样大。如果等于栈顶数据，弹出栈顶。如果比栈顶数据小，则序列错误。如果正常运行结束则序列正确。 不太容易讲清楚，最好举个例子。 想了一丢丢，终于讲清楚了。重点在于判断模拟过程的条件需要缕清。 样例：123456789101112131415true:1,2,31,2,31,2,33,2,11,2,33,1,21,2,3,4,5,63,4,2,5,1,61,2,3,4,5,63,4,2,6,1,5 代码：12345678910111213141516171819202122bool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop){ stack&lt;int&gt; s; int pushMax = 0; if(lenPush != lenPop) return false; for(int i = 0; i &lt; lenPush; i++){ if(s.empty() || aPush[i] &gt; s.top()){ int k = pushMax + 1; while(k &lt;= aPush[i]){ s.push(k); k++; } pushMax = k - 1; } if(s.top() == aPush[i]){ s.pop(); }else{ return false; } } return true;}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"title":"面试题-递归迭代","text":"收集一些经典的题目 斐波那契数列计算 三种思路：递归、dp和快速矩阵乘 dp 1234567891011121314long long Fobonacci(unsigned n){ if(n &lt;= 0) return -1; long long fibN1 = 0; long long fibN2 = 1; if(n == 1) return fibN1; else if(n == 2) return fibN2; for(int k = 2; k &lt;= n; k++){ int temp = fibN2; fibN2 = fibN2 + fibN2; fibN1 = temp; } return fibN2;} 思路扩展：青蛙跳台阶问题，1*2方块铺设问题，","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%80%92%E5%BD%92%E8%BF%AD%E4%BB%A3/"},{"title":"面试题 链表相关","text":"所有关于链表的题目都会总结在这里。假设这些题目的链表的头结点都是带有效值的 定义链表1234struct ListNode{ int Value; ListNode* pNext;}; 尾插入节点注意第一个参数是指针的指针，因为有可能需要修改第一个链表节点。 123456789101112131415void AddToTail(ListNode **pHead, int value){ if(pHead == null) return; ListNode *pNew = new ListNode(); pNew-&gt;Value = value; pNew-&gt;pNext = nullptr; if(*pHead == null){ *pHead = pNew; }else{ ListNode* pNode = *pHead; while(pNode-&gt;pNext != null){ pNode = pNode-&gt;pNext; } *pNode-&gt;pNext = pNew; }} 删除第一个对应值的链表12345678910111213141516171819202122viod RemoveNode(ListNode** pHead, int value){ if(pHead == nullptr || *pHead == nullptr) return; ListNode *pToDeleted = nullptr; if((*pHead)-&gt;value == value){ pToDeleted = *pHead; *pHead = (*pHead)-&gt;pNext; }else{ ListNode *pNode = *pHead; //pNode指向检查节点的前一个节点 while((*pNode)-&gt;pNext != null &amp;&amp; (*pNode)-&gt;pNext-&gt;value != value){ pNode = pNode-&gt;pNext; } if((*pNode)-&gt;pNext != null &amp;&amp; (*pNode)-&gt;pNext-&gt;value == value){ pToDeleted = (*pNode)-&gt;pNext; } } if(pToDeleted != nullptr){ delte pToDelted; pToDelted = nullptr; //释放内存后，即使是不需要使用的指针，也要做好清除工作，不然不容易维护 } } pToDeleted = *pNode-&gt;pNext;上面遍历链表中代码不应该用pToDeleted来记录链表值，否然容易出现代码指针值意义混乱，造成不该删的指针却删掉了。 面试题6 从尾到头打印链表假如对空间复杂度在O(N)O(N)之上，那么可以使用栈或者递归。 栈代码如下 1234567891011121314void PrintListReversingly_Iteratively(ListNode* pHead){ //使用指针类型的STACK更省内存？ std::stack&lt;ListNode*&gt; nodes; ListNode* pNode = pHead; while(pNode != nullptr){ nodes.push(pNode); pNode = pNode-&gt;pNext; } while(!nodes.empty()){ pNode = nodes.top(); printf(&quot;%d\\n&quot;, pNode-&gt;value); nodes.pop(); } } 递 归代码 123456void PrintListReversingly_Recursively(ListNode* pHead){ if(pHead == nullptr) return; PrintListReversingly_Recursively(pHead-&gt;pNext); printf(&quot;%d\\n&quot;, pHead-&gt;pNext); } 面试18：删除一个链表节点题面：给定一个单向链表的头结点指针和一个指向待删除的节点的指针，要求用O(N)O(N)时间删除节点。 思路：教科书上的链表删除都是遍历得到上一个待删除的节点的指针，时间复杂度O(N)O(N)。显然不行，也可以直接把待删除的节点K的下一个节点J的内容复制到K上，再删除J，就可以快速删除。考虑边界上，如果没有下一个节点则需要从头遍历；如果只有一个头结点且删除的是头结点，那么只能把头结点置nullptr。 其时间复杂度为(n−1)∗O(1)+O(N)(n−1)∗O(1)+O(N)。 代码：123456789101112131415161718192021222324void DeleteNode(ListNode **pHead, ListNode *pToBeDeleted){ if(pHead == nullptr || (*phead) == nullptr || (*pToBeDeleted) == nullptr ) return; ListNode *pFree = nullptr; if(pToBeDeleted-&gt;pNext){ pFree = ToBeDeleted-&gt;pNext; pToBeDeleted-&gt;value = pToBeDeleted-&gt;pNext-&gt;value; pToBeDeleted-&gt;pNext = pToBeDeleted-&gt;pNext-&gt;pNext; } //删除节点无后继节点，且是头结点 else if( *pHead == pToBeDeleted){ pFree = *pHead; *pHead = nullptr; } // 链表中多个节点，且删除节点在末尾 else{ ListNode *pCur = *pHead for(; pCur-&gt;pNext-&gt;pNext != nullptr; pCur = pCur-&gt;pNext); pFree = pCur-&gt;pNext; pCur-&gt;pNext = nullptr; } Delete pFree;} 错误点： the properiry of “*” &gt; the properity of “==” 链表插入和删除后没有设置指针 注意点： 这个函数假设了待删除的节点一定在链表中； 头结点可能删除掉，所以设置了头结点为指针的指针。 面18（题目二）：删除重复值的链表节点题面：删除一条已排序的链表中的所有的其值重复出现的节点。 思路：在上面学习的基础上，连续删除就行，应该是比较简单的。 代码：123456789101112131415161718192021222324252627282930313233343536void DeleteDuplication(ListNode **pHead){ if(pHead == nullptr || *pHead == nullptr) return; ListNode *pCur = *pHead, *pPre = nullptr, *pFree = nullptr; //定义一个头结点，避免不同情况的删除 ListNode *pKid = new ListNode(); pKid-&gt;pNext = *pHead; pPre = pKid; while(pCur != nullptr){ int value = pCur-&gt;value, isDuplication = 0; //删除后面的重复节点 while(pCur-&gt;pNext &amp;&amp; pCur-&gt;pNext-&gt;value == value){ pFree = pCur-&gt;pNext; pCur-&gt;pNext = pFree-&gt;pNext; delete pFree; isDuplication = 1; } //若重复，则删除第一个重复节点 if(isDuplication){ pFree = pCur; pCur = pCur-&gt;pNext; pPre-&gt;pNext = pCur; delete pFree; // if(pFree) printf(&quot;@&quot;); } //不重复则下移 else{ pPre = pPre-&gt;pNext; pCur = pCur-&gt;pNext; } } *pHead = pKid-&gt;pNext; delete pKid;} 测试参见 面22：倒数第K个节点题面：给出一个链表，返回倒数第K个节点。 思路：最直观的思路是遍历到终点，反向遍历K-1次，但是对单链表无可奈何，而且效率不高。 第二种思路可以遍历一次求链表的长度L，第二次遍历L - K + 1个节点。但是需要遍历两次链表。 三种思路更秒，采用双指针，第一个指针先遍历K个节点，随后两个节点一起遍历，直到第一个指针为空，第二个指针就指向了倒数第K个节点。 代码：1234567891011121314ListNode *FindKthToTail(ListNode *pHead, unsigned int K){ if(pHead == nullptr) return nullptr; ListNode *p1 = pHead, *p2 = pHead; for(int i = 0; i &lt; K; i++){ if(p1 == nullptr) return nullptr; p1 = p1-&gt;pNext; } while(p1!=nullptr){ p1 = p1-&gt;pNext; p2 = p2-&gt;pNext; } return p2;} 这代码写的比剑指offer代码写的优美多了 相关扩展：相关题目有找出链表的中间节点；判断一个链表是否有环；更难一点判断链表的环的入口节点！ 其思路宗旨都是使用两个进度不一样的指针指向不同的节点来解决问题！ 面23：链表中的环的入口节点题面：给出一个链表，求出其成环的入口节点。 思路：首先得判断有环，可以使用一个快一慢的两只指针（移动速度分别为2和1）指向链表头。如果链表有环，则快慢指针就一定会相遇。 那么对于有环的链表如何确定其入口节点呢？假设环的中节点有K个，快指针从头先遍历K次之后，快慢指针同时开始遍历，正好两个指针会在入口节点上汇合！ 如何确定环中节点呢？这个！可以直接在确定有环后，记录下该节点的位置，再继续遍历直到重新到该节点同时统计经过的节点数量即可。 amazing啊 代码：123456789101112131415161718192021222324252627282930ListNode *FindCycleNode(ListNode* pHead){ if(pHead == nullptr) return nullptr; ListNode *pSlow, *pQuick, *pRecord = nullptr ; //判断有没有环 pSlow = pQuick = pHead; while(pQuick != nullptr){ pQuick = pQuick-&gt;pNext; if(pQuick) pQuick = pQuick-&gt;pNext; if(pSlow) pSlow = pSlow-&gt;pNext; if(pSlow == pQuick) break; } if(pQuick == nullptr) return nullptr; //确定环内数量 pRecord = pSlow; int numberOfCycle = 0; while(pRecord != pSlow){ numberOfCycle++; pSlow = pSlow-&gt;pNext; } //确定环的入口节点 pSlow = pQuick = pHead; for(int i = 0; i &lt; numberOfCycle; i++){ pQuick = pQuick-&gt;pNext; } while(pSlow != pQuick){ pQuick = pQuick-&gt;pNext; pSlow = pSlow-&gt;pNext; } return pSlow;} 面24：反转链表题面：输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。 思路：在反转过程中，假设有三个顺序排列的待反转的链表i，j，k，其中j是待反转的链表。初始化，i为空指针，j为头节点，k为头结点的下一个指针指向的内容（可能为空），并把i的指针指空。在链表反转过程如下：j的指针指向i，然后把i，j，k分别按次序向后移动。重复执行上述步骤直到j为空。 代码：1234567891011ListNode *ReverseList(ListNode *pHead){ if(pHead == nullptr) return nullptr; ListNode *p1 = nullptr, *p2 = pHead, *p3 = pHead-&gt;pNext; while(p2 != nullptr){ p2-&gt;pNext = p1; p1 = p2; p2 = p3; if(p3) p3 = p3-&gt;next; } return p2; } 面25：合并链表题面：将两个链表增序合并成一条链表。 思路：用两个指针指向两条链表的头结点，用合并数组的思路合并即可。注意一条链表为空后，另一条不为空的链表可以直接连上去。 代码：12345678910111213141516171819202122232425262728293031ListNode *Merge(ListNode *pHead1, ListNode *pHead2){ if( pHead1 == nullptr &amp;&amp; pHead2 == nullptr){ return nullptr; }else if(pHead1 == nullptr) return pHead2; else if(pHead2 == nullpr) return pHead1; ListNode *p1 = pHead1, *p2 = pHead2, *pHead3 = new ListNode(), *p3 = pHead3; while(p1 &amp;&amp; p2){ if(p1-&gt;value &lt;= p2-&gt;value){ p3-&gt;pNext = p1; p3 = p1; p1 = p1-&gt;pNext; }else{ p3-&gt;pNext = p2; p3 = p2; p2 = p2-&gt;pNext; } } p3-&gt;pNext = nullptr; if(p1){ p3-&gt;pNext = p1; }else if(p2){ p3-&gt;pNext = p2; } ListNode *pFree = pHead3; pHead3 = pHead-&gt;pNext; delete pFree; return pHead3; } 测试参见 面35：复杂链表的分解题面：给出一个有两个指针的链表数据结构，一个指针1指向下一个节点，另一个指针2可指向任意一个节点，或者为空。将给出的链表复制并返回头结点。 思路：这题目还是挺不错的！属于比较复杂的题目，而且有思考空间。 将复制的过程分解为两个部分，第一步先不管指针2，复制整个链表；第二步再设置指针2。第一步需要的复杂度为O(N)O(N)。第二步再复制的过程中需要确定复制链表中指针2指向的节点的的位置。 第一种确定位置的思路：就是从原链表遍历寻找原指针指向的节点位置，同样的在复制链表上一起遍历。复杂度为O(N2)O(N2)。 第二种确定位置的思路：直接用hash表记录下原链表中节点和复制链表中对应节点的映射关系。复杂度为O(N)O(N)。是用了空间换时间的思路。 害怕碰撞。 脱离上面的方案的限制，更巧妙的方法来了。链表的顺序遍历远远比随机遍历方便很多，而且指针指向的节点的位置不随链表节点而变化。可以考虑把复制节点直接插入到被复制节点的后面。全部复制完成后，由于原节点的指针2指向的节点的后一个节点就是复制节点的指针2指向的节点，所以可以直接指向。复杂度为O(N)O(N)，空间复杂度为O(1)O(1)。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct ComplexListNode{ int value; ComplexListNode *pNext; ComplexListNode *pSibling; }void CopyNode(ComplexListNode *pHead){ if(pHead == nullptr) return null; ComplexListNode *pNode = pHead; while(pNode){ ComplexListNode *pNew = new ComplexListNode(); pNew-&gt;value = pNode-&gt;value; pNew-&gt;pNext = pNode-&gt;pNext; pNew-&gt;pSibling = nullptr; pNode-&gt;pNext = pNew; pNode = pNew-&gt;pNext; } }void SetSiblingLink(ComplexListNode * pHead){ if(pHead == nullptr )return nullptr; ComplexListNode *pNode = pHead; while(pNode){ ComplexListNode *pNext = pNode-&gt;pNext; pNext-&gt;pSibling = pNode-&gt;pSibliing-&gt;pNext; pNode = pNext-&gt;pNext; } }ComplexListNode *GetComplexList(ComplexListNode *pHead){ if(pHead == nullptr) return nullptr; ComplexListNode *pNode = pHead; ComplexListNode *pClonedHead = pNode-&gt;pNext; ComplexListNode *pClonedNode = pNode-&gt;pNext; pNode-&gt;next = pClonedNode-&gt;next; pNode = pClneNode-&gt;next; while(pNode){ pClonedNode-&gt;pNext = pNode-&gt;pNext; pNode-&gt;pNext = pNode-&gt;pNext-&gt;pNext; pClonedNode = pNode-&gt;pNext; pNode = pClonedNode-&gt;pNext; /* //we can write in this way. pClonedNode-&gt;pNext = pNode-&gt;pNext; pClonedNode = pClonedNode-&gt;pNext; pNode-&gt;pNext = pClonedNode-&gt;pNext; pNode = pNode-&gt;pNext; */ } return pClonedHead; }ComplexListNode *Clone(ComplexListNode* pHead){ CopyNode(pHead); SetSiblingLink(pHead); return GetComplexList(pHead);} 面36：把二叉搜索树转化为双向链表题面：如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。 思路：可以从递归的角度入手。对于一个节点A，中序遍历到A，则A的左子树已经转化为了链表，连接好A和A的左子树的最大节点（前一个指针）的指针则连接完成。 那对于A的右子树的最小节点B与A之间的连接，也可以看成B与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。 注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。 对于一个节点A的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点B的指针，并设置好B的右指针和A的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是NULL，所以无需修改。 代码：1234567891011121314151617void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead){ if(pRoot == nullptr) return; AdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead); if(pHead == nullptr) pHead = pRoot; pRoot-&gt;pLeft = preNode; if(preNode) preNode-&gt;pRight = pRoot; preNode = pRoot; AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead);}BinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){ BinaryTreeNode *preNode = nullptr; BinaryTreeNode *pHead = nullptr; AdjustLinkCore(pRoot, preNode, pHead); return pHead;} 面52：两个链表的第一个公共节点题面：如题。 思路：明显地，可以用栈来存储两个链表遍历过程。空间复杂度和时间复杂度都是O(N)O(N)。 换一种想法，能不能直接遍历就使两个链表同时遍历到第一个公共节点。定义两个指针来遍历两条链表。只要让一个指向长链表的节点的指针多走多出的节点，就可以让两个节点同时同序的遍历到公共节点。时间复杂度为O(N+M)O(N+M)，空间复杂度O(1)O(1)。 代码：12345678910111213141516171819202122232425262728293031int GetLenOfList(ListNode *pHead){ int len = 0; ListNode *pNode = pHead; while(pNode){ pNode = pNode-&gt;pNext; len++; } return len;}ListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2){ if(pHead1 == nullptr || pHead2 == nullptr) return nullptr; int len1 = GetLenOfList(pHead1); int len2 = GetLenOfList(pHead2); if(len1 &lt; len2){ swap(pHead1, pHead2); swap(len1, len2); } int step = len1 - len2; ListNode *pNode1 = pHead1; ListNode *pNode2 = pHead2; while(step){ pNode1 = pNode-&gt;pNext; step--; } while(pNode1 != pNode2){ pNode1 = pNode1-&gt;pNext; pNode2 = pNode1-&gt;pNext; } //two pNodes maybe refer to null or the first common node. return pNode1;}","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"},{"title":"面试题44：1出现的个数","text":"广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理 题目：统计从1到N的所有数字的1的出现次数。 思路：第一种：所有人都能想出直接暴力解的算法。 第二种：参考其他人的解法。 设N = abcde ,其中abcde分别为十进制中各位上的数字。如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100199，11001199,21002199，，…，1110011199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100199，11001199,21002199，，….，1110011199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：1210012113,一共114个，等于低位数字（113）+1。③ 如果百位上数字大于1（29），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100199,11001199，21002199，…，1110011199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。——参考牛客网@藍裙子的百合魂 代码：12345678910111213141516171819202122int CounterOf1(int x){ if(x &lt;= 0) return 0; int len = 0, tempX = x, judugNum = 1; while(tempX){ tempX = tempX / 10; len ++; } int power = 10, counter = 0 ; for(int i = 0; i &lt; len; i++){ int liPower = power / 10; int num = x % power / liPower; if(num &gt; judugNum ){ counter += (x / power + 1) * liPower; }else if(num == judugNum ){ counter += (x / power) * liPower + x % liPower + 1; }else counter += x / power * liPower; power *= 10; } return counter;} 测试可见 牛客","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%9844%EF%BC%9A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"面试题49：丑数","text":"","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%9849%EF%BC%9A%E4%B8%91%E6%95%B0/"},{"title":"面试题51:逆序数","text":"这道题目还是比较神奇的。 题目：在一个数组中找出所有的逆序数。 逆序数就是指前一个数字大于后一个数组的一对数字。 思路：可以暴力查找，但是复杂度是O(N)O(N)。 想尝试用DP，但是没有明确的子问题分解界线。 最优算法是分治算法。将序列递归的一分为二，直到分割成长度为1的数组。在回朔地合并相邻的两个数组，同时统计序列的逆序数。在回朔的一个合并过程中，两个数组已经保持有序，也就是说数组内部的逆序数都不存在，只统计两个数组间的逆序数。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243int InversePairCore(int *A, int *copy, int start, int end){ // the the len of array should be looger than 1. // for example, the function will struggle with [0, 1]. // becaues start = 0, mid = 0, end = 1. Moreover the situtaion never change. if(start + 1 &gt;= end) return 0; int mid = (end + start) / 2; int leftCount = InversePairCore(A, copy, start, mid); int rightCount = InversePairCore(A, copy, mid, end); int midCount = 0; int p1 = mid - 1, p2 = end - 1, p3 = end - 1; while(p1 &gt;= start &amp;&amp; p2 &gt;= mid){ if(A[p1] &gt; A[p2]){ copy[p3] = A[p1]; p3--; p1--; midCount += p2 - mid + 1; } else{ copy[p3] = A[p2]; p3--; p2--; } } while(p1 &gt;= start){ copy[p3] = A[p1]; p3--; p1--; } while(p2 &gt;= mid){ copy[p3] = A[p2]; p3--; p2--; } for(int i = start; i &lt; end; i++) A[i] = copy[i]; return rightCount + midCount + leftCount;}int InversePair(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int *copy = new int(length);// for(int i = 0; i &lt; length; i++) copy[i] = A[i]; return InversePairCore(A, copy, 0, length); }","link":"/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%9851-%E9%80%86%E5%BA%8F%E6%95%B0/"}],"tags":[{"name":"LAC","slug":"LAC","link":"/tags/LAC/"},{"name":"关键路径","slug":"关键路径","link":"/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"MATH","slug":"MATH","link":"/tags/MATH/"},{"name":"AVL","slug":"AVL","link":"/tags/AVL/"},{"name":"BinaryTree","slug":"BinaryTree","link":"/tags/BinaryTree/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"反思","slug":"反思","link":"/tags/%E5%8F%8D%E6%80%9D/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"代码规范","slug":"代码规范","link":"/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"}],"categories":[{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"DL","slug":"AI/DL","link":"/categories/AI/DL/"},{"name":"Algorithms","slug":"CS/Algorithms","link":"/categories/CS/Algorithms/"},{"name":"CN","slug":"CS/CN","link":"/categories/CS/CN/"},{"name":"CSAPP","slug":"CS/CSAPP","link":"/categories/CS/CSAPP/"},{"name":"DB","slug":"CS/DB","link":"/categories/CS/DB/"},{"name":"DS","slug":"CS/DS","link":"/categories/CS/DS/"},{"name":"Code tools","slug":"Code-tools","link":"/categories/Code-tools/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Anki","slug":"Code-tools/Anki","link":"/categories/Code-tools/Anki/"},{"name":"刷题","slug":"刷题","link":"/categories/%E5%88%B7%E9%A2%98/"},{"name":"Blog","slug":"Code-tools/Blog","link":"/categories/Code-tools/Blog/"},{"name":"Docker","slug":"Code-tools/Docker","link":"/categories/Code-tools/Docker/"},{"name":"Git","slug":"Code-tools/Git","link":"/categories/Code-tools/Git/"},{"name":"Jupyter","slug":"Code-tools/Jupyter","link":"/categories/Code-tools/Jupyter/"},{"name":"Linux","slug":"Code-tools/Linux","link":"/categories/Code-tools/Linux/"},{"name":"Matlab","slug":"Code-tools/Matlab","link":"/categories/Code-tools/Matlab/"},{"name":"Pycharm","slug":"Code-tools/Pycharm","link":"/categories/Code-tools/Pycharm/"},{"name":"VScode","slug":"Code-tools/VScode","link":"/categories/Code-tools/VScode/"},{"name":"Windows","slug":"Code-tools/Windows","link":"/categories/Code-tools/Windows/"},{"name":"C++","slug":"Language/C","link":"/categories/Language/C/"},{"name":"Go","slug":"Language/Go","link":"/categories/Language/Go/"},{"name":"Java","slug":"Language/Java","link":"/categories/Language/Java/"},{"name":"Python","slug":"Language/Python","link":"/categories/Language/Python/"},{"name":"LeetCode","slug":"刷题/LeetCode","link":"/categories/%E5%88%B7%E9%A2%98/LeetCode/"},{"name":"PAT","slug":"刷题/PAT","link":"/categories/%E5%88%B7%E9%A2%98/PAT/"},{"name":"剑指offer","slug":"刷题/剑指offer","link":"/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/"}]}