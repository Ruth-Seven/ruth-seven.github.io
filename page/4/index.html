<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Hexo</title><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Hexo","image":["http://yoursite.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="http://static.come2rss.xyz/%E9%93%81%E7%94%B2%E5%9F%8Elogo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://static.come2rss.xyz/%E9%92%A2%E9%93%81%E4%BE%A0.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Ruth-Seven"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/%E5%88%B7%E9%A2%98/PAT/PAT-1043-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%8D%E5%BB%BA/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="PAT 1043 二叉树重建"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:17:52.000Z" title="2020-08-07T05:17:52.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a><span> / </span><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/PAT/">PAT</a></span><span class="level-item">2 minutes read (About 311 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/PAT/PAT-1043-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%8D%E5%BB%BA/">PAT 1043 二叉树重建</a></h1><div class="content"><!-- mroe -->



<h2 id="搜索二叉树的前序列推出整个二叉树或者推出后序列"><a href="#搜索二叉树的前序列推出整个二叉树或者推出后序列" class="headerlink" title="搜索二叉树的前序列推出整个二叉树或者推出后序列"></a>搜索二叉树的前序列推出整个二叉树或者推出后序列</h2><p>思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点；</p>
<p>难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界；</p>
<p><strong>PAT 1043</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">其实有点意思</span><br><span class="line">柳神的代码比我的构思好多了</span><br><span class="line">vector&lt;int&gt;pre,post;</span><br><span class="line">bool isMirror;</span><br><span class="line">void checkPre(int root,int tail)&#x2F;&#x2F;【root，tail】</span><br><span class="line">&#123;</span><br><span class="line">    if(root&gt;tail) return;&#x2F;&#x2F;! 空节点退出</span><br><span class="line">    int i&#x3D;root+1,j&#x3D;tail;</span><br><span class="line">    if(!isMirror)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;!while退出之时 就是到了另一个子树序列的开头与结尾</span><br><span class="line">        while(i&lt;&#x3D;tail&amp;&amp;pre[root]&gt;pre[i]) i++;</span><br><span class="line">        while(j&gt;root&amp;&amp;pre[root]&lt;&#x3D;pre[j]) j--;&#x2F;&#x2F;!若该序列是二叉搜索树则必有i&#x3D;&#x3D;j+1</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(i&lt;&#x3D;tail&amp;&amp;pre[root]&lt;&#x3D;pre[i]) i++;</span><br><span class="line">        while(j&gt;root&amp;&amp;pre[root]&gt;pre[j]) j--;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i-j!&#x3D;1) return;&#x2F;&#x2F;!由于树可能不存在 需要处理异常情况</span><br><span class="line">    checkPre(root+1,j);</span><br><span class="line">    checkPre(i,tail);</span><br><span class="line">    post.push_back(pre[root]);&#x2F;&#x2F;!前序遍历压入当前根节点；</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, flag &#x3D; 1;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    pre.resize(n+1);</span><br><span class="line">    for(int i&#x3D;0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;pre[i]);</span><br><span class="line">    checkPre(0,n-1);</span><br><span class="line">    if(post.size()!&#x3D;n)&#x2F;&#x2F;! 不为二、        printf(&quot;YES\n&quot;);</span><br><span class="line">        for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d&quot;,post[i]);</span><br><span class="line">            printf(&quot;%c&quot;,i!&#x3D;n-1?&#39; &#39;:&#39;\n&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else printf(&quot;NO\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/%E5%88%B7%E9%A2%98/PAT/PAT%E9%A3%8E%E6%A0%BC%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="PAT风格二叉树总结"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:17:11.000Z" title="2020-08-07T05:17:11.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a><span> / </span><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/PAT/">PAT</a></span><span class="level-item">7 minutes read (About 1123 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/PAT/PAT%E9%A3%8E%E6%A0%BC%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93/">PAT风格二叉树总结</a></h1><div class="content"><!-- mroe -->



<p>总结一下PAT出现的所有树的套路</p>
<h2 id="前序中序转后序"><a href="#前序中序转后序" class="headerlink" title="前序中序转后序"></a>前序中序转后序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int post[40], n, pos &#x3D; 0;</span><br><span class="line">vector&lt;int&gt; pre, in;</span><br><span class="line">stack&lt;int&gt;s;</span><br><span class="line">void dfs(int l1, int h1, int l2, int h2)&#123;</span><br><span class="line">    if(l1 &gt; h1) return;</span><br><span class="line">    int k &#x3D; l2;</span><br><span class="line">    for(;in[k]!&#x3D;pre[l1];k++);</span><br><span class="line">    dfs(l1 + 1, l1 + k - l2, l2 , k - 1);</span><br><span class="line">    dfs(l1 + k - l2 + 1, h1, k + 1, h2);</span><br><span class="line">    post[pos++] &#x3D; pre[l1];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i &#x3D;0 ;i &lt; 2 * n; i++)&#123;</span><br><span class="line">        string a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        if(a[1] &#x3D;&#x3D; &#39;u&#39;)&#123;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            s.push(t);</span><br><span class="line">            pre.push_back(t);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            in.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(0, n - 1, 0, n - 1);</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n; i++)&#123;</span><br><span class="line">        if(i &#x3D;&#x3D; n - 1) cout &lt;&lt; post[i];</span><br><span class="line">        else cout &lt;&lt; post[i] &lt;&lt; &#39; &#39; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BST-CMT-转层序"><a href="#BST-CMT-转层序" class="headerlink" title="BST + CMT 转层序"></a>BST + CMT 转层序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int cbst[2000], n, pos &#x3D; 1, in[2000];</span><br><span class="line">int dfs(int u)&#123;</span><br><span class="line">    if(u &gt; n ) return 0;</span><br><span class="line">    dfs(u * 2);</span><br><span class="line">    cbst[u] &#x3D; in[pos++];</span><br><span class="line">    dfs(u * 2 + 1);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(in + 1, in + n + 1);</span><br><span class="line">    dfs(1);</span><br><span class="line">    for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        if(i &#x3D;&#x3D; n ) printf(&quot;%d&quot;, cbst[i]);</span><br><span class="line">        else printf(&quot;%d &quot;, cbst[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前序中序转后序-1"><a href="#前序中序转后序-1" class="headerlink" title="前序中序转后序"></a>前序中序转后序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; in, post, pre;</span><br><span class="line">int n, flag  &#x3D; 1;</span><br><span class="line">void dfs(int l1, int h1, int l2, int h2)&#123;</span><br><span class="line">    if(l1 &gt;&#x3D; h1)&#123;</span><br><span class="line">        if(l1 &#x3D;&#x3D; h1) in.push_back(pre[l1]); &#x2F;&#x2F; l1 &gt; h1时 才能压入 否则是错误的</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int k &#x3D; l1 + 1;</span><br><span class="line">    while(k &lt;&#x3D; h1 &amp;&amp; pre[k] !&#x3D; post[h2 - 1]) k++;</span><br><span class="line">    if(k &#x3D;&#x3D; l1 + 1)</span><br><span class="line">        flag &#x3D; 0;</span><br><span class="line">    dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2  );</span><br><span class="line">    in.push_back(pre[l1]);</span><br><span class="line">    dfs(k, h1, l2 + k - l1 - 1, h2 - 1 );</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    post.resize(n);</span><br><span class="line">    pre.resize(n);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; pre[i];</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; post[i];</span><br><span class="line">    dfs(0, n - 1, 0 , n - 1);</span><br><span class="line">    if(flag) cout &lt;&lt; &quot;Yes\n&quot;;</span><br><span class="line">    else cout &lt;&lt; &quot;No\n&quot;;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\n&quot;, in[i]);</span><br><span class="line">        else printf(&quot;%d &quot;, in[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="层序中序转前序后序"><a href="#层序中序转前序后序" class="headerlink" title="层序中序转前序后序"></a>层序中序转前序后序</h2><p>这个问题也非常的巧妙，本来是一个层次遍历划分出一个父节点，但是下一步左右子树划分却成了问题，这个算法有一次刷新了我的世界观。使用中序遍历的思想，在层次遍历中查询每一个节点的归属父节点的左子树还是右子树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const ll mod &#x3D; 1000000007;</span><br><span class="line">int tree[40][2], val[40], n;</span><br><span class="line">int  in[40];</span><br><span class="line">vector&lt;int&gt; pre, post, lay;</span><br><span class="line"></span><br><span class="line">int build(vector&lt;int&gt; lay, int l, int r)&#123;</span><br><span class="line">    if(l &gt; r) return 0;</span><br><span class="line">    int k &#x3D; 1;</span><br><span class="line">    while(lay[0] !&#x3D; in[k]) k++;</span><br><span class="line">    vector&lt;int&gt; llay, rlay;</span><br><span class="line">    for(int i &#x3D; 1;i &lt; lay.size(); i++)&#123;</span><br><span class="line">        int isl &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; l; j&lt; k; j++)</span><br><span class="line">        if(lay[i] &#x3D;&#x3D; in[j])&#123;</span><br><span class="line">            isl &#x3D; 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(isl) llay.push_back(lay[i]);</span><br><span class="line">        else rlay.push_back(lay[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pre.push_back(in[k]);</span><br><span class="line">    tree[k][0] &#x3D;  build(llay, l, k - 1);</span><br><span class="line">    tree[k][1] &#x3D;  build(rlay, k + 1, r);</span><br><span class="line">    post.push_back(in[k]);</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    lay.resize(n);</span><br><span class="line">    int root &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; lay[i];</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; in[i + 1];</span><br><span class="line">    root &#x3D; build(lay, 1, n);</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n;i++)</span><br><span class="line">        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\n&quot;, pre[i]);</span><br><span class="line">        else printf(&quot;%d &quot;, pre[i]);</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n;i++)</span><br><span class="line">        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\n&quot;, post[i]);</span><br><span class="line">        else printf(&quot;%d &quot;, post[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int tree[200][2], n, ingree[200], root, lastnood, flag &#x3D; 1;</span><br><span class="line">int bfs(int u)&#123;</span><br><span class="line">    int tn &#x3D; 1;</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    que.push(u);</span><br><span class="line">    while(que.size())&#123;</span><br><span class="line">        int v &#x3D; que.front(); que.pop();</span><br><span class="line">        lastnood &#x3D; v;</span><br><span class="line">        if(tree[v][0] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">            if(tn !&#x3D; n)</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            que.push(tree[v][0]);</span><br><span class="line">            tn++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tree[v][1] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">            if(tn !&#x3D; n)</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            que.push(tree[v][1]);</span><br><span class="line">            tn++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    fill(tree[0], tree[0] + 200 * 2 , - 1 );</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n; i++) &#123;</span><br><span class="line">        string a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        if(a !&#x3D; &quot;-&quot;)&#123;</span><br><span class="line">            int v &#x3D; atoi(a.c_str());</span><br><span class="line">            tree[i][0] &#x3D; v;</span><br><span class="line">            ingree[v] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(b !&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">            int v &#x3D; atoi(b.c_str());</span><br><span class="line">            tree[i][1] &#x3D; v;</span><br><span class="line">            ingree[v] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n ;i++) if(ingree[i] &#x3D;&#x3D; 0) root &#x3D; i;</span><br><span class="line">    bfs(root);</span><br><span class="line">    if(flag) cout &lt;&lt; &quot;YES &quot; &lt;&lt; lastnood;</span><br><span class="line">    else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态链表建树"><a href="#静态链表建树" class="headerlink" title="静态链表建树"></a>静态链表建树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int tree[2000][3], lay[2000], n, depest, ct &#x3D; 0;</span><br><span class="line">int insert(int u, int val, int dep)&#123;</span><br><span class="line">    depest &#x3D; max(depest,dep);</span><br><span class="line">&#x2F;&#x2F;    cout &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">    if(u &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        lay[dep] ++;</span><br><span class="line">        tree[++ct][2] &#x3D; val;</span><br><span class="line">        return ct;</span><br><span class="line">    &#125;else if(val &lt;&#x3D; tree[u][2])&#123;</span><br><span class="line">        tree[u][0] &#x3D; insert(tree[u][0], val, dep + 1);</span><br><span class="line">    &#125;else if(val &gt; tree[u][2])&#123;</span><br><span class="line">        tree[u][1] &#x3D; insert(tree[u][1], val, dep + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return u;</span><br><span class="line"> &#125;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     int root &#x3D; 0, tmp;</span><br><span class="line">     cin &gt;&gt; n;</span><br><span class="line">     for(int i &#x3D; 0;i &lt; n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        root &#x3D; insert(root, tmp, 1);</span><br><span class="line">     &#125;</span><br><span class="line">     cout &lt;&lt; lay[depest ] &lt;&lt; &quot; + &quot; &lt;&lt;  lay[depest - 1] &lt;&lt; &quot; &#x3D; &quot; &lt;&lt;  lay[depest] + lay[depest - 1] &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断树"><a href="#判断树" class="headerlink" title="判断树"></a>判断树</h2><p>晴神的一道题1016</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">int tree[100][3], val[40], n,  ingree[20];</span><br><span class="line">int navln, layer[23], isct &#x3D; 1, switime;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">&#x2F;&#x2F;avl</span><br><span class="line">int ctavl(int root)&#123;</span><br><span class="line">    if(root &#x3D;&#x3D; 0) return 0;</span><br><span class="line">    int h1 &#x3D; ctavl(tree[root][0]);</span><br><span class="line">    int h2 &#x3D;  ctavl(tree[root][1]);</span><br><span class="line">    if( abs(h1 - h2) &gt; 1) navln ++;</span><br><span class="line">    return max(h1, h2) + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;层序遍历同时存储 逆层序遍历的顺序以便调整堆！</span><br><span class="line">void isctree(int root)&#123;</span><br><span class="line">    int nt &#x3D; 1;</span><br><span class="line">    queue&lt;int&gt; que, lay;</span><br><span class="line">    que.push(root);</span><br><span class="line">    lay.push(1);</span><br><span class="line">    while(que.size())&#123;</span><br><span class="line">        int u &#x3D; que.front(); que.pop();</span><br><span class="line">        int ll &#x3D; lay.front(); lay.pop();</span><br><span class="line">        s.push(u);</span><br><span class="line">        layer[ll] ++;</span><br><span class="line">&#x2F;&#x2F;        cout &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">        if( tree[u][0] )&#123;</span><br><span class="line">            que.push(tree[u][0]);</span><br><span class="line">            lay.push(ll + 1);</span><br><span class="line">            nt ++;</span><br><span class="line">        &#125;else if(nt !&#x3D; n) isct &#x3D; 0;</span><br><span class="line">        if( tree[u][1] )&#123;</span><br><span class="line">            que.push(tree[u][1]);</span><br><span class="line">            lay.push(ll + 1);</span><br><span class="line">            nt ++;</span><br><span class="line">        &#125;else if(nt !&#x3D; n) isct &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 向下调整 大顶堆</span><br><span class="line">void downAdjust(int root)&#123;</span><br><span class="line">    for(int p &#x3D; tree[root][0];p !&#x3D;0; p &#x3D; tree[root][0])&#123;</span><br><span class="line">        int pp &#x3D; tree[root][1];</span><br><span class="line">        if(val[pp] &gt; val[p]) p &#x3D; pp;</span><br><span class="line">        if(val[p] &lt; val[root]) break;</span><br><span class="line">        swap( val[root], val[p]);</span><br><span class="line">        switime ++;</span><br><span class="line">        root &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt;  s1 &gt;&gt; s2;</span><br><span class="line">        if(s1 !&#x3D; &quot;-&quot;)&#123;</span><br><span class="line">            tree[i][0] &#x3D; atoi(s1.c_str());</span><br><span class="line">            ingree[atoi(s1.c_str())]++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s2 !&#x3D; &quot;-&quot;)&#123;</span><br><span class="line">            tree[i][1] &#x3D; atoi(s2.c_str());</span><br><span class="line">            ingree[atoi(s2.c_str())]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int rt &#x3D; -1;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; n; i++)</span><br><span class="line">        if( ingree[i] &#x3D;&#x3D; 0) rt &#x3D; i;</span><br><span class="line">&#x2F;&#x2F;    cout &lt;&lt; rt ;</span><br><span class="line">    ctavl(rt);</span><br><span class="line">    if(navln !&#x3D; 0) cout &lt;&lt; &quot;NOT AVL TREE!!!\n&quot; &lt;&lt;  navln &lt;&lt; endl;</span><br><span class="line">    else&#123;</span><br><span class="line">        isctree(rt);</span><br><span class="line">        int p &#x3D; 1, noden &#x3D; 1;</span><br><span class="line">        while(noden &#x3D;&#x3D; layer[p])&#123;</span><br><span class="line">            noden *&#x3D; 2;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!isct) cout &lt;&lt; &quot;NOT COMPLETE TREE!!!\n&quot; &lt;&lt; p - 1 &lt;&lt; endl;</span><br><span class="line">        else&#123;</span><br><span class="line">            while(s.size())&#123;</span><br><span class="line">                int u &#x3D; s.top(); s.pop();</span><br><span class="line">                downAdjust(u);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; &quot;OHHHHH HEAP!!!\n&quot; &lt;&lt; switime &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Go/Go%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Go笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:15:47.000Z" title="2020-08-07T05:15:47.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Go/">Go</a></span><span class="level-item">2 minutes read (About 255 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Go/Go%E7%AC%94%E8%AE%B0/">Go笔记</a></h1><div class="content"><!-- mroe -->

<h1 id="go学习"><a href="#go学习" class="headerlink" title="go学习"></a>go学习</h1><blockquote>
<p>在一个悲伤的日子打开一个特殊语言的入门学习之路。</p>
</blockquote>
<p>Go is expressive, concise, clean, and efficient. Its <strong>concurrency mechanisms</strong> make it easy to write programs that get the most out of multicore and networked machines, while its <strong>novel type</strong> system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of <strong>garbage collection</strong> and the power of <strong>run-time reflection.</strong> It’s a fast, <strong>statically typed</strong>, compiled language that feels like a dynamically typed, interpreted language.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>去该<a href="https://golang.org/doc/install">页面</a>寻找安装包入口，安装后把路径加入环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</span><br></pre></td></tr></table></figure>

<h2 id="tour"><a href="#tour" class="headerlink" title="tour"></a>tour</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;Welcome to the playground!&quot;)</span><br><span class="line">	fmt.Println(&quot;The time is&quot;, time.Now())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>有两种方式，一是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&#x2F;rand&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>抑或：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;math&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Exported-names"><a href="#Exported-names" class="headerlink" title="Exported names"></a>Exported names</h3><p>go中包中Capital Word开头的变量都是Exported names，Exported names顾名思义就是可以被暴露给调用者的。应对的Unexported names都是对于调用包的都是unaccessible。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">&#x2F;</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&#x2F;rand&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;My favorite number is&quot;, rand.Intn(10))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Python/random%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="random笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:14:37.000Z" title="2020-08-07T05:14:37.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Python/">Python</a></span><span class="level-item">a minute read (About 121 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Python/random%E7%AC%94%E8%AE%B0/">random笔记</a></h1><div class="content"><!-- mroe -->

<p>wrandom常用函数</p>
<p><code>sample(list, simpleSize)</code>从list中抽simpleSize个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [33]: from random import randint,sample</span><br><span class="line">    ...: lst &#x3D; [randint(0,50) for _ in range(100)]</span><br><span class="line">    ...: print(lst[:5])</span><br><span class="line">    ...: lst_sample &#x3D; sample(lst,10)</span><br><span class="line">    ...: print(lst_sample)</span><br><span class="line">[0, 38, 31, 33, 43]</span><br><span class="line">[9, 43, 31, 22, 31, 30, 14, 47, 14, 1]</span><br></pre></td></tr></table></figure>

<p><code>shuffle(lst)</code>随机打乱顺序</p>
<p>值得注意，shuffle 是对输入列表就地（in place）洗牌，节省存储空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [34]: from random import shuffle</span><br><span class="line">    ...: lst &#x3D; [randint(0,50) for _ in range(100)]</span><br><span class="line">    ...: shuffle(lst)</span><br><span class="line">    ...: print(lst[:5]) </span><br><span class="line">[22, 49, 34, 9, 38]</span><br></pre></td></tr></table></figure>

<p><code>uniform(a,b)</code> 生成 [a,b) 内的一个随机数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from random import uniform</span><br><span class="line"> x, y &#x3D; [i for i in range(100)], [round(uniform(0, 10), 2) for _ in range</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Python/python%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="python系统操作"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:13:52.000Z" title="2020-08-07T05:13:52.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Python/">Python</a></span><span class="level-item">3 minutes read (About 510 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Python/python%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/">python系统操作</a></h1><div class="content"><!-- mroe -->



<h1 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h1><h2 id="镜像库"><a href="#镜像库" class="headerlink" title="镜像库"></a>镜像库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> #华中科技的很快</span><br><span class="line">https:&#x2F;&#x2F;pypi.mirrors.ustc.edu.cn&#x2F;simple&#x2F;</span><br><span class="line"> #清华的一般</span><br><span class="line"> https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package</span><br><span class="line"> #豆瓣也OK</span><br><span class="line"> https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>



<h2 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package</span><br><span class="line"></span><br><span class="line">#有些模块只能在官方的站点下？</span><br><span class="line">pip install  tensorflow -i https:&#x2F;&#x2F;pypi.org&#x2F;simple</span><br></pre></td></tr></table></figure>

<p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p>
<h2 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h2><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置（如果是WIN，记得用管理员身份运行CMD）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line">pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>

<p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple pip -U</span><br></pre></td></tr></table></figure>

<h2 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --default-timeout&#x3D;100 install -U tensorflow-gpu # 设置超时时间</span><br></pre></td></tr></table></figure>

<h2 id="PYTHON-包安装更新"><a href="#PYTHON-包安装更新" class="headerlink" title="PYTHON 包安装更新"></a>PYTHON 包安装更新</h2><p>在PYcharm中，双击pip后面的蓝色升级箭头按钮。</p>
<p><a href="http://static.come2rss.xyz/image-20200503125713771.png"><img src="http://static.come2rss.xyz/image-20200503125713771.png" alt="image-20200503125713771"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125713771.png">image-20200503125713771</a></p>
<p>会出现如图所示，Specify version要打对勾。然后install package即可。</p>
<p>或者使用命令操作：<code>--upgrade</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade tensorflow -i https:&#x2F;&#x2F;pypi.org&#x2F;simple</span><br></pre></td></tr></table></figure>

<p>有时候由于一些环境上的问题，导致<code>pip</code>无法及时更新，所以采取另一种更新方法更有效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#强制更新</span><br><span class="line">python3 -m pip install -U --force-reinstall pip</span><br></pre></td></tr></table></figure>

<h1 id="PIP使用"><a href="#PIP使用" class="headerlink" title="PIP使用"></a>PIP使用</h1><p>pip 当前内建命令并不支持升级所有已安装的Python模块。</p>
<p>列出当前安装的包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>

<p>列出可升级的包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list --outdate</span><br></pre></td></tr></table></figure>

<p>升级一个包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade requests  &#x2F;&#x2F; mac,linux,unix 在命令前加 sudo -H</span><br></pre></td></tr></table></figure>

<p>升级所有可升级的包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip freeze --local | grep -v &#39;^-e&#39; | cut -d &#x3D; -f 1  | xargs -n1 pip install -U</span><br><span class="line">pip list -o --format legacy|awk &#39;&#123;print $1&#125;&#39;&#96; ; do pip install --upgrade $i; done</span><br></pre></td></tr></table></figure>

<p>显示包的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show numpy</span><br></pre></td></tr></table></figure>

<p>删除包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall numpy</span><br></pre></td></tr></table></figure>

<p>pip默认源由于墙，所以速度很慢，可使用第三源提高速度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.pip&#x2F;pip.conf</span><br><span class="line">[global]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trusted-host &#x3D; mirrors.aliyun.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index-url &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E9%98%B6/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="python基础学习笔记-进阶"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:12:46.000Z" title="2020-08-07T05:12:46.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Python/">Python</a></span><span class="level-item">2 hours read (About 14435 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E9%98%B6/">python基础学习笔记-进阶</a></h1><div class="content"><!-- mroe -->



<h1 id="速记"><a href="#速记" class="headerlink" title="速记"></a>速记</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><code>ls</code>表示一个list函数。</p>
<p><code>ls.pop(i)</code> 删除指定下标的内容。（可以用来删除str内容）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list_str &#x3D; list(string)</span><br><span class="line">list_str.pop(1)</span><br><span class="line">#join 可以合并一整个list！</span><br><span class="line">list_str &#x3D; &#39;&#39;.join(list_str)</span><br></pre></td></tr></table></figure>



<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p><code>dict.has_key(&#39;name&#39;)</code> 若有此键，则返回True，否则返回False。</p>
<blockquote>
<p>同样的，也可以使用in判断，<code>print ‘name’ in d.keys()</code></p>
</blockquote>
<h2 id="STR函数"><a href="#STR函数" class="headerlink" title="STR函数"></a>STR函数</h2><p><code>str</code>表示一个字符串对象。</p>
<p><code>str.upper()</code> 返回一个大写字母的字符串。</p>
<p><code>str.atoi()</code> 别python删掉了</p>
<p><code>str.join(str2)</code>返回两个字符串连接的新字符串 #join 可以合并一整个list！</p>
<p><code>str.replace(old, new[, max])</code> <strong>返回</strong>把str中的old换成new的字符串。在（最多换max次）</p>
<blockquote>
<p>也可以使用正则表示式中的sub来替换符合正则表达式的子串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)</span><br></pre></td></tr></table></figure>

<p>repl: 为新字符串</p>
<p>string：为原字符串</p>
</blockquote>
<p><code>str.strip(str)</code> 删除头尾指定字符 。参数为空时，默认去除ss字符串中头尾\r, \t, \n, 空格等字符。 <code>ss.lstrip()</code>删除ss字符串开头处的指定字符，<code>ss.rstrip()</code>删除ss结尾处的指定字符。</p>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><p><code>Zip(x,y)</code> 返回一个将两个迭代器或者list，tuple啥的一一对应的组合成新样本的迭代器，其内容长度为最短的一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;c &#x3D; [1, 3, 4 ]</span><br><span class="line">&gt;&gt;&gt;b &#x3D; [4, 3 ,2] </span><br><span class="line">&gt;&gt;&gt;Zip &#x3D; zip(c,b)</span><br><span class="line">&gt;&gt;&gt;Zip</span><br><span class="line">&lt;zip at 0x1fb0cd1f248&gt;</span><br><span class="line">&gt;&gt;&gt;for x, y in Zip:</span><br><span class="line">&gt;&gt;&gt;print(x, y)</span><br><span class="line">1 4</span><br><span class="line">3 3</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure>

<p>利用 *** 号操作符**，可以将二维数据重组为形式等价于转置的数据。</p>
<p>这个<a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/solution/">题目</a>就使用了该技巧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b &#x3D; [4,5,6]</span><br><span class="line">&gt;&gt;&gt; c &#x3D; [4,5,6,7,8]</span><br><span class="line">&gt;&gt;&gt; zipped &#x3D; zip(a,b)     # 打包为元组的列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure>

<p><code>enumerate(thing)</code> 注意他返回的是一个迭代器</p>
<p>enumerate(thing)<code>, where thing is either an iterator or a sequence, returns a iterator that will return</code>(0, thing[0])<code>,</code>(1, thing[1])<code>,</code>(2, thing[2])`, and so forth.</p>
<h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><p><code>enumerate</code> 可在迭代中得到遍历值和下标<code>for inx, val in enumerate([&#39;uyy&#39;, &#39;dfdf&#39;]):</code>。</p>
<h2 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h2><p><code>list(), str(), float(),int()</code> 比比皆是。</p>
<p>注意Python没有<code>char</code>类型，str字符串也不能和数字相减。</p>
<p><code>isinstance(instance, Object)</code> 判断一个实例是否是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(&#39;a&#39;, str)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b&#39;a&#39;, bytes)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><code>type()</code> 判断对象的类型，也可判断其他情况如是否是函数、lambda表示式等等。可参见<code>types</code>自定义的常量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; type(fn)&#x3D;&#x3D;types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs)&#x3D;&#x3D;types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x)&#x3D;&#x3D;types.LambdaType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10)))&#x3D;&#x3D;types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><code>dir()</code> 如果要获得一个对象的所有属性和方法，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&#39;ABC&#39;)</span><br><span class="line">[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;zfill&#39;]</span><br></pre></td></tr></table></figure>

<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&#39;ABC&#39;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; &#39;ABC&#39;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code> 获取属性、设置属性、是否拥有属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; obj.y # 获取属性&#39;y&#39;</span><br><span class="line">19</span><br></pre></td></tr></table></figure>

<p>如果试图获取不存在的属性，会抛出AttributeError的错误。</p>
<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404</span><br><span class="line">404</span><br></pre></td></tr></table></figure>

<p>获取对象的方法！</p>
<p>也可以获得对象的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn &#x3D; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn</span><br><span class="line">&gt;&gt;&gt; fn # fn指向obj.power</span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的</span><br><span class="line">81</span><br><span class="line">def readImage(fp):</span><br><span class="line">    if hasattr(fp, &#39;read&#39;):</span><br><span class="line">        return readData(fp)</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<p>假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。<code>hasattr()</code>就派上了用场。</p>
<p>请注意，在Python这类动态语言中，根据鸭子类型，有<code>read()</code>方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要<code>read()</code>方法返回的是有效的图像数据，就不影响读取图像的功能。</p>
<h1 id="奇妙的编程"><a href="#奇妙的编程" class="headerlink" title="奇妙的编程"></a>奇妙的编程</h1><h2 id="去重并建立索引"><a href="#去重并建立索引" class="headerlink" title="去重并建立索引"></a>去重并建立索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#使用set 取出corpus_chars 中唯一不重复的部分。</span><br><span class="line">idx_to_char &#x3D; list(set(corpus_chars))</span><br><span class="line"># 对唯一的数据生成键值对的tuple，并转化为dict</span><br><span class="line">char_to_idx &#x3D; dict([(char, i) for i, char in enumerate(idx_to_char)])</span><br></pre></td></tr></table></figure>

<h2 id="Max和Lambda"><a href="#Max和Lambda" class="headerlink" title="Max和Lambda"></a>Max和Lambda</h2><p>max 函数是 Python 的内置函数</p>
<p>max 有一个 key 参数，指定如何进行值得比较。</p>
<p>下面案例，求出现频次最多的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [13]: def mode(lst):</span><br><span class="line">             if lst is None or len(lst)&#x3D;&#x3D;0: </span><br><span class="line">                return None</span><br><span class="line">    ...:     return max(lst, key&#x3D;lambda v: lst.count(v))</span><br></pre></td></tr></table></figure>

<p>出镜最多的元素有多个时，按照以上方法，默认只返回一个。</p>
<p>下面，支持返回多个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [34]: def mode(lst):</span><br><span class="line">    ...:     if lst is None or len(lst)&#x3D;&#x3D;0:</span><br><span class="line">    ...:         return None</span><br><span class="line">    ...:     max_freq_elem &#x3D; max(lst, key&#x3D;lambda v: lst.count(v))</span><br><span class="line">    ...:     max_freq &#x3D; lst.count(max_freq_elem) # 出现最多次数</span><br><span class="line">    ...:     ret &#x3D; []</span><br><span class="line">    ...:     for i in lst:</span><br><span class="line">    ...:         if i not in ret and lst.count(i)&#x3D;&#x3D;max_freq:</span><br><span class="line">    ...:             ret.append(i)</span><br><span class="line">    ...:     return ret</span><br><span class="line"></span><br><span class="line">In [35]: mode([1,1,2,2,3,2,1])</span><br><span class="line">Out[35]: [1, 2]</span><br></pre></td></tr></table></figure>

<h3 id="多个list"><a href="#多个list" class="headerlink" title="多个list"></a>多个list</h3><p>带有一个 <code>*</code> 的参数为可变的位置参数，意味着能传入任意多个位置参数。</p>
<p>key 函数定义怎么比较大小：lambda 的参数 v 是 lists 中的一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [15]: def max_len(*lists):</span><br><span class="line">    ...:     return max(*lists, key&#x3D;lambda v: len(v))</span><br></pre></td></tr></table></figure>

<p>调用 max_len，传入三个列表，正是 v 可能的三个取值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [17]: r &#x3D; max_len([1, 2, 3], [4, 5, 6, 7], [8])</span><br><span class="line">    ...: print(f&#39; 更长的列表是 &#123;r&#125;&#39;)</span><br><span class="line">更长的列表是 [4, 5, 6, 7]</span><br></pre></td></tr></table></figure>

<p>关于 lambda 函数，在此做图形演示。</p>
<p>max_len 函数被传入三个实参，类型为 list，如下图所示，lists 变量指向最下面的 tuple 实例。</p>
<p><a href="http://static.come2rss.xyz/80dc83f0-5317-11ea-8128-358088d96de7"><img src="http://static.come2rss.xyz/80dc83f0-5317-11ea-8128-358088d96de7" alt="image-20200219203830985"></a></p>
<p><a href="http://static.come2rss.xyz/80dc83f0-5317-11ea-8128-358088d96de7">image-20200219203830985</a></p>
<p>程序运行到下一帧，会出现 lambda 函数，它的父函数为 f1，也就是 max_len 函数。</p>
<p>有些读者可能不理解两点，这种用法中：</p>
<ul>
<li>参数 v 取值到底是多少？</li>
<li>lambda 函数有返回值吗？如果有，返回值是多少？</li>
</ul>
<p>通过下面图形，非常容易看出，v 指向 tuple 实例的第一个元素，指向的线和箭头能非常直观地反映出来。</p>
<p><a href="http://static.come2rss.xyz/91f66a20-5317-11ea-b2e1-7d26d62747f1"><img src="http://static.come2rss.xyz/91f66a20-5317-11ea-b2e1-7d26d62747f1" alt="image-20200219204141898"></a></p>
<p><a href="http://static.come2rss.xyz/91f66a20-5317-11ea-b2e1-7d26d62747f1">image-20200219204141898</a></p>
<p>下面示意图中，看到返回值为 3，也就是 len(v) 的返回值，其中 v = [1,2,3]。</p>
<p><a href="http://static.come2rss.xyz/a078b580-5317-11ea-b2e1-7d26d62747f1"><img src="http://static.come2rss.xyz/a078b580-5317-11ea-b2e1-7d26d62747f1" alt="image-20200219204920052"></a></p>
<p><a href="http://static.come2rss.xyz/a078b580-5317-11ea-b2e1-7d26d62747f1">image-20200219204920052</a></p>
<p>然后，v 指向 tuple 中的下一个元素，返回值为 4。</p>
<p><a href="http://static.come2rss.xyz/af1391f0-5317-11ea-b2e1-7d26d62747f1"><img src="http://static.come2rss.xyz/af1391f0-5317-11ea-b2e1-7d26d62747f1" alt="img"></a></p>
<p><a href="http://static.come2rss.xyz/af1391f0-5317-11ea-b2e1-7d26d62747f1">img</a></p>
<p>然后，v 指向 tuple 的最后一个元素 [8]，返回值为 1。</p>
<p><a href="http://static.come2rss.xyz/bfc5dcb0-5317-11ea-8128-358088d96de7"><img src="http://static.come2rss.xyz/bfc5dcb0-5317-11ea-8128-358088d96de7" alt="image-20200219205408391"></a></p>
<p><a href="http://static.come2rss.xyz/bfc5dcb0-5317-11ea-8128-358088d96de7">image-20200219205408391</a></p>
<p>根据 key 确定的比较标准，max 函数的返回值为红色字体指向的元素，也就是返回 [4,5,6,7]。</p>
<p><a href="http://static.come2rss.xyz/ce141fc0-5317-11ea-8bb5-594930f74663"><img src="http://static.come2rss.xyz/ce141fc0-5317-11ea-8bb5-594930f74663" alt="img"></a></p>
<p><a href="http://static.come2rss.xyz/ce141fc0-5317-11ea-8bb5-594930f74663">img</a></p>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="容器对象"><a href="#容器对象" class="headerlink" title="容器对象"></a>容器对象</h2><p>在某些对象中会包含对其它对象的引用，这样的对象被称作<strong>容器</strong>(<em>containers</em>)。因此，我们可以把容器视作用于组织各种元素的数据结构。</p>
<p>下面是一些常见的容器对象：</p>
<ul>
<li>list, deque, …</li>
<li>set, frozensets, …</li>
<li>dict, defaultdict, OrderedDict, Counter, …</li>
<li>tuple, namedtuple, …</li>
<li>str</li>
</ul>
<p>详细内容见<a href="https://www.jianshu.com/p/63af3680c221">链接</a></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。<code>L[0:3]</code>表示，从索引<code>0</code>开始取，直到索引<code>3</code>为止，但不包括索引<code>3</code>。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def trim(s):</span><br><span class="line">	whlie s[:1] &#x3D;&#x3D; &#39; &#39;:</span><br><span class="line">		s &#x3D; s[1：]</span><br><span class="line">	whlie s[-1] &#x3D;&#x3D; &#39; &#39;:</span><br><span class="line">		s &#x3D; s[:-1]</span><br></pre></td></tr></table></figure>

<p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：字符串<code>&#39;xxx&#39;</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>更详细的补充<a href="https://www.cnblogs.com/wj-1314/p/8490822.html">汗颜</a></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>定义：<br>对于list、string、tuple、dict等这些<strong>容器对象</strong>,使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数。iter()是python内置函数。<br>iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内的元素。next()也是python内置函数。在没有后续元素时，next()会抛出一个StopIteration异常，通知for语句循环结束。</p>
<p>迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数的时候，调用的就是迭代器对象的_next_方法（Python3中是对象的_next_方法，Python2中是对象的next()方法）。所以，我们要想构造一个迭代器，就要实现它的_next_方法。但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现_iter_方法，而_iter_方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的_iter_方法返回自身self即可。</p>
<p><strong>术语解释</strong></p>
<p>1，<strong>迭代器</strong>协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。</p>
<p>2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。</p>
<p>3，for item in Iterable 循环的<strong>本质</strong>就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束</p>
<p><strong>容器对象化为迭代器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 随便定义一个list</span><br><span class="line">listArray&#x3D;[1,2,3]</span><br><span class="line"># 使用iter()函数</span><br><span class="line">iterName&#x3D;iter(listArray)</span><br><span class="line">print(iterName)</span><br><span class="line"># 结果如下：是一个列表list的迭代器</span><br><span class="line"># &lt;list_iterator object at 0x0000017B0D984278&gt;</span><br><span class="line"></span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))#没有迭代到下一个元素，直接抛出异常</span><br><span class="line"># 1</span><br><span class="line"># 2</span><br><span class="line"># 3</span><br><span class="line"># Traceback (most recent call last):</span><br><span class="line">#   File &quot;Test07.py&quot;, line 32, in &lt;module&gt;</span><br><span class="line"># StopIteration</span><br></pre></td></tr></table></figure>

<p><strong>自定义迭代器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self, max):</span><br><span class="line">        super(Fib, self).__init__()</span><br><span class="line">        self.max &#x3D; max</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.a &#x3D; 0</span><br><span class="line">        self.b &#x3D; 1</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        fib &#x3D; self.a</span><br><span class="line">        if fib &gt; self.max:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.a, self.b &#x3D; self.b, self.a + self.b</span><br><span class="line">        return fib</span><br><span class="line"></span><br><span class="line"># 定义一个main函数，循环遍历每一个菲波那切数</span><br><span class="line">def main():</span><br><span class="line">    # 20以内的数</span><br><span class="line">    fib &#x3D; Fib(20)</span><br><span class="line">    for i in fib:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<p>在本类的实现中，定义了一个<em>iter</em>(self)方法，这个方法是在for循环遍历时被iter()调用，返回一个迭代器。因为在遍历的时候，是直接调用的python内置函数iter()，由iter()通过调用<em>iter</em>(self)获得对象的迭代器。有了迭代器，就可以逐个遍历元素了。而逐个遍历的时候，也是使用内置的next(）函数通过调用对象的<em>next</em>(self)方法对迭代器对象进行遍历。所以要实现<em>iter</em>(self)和<em>next</em>(self)这两个方法。</p>
<p>而且因为实现了<em>next</em>(self)方法，所以在实现<em>iter</em>(self)的时候，直接返回self就可以。</p>
<p>总结一句话就是：<br>在循环遍历自定义容器对象时,会使用python内置函数iter()调用遍历对象的<em>iter</em>(self)获得一个迭代器,之后再循环对这个迭代器使用next()调用迭代器对象的<em>next</em>(self)。</p>
<p>注意点：<em>iter</em>(self)只会被调用一次,而<em>next</em>(self)会被调用 n 次，直到出现StopIteration异常。</p>
<p><strong>判断可迭代</strong>可使用<code>Iterable</code>类型来判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&#39;abc&#39;, Iterable) #判断 &#39;abc&#39; 是否可迭代</span><br><span class="line"># True</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是一类特殊的迭代器。生成器是只能遍历一次的</p>
<p>延迟操作。也就是在需要的时候才产生结果，不是立即产生结果。</p>
<p>第一类：生成器函数：还是使用 def 定义函数，但是，使用yield而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次从它离开的地方继续执行。</p>
<p>如下案例加以说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 菲波那切数列</span><br><span class="line">def Fib(max):</span><br><span class="line">    n, a, b &#x3D; 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b &#x3D; b, a + b</span><br><span class="line">        n &#x3D; n + 1</span><br><span class="line">    return &#39;亲！没有数据了...&#39;</span><br><span class="line"># 调用方法，生成出10个数来</span><br><span class="line">f&#x3D;Fib(10)</span><br><span class="line"># 使用一个循环捕获最后return 返回的值，保存在异常StopIteration的value中</span><br><span class="line">while  True:</span><br><span class="line">    try:</span><br><span class="line">        x&#x3D;next(f)</span><br><span class="line">        print(&quot;f:&quot;,x)</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        print(&quot;生成器最后的返回值是：&quot;,e.value)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<p>第二类：生成器表达式：类似于列表推导，只不过是把一对大括号[]变换为一对小括号()。但是，生成器表达式是按需产生一个生成器结果对象，要想拿到每一个元素，就需要循环遍历。</p>
<p>如下案例加以说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># 一个列表</span><br><span class="line">xiaoke&#x3D;[2,3,4,5]</span><br><span class="line"># 生成器generator，类似于list，但是是把[]改为()</span><br><span class="line">gen&#x3D;(a for a  in xiaoke)</span><br><span class="line">for  i  in gen:</span><br><span class="line">    print(i)</span><br><span class="line">#结果是：</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">#也可以使用next调用generator</span><br><span class="line">generator_ex &#x3D; (x*x for x in range(10))</span><br><span class="line">print(next(generator_ex))</span><br><span class="line">print(next(generator_ex))</span><br><span class="line">print(next(generator_ex))</span><br><span class="line">print(next(generator_ex))</span><br><span class="line">print(next(generator_ex))</span><br><span class="line">print(next(generator_ex))</span><br><span class="line">print(next(generator_ex))</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line"># 为什么要使用生成器？因为效率。</span><br><span class="line"># 使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。</span><br><span class="line"># 如果你构造一个列表(list)的目的仅仅是传递给别的函数,</span><br><span class="line"># 比如 传递给tuple()或者set(), 那就用生成器表达式替代吧!</span><br><span class="line"></span><br><span class="line"># 本案例是直接把列表转化为元组</span><br><span class="line">kk&#x3D;tuple(a for a in xiaoke)</span><br><span class="line">print(kk)</span><br><span class="line">#结果是：</span><br><span class="line">(2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line"># python内置的一些函数，可以识别这是生成器表达式，外面有一对小括号，就是生成器，中括号就列表生成式</span><br><span class="line">result1&#x3D;sum(a for a in range(3))</span><br><span class="line">print(result1)</span><br><span class="line"># 列表推导式</span><br><span class="line">result2&#x3D;sum([a for a in range(3)])</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure>

<h3 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h3><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x * x for x in range(1, 11)]</span><br><span class="line">[x * x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]</span><br></pre></td></tr></table></figure>

<p>还可以使用两层循环，可以生成全排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</span><br><span class="line">[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</span><br></pre></td></tr></table></figure>

<p>三层和三层以上的循环就很少用到了。</p>
<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到</span><br><span class="line">&gt;&gt;&gt; [d for d in os.listdir(&#39;.&#39;)] # os.listdir可以列出文件和目录</span><br><span class="line">[&#39;.emacs.d&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;Adlm&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, &#39;Documents&#39;, &#39;Downloads&#39;, &#39;Library&#39;, &#39;Movies&#39;, &#39;Music&#39;, &#39;Pictures&#39;, &#39;Public&#39;, &#39;VirtualBox VMs&#39;, &#39;Workspace&#39;, &#39;XCode&#39;]</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环其实可以同时使用两个甚至多个变量，比如<code>dict</code>的<code>items()</code>可以同时迭代key和value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; &#125;</span><br><span class="line">&gt;&gt;&gt; [k + &#39;&#x3D;&#39; + v for k, v in d.items()]</span><br><span class="line">[&#39;y&#x3D;B&#39;, &#39;x&#x3D;A&#39;, &#39;z&#x3D;C&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>Note：</strong> 在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。也就是说<code>for</code>后面不能加<code>else</code>，而<code>for</code>前面<code>if</code>必须加<code>else</code>。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>类中的属性可以通过方法的包装来防止外露，但是直接调用方法不如直接写属性简介明白。程序员们想出了装饰器<code>@property</code>个东西来修饰方法，是其可以方法可以如同属性一样使用、赋值。当然Python最后会把它转化为等价的方法调用形式？</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">	#定义了一个只读的属性</span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line">	#定义了一个可读也可写的属性</span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&#39;score must be an integer!&#39;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&#39;score must between 0 ~ 100!&#39;)</span><br><span class="line">        self._score &#x3D; value</span><br><span class="line">        </span><br><span class="line">    # 仅定义@property的方法是定义了一个只读属性</span><br><span class="line">	@property</span><br><span class="line">	def age(self):</span><br><span class="line">		return self.age</span><br></pre></td></tr></table></figure>

<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>假设在为了每个功能而专门设计一个类并同时作为一个父亲类，那么类数量可能会指数型增长而且类的层次变得更加复杂。</p>
<p><a href="http://static.come2rss.xyz/image-20200503125546752.png"><img src="http://static.come2rss.xyz/image-20200503125546752.png" alt="image-20200503125546752"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125546752.png">image-20200503125546752</a></p>
<p>为了解决这一个问题，多重继承的概念就此引出，即一个类可以继承多个类，那么只需要把需要添加的功能写成类，并继承给相应需要的类即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#比如给Dog添加Runable， Carnivorous 的功能</span><br><span class="line">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h2 id="自定义类-magic-function的天下"><a href="#自定义类-magic-function的天下" class="headerlink" title="自定义类 magic function的天下"></a>自定义类 magic function的天下</h2><p>我们先定义一个<code>Student</code>类，打印一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name &#x3D; name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(Student(&#39;Michael&#39;))</span><br><span class="line">&lt;__main__.Student object at 0x109afb190&gt;</span><br></pre></td></tr></table></figure>

<p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>
<p><code>__slots__</code>我们已经知道怎么用了，<code>__len__()</code>方法我们也知道是为了能让class作用于<code>len()</code>函数。</p>
<p>除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<h4 id="str-repr-len-iter-getitem-setitem"><a href="#str-repr-len-iter-getitem-setitem" class="headerlink" title="__str__() __repr__() __len__() __iter__ __getitem__ __setitem__()"></a><code>__str__()</code> <code>__repr__()</code> <code>__len__()</code> <code>__iter__</code> <code>__getitem__</code> <code>__setitem__()</code></h4><p><code>__str__()</code>可在<code>print(class)</code>时调用，并显示出内容。 如果不定义的话，一般都是这样子的打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p>
<p><code>__repr__()</code>在直接敲变量的被调用，同样也可以自定义来输出的好看一点，也可以偷懒一点<code>__repr__ = __str__</code>。</p>
<p><code>__len__()</code> 可在<code>__len__()</code>时调用。</p>
<p><code>__iter__</code> 该方法返回一个迭代对象以供<code>for</code>循环使用。然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b &#x3D; 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b &#x3D; self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a # 返回下一个值</span><br></pre></td></tr></table></figure>

<p>现在，试试把Fib实例作用于for循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in Fib():</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">...</span><br><span class="line">46368</span><br><span class="line">75025</span><br></pre></td></tr></table></figure>

<p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Fib()[5]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#39;Fib&#39; object does not support indexing</span><br></pre></td></tr></table></figure>

<p><code>__getitem__</code> 可以实现按元素寻址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        a, b &#x3D; 1, 1</span><br><span class="line">        for x in range(n):</span><br><span class="line">            a, b &#x3D; b, a + b</span><br><span class="line">        return a</span><br></pre></td></tr></table></figure>

<p>现在，就可以按下标访问数列的任意一项了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; Fib()</span><br><span class="line">&gt;&gt;&gt; f[0]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>但是list有个神奇的切片方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(100))[5:10]</span><br><span class="line">[5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>对于Fib却报错。原因是<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象<code>slice</code>，所以要做判断：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        if isinstance(n, int): # n是索引</span><br><span class="line">            a, b &#x3D; 1, 1</span><br><span class="line">            for x in range(n):</span><br><span class="line">                a, b &#x3D; b, a + b</span><br><span class="line">            return a</span><br><span class="line">        if isinstance(n, slice): # n是切片</span><br><span class="line">            start &#x3D; n.start</span><br><span class="line">            stop &#x3D; n.stop</span><br><span class="line">            if start is None:</span><br><span class="line">                start &#x3D; 0</span><br><span class="line">            a, b &#x3D; 1, 1</span><br><span class="line">            L &#x3D; []</span><br><span class="line">            for x in range(stop):</span><br><span class="line">                if x &gt;&#x3D; start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b &#x3D; b, a + b</span><br><span class="line">            return L</span><br></pre></td></tr></table></figure>

<p>现在试试Fib的切片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; Fib()</span><br><span class="line">&gt;&gt;&gt; f[0:5]</span><br><span class="line">[1, 1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; f[:10]</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure>

<p>但是没有对step参数作处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f[:10:2]</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span><br></pre></td></tr></table></figure>

<p>也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p>
<p>此外，如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code>。</p>
<p>与之对应的是<code>__setitem__()</code>方法，把对象视作list或dict来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。</p>
<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h4 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h4><p>一般来说，如果调用一个不存在的属性，会爆出错误，提示没有这个<code>attribute</code>。要避免这个错误，除了可以加上一个<code>score</code>属性外，Python还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name &#x3D; &#39;Michael&#39;</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr&#x3D;&#x3D;&#39;score&#39;:</span><br><span class="line">            return 99</span><br><span class="line">         # 返回函数也是完全可以的：    </span><br><span class="line">        if attr&#x3D;&#x3D;&#39;age&#39;:</span><br><span class="line">            return lambda: 25</span><br></pre></td></tr></table></figure>

<p>python对于调用的不存在的类的函数和属性会都使用<code>__getattr__()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; Student()</span><br><span class="line">&gt;&gt;&gt; s.name</span><br><span class="line">&#39;Michael&#39;</span><br><span class="line">&gt;&gt;&gt; s.score</span><br><span class="line">99</span><br><span class="line">&gt;&gt;&gt; s.age()</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>: 只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p>
<p>注意到任意调用<code>__getattr__</code>也未定义的属性都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让class只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        if attr&#x3D;&#x3D;&#39;age&#39;:</span><br><span class="line">            return lambda: 25</span><br><span class="line">        raise AttributeError(&#39;Student object has no attribute %s % attr)</span><br></pre></td></tr></table></figure>

<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>
<p>举个例子：</p>
<p>现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：</p>
<ul>
<li><a href="http://api.server/user/friends">http://api.server/user/friends</a></li>
<li><a href="http://api.server/user/timeline/list">http://api.server/user/timeline/list</a></li>
</ul>
<p>如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。</p>
<p>利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Chain(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, path&#x3D;&#39;&#39;):</span><br><span class="line">        self._path &#x3D; path</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, path):</span><br><span class="line">    	#返回一个Chain对象，而且path随着新的对象而动态增长了！</span><br><span class="line">        return Chain(&#39;%s&#x2F;%s&#39; % (self._path, path))</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line"></span><br><span class="line">    __repr__ &#x3D; __str__</span><br></pre></td></tr></table></figure>

<p>试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#一开始&#96;chain()&#96;的&#96;_path&#96;为空！</span><br><span class="line">&gt;&gt;&gt; Chain().status.user.timeline.list</span><br><span class="line">&#39;&#x2F;status&#x2F;user&#x2F;timeline&#x2F;list&#39;</span><br></pre></td></tr></table></figure>

<p>这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！</p>
<p>还有些REST API会把参数放到URL中，比如GitHub的API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;users&#x2F;:user&#x2F;repos</span><br></pre></td></tr></table></figure>

<p>调用时，需要把<code>:user</code>替换为实际用户名。如果我们能写出这样的链式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chain().users(&#39;michael&#39;).repos</span><br></pre></td></tr></table></figure>

<p>就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。</p>
<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&#39;My name is %s.&#39; % self.name)</span><br><span class="line">&gt;&gt;&gt; s &#x3D; Student(&#39;Michael&#39;)</span><br><span class="line">&gt;&gt;&gt; s() # self参数不要传入</span><br><span class="line">My name is Michael.</span><br></pre></td></tr></table></figure>

<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>
<p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断<strong>一个对象是否能被调用</strong>，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例.通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; callable(Student())</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable(max)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; callable([1, 2, 3])</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(None)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; callable(&#39;str&#39;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p><code>Enum</code>枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line">#返回&#96;Month&#96;类型的枚举类</span><br><span class="line">Month &#x3D; Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))</span><br></pre></td></tr></table></figure>

<p>可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, &#39;&#x3D;&gt;&#39;, member, &#39;,&#39;, member.value)</span><br></pre></td></tr></table></figure>

<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line">#@unique装饰器可以帮助我们检查保证没有重复值。</span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun &#x3D; 0 # Sun的value被设定为0</span><br><span class="line">    Mon &#x3D; 1</span><br><span class="line">    Tue &#x3D; 2</span><br><span class="line">    Wed &#x3D; 3</span><br><span class="line">    Thu &#x3D; 4</span><br><span class="line">    Fri &#x3D; 5</span><br><span class="line">    Sat &#x3D; 6</span><br></pre></td></tr></table></figure>

<p>访问枚举类型的方法归纳：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#引用</span><br><span class="line">##属性</span><br><span class="line">&gt;&gt;&gt; day1 &#x3D; Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line"></span><br><span class="line">##下标</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&#39;Tue&#39;])</span><br><span class="line">Weekday.Tue</span><br><span class="line"></span><br><span class="line">##方法调用，（必须是int）</span><br><span class="line">&gt;&gt;&gt; print(Weekday(1))</span><br><span class="line">Weekday.Mon</span><br><span class="line"></span><br><span class="line">#属性具有值</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</span><br><span class="line">2</span><br><span class="line">#属性之间可以比较</span><br><span class="line">&gt;&gt;&gt; print(day1 &#x3D;&#x3D; Weekday.Mon)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(day1 &#x3D;&#x3D; Weekday.Tue)</span><br><span class="line">False</span><br><span class="line">#遍历</span><br><span class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</span><br><span class="line">...     print(name, &#39;&#x3D;&gt;&#39;, member)</span><br><span class="line">...</span><br><span class="line">Sun &#x3D;&gt; Weekday.Sun</span><br><span class="line">Mon &#x3D;&gt; Weekday.Mon</span><br><span class="line">Tue &#x3D;&gt; Weekday.Tue</span><br><span class="line">Wed &#x3D;&gt; Weekday.Wed</span><br><span class="line">Thu &#x3D;&gt; Weekday.Thu</span><br><span class="line">Fri &#x3D;&gt; Weekday.Fri</span><br><span class="line">Sat &#x3D;&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>

<h2 id="Callback函数"><a href="#Callback函数" class="headerlink" title="Callback函数"></a>Callback函数</h2><p>在我的理解下，Callback是可以指函数A可以作为参数传入一个函数B并在函数B中调用A，即A是Callbackable的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#callback</span><br><span class="line">def cb(value):</span><br><span class="line">    if  value % 130 &#x3D;&#x3D; 0:</span><br><span class="line">        return (True, value)</span><br><span class="line">    elif value &gt; 100000:</span><br><span class="line">        return (True, None)</span><br><span class="line">    return (False ,None)</span><br><span class="line"></span><br><span class="line">def fibonacci_call(func):</span><br><span class="line">    values &#x3D; []</span><br><span class="line">    while(True):</span><br><span class="line">        if len(values) &lt; 2:</span><br><span class="line">            values.append(1)</span><br><span class="line">        else:</span><br><span class="line">            values &#x3D; [values[-1], values[-2] + values[-1]]</span><br><span class="line">        res &#x3D;  func(values[-1] )</span><br><span class="line">        print(values[-1])</span><br><span class="line">        if res[0]:</span><br><span class="line">            return res[1]</span><br><span class="line">        </span><br><span class="line">fibonacci_call(cb)</span><br></pre></td></tr></table></figure>

<h2 id="Python的对象说明"><a href="#Python的对象说明" class="headerlink" title="Python的对象说明"></a>Python的对象说明</h2><p>Python的一切都是一个对象，当传参给函数的时候传的是一个对象的指针！那么在函数内部进行改变变量的指向的时候，原数据是不会受到影响的！如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 10</span><br><span class="line">def test(a):</span><br><span class="line">    a &#x3D; a + 1</span><br><span class="line">    print(a)</span><br><span class="line">test(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>11<br>10<br>​```</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">所以只能不改变原来的指向，直接改变原来的值！如</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;python</span><br><span class="line">a &#x3D; [1]</span><br><span class="line">def test(a):</span><br><span class="line">	a[0] &#x3D; 2</span><br><span class="line">    print(a)</span><br><span class="line">test(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>[1]<br>[1]<br>​```</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">## 元类MateClass</span><br><span class="line"></span><br><span class="line">看不太懂，溜了溜了 https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;wiki&#x2F;1016959663602400&#x2F;1017592449371072</span><br><span class="line"></span><br><span class="line">## 引用顺序以及关键字</span><br><span class="line"></span><br><span class="line">### 命名空间</span><br><span class="line"></span><br><span class="line">命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</span><br><span class="line"></span><br><span class="line">命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</span><br><span class="line"></span><br><span class="line">一般有三种命名空间：</span><br><span class="line"></span><br><span class="line">- **内置名称（built-in names**）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</span><br><span class="line">- **全局名称（global names）**，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</span><br><span class="line">- **局部名称（local names）**，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</span><br><span class="line"></span><br><span class="line">**命名空间的生命周期**：</span><br><span class="line"></span><br><span class="line">命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</span><br><span class="line"></span><br><span class="line">因此，我们无法从外部命名空间访问内部命名空间的对象。</span><br><span class="line"></span><br><span class="line">### 作用域</span><br><span class="line"></span><br><span class="line">作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</span><br><span class="line"></span><br><span class="line">Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：</span><br><span class="line"></span><br><span class="line">有四种作用域：</span><br><span class="line"></span><br><span class="line">- **L（Local）**：最内层，包含局部变量，比如一个函数&#x2F;方法内部。</span><br><span class="line">- **E（Enclosing）**：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</span><br><span class="line">- **G（Global）**：当前脚本的最外层，比如当前模块的全局变量。</span><br><span class="line">- **B（Built-in）**： 包含了内建的变量&#x2F;关键字等。，最后被搜索</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**查找变量的顺序：**</span><br><span class="line"></span><br><span class="line">python引用变量的顺序： 当前作用域局部变量（此函数）-&gt;外层作用域变量-&gt;当前模块中的全局变量-&gt;python内置变量</span><br><span class="line"></span><br><span class="line">![image-20200503125603390](http:&#x2F;&#x2F;static.come2rss.xyz&#x2F;image-20200503125603390.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**全局变量和局部变量**</span><br><span class="line"></span><br><span class="line">定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</span><br><span class="line"></span><br><span class="line">局部变量只能在其被声明的函数内部**访问**，而全局变量可以在整个程序范围内访问。调用函数时，**所有在函数内声明的变量名称都将被加入到作用域中**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### global 和 nonlocal关键字</span><br><span class="line"></span><br><span class="line">当内部作用域想**修改**外部作用域的变量时，就要用到global和nonlocal关键字了。</span><br><span class="line"></span><br><span class="line">如果要修改**嵌套**作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;python</span><br><span class="line">def a():</span><br><span class="line">	var &#x3D; 1</span><br><span class="line">	def b():</span><br><span class="line">		nonlocal var #注意这里var的nonlocal的声明不可以接后续的东西</span><br><span class="line">		var &#x3D; 2</span><br></pre></td></tr></table></figure>

<h2 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h2><p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。在Python中，定义类是通过<code>class</code>关键字：</p>
<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是<strong>大写开头</strong>的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>
<p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，创建实例是通过类名()实现的：</p>
<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student()</span><br><span class="line">&gt;&gt;&gt; bart</span><br><span class="line">&lt;__main__.Student object at 0x10a67a590&gt;</span><br><span class="line">&gt;&gt;&gt; Student</span><br><span class="line">&lt;class &#39;__main__.Student&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x10a67a590</code>是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类。</p>
<p>可以<strong>自由地给一个实例变量绑定属性</strong>，比如，给实例<code>bart</code>绑定一个<code>name</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.name &#x3D; &#39;Bart Simpson&#39;</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br></pre></td></tr></table></figure>

<p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.score &#x3D; score</span><br></pre></td></tr></table></figure>

<p>注意：特殊方法“<strong>init</strong>”前后分别有两个下划线！！！</p>
<p>注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p>
<p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br></pre></td></tr></table></figure>

<p>和普通的函数相比，在<strong>类中定义的函数只有一点不同</strong>，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>面向对象编程的一个重要特点就是数据封装。在上面的<code>Student</code>类中，每个实例就拥有各自的<code>name</code>和<code>score</code>这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def print_score(std):</span><br><span class="line">...     print(&#39;%s: %s&#39; % (std.name, std.score))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print_score(bart)</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure>

<p>但是，既然<code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.score &#x3D; score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&#39;%s: %s&#39; % (self.name, self.score))</span><br></pre></td></tr></table></figure>

<p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.print_score()</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure>

<p>这样一来，我们从外部看<code>Student</code>类，就只需要知道，创建实例需要给出<code>name</code>和<code>score</code>，而如何打印，都是在<code>Student</code>类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p>
<p>封装的另一个好处是可以给<code>Student</code>类增加新的方法，比如<code>get_grade</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.score &gt;&#x3D; 90:</span><br><span class="line">            return &#39;A&#39;</span><br><span class="line">        elif self.score &gt;&#x3D; 60:</span><br><span class="line">            return &#39;B&#39;</span><br><span class="line">        else:</span><br><span class="line">            return &#39;C&#39;</span><br></pre></td></tr></table></figure>

<p>同样的，<code>get_grade</code>方法可以直接在实例变量上调用，不需要知道内部实现细节：</p>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><hr>
<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>
<p>私有变量（private）是类中属性的名称前加上两个下划线<code>__</code>的属性，在Python中，实例的变量名如果以<code>__</code>开头，所以，我们把Student类改一改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name &#x3D; name</span><br><span class="line">        self.__score &#x3D; score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&#39;%s: %s&#39; % (self.__name, self.__score))</span><br></pre></td></tr></table></figure>

<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>但是如果外部代码要获取和修改name和score怎么办？可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self.__name</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        self.__score &#x3D; score</span><br></pre></td></tr></table></figure>

<p>在这种方法中，可以对参数做<strong>检查</strong>，避免传入无效的参数：</p>
<p>需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，<strong>特殊变量是可以直接访问的</strong>，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p><strong>原理：</strong>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart._Student__name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br></pre></td></tr></table></figure>

<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把<code>__name</code>改成不同的变量名。总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。</p>
<p>最后注意下面的这种<em>错误写法</em>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)</span><br><span class="line">&gt;&gt;&gt; bart.get_name()</span><br><span class="line">&#39;Bart Simpson&#39;</span><br><span class="line">&gt;&gt;&gt; bart.__name &#x3D; &#39;New Name&#39; # 设置__name变量！</span><br><span class="line">&gt;&gt;&gt; bart.__name</span><br><span class="line">&#39;New Name&#39;</span><br></pre></td></tr></table></figure>

<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name</span><br><span class="line">&#39;Bart Simpson&#39;</span><br></pre></td></tr></table></figure>

<p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure>

<p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Animal())</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure>

<p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure>

<p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Cat())</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>

<p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Tortoise is running slowly...&#39;)</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Tortoise())</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure>

<p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p>
<p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p>对扩展开放：允许新增<code>Animal</code>子类；</p>
<p>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
<p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                ┌───────────────┐</span><br><span class="line">                │    object     │</span><br><span class="line">                └───────────────┘</span><br><span class="line">                        │</span><br><span class="line">           ┌────────────┴────────────┐</span><br><span class="line">           │                         │</span><br><span class="line">           ▼                         ▼</span><br><span class="line">    ┌─────────────┐           ┌─────────────┐</span><br><span class="line">    │   Animal    │           │    Plant    │</span><br><span class="line">    └─────────────┘           └─────────────┘</span><br><span class="line">           │                         │</span><br><span class="line">     ┌─────┴──────┐            ┌─────┴──────┐</span><br><span class="line">     │            │            │            │</span><br><span class="line">     ▼            ▼            ▼            ▼</span><br><span class="line">┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</span><br><span class="line">│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │</span><br><span class="line">└─────────┘  └─────────┘  └─────────┘  └─────────┘</span><br></pre></td></tr></table></figure>

<h3 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h3><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Timer(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&#39;Start...&#39;)</span><br></pre></td></tr></table></figure>

<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一<strong>个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</strong></p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
<p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
<h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。</p>
<p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">s &#x3D; Student(&#39;Bob&#39;)</span><br><span class="line">s.score &#x3D; 90</span><br></pre></td></tr></table></figure>

<p>但是，如果<code>Student</code>类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name &#x3D; &#39;Student&#39;</span><br></pre></td></tr></table></figure>

<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name &#x3D; &#39;Student&#39;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s &#x3D; Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name &#x3D; &#39;Michael&#39; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
<p>小结：python可以动态绑定实例属性，但是最好别和类属性重合，不然会会覆盖掉类属性。</p>
<h2 id="Python高级面对对象编程"><a href="#Python高级面对对象编程" class="headerlink" title="Python高级面对对象编程"></a>Python高级面对对象编程</h2><h3 id="添加对象和属性"><a href="#添加对象和属性" class="headerlink" title="添加对象和属性"></a>添加对象和属性</h3><p>Python这种动态类型语言可以在运行过程中动态添加定义给类和实例添加方法和属性。但是给实例添加的属性和方法是无法对新建的实例生效的，或者说无法改变类。</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br><span class="line">&gt;&gt;&gt; s &#x3D; Student()</span><br><span class="line">&gt;&gt;&gt; s.name &#x3D; &#39;Michael&#39; # 动态给实例绑定一个属性</span><br><span class="line">&gt;&gt;&gt; print(s.name)</span><br><span class="line">Michael   </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法</span><br><span class="line">...     self.age &#x3D; age</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; from types import MethodType</span><br><span class="line">&gt;&gt;&gt; s.set_age &#x3D; MethodType(set_age, s) # 给实例绑定一个方法</span><br><span class="line">&gt;&gt;&gt; s.set_age(25) # 调用实例方法</span><br><span class="line">&gt;&gt;&gt; s.age # 测试结果</span><br><span class="line">25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s2 &#x3D; Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法,</span><br><span class="line">#可以见到给一个实例添加的方法是不对另一个实例起作用的</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &#39;Student&#39; object has no attribute &#39;set_age&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def set_score(self, score):</span><br><span class="line">...     self.score &#x3D; score</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Student.set_score &#x3D; set_score # 给类绑定方法</span><br></pre></td></tr></table></figure>

<h5 id="使用-slots-限制类的属性"><a href="#使用-slots-限制类的属性" class="headerlink" title="使用__slots__限制类的属性"></a>使用<code>__slots__</code>限制类的属性</h5><p>可以使用特殊变量<code>__slots__</code>来限制类的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ &#x3D; (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; s &#x3D; Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s.name &#x3D; &#39;Michael&#39; # 绑定属性&#39;name&#39;</span><br><span class="line">&gt;&gt;&gt; s.age &#x3D; 25 # 绑定属性&#39;age&#39;</span><br><span class="line">&gt;&gt;&gt; s.score &#x3D; 99 # 绑定属性&#39;score&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>age</code>由于没有被<code>__slots__</code>包括在内，所以不可被绑定。</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h2 id="函数式编程-Functional-Programming"><a href="#函数式编程-Functional-Programming" class="headerlink" title="函数式编程 Functional Programming"></a>函数式编程 Functional Programming</h2><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p>
<p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>
<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>
<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>
<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>
<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为<strong>没有副作用</strong>。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把<strong>函数本身作为参数传入另一个函数</strong>，还允许返回一个函数！</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h4><p>函数名其实就是指向函数的变量！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，它指向一个可以计算绝对值的函数！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs &#x3D; 10</span><br><span class="line">&gt;&gt;&gt; abs(-10)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#39;int&#39; object is not callable</span><br></pre></td></tr></table></figure>

<p>把<code>abs</code>指向<code>10</code>后，就无法通过<code>abs(-10)</code>调用该函数了！因为<code>abs</code>这个变量已经不指向求绝对值函数而是指向一个整数<code>10</code>！要恢复<code>abs</code>函数，请重启Python交互环境。</p>
<p>注：由于<code>abs</code>函数实际上是定义在<code>import builtins</code>模块中的，所以要让修改<code>abs</code>变量的指向在其它模块也生效，要用<code>import builtins; builtins.abs = 10</code>。</p>
<h4 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h4><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    return f(x) + f(y)</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; -5</span><br><span class="line">y &#x3D; 6</span><br><span class="line">f &#x3D; abs</span><br><span class="line">f(x) + f(y) &#x3D;&#x3D;&gt; abs(-5) + abs(6) &#x3D;&#x3D;&gt; 11</span><br><span class="line">return 11</span><br></pre></td></tr></table></figure>

<h3 id="Map-Reduct"><a href="#Map-Reduct" class="headerlink" title="Map/Reduct"></a>Map/Reduct</h3><p>Python内建了<code>map()</code>和<code>reduce()</code>函数。</p>
<p>如果你读过Google的那篇大名鼎鼎的论文“<a href="http://research.google.com/archive/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a>”，你就能大概明白map/reduce的概念。</p>
<p>我们先看map。<code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r &#x3D; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>

<p><code>map()</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个<code>Iterator</code>，<code>Iterator</code>是惰性序列，因此通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p>
<p>看<code>reduce</code>的用法。<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做”累积”。其实这么描述并不够详细，</p>
<p><a href="https://www.cnblogs.com/51kata/p/5438195.html">参考</a></p>
<blockquote>
<p>reduce操作是函数式编程中的重要技术之一，其作用是通过对一个集合的操作，可以从中生成一个值。比如最常见的求和，求最大值、最小值等都是reduce操作的典型例子。python通过内置reduce函数对reduce操作提供了很好的支持。</p>
<p>函数语法： reduce(function, iterable[,initializer])</p>
<p>函数参数含义如下：</p>
<p>1、function 需要带两个参数，1个是用于保存操作的结果，另一个是每次迭代的元素。</p>
<p>2、iterable 待迭代处理的集合</p>
<p>3、initializer 初始值，可以没有。</p>
<p>reduce函数的运作过程是，当调用reduce方法时：</p>
<p>1、如果存在initializer参数，会先从iterable中取出第一个元素值，然后initializer和元素值会传给function处理；</p>
<p>接着再从iterable中取出第二个元素值，与function函数的返回值 再一起传给function处理，以此迭代处理完所有元素。最后一次处理的function返回值就是reduce函数的返回值。</p>
<p>2、如果不存在initializer参数，会先从iterable中取出第一个元素值作为initializer值，然后以此从iterable取第二个元素及以后的元素进行处理。特殊情况下，如果集合只有一个元素，则无论function如何处理，reduce返回的都是第一个元素的值。</p>
<p>下面我们通过具体的例子来说明。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">CHAR_TO_FLOAT &#x3D; &#123;</span><br><span class="line">    &#39;0&#39;: 0,</span><br><span class="line">    &#39;1&#39;: 1,</span><br><span class="line">    &#39;2&#39;: 2,</span><br><span class="line">    &#39;3&#39;: 3,</span><br><span class="line">    &#39;4&#39;: 4,</span><br><span class="line">    &#39;5&#39;: 5,</span><br><span class="line">    &#39;6&#39;: 6,</span><br><span class="line">    &#39;7&#39;: 7,</span><br><span class="line">    &#39;8&#39;: 8,</span><br><span class="line">    &#39;9&#39;: 9,</span><br><span class="line">    &#39;.&#39;: -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def str2float(s):</span><br><span class="line">    nums &#x3D; map(lambda y: CHAR_TO_FLOAT[y], s)</span><br><span class="line">    point &#x3D; 0</span><br><span class="line">    def add(sum, x):</span><br><span class="line">        nonlocal point</span><br><span class="line">        if x &#x3D;&#x3D; -1 :</span><br><span class="line">            point &#x3D;  1;</span><br><span class="line">            return sum</span><br><span class="line">        elif point &#x3D;&#x3D; 0:</span><br><span class="line">            return sum* 10 + x</span><br><span class="line">        else:</span><br><span class="line">            point &#x3D; point * 10</span><br><span class="line">            return sum + x&#x2F;point            </span><br><span class="line">    return reduce(add, nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def str2float_ini(s):</span><br><span class="line">    nums &#x3D; map(lambda y: CHAR_TO_FLOAT[y], s)</span><br><span class="line">    point &#x3D; 0</span><br><span class="line">    def add(sum, x):</span><br><span class="line">        nonlocal point</span><br><span class="line">        if x &#x3D;&#x3D; -1 :</span><br><span class="line">            point &#x3D;  1;</span><br><span class="line">            return sum</span><br><span class="line">        elif point &#x3D;&#x3D; 0:</span><br><span class="line">            return sum* 10 + x</span><br><span class="line">        else:</span><br><span class="line">            point &#x3D; point * 10</span><br><span class="line">            return sum + x&#x2F;point            </span><br><span class="line">    return reduce(add, nums,999)</span><br><span class="line"></span><br><span class="line">t &#x3D; str2float_ini(&#39;2132.213&#39;)</span><br><span class="line">print(t)</span><br><span class="line">t &#x3D; str2float_ini(&#39;2132.213&#39;)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>

<p>2132.213<br>9992132.213<br>​```</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">### filter</span><br><span class="line"></span><br><span class="line">Python内建的&#96;filter()&#96;函数用于过滤序列。</span><br><span class="line"></span><br><span class="line">和&#96;map()&#96;类似，&#96;filter()&#96;也接收一个函数和一个序列。&#96;filter()&#96;把传入的函数依次作用于每个元素，然后根据返回值是&#96;True&#96;还是&#96;False&#96;决定保留还是丢弃该元素。</span><br><span class="line"></span><br><span class="line">**注意**到&#96;filter()&#96;函数返回的是一个&#96;Iterator&#96;，也就是一个惰性序列，所以要强迫&#96;filter()&#96;完成计算结果，需要用&#96;list()&#96;函数获得所有结果并返回list。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### sort</span><br><span class="line"></span><br><span class="line">Python内置的&#96;sorted()&#96;函数就可以对list进行排序：</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<blockquote>
<p>sorted([36, 5, -12, 9, -21])<br>[-21, -12, 5, 9, 36]</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此外，&#96;sorted()&#96;函数也是一个高阶函数，它还可以接收一个&#96;key&#96;函数来实现自定义的排序。key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过&#96;key&#x3D;abs&#96;处理过的list：</span><br><span class="line"></span><br><span class="line">我们再看一个字符串排序的例子：</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<blockquote>
<p>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’])<br>[‘Credit’, ‘Zoo’, ‘about’, ‘bob’]</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">默认情况下，对字符串排序，是按照ASCII的大小比较的，由于&#96;&#39;Z&#39; &lt; &#39;a&#39;&#96;，结果，大写字母&#96;Z&#96;会排在小写字母&#96;a&#96;的前面。</span><br><span class="line"></span><br><span class="line">现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。xx</span><br><span class="line"></span><br><span class="line">这样，我们给&#96;sorted&#96;传入key函数，即可实现忽略大小写的排序：</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<blockquote>
<p>sorted([‘bob’, ‘about’, ‘Zoo’, ‘Credit’], key=str.lower)<br>[‘about’, ‘bob’, ‘Credit’, ‘Zoo’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>```</p>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>这个坑以后再填 <a href="https://www.runoob.com/regexp/regexp-rule.html">https://www.runoob.com/regexp/regexp-rule.html</a></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-import%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="python基础学习笔记-import和命名空间"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:12:03.000Z" title="2020-08-07T05:12:03.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Python/">Python</a></span><span class="level-item">8 minutes read (About 1133 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-import%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/">python基础学习笔记-import和命名空间</a></h1><div class="content"><!-- mroe -->



<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>Python 模块(Module)，是<strong>一个 Python 文件</strong>，以 .py 结尾，包含了 Python 对象定义和Python语句。</p>
<p>模块让你能够有逻辑地组织你的 Python 代码段。</p>
<p>把相关的代码分配到一个模块里能让你的代码更好用，更易懂。</p>
<p>模块能定义函数，类和变量，模块里也能包含可执行的代码。</p>
<h2 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h2><h3 id="模块的引入"><a href="#模块的引入" class="headerlink" title="模块的引入"></a>模块的引入</h3><p>模块定义好后，我们可以使用 import 语句来引入模块，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import module1[, module2[,... moduleN]]</span><br></pre></td></tr></table></figure>

<p>比如要引用模块 math，就可以在文件最开始的地方用 <strong>import math</strong> 来引入。在调用 math 模块中的函数时，必须这样引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名.函数名</span><br></pre></td></tr></table></figure>

<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在<strong>脚本的顶端</strong>：</p>
<p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p>
<h2 id="from…import-语句"><a href="#from…import-语句" class="headerlink" title="from…import 语句"></a>from…import 语句</h2><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from modname import name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>

<p>例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from fib import fibonacci</span><br></pre></td></tr></table></figure>

<p>这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。</p>
<h2 id="from…import-语句-1"><a href="#from…import-语句-1" class="headerlink" title="from…import* 语句"></a>from…import* 语句</h2><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from modname import *</span><br></pre></td></tr></table></figure>

<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<p>例如我们想一次性引入 math 模块中所有的东西，语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from math import *</span><br></pre></td></tr></table></figure>

<h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是：</p>
<ul>
<li>1、当前目录</li>
<li>2、如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li>
<li>3、如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li>
</ul>
<p>模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</p>
<h2 id="PYTHONPATH-变量"><a href="#PYTHONPATH-变量" class="headerlink" title="PYTHONPATH 变量"></a>PYTHONPATH 变量</h2><p>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。</p>
<p>在 Windows 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PYTHONPATH&#x3D;c:\python27\lib;</span><br></pre></td></tr></table></figure>

<p>在 UNIX 系统，典型的 PYTHONPATH 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PYTHONPATH&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python</span><br></pre></td></tr></table></figure>

<h2 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h2><p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。</p>
<p>一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。</p>
<p>每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。</p>
<p>Python 会智能地猜测一个变量是局部的还是全局的，它<strong>假设任何在函数内赋值的变量都是局部的。</strong></p>
<p>因此，如果要给函数内<strong>的全局变量赋值，必须使用 global 语句</strong>。</p>
<p><code>global VarName</code> 的表达式会告诉 Python， `VarName 1是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。</p>
<p>例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。取消 global 语句前的注释符就能解决这个问题。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Python/Python%E5%9F%BA%E7%A1%80/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Python基础-函数速记和基础内容"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:11:04.000Z" title="2020-08-07T05:11:04.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Python/">Python</a></span><span class="level-item">36 minutes read (About 5398 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Python/Python%E5%9F%BA%E7%A1%80/">Python基础-函数速记和基础内容</a></h1><div class="content"><!-- mroe -->



<h2 id="python特点"><a href="#python特点" class="headerlink" title="python特点"></a>python特点</h2><ul>
<li>动态类型</li>
<li>简洁的语法（伪代码）</li>
<li>强大的扩展库和开源社区</li>
<li>解释性语言</li>
<li>快速开发</li>
<li>执行速度不如C，C++语言</li>
</ul>
<p>值得看的部分：变量中对不可变和可变对象的讲述以及函数传递参数中对不同类型对象传递参数的处理差别。</p>
<h4 id="什么是动态语言？"><a href="#什么是动态语言？" class="headerlink" title="什么是动态语言？"></a><strong>什么是动态语言？</strong></h4><p>要了解什么是动态语言，要首先了解“类型检查”。</p>
<p>类型检查是验证类型约束的过程，编译器或解释器通常在编译阶段或运行阶段做类型检查。</p>
<p>类型检查就是查看“变量”和它们的”类型”，然后判断表达式是否合理。例如，不能拿一个 string 类型变量除以浮点数变量。</p>
<p>如果类型检查发生在程序运行阶段（run time），那么它便是“动态类型语言”（dynamically typed languages）。常见的动态语言包括：</p>
<ul>
<li>Python</li>
<li>JavaScrpit</li>
<li>PHP</li>
</ul>
<p>类型检查发生在“编译阶段”（compile time）的是“静态类型语言”（statically typed languages）。常见的静态类型语言包括：</p>
<ul>
<li>C</li>
<li>C++</li>
<li>Java</li>
<li>C#</li>
<li>Scala</li>
</ul>
<h4 id="什么是强类型语言？"><a href="#什么是强类型语言？" class="headerlink" title="什么是强类型语言？"></a><strong>什么是强类型语言？</strong></h4><p>强类型语言是指：不管是在编译阶段还是运行阶段，一旦某种类型绑定到变量后，此变量便会持有此类型，并且不能同其他类型在计算表达式时，混合使用。</p>
<p>例如，在交互式工具 IPython 中输入如下两行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a &#x3D; 5</span><br><span class="line">In [2]: a &#x3D; a + &#39;s&#39;</span><br></pre></td></tr></table></figure>

<p>程序会抛出 TypeError 异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>

<p>意思是不支持 int 变量和 str 变量相加。</p>
<p>常见的强类型语言有：</p>
<ul>
<li>Python</li>
<li>Java</li>
<li>C#</li>
<li>Scala</li>
</ul>
<p>与之对应的是弱类型语言，弱类型语言容易与其他类型混合计算。弱类型语言代表 JavaScript。</p>
<p>支持如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; 5</span><br><span class="line">data &#x3D; data + &#39;xiaoming&#39; &#x2F;&#x2F;string 和 int 结合自动转化为 string</span><br></pre></td></tr></table></figure>

<p>常见的弱类型语言有：</p>
<ul>
<li>C</li>
<li>C++</li>
<li>PHP</li>
<li>Javascript</li>
</ul>
<p>如下，按照是否为静态/动态语言，弱类型/强类型两个维度，总结常用的语言分类。</p>
<p><a href="http://static.come2rss.xyz/2020-02-05-080211.png"><img src="http://static.come2rss.xyz/2020-02-05-080211.png" alt="image-20200205155429583"></a></p>
<p><a href="http://static.come2rss.xyz/2020-02-05-080211.png">image-20200205155429583</a></p>
<h2 id="函数手册"><a href="#函数手册" class="headerlink" title="函数手册"></a>函数手册</h2><p><code>range(start, stop, step)</code>从start到stop-1每step个元素的元素迭代器。</p>
<p><code>read(),readlines(),readline()</code>文件对象提供了三个“读”方法：</p>
<p><code>.read()</code>每次读取整个文件，它通常用于将文件内容放到一个字符串变量中，但是需要考虑文件的大小。<code>.readline()</code>和 <code>.readlines()</code>非常相似。它们都在类似于以下的结构中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fh &#x3D; open( &#39;c:\\autoexec.bat&#39;)</span><br><span class="line">for line in fh.readlines():</span><br><span class="line">    print   line.readline(</span><br></pre></td></tr></table></figure>



<p><code>.readlines()</code>之间的差异是后者一次读取整个文件，像<code>.read()</code>一样。<code>.readlines()</code>自动将文件内容分析成一个行的列表，该列表可以由 Python 的 <code>for... in ...</code>结构进行处理。另一方面，<code>.readline()</code>每次只读取一行，通常比 <code>.readlines()</code>慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用<code>.readline()</code>。</p>
<p><code>writeline()</code>是输出后换行，下次写会在下一行写。<code>.write()</code>是输出后光标在行末不会换行，下次写会接着这行写</p>
<p><code>zip(L1, L2, L3,[...Ln])</code> 可以把N个输入的相同位置捆绑起来合成一个list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; [1, 2, 3]</span><br><span class="line">y &#x3D; [4, 5, 6]</span><br><span class="line">z &#x3D; [7, 8, 9]</span><br><span class="line">xyz &#x3D; zip(x, y, z) # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]</span><br><span class="line">nstr &#x3D; str.join(*ostr)</span><br></pre></td></tr></table></figure>

<p>所有的ostr和str合并成一个新的字符串</p>
<p><code>repr（）</code>将任何对象转换为一对python友好的字符串</p>
<p><code>str()</code>将任何对象转换为一对python友好的字符串</p>
<p><code>is(A,B)</code>判断对象相等</p>
<h2 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h2><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>生成list的三种方法：</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#以下三种方式等效</span><br><span class="line">L &#x3D; list（range(1,11)） ## 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">for x in range(1, 11):</span><br><span class="line">	L.append(x * x)</span><br><span class="line">L &#x3D; [x * x for x in range(1, 11)]</span><br></pre></td></tr></table></figure>

<p>列表生成式扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#加上if判断</span><br><span class="line"> [x * x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]</span><br><span class="line"> [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</span><br></pre></td></tr></table></figure>

<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [d for d in os.listdir(&#39;.&#39;)] # os.listdir可以列出文件和目录</span><br></pre></td></tr></table></figure>

<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a><strong>深浅拷贝</strong></h2><p>lst2 位于全局帧栈中，其中三个元素内存中的可视化图如下所示：</p>
<p><a href="http://static.come2rss.xyz/2020-02-06-013522.png"><img src="http://static.come2rss.xyz/2020-02-06-013522.png" alt="1574820784839"></a></p>
<p><a href="http://static.come2rss.xyz/2020-02-06-013522.png">1574820784839</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sku_deep &#x3D; lst2[2].copy()</span><br></pre></td></tr></table></figure>

<p>注意，<strong>copy 函数，仅仅实现对内嵌对象的一层拷贝，属于 shallow copy。</strong></p>
<p>此时可视化图为如下，因为拷贝 lst2[2]，所以 sku_deep 位于栈帧中指向一块新的内存空间：</p>
<p><a href="http://static.come2rss.xyz/2020-02-06-13523.png"><img src="http://static.come2rss.xyz/2020-02-06-13523.png" alt="1574820818329"></a></p>
<p><a href="http://static.come2rss.xyz/2020-02-06-13523.png">1574820818329</a></p>
<p><strong>深拷贝，英文叫 deepcopy，</strong>又有什么不同？</p>
<p>请看下面例子，a 是内嵌一层 list 的列表，对其浅拷贝生成列表 ac，修改 ac 的第三个元素，也就是列表 [3,4,5] 中的第二个元素为 40：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [1,2,[3,4,5]]</span><br><span class="line">ac &#x3D; a.copy()</span><br><span class="line">ac[0] &#x3D; 10</span><br><span class="line">ac[2][1] &#x3D; 40</span><br></pre></td></tr></table></figure>

<p>修改后，分别测试两个值的<strong>相等性</strong>。</p>
<blockquote>
<p>两个对象内存地址相同即相同</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a[0] &#x3D;&#x3D; ac[0])</span><br></pre></td></tr></table></figure>

<p>返回 False，证明实现拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a[2][1] &#x3D;&#x3D; ac[2][1])</span><br></pre></td></tr></table></figure>

<p>返回 True，进一步证明是浅拷贝，不是深拷贝。</p>
<p>如下图所示：copy 只完成了一层 copy，即 [1,2, id([3,4,5])] 复制一份，而复制后，仍然指向 [3,4,5] 所在的内存空间：</p>
<p><a href="http://static.come2rss.xyz/87ba9090-6145-11ea-be13-9d4b32a4c9f6"><img src="http://static.come2rss.xyz/87ba9090-6145-11ea-be13-9d4b32a4c9f6" alt="img"></a></p>
<p><a href="http://static.come2rss.xyz/87ba9090-6145-11ea-be13-9d4b32a4c9f6">img</a></p>
<p>要想实现深度拷贝，需要使用 <strong>copy 模块的 deepcopy 函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from copy import deepcopy</span><br><span class="line"></span><br><span class="line">a &#x3D; [1,2,[3,4,5]]</span><br><span class="line">ac &#x3D; deepcopy(a)</span><br><span class="line">ac[0] &#x3D; 10</span><br><span class="line">ac[2][1] &#x3D; 40</span><br><span class="line">print(a[0] &#x3D;&#x3D; ac[0])</span><br><span class="line">print(a[2][1] &#x3D;&#x3D; ac[2][1])</span><br></pre></td></tr></table></figure>

<p>打印结果，都为 False，结合下图，也能看出内嵌的 list 全部完成复制，都指向了不同的内存区域。</p>
<p><a href="http://static.come2rss.xyz/9e25b350-6145-11ea-b4a5-257b69c74d67"><img src="http://static.come2rss.xyz/9e25b350-6145-11ea-b4a5-257b69c74d67" alt="img"></a></p>
<p><a href="http://static.come2rss.xyz/9e25b350-6145-11ea-b4a5-257b69c74d67">img</a></p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="标志符"><a href="#标志符" class="headerlink" title="标志符"></a>标志符</h2><p>在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</p>
<p>Python 中的标识符是区分大小写的。</p>
<p>以<strong>下划线开头</strong>的标识符是有特殊意义的。以单下划线开头 <code>_foo</code> 的代表<strong>不能直接访问的类属性</strong>，需通过类提供的接口进行访问，不能用 <code>from xxx import *</code> 而导入。</p>
<p>以双下划线开头的 <code>__foo</code> 代表类的<strong>私有成员</strong>，以双下划线开头和结尾的 <code>__foo__</code> 代表 Python 里<strong>特殊方法</strong>专用的标识，如 <code>__init__()</code> 代表类的构造函数。</p>
<p>Python 可以同一行显示多条语句，方法是用分号 ; 分开。</p>
<h2 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h2><p>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。</p>
<p>缩进的空白数量是可变的，但是<strong>所有代码块语句必须包含相同的缩进空白数量</strong>，这个必须严格执行。</p>
<p>建议你在每个缩进层次使用 <strong>单个制表符</strong> 或 <strong>两个空格</strong> 或 <strong>四个空格</strong> , 切记不能混用</p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python语句中一般以新行作为语句的结束符。</p>
<p>但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total &#x3D; item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>

<p>语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">days &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;,</span><br><span class="line">        &#39;Thursday&#39;, &#39;Friday&#39;]</span><br></pre></td></tr></table></figure>

<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>Python 可以使用引号( <strong>‘</strong> )、双引号( <strong>“</strong> )、三引号( <strong>‘’’</strong> 或 <strong>“””</strong> ) 来表示字符串，引号的开始与结束必须的相同类型的。</p>
<p>其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>python中单行注释采用 # 开头。</p>
<p>python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。</p>
<h2 id="if-else简洁表达"><a href="#if-else简洁表达" class="headerlink" title="if-else简洁表达"></a>if-else简洁表达</h2><p>求列表的最后一个元素，同样列表为空时，返回 None。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [20]: def tail(lst):</span><br><span class="line">    ...:     return lst[-1] if len(lst) &gt; 0 else None</span><br></pre></td></tr></table></figure>

<h2 id="Python空行"><a href="#Python空行" class="headerlink" title="Python空行"></a>Python空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：空行也是程序代码的一部分。</strong></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="不需要的输出值"><a href="#不需要的输出值" class="headerlink" title="不需要的输出值"></a>不需要的输出值</h2><p>在此记录一下：<code>parameters_values, _ = dictionary_to_vector(parameters)</code> 中的<code>_</code>表示函数中的多个输出的该个位置的数据不需要了。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>以下假设变量： <strong>a=10，b=20</strong>：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加 - 两个对象相加</td>
<td>a + b 输出结果 30</td>
</tr>
<tr>
<td>-</td>
<td>减 - 得到负数或是一个数减去另一个数</td>
<td>a - b 输出结果 -10</td>
</tr>
<tr>
<td>*</td>
<td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td>a * b 输出结果 200</td>
</tr>
<tr>
<td>/</td>
<td>除 - x除以y</td>
<td>b / a 输出结果 2</td>
</tr>
<tr>
<td>%</td>
<td>取模 - 返回除法的余数</td>
<td>b % a 输出结果 0</td>
</tr>
<tr>
<td>**</td>
<td>幂 - 返回x的y次幂</td>
<td>a**b 为10的20次方， 输出结果 100000000000000000000</td>
</tr>
<tr>
<td>//</td>
<td><strong>取整除</strong> - 返回商的整数部分（<strong>向下取整</strong>）</td>
<td><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td>
</tr>
</tbody></table>
<h2 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>等于 - 比较对象是否相等</td>
<td>(a == b) 返回 False。</td>
</tr>
<tr>
<td>!=</td>
<td>不等于 - 比较两个对象是否不相等</td>
<td>(a != b) 返回 true.</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于 - 比较两个对象是否不相等。python3 <strong>已废弃。</strong></td>
<td>(a &lt;&gt; b) 返回 true。这个运算符类似 != 。</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 - 返回x是否大于y</td>
<td>(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。</td>
<td>(a &lt; b) 返回 true。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 - 返回x是否大于等于y。</td>
<td>(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 - 返回x是否小于等于y。</td>
<td>(a &lt;= b) 返回 true。</td>
</tr>
</tbody></table>
<h2 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单的赋值运算符</td>
<td>c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c *= a 等效于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c <strong>= a 等效于 c = c</strong> a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
</tbody></table>
<h2 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1</td>
<td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。</td>
<td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数</td>
<td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody></table>
<h2 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>逻辑表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>x and y</td>
<td>布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td>(a and b) 返回 20。</td>
</tr>
<tr>
<td>or</td>
<td>x or y</td>
<td>布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td>
<td>(a or b) 返回 10。</td>
</tr>
<tr>
<td>not</td>
<td>not x</td>
<td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td>not(a and b) 返回 False</td>
</tr>
</tbody></table>
<h2 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h2><p>Python还支持成员运算符，</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<h2 id="Python身份运算符（很有意思）"><a href="#Python身份运算符（很有意思）" class="headerlink" title="Python身份运算符（很有意思）"></a>Python身份运算符（很有意思）</h2><p>身份运算符用于比较两个对象的<strong>存储单元</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>is</td>
<td>is 是判断两个标识符是不是<strong>引用自一个对象</strong></td>
<td><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
<td><strong>x is not y</strong> ， 类似 **id(a) != id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody></table>
<p><strong>注：</strong> <strong><a href="https://www.runoob.com/python/python-func-id.html">id()</a> 函数</strong>用于获取<strong>对象内存地址</strong>。</p>
<blockquote>
<p>is 与 == 区别：</p>
<p>is 用于判断两个变量引用对象是否为**同一个(同一块内存空间)**， == 用于判断引用变量的值是否相等。</p>
<p>值得注意的是<code>b = a[:] #截取一个新的list</code>属于创建了一个新的内存空间的情况.</p>
</blockquote>
<h2 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>**</td>
<td>指数 (最高优先级)</td>
</tr>
<tr>
<td>~ + -</td>
<td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td>* / % //</td>
<td>乘，除，取模和取整除</td>
</tr>
<tr>
<td>+ -</td>
<td>加法减法</td>
</tr>
<tr>
<td>&gt;&gt; &lt;&lt;</td>
<td>右移，左移运算符</td>
</tr>
<tr>
<td>&amp;</td>
<td>位 ‘AND’</td>
</tr>
<tr>
<td>^ |</td>
<td>位运算符</td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td>比较运算符</td>
</tr>
<tr>
<td>&lt;&gt; == !=</td>
<td>等于运算符</td>
</tr>
<tr>
<td>= %= /= //= -= += *= **=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>is is not</td>
<td>身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td>成员运算符</td>
</tr>
<tr>
<td>not and or</td>
<td>逻辑运算符</td>
</tr>
</tbody></table>
<h2 id="Python-pass-语句"><a href="#Python-pass-语句" class="headerlink" title="Python pass 语句"></a>Python pass 语句</h2><p>Python pass 是空语句，是为了保持程序结构的完整性。</p>
<p><strong>pass</strong> 不做任何事情，一般用做占位语句。因为如果定义<strong>一个空函数程序</strong>会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号**()**。</li>
<li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li>
</ul>
<p><strong>参数传递(写的太好了)</strong></p>
<p>在 python 中，<strong>类型属于对象，变量是没有类型的：</strong></p>
<p>a=[1,2,3] a=”Runoob”</p>
<p>以上代码中，**[1,2,3]** 是 List 类型，<strong>“Runoob”</strong> 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象<strong>的引用</strong>（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</p>
<h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def is_rotation(s1: str, s2: str) -&gt; bool:#将参数和返回值的类型注明，增强了可读性和可维护性</span><br><span class="line">    if s1 is None or s2 is None:</span><br><span class="line">        return False</span><br><span class="line">    if len(s1) !&#x3D; len(s2):</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def is_substring(s1: str, s2: str) -&gt; bool:</span><br><span class="line">        return s1 in s2</span><br><span class="line">    return is_substring(s1, s2 + s2)</span><br></pre></td></tr></table></figure>

<h2 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h2><p>在 python 中，<code>strings</code>,<code>tuples</code>,和 <code>numbers</code> 是不可更改的对象，而 <code>list</code>,<code>dic</code>等则是可以修改的对象。</p>
<ul>
<li><strong>不可变类型：</strong>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是<strong>新生成一个 int 值对</strong>象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li>
<li><strong>可变类型：</strong>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p><strong>python 函数的参数传递：</strong></p>
<ul>
<li><strong>不可变类型：</strong> <strong>类似 c++ 的值传递</strong>，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li><strong>可变类型：</strong> <strong>类似 c++ 的引用传递</strong>，如 列表，字典。如 fun（la），则是将 <strong>la 真正的传过去，修改后fun外部的la也会受影响</strong></li>
</ul>
<p>python 中<strong>一切都是对象</strong>，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<p><strong>Python传不可变对象的实例</strong></p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def ChangeInt( a ):</span><br><span class="line">	 a &#x3D; 10</span><br><span class="line">b &#x3D; 2</span><br><span class="line">ChangeInt(b)</span><br><span class="line">print b # 结果是 2</span><br></pre></td></tr></table></figure>

<p><strong>Python传可变对象的实例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def changeme( mylist ):</span><br><span class="line">	mylist.append([1,2,3,4])</span><br><span class="line">    print &quot;函数内取值: &quot;, mylist</span><br><span class="line">mylist &#x3D; [10,20,30]</span><br><span class="line">changeme( mylist )</span><br><span class="line">print &quot;函数外取值: &quot;, mylist</span><br></pre></td></tr></table></figure>

<p>实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br><span class="line">函数外取值:  [10, 20, 30, [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>以下是调用函数时可使用的正式参数类型：</p>
<ul>
<li>必备参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<h3 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h3><p>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def printme( str ):</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( name, age ):</span><br><span class="line">	pass</span><br><span class="line">printinfo( age&#x3D;50, name&#x3D;&quot;miki&quot; )</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def printinfo( name, age &#x3D; 35 ):</span><br></pre></td></tr></table></figure>

<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def functionname([formal_args,] *var_args_tuple ):</span><br><span class="line">	for var in vartuple:</span><br><span class="line">	      print var</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>python 使用 lambda 来创建匿名函数。</p>
<ul>
<li>lambda只是一个表达式，函数体比def简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>lambda函数的语法只包含一个语句，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lambda [arg1 [,arg2,.....argn]]:expression</span><br><span class="line">#比如</span><br><span class="line">sum &#x3D; lambda arg1, arg2: arg1 + arg2</span><br><span class="line">print &quot;相加后的值为 : &quot;, sum( 10, 20 )</span><br></pre></td></tr></table></figure>

<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。</p>
<p>变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</p>
<ul>
<li>全局变量</li>
<li>局部变量</li>
</ul>
<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，<strong>所有在函数内声明的变量名称都将被加入到作用域</strong>中。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Python/PIL%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="PIL笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:10:04.000Z" title="2020-08-07T05:10:04.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Python/">Python</a></span><span class="level-item">15 minutes read (About 2230 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Python/PIL%E7%AC%94%E8%AE%B0/">PIL笔记</a></h1><div class="content"><p>Python Image Library别名Pillow</p>
<p>教程参见：<a href="https://pillow-cn.readthedocs.io/zh_CN/latest/handbook/tutorial.html">翻译版</a></p>
<!-- mroe -->

<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="Image-类"><a href="#Image-类" class="headerlink" title="Image 类"></a>Image 类</h2><p>PIL最重要的类是 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image"><code>Image</code></a> class, 你可以通过多种方法创建这个类的实例；你可以从文件加载图像，或者处理其他图像, 或者从 scratch 创建。</p>
<p>要从文件加载图像，使用 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.open"><code>open()</code></a> 函数， 在 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#module-PIL.Image"><code>Image</code></a> 模块:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; im &#x3D; Image.open(&quot;lena.ppm&quot;)</span><br></pre></td></tr></table></figure>

<p>加载成功将返回一个 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image"><code>Image</code></a> 对象。 你现在可以使用示例属性检查文件内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from __future__ import print_function</span><br><span class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</span><br><span class="line">PPM (512, 512) RGB</span><br></pre></td></tr></table></figure>

<p><code>format</code> 这个属性标识了图像来源。如果图像不是从文件读取它的值就是None。size属性是一个二元tuple，包含width和height（宽度和高度，单位都是px）。 <code>mode</code> 属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes 有 “L” (luminance) 表示灰度图像, “RGB” 表示真彩色图像, and “CMYK” 表示出版图像。</p>
<p>如果文件打开错误，返回 <code>IOError</code> 错误。</p>
<p>只要你有了 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image"><code>Image</code></a> 类的实例，你就可以通过类的方法处理图像。比如，下列方法可以显示图像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; im.show()</span><br></pre></td></tr></table></figure>

<h2 id="读写图像"><a href="#读写图像" class="headerlink" title="读写图像"></a>读写图像</h2><p>PIL 模块支持大量图片格式。使用在 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#module-PIL.Image"><code>Image</code></a> 模块的 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.open"><code>open()</code></a> 函数从磁盘读取文件。你不需要知道文件格式就能打开它，这个库能够根据文件内容自动确定文件格式。</p>
<p>要保存文件，使用 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image"><code>Image</code></a> 类的 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.save"><code>save()</code></a> 方法。保存文件的时候文件名变得重要了。除非你指定格式，否则这个库将会以文件名的扩展名作为格式保存。</p>
<h3 id="转换文件格式到JPEG"><a href="#转换文件格式到JPEG" class="headerlink" title="转换文件格式到JPEG"></a>转换文件格式到JPEG</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import os, sys</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">for infile in sys.argv[1:]:</span><br><span class="line">    f, e &#x3D; os.path.splitext(infile)</span><br><span class="line">    outfile &#x3D; f + &quot;.jpg&quot;</span><br><span class="line">    if infile !&#x3D; outfile:</span><br><span class="line">        try:</span><br><span class="line">            Image.open(infile).save(outfile)</span><br><span class="line">        except IOError:</span><br><span class="line">            print(&quot;cannot convert&quot;, infile)</span><br></pre></td></tr></table></figure>

<p><a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.save"><code>save()</code></a> 方法的第二个参数可以指定文件格式，如果你使用非标准的扩展名你必须这样做：</p>
<h3 id="创建-JPEG-缩略图"><a href="#创建-JPEG-缩略图" class="headerlink" title="创建 JPEG 缩略图"></a>创建 JPEG 缩略图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import os, sys</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">size &#x3D; (128, 128)</span><br><span class="line"></span><br><span class="line">for infile in sys.argv[1:]:</span><br><span class="line">    outfile &#x3D; os.path.splitext(infile)[0] + &quot;.thumbnail&quot;</span><br><span class="line">    if infile !&#x3D; outfile:</span><br><span class="line">        try:</span><br><span class="line">            im &#x3D; Image.open(infile)</span><br><span class="line">            im.thumbnail(size)</span><br><span class="line">            im.save(outfile, &quot;JPEG&quot;)</span><br><span class="line">        except IOError:</span><br><span class="line">            print(&quot;cannot create thumbnail for&quot;, infile)</span><br></pre></td></tr></table></figure>

<p>很重要的一点是这个库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图片大小和压缩方式无关。下面是一个简单的脚本用来快速验证大量图片。</p>
<h3 id="验证图像文件"><a href="#验证图像文件" class="headerlink" title="验证图像文件"></a>验证图像文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import sys</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">for infile in sys.argv[1:]:</span><br><span class="line">    try:</span><br><span class="line">        with Image.open(infile) as im:</span><br><span class="line">            print(infile, im.format, &quot;%dx%d&quot; % im.size, im.mode)</span><br><span class="line">    except IOError:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>

<h2 id="剪切，粘贴，合并图像"><a href="#剪切，粘贴，合并图像" class="headerlink" title="剪切，粘贴，合并图像"></a>剪切，粘贴，合并图像</h2><p><a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image"><code>Image</code></a> 类包含的方法允许你操作图像部分选区。使用:py:meth:~PIL.Image.Image.crop 方法获取图像的一个子矩形选区。</p>
<h3 id="从图像中复制出一个矩形选区"><a href="#从图像中复制出一个矩形选区" class="headerlink" title="从图像中复制出一个矩形选区"></a>从图像中复制出一个矩形选区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box &#x3D; (100, 100, 400, 400)</span><br><span class="line">region &#x3D; im.crop(box)</span><br></pre></td></tr></table></figure>

<p>矩形选区有一个4元元组定义，分别表示左、上、右、下的坐标。这个库以左上角为坐标原点，单位是px，所以上诉代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。</p>
<h3 id="处理复制的矩形选区并粘贴到原图"><a href="#处理复制的矩形选区并粘贴到原图" class="headerlink" title="处理复制的矩形选区并粘贴到原图"></a>处理复制的矩形选区并粘贴到原图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">region &#x3D; region.transpose(Image.ROTATE_180)</span><br><span class="line">im.paste(region, box)</span><br></pre></td></tr></table></figure>

<p>当你粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而你不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色（参看下面的 <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/handbook/tutorial.html#color-transforms"><em>颜色变换</em></a> 部分），下面是一个例子：</p>
<h3 id="Rolling-an-image"><a href="#Rolling-an-image" class="headerlink" title="Rolling an image"></a>Rolling an image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def roll(image, delta):</span><br><span class="line">    &quot;Roll an image sideways&quot;</span><br><span class="line"></span><br><span class="line">    xsize, ysize &#x3D; image.size</span><br><span class="line"></span><br><span class="line">    delta &#x3D; delta % xsize</span><br><span class="line">    if delta &#x3D;&#x3D; 0: return image</span><br><span class="line"></span><br><span class="line">    part1 &#x3D; image.crop((0, 0, delta, ysize))</span><br><span class="line">    part2 &#x3D; image.crop((delta, 0, xsize, ysize))</span><br><span class="line">    image.paste(part2, (0, 0, xsize-delta, ysize))</span><br><span class="line">    image.paste(part1, (xsize-delta, 0, xsize, ysize))</span><br><span class="line"></span><br><span class="line">    return image</span><br></pre></td></tr></table></figure>

<p>For more advanced tricks, the paste method can also take a transparency mask as an optional argument. In this mask, the value 255 indicates that the pasted image is opaque in that position (that is, the pasted image should be used as is). The value 0 means that the pasted image is completely transparent. Values in-between indicate different levels of transparency.</p>
<p>The Python Imaging Library also allows you to work with the individual bands of an multi-band image, such as an RGB image. The split method creates a set of new images, each containing one band from the original multi-band image. The merge function takes a mode and a tuple of images, and combines them into a new image. The following sample swaps the three bands of an RGB image:</p>
<h3 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r, g, b &#x3D; im.split()</span><br><span class="line">im &#x3D; Image.merge(&quot;RGB&quot;, (b, g, r))</span><br></pre></td></tr></table></figure>

<p>Note that for a single-band image, <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.split"><code>split()</code></a> returns the image itself. To work with individual color bands, you may want to convert the image to “RGB” first.</p>
<h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p>The <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image"><code>PIL.Image.Image</code></a> class contains methods to <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.resize"><code>resize()</code></a> and <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.rotate"><code>rotate()</code></a> an image. The former takes a tuple giving the new size, the latter the angle in degrees counter-clockwise.</p>
<h3 id="简单的几何变换"><a href="#简单的几何变换" class="headerlink" title="简单的几何变换"></a>简单的几何变换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out &#x3D; im.resize((128, 128))</span><br><span class="line">out &#x3D; im.rotate(45) # degrees counter-clockwise</span><br></pre></td></tr></table></figure>

<p>To rotate the image in 90 degree steps, you can either use the <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.rotate"><code>rotate()</code></a> method or the <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.transpose"><code>transpose()</code></a> method. The latter can also be used to flip an image around its horizontal or vertical axis.</p>
<h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">out &#x3D; im.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line">out &#x3D; im.transpose(Image.FLIP_TOP_BOTTOM)</span><br><span class="line">out &#x3D; im.transpose(Image.ROTATE_90)</span><br><span class="line">out &#x3D; im.transpose(Image.ROTATE_180)</span><br><span class="line">out &#x3D; im.transpose(Image.ROTATE_270)</span><br></pre></td></tr></table></figure>

<p>There’s no difference in performance or result between <code>transpose(ROTATE)</code> and corresponding <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.rotate"><code>rotate()</code></a> operations.</p>
<p>A more general form of image transformations can be carried out via the <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.transform"><code>transform()</code></a> method.</p>
<h2 id="颜色变换"><a href="#颜色变换" class="headerlink" title="颜色变换"></a>颜色变换</h2><p>The Python Imaging Library allows you to convert images between different pixel representations using the <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.convert"><code>convert()</code></a> method.</p>
<h3 id="颜色模式转换"><a href="#颜色模式转换" class="headerlink" title="颜色模式转换"></a>颜色模式转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im &#x3D; Image.open(&quot;lena.ppm&quot;).convert(&quot;L&quot;)</span><br></pre></td></tr></table></figure>

<p>The library supports transformations between each supported mode and the “L” and “RGB” modes. To convert between other modes, you may have to use an intermediate image (typically an “RGB” image).</p>
<h2 id="颜色增强"><a href="#颜色增强" class="headerlink" title="颜色增强"></a>颜色增强</h2><p>The Python Imaging Library provides a number of methods and modules that can be used to enhance images.</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>The <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/ImageFilter.html#module-PIL.ImageFilter"><code>ImageFilter</code></a> module contains a number of pre-defined enhancement filters that can be used with the <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.filter"><code>filter()</code></a> method.</p>
<h4 id="应用过滤器"><a href="#应用过滤器" class="headerlink" title="应用过滤器"></a>应用过滤器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from PIL import ImageFilter</span><br><span class="line">out &#x3D; im.filter(ImageFilter.DETAIL)</span><br></pre></td></tr></table></figure>

<h3 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h3><p>The <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.point"><code>point()</code></a> method can be used to translate the pixel values of an image (e.g. image contrast manipulation). In most cases, a function object expecting one argument can be passed to the this method. Each pixel is processed according to that function:</p>
<h4 id="应用点操作"><a href="#应用点操作" class="headerlink" title="应用点操作"></a>应用点操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># multiply each pixel by 1.2</span><br><span class="line">out &#x3D; im.point(lambda i: i * 1.2)</span><br></pre></td></tr></table></figure>

<p>Using the above technique, you can quickly apply any simple expression to an image. You can also combine the <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.point"><code>point()</code></a> and <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/Image.html#PIL.Image.Image.paste"><code>paste()</code></a> methods to selectively modify an image:</p>
<h4 id="处理个别bands"><a href="#处理个别bands" class="headerlink" title="处理个别bands"></a>处理个别bands</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># split the image into individual bands</span><br><span class="line">source &#x3D; im.split()</span><br><span class="line"></span><br><span class="line">R, G, B &#x3D; 0, 1, 2</span><br><span class="line"></span><br><span class="line"># select regions where red is less than 100</span><br><span class="line">mask &#x3D; source[R].point(lambda i: i &lt; 100 and 255)</span><br><span class="line"></span><br><span class="line"># process the green band</span><br><span class="line">out &#x3D; source[G].point(lambda i: i * 0.7)</span><br><span class="line"></span><br><span class="line"># paste the processed band back, but only where red was &lt; 100</span><br><span class="line">source[G].paste(out, None, mask)</span><br><span class="line"></span><br><span class="line"># build a new multiband image</span><br><span class="line">im &#x3D; Image.merge(im.mode, source)</span><br></pre></td></tr></table></figure>

<p>Note the syntax used to create the mask:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imout &#x3D; im.point(lambda i: expression and 255)</span><br></pre></td></tr></table></figure>

<p>Python only evaluates the portion of a logical expression as is necessary to determine the outcome, and returns the last value examined as the result of the expression. So if the expression above is false (0), Python does not look at the second operand, and thus returns 0. Otherwise, it returns 255.</p>
<h3 id="增强"><a href="#增强" class="headerlink" title="增强"></a>增强</h3><p>For more advanced image enhancement, you can use the classes in the <a href="https://pillow-cn.readthedocs.io/zh_CN/latest/reference/ImageEnhance.html#module-PIL.ImageEnhance"><code>ImageEnhance</code></a> module. Once created from an image, an enhancement object can be used to quickly try out different settings.</p>
<p>You can adjust contrast, brightness, color balance and sharpness in this way.</p>
<h4 id="增强图形"><a href="#增强图形" class="headerlink" title="增强图形"></a>增强图形</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import ImageEnhance</span><br><span class="line"></span><br><span class="line">enh &#x3D; ImageEnhance.Contrast(im)</span><br><span class="line">enh.enhance(1.3).show(&quot;30% more contrast&quot;)</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Language/Python/pandas%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="pandas笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:09:27.000Z" title="2020-08-07T05:09:27.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Python/">Python</a></span><span class="level-item">3 minutes read (About 509 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Language/Python/pandas%E7%AC%94%E8%AE%B0/">pandas笔记</a></h1><div class="content"><!-- mroe -->



<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandas.read_excel(io, sheet_name, dtype)</span><br></pre></td></tr></table></figure>

<p>神奇的函数：<code>io</code>可使用多种URL，如http、ftp、file、path。</p>
<p>sheet_name 指定读取的工作簿</p>
<p>dtype：以dict的形式指定多列的数据类型</p>
<h2 id="DataFrame以及Df对象"><a href="#DataFrame以及Df对象" class="headerlink" title="DataFrame以及Df对象"></a>DataFrame以及Df对象</h2><p>记一个DataFrame对象为df， 当然一个Narray对象为Na。</p>
<p><code>pd.DataFrame()</code> 创建一个Df对象</p>
<p>如下例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df &#x3D; pd.DataFrame([(&#39;bird&#39;, 389.0),</span><br><span class="line">...                    (&#39;bird&#39;, 24.0),</span><br><span class="line">...                    (&#39;mammal&#39;, 80.5),</span><br><span class="line">...                    (&#39;mammal&#39;, np.nan)],</span><br><span class="line">...                   index&#x3D;[&#39;falcon&#39;, &#39;parrot&#39;, &#39;lion&#39;, &#39;monkey&#39;],</span><br><span class="line">...                   columns&#x3D;(&#39;class&#39;, &#39;max_speed&#39;))</span><br></pre></td></tr></table></figure>

<p><code>df.values</code> 为一个Narray对象（实现从Df转化Na）</p>
<blockquote>
<p>同样也有pd。DataFrame(na), 即从Narray转化为Df。</p>
</blockquote>
<p><code>df.dropna(inplace=True, how=&#39;any&#39;， axis=0)</code> 删除一行中带有Nan的 一行数据（how=‘any’， axis=0）。其中axis可为1，即从列中寻找，how=‘all’，即一个数据集中必须都为Nan。</p>
<p><code>inplace</code>参数经常出现，若为<code>True</code>表示直接对源对象修改，不返回一个新对象。<code>False</code>表示生成一个新对象，并只对新对象进行修改。</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; df&#x3D;pd.DataFrame(np.random.randn(4,3),columns&#x3D;[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])</span><br><span class="line">&gt;&gt;&gt; df.loc[1, &#39;A&#39;] &#x3D; np.nan</span><br><span class="line">&gt;&gt;&gt; df</span><br><span class="line">          A         B         C</span><br><span class="line">0  1.184976  0.757937 -1.403958</span><br><span class="line">1       NaN -0.459589  0.774141</span><br><span class="line">2 -1.522429  0.789742 -0.486841</span><br><span class="line">3 -0.188630  0.511300  1.807077</span><br><span class="line">&gt;&gt;&gt; x &#x3D; df.dropna(axis&#x3D;0, inplace&#x3D;True, how&#x3D;&#39;any&#39;)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&gt;&gt;&gt; df</span><br><span class="line">          A         B         C</span><br><span class="line">0  1.184976  0.757937 -1.403958</span><br><span class="line">2 -1.522429  0.789742 -0.486841</span><br><span class="line">3 -0.188630  0.511300  1.807077</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; df&#x3D;pd.DataFrame(np.random.randn(4,3),columns&#x3D;[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;])</span><br><span class="line">&gt;&gt;&gt; df.loc[1, &#39;A&#39;] &#x3D; np.nan</span><br><span class="line">&gt;&gt;&gt; x &#x3D; df.dropna(axis&#x3D;0, inplace&#x3D;False, how&#x3D;&#39;any&#39;)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">          A         B         C</span><br><span class="line">0  0.999307 -1.473423 -0.255439</span><br><span class="line">2  2.322430  0.228044 -1.383975</span><br><span class="line">3 -0.734672  0.643534  1.203060</span><br><span class="line">&gt;&gt;&gt; df</span><br><span class="line">          A         B         C</span><br><span class="line">0  0.999307 -1.473423 -0.255439</span><br><span class="line">1       NaN  0.438706  0.278976</span><br><span class="line">2  2.322430  0.228044 -1.383975</span><br><span class="line">3 -0.734672  0.643534  1.203060</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><code>df.drop</code>类似与<code>df.dropna()</code>都是删除之用。</p>
<p><code>df.reset_index(drop=True, inplace=True)</code> 用来重新生成index（行的索引）。<code>drop=True</code>表示重新生成index，否则则保留原来的index。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><code>df.loc[:, [col1, col2] ]</code>（尤其是修改df原本数据时）可以有效选择数据。</p>
<p><code>df.index</code> 返回df的<strong>index ranger</strong></p>
<p><code>df.values</code>返回一个Narray。</p>
<p><code>df.columns</code>返回df的columns的list。</p>
<h3 id="添加一行"><a href="#添加一行" class="headerlink" title="添加一行"></a>添加一行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &#x3D; pd.DataFrame(columns&#x3D;[&#39;A&#39;, &#39;B&#39;], data &#x3D; [[1,2],[3,4]]) </span><br><span class="line">df.loc[&#39;B&#39;] &#x3D; dict</span><br></pre></td></tr></table></figure>

<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p><code>ExcelWriter(path, )</code> 返回一个ExcelWriter，配合就<strong>多个</strong><code>df.to_excle(Ewriter,sheet_name)</code>写入DataFrame的数据，并用<code>EecelWriter.save()</code>来写入文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; writer &#x3D; pd.ExcelWriter(&#39;output.xlsx&#39;)</span><br><span class="line">&gt;&gt;&gt; df1.to_excel(writer,&#39;Sheet1&#39;)</span><br><span class="line">&gt;&gt;&gt; df2.to_excel(writer,&#39;Sheet2&#39;)</span><br><span class="line">&gt;&gt;&gt; writer.save()</span><br></pre></td></tr></table></figure>

</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">Previous</a></div><div class="pagination-next"><a href="/page/5/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="http://static.come2rss.xyz/%E9%93%81%E7%94%B2%E5%9F%8Elogo.png" alt="Ove"></figure><p class="title is-size-4 is-block line-height-inherit">Ove</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>宁波</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">90</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知乎" href="https://www.zhihu.com/people/ddd-37-43"><i class="http://static.come2rss.xyz/zhihu.png"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/15-3sum/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="15 3sum"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:15:37.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/15-3sum/">15 3sum</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="1190. Reverse Substrings Between Each Pair of Parentheses"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:14:44.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses/">1190. Reverse Substrings Between Each Pair of Parentheses</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-DP-%E8%B4%AA%E5%BF%83/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="面试题 DP 贪心"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:14:08.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-DP-%E8%B4%AA%E5%BF%83/">面试题 DP 贪心</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/">剑指offer</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="786. 第 K 个最小的素数分数"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:13:32.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/">786. 第 K 个最小的素数分数</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="1025 除数博弈"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:13:01.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/">1025 除数博弈</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">90</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/AI/DL/"><span class="level-start"><span class="level-item">DL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CS/Algorithms/"><span class="level-start"><span class="level-item">Algorithms</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/CN/"><span class="level-start"><span class="level-item">CN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/CSAPP/"><span class="level-start"><span class="level-item">CSAPP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/DB/"><span class="level-start"><span class="level-item">DB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/DS/"><span class="level-start"><span class="level-item">DS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/"><span class="level-start"><span class="level-item">Code tools</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Anki/"><span class="level-start"><span class="level-item">Anki</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Matlab/"><span class="level-start"><span class="level-item">Matlab</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Pycharm/"><span class="level-start"><span class="level-item">Pycharm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/VScode/"><span class="level-start"><span class="level-item">VScode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Language/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">刷题</span></span><span class="level-end"><span class="level-item tag">31</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/PAT/"><span class="level-start"><span class="level-item">PAT</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/"><span class="level-start"><span class="level-item">剑指offer</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://static.come2rss.xyz/%E9%92%A2%E9%93%81%E4%BE%A0.png" alt="Hexo" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>