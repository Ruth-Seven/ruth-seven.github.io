{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1621101559740},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1621101559740},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1621101559740},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1621101559740},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1621101559740},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1621101559740},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1621101559740},{"_id":"themes/icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":1621101559740},{"_id":"themes/icarus/package.json","hash":"89112412ed14c125a852b499ea91c54fc0be029e","modified":1621101559740},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1621101559740},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1621101559740},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1621101559740},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1621101559740},{"_id":"themes/icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":1621101559740},{"_id":"themes/icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":1621101559740},{"_id":"themes/icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":1621101559740},{"_id":"themes/icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":1621101559740},{"_id":"themes/icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":1621101559740},{"_id":"themes/icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":1621101559740},{"_id":"themes/icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":1621101559740},{"_id":"themes/icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":1621101559740},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":1621101559740},{"_id":"themes/icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":1621101559740},{"_id":"themes/icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":1621101559740},{"_id":"themes/icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":1621101559740},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":1621101559740},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":1621101559740},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1621101559740},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1621101559740},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1621101559740},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1621101559740},{"_id":"themes/icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":1621101559740},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1621101559740},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1621101559740},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1621101559740},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1621101559740},{"_id":"themes/icarus/.github/dependabot.yml","hash":"d532d0db30e42211f35823b9885f3ed1b2d51777","modified":1621101559740},{"_id":"themes/icarus/.github/stale.yml","hash":"88c73f6216c5666d2f60b1e8fe690a3f6e561e42","modified":1621101559740},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1621101559740},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1621101559740},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1621101559740},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1621101559740},{"_id":"themes/icarus/include/style/article.styl","hash":"be25e890113e926bbac3bf1461d7ce5427914774","modified":1621101559740},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1621101559740},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1621101559740},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1621101559740},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1621101559740},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1621101559740},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1621101559740},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1621101559740},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1621101559740},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1621101559740},{"_id":"themes/icarus/include/style/plugin.styl","hash":"dc98160142c95ef81ba4789351002a5fcf29c04c","modified":1621101559740},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1621101559740},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1621101559740},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1621101559740},{"_id":"themes/icarus/include/style/widget.styl","hash":"af07ee43e209b6361eed22171bb50efaef7cbfeb","modified":1621101559740},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1621101559740},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1621101559740},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1621101559740},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1621101559740},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1621101559750},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1621101559750},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1621101559750},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1621101559750},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1621101559750},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1621101559740},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1621101559740},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1621101559740},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1621101559740},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1621101559750},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1621101559750},{"_id":"themes/icarus/layout/common/article.jsx","hash":"85d13095ed49e3bb362fbac830df63fc416e79bf","modified":1621101559740},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1621101559740},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1621101559740},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1621101559740},{"_id":"themes/icarus/layout/common/head.jsx","hash":"bcee2e258d13af6ac439ee6adaeefc06ea384e7e","modified":1621101559740},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1621101559740},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1621101559740},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1621101559740},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1621101559740},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1621101559740},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1621101559740},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1621101559740},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1621101559740},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"6fb534c9e9ba8c22449d11fc68b891c343a3a742","modified":1621101559740},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"d801be6937df21e63113be8840b2e23c465db87b","modified":1621101559740},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"5d3abdc1a2a79ef9822865184eced6e31066d8f6","modified":1621101559740},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"42afb69546eae522e340e3adb99f7bfc4cc4c397","modified":1621101559740},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1621101559740},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1621101559740},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1621101559740},{"_id":"themes/icarus/.github/workflows/github-release.yml","hash":"48b6bd2cc567687a7b1648c55c8f9de9d44fa9e1","modified":1621101559740},{"_id":"themes/icarus/.github/workflows/lint.yml","hash":"71f04b66e48f065285ba109939999876ef411598","modified":1621101559740},{"_id":"themes/icarus/.github/workflows/npm-publish.yml","hash":"4eabc0c60cb7102fdd5e4b0fbd8c0ac4c17cc8d0","modified":1621101559740},{"_id":"themes/icarus/.github/workflows/test.yml","hash":"f816a5970f4ad4fcf6c8350dbcd4c300c6986cb4","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"bd30bd9ffc84e88e704384acdfcaab09019a744f","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1621101559740},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1621101559740},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1621101559740},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1621101559740},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1621101559740},{"_id":"source/_posts/随谈/优秀是会遗传的吧？.md","hash":"8fb68ab5004aa60dbdb29666f53fd0b368b39ad5","modified":1611843406189},{"_id":"source/_posts/随谈/大数据产品思考——地球保卫者.md","hash":"e479c4c2729ef155d511f341753e6442e8d68450","modified":1611842677919},{"_id":"source/_posts/Code tools/build/cmake学习索引.md","hash":"5d43cd3ae4876e1aa9a49d3e2fba5ed2f3e54c9c","modified":1620058601760},{"_id":"source/_posts/刷题/DP/10-Regular-Expression-Matching.md","hash":"df523ad74e7ad73fc7def0b34bfd35388faff167","modified":1611842677799},{"_id":"source/_posts/刷题/DP/121-Best-Time-to-Buy-and-Sell-Stock.md","hash":"63e49cc03ff760affa1890ca445c307bd9a9f10c","modified":1611842677789},{"_id":"source/_posts/刷题/DP/123-Best-Time-to-Buy-and-Sell-Stock-III.md","hash":"bfd52d2ab95ce7ce470276b06c2c9f60f8a9a1f6","modified":1611842677799},{"_id":"source/_posts/刷题/DP/124-Binary-Tree-Maximum-Path-Sum.md","hash":"b25efce5c64922a1f1c09a28dace1f66edba9a73","modified":1618794483839},{"_id":"source/_posts/刷题/DP/1289-Minimum-Falling-Path-Sum2.md","hash":"92e1797d94c3ce1b59a184e1fee83cb77c6878a8","modified":1611842677799},{"_id":"source/_posts/刷题/DP/139-Word-Break.md","hash":"778b39ed13f52554761b52bc0d5900ef3adb673e","modified":1611842677789},{"_id":"source/_posts/刷题/DP/1411-Number-of-Ways-to-Paint-N-×-3-Grid.md","hash":"063f6cd0f353f6a6fc3b30e8e94ffc629be05bcb","modified":1611842677789},{"_id":"source/_posts/刷题/DP/188-Best-Time-to-Buy-and-Sell-Stock-IV.md","hash":"ccc56357cb59893683fcd154b768f7fd9aef660a","modified":1611842677799},{"_id":"source/_posts/刷题/DP/198-House-Robber.md","hash":"8c3a133bacb1974eae0e34cf0b4104658a6e64d5","modified":1611842677799},{"_id":"source/_posts/刷题/DP/213-House-Robber-II.md","hash":"dfc3976ef05bba2a6a4cb07cca202f5bb7586f54","modified":1611842677799},{"_id":"source/_posts/刷题/DP/221-Maximal-Square.md","hash":"58792b3a6682e8599eefaf0f6f229f5e4b3637f1","modified":1611842677799},{"_id":"source/_posts/刷题/DP/279-Perfect-Squares.md","hash":"6bc1799a534272b192b6f1ccd358c45b0af24593","modified":1611842677799},{"_id":"source/_posts/刷题/DP/300-Longest-Increasing-Subsequence.md","hash":"56ceede5d97cb04cf21770b2e86c6ee95d6b6e95","modified":1611842677799},{"_id":"source/_posts/刷题/DP/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown.md","hash":"c285c65ade618edf03156fca78698276fc1cdf7a","modified":1611842677789},{"_id":"source/_posts/刷题/DP/312-Burst-Balloons.md","hash":"23e62fff44be9d38db3431f3223d22dc85364f30","modified":1620200671960},{"_id":"source/_posts/刷题/DP/322-Coin-Change.md","hash":"ac1037cae3a85212d4762ca714ce4397e2d8e346","modified":1611842677789},{"_id":"source/_posts/刷题/DP/337-House-Robber-III.md","hash":"1eb6de8ceabcfe83a189d527ccebaa517b3952ca","modified":1619756995597},{"_id":"source/_posts/刷题/DP/343-Integer-Break.md","hash":"0f3a5f4d2a54afc1f837ba5a6fa39eba8970c06c","modified":1611842677799},{"_id":"source/_posts/刷题/DP/376-Wiggle-Subsequence.md","hash":"737983f4163501a256948c6af6ee392c40b6bcdd","modified":1611842677789},{"_id":"source/_posts/刷题/DP/413-Arithmetic-Slices 2刷.md","hash":"0d14a24c4f9d237ed0bdc932ff8524bc2079dd11","modified":1611842677789},{"_id":"source/_posts/刷题/DP/413-Arithmetic-Slices.md","hash":"a9e2a4deb81c243e36601c3b5d67868d8003f647","modified":1611842677789},{"_id":"source/_posts/刷题/DP/416-Partition-Equal-Subset-Sum.md","hash":"4b0f2e97bfd7f4aeb80f71e57f8b749f4a9f2488","modified":1611842677799},{"_id":"source/_posts/刷题/DP/474-Ones-and-Zeroes.md","hash":"e8186902ad91664be518b94f39b270e32faffa21","modified":1611842677789},{"_id":"source/_posts/刷题/DP/494-Target-Sum.md","hash":"c1054c4cd14f62c750995a93d324f4c13ff37bc5","modified":1611842677789},{"_id":"source/_posts/刷题/DP/53-Maximum-Subarray.md","hash":"72df3eee9ca7983e22b4a0a7ac92ba8c145e987e","modified":1611842677799},{"_id":"source/_posts/刷题/DP/542-01-Matrix.md","hash":"e488fed1dfdbc5e32c0056098e6f862ce05fb948","modified":1611842677799},{"_id":"source/_posts/刷题/DP/583-Delete-Operation-for-Two-Strings.md","hash":"0f056ecb1ddee0288cc68fd883e01833929538c9","modified":1611842677799},{"_id":"source/_posts/刷题/DP/594-Longest-Harmonious-Subsequence.md","hash":"2137515dbcb7d3246e73aa22e774fab731f8a8ae","modified":1611990832240},{"_id":"source/_posts/刷题/DP/64-Minimum-Path-Sum.md","hash":"89466e9818a4c9e176a5f9d177f0da94b7e0d8e1","modified":1611842677799},{"_id":"source/_posts/刷题/DP/650-2-Keys-Keyboard.md","hash":"e6067045a3d9fee0249e490a035e17190317ce9f","modified":1611842677789},{"_id":"source/_posts/刷题/DP/70-Climbing-Stairs.md","hash":"b2072478598fe4fee6ac2c89da744f0601e1f492","modified":1611842677789},{"_id":"source/_posts/刷题/DP/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee.md","hash":"e02d1a22783cc300c9046d14afd2ccc992933ed5","modified":1611842677799},{"_id":"source/_posts/刷题/DP/72-Edit-Distance.md","hash":"163ecfff665b16bdcda4e126a1fd9cf9f08d2619","modified":1611842677789},{"_id":"source/_posts/刷题/DP/790-Domino-and-Tromino-Tiling.md","hash":"849be945b6bb30bf3b998891e1ba94f4ad6e6fa9","modified":1611842677799},{"_id":"source/_posts/刷题/DP/91-Decode-Ways.md","hash":"7f9dc0a986dabc9a7b2aa0b21814c4378c360d5e","modified":1611842677799},{"_id":"source/_posts/刷题/DP/96-Unique-Binary-Search-Trees.md","hash":"a031e4b877620fcf2952924f0a696096f82e9e0d","modified":1619672282020},{"_id":"source/_posts/刷题/DP/P1025-数的划分.md","hash":"8e27fdb25043a1d94b9d88afaef3cedbda79f9b2","modified":1611842677789},{"_id":"source/_posts/刷题/DP/面试题-17-24-最大子矩阵.md","hash":"fe9b28e8c0edd7c3bf0cf70f84f6bd6873db2c2e","modified":1620611726053},{"_id":"source/_posts/刷题/DP/面试题-DP-贪心.md","hash":"ed05514c683f54a7de74bf3b481a71eab67da951","modified":1611842677799},{"_id":"source/_posts/刷题/位运算\n/1286-Iterator-for-Combination.md","hash":"c3c643da72a8f000c09d988075e5e48a5c0d0e70","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/136-Single-Number.md","hash":"534dd15763ee1b2ec66dab1974310edd141889c2","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/190-Reverse-Bits.md","hash":"c9305935457c297cbc193398e1e3d3688ce4d96a","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/260-Single-Number-III.md","hash":"5c00c13249c77cbe0a092b3678d55b269225087e","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/268-Missing-Number.md","hash":"baa6fa284c8f783d5dbff4f751d068e40650456a","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/318-Maximum-Product-of-Word-Lengths.md","hash":"2ba9832b2d2e8a5e08cb2160d5faebde9a35f915","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/338-Counting-Bits.md","hash":"a48469a7752f14df62b92fadff976c645ac4e2b3","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/342-Power-of-Four.md","hash":"56feeb8b07717134cb9e81dcdb0b715e19760b3d","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/461-Hamming-Distance.md","hash":"f78ca388299ac868ffa60155d1c743a4f0c64f55","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/476-Number-Complement.md","hash":"94233e9429db6d28100d3ff5e7d8d86e1596ed4a","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/693-Binary-Number-with-Alternating-Bits.md","hash":"757b04b30af974b271f4bfa1b8f5c6430dc993f8","modified":1611842677879},{"_id":"source/_posts/刷题/位运算\n/面试题-位运算.md","hash":"6a847d2087d4ece577e2086145a3cee9691081eb","modified":1611842677879},{"_id":"source/_posts/刷题/其他/1025-除数博弈.md","hash":"74683296a8dfe7560ef54c491c46b70e82fab56e","modified":1611843421689},{"_id":"source/_posts/刷题/其他/1027-最长等差数列.md","hash":"d7f6a8e3c693917941f8da07bc3e2ec7d04ba3e5","modified":1611842677819},{"_id":"source/_posts/刷题/其他/1143-Longest-Common-Subsequence.md","hash":"6e66fab4a3836636a908cb0ffe0f47f5e0f4f17a","modified":1611842677819},{"_id":"source/_posts/刷题/其他/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses.md","hash":"6de5f2710be0bf04e5cbcd51783aacfcf2c4ed63","modified":1611842677819},{"_id":"source/_posts/刷题/其他/122-Best-Time-to-Buy-and-Sell-Stock-II.md","hash":"8903fcd056f51cc2a797be44db4382953cc7a942","modified":1611842677819},{"_id":"source/_posts/刷题/其他/1254-Number-of-Closed-Islands.md","hash":"745e9295a38d0b4e9b3bdcbcecf21789153ce56d","modified":1611842677819},{"_id":"source/_posts/刷题/其他/15-3sum.md","hash":"796649c3f43b0731f7fb4912e0b24cb2e31610ba","modified":1611843588019},{"_id":"source/_posts/刷题/其他/240-Search-a-2D-Matrix-II.md","hash":"92ff0a3bf2de6f1877ca90cfba0c79241b8d4389","modified":1611842677819},{"_id":"source/_posts/刷题/其他/303-Range-Sum-Query-Immutable.md","hash":"8bb89aa076aebdaa85cdc32ec3296e8807fe580a","modified":1611892080553},{"_id":"source/_posts/刷题/其他/304-Range-Sum-Query-2D-Immutable.md","hash":"3b01b098f0305aac8cc35234004c2cdf6127e84a","modified":1611892075013},{"_id":"source/_posts/刷题/其他/326-Power-of-Three.md","hash":"64a7f49bfdf5957e51cb19b31b3f9e153efa9d68","modified":1611842677799},{"_id":"source/_posts/刷题/其他/341-Flatten-Nested-List-Iterator.md","hash":"59a00d27c4339a162292b98d12ddffbd523d60d6","modified":1616487813500},{"_id":"source/_posts/刷题/其他/406-Queue-Reconstruction-by-Height.md","hash":"a6314f39cd38130172ecba4e2c2330c7c297a2ee","modified":1611842677819},{"_id":"source/_posts/刷题/其他/448-Find-All-Numbers-Disappeared-in-an-Array.md","hash":"704f71f3793366bc0e58ddc76e4d28437ae1a470","modified":1611842677819},{"_id":"source/_posts/刷题/其他/48-Rotate-Image.md","hash":"489ac3ae86bc9fce4946df17d79d46d3b6e4f183","modified":1611842677799},{"_id":"source/_posts/刷题/其他/524-Longest-Word-in-Dictionary-through-Deleting.md","hash":"df4ffa91eecc64df7810659ca8b62f443fc0c8db","modified":1611842677819},{"_id":"source/_posts/刷题/其他/540-Single-Element-in-a-Sorted-Array.md","hash":"767a3def192810411ecfa0441ce463c1364e6c6d","modified":1611842677819},{"_id":"source/_posts/刷题/其他/560-Subarray-Sum-Equals-K.md","hash":"66176d39dfb01d20f24695d16bed8f94a7e2a210","modified":1611892095313},{"_id":"source/_posts/刷题/其他/566-Reshape-the-Matrix.md","hash":"f7c50031c2480d85cb1aa7126b348a117753e0ba","modified":1611990797930},{"_id":"source/_posts/刷题/其他/605-Can-Place-Flowers.md","hash":"8110e75d84e741d6cad76ff11c3fbf8394d1bfc5","modified":1611842677799},{"_id":"source/_posts/刷题/其他/697-Degree-of-an-Array.md","hash":"06aa34789fefa7b04463547d1a10af42f5cee422","modified":1611842677799},{"_id":"source/_posts/刷题/其他/747-Largest-Number-At-Least-Twice-of-Others.md","hash":"945c66214cf0ddccefa2e669ceb978b047f900c0","modified":1611842677819},{"_id":"source/_posts/刷题/其他/769-Max-Chunks-To-Make-Sorted.md","hash":"216b7af0d9ea3ad8dca6a0ca84083b94388747dd","modified":1611842677819},{"_id":"source/_posts/刷题/其他/786-第-K-个最小的素数分数.md","hash":"043d45576ff07f5fb922a386ec92a0c7c0c110ac","modified":1611842677819},{"_id":"source/_posts/刷题/其他/79-Word-Search.md","hash":"5855a2ac033bbf348c05b5ddf8703031382c9198","modified":1611842677799},{"_id":"source/_posts/刷题/其他/833-字符串中的查找与替换.md","hash":"4c107f8627256528aabf0101654e404ba094f42a","modified":1611842677799},{"_id":"source/_posts/刷题/其他/88-Merge-Sorted-Array.md","hash":"7871859b13184fea1634b8579790aa9f731e54a5","modified":1611842677819},{"_id":"source/_posts/刷题/其他/934-Shortest-Bridge.md","hash":"0b58c835be810b99bc81652722b89b27c5778265","modified":1611842677819},{"_id":"source/_posts/刷题/其他/面16-数值的N次方.md","hash":"c5b9e9cb0f613f6c5b7d54ff2fe2f7d0dd541be4","modified":1611842677799},{"_id":"source/_posts/刷题/其他/面试题-递归迭代.md","hash":"1ffbd75a8217ee678676bef5c4c0d02639f364a3","modified":1611842677799},{"_id":"source/_posts/刷题/其他/面试题44：1出现的个数.md","hash":"d53a5460e2b94ea4e7e7b68db04686da9fe41a80","modified":1611842677819},{"_id":"source/_posts/刷题/其他/面试题49：丑数.md","hash":"b8a2fb7bf9e8460a7d6c472b5891d6969a1c0f30","modified":1611842677819},{"_id":"source/_posts/刷题/分治\n/241-Different-Ways-to-Add-Parentheses.md","hash":"c31cb28529af817376ccff54c028a376448895b7","modified":1611842677829},{"_id":"source/_posts/刷题/分治\n/932-Beautiful-Array.md","hash":"c826b84cbfef2f4c2df3a5d118e1bbbca650f8ff","modified":1611842677829},{"_id":"source/_posts/刷题/双指针/142-Linked-List-Cycle-II.md","hash":"92f4337db51e5c328b64eba635a8c37559b018ba","modified":1611842677839},{"_id":"source/_posts/刷题/双指针/167-Two-Sum-II-Input-array-is-sorted.md","hash":"80f1861a87ef977ef868b20b26215e657509f1f3","modified":1611842677839},{"_id":"source/_posts/刷题/双指针/287-Find-the-Duplicate-Number.md","hash":"c67061f7b845a4aade6b89fc0a5258cd90349f4a","modified":1612528766236},{"_id":"source/_posts/刷题/双指针/438-Find-All-Anagrams-in-a-String.md","hash":"83dbc588db0df0f890e9df6603cb0ceea053a91f","modified":1619763847457},{"_id":"source/_posts/刷题/双指针/633-Sum-of-Square-Numbers.md","hash":"cc4025c9b084005b9a83f30a76b154dfcd0473c4","modified":1611842677839},{"_id":"source/_posts/刷题/双指针/680-Valid-Palindrome-II.md","hash":"52bb5242973eb11f7b38977d0399f07d8bdc9809","modified":1611842677839},{"_id":"source/_posts/刷题/双指针/76-Minimum-Window-Substring.md","hash":"45eafbd421ecd7c87e32c2c7c5255ad724a1891f","modified":1619270883349},{"_id":"source/_posts/刷题/字符串/132-Palindrome-Partitioning-II.md","hash":"4ca6ca3abe9953eb097542689bf33a80dd7b32f1","modified":1615175322320},{"_id":"source/_posts/刷题/字符串/227-Basic-Calculator-II.md","hash":"b3274e681cf6044104a37d4ee67b592331a158a6","modified":1613132953610},{"_id":"source/_posts/刷题/字符串/28-Implement-strStr.md","hash":"9ab72a3528700610143f9d07d70d35b7346968c8","modified":1613566435143},{"_id":"source/_posts/刷题/字符串/3-Longest-Substring-Without-Repeating-Characters.md","hash":"cfd653e17059331210a8ea705a684bef8c229e32","modified":1613626400100},{"_id":"source/_posts/刷题/字符串/647-Palindromic-Substrings.md","hash":"09cf739be7dd29f519a282241717d12e722944a5","modified":1613308276069},{"_id":"source/_posts/刷题/排序\n/215-Kth-Largest-Element-in-an-Array.md","hash":"002b40bcc78ceb98d197b877f7747d5dcd349c12","modified":1613624854800},{"_id":"source/_posts/刷题/排序\n/451-Sort-Characters-By-Frequency.md","hash":"bb98f522c3849b6319cf3b92390eba9e044363e0","modified":1611842677839},{"_id":"source/_posts/刷题/排序\n/面试题51-逆序数.md","hash":"7958796c6aa29d05290e3086158268beed504369","modified":1611842677839},{"_id":"source/_posts/刷题/数学\n/168-Excel-Sheet-Column-Title.md","hash":"f21d30d16dfbdc8bfd645e9ed17ff449e59d7793","modified":1611842677819},{"_id":"source/_posts/刷题/数学\n/169-Majority-Element.md","hash":"e01ce6b5501b5cdc987bfaa1a73254094f12a6c4","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/172-Factorial-Trailing-Zeroes.md","hash":"41219aaf97ebcf982c84e167a6f99d2ed5ae29c7","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/202-Happy-Number.md","hash":"759ff4b7df7dce0da85b6118156c001d31f34ec1","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/204-Count-Primes.md","hash":"e05e0db155213cc7d055c93d296dc2898a5ecb50","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/238-Product-of-Array-Except-Self.md","hash":"4d6912fb7c7d6d48bac554fcb32303e667dd8fbc","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/313-Super-Ugly-Number.md","hash":"194470a3f5ee5249ce7159f1dfe26d6fd95418c2","modified":1612528755556},{"_id":"source/_posts/刷题/数学\n/382-Linked-List-Random-Node.md","hash":"d7e9dcfa2ff51639d758eeed64aeac2f40e08f19","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/384-Shuffle-an-Array.md","hash":"ba060763c4d6fc69731dba9434647e18d52a55e2","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/415-Add-Strings.md","hash":"d6c24d8caf0162529b54b4d9724c8a539def1b5d","modified":1611842677819},{"_id":"source/_posts/刷题/数学\n/462-Minimum-Moves-to-Equal-Array-Elements-II.md","hash":"6075e84b72484f78d826318346275c020396b793","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/470-Implement-Rand10-Using-Rand7.md","hash":"b05716d455abd4eb50e0cc2c2e19d8c94589a8c8","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/504-Base-7.md","hash":"bc2d3912c8b2941290214508575c902d58e9984a","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/528-Random-Pick-with-Weight.md","hash":"fc678aa66d75283557ccaae10e3f6149a5acfb06","modified":1611842677819},{"_id":"source/_posts/刷题/数学\n/67-Add-Binary.md","hash":"237343d4d22ccb894f5a4ff6aa11c7726779ba17","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/972-Equal-Rational-Numbers.md","hash":"3bb067cd9aa429144d9df8d61890942dd7b65e49","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/错排问题-年会抽奖.md","hash":"7e938736a1cf7acccd1f6911096a2c21043a2dcd","modified":1615386562330},{"_id":"source/_posts/刷题/数学\n/面16-数值的N次方.md","hash":"c5b9e9cb0f613f6c5b7d54ff2fe2f7d0dd541be4","modified":1611842677819},{"_id":"source/_posts/刷题/数学\n/面试题-16-05-Factorial-Zeros-LCCI.md","hash":"02224a3ddbc3074ebbe62fe3e96d91fc7b3796fd","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/面试题-大数.md","hash":"828f13821d4ee977d5d4ae7c12e334bea7f624ca","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/面试题-建模.md","hash":"1c405c7848c27bc329942aff3aacf5a4fd7eb33d","modified":1611842677819},{"_id":"source/_posts/刷题/数学\n/面试题44：1出现的个数.md","hash":"d53a5460e2b94ea4e7e7b68db04686da9fe41a80","modified":1611842677829},{"_id":"source/_posts/刷题/数学\n/面试题49：丑数.md","hash":"b8a2fb7bf9e8460a7d6c472b5891d6969a1c0f30","modified":1611842677829},{"_id":"source/_posts/刷题/模拟\n/146-LRU-Cache.md","hash":"9254e4a81bfeb084217d9295d70e143b148df1b0","modified":1614395513373},{"_id":"source/_posts/刷题/模拟\n/面5：合并数组.md","hash":"49553f42ae3dad91f7d3cb48aadc145ae0bc9507","modified":1613308437219},{"_id":"source/_posts/刷题/模拟\n/面试-模拟题.md","hash":"a0597c2125da9b4da724b7d16bc9fccd1cbfc791","modified":1611842677879},{"_id":"source/_posts/刷题/模拟\n/面试题-建模.md","hash":"1c405c7848c27bc329942aff3aacf5a4fd7eb33d","modified":1611842677879},{"_id":"source/_posts/刷题/贪心\n/435-Non-overlapping-Intervals.md","hash":"48bb7304c24a8ac7a2a4b83dcec7a892464e451c","modified":1611842677839},{"_id":"source/_posts/刷题/贪心\n/452-Minimum-Number-of-Arrows-to-Burst-Balloons.md","hash":"5629ae69651672b8c9b4348de5ae74a1d575a9a0","modified":1611842677829},{"_id":"source/_posts/刷题/贪心\n/455-Assign-Cookies.md","hash":"552538942653a01d835826d3f98281df3deaab15","modified":1611842677839},{"_id":"source/_posts/刷题/贪心\n/5674-Largest-Merge-Of-Two-Strings.md","hash":"d9e6e7564fc16b6e0865ba10fa243ba49c8b4ea3","modified":1612677295725},{"_id":"source/_posts/刷题/贪心\n/665-Non-decreasing-Array.md","hash":"bedfd9aa49e3af04dfb40482a08898d05fe68873","modified":1611842677829},{"_id":"source/_posts/刷题/贪心\n/763-Partition-Labels.md","hash":"d0186c0f8f98b3c17a2497b3766dd2b435ad085b","modified":1611842677839},{"_id":"source/_posts/刷题/贪心\n/870-Advantage-Shuffle.md","hash":"46df2e2c904935c7304d87e12a7215e3d0600708","modified":1612528788976},{"_id":"source/_posts/刷题/贪心\n/面试题-DP-贪心.md","hash":"ed05514c683f54a7de74bf3b481a71eab67da951","modified":1611842677839},{"_id":"source/_posts/刷题/~其他code能力/代码规范\n/编程完整性.md","hash":"a6fd27bbdc0f86a30637092dda823b390d8d4a18","modified":1611842677879},{"_id":"source/_posts/刷题/~其他code能力/沟通能力\n/面试素质.md","hash":"9ebd8678b62b1db1240dfdb8f38b3443236f6aee","modified":1611842677879},{"_id":"source/_posts/刷题/其他/扫描线\n/218-The-Skyline-Problem.md","hash":"09160bd19a59e4ec0be1487f2be93b4cee662840","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/bfs\n/126-Word-Ladder-II.md","hash":"b381fb49601d3e00be74b121d82eace706877ffc","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/bfs\n/22-Generate-Parentheses.md","hash":"73bdeacf86ddbc09377a5d28f516e3cf44f9c677","modified":1619397489150},{"_id":"source/_posts/刷题/搜索/dfs\n/130-Surrounded-Regions.md","hash":"3a38264c80d89532aae80b59c8901ac71c0fe9ce","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/dfs\n/417-Pacific-Atlantic-Water-Flow.md","hash":"2302d87fe764edcc635a2401f993cbfa31249764","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/dfs\n/547-Friend-Circles.md","hash":"3933d26a5c2a12eb92fcd09b51edc330b9a4c020","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/dfs\n/547-Number-of-Provinces.md","hash":"539c07b6b2d468170621921da819b038779003cb","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/dfs\n/695-Max-Area-of-Island.md","hash":"ee7a6275e77d657b176ca6cf648ca073dbb2bc9c","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/154-Find-Minimum-in-Rotated-Sorted-Array-II.md","hash":"307d22c1fcf1c7859d948af7cd85c48c34c6375c","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/2020-10-30-81.-Search-in-Rotated-Sorted-Array-II.md","hash":"7c070d6e454178f365b9c0ffd006eccadc154e54","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.md","hash":"af1b8a6ebbbf3c7ab703959db15b50110034b6a8","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/4-Median-of-Two-Sorted-Arrays.md","hash":"e582af36afe0ab5be01b9744059d715974f54aa8","modified":1618992699270},{"_id":"source/_posts/刷题/搜索/二分\n/69-Sqrt-x.md","hash":"fe4f07318fb24d689846e4b71f0c0b9a89f513b9","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/75-Sort-Colors.md","hash":"a3392348ca8b63c3c60e98b0a1133ae85687a7e6","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/81-Search-in-Rotated-Sorted-Array-II.md","hash":"aa12b65f7d7465a7595ebeb4b8cc149e9059c3be","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/面试题-二分.md","hash":"31abba24f372a5301e9fc9c18cc0a206f7663f1d","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/二分\n/面试题53-II-0～n-1中缺失的数字.md","hash":"ae4d36bbe18bc4740559a236b430aedd2f79a024","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/37-Sudoku-Solver.md","hash":"d21a8929184e1ba676c04c15ef68f7e1d615250f","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/37.解数独.md","hash":"a5af931bdd14cfb5c94326f18b18820d12e9e1c7","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/39-Combination-Sum.md","hash":"c08b1dc1dca7205e12f7803d18448a929afb92aa","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/40-Combination-Sum-II.md","hash":"7c239dcc2338c8dfc8c407a10e57fc5d24d3573a","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/46-Permutations.md","hash":"f37bee920be2f9a38987db0e52034593b40446fc","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/47-Permutations-II.md","hash":"4d7acdad3d03a1beadd12005fcac03621dc04ee9","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/51-N-Queens.md","hash":"54df0e7d7a6d2085cb68d2d5c5562551f9f16f05","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/77-Combinations.md","hash":"30d1b69d2e00fde893541ece57b22c35cd425872","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/回溯\n/面试题-回溯DFs.md","hash":"f04ab92112830ae5ed7a94129bd606be57db39bb","modified":1611842677839},{"_id":"source/_posts/刷题/搜索/记忆化搜索\n/1340-Jump-Game-V.md","hash":"4c1e51f8f752e18db4f19d44fe16f2f32d33ea24","modified":1611842677899},{"_id":"source/_posts/刷题/搜索/记忆化搜索\n/135-Candy.md","hash":"82feb4fb5258a3a9b84eb9daa92058c9908f22f5","modified":1611842677899},{"_id":"source/_posts/刷题/数据结构/set\n/1-Two-Sum.md","hash":"6964a1df84177c0ca1f90a8b8c574ba9dfc8a3df","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/set\n/128-Longest-Consecutive-Sequence.md","hash":"f6ecdaf73f6e398bdd56900b1cfcd654533bb2b1","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/优先队列\n/23-Merge-k-Sorted-Lists.md","hash":"d8bc9962a9fff1979bf88015e610b7602ed51b51","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/哈希/149-Max-Points-on-a-Line.md","hash":"e977b9ee27c29c083c96f0e7fd006b300cbfd80c","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/图\n/210-Course-Schedule-II-Medium.md","hash":"1c911bb68d9eb804b7f4ac558c89a7bee9cfb902","modified":1614388769863},{"_id":"source/_posts/刷题/数据结构/图\n/332-Reconstruct-Itinerary.md","hash":"ef5bf1f7e11f99e7632b124d28a0a42a58f4f25a","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/图\n/785-Is-Graph-Bipartite.md","hash":"df9aa17a16ecf27aa098621dfbc5a675e82f3001","modified":1614140368113},{"_id":"source/_posts/刷题/数据结构/图\n/847-访问所有节点的最短路径.md","hash":"81bf66b3c330811ddce517697635633a241b76b4","modified":1620464698030},{"_id":"source/_posts/刷题/数据结构/图\n/882-Reachable-Nodes-In-Subdivided-Graph.md","hash":"135da0838447922371d19d703f48fb46ee3c50e2","modified":1614676992060},{"_id":"source/_posts/刷题/数据结构/图\n/二分图匹配.md","hash":"557d5ef601f95082a28928525486396eb7dcf0e6","modified":1620540180086},{"_id":"source/_posts/刷题/数据结构/图\n/割点算法.md","hash":"54ffe575e8b2f0ccdb38a684f05c3fd936d68238","modified":1620531466240},{"_id":"source/_posts/刷题/数据结构/堆\n/347-Top-K-Frequent-Elements.md","hash":"9d6f9f18d2500610544bee05e4454959ae286146","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/复杂数据结构/380-Insert-Delete-GetRandom-O-1.md","hash":"a81bd08fb35b0765e6f1279e992d85a80b9b83b9","modified":1614745994530},{"_id":"source/_posts/刷题/数据结构/复杂数据结构/706-Design-HashMap.md","hash":"04cf1998113952afa298d9ca5468eb272e67bcc4","modified":1615778097317},{"_id":"source/_posts/刷题/数据结构/栈和队列/155-Min-Stack.md","hash":"ee440bfe97a832a03f4d0c11276d7eee22e957d5","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/栈和队列/20-Valid-Parentheses.md","hash":"30cf9cfcb7c8c8ff8aac1c00233ae6958396bece","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/栈和队列/225-Implement-Stack-using-Queues.md","hash":"b3cbea200ca0e8d660ba0fed894c7b7f83cf3201","modified":1611990788070},{"_id":"source/_posts/刷题/数据结构/栈和队列/232-Implement-Queue-using-Stacks.md","hash":"6e7acfe3a657c2fcd9e07ae97b5b546c92346d4b","modified":1611842677879},{"_id":"source/_posts/刷题/数据结构/栈和队列/239-Sliding-Window-Maximum.md","hash":"f46678bf3a115aeab9a26933c4b50425f9c2b23a","modified":1618993062920},{"_id":"source/_posts/刷题/数据结构/栈和队列/32-Longest-Valid-Parentheses.md","hash":"66646c0718680ac16703ce6aeb99078eec6a87e8","modified":1619339529630},{"_id":"source/_posts/刷题/数据结构/栈和队列/503-Next-Greater-Element-II.md","hash":"e939c482e5ee79ba615ce5cca0ab5edf492b8351","modified":1611990808850},{"_id":"source/_posts/刷题/数据结构/栈和队列/98-Validate-Binary-Search-Tree.md","hash":"d9e49349283134496b3f0271a15d6f7005d33c37","modified":1619078583910},{"_id":"source/_posts/刷题/数据结构/栈和队列/面试题-栈和队列.md","hash":"0e00d85f9bf683edf5b183f32e25a280537cfa09","modified":1611842677839},{"_id":"source/_posts/刷题/数据结构/树/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.md","hash":"067ae6f494982d8b902533893aa5265add7b7d25","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/树/109-Convert-Sorted-List-to-Binary-Search-Tree.md","hash":"07f2e6ae0e38ba2dab1cd45052928af41fb78e81","modified":1614819476610},{"_id":"source/_posts/刷题/数据结构/树/1609-Even-Odd-Tree.md","hash":"3e69ad1fe37201ca5c391dc5938feb6d54ff5ae9","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/树/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree.md","hash":"3ba95ef8b3c7f7bad6a87ab8aa9293f7091914cb","modified":1611842677879},{"_id":"source/_posts/刷题/数据结构/树/236-Lowest-Common-Ancestor-of-a-Binary-Tree.md","hash":"94300fba32f73d2f24b38179c838f1449863e623","modified":1617265773460},{"_id":"source/_posts/刷题/数据结构/树/297-Serialize-and-Deserialize-Binary-Tree.md","hash":"62d8183c48df948b675c184dd5389d6a6f041bdf","modified":1619397299990},{"_id":"source/_posts/刷题/数据结构/树/307-Range-Sum-Query-Mutable.md","hash":"089876f088e768c25cf9914a3b536c828aa95899","modified":1612528796426},{"_id":"source/_posts/刷题/数据结构/树/310-Minimum-Height-Trees.md","hash":"9795099007c736e437ba4e077638d23cbaaa32fd","modified":1611842677879},{"_id":"source/_posts/刷题/数据结构/树/331-Verify-Preorder-Serialization-of-a-Binary-Tree.md","hash":"38cd3420aede0048f5120e526c3176ee0f7ac7e5","modified":1615534809030},{"_id":"source/_posts/刷题/数据结构/树/450-Delete-Node-in-a-BST.md","hash":"3b5e9fe0479b4c2f3806a7aaa35a5e3378ec7a1c","modified":1614753073261},{"_id":"source/_posts/刷题/数据结构/树/653-Two-Sum-IV-Input-is-a-BST.md","hash":"0751d3a29c5203b69105ec1bb0e9430311ae87a2","modified":1614758473771},{"_id":"source/_posts/刷题/数据结构/树/654-最大二叉树.md","hash":"055d68849ddc11f0a0a08d88d77d0a4274ca0977","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/树/897-Increasing-Order-Search-Tree.md","hash":"4cea24c38fea93d5c2639029089e6bf7ecbfbfa0","modified":1614820247070},{"_id":"source/_posts/刷题/数据结构/树/PAT-1043-二叉树重建.md","hash":"8aaac0ca2f7dc51824cf800c8848b791f5f4dcc5","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/树/PAT风格二叉树总结.md","hash":"040d68a62b5fbf4ab42672c335640f5e5f1501a3","modified":1611842677859},{"_id":"source/_posts/刷题/数据结构/树/面试题-04-09-BST-Sequences-LCCI.md","hash":"df4d0090e74c3abed582028f555b6601ff873c66","modified":1617265734820},{"_id":"source/_posts/刷题/数据结构/树/面试题-二叉树.md","hash":"6a24c461450da9fc5fb8235273e9c85b6107baa2","modified":1617265748210},{"_id":"source/_posts/刷题/数据结构/链表\n/148-排序链表.md","hash":"896023afd7bdcefce5a87d1ae0401278d0c8100b","modified":1617265807540},{"_id":"source/_posts/刷题/数据结构/链表\n/面试题-链表相关.md","hash":"2f8d56a2d607e76ab25fec5f7c28d114ce50cec0","modified":1613817123052},{"_id":"source/_posts/刷题/数据结构/栈和队列/单调栈\n/42-Trapping-Rain-Water.md","hash":"71a111a5a81f032f568781d098d52ce0330a787b","modified":1618568225563},{"_id":"source/_posts/刷题/数据结构/栈和队列/单调栈\n/739-Daily-Temperatures.md","hash":"2c983b4a4abb9aa2eae78f2ba5ed8d8fa262f414","modified":1611842677839},{"_id":"source/_posts/刷题/数据结构/栈和队列/单调栈\n/84-Largest-Rectangle-in-Histogram.md","hash":"5e3bcd18da958de06c7346730e9e852da889cc60","modified":1619757004127},{"_id":"public/atom.xml","hash":"3cd45ee1d090a2d4ec01e7c1b195be2f07e4e27e","modified":1621101838941},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1621101838941},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1621101838941},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1621101838941},{"_id":"public/content.json","hash":"50fbc5f84d85811a2790473a5be681fb48439fb8","modified":1621101838941},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1621101838941},{"_id":"public/manifest.json","hash":"17895bd3420a44189ef98c5c6368b257e000bd44","modified":1621101838941},{"_id":"public/2021/05/10/shua-ti/dp/mian-shi-ti-17-24-zui-da-zi-ju-zhen/index.html","hash":"f5472181a2d709ff96cbc09e95f7d9f6bf8172b1","modified":1621101838941},{"_id":"public/2021/05/09/shua-ti-shu-ju-jie-gou-tu-er-fen-tu-pi-pei/index.html","hash":"cfed7454875ea6edaaa050c6e4227c9a23b05e1f","modified":1621101838941},{"_id":"public/2021/05/09/shua-ti-shu-ju-jie-gou-tu-ge-dian-suan-fa/index.html","hash":"df8609c918ab4a782a1f1790b490d4c4b2e0df8d","modified":1621101838941},{"_id":"public/2021/05/08/shua-ti-shu-ju-jie-gou-tu-847-fang-wen-suo-you-jie-dian-de-zui-duan-lu-jing/index.html","hash":"567a717d109fc39c4da41a110b14f391c8a1842e","modified":1621101838941},{"_id":"public/2021/05/05/shua-ti/dp/312-burst-balloons/index.html","hash":"06281894e091b164b58f833a88b0dfca578141cb","modified":1621101838941},{"_id":"public/2021/05/04/code-tools/build/cmake-xue-xi-suo-yin/index.html","hash":"23b7ff521cdccb21745aa724dd3a05edb327a99f","modified":1621101838941},{"_id":"public/2021/04/30/shua-ti/shuang-zhi-zhen/438-find-all-anagrams-in-a-string/index.html","hash":"a0eb6b8b8f93e1d4c15bdf8c0708d07ee8561c5f","modified":1621101838941},{"_id":"public/2021/04/30/shua-ti/dp/337-house-robber-iii/index.html","hash":"fd417d286dd219debe0eac9bba747cb4d52c494d","modified":1621101838941},{"_id":"public/2021/04/30/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-84-largest-rectangle-in-histogram/index.html","hash":"74c46342fe549b48be2ef08b7509d9c6a7f00e63","modified":1621101838941},{"_id":"public/2021/04/29/shua-ti/dp/96-unique-binary-search-trees/index.html","hash":"5651b84d12b085f766c6f2afbe598195722c71c2","modified":1621101838941},{"_id":"public/2021/04/26/shua-ti/shu-ju-jie-gou/shu/297-serialize-and-deserialize-binary-tree/index.html","hash":"6fb7f9c5bbe634fba0274586c2f7b11c9a582c48","modified":1621101838941},{"_id":"public/2021/04/26/shua-ti-sou-suo-bfs-22-generate-parentheses/index.html","hash":"df1c195cd1cec699f2e5700658cbf0df0b24c416","modified":1621101838941},{"_id":"public/2021/04/25/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/32-longest-valid-parentheses/index.html","hash":"48d5712b55e13b2e08330ed3d88d71f977e47a3a","modified":1621101838941},{"_id":"public/2021/04/22/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/98-validate-binary-search-tree/index.html","hash":"a26530302216c83bada032222fa41b3c0a639359","modified":1621101838941},{"_id":"public/2021/04/19/shua-ti/dp/124-binary-tree-maximum-path-sum/index.html","hash":"3628b83ebe35d9dfe26e843da521726b0ce24ff6","modified":1621101838941},{"_id":"public/2021/04/16/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-42-trapping-rain-water/index.html","hash":"db1dc0a1da13fbc2897376b3509a671d2b4f0825","modified":1621101838941},{"_id":"public/2021/04/01/shua-ti/shu-ju-jie-gou/shu/mian-shi-ti-04-09-bst-sequences-lcci/index.html","hash":"067fb8dad3a8889ce2d03a217ee18adc538c666d","modified":1621101838941},{"_id":"public/2021/03/31/shua-ti-shu-ju-jie-gou-lian-biao-148-pai-xu-lian-biao/index.html","hash":"3bfd8fe8dce4e002bd561a6ecfe48707b6b0a80d","modified":1621101838941},{"_id":"public/2021/03/15/shua-ti/shu-ju-jie-gou/fu-za-shu-ju-jie-gou/706-design-hashmap/index.html","hash":"edb16c2b3242bb92d30c121b971ea33729649eaf","modified":1621101838941},{"_id":"public/2021/03/12/shua-ti/shu-ju-jie-gou/shu/331-verify-preorder-serialization-of-a-binary-tree/index.html","hash":"f3f7fe016a950999439a06c852060912a4056e7c","modified":1621101838941},{"_id":"public/2021/03/10/shua-ti-shu-xue-cuo-pai-wen-ti-nian-hui-chou-jiang/index.html","hash":"cfa32bf15240755886e62c4014455a3a337ef492","modified":1621101838941},{"_id":"public/2021/03/08/shua-ti/zi-fu-chuan/132-palindrome-partitioning-ii/index.html","hash":"f9bb97b77e832ddf5c96de83b0875934d1b6ec08","modified":1621101838941},{"_id":"public/2021/03/04/shua-ti/shu-ju-jie-gou/shu/236-lowest-common-ancestor-of-a-binary-tree/index.html","hash":"76dc66f342b415a6967bb39769e8694a4aa0b080","modified":1621101838941},{"_id":"public/2021/03/04/shua-ti/shu-ju-jie-gou/shu/897-increasing-order-search-tree/index.html","hash":"b8cb4256e2e73b69f2b050924cab0eb6d52a43a8","modified":1621101838941},{"_id":"public/2021/03/04/shua-ti/shu-ju-jie-gou/shu/109-convert-sorted-list-to-binary-search-tree/index.html","hash":"b67d34d956635ee7dc826711384bf4a656878209","modified":1621101838941},{"_id":"public/2021/03/03/shua-ti/shu-ju-jie-gou/shu/653-two-sum-iv-input-is-a-bst/index.html","hash":"81732e5d3e5381e723c3ac09a183c13514cbf0bc","modified":1621101838941},{"_id":"public/2021/03/03/shua-ti/shu-ju-jie-gou/shu/450-delete-node-in-a-bst/index.html","hash":"d3cf69da5996778ac2d9ebe27c955a550a98fcc5","modified":1621101838941},{"_id":"public/2021/03/03/shua-ti/shu-ju-jie-gou/fu-za-shu-ju-jie-gou/380-insert-delete-getrandom-o-1/index.html","hash":"6b2acf41b822e9b66a49928ccfc688efe8e99c7b","modified":1621101838941},{"_id":"public/2021/03/02/shua-ti-shu-ju-jie-gou-tu-882-reachable-nodes-in-subdivided-graph/index.html","hash":"ff20fc10d4cfdc1c997e33159dc88de474d98a3b","modified":1621101838941},{"_id":"public/2021/02/27/shua-ti-mo-ni-146-lru-cache/index.html","hash":"ffda13274dca6f4826d66672fe35e0b194cd5cc4","modified":1621101838941},{"_id":"public/2021/02/27/shua-ti-shu-ju-jie-gou-tu-210-course-schedule-ii-medium/index.html","hash":"3988116319c5b7b86c331dc8abb6b41f1de6b14d","modified":1621101838941},{"_id":"public/2021/02/24/shua-ti-shu-ju-jie-gou-tu-785-is-graph-bipartite/index.html","hash":"1109842571f641dd84b6aad5e03e1081e326ca75","modified":1621101838941},{"_id":"public/2021/02/18/shua-ti/zi-fu-chuan/3-longest-substring-without-repeating-characters/index.html","hash":"b179dab8f0526de8644c3d37302b64518126e9ba","modified":1621101838941},{"_id":"public/2021/02/15/shua-ti/zi-fu-chuan/28-implement-strstr/index.html","hash":"5b862a1f11b331e6ed4a71bedf79bc38b92e1121","modified":1621101838941},{"_id":"public/2021/02/14/shua-ti/zi-fu-chuan/647-palindromic-substrings/index.html","hash":"757bfa207220b2207d28fb9d1f2462c157106ed3","modified":1621101838941},{"_id":"public/2021/02/12/shua-ti/zi-fu-chuan/227-basic-calculator-ii/index.html","hash":"dccf06d7134cc785526d0ea11b60248166bde8bd","modified":1621101838941},{"_id":"public/2021/02/07/shua-ti-tan-xin-5674-largest-merge-of-two-strings/index.html","hash":"066d82f96b1d542fde595b2766edb2b032e70ca3","modified":1621101838941},{"_id":"public/2021/02/05/shua-ti/shu-ju-jie-gou/shu/307-range-sum-query-mutable/index.html","hash":"9487b96afb8c074c3ae7666b5f33e436f9a876d2","modified":1621101838941},{"_id":"public/2021/02/05/shua-ti-tan-xin-870-advantage-shuffle/index.html","hash":"f2b210631b7e8789cd804e2e5c4b7727f5148b10","modified":1621101838941},{"_id":"public/2021/02/05/shua-ti-shu-xue-313-super-ugly-number/index.html","hash":"9790ca8f18e80ccddfe98688acb37baa5ea2c687","modified":1621101838941},{"_id":"public/2021/02/05/shua-ti/shuang-zhi-zhen/287-find-the-duplicate-number/index.html","hash":"cbe516682ffa4bd49c1d7e436969b3a35f7276e8","modified":1621101838941},{"_id":"public/2021/01/30/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/225-implement-stack-using-queues/index.html","hash":"c172d1eb93e502d3105128b3d25d322dad1c8dab","modified":1621101838941},{"_id":"public/2021/01/30/shua-ti/qi-ta/566-reshape-the-matrix/index.html","hash":"ab9b13d6170a05c145050ad40a169af371528d31","modified":1621101838941},{"_id":"public/2021/01/30/shua-ti/dp/594-longest-harmonious-subsequence/index.html","hash":"faa6adb68571f52d9d8d680791b0febe2c7ce407","modified":1621101838941},{"_id":"public/2021/01/30/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/503-next-greater-element-ii/index.html","hash":"ea382939e1845f8284f706082569373997c4ff5a","modified":1621101838941},{"_id":"public/2021/01/29/shua-ti/qi-ta/560-subarray-sum-equals-k/index.html","hash":"3463a24ae61cfcd153eb86ed30896117399cf8d2","modified":1621101838941},{"_id":"public/2021/01/29/shua-ti/qi-ta/304-range-sum-query-2d-immutable/index.html","hash":"8c8b561620547581372ece213b369fe0096f08bc","modified":1621101838941},{"_id":"public/2021/01/29/shua-ti/qi-ta/303-range-sum-query-immutable/index.html","hash":"1a30abede02d7906c93b459cfad48e954490fc6e","modified":1621101838941},{"_id":"public/2021/01/28/shua-ti-sou-suo-er-fen-81-search-in-rotated-sorted-array-ii/index.html","hash":"fe51b49281d3b6ac973687cb595aad794dfdcb71","modified":1621101838941},{"_id":"public/2021/01/28/shua-ti-shu-ju-jie-gou-tu-332-reconstruct-itinerary/index.html","hash":"c1c0c53ece32be20bce237749be601031730abbf","modified":1621101838941},{"_id":"public/2021/01/27/shua-ti/shu-ju-jie-gou/ha-xi/149-max-points-on-a-line/index.html","hash":"971b5482c0e6912ee5899b9f24f17ad713a252e4","modified":1621101838941},{"_id":"public/2021/01/26/shua-ti-qi-ta-sao-miao-xian-218-the-skyline-problem/index.html","hash":"3f4430e4d5524fa89158c069bf34d675bcdeb140","modified":1621101838941},{"_id":"public/2021/01/25/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/239-sliding-window-maximum/index.html","hash":"9ec57222ad64e1de5d2e55891de6ecd14999af6a","modified":1621101838941},{"_id":"public/2021/01/25/shua-ti-shu-ju-jie-gou-set-1-two-sum/index.html","hash":"91ac5c3300f79436fc004a442e58a7299d3c1041","modified":1621101838941},{"_id":"public/2021/01/25/shua-ti-shu-ju-jie-gou-set-128-longest-consecutive-sequence/index.html","hash":"e513a641abf905a7b474f1cddd14b2ca76d4cc57","modified":1621101838941},{"_id":"public/2021/01/24/shua-ti-shu-ju-jie-gou-you-xian-dui-lie-23-merge-k-sorted-lists/index.html","hash":"17b3a89617934a6be2272be9eef845285e202f26","modified":1621101838941},{"_id":"public/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/232-implement-queue-using-stacks/index.html","hash":"0ba4271b565f305934403195462cffafb7692fef","modified":1621101838941},{"_id":"public/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/20-valid-parentheses/index.html","hash":"6b95a4472faedba4d06f82c0e25664547bf7d236","modified":1621101838941},{"_id":"public/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/155-min-stack/index.html","hash":"70b437337a31c31c5a2e83fd1fd3c9f149d46169","modified":1621101838941},{"_id":"public/2021/01/23/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-739-daily-temperatures/index.html","hash":"c3b3c31e48b18e6255c96e5e2a912784c0f78b8e","modified":1621101838941},{"_id":"public/2021/01/22/shua-ti/qi-ta/448-find-all-numbers-disappeared-in-an-array/index.html","hash":"bd39f874f6784bb11e15fa3bf97495d2bb45ba32","modified":1621101838941},{"_id":"public/2021/01/22/shua-ti/qi-ta/240-search-a-2d-matrix-ii/index.html","hash":"df45cdd1f02cb0de57de2f86d1dcbedeb821b646","modified":1621101838941},{"_id":"public/2021/01/22/shua-ti/qi-ta/769-max-chunks-to-make-sorted/index.html","hash":"7416a2c069a8d9e7403f67ab58e8f0edeb2955fd","modified":1621101838941},{"_id":"public/2021/01/22/shua-ti/qi-ta/48-rotate-image/index.html","hash":"dc1078e6bca5c06b3cc982dee5d56986390ba894","modified":1621101838941},{"_id":"public/2021/01/19/shua-ti-wei-yun-suan-260-single-number-iii/index.html","hash":"f130256b78567ac4463bf9c05087ff5afd117761","modified":1621101838941},{"_id":"public/2021/01/19/shua-ti-wei-yun-suan-268-missing-number/index.html","hash":"e08e8904db5fca51e394cbe8303aa09b2e83d1ba","modified":1621101838941},{"_id":"public/2021/01/19/shua-ti-wei-yun-suan-693-binary-number-with-alternating-bits/index.html","hash":"a67f5376ac34d81d2b72105d841f38a17056a733","modified":1621101838941},{"_id":"public/2021/01/19/shua-ti-wei-yun-suan-476-number-complement/index.html","hash":"9d7214aacbbd0aefea6acd1c17c39fa24dc2875b","modified":1621101838941},{"_id":"public/2021/01/19/shua-ti-wei-yun-suan-338-counting-bits/index.html","hash":"035c6d6d01094d53598d5e814e212d6964fa9ab6","modified":1621101838941},{"_id":"public/2021/01/17/shua-ti-wei-yun-suan-136-single-number/index.html","hash":"4687ceb67039d0339c32d86d9733a67f036810c4","modified":1621101838941},{"_id":"public/2021/01/17/shua-ti-wei-yun-suan-461-hamming-distance/index.html","hash":"f8888947cadd1ae42f724e586dafd8b6e5aa4e06","modified":1621101838941},{"_id":"public/2021/01/17/shua-ti-wei-yun-suan-342-power-of-four/index.html","hash":"7ca241ffab9e59569379adfe1f620751266167ed","modified":1621101838941},{"_id":"public/2021/01/17/shua-ti-wei-yun-suan-318-maximum-product-of-word-lengths/index.html","hash":"c249fcad33cc737e71a0a8aecb9b410ebc7c31de","modified":1621101838941},{"_id":"public/2021/01/17/shua-ti-wei-yun-suan-190-reverse-bits/index.html","hash":"cd1c8b1770ca5c311c9e42c34e8cb53e13a73144","modified":1621101838941},{"_id":"public/2021/01/15/shua-ti-shu-xue-470-implement-rand10-using-rand7/index.html","hash":"0cdd93275d465b25f50e2018df03c72b0495d36f","modified":1621101838941},{"_id":"public/2021/01/15/shua-ti-shu-xue-169-majority-element/index.html","hash":"6f1126964f0499e0e65eba748d609bd4bbb59866","modified":1621101838941},{"_id":"public/2021/01/15/shua-ti-shu-xue-202-happy-number/index.html","hash":"f4d570e487089cafed465f351a01c7e5881c8926","modified":1621101838941},{"_id":"public/2021/01/14/shua-ti-shu-xue-462-minimum-moves-to-equal-array-elements-ii/index.html","hash":"fcb432932030d99a72195ad25bd0b2fb1654a0d8","modified":1621101838941},{"_id":"public/2021/01/12/shua-ti-shu-xue-238-product-of-array-except-self/index.html","hash":"b63345928431d09f6e852164e4c892baa5cc4595","modified":1621101838941},{"_id":"public/2021/01/12/shua-ti-shu-xue-67-add-binary/index.html","hash":"3552fbe305e5a4d8fef246c36dc8312ff1b3a033","modified":1621101838941},{"_id":"public/2021/01/12/shua-ti-shu-xue-168-excel-sheet-column-title/index.html","hash":"ab6c6f45b78c7cd50a0aa4e27677b2bf320fc0f5","modified":1621101838941},{"_id":"public/2021/01/10/shua-ti-shu-xue-528-random-pick-with-weight/index.html","hash":"8847dd3dcc88e48bc845951e2eb644956af8848e","modified":1621101838941},{"_id":"public/2021/01/10/shua-ti-shu-xue-382-linked-list-random-node/index.html","hash":"34f5fe12a9a3be3e6d798f660cf23dba0e889dbf","modified":1621101838941},{"_id":"public/2021/01/09/shua-ti-shu-xue-384-shuffle-an-array/index.html","hash":"7532300be2ef65f40d16dbe0c6eb5094c9c09fed","modified":1621101838941},{"_id":"public/2021/01/08/shua-ti/qi-ta/326-power-of-three/index.html","hash":"09678fb279cde33f0970b2007ce9966add8bec52","modified":1621101838941},{"_id":"public/2021/01/07/shua-ti-shu-xue-415-add-strings/index.html","hash":"22b92eb33542e7d0e0eae8352a66c0dd8af647f3","modified":1621101838941},{"_id":"public/2021/01/07/shua-ti-shu-xue-172-factorial-trailing-zeroes/index.html","hash":"af103b635d0f1afd7fe153bf967a11bcb5cdea84","modified":1621101838941},{"_id":"public/2021/01/07/shua-ti-shu-xue-504-base-7/index.html","hash":"7b6ea35aa1720e496eec50e05b133fff61916682","modified":1621101838941},{"_id":"public/2021/01/07/shua-ti-shu-xue-204-count-primes/index.html","hash":"3fad625c76684235fc16b80690627049b539ee92","modified":1621101838941},{"_id":"public/2021/01/07/shua-ti-sou-suo-dfs-547-number-of-provinces/index.html","hash":"99a1e1680863aa46675cbdaef580a75c3464de08","modified":1621101838941},{"_id":"public/2021/01/04/shua-ti-fen-zhi-932-beautiful-array/index.html","hash":"679a4edb45728232d7c6c91d8e4e5983c5703746","modified":1621101838941},{"_id":"public/2021/01/02/shua-ti-fen-zhi-241-different-ways-to-add-parentheses/index.html","hash":"f10dd2d1b564d8f84f709d637b8dec107d750156","modified":1621101838941},{"_id":"public/2020/12/31/shua-ti/dp/494-target-sum/index.html","hash":"e9d9d4c51c54eacb4feb5c6cb726fa9295d44efb","modified":1621101838941},{"_id":"public/2020/12/31/shua-ti/dp/376-wiggle-subsequence/index.html","hash":"8edb615b74ba2f3f827dd5f48c4d2b4bc0efe7b4","modified":1621101838941},{"_id":"public/2020/12/29/shua-ti/dp/343-integer-break/index.html","hash":"a20ca2d1b38995c902763e6899971e98ea37cd60","modified":1621101838941},{"_id":"public/2020/12/29/shua-ti/dp/583-delete-operation-for-two-strings/index.html","hash":"cac2ff947523f8c314e512df8f8603ae7e1f89b6","modified":1621101838941},{"_id":"public/2020/12/28/shua-ti/dp/213-house-robber-ii/index.html","hash":"27b95279429c08c907623591b5ea386fa7a59f15","modified":1621101838941},{"_id":"public/2020/12/28/shua-ti/dp/53-maximum-subarray/index.html","hash":"75f3fc69aa7a178111a5305f1d067e5cd88b56c1","modified":1621101838941},{"_id":"public/2020/12/26/shua-ti/dp/714-best-time-to-buy-and-sell-stock-with-transaction-fee/index.html","hash":"eff41276c2122f3a815e28ef5dd5855dced84460","modified":1621101838941},{"_id":"public/2020/12/26/shua-ti/dp/309-best-time-to-buy-and-sell-stock-with-cooldown/index.html","hash":"a75c3c8ba411d3aaac00461e07486029be2a8148","modified":1621101838941},{"_id":"public/2020/12/25/shua-ti/dp/188-best-time-to-buy-and-sell-stock-iv/index.html","hash":"28e511e36fb75dee2048245b2f0e2a034d30d779","modified":1621101838941},{"_id":"public/2020/12/25/shua-ti/dp/123-best-time-to-buy-and-sell-stock-iii/index.html","hash":"7016a36d92cdb475944b9e327a7d46308da7b9dd","modified":1621101838941},{"_id":"public/2020/12/23/shua-ti/dp/10-regular-expression-matching/index.html","hash":"f63d5084981914d7524b77d298c4cb1b7c7478dc","modified":1621101838941},{"_id":"public/2020/12/23/shua-ti/dp/121-best-time-to-buy-and-sell-stock/index.html","hash":"f00834673d7db51a19c7327e4e150ab6336ed096","modified":1621101838941},{"_id":"public/2020/12/21/shua-ti/dp/650-2-keys-keyboard/index.html","hash":"2e39304aba185c11560e0293747cc0ef0fb63227","modified":1621101838941},{"_id":"public/2020/12/21/shua-ti/dp/72-edit-distance/index.html","hash":"adb24bdfbca5f90d161fc13ec3d5553634b05235","modified":1621101838941},{"_id":"public/2020/12/18/shua-ti/dp/322-coin-change/index.html","hash":"a4f36aa5ae1b8a736a7514762dc6ff169fbfd5a3","modified":1621101838941},{"_id":"public/2020/12/18/shua-ti/dp/474-ones-and-zeroes/index.html","hash":"661e961ddebe9d9c23d7f9129b7e519cbd754c71","modified":1621101838941},{"_id":"public/2020/12/16/shua-ti/dp/416-partition-equal-subset-sum/index.html","hash":"52a69f7cc5b2524c95e468248a40ada51aa9ed6b","modified":1621101838941},{"_id":"public/2020/12/15/shua-ti/qi-ta/1143-longest-common-subsequence/index.html","hash":"dbb9182404bc1c4b6d6a6485a91de0a4c7cf6857","modified":1621101838941},{"_id":"public/2020/12/13/shua-ti/dp/139-word-break/index.html","hash":"51319a02fc891a74ddfcd53777d9b610d8356f1b","modified":1621101838941},{"_id":"public/2020/12/13/shua-ti/dp/300-longest-increasing-subsequence/index.html","hash":"c9aa88104deecb890af11df2333182e177b3bcc8","modified":1621101838941},{"_id":"public/2020/12/11/shua-ti/dp/91-decode-ways/index.html","hash":"08ca60a7837b78c4e37334b02b0fff9eb15138b5","modified":1621101838941},{"_id":"public/2020/12/10/shua-ti/dp/279-perfect-squares/index.html","hash":"9162419c49395621b4bdd3c74e57369cb2e22e48","modified":1621101838941},{"_id":"public/2020/12/09/shua-ti/dp/221-maximal-square/index.html","hash":"ba077a1bc3612dc96548031f8bea2c6ee8ec19b2","modified":1621101838941},{"_id":"public/2020/12/08/shua-ti/dp/64-minimum-path-sum/index.html","hash":"b1b617f9de80f044f658fdd271136e899d5e55f3","modified":1621101838941},{"_id":"public/2020/12/08/shua-ti/dp/542-01-matrix/index.html","hash":"d80d4968b401b1908489e9b166ccc5d28424873c","modified":1621101838941},{"_id":"public/2020/12/07/shua-ti/dp/413-arithmetic-slices-2-shua/index.html","hash":"5640ef8cfe6884da0ce6e659f8bbcde57d0f4111","modified":1621101838941},{"_id":"public/2020/12/07/shua-ti/dp/70-climbing-stairs/index.html","hash":"34202f3db70c0395b126da79669c2a1ba6970541","modified":1621101838941},{"_id":"public/2020/12/07/shua-ti/dp/198-house-robber/index.html","hash":"d5f2e337a17e7739de88e6f4af1eaf5d578553aa","modified":1621101838941},{"_id":"public/2020/12/06/shua-ti/shu-ju-jie-gou/shu/310-minimum-height-trees/index.html","hash":"7e8cde81dfdbbe88632d5a7dbcdca5ea2d78921d","modified":1621101838941},{"_id":"public/2020/12/05/shua-ti-sou-suo-hui-su-37-sudoku-solver/index.html","hash":"f6ff1ca4c213150f89cd669ab1fa42c9fef94a63","modified":1621101838941},{"_id":"public/2020/12/04/shua-ti-sou-suo-hui-su-40-combination-sum-ii/index.html","hash":"1c136325bf973fcd6cdde3cb300e47d3b708589d","modified":1621101838941},{"_id":"public/2020/12/04/shua-ti-sou-suo-hui-su-39-combination-sum/index.html","hash":"730042dde615333700353e3ebc4132926fa7a6e3","modified":1621101838941},{"_id":"public/2020/12/03/shua-ti-sou-suo-hui-su-47-permutations-ii/index.html","hash":"0cdcf1fab29ffd97a6f83820c3e7c4ee310126cb","modified":1621101838941},{"_id":"public/2020/12/01/shua-ti-sou-suo-dfs-130-surrounded-regions/index.html","hash":"9fde69fcf83f97bde43b632bce1fd30ad5a23b1f","modified":1621101838941},{"_id":"public/2020/11/29/shua-ti-sou-suo-bfs-126-word-ladder-ii/index.html","hash":"8f51813bb322237719154e70611b903e867cb73c","modified":1621101838941},{"_id":"public/2020/11/28/sui-tan/da-shu-ju-chan-pin-si-kao-di-qiu-bao-wei-zhe/index.html","hash":"cafe9dc62469e4007587a500c988ed55932549cd","modified":1621101838941},{"_id":"public/2020/11/28/shua-ti/qi-ta/934-shortest-bridge/index.html","hash":"387ca0fc0252d51dda0316bac9408544c513bdc6","modified":1621101838941},{"_id":"public/2020/11/27/shua-ti-sou-suo-hui-su-51-n-queens/index.html","hash":"3f6236d85f2037d015123890cfb185e09692ff39","modified":1621101838941},{"_id":"public/2020/11/26/shua-ti/qi-ta/79-word-search/index.html","hash":"38ae74925fa0dc8aa610c047cb7d18d9330e8437","modified":1621101838941},{"_id":"public/2020/11/25/sui-tan/you-xiu-shi-hui-yi-chuan-de-ba/index.html","hash":"ac289dd094d82b88c8eecfbb60507c7e7a03f377","modified":1621101838941},{"_id":"public/2020/11/25/shua-ti-sou-suo-hui-su-77-combinations/index.html","hash":"7c81f3f93821c4bed5aa458b0614905845f28103","modified":1621101838941},{"_id":"public/2020/11/24/shua-ti-sou-suo-hui-su-46-permutations/index.html","hash":"5b817f66eb9d36c0044405a7fdeae21460cb0a0c","modified":1621101838941},{"_id":"public/2020/11/24/shua-ti-sou-suo-dfs-417-pacific-atlantic-water-flow/index.html","hash":"2c98eaefd8f076af1183625bb4db122e1048dac0","modified":1621101838941},{"_id":"public/2020/11/22/shua-ti-sou-suo-dfs-547-friend-circles/index.html","hash":"d37feea445b56d20ba1245308bc809bb0c752ab5","modified":1621101838941},{"_id":"public/2020/11/19/shua-ti-sou-suo-dfs-695-max-area-of-island/index.html","hash":"f27e7cf684027d7d4a65ac6625088e8d0c1520b2","modified":1621101838941},{"_id":"public/2020/11/17/shua-ti-sou-suo-er-fen-75-sort-colors/index.html","hash":"ded77732a85094a2198e95ef912e051ed5bd9afa","modified":1621101838941},{"_id":"public/2020/11/16/shua-ti-pai-xu-451-sort-characters-by-frequency/index.html","hash":"8c57e9795f47a8c9ddd5369b1c5d60c6edcbca3d","modified":1621101838941},{"_id":"public/2020/11/15/shua-ti-shu-ju-jie-gou-dui-347-top-k-frequent-elements/index.html","hash":"990bc21a35f3c3521fd5cd1547746894d80fb779","modified":1621101838941},{"_id":"public/2020/11/14/shua-ti-pai-xu-215-kth-largest-element-in-an-array/index.html","hash":"fc9be612f559012a48b323d600c07695bda25e2f","modified":1621101838941},{"_id":"public/2020/11/12/shua-ti-sou-suo-er-fen-4-median-of-two-sorted-arrays/index.html","hash":"328b4d27aa6c7490c861161b4f0e364b37a3fdc9","modified":1621101838941},{"_id":"public/2020/11/09/shua-ti/qi-ta/540-single-element-in-a-sorted-array/index.html","hash":"d78cc7fb2ee0ca7f6d6627406d73302c4a0169c6","modified":1621101838941},{"_id":"public/2020/11/01/shua-ti-sou-suo-er-fen-154-find-minimum-in-rotated-sorted-array-ii/index.html","hash":"fc5c216728938458bb91d310c1d4e1a5c32f8387","modified":1621101838941},{"_id":"public/2020/10/30/shua-ti-sou-suo-er-fen-2020-10-30-81-search-in-rotated-sorted-array-ii/index.html","hash":"01159a23c78f60bd4d6f4ee9c982c21796e4e157","modified":1621101838941},{"_id":"public/2020/10/28/shua-ti-sou-suo-er-fen-34-find-first-and-last-position-of-element-in-sorted-array/index.html","hash":"6732377bbb9983cacbf919da46839e56ca8c408a","modified":1621101838941},{"_id":"public/2020/10/27/shua-ti-sou-suo-er-fen-69-sqrt-x/index.html","hash":"fc024d6bd9100803eafe0cde8f2ac43ebbffaa99","modified":1621101838941},{"_id":"public/2020/10/26/shua-ti/shuang-zhi-zhen/680-valid-palindrome-ii/index.html","hash":"4b5ad33b4dd9cf47260ce1b1178ec33d024c2ca9","modified":1621101838941},{"_id":"public/2020/10/24/shua-ti/shuang-zhi-zhen/633-sum-of-square-numbers/index.html","hash":"0555eb6a2461b2388a63525760f4c11430ed80d0","modified":1621101838941},{"_id":"public/2020/10/23/shua-ti/shuang-zhi-zhen/76-minimum-window-substring/index.html","hash":"aa2fa79de92fd709c9fb1af6fe37bc5d75d3bd12","modified":1621101838941},{"_id":"public/2020/10/22/shua-ti/qi-ta/524-longest-word-in-dictionary-through-deleting/index.html","hash":"10d764f06e6770731cb695fb4b71e88ab734a1f1","modified":1621101838941},{"_id":"public/2020/10/19/shua-ti/shuang-zhi-zhen/142-linked-list-cycle-ii/index.html","hash":"c44666c07ae852533f2396538de2539a9889eede","modified":1621101838941},{"_id":"public/2020/10/18/shua-ti/shu-ju-jie-gou/shu/1609-even-odd-tree/index.html","hash":"7425b6f7413d04786a2fbca26f5047e5bc476709","modified":1621101838941},{"_id":"public/2020/10/18/shua-ti/dp/p1025-shu-de-hua-fen/index.html","hash":"24434841bddb2560b8ad7e62f255b300d41d9392","modified":1621101838941},{"_id":"public/2020/10/17/shua-ti/qi-ta/88-merge-sorted-array/index.html","hash":"dd8674532b0dc324e4f0fd8baa0a00e1a71dd540","modified":1621101838941},{"_id":"public/2020/10/17/shua-ti/shuang-zhi-zhen/167-two-sum-ii-input-array-is-sorted/index.html","hash":"3ab5d67e94914383b357b8dd82a86d2479105dbc","modified":1621101838941},{"_id":"public/2020/10/16/shua-ti-tan-xin-665-non-decreasing-array/index.html","hash":"b76272d4709c4e1f0c13f728a5bcf9fbae695d57","modified":1621101838941},{"_id":"public/2020/10/15/shua-ti/qi-ta/406-queue-reconstruction-by-height/index.html","hash":"820f9a2c1631a9ca3dd3a50ed091f7cef26411cf","modified":1621101838941},{"_id":"public/2020/10/15/shua-ti/qi-ta/122-best-time-to-buy-and-sell-stock-ii/index.html","hash":"5e1d91895cb49af30ae27139d9901960e6c96748","modified":1621101838941},{"_id":"public/2020/10/14/shua-ti-tan-xin-763-partition-labels/index.html","hash":"05955bba1fd4119b9dd11050a64db5569d5d1d85","modified":1621101838941},{"_id":"public/2020/10/13/shua-ti/qi-ta/605-can-place-flowers/index.html","hash":"9b49a2bcaacd58a2a8a6de5375e457f177100f2c","modified":1621101838941},{"_id":"public/2020/10/13/shua-ti-tan-xin-452-minimum-number-of-arrows-to-burst-balloons/index.html","hash":"9bd59d9218df3e34e9663e72da44eef3323f599c","modified":1621101838941},{"_id":"public/2020/10/12/shua-ti-tan-xin-435-non-overlapping-intervals/index.html","hash":"0a756710f640b75725cf0a1562ff4201408d99e8","modified":1621101838941},{"_id":"public/2020/10/11/shua-ti/qi-ta/697-degree-of-an-array/index.html","hash":"f39571a5ee624c0784d4b87c11a8a2f92fbe22c4","modified":1621101838941},{"_id":"public/2020/10/10/shua-ti-sou-suo-ji-yi-hua-sou-suo-135-candy/index.html","hash":"c908a5a53b14a95adddb61612917020fab5c2635","modified":1621101838941},{"_id":"public/2020/10/09/shua-ti-tan-xin-455-assign-cookies/index.html","hash":"d6fab6c1ea247d1ead8b6c113f9973e4b1a6f08d","modified":1621101838941},{"_id":"public/2020/10/08/shua-ti-wei-yun-suan-1286-iterator-for-combination/index.html","hash":"e5b2213a1cd03837e0d4496509c5a320d04dc71c","modified":1621101838941},{"_id":"public/2020/10/07/shua-ti/dp/790-domino-and-tromino-tiling/index.html","hash":"8a3ed1cd64dcb3a7b0492854588641097498a376","modified":1621101838941},{"_id":"public/2020/10/05/shua-ti-sou-suo-ji-yi-hua-sou-suo-1340-jump-game-v/index.html","hash":"336f77e44158ad062152c339aee83e568f6968ac","modified":1621101838941},{"_id":"public/2020/09/28/shua-ti/dp/413-arithmetic-slices/index.html","hash":"d68f3c209e34231d7f3058548d03ee971994ea35","modified":1621101838941},{"_id":"public/2020/09/27/shua-ti/dp/1411-number-of-ways-to-paint-n-x-3-grid/index.html","hash":"a7d37367c4d6100ef1c4b3a456c23271a5e482b8","modified":1621101838941},{"_id":"public/2020/09/27/shua-ti/shu-ju-jie-gou/shu/235-lowest-common-ancestor-of-a-binary-search-tree/index.html","hash":"11ff84912c1f65a9d58a740f7d3f567256d77e6c","modified":1621101838941},{"_id":"public/2020/09/25/shua-ti/qi-ta/341-flatten-nested-list-iterator/index.html","hash":"faa90e7438f21f47d48e47083a371438b01815f6","modified":1621101838941},{"_id":"public/2020/09/25/shua-ti/shu-ju-jie-gou/shu/106-construct-binary-tree-from-inorder-and-postorder-traversal/index.html","hash":"1dbbfff0eef5f00ef4bc8ed511086a2e68bbd2e4","modified":1621101838941},{"_id":"public/2020/09/24/shua-ti-shu-xue-mian-shi-ti-16-05-factorial-zeros-lcci/index.html","hash":"72af395beab83d3bbd811b0082142af566150b98","modified":1621101838941},{"_id":"public/2020/09/24/shua-ti/qi-ta/747-largest-number-at-least-twice-of-others/index.html","hash":"f701d4e88b56709914c5dc3552883ec025701d34","modified":1621101838941},{"_id":"public/2020/09/23/shua-ti/dp/1289-minimum-falling-path-sum2/index.html","hash":"240c32d95ff032fc2ae9cf3a518463cd6ee36075","modified":1621101838941},{"_id":"public/2020/09/21/shua-ti-shu-xue-972-equal-rational-numbers/index.html","hash":"429d77a64fce8975161b4dca2d11ffe93a285861","modified":1621101838941},{"_id":"public/2020/09/17/shua-ti-sou-suo-hui-su-37-jie-shu-du/index.html","hash":"f5b4e6d4ed5cf2073d91624ce47a4b82e40bc378","modified":1621101838941},{"_id":"public/2020/08/11/shua-ti-shu-xue-mian-shi-ti-jian-mo/index.html","hash":"c33dabc740f19556f8de034a815686762ef1d46e","modified":1621101838941},{"_id":"public/2020/08/11/shua-ti-mo-ni-mian-shi-ti-jian-mo/index.html","hash":"f7f8dcaf14e403be37c238b0709c9eb894a55d9d","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/15-3sum/index.html","hash":"842f1557e4b085313d74afa2d9ddf08978a1d2c9","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/1190-reverse-substrings-between-each-pair-of-parentheses/index.html","hash":"baefbdcdcce0e38c73167f469e76d8c591aef372","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/dp/mian-shi-ti-dp-tan-xin/index.html","hash":"b64ac899abde730a93bd3bbca1a756e98d0336ab","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-tan-xin-mian-shi-ti-dp-tan-xin/index.html","hash":"419db176563e3373fac2ca4aa8d2a0314e53e5e3","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/1025-chu-shu-bo-yi/index.html","hash":"06f04958f41b98d4429c328f3ab6cd26171dea42","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/786-di-k-ge-zui-xiao-de-su-shu-fen-shu/index.html","hash":"36888aea7328fae1c52d9f58095c6755f40dc598","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/1027-zui-chang-deng-chai-shu-lie/index.html","hash":"70a875404e73801f65be107c78ca5ac245b9b8b8","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/1254-number-of-closed-islands/index.html","hash":"964ef95d1a80df87748354fd89452dc97f428a25","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/833-zi-fu-chuan-zhong-de-cha-zhao-yu-ti-huan/index.html","hash":"d8eadbf69fb389c76dc421acd70f001bbe63f04f","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-sou-suo-er-fen-mian-shi-ti-53-ii-0-n-1-zhong-que-shi-de-shu-zi/index.html","hash":"15a96405a47009937539062c63353544e06195fc","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/shu-ju-jie-gou/shu/654-zui-da-er-cha-shu/index.html","hash":"13454c7c60ebe06d483b87371ebe7bc46fc93002","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-mo-ni-mian-5-he-bing-shu-zu/index.html","hash":"2ddd4c8da5a6daeb25c7e1822913b9f6a0755f03","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-shu-ju-jie-gou-lian-biao-mian-shi-ti-lian-biao-xiang-guan/index.html","hash":"5a97d7d1562148f228b56bbabeaece5343b57935","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/mian-shi-ti-zhan-he-dui-lie/index.html","hash":"1c7f93d46fbbf06205ca46cb42c1fb34382ea7e9","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/mian-shi-ti-di-gui-die-dai/index.html","hash":"9aecc781ac10f966ba5105386bcafab7d086ba93","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-sou-suo-er-fen-mian-shi-ti-er-fen/index.html","hash":"8d50b4ca6d4cce3a1a311a6885b5f1b6b9f8651e","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-sou-suo-hui-su-mian-shi-ti-hui-su-dfs/index.html","hash":"87e3becb28efe0e454bab9d5f6179e36aaa7d1a4","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-wei-yun-suan-mian-shi-ti-wei-yun-suan/index.html","hash":"6d8aca4bd563dd5500f69c660e0190e5325a45d1","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-qi-ta-code-neng-li-dai-ma-gui-fan-bian-cheng-wan-zheng-xing/index.html","hash":"b10f5272f29428f3f4dd4fdad3a9c76a7c878a8b","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-shu-xue-mian-shi-ti-da-shu/index.html","hash":"249d1d63f9c48d9b451b74723f981499fcd45993","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/mian-16-shu-zhi-de-n-ci-fang/index.html","hash":"c92506cea9dd02b80f9631b84c3cba6a38014774","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-shu-xue-mian-16-shu-zhi-de-n-ci-fang/index.html","hash":"4756bdbec36a6051cd1f5cb434e25ae02e5b45da","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/shu-ju-jie-gou/shu/mian-shi-ti-er-cha-shu/index.html","hash":"1fc9b3751ec671cc740f1f3a087100bd28758d2f","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/mian-shi-ti-44-1-chu-xian-de-ge-shu/index.html","hash":"a98b31aa7275a71c8c0cf138005102bc8103e550","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-shu-xue-mian-shi-ti-44-1-chu-xian-de-ge-shu/index.html","hash":"f736cebe52dad2b202e9395e86a64ea7c7599570","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/qi-ta/mian-shi-ti-49-chou-shu/index.html","hash":"acae1164fe9d28fd551525569913c42d15d722a2","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-shu-xue-mian-shi-ti-49-chou-shu/index.html","hash":"d04ad930507a0845e31edeb3a34bd8f3403789c3","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-mo-ni-mian-shi-mo-ni-ti/index.html","hash":"fa3bd7984890cb599ef55135f6bc59bce9d10d87","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-pai-xu-mian-shi-ti-51-ni-xu-shu/index.html","hash":"62a553df7a1e71658df4f772df3f10e46ccb61a3","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti-qi-ta-code-neng-li-gou-tong-neng-li-mian-shi-su-zhi/index.html","hash":"475725694ba425f71977848183de0560b2badde2","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/shu-ju-jie-gou/shu/pat-1043-er-cha-shu-chong-jian/index.html","hash":"8817066a8c5c863a534464bb9a1ee69a8f23c89c","modified":1621101838941},{"_id":"public/2020/08/07/shua-ti/shu-ju-jie-gou/shu/pat-feng-ge-er-cha-shu-zong-jie/index.html","hash":"c946612d1caa5015fbe51c1126208f7a6008ede1","modified":1621101838941},{"_id":"public/archives/index.html","hash":"efed099d3b1f5e871506a9caffdb6359f6e76d98","modified":1621101838941},{"_id":"public/archives/page/2/index.html","hash":"781be70b6cfb540ad1c344bef56330b87edcca85","modified":1621101838941},{"_id":"public/archives/page/3/index.html","hash":"350478820ac1e5d6b88f5fd81950c654e7807218","modified":1621101838941},{"_id":"public/archives/page/4/index.html","hash":"0155499b8587efcb3295c00cd660cc9f2dc055cd","modified":1621101838941},{"_id":"public/archives/page/5/index.html","hash":"fa36be2e97b269833f528c71e546dabdd7e0ce57","modified":1621101838941},{"_id":"public/archives/page/6/index.html","hash":"ec3e23cc5c0695f748b361b05b5702ab9558d3ec","modified":1621101838941},{"_id":"public/archives/page/7/index.html","hash":"1ae2e7736831386b75fa53218614987b41e6aaea","modified":1621101838941},{"_id":"public/archives/page/8/index.html","hash":"79ba528c8fe2f79ee4d8940e3300713cfa00e9bb","modified":1621101838941},{"_id":"public/archives/page/9/index.html","hash":"b59a5c12e193b22c43bfeae8fea0c135b4ee00c4","modified":1621101838941},{"_id":"public/archives/page/10/index.html","hash":"3feb4f70172e050b2905e9feb47c836d31306241","modified":1621101838941},{"_id":"public/archives/page/11/index.html","hash":"be67b92212a52e61e9826569fc2100a884117814","modified":1621101838941},{"_id":"public/archives/2020/index.html","hash":"76a38a773f4ebcc9684119d5001b1e5c08bbe496","modified":1621101838941},{"_id":"public/archives/2020/page/2/index.html","hash":"5f407ec905f2473888c749facbea03508cc99d1f","modified":1621101838941},{"_id":"public/archives/2020/page/3/index.html","hash":"b7a64c23a56329419b4d9e0b18f82cabb3a40773","modified":1621101838941},{"_id":"public/archives/2020/page/4/index.html","hash":"d9ec4affd05ce9bedc4a25200a3c5634527ba9b1","modified":1621101838941},{"_id":"public/archives/2020/page/5/index.html","hash":"5f9c9d2b0d0be38da365ebd50c51dd0bef1a1340","modified":1621101838941},{"_id":"public/archives/2020/page/6/index.html","hash":"b172d56920ee10be3c12e0f419c0d008875a60cd","modified":1621101838941},{"_id":"public/archives/2020/page/7/index.html","hash":"7a6381e8f375dffd6030e41c0405811088fa6c11","modified":1621101838941},{"_id":"public/archives/2020/08/index.html","hash":"9defae17fd2287af19e10c90280d75bf1c857e73","modified":1621101838941},{"_id":"public/archives/2020/08/page/2/index.html","hash":"9b2b90c8579d271ae0febb18f17834e5215bffa0","modified":1621101838941},{"_id":"public/archives/2020/09/index.html","hash":"d3e0c6f71f3e072f6cdd34268440c2891d048d93","modified":1621101838941},{"_id":"public/archives/2020/10/index.html","hash":"1580483a09e44314fba2dcc23dbb2db5be1642d5","modified":1621101838941},{"_id":"public/archives/2020/10/page/2/index.html","hash":"85771ecbe0a30f2379bf652c139a9a7cd83c8ae6","modified":1621101838941},{"_id":"public/archives/2020/11/index.html","hash":"75adc00e5f3f90272ec05eb77c65b24d74063f7f","modified":1621101838941},{"_id":"public/archives/2020/12/index.html","hash":"31dc28732b0db0aacd0daa94b50d2291e1b188f7","modified":1621101838941},{"_id":"public/archives/2020/12/page/2/index.html","hash":"20787a8f14ae9bf61fe46c3836984c6e89546224","modified":1621101838941},{"_id":"public/archives/2021/index.html","hash":"f4b57b36cd4c57c12ae0dfabcc3ac7371de0718f","modified":1621101838941},{"_id":"public/archives/2021/page/2/index.html","hash":"c31cb419fc7ed541ed676670a86cec82ec15c942","modified":1621101838941},{"_id":"public/archives/2021/page/3/index.html","hash":"400c45b3462ae9dd976dbbd275d87aa5371fb2c5","modified":1621101838941},{"_id":"public/archives/2021/page/4/index.html","hash":"88b4aa587faef349bd0021baaf85e586e4c27098","modified":1621101838941},{"_id":"public/archives/2021/page/5/index.html","hash":"0cf2797b4384a875192e8048a91ca4530e6a48cb","modified":1621101838941},{"_id":"public/archives/2021/01/index.html","hash":"43de81c64ce06e2fbbd6bc60a47a1021d86c43a7","modified":1621101838941},{"_id":"public/archives/2021/01/page/2/index.html","hash":"10c364a1df57a0b2676a611f5675e0f998c91529","modified":1621101838941},{"_id":"public/archives/2021/01/page/3/index.html","hash":"41f13cfa80314e03eed6ef312bc358d2968306d7","modified":1621101838941},{"_id":"public/archives/2021/02/index.html","hash":"16578bbbf6132117a310f24ae84dd52c1d8cc055","modified":1621101838941},{"_id":"public/archives/2021/03/index.html","hash":"3aad5c756a2fe5ec5da94d36c3668e5eb9fd3d57","modified":1621101838941},{"_id":"public/archives/2021/04/index.html","hash":"2adfd5fd4ccdef1556ad15570c866012accca18b","modified":1621101838941},{"_id":"public/archives/2021/05/index.html","hash":"57128ae7e81cf0b258ba37dbd20cad965faf48cd","modified":1621101838941},{"_id":"public/categories/随谈/index.html","hash":"d77ecb8c22f08ed4834aab4bdc75cd10f82cf01b","modified":1621101838941},{"_id":"public/categories/Code-tools/index.html","hash":"268fb0b880049ba7c24d09b0f65042c41ba4688a","modified":1621101838941},{"_id":"public/categories/刷题/index.html","hash":"8c5a568a6ae7c4378737ddbcb6312b8a86605a21","modified":1621101838941},{"_id":"public/categories/刷题/page/2/index.html","hash":"687910f48ba2ffd702b46d230c4e1046fad6bb78","modified":1621101838941},{"_id":"public/categories/刷题/page/3/index.html","hash":"1967652dee7e0ebf6bb77de3f7d3951cb26eaf34","modified":1621101838941},{"_id":"public/categories/刷题/page/4/index.html","hash":"cfc122ef544fda7813a99fd608558a36c1429958","modified":1621101838941},{"_id":"public/categories/刷题/page/5/index.html","hash":"c251f211e9c7d16ce628c3195f06c6bed9bd0acb","modified":1621101838941},{"_id":"public/categories/刷题/page/6/index.html","hash":"2bef3eaadf0c2d1ca0ddd8e5d71dbb7d79942512","modified":1621101838941},{"_id":"public/categories/刷题/page/7/index.html","hash":"07ee68f8895b7ba19714b4ff8158bad8b1173e17","modified":1621101838941},{"_id":"public/categories/刷题/page/8/index.html","hash":"cf82471ca83c8b9d691b42ed2f1a9bdd41ed97aa","modified":1621101838941},{"_id":"public/categories/刷题/page/9/index.html","hash":"541dcd2c545412cfacd7ac76e782da17d07af83e","modified":1621101838941},{"_id":"public/categories/刷题/page/10/index.html","hash":"77ae811f31887efb1e3fcf82c9e9f2620867fc8b","modified":1621101838941},{"_id":"public/categories/刷题/page/11/index.html","hash":"32697b627b1124d5c2f2c90a09b11e9d1bcdbf42","modified":1621101838941},{"_id":"public/categories/Code-tools/build/index.html","hash":"5024ddd1c76b8d32db16b8d429562db1be6c8415","modified":1621101838941},{"_id":"public/categories/刷题/DP/index.html","hash":"1e3b519a9266a212595c7d3887d2fdf513b2f028","modified":1621101838941},{"_id":"public/categories/刷题/DP/page/2/index.html","hash":"a7c8de0c10649a303ef3a3384301d849ce6ce748","modified":1621101838941},{"_id":"public/categories/刷题/位运算/index.html","hash":"aad9f8c48aac4a13c7e728031f851173072b1a57","modified":1621101838941},{"_id":"public/categories/刷题/其他/index.html","hash":"c506082a8d08adb0726a60f7cd3886756f78fb9b","modified":1621101838941},{"_id":"public/categories/刷题/其他/page/2/index.html","hash":"6544eb7f55d3a06296d3476bcb95554131a8ea05","modified":1621101838941},{"_id":"public/categories/刷题/分治/index.html","hash":"4ce7c4d64a3b167ee554a2780246602cdc981ff1","modified":1621101838941},{"_id":"public/categories/刷题/双指针/index.html","hash":"aa46754dfe9a5e08547ae794d701f28ae09a6fad","modified":1621101838941},{"_id":"public/categories/刷题/字符串/index.html","hash":"b6a2ac54207f0403777ca370de4db68b1a9b4115","modified":1621101838941},{"_id":"public/categories/刷题/排序/index.html","hash":"4b8e393025fe89c5f90978fd66f3342e7eba4342","modified":1621101838941},{"_id":"public/categories/刷题/数学/index.html","hash":"e7825aabed346f51d4253c5aebc6cab0fd8f7476","modified":1621101838941},{"_id":"public/categories/刷题/数学/page/2/index.html","hash":"2d7703d19fe4982c67f5000cc94aa96c13abb8a1","modified":1621101838941},{"_id":"public/categories/刷题/模拟/index.html","hash":"7408f085d019add7b8ec8fac8acb3d999770d842","modified":1621101838941},{"_id":"public/categories/刷题/贪心/index.html","hash":"86f9a4974ce8576854870d759cc4b03769c51ba2","modified":1621101838941},{"_id":"public/categories/刷题/其他code能力/index.html","hash":"955169488a1c36e6d43b86c9f77038cfc92ddcf4","modified":1621101838941},{"_id":"public/categories/刷题/搜索/index.html","hash":"c7ccedb1367b9e5548a63fe6f8c515a88342b654","modified":1621101838941},{"_id":"public/categories/刷题/搜索/page/2/index.html","hash":"9e1265789ac65b29ef1405e55fd803d166e447cd","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/index.html","hash":"2a7c5e34ae947412928b3cf11597aa11a788d749","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/page/2/index.html","hash":"3c366b104570e377c01aea2a4e08c620db4fb447","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/page/3/index.html","hash":"74ae7bd27b98e6a73ee1aa0eaaceb54b1c494047","modified":1621101838941},{"_id":"public/categories/刷题/其他code能力/代码规范/index.html","hash":"c8f6ad5e618764577f038817297eaa9db2301eab","modified":1621101838941},{"_id":"public/categories/刷题/其他code能力/沟通能力/index.html","hash":"fb53e2dfa1803e22b9a57c565404e429ee682a66","modified":1621101838941},{"_id":"public/categories/刷题/其他/扫描线/index.html","hash":"4ecedef319ce39bdd46ace5700e49622247485f9","modified":1621101838941},{"_id":"public/categories/刷题/搜索/bfs/index.html","hash":"4ba820239b67b0a8abf0d8243931b71d29645cb7","modified":1621101838941},{"_id":"public/categories/刷题/搜索/dfs/index.html","hash":"f6d13602a765c55060461ea68c895ef80985cc63","modified":1621101838941},{"_id":"public/categories/刷题/搜索/二分/index.html","hash":"3818078a974a74d4d8ab0c576f260a023d34f711","modified":1621101838941},{"_id":"public/categories/刷题/搜索/回溯/index.html","hash":"b76ae7680a0d3577a60bbc1d786ab5cf29e1f7c0","modified":1621101838941},{"_id":"public/categories/刷题/搜索/记忆化搜索/index.html","hash":"cf0c8b41233d3aed31342788ef6416b28f3a9237","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/set/index.html","hash":"b4e70146410d5fb70173f7e055bcd015fcab6f22","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/优先队列/index.html","hash":"1e1033b18442d037412ed3d47d68e982ba24a4a6","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/哈希/index.html","hash":"628ec7f9bd0c90b06a1c0c0d597931f40555133d","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/图/index.html","hash":"afab288e1965191b9c43f8a7bf5f99d87d21da69","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/堆/index.html","hash":"8241f62ee085212ec5fedb89c93268732940f321","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/复杂数据结构/index.html","hash":"02e0d743afa18f355be9f3e8be2df16a8028c70a","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/栈和队列/index.html","hash":"339cc6848f18dbf08293830dbde6c4ab5c2be515","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/树/index.html","hash":"cadb0df364d562ed6be19bc2cbbf904f23e3c320","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/链表/index.html","hash":"7a998f4341d4bb78d98b32a8ac8c396951f9262e","modified":1621101838941},{"_id":"public/categories/刷题/数据结构/栈和队列/单调栈/index.html","hash":"e7b81b7fd165fc53959baedf9b42cee4889d85ce","modified":1621101838941},{"_id":"public/index.html","hash":"d8f34df14db1526200f5289662bec3a9740facf5","modified":1621101838941},{"_id":"public/page/2/index.html","hash":"0338bd41d16868c0da959b24aaf7c27bdfbde0d8","modified":1621101838941},{"_id":"public/page/3/index.html","hash":"04dc683e5812b11817fb94e01c38d2970a81976e","modified":1621101838941},{"_id":"public/page/4/index.html","hash":"f405c0d05f4a977e719bdd19cef9564089f4c961","modified":1621101838941},{"_id":"public/page/5/index.html","hash":"0e3b5aa1f281245a2a5dbc4126aa3c3ad1eacb36","modified":1621101838941},{"_id":"public/page/6/index.html","hash":"7e8cb42a0f19e97a5c875dbf6f753671b01dcdbd","modified":1621101838941},{"_id":"public/page/7/index.html","hash":"f56020d945f9d8484950b7dabc03bfe82a4363b1","modified":1621101838941},{"_id":"public/page/8/index.html","hash":"033db0d30c283495ce247b381c092fcd3727c984","modified":1621101838941},{"_id":"public/categories/index.html","hash":"48acadf0fd990aa8e9608e279e387afb01a0f181","modified":1621101838941},{"_id":"public/tags/index.html","hash":"0c4be6935bf34e5a8b02c9f1768ebdc51d7dff35","modified":1621101838941},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1621101838941},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1621101838941},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1621101838941},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1621101838941},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1621101838941},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1621101838941},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1621101838941},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1621101838941},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1621101838941},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1621101838941},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1621101838941},{"_id":"public/css/cyberpunk.css","hash":"0d8dc4bf137bd7ccd0125f1bb6af45c1e51d7489","modified":1621101838941},{"_id":"public/css/style.css","hash":"f36bff9e79cb531e5ac60c5242c449644d3c7750","modified":1621101838941},{"_id":"public/css/default.css","hash":"f36bff9e79cb531e5ac60c5242c449644d3c7750","modified":1621101838941}],"Category":[{"name":"随谈","_id":"ckoq26jd0005xl5uo8uoa3o2a"},{"name":"Code tools","_id":"ckoq26jmb005zl5uo41hegxyq"},{"name":"刷题","_id":"ckoq26jmi0062l5uo4rffa56j"},{"name":"build","parent":"ckoq26jmb005zl5uo41hegxyq","_id":"ckoq26jr600bwl5uo8wi07l4f"},{"name":"DP","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jr700bxl5uocsgdbzn4"},{"name":"位运算\n","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsq00f4l5uo57izhj9g"},{"name":"其他","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt500g4l5uo3bwme7o8"},{"name":"分治\n","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju500isl5uobjr014mz"},{"name":"双指针","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju700iyl5uo4vsda2cz"},{"name":"字符串","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jui00jjl5uogys09aaz"},{"name":"排序\n","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jup00jyl5uo904l3hpu"},{"name":"数学\n","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jut00k7l5uoc5afbyz1"},{"name":"模拟\n","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jve00m4l5uo8r3mfozl"},{"name":"贪心\n","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvh00mgl5uo249s5zwi"},{"name":"~其他code能力","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvp00n4l5uocqnsd21z"},{"name":"搜索","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvr00nbl5uodhvra99b"},{"name":"数据结构","parent":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jw900o2l5uof9xr1yp9"},{"name":"代码规范\n","parent":"ckoq26jvp00n4l5uocqnsd21z","_id":"ckoq26jxa00pbl5uogocc9lz5"},{"name":"沟通能力\n","parent":"ckoq26jvp00n4l5uocqnsd21z","_id":"ckoq26jxa00pcl5uoa61ndqgp"},{"name":"扫描线\n","parent":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jxb00pel5uo5lmyc6h4"},{"name":"bfs\n","parent":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxc00phl5uog8ljc1vp"},{"name":"dfs\n","parent":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxd00pnl5uo0zgqcevq"},{"name":"二分\n","parent":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxl00q2l5uo3le8domd"},{"name":"回溯\n","parent":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxt00qul5uo7q1x1pvo"},{"name":"记忆化搜索\n","parent":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy200rll5uoebzb5oak"},{"name":"set\n","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jy400rrl5uodglk3cg1"},{"name":"优先队列\n","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jy600rxl5uo3xo620dc"},{"name":"哈希","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jy700s1l5uo63gsev8v"},{"name":"图\n","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jy700s4l5uogmdmbmk6"},{"name":"堆\n","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyf00spl5uohfen6n1t"},{"name":"复杂数据结构","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyg00ssl5uogzaha1fa"},{"name":"栈和队列","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyi00szl5uoe7yb1bo1"},{"name":"树","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyx00tql5uo49be93kr"},{"name":"链表\n","parent":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzi00v2l5uo9kw640p4"},{"name":"单调栈\n","parent":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzo00vkl5uo5rjq3fix"}],"Data":[],"Page":[],"Post":[{"title":"优秀是会遗传的吧？","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-25T13:38:57.000Z","_content":"\n\n\n\n\n\n\n\n\n## G姐妈妈访谈录\n\n\n\n听到G姐麻麻和G姐的访谈，非常非常震惊。G姐家庭环境非常好，爸爸是富二代，妈妈美国名校硕士，哈佛博士后。妈妈比较开明，理性，对家庭和孩子都是采取鼓励式教育。我最欣赏的是G妈身上那股专注投身于命运的专注，那种全身心的投入目标中去，抗争所能争取的，从不疲劳不抱怨的状态和心境。同时也为她这种看透人世的智慧，巧妙的与人相处的气质所膜拜。\n\n  <!-- more -->\n\n哈哈，但愿我也能找到这么一个优秀的女孩子。可以看看[胸大有脑用心做视频的G姐](https://www.bilibili.com/video/BV1Ft4y1Y7sd?t=13)。","source":"_posts/随谈/优秀是会遗传的吧？.md","raw":"---\ntitle: 优秀是会遗传的吧？\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-25 21:38:57\n---\n\n\n\n\n\n\n\n\n\n## G姐妈妈访谈录\n\n\n\n听到G姐麻麻和G姐的访谈，非常非常震惊。G姐家庭环境非常好，爸爸是富二代，妈妈美国名校硕士，哈佛博士后。妈妈比较开明，理性，对家庭和孩子都是采取鼓励式教育。我最欣赏的是G妈身上那股专注投身于命运的专注，那种全身心的投入目标中去，抗争所能争取的，从不疲劳不抱怨的状态和心境。同时也为她这种看透人世的智慧，巧妙的与人相处的气质所膜拜。\n\n  <!-- more -->\n\n哈哈，但愿我也能找到这么一个优秀的女孩子。可以看看[胸大有脑用心做视频的G姐](https://www.bilibili.com/video/BV1Ft4y1Y7sd?t=13)。","slug":"随谈/优秀是会遗传的吧？","published":1,"updated":"2021-01-28T14:16:46.189Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j270000l5uoau4van64","content":"<h2 id=\"G姐妈妈访谈录\"><a href=\"#G姐妈妈访谈录\" class=\"headerlink\" title=\"G姐妈妈访谈录\"></a>G姐妈妈访谈录</h2><p>听到G姐麻麻和G姐的访谈，非常非常震惊。G姐家庭环境非常好，爸爸是富二代，妈妈美国名校硕士，哈佛博士后。妈妈比较开明，理性，对家庭和孩子都是采取鼓励式教育。我最欣赏的是G妈身上那股专注投身于命运的专注，那种全身心的投入目标中去，抗争所能争取的，从不疲劳不抱怨的状态和心境。同时也为她这种看透人世的智慧，巧妙的与人相处的气质所膜拜。</p>\n  <span id=\"more\"></span>\n\n<p>哈哈，但愿我也能找到这么一个优秀的女孩子。可以看看<a href=\"https://www.bilibili.com/video/BV1Ft4y1Y7sd?t=13\">胸大有脑用心做视频的G姐</a>。</p>\n","site":{"data":{}},"abbrlink":"VDK6J","excerpt":"<h2 id=\"G姐妈妈访谈录\"><a href=\"#G姐妈妈访谈录\" class=\"headerlink\" title=\"G姐妈妈访谈录\"></a>G姐妈妈访谈录</h2><p>听到G姐麻麻和G姐的访谈，非常非常震惊。G姐家庭环境非常好，爸爸是富二代，妈妈美国名校硕士，哈佛博士后。妈妈比较开明，理性，对家庭和孩子都是采取鼓励式教育。我最欣赏的是G妈身上那股专注投身于命运的专注，那种全身心的投入目标中去，抗争所能争取的，从不疲劳不抱怨的状态和心境。同时也为她这种看透人世的智慧，巧妙的与人相处的气质所膜拜。</p>","more":"<p>哈哈，但愿我也能找到这么一个优秀的女孩子。可以看看<a href=\"https://www.bilibili.com/video/BV1Ft4y1Y7sd?t=13\">胸大有脑用心做视频的G姐</a>。</p>"},{"title":"大数据产品思考——地球保卫者","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-28T07:32:29.000Z","_content":"\n\n\n# 地球守护者\n\n就课堂作业扯扯淡\n\n<!-- more -->\n\n![作业描述](D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\作业描述.png)\n\n> 原谅我的文不对题\n>\n\n大数据之所以大，是得利于现代化数字化生活的在全国全球范围的快速普及和发展，其中数据的起源来源于大众生活中重复的需求和行为。比如美团控制了外卖，点餐的信息渠道，支付宝和微信支付把持了人民支付行为的巨大入口。现有的模式（我观察到的）就有：平台推出新模式改变用户行为，压缩传统市场占有空间，由此在平台上收集用户大数据，并用大数据进行决策优化以提升营收。比如Keep让用户接受了记录运动生活，进而尝试付费解锁运动健康知识，而掌握了大量人群的运动数据可以帮助keep分析用户，但真正的需求还是运动。\n\n这个案例是大数据附加在产品平台上的属性，我在思考真正能够用大数据驱动需求产品到底有什么？也许有大数据监控道路，监控生态，智能城市管理之类的需求（这些都用人做了）。我想可能用大数据监控太阳系突入起来的小行星防止撞击地球是一个好主意！没错\n\n真正的困难不仅仅在于如何构象出一款大数据产品，而是如何获取到用户（或政府一抑或公司，看你们做哪个端）的数据。政府的数据因为保密、安全、设备老旧和人脉不通而无法获取，大公司数据就更难了，你都有了为啥自己不做一个（腾讯：偷袭！我69岁的老数据）。到底是为了做大数据产品去构象一款产品呢，还是依据需求去做一个产品，如果能用大数据就用大数据，孰优孰劣。\n\n> 如果用大数据平台技术优势作为优势点，我……\n\n# 上衣\n\n\n\n面对年轻人多元化，多潮流的服装需求，一个快速推荐、指出潮流指数，表现个人欲望的平台呼之欲出。你可以在平台po出你的着装，平台会自动记录识别用户的服装种类，购买平台。平台会对用户进行用户画像，尝试进行用户推荐相似的风格的衣服和用户。在大数据加持下，用户可以在平台上查看当天当月当季的流行指数，欣赏最火的衣服推荐，从平台推送中做出更加适合自己的，省心的选择。在更加高级的人性化定制，大数据起到了更多的作用：个人风格设计、365天不重样个人着装设计……\n\n总之这是一个结合用户社交个性化展示，用户衣服选购，用户衣服流行趋势展示的选衣平台。\n\n这个需求很真，我就想要。\n\n痛点：种子用户难获取\n\n痒点：可以名正言顺的发自拍\n\n爽点：让懒鬼随便选择衣服，让个性化高的用户有展示空间，获取认同和名气\n\n市场规模：全国全球\n\n种子用户：这是一个边际获客成本很低的平台。种子用户建议在大学高校中大规模推广，他们是需求最大的群体。\n\n利润来源：衣服推荐商的佣金以及高度自定义话的衣物界相关金主广告植入，做成一个免费的平台是互联网常态吧。","source":"_posts/随谈/大数据产品思考——地球保卫者.md","raw":"---\ntitle: 大数据产品思考——地球保卫者\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-11-28 15:32:29\ntags:\n---\n\n\n\n# 地球守护者\n\n就课堂作业扯扯淡\n\n<!-- more -->\n\n![作业描述](D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\作业描述.png)\n\n> 原谅我的文不对题\n>\n\n大数据之所以大，是得利于现代化数字化生活的在全国全球范围的快速普及和发展，其中数据的起源来源于大众生活中重复的需求和行为。比如美团控制了外卖，点餐的信息渠道，支付宝和微信支付把持了人民支付行为的巨大入口。现有的模式（我观察到的）就有：平台推出新模式改变用户行为，压缩传统市场占有空间，由此在平台上收集用户大数据，并用大数据进行决策优化以提升营收。比如Keep让用户接受了记录运动生活，进而尝试付费解锁运动健康知识，而掌握了大量人群的运动数据可以帮助keep分析用户，但真正的需求还是运动。\n\n这个案例是大数据附加在产品平台上的属性，我在思考真正能够用大数据驱动需求产品到底有什么？也许有大数据监控道路，监控生态，智能城市管理之类的需求（这些都用人做了）。我想可能用大数据监控太阳系突入起来的小行星防止撞击地球是一个好主意！没错\n\n真正的困难不仅仅在于如何构象出一款大数据产品，而是如何获取到用户（或政府一抑或公司，看你们做哪个端）的数据。政府的数据因为保密、安全、设备老旧和人脉不通而无法获取，大公司数据就更难了，你都有了为啥自己不做一个（腾讯：偷袭！我69岁的老数据）。到底是为了做大数据产品去构象一款产品呢，还是依据需求去做一个产品，如果能用大数据就用大数据，孰优孰劣。\n\n> 如果用大数据平台技术优势作为优势点，我……\n\n# 上衣\n\n\n\n面对年轻人多元化，多潮流的服装需求，一个快速推荐、指出潮流指数，表现个人欲望的平台呼之欲出。你可以在平台po出你的着装，平台会自动记录识别用户的服装种类，购买平台。平台会对用户进行用户画像，尝试进行用户推荐相似的风格的衣服和用户。在大数据加持下，用户可以在平台上查看当天当月当季的流行指数，欣赏最火的衣服推荐，从平台推送中做出更加适合自己的，省心的选择。在更加高级的人性化定制，大数据起到了更多的作用：个人风格设计、365天不重样个人着装设计……\n\n总之这是一个结合用户社交个性化展示，用户衣服选购，用户衣服流行趋势展示的选衣平台。\n\n这个需求很真，我就想要。\n\n痛点：种子用户难获取\n\n痒点：可以名正言顺的发自拍\n\n爽点：让懒鬼随便选择衣服，让个性化高的用户有展示空间，获取认同和名气\n\n市场规模：全国全球\n\n种子用户：这是一个边际获客成本很低的平台。种子用户建议在大学高校中大规模推广，他们是需求最大的群体。\n\n利润来源：衣服推荐商的佣金以及高度自定义话的衣物界相关金主广告植入，做成一个免费的平台是互联网常态吧。","slug":"随谈/大数据产品思考——地球保卫者","published":1,"updated":"2021-01-28T14:04:37.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2d0001l5uo7fel1ifl","content":"<h1 id=\"地球守护者\"><a href=\"#地球守护者\" class=\"headerlink\" title=\"地球守护者\"></a>地球守护者</h1><p>就课堂作业扯扯淡</p>\n<span id=\"more\"></span>\n\n<p><img src=\"D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\作业描述.png\" alt=\"作业描述\"></p>\n<blockquote>\n<p>原谅我的文不对题</p>\n</blockquote>\n<p>大数据之所以大，是得利于现代化数字化生活的在全国全球范围的快速普及和发展，其中数据的起源来源于大众生活中重复的需求和行为。比如美团控制了外卖，点餐的信息渠道，支付宝和微信支付把持了人民支付行为的巨大入口。现有的模式（我观察到的）就有：平台推出新模式改变用户行为，压缩传统市场占有空间，由此在平台上收集用户大数据，并用大数据进行决策优化以提升营收。比如Keep让用户接受了记录运动生活，进而尝试付费解锁运动健康知识，而掌握了大量人群的运动数据可以帮助keep分析用户，但真正的需求还是运动。</p>\n<p>这个案例是大数据附加在产品平台上的属性，我在思考真正能够用大数据驱动需求产品到底有什么？也许有大数据监控道路，监控生态，智能城市管理之类的需求（这些都用人做了）。我想可能用大数据监控太阳系突入起来的小行星防止撞击地球是一个好主意！没错</p>\n<p>真正的困难不仅仅在于如何构象出一款大数据产品，而是如何获取到用户（或政府一抑或公司，看你们做哪个端）的数据。政府的数据因为保密、安全、设备老旧和人脉不通而无法获取，大公司数据就更难了，你都有了为啥自己不做一个（腾讯：偷袭！我69岁的老数据）。到底是为了做大数据产品去构象一款产品呢，还是依据需求去做一个产品，如果能用大数据就用大数据，孰优孰劣。</p>\n<blockquote>\n<p>如果用大数据平台技术优势作为优势点，我……</p>\n</blockquote>\n<h1 id=\"上衣\"><a href=\"#上衣\" class=\"headerlink\" title=\"上衣\"></a>上衣</h1><p>面对年轻人多元化，多潮流的服装需求，一个快速推荐、指出潮流指数，表现个人欲望的平台呼之欲出。你可以在平台po出你的着装，平台会自动记录识别用户的服装种类，购买平台。平台会对用户进行用户画像，尝试进行用户推荐相似的风格的衣服和用户。在大数据加持下，用户可以在平台上查看当天当月当季的流行指数，欣赏最火的衣服推荐，从平台推送中做出更加适合自己的，省心的选择。在更加高级的人性化定制，大数据起到了更多的作用：个人风格设计、365天不重样个人着装设计……</p>\n<p>总之这是一个结合用户社交个性化展示，用户衣服选购，用户衣服流行趋势展示的选衣平台。</p>\n<p>这个需求很真，我就想要。</p>\n<p>痛点：种子用户难获取</p>\n<p>痒点：可以名正言顺的发自拍</p>\n<p>爽点：让懒鬼随便选择衣服，让个性化高的用户有展示空间，获取认同和名气</p>\n<p>市场规模：全国全球</p>\n<p>种子用户：这是一个边际获客成本很低的平台。种子用户建议在大学高校中大规模推广，他们是需求最大的群体。</p>\n<p>利润来源：衣服推荐商的佣金以及高度自定义话的衣物界相关金主广告植入，做成一个免费的平台是互联网常态吧。</p>\n","site":{"data":{}},"abbrlink":"27NC3FB","excerpt":"<h1 id=\"地球守护者\"><a href=\"#地球守护者\" class=\"headerlink\" title=\"地球守护者\"></a>地球守护者</h1><p>就课堂作业扯扯淡</p>","more":"<p><img src=\"D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\作业描述.png\" alt=\"作业描述\"></p>\n<blockquote>\n<p>原谅我的文不对题</p>\n</blockquote>\n<p>大数据之所以大，是得利于现代化数字化生活的在全国全球范围的快速普及和发展，其中数据的起源来源于大众生活中重复的需求和行为。比如美团控制了外卖，点餐的信息渠道，支付宝和微信支付把持了人民支付行为的巨大入口。现有的模式（我观察到的）就有：平台推出新模式改变用户行为，压缩传统市场占有空间，由此在平台上收集用户大数据，并用大数据进行决策优化以提升营收。比如Keep让用户接受了记录运动生活，进而尝试付费解锁运动健康知识，而掌握了大量人群的运动数据可以帮助keep分析用户，但真正的需求还是运动。</p>\n<p>这个案例是大数据附加在产品平台上的属性，我在思考真正能够用大数据驱动需求产品到底有什么？也许有大数据监控道路，监控生态，智能城市管理之类的需求（这些都用人做了）。我想可能用大数据监控太阳系突入起来的小行星防止撞击地球是一个好主意！没错</p>\n<p>真正的困难不仅仅在于如何构象出一款大数据产品，而是如何获取到用户（或政府一抑或公司，看你们做哪个端）的数据。政府的数据因为保密、安全、设备老旧和人脉不通而无法获取，大公司数据就更难了，你都有了为啥自己不做一个（腾讯：偷袭！我69岁的老数据）。到底是为了做大数据产品去构象一款产品呢，还是依据需求去做一个产品，如果能用大数据就用大数据，孰优孰劣。</p>\n<blockquote>\n<p>如果用大数据平台技术优势作为优势点，我……</p>\n</blockquote>\n<h1 id=\"上衣\"><a href=\"#上衣\" class=\"headerlink\" title=\"上衣\"></a>上衣</h1><p>面对年轻人多元化，多潮流的服装需求，一个快速推荐、指出潮流指数，表现个人欲望的平台呼之欲出。你可以在平台po出你的着装，平台会自动记录识别用户的服装种类，购买平台。平台会对用户进行用户画像，尝试进行用户推荐相似的风格的衣服和用户。在大数据加持下，用户可以在平台上查看当天当月当季的流行指数，欣赏最火的衣服推荐，从平台推送中做出更加适合自己的，省心的选择。在更加高级的人性化定制，大数据起到了更多的作用：个人风格设计、365天不重样个人着装设计……</p>\n<p>总之这是一个结合用户社交个性化展示，用户衣服选购，用户衣服流行趋势展示的选衣平台。</p>\n<p>这个需求很真，我就想要。</p>\n<p>痛点：种子用户难获取</p>\n<p>痒点：可以名正言顺的发自拍</p>\n<p>爽点：让懒鬼随便选择衣服，让个性化高的用户有展示空间，获取认同和名气</p>\n<p>市场规模：全国全球</p>\n<p>种子用户：这是一个边际获客成本很低的平台。种子用户建议在大学高校中大规模推广，他们是需求最大的群体。</p>\n<p>利润来源：衣服推荐商的佣金以及高度自定义话的衣物界相关金主广告植入，做成一个免费的平台是互联网常态吧。</p>"},{"title":"cmake学习索引","thumbnail":"http://static.come2rss.xyz/simptab-wallpaper-20210415205844.jpg","toc":true,"top":10,"date":"2021-05-03T16:09:43.000Z","_content":"\n\n\n\n\n\n\n# Cmake笔记\n\n\n\nCmake是跨系统，C++现行标准构建标准的build system of build system`.\n\n\n\n比较好的学习资源如下：\n\n> [understand Cmake](https://internalpointers.com/post/modern-cmake-beginner-introduction) ✅: 一个简单的接受\n>\n> [cmake official web](https://cmake.org/) ： 对各个命令有最详细的解释，当字典用\n>\n> [Cmake Tutorial](https://medium.com/@onur.dundar1/cmake-tutorial-585dd180109b): 💖从零基础解释CMake基础概念，看完这个再看官方教程就很简单了\n>\n> [cmake tutorial](https://cmake.org/cmake/help/latest/guide/tutorial/index.html) ✅ ：跟着做比较有意思，可以多多尝试，就是有点花时间。后面部分内容可以看看\n>\n> [Cmake Detailed tutorial](https://cliutils.gitlab.io/modern-cmake/chapters/intro/newcmake.html) ✅: 最详细，有很多项目经验\n\n看完了，直接上手项目或者看其他开源项目如何管理也是有点启发滴。当然对照着一个真实项目学习Cmake也有点帮助。\n\n<!-- more -->","source":"_posts/Code tools/build/cmake学习索引.md","raw":"---\ntitle: cmake学习索引\nthumbnail: 'http://static.come2rss.xyz/simptab-wallpaper-20210415205844.jpg'\ntoc: true\ntop: 10\ndate: 2021-05-04 00:09:43\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n# Cmake笔记\n\n\n\nCmake是跨系统，C++现行标准构建标准的build system of build system`.\n\n\n\n比较好的学习资源如下：\n\n> [understand Cmake](https://internalpointers.com/post/modern-cmake-beginner-introduction) ✅: 一个简单的接受\n>\n> [cmake official web](https://cmake.org/) ： 对各个命令有最详细的解释，当字典用\n>\n> [Cmake Tutorial](https://medium.com/@onur.dundar1/cmake-tutorial-585dd180109b): 💖从零基础解释CMake基础概念，看完这个再看官方教程就很简单了\n>\n> [cmake tutorial](https://cmake.org/cmake/help/latest/guide/tutorial/index.html) ✅ ：跟着做比较有意思，可以多多尝试，就是有点花时间。后面部分内容可以看看\n>\n> [Cmake Detailed tutorial](https://cliutils.gitlab.io/modern-cmake/chapters/intro/newcmake.html) ✅: 最详细，有很多项目经验\n\n看完了，直接上手项目或者看其他开源项目如何管理也是有点启发滴。当然对照着一个真实项目学习Cmake也有点帮助。\n\n<!-- more -->","slug":"Code tools/build/cmake学习索引","published":1,"updated":"2021-05-03T16:16:41.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2e0002l5uod2ox9wvm","content":"<h1 id=\"Cmake笔记\"><a href=\"#Cmake笔记\" class=\"headerlink\" title=\"Cmake笔记\"></a>Cmake笔记</h1><p>Cmake是跨系统，C++现行标准构建标准的build system of build system`.</p>\n<p>比较好的学习资源如下：</p>\n<blockquote>\n<p><a href=\"https://internalpointers.com/post/modern-cmake-beginner-introduction\">understand Cmake</a> ✅: 一个简单的接受</p>\n<p><a href=\"https://cmake.org/\">cmake official web</a> ： 对各个命令有最详细的解释，当字典用</p>\n<p><a href=\"https://medium.com/@onur.dundar1/cmake-tutorial-585dd180109b\">Cmake Tutorial</a>: 💖从零基础解释CMake基础概念，看完这个再看官方教程就很简单了</p>\n<p><a href=\"https://cmake.org/cmake/help/latest/guide/tutorial/index.html\">cmake tutorial</a> ✅ ：跟着做比较有意思，可以多多尝试，就是有点花时间。后面部分内容可以看看</p>\n<p><a href=\"https://cliutils.gitlab.io/modern-cmake/chapters/intro/newcmake.html\">Cmake Detailed tutorial</a> ✅: 最详细，有很多项目经验</p>\n</blockquote>\n<p>看完了，直接上手项目或者看其他开源项目如何管理也是有点启发滴。当然对照着一个真实项目学习Cmake也有点帮助。</p>\n<span id=\"more\"></span>","site":{"data":{}},"abbrlink":"XPX1GV","excerpt":"<h1 id=\"Cmake笔记\"><a href=\"#Cmake笔记\" class=\"headerlink\" title=\"Cmake笔记\"></a>Cmake笔记</h1><p>Cmake是跨系统，C++现行标准构建标准的build system of build system`.</p>\n<p>比较好的学习资源如下：</p>\n<blockquote>\n<p><a href=\"https://internalpointers.com/post/modern-cmake-beginner-introduction\">understand Cmake</a> ✅: 一个简单的接受</p>\n<p><a href=\"https://cmake.org/\">cmake official web</a> ： 对各个命令有最详细的解释，当字典用</p>\n<p><a href=\"https://medium.com/@onur.dundar1/cmake-tutorial-585dd180109b\">Cmake Tutorial</a>: 💖从零基础解释CMake基础概念，看完这个再看官方教程就很简单了</p>\n<p><a href=\"https://cmake.org/cmake/help/latest/guide/tutorial/index.html\">cmake tutorial</a> ✅ ：跟着做比较有意思，可以多多尝试，就是有点花时间。后面部分内容可以看看</p>\n<p><a href=\"https://cliutils.gitlab.io/modern-cmake/chapters/intro/newcmake.html\">Cmake Detailed tutorial</a> ✅: 最详细，有很多项目经验</p>\n</blockquote>\n<p>看完了，直接上手项目或者看其他开源项目如何管理也是有点启发滴。当然对照着一个真实项目学习Cmake也有点帮助。</p>","more":""},{"title":"10. Regular Expression Matching","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-23T01:44:57.000Z","_content":"\n\n\n\n## [10. Regular Expression Matching](https://leetcode-cn.com/problems/regular-expression-matching/)\n\n## 思路：\n\nhard的DP题，思路见代码。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int  n = s.size(), m = p.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\n        dp[0][0] = true;\n        for(int j = 1; j <= m; j++){\n            if(j > 1 && p[j - 1] == '*') dp[0][j] = dp[0][j - 2];\n            for(int i = 1; i <= n; i++){\n                if(p[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1];\n                else if(p[j - 1] != '*') dp[i][j] = dp[i - 1][j - 1] && s[i - 1] == p[j - 1];\n                else if(s[i - 1] != p[j - 2] && p[j - 2] != '.')\n                    dp[i][j] = dp[i][j -2];\n                else // C* 子串可以匹配\n                // 1. 重复模式 C, 比如 [aa，a*] -> [a，a*]，[ba，ba*] -> [b，ba*] (-> [b，b])\n                // 2. 放弃匹配 C, 比如 [b，ba*] -> [b，b]\n                // 我尝试去掉了 3 也是可以过的呵呵~ \n                // 3. 第一次匹配 C, 比如 [a，a*] -> [a ，a]\n                //这题难就难在这, 想到状态转移方程\n                    dp[i][j] = dp[i -1][j] || dp[i][j - 2] ;//|| dp[i][j - 1];\n            }\n        }\n        return dp[n][m];\n    }\n};\n\n```","source":"_posts/刷题/DP/10-Regular-Expression-Matching.md","raw":"---\ntitle: 10. Regular Expression Matching\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-23 09:44:57\n---\n\n\n\n\n## [10. Regular Expression Matching](https://leetcode-cn.com/problems/regular-expression-matching/)\n\n## 思路：\n\nhard的DP题，思路见代码。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int  n = s.size(), m = p.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\n        dp[0][0] = true;\n        for(int j = 1; j <= m; j++){\n            if(j > 1 && p[j - 1] == '*') dp[0][j] = dp[0][j - 2];\n            for(int i = 1; i <= n; i++){\n                if(p[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1];\n                else if(p[j - 1] != '*') dp[i][j] = dp[i - 1][j - 1] && s[i - 1] == p[j - 1];\n                else if(s[i - 1] != p[j - 2] && p[j - 2] != '.')\n                    dp[i][j] = dp[i][j -2];\n                else // C* 子串可以匹配\n                // 1. 重复模式 C, 比如 [aa，a*] -> [a，a*]，[ba，ba*] -> [b，ba*] (-> [b，b])\n                // 2. 放弃匹配 C, 比如 [b，ba*] -> [b，b]\n                // 我尝试去掉了 3 也是可以过的呵呵~ \n                // 3. 第一次匹配 C, 比如 [a，a*] -> [a ，a]\n                //这题难就难在这, 想到状态转移方程\n                    dp[i][j] = dp[i -1][j] || dp[i][j - 2] ;//|| dp[i][j - 1];\n            }\n        }\n        return dp[n][m];\n    }\n};\n\n```","slug":"刷题/DP/10-Regular-Expression-Matching","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2g0003l5uo0dfz5hxy","content":"<h2 id=\"10-Regular-Expression-Matching\"><a href=\"#10-Regular-Expression-Matching\" class=\"headerlink\" title=\"10. Regular Expression Matching\"></a><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/\">10. Regular Expression Matching</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>hard的DP题，思路见代码。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isMatch(string s, string p) &#123;\n        int  n &#x3D; s.size(), m &#x3D; p.size();\n        vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false));\n        dp[0][0] &#x3D; true;\n        for(int j &#x3D; 1; j &lt;&#x3D; m; j++)&#123;\n            if(j &gt; 1 &amp;&amp; p[j - 1] &#x3D;&#x3D; &#39;*&#39;) dp[0][j] &#x3D; dp[0][j - 2];\n            for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n                if(p[j - 1] &#x3D;&#x3D; &#39;.&#39;) dp[i][j] &#x3D; dp[i - 1][j - 1];\n                else if(p[j - 1] !&#x3D; &#39;*&#39;) dp[i][j] &#x3D; dp[i - 1][j - 1] &amp;&amp; s[i - 1] &#x3D;&#x3D; p[j - 1];\n                else if(s[i - 1] !&#x3D; p[j - 2] &amp;&amp; p[j - 2] !&#x3D; &#39;.&#39;)\n                    dp[i][j] &#x3D; dp[i][j -2];\n                else &#x2F;&#x2F; C* 子串可以匹配\n                &#x2F;&#x2F; 1. 重复模式 C, 比如 [aa，a*] -&gt; [a，a*]，[ba，ba*] -&gt; [b，ba*] (-&gt; [b，b])\n                &#x2F;&#x2F; 2. 放弃匹配 C, 比如 [b，ba*] -&gt; [b，b]\n                &#x2F;&#x2F; 我尝试去掉了 3 也是可以过的呵呵~ \n                &#x2F;&#x2F; 3. 第一次匹配 C, 比如 [a，a*] -&gt; [a ，a]\n                &#x2F;&#x2F;这题难就难在这, 想到状态转移方程\n                    dp[i][j] &#x3D; dp[i -1][j] || dp[i][j - 2] ;&#x2F;&#x2F;|| dp[i][j - 1];\n            &#125;\n        &#125;\n        return dp[n][m];\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1HNHYB0","excerpt":"<h2 id=\"10-Regular-Expression-Matching\"><a href=\"#10-Regular-Expression-Matching\" class=\"headerlink\" title=\"10. Regular Expression Matching\"></a><a href=\"https://leetcode-cn.com/problems/regular-expression-matching/\">10. Regular Expression Matching</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>hard的DP题，思路见代码。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isMatch(string s, string p) &#123;\n        int  n &#x3D; s.size(), m &#x3D; p.size();\n        vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false));\n        dp[0][0] &#x3D; true;\n        for(int j &#x3D; 1; j &lt;&#x3D; m; j++)&#123;\n            if(j &gt; 1 &amp;&amp; p[j - 1] &#x3D;&#x3D; &#39;*&#39;) dp[0][j] &#x3D; dp[0][j - 2];\n            for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n                if(p[j - 1] &#x3D;&#x3D; &#39;.&#39;) dp[i][j] &#x3D; dp[i - 1][j - 1];\n                else if(p[j - 1] !&#x3D; &#39;*&#39;) dp[i][j] &#x3D; dp[i - 1][j - 1] &amp;&amp; s[i - 1] &#x3D;&#x3D; p[j - 1];\n                else if(s[i - 1] !&#x3D; p[j - 2] &amp;&amp; p[j - 2] !&#x3D; &#39;.&#39;)\n                    dp[i][j] &#x3D; dp[i][j -2];\n                else &#x2F;&#x2F; C* 子串可以匹配\n                &#x2F;&#x2F; 1. 重复模式 C, 比如 [aa，a*] -&gt; [a，a*]，[ba，ba*] -&gt; [b，ba*] (-&gt; [b，b])\n                &#x2F;&#x2F; 2. 放弃匹配 C, 比如 [b，ba*] -&gt; [b，b]\n                &#x2F;&#x2F; 我尝试去掉了 3 也是可以过的呵呵~ \n                &#x2F;&#x2F; 3. 第一次匹配 C, 比如 [a，a*] -&gt; [a ，a]\n                &#x2F;&#x2F;这题难就难在这, 想到状态转移方程\n                    dp[i][j] &#x3D; dp[i -1][j] || dp[i][j - 2] ;&#x2F;&#x2F;|| dp[i][j - 1];\n            &#125;\n        &#125;\n        return dp[n][m];\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"121. Best Time to Buy and Sell Stock","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-23T01:44:30.000Z","_content":"\n\n\n\n## [121. Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n## 思路：\n\n记录最值。<!-- more -->\n\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.size() == 0) return 0;\n        int profit = 0;\n        int minv = prices[0];\n        for(auto v : prices){\n            minv = min(minv, v);\n            profit = max(profit, v - minv);\n        }\n        return profit;\n    }\n};\n```","source":"_posts/刷题/DP/121-Best-Time-to-Buy-and-Sell-Stock.md","raw":"---\ntitle: 121. Best Time to Buy and Sell Stock\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-23 09:44:30\n---\n\n\n\n\n## [121. Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n## 思路：\n\n记录最值。<!-- more -->\n\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        if(prices.size() == 0) return 0;\n        int profit = 0;\n        int minv = prices[0];\n        for(auto v : prices){\n            minv = min(minv, v);\n            profit = max(profit, v - minv);\n        }\n        return profit;\n    }\n};\n```","slug":"刷题/DP/121-Best-Time-to-Buy-and-Sell-Stock","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2h0004l5uo0b979zil","content":"<h2 id=\"121-Best-Time-to-Buy-and-Sell-Stock\"><a href=\"#121-Best-Time-to-Buy-and-Sell-Stock\" class=\"headerlink\" title=\"121. Best Time to Buy and Sell Stock\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">121. Best Time to Buy and Sell Stock</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>记录最值。<span id=\"more\"></span></p>\n<blockquote>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        if(prices.size() &#x3D;&#x3D; 0) return 0;\n        int profit &#x3D; 0;\n        int minv &#x3D; prices[0];\n        for(auto v : prices)&#123;\n            minv &#x3D; min(minv, v);\n            profit &#x3D; max(profit, v - minv);\n        &#125;\n        return profit;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1C8NZ4M","excerpt":"<h2 id=\"121-Best-Time-to-Buy-and-Sell-Stock\"><a href=\"#121-Best-Time-to-Buy-and-Sell-Stock\" class=\"headerlink\" title=\"121. Best Time to Buy and Sell Stock\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">121. Best Time to Buy and Sell Stock</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>记录最值。","more":"</p>\n<blockquote>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        if(prices.size() &#x3D;&#x3D; 0) return 0;\n        int profit &#x3D; 0;\n        int minv &#x3D; prices[0];\n        for(auto v : prices)&#123;\n            minv &#x3D; min(minv, v);\n            profit &#x3D; max(profit, v - minv);\n        &#125;\n        return profit;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"123. Best Time to Buy and Sell Stock III","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-25T01:45:19.000Z","_content":"\n\n\n\n## [123. Best Time to Buy and Sell Stock III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)\n\n\n\n## 思路：\n\n1. 借用[简单股票](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)的思路可以双向遍历price,获取`price[0, i]`和`price[i, n]`两个时间段各自最大的花费。\n2. 比较巧妙，用第一段操作的利润去抵消第二段购买时的花费，一次遍历。\n\n> 股票的题目有很多，慢慢写。\n>\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n<!-- more -->\n\n## 代码：\n\n35%\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int d = prices.size();\n        vector<int> left(d, 0), right(d, 0);\n        int maxv = prices[0], minv = prices[0], maxpro = 0;\n        for(int i = 0; i < d; ++i){\n            if(minv > prices[i]){\n                maxv = minv = prices[i];\n            }\n            maxv = max(maxv, prices[i]);\n            maxpro = left[i] = max(left[i], max(maxpro, maxv - minv));\n        }\n        maxv = minv = prices[d - 1], maxpro = 0;\n        for(int i = d - 1; i >= 0; --i){\n            if(maxv < prices[i]){\n                maxv = minv = prices[i];\n            }\n            minv = min(minv, prices[i]);\n            maxpro = right[i] = max(right[i], max(maxpro, maxv - minv));\n        }\n        int res = 0;\n        for(int i = 0; i < d; ++i){\n            res = max(res, left[i] + right[i]);\n            // cout << left[i] + right[i] << endl;\n        }\n        return res;\n    }\n};\n```\n\n\n\n93%\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int d = prices.size();\n        int pro1, pro2, minp1, minp2;\n        pro1 = pro2 = INT_MIN;\n        minp1 = minp2 = INT_MAX;\n        for(auto p : prices){\n            minp1 = min(p, minp1);\n            pro1 = max(pro1, p - minp1);\n            minp2 = min(minp2, p - pro1);\n            pro2 = max(pro2, p - minp2);\n        }\n        return pro2;\n    }\n};\n```","source":"_posts/刷题/DP/123-Best-Time-to-Buy-and-Sell-Stock-III.md","raw":"---\ntitle: 123. Best Time to Buy and Sell Stock III\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-25 09:45:19\n---\n\n\n\n\n## [123. Best Time to Buy and Sell Stock III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)\n\n\n\n## 思路：\n\n1. 借用[简单股票](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)的思路可以双向遍历price,获取`price[0, i]`和`price[i, n]`两个时间段各自最大的花费。\n2. 比较巧妙，用第一段操作的利润去抵消第二段购买时的花费，一次遍历。\n\n> 股票的题目有很多，慢慢写。\n>\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n<!-- more -->\n\n## 代码：\n\n35%\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int d = prices.size();\n        vector<int> left(d, 0), right(d, 0);\n        int maxv = prices[0], minv = prices[0], maxpro = 0;\n        for(int i = 0; i < d; ++i){\n            if(minv > prices[i]){\n                maxv = minv = prices[i];\n            }\n            maxv = max(maxv, prices[i]);\n            maxpro = left[i] = max(left[i], max(maxpro, maxv - minv));\n        }\n        maxv = minv = prices[d - 1], maxpro = 0;\n        for(int i = d - 1; i >= 0; --i){\n            if(maxv < prices[i]){\n                maxv = minv = prices[i];\n            }\n            minv = min(minv, prices[i]);\n            maxpro = right[i] = max(right[i], max(maxpro, maxv - minv));\n        }\n        int res = 0;\n        for(int i = 0; i < d; ++i){\n            res = max(res, left[i] + right[i]);\n            // cout << left[i] + right[i] << endl;\n        }\n        return res;\n    }\n};\n```\n\n\n\n93%\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int d = prices.size();\n        int pro1, pro2, minp1, minp2;\n        pro1 = pro2 = INT_MIN;\n        minp1 = minp2 = INT_MAX;\n        for(auto p : prices){\n            minp1 = min(p, minp1);\n            pro1 = max(pro1, p - minp1);\n            minp2 = min(minp2, p - pro1);\n            pro2 = max(pro2, p - minp2);\n        }\n        return pro2;\n    }\n};\n```","slug":"刷题/DP/123-Best-Time-to-Buy-and-Sell-Stock-III","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2i0005l5uog4lyf6lp","content":"<h2 id=\"123-Best-Time-to-Buy-and-Sell-Stock-III\"><a href=\"#123-Best-Time-to-Buy-and-Sell-Stock-III\" class=\"headerlink\" title=\"123. Best Time to Buy and Sell Stock III\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/\">123. Best Time to Buy and Sell Stock III</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>借用<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\">简单股票</a>的思路可以双向遍历price,获取<code>price[0, i]</code>和<code>price[i, n]</code>两个时间段各自最大的花费。</li>\n<li>比较巧妙，用第一段操作的利润去抵消第二段购买时的花费，一次遍历。</li>\n</ol>\n<blockquote>\n<p>股票的题目有很多，慢慢写。</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>35%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size();\n        vector&lt;int&gt; left(d, 0), right(d, 0);\n        int maxv &#x3D; prices[0], minv &#x3D; prices[0], maxpro &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; d; ++i)&#123;\n            if(minv &gt; prices[i])&#123;\n                maxv &#x3D; minv &#x3D; prices[i];\n            &#125;\n            maxv &#x3D; max(maxv, prices[i]);\n            maxpro &#x3D; left[i] &#x3D; max(left[i], max(maxpro, maxv - minv));\n        &#125;\n        maxv &#x3D; minv &#x3D; prices[d - 1], maxpro &#x3D; 0;\n        for(int i &#x3D; d - 1; i &gt;&#x3D; 0; --i)&#123;\n            if(maxv &lt; prices[i])&#123;\n                maxv &#x3D; minv &#x3D; prices[i];\n            &#125;\n            minv &#x3D; min(minv, prices[i]);\n            maxpro &#x3D; right[i] &#x3D; max(right[i], max(maxpro, maxv - minv));\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; d; ++i)&#123;\n            res &#x3D; max(res, left[i] + right[i]);\n            &#x2F;&#x2F; cout &lt;&lt; left[i] + right[i] &lt;&lt; endl;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>93%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size();\n        int pro1, pro2, minp1, minp2;\n        pro1 &#x3D; pro2 &#x3D; INT_MIN;\n        minp1 &#x3D; minp2 &#x3D; INT_MAX;\n        for(auto p : prices)&#123;\n            minp1 &#x3D; min(p, minp1);\n            pro1 &#x3D; max(pro1, p - minp1);\n            minp2 &#x3D; min(minp2, p - pro1);\n            pro2 &#x3D; max(pro2, p - minp2);\n        &#125;\n        return pro2;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"XCCRYG","excerpt":"<h2 id=\"123-Best-Time-to-Buy-and-Sell-Stock-III\"><a href=\"#123-Best-Time-to-Buy-and-Sell-Stock-III\" class=\"headerlink\" title=\"123. Best Time to Buy and Sell Stock III\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/\">123. Best Time to Buy and Sell Stock III</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>借用<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\">简单股票</a>的思路可以双向遍历price,获取<code>price[0, i]</code>和<code>price[i, n]</code>两个时间段各自最大的花费。</li>\n<li>比较巧妙，用第一段操作的利润去抵消第二段购买时的花费，一次遍历。</li>\n</ol>\n<blockquote>\n<p>股票的题目有很多，慢慢写。</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>35%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size();\n        vector&lt;int&gt; left(d, 0), right(d, 0);\n        int maxv &#x3D; prices[0], minv &#x3D; prices[0], maxpro &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; d; ++i)&#123;\n            if(minv &gt; prices[i])&#123;\n                maxv &#x3D; minv &#x3D; prices[i];\n            &#125;\n            maxv &#x3D; max(maxv, prices[i]);\n            maxpro &#x3D; left[i] &#x3D; max(left[i], max(maxpro, maxv - minv));\n        &#125;\n        maxv &#x3D; minv &#x3D; prices[d - 1], maxpro &#x3D; 0;\n        for(int i &#x3D; d - 1; i &gt;&#x3D; 0; --i)&#123;\n            if(maxv &lt; prices[i])&#123;\n                maxv &#x3D; minv &#x3D; prices[i];\n            &#125;\n            minv &#x3D; min(minv, prices[i]);\n            maxpro &#x3D; right[i] &#x3D; max(right[i], max(maxpro, maxv - minv));\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; d; ++i)&#123;\n            res &#x3D; max(res, left[i] + right[i]);\n            &#x2F;&#x2F; cout &lt;&lt; left[i] + right[i] &lt;&lt; endl;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>93%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size();\n        int pro1, pro2, minp1, minp2;\n        pro1 &#x3D; pro2 &#x3D; INT_MIN;\n        minp1 &#x3D; minp2 &#x3D; INT_MAX;\n        for(auto p : prices)&#123;\n            minp1 &#x3D; min(p, minp1);\n            pro1 &#x3D; max(pro1, p - minp1);\n            minp2 &#x3D; min(minp2, p - pro1);\n            pro2 &#x3D; max(pro2, p - minp2);\n        &#125;\n        return pro2;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"124. Binary Tree Maximum Path Sum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-04-19T01:01:33.000Z","_content":"\n# [124. Binary Tree Maximum Path Sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)\n\n\n\n\n\n## 思路：\n\n这题有意思在DP。但算不上hard。\n\n树上的最大路径之和可以转化为一个节点上的左右子树连起来的路径，而左右路径的最大长度分别可以通过左右子树的路径的一部分求得。考虑到子树路径之和小于0的情况，有当前节点和左右子树路径的最大长度为：`DP[i] = max(max(DP[i * 2],0), max(DP[i * 2 + 1],0) + val` 。同时可以求出，当前节点最长路径，`pathsum = max(DP[i * 2],0) + max(DP[i * 2 + 1],0) + val`。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    int maxv = 0;\npublic:\n    int maxPathSum(TreeNode* root) {\n        maxv = root->val;\n        maxPathSumCore(root);\n        return maxv;\n    }\n\n    int maxPathSumCore(TreeNode *root){\n        if(!root) return 0;\n        int lv = maxPathSumCore(root->left); lv = max(0, lv);\n        int rv = maxPathSumCore(root->right); rv = max(0, rv);\n        maxv = max(maxv, lv + rv + root->val);\n        return root->val + max(lv, rv);\n    }\n};\n```\n\n","source":"_posts/刷题/DP/124-Binary-Tree-Maximum-Path-Sum.md","raw":"---\ntitle: 124. Binary Tree Maximum Path Sum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-04-19 09:01:33\ntags:\ncategories:\n---\n\n# [124. Binary Tree Maximum Path Sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)\n\n\n\n\n\n## 思路：\n\n这题有意思在DP。但算不上hard。\n\n树上的最大路径之和可以转化为一个节点上的左右子树连起来的路径，而左右路径的最大长度分别可以通过左右子树的路径的一部分求得。考虑到子树路径之和小于0的情况，有当前节点和左右子树路径的最大长度为：`DP[i] = max(max(DP[i * 2],0), max(DP[i * 2 + 1],0) + val` 。同时可以求出，当前节点最长路径，`pathsum = max(DP[i * 2],0) + max(DP[i * 2 + 1],0) + val`。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    int maxv = 0;\npublic:\n    int maxPathSum(TreeNode* root) {\n        maxv = root->val;\n        maxPathSumCore(root);\n        return maxv;\n    }\n\n    int maxPathSumCore(TreeNode *root){\n        if(!root) return 0;\n        int lv = maxPathSumCore(root->left); lv = max(0, lv);\n        int rv = maxPathSumCore(root->right); rv = max(0, rv);\n        maxv = max(maxv, lv + rv + root->val);\n        return root->val + max(lv, rv);\n    }\n};\n```\n\n","slug":"刷题/DP/124-Binary-Tree-Maximum-Path-Sum","published":1,"updated":"2021-04-19T01:08:03.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2j0006l5uocksufq4c","content":"<h1 id=\"124-Binary-Tree-Maximum-Path-Sum\"><a href=\"#124-Binary-Tree-Maximum-Path-Sum\" class=\"headerlink\" title=\"124. Binary Tree Maximum Path Sum\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">124. Binary Tree Maximum Path Sum</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题有意思在DP。但算不上hard。</p>\n<p>树上的最大路径之和可以转化为一个节点上的左右子树连起来的路径，而左右路径的最大长度分别可以通过左右子树的路径的一部分求得。考虑到子树路径之和小于0的情况，有当前节点和左右子树路径的最大长度为：<code>DP[i] = max(max(DP[i * 2],0), max(DP[i * 2 + 1],0) + val</code> 。同时可以求出，当前节点最长路径，<code>pathsum = max(DP[i * 2],0) + max(DP[i * 2 + 1],0) + val</code>。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    int maxv &#x3D; 0;\npublic:\n    int maxPathSum(TreeNode* root) &#123;\n        maxv &#x3D; root-&gt;val;\n        maxPathSumCore(root);\n        return maxv;\n    &#125;\n\n    int maxPathSumCore(TreeNode *root)&#123;\n        if(!root) return 0;\n        int lv &#x3D; maxPathSumCore(root-&gt;left); lv &#x3D; max(0, lv);\n        int rv &#x3D; maxPathSumCore(root-&gt;right); rv &#x3D; max(0, rv);\n        maxv &#x3D; max(maxv, lv + rv + root-&gt;val);\n        return root-&gt;val + max(lv, rv);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2HTZFYK","excerpt":"<h1 id=\"124-Binary-Tree-Maximum-Path-Sum\"><a href=\"#124-Binary-Tree-Maximum-Path-Sum\" class=\"headerlink\" title=\"124. Binary Tree Maximum Path Sum\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">124. Binary Tree Maximum Path Sum</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题有意思在DP。但算不上hard。</p>\n<p>树上的最大路径之和可以转化为一个节点上的左右子树连起来的路径，而左右路径的最大长度分别可以通过左右子树的路径的一部分求得。考虑到子树路径之和小于0的情况，有当前节点和左右子树路径的最大长度为：<code>DP[i] = max(max(DP[i * 2],0), max(DP[i * 2 + 1],0) + val</code> 。同时可以求出，当前节点最长路径，<code>pathsum = max(DP[i * 2],0) + max(DP[i * 2 + 1],0) + val</code>。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    int maxv &#x3D; 0;\npublic:\n    int maxPathSum(TreeNode* root) &#123;\n        maxv &#x3D; root-&gt;val;\n        maxPathSumCore(root);\n        return maxv;\n    &#125;\n\n    int maxPathSumCore(TreeNode *root)&#123;\n        if(!root) return 0;\n        int lv &#x3D; maxPathSumCore(root-&gt;left); lv &#x3D; max(0, lv);\n        int rv &#x3D; maxPathSumCore(root-&gt;right); rv &#x3D; max(0, rv);\n        maxv &#x3D; max(maxv, lv + rv + root-&gt;val);\n        return root-&gt;val + max(lv, rv);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1289.Minimum Falling Path Sum2","thumbnail":"http://static.come2rss.xyz/南京玄武湖.jpg","toc":true,"top":10,"date":"2020-09-23T01:58:21.000Z","_content":"\n\n\n\n\n<!-- more -->\n\n## [1289. Minimum Falling Path Sum II](https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/)\n\n\n\n## 思路：\n\n这题比较简单，dp做就行。\n\n寻找最小值的时候可以直接记录，或者用堆记录前2个最小值，从而快速dp。而记录的同时可以发现，之前多余dp信息无需存储，所以可以把空间复杂度从$O(n)$降到$O(1)$。\n\n## 代码：\n\n```C++\nclass Solution {\npublic:\n\n    int minFallingPathSum(vector<vector<int>>& arr) {\n        int dp[2][300] = {0};\n        int minp[300];\n        int len = arr.size();\n        priority_queue<int, vector<int>, less<int>> pq;\n       \n        //init\n        for(int i = 0; i < len; i++){\n            dp[0][i] = arr[0][i];\n            if(pq.size() < 2) pq.push(arr[0][i]);\n            else if(pq.top() > arr[0][i]){\n                pq.pop();\n                pq.push(arr[0][i]);\n            }\n        }\n\n        //dp\n        for(int i = 1; i < len; i++){\n            int nowr = i & 1;\n            int lastr = (i - 1) & 1;\n            \n            int min2 = pq.top(); pq.pop();\n            int min1 = pq.top(); pq.pop();\n            for(int j = 0; j < len; j++){            \n                if(min1 == dp[lastr][j])   \n                    dp[nowr][j] = min2 + arr[i][j];\n                else dp[nowr][j] = min1 + arr[i][j];\n                if(pq.size() < 2){\n                    pq.push(dp[nowr][j]);\n                }\n                else if(dp[nowr][j] < pq.top()){\n                    pq.pop();\n                    pq.push(dp[nowr][j]);\n                }   \n            }    \n        }\n\n        pq.pop();\n        return pq.top();\n    }\n};\n```\n\n","source":"_posts/刷题/DP/1289-Minimum-Falling-Path-Sum2.md","raw":"---\ntitle: 1289.Minimum Falling Path Sum2\nthumbnail: 'http://static.come2rss.xyz/南京玄武湖.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-09-23 09:58:21\n---\n\n\n\n\n\n<!-- more -->\n\n## [1289. Minimum Falling Path Sum II](https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/)\n\n\n\n## 思路：\n\n这题比较简单，dp做就行。\n\n寻找最小值的时候可以直接记录，或者用堆记录前2个最小值，从而快速dp。而记录的同时可以发现，之前多余dp信息无需存储，所以可以把空间复杂度从$O(n)$降到$O(1)$。\n\n## 代码：\n\n```C++\nclass Solution {\npublic:\n\n    int minFallingPathSum(vector<vector<int>>& arr) {\n        int dp[2][300] = {0};\n        int minp[300];\n        int len = arr.size();\n        priority_queue<int, vector<int>, less<int>> pq;\n       \n        //init\n        for(int i = 0; i < len; i++){\n            dp[0][i] = arr[0][i];\n            if(pq.size() < 2) pq.push(arr[0][i]);\n            else if(pq.top() > arr[0][i]){\n                pq.pop();\n                pq.push(arr[0][i]);\n            }\n        }\n\n        //dp\n        for(int i = 1; i < len; i++){\n            int nowr = i & 1;\n            int lastr = (i - 1) & 1;\n            \n            int min2 = pq.top(); pq.pop();\n            int min1 = pq.top(); pq.pop();\n            for(int j = 0; j < len; j++){            \n                if(min1 == dp[lastr][j])   \n                    dp[nowr][j] = min2 + arr[i][j];\n                else dp[nowr][j] = min1 + arr[i][j];\n                if(pq.size() < 2){\n                    pq.push(dp[nowr][j]);\n                }\n                else if(dp[nowr][j] < pq.top()){\n                    pq.pop();\n                    pq.push(dp[nowr][j]);\n                }   \n            }    \n        }\n\n        pq.pop();\n        return pq.top();\n    }\n};\n```\n\n","slug":"刷题/DP/1289-Minimum-Falling-Path-Sum2","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2k0007l5uobeqjd16i","content":"<span id=\"more\"></span>\n\n<h2 id=\"1289-Minimum-Falling-Path-Sum-II\"><a href=\"#1289-Minimum-Falling-Path-Sum-II\" class=\"headerlink\" title=\"1289. Minimum Falling Path Sum II\"></a><a href=\"https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/\">1289. Minimum Falling Path Sum II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题比较简单，dp做就行。</p>\n<p>寻找最小值的时候可以直接记录，或者用堆记录前2个最小值，从而快速dp。而记录的同时可以发现，之前多余dp信息无需存储，所以可以把空间复杂度从$O(n)$降到$O(1)$。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n\n    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; arr) &#123;\n        int dp[2][300] &#x3D; &#123;0&#125;;\n        int minp[300];\n        int len &#x3D; arr.size();\n        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq;\n       \n        &#x2F;&#x2F;init\n        for(int i &#x3D; 0; i &lt; len; i++)&#123;\n            dp[0][i] &#x3D; arr[0][i];\n            if(pq.size() &lt; 2) pq.push(arr[0][i]);\n            else if(pq.top() &gt; arr[0][i])&#123;\n                pq.pop();\n                pq.push(arr[0][i]);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;dp\n        for(int i &#x3D; 1; i &lt; len; i++)&#123;\n            int nowr &#x3D; i &amp; 1;\n            int lastr &#x3D; (i - 1) &amp; 1;\n            \n            int min2 &#x3D; pq.top(); pq.pop();\n            int min1 &#x3D; pq.top(); pq.pop();\n            for(int j &#x3D; 0; j &lt; len; j++)&#123;            \n                if(min1 &#x3D;&#x3D; dp[lastr][j])   \n                    dp[nowr][j] &#x3D; min2 + arr[i][j];\n                else dp[nowr][j] &#x3D; min1 + arr[i][j];\n                if(pq.size() &lt; 2)&#123;\n                    pq.push(dp[nowr][j]);\n                &#125;\n                else if(dp[nowr][j] &lt; pq.top())&#123;\n                    pq.pop();\n                    pq.push(dp[nowr][j]);\n                &#125;   \n            &#125;    \n        &#125;\n\n        pq.pop();\n        return pq.top();\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2M5FZFS","excerpt":"","more":"<h2 id=\"1289-Minimum-Falling-Path-Sum-II\"><a href=\"#1289-Minimum-Falling-Path-Sum-II\" class=\"headerlink\" title=\"1289. Minimum Falling Path Sum II\"></a><a href=\"https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/\">1289. Minimum Falling Path Sum II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题比较简单，dp做就行。</p>\n<p>寻找最小值的时候可以直接记录，或者用堆记录前2个最小值，从而快速dp。而记录的同时可以发现，之前多余dp信息无需存储，所以可以把空间复杂度从$O(n)$降到$O(1)$。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n\n    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; arr) &#123;\n        int dp[2][300] &#x3D; &#123;0&#125;;\n        int minp[300];\n        int len &#x3D; arr.size();\n        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq;\n       \n        &#x2F;&#x2F;init\n        for(int i &#x3D; 0; i &lt; len; i++)&#123;\n            dp[0][i] &#x3D; arr[0][i];\n            if(pq.size() &lt; 2) pq.push(arr[0][i]);\n            else if(pq.top() &gt; arr[0][i])&#123;\n                pq.pop();\n                pq.push(arr[0][i]);\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F;dp\n        for(int i &#x3D; 1; i &lt; len; i++)&#123;\n            int nowr &#x3D; i &amp; 1;\n            int lastr &#x3D; (i - 1) &amp; 1;\n            \n            int min2 &#x3D; pq.top(); pq.pop();\n            int min1 &#x3D; pq.top(); pq.pop();\n            for(int j &#x3D; 0; j &lt; len; j++)&#123;            \n                if(min1 &#x3D;&#x3D; dp[lastr][j])   \n                    dp[nowr][j] &#x3D; min2 + arr[i][j];\n                else dp[nowr][j] &#x3D; min1 + arr[i][j];\n                if(pq.size() &lt; 2)&#123;\n                    pq.push(dp[nowr][j]);\n                &#125;\n                else if(dp[nowr][j] &lt; pq.top())&#123;\n                    pq.pop();\n                    pq.push(dp[nowr][j]);\n                &#125;   \n            &#125;    \n        &#125;\n\n        pq.pop();\n        return pq.top();\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"139. Word Break","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-13T01:28:19.000Z","_content":"\n## [139. Word Break](https://leetcode-cn.com/problems/word-break/)\n\n\n\n## 思路：\n\n动态规划：$dp[i]=1$表示s子串`s.substr(0,i + 1)`可以被在词典中正确切分。\n\n<!-- more -->\n\n## 代码:\n\n77%\n\n```c++\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        // if(s.size())\n        set<string> dict;\n        for(auto t : wordDict)\n            dict.insert(t);\n        vector<int> dp(s.size(), 0);\n        // int lastdo = 0;\n        for(int i = 0;i < s.size(); ++i){\n            if(dict.count(s.substr(0, i + 1)))\n                    dp[i] = 1;                \n                \n            for(int j = i; j > 0; j--){\n                if(dp[j - 1] && dict.count(s.substr(j, i - j + 1))){\n                    dp[i] = 1;\n                    break;\n                }\n            }\n        }    \n        if(dp[s.size() - 1]) return true;\n        return false;\n    }\n};\n```","source":"_posts/刷题/DP/139-Word-Break.md","raw":"---\ntitle: 139. Word Break\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-13 09:28:19\n---\n\n## [139. Word Break](https://leetcode-cn.com/problems/word-break/)\n\n\n\n## 思路：\n\n动态规划：$dp[i]=1$表示s子串`s.substr(0,i + 1)`可以被在词典中正确切分。\n\n<!-- more -->\n\n## 代码:\n\n77%\n\n```c++\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        // if(s.size())\n        set<string> dict;\n        for(auto t : wordDict)\n            dict.insert(t);\n        vector<int> dp(s.size(), 0);\n        // int lastdo = 0;\n        for(int i = 0;i < s.size(); ++i){\n            if(dict.count(s.substr(0, i + 1)))\n                    dp[i] = 1;                \n                \n            for(int j = i; j > 0; j--){\n                if(dp[j - 1] && dict.count(s.substr(j, i - j + 1))){\n                    dp[i] = 1;\n                    break;\n                }\n            }\n        }    \n        if(dp[s.size() - 1]) return true;\n        return false;\n    }\n};\n```","slug":"刷题/DP/139-Word-Break","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2l0008l5uoh4rw9tck","content":"<h2 id=\"139-Word-Break\"><a href=\"#139-Word-Break\" class=\"headerlink\" title=\"139. Word Break\"></a><a href=\"https://leetcode-cn.com/problems/word-break/\">139. Word Break</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>动态规划：$dp[i]=1$表示s子串<code>s.substr(0,i + 1)</code>可以被在词典中正确切分。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码:\"></a>代码:</h2><p>77%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n        &#x2F;&#x2F; if(s.size())\n        set&lt;string&gt; dict;\n        for(auto t : wordDict)\n            dict.insert(t);\n        vector&lt;int&gt; dp(s.size(), 0);\n        &#x2F;&#x2F; int lastdo &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; s.size(); ++i)&#123;\n            if(dict.count(s.substr(0, i + 1)))\n                    dp[i] &#x3D; 1;                \n                \n            for(int j &#x3D; i; j &gt; 0; j--)&#123;\n                if(dp[j - 1] &amp;&amp; dict.count(s.substr(j, i - j + 1)))&#123;\n                    dp[i] &#x3D; 1;\n                    break;\n                &#125;\n            &#125;\n        &#125;    \n        if(dp[s.size() - 1]) return true;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"33YBP7D","excerpt":"<h2 id=\"139-Word-Break\"><a href=\"#139-Word-Break\" class=\"headerlink\" title=\"139. Word Break\"></a><a href=\"https://leetcode-cn.com/problems/word-break/\">139. Word Break</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>动态规划：$dp[i]=1$表示s子串<code>s.substr(0,i + 1)</code>可以被在词典中正确切分。</p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码:\"></a>代码:</h2><p>77%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;\n        &#x2F;&#x2F; if(s.size())\n        set&lt;string&gt; dict;\n        for(auto t : wordDict)\n            dict.insert(t);\n        vector&lt;int&gt; dp(s.size(), 0);\n        &#x2F;&#x2F; int lastdo &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; s.size(); ++i)&#123;\n            if(dict.count(s.substr(0, i + 1)))\n                    dp[i] &#x3D; 1;                \n                \n            for(int j &#x3D; i; j &gt; 0; j--)&#123;\n                if(dp[j - 1] &amp;&amp; dict.count(s.substr(j, i - j + 1)))&#123;\n                    dp[i] &#x3D; 1;\n                    break;\n                &#125;\n            &#125;\n        &#125;    \n        if(dp[s.size() - 1]) return true;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1411. Number of Ways to Paint N × 3 Grid","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-09-27T06:39:28.000Z","_content":"\n#### [1411. Number of Ways to Paint N × 3 Grid](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/)\n\n<!-- more -->\n\n题目不难，但是因为一个**累加的初始化的小bug**没有找出来而浪费了好多时间！\n\n## 思路：\n\n先遍历寻找可以叠放的图块，然后dp数量即可，空间状态可压缩。注意，每次dp数组后初始化问题。\n\n当然这里也可以看成矩阵乘法。\n\n官网的另一中解法涉及到[线性递推式的优化](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/solution/gei-n-x-3-wang-ge-tu-tu-se-de-fang-an-shu-by-leetc/)。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int numOfWays(int n) {\n        int cmap[13][13] ={0};\n        int posidx = 1;\n        map<int, int> pos;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                for(int k = 0; k < 3; k++){\n                    if(i == j || j == k) continue;\n                    int countR = i * 100 + j * 10 + k;\n                    if(pos[countR] == 0)\n                        pos[countR] = posidx++;   \n                    for(int s = 0; s < 3; s++){\n                        for(int t = 0; t < 3; t++){\n                            for(int q = 0; q < 3; q++){\n                                if(s == t || t == q) continue;\n                                int countC = s * 100 + t * 10 + q;\n                                if(pos[countC] == 0)\n                                    pos[countC] = posidx++;\n                                if(i == s || j == t || k == q) continue;\n                                cmap[pos[countR] - 1][pos[countC] - 1] = 1;\n                            \n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << posidx << endl;\n//          for(int i = 0; i < 12; i++) {\n//               for(int j = 0; j < 12; j++)\n//                 cout << cmap[i][j] << ' ';\n//                 cout << endl;\n//         }\n        \n        long long dp[2][12] = {0};\n        long long MOD = 1e9 + 7;\n        for(int i = 0; i < 12; i++) dp[0][i] = 1;\n        for(int i = 1; i < n; i++){\n            int newr = i & 1;\n            int lastr = (i - 1) & 1;\n            for(int j = 0; j < 12; j++){\n                dp[newr][j] = 0;\n                for(int k = 0; k < 12; k++)\n                    if(cmap[j][k] == 1){\n                        dp[newr][j] = (dp[newr][j] + dp[lastr][k]) % MOD; \n                    }\n            }\n//               for(int t = 0; t < 12; t++)\n//                 cout << dp[newr][t] << ' ';\n//                 cout << endl;            \n        }\n        long long  sum = 0;\n        int newr = (n - 1) & 1;\n        for(int i = 0; i < 12; i++){\n            sum = (sum + dp[newr][i]) % MOD;\n        }\n        return sum;\n    }\n};\n\n```\n\n","source":"_posts/刷题/DP/1411-Number-of-Ways-to-Paint-N-×-3-Grid.md","raw":"---\ntitle: 1411. Number of Ways to Paint N × 3 Grid\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-09-27 14:39:28\n---\n\n#### [1411. Number of Ways to Paint N × 3 Grid](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/)\n\n<!-- more -->\n\n题目不难，但是因为一个**累加的初始化的小bug**没有找出来而浪费了好多时间！\n\n## 思路：\n\n先遍历寻找可以叠放的图块，然后dp数量即可，空间状态可压缩。注意，每次dp数组后初始化问题。\n\n当然这里也可以看成矩阵乘法。\n\n官网的另一中解法涉及到[线性递推式的优化](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/solution/gei-n-x-3-wang-ge-tu-tu-se-de-fang-an-shu-by-leetc/)。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int numOfWays(int n) {\n        int cmap[13][13] ={0};\n        int posidx = 1;\n        map<int, int> pos;\n        for(int i = 0; i < 3; i++){\n            for(int j = 0; j < 3; j++){\n                for(int k = 0; k < 3; k++){\n                    if(i == j || j == k) continue;\n                    int countR = i * 100 + j * 10 + k;\n                    if(pos[countR] == 0)\n                        pos[countR] = posidx++;   \n                    for(int s = 0; s < 3; s++){\n                        for(int t = 0; t < 3; t++){\n                            for(int q = 0; q < 3; q++){\n                                if(s == t || t == q) continue;\n                                int countC = s * 100 + t * 10 + q;\n                                if(pos[countC] == 0)\n                                    pos[countC] = posidx++;\n                                if(i == s || j == t || k == q) continue;\n                                cmap[pos[countR] - 1][pos[countC] - 1] = 1;\n                            \n                            }\n                        }\n                    }\n                }\n            }\n        }\n        cout << posidx << endl;\n//          for(int i = 0; i < 12; i++) {\n//               for(int j = 0; j < 12; j++)\n//                 cout << cmap[i][j] << ' ';\n//                 cout << endl;\n//         }\n        \n        long long dp[2][12] = {0};\n        long long MOD = 1e9 + 7;\n        for(int i = 0; i < 12; i++) dp[0][i] = 1;\n        for(int i = 1; i < n; i++){\n            int newr = i & 1;\n            int lastr = (i - 1) & 1;\n            for(int j = 0; j < 12; j++){\n                dp[newr][j] = 0;\n                for(int k = 0; k < 12; k++)\n                    if(cmap[j][k] == 1){\n                        dp[newr][j] = (dp[newr][j] + dp[lastr][k]) % MOD; \n                    }\n            }\n//               for(int t = 0; t < 12; t++)\n//                 cout << dp[newr][t] << ' ';\n//                 cout << endl;            \n        }\n        long long  sum = 0;\n        int newr = (n - 1) & 1;\n        for(int i = 0; i < 12; i++){\n            sum = (sum + dp[newr][i]) % MOD;\n        }\n        return sum;\n    }\n};\n\n```\n\n","slug":"刷题/DP/1411-Number-of-Ways-to-Paint-N-×-3-Grid","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2n0009l5uo5vv69u29","content":"<h4 id=\"1411-Number-of-Ways-to-Paint-N-×-3-Grid\"><a href=\"#1411-Number-of-Ways-to-Paint-N-×-3-Grid\" class=\"headerlink\" title=\"1411. Number of Ways to Paint N × 3 Grid\"></a><a href=\"https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/\">1411. Number of Ways to Paint N × 3 Grid</a></h4><span id=\"more\"></span>\n\n<p>题目不难，但是因为一个<strong>累加的初始化的小bug</strong>没有找出来而浪费了好多时间！</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>先遍历寻找可以叠放的图块，然后dp数量即可，空间状态可压缩。注意，每次dp数组后初始化问题。</p>\n<p>当然这里也可以看成矩阵乘法。</p>\n<p>官网的另一中解法涉及到<a href=\"https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/solution/gei-n-x-3-wang-ge-tu-tu-se-de-fang-an-shu-by-leetc/\">线性递推式的优化</a>。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numOfWays(int n) &#123;\n        int cmap[13][13] &#x3D;&#123;0&#125;;\n        int posidx &#x3D; 1;\n        map&lt;int, int&gt; pos;\n        for(int i &#x3D; 0; i &lt; 3; i++)&#123;\n            for(int j &#x3D; 0; j &lt; 3; j++)&#123;\n                for(int k &#x3D; 0; k &lt; 3; k++)&#123;\n                    if(i &#x3D;&#x3D; j || j &#x3D;&#x3D; k) continue;\n                    int countR &#x3D; i * 100 + j * 10 + k;\n                    if(pos[countR] &#x3D;&#x3D; 0)\n                        pos[countR] &#x3D; posidx++;   \n                    for(int s &#x3D; 0; s &lt; 3; s++)&#123;\n                        for(int t &#x3D; 0; t &lt; 3; t++)&#123;\n                            for(int q &#x3D; 0; q &lt; 3; q++)&#123;\n                                if(s &#x3D;&#x3D; t || t &#x3D;&#x3D; q) continue;\n                                int countC &#x3D; s * 100 + t * 10 + q;\n                                if(pos[countC] &#x3D;&#x3D; 0)\n                                    pos[countC] &#x3D; posidx++;\n                                if(i &#x3D;&#x3D; s || j &#x3D;&#x3D; t || k &#x3D;&#x3D; q) continue;\n                                cmap[pos[countR] - 1][pos[countC] - 1] &#x3D; 1;\n                            \n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; posidx &lt;&lt; endl;\n&#x2F;&#x2F;          for(int i &#x3D; 0; i &lt; 12; i++) &#123;\n&#x2F;&#x2F;               for(int j &#x3D; 0; j &lt; 12; j++)\n&#x2F;&#x2F;                 cout &lt;&lt; cmap[i][j] &lt;&lt; &#39; &#39;;\n&#x2F;&#x2F;                 cout &lt;&lt; endl;\n&#x2F;&#x2F;         &#125;\n        \n        long long dp[2][12] &#x3D; &#123;0&#125;;\n        long long MOD &#x3D; 1e9 + 7;\n        for(int i &#x3D; 0; i &lt; 12; i++) dp[0][i] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n; i++)&#123;\n            int newr &#x3D; i &amp; 1;\n            int lastr &#x3D; (i - 1) &amp; 1;\n            for(int j &#x3D; 0; j &lt; 12; j++)&#123;\n                dp[newr][j] &#x3D; 0;\n                for(int k &#x3D; 0; k &lt; 12; k++)\n                    if(cmap[j][k] &#x3D;&#x3D; 1)&#123;\n                        dp[newr][j] &#x3D; (dp[newr][j] + dp[lastr][k]) % MOD; \n                    &#125;\n            &#125;\n&#x2F;&#x2F;               for(int t &#x3D; 0; t &lt; 12; t++)\n&#x2F;&#x2F;                 cout &lt;&lt; dp[newr][t] &lt;&lt; &#39; &#39;;\n&#x2F;&#x2F;                 cout &lt;&lt; endl;            \n        &#125;\n        long long  sum &#x3D; 0;\n        int newr &#x3D; (n - 1) &amp; 1;\n        for(int i &#x3D; 0; i &lt; 12; i++)&#123;\n            sum &#x3D; (sum + dp[newr][i]) % MOD;\n        &#125;\n        return sum;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3E0MQY","excerpt":"<h4 id=\"1411-Number-of-Ways-to-Paint-N-×-3-Grid\"><a href=\"#1411-Number-of-Ways-to-Paint-N-×-3-Grid\" class=\"headerlink\" title=\"1411. Number of Ways to Paint N × 3 Grid\"></a><a href=\"https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/\">1411. Number of Ways to Paint N × 3 Grid</a></h4>","more":"<p>题目不难，但是因为一个<strong>累加的初始化的小bug</strong>没有找出来而浪费了好多时间！</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>先遍历寻找可以叠放的图块，然后dp数量即可，空间状态可压缩。注意，每次dp数组后初始化问题。</p>\n<p>当然这里也可以看成矩阵乘法。</p>\n<p>官网的另一中解法涉及到<a href=\"https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/solution/gei-n-x-3-wang-ge-tu-tu-se-de-fang-an-shu-by-leetc/\">线性递推式的优化</a>。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numOfWays(int n) &#123;\n        int cmap[13][13] &#x3D;&#123;0&#125;;\n        int posidx &#x3D; 1;\n        map&lt;int, int&gt; pos;\n        for(int i &#x3D; 0; i &lt; 3; i++)&#123;\n            for(int j &#x3D; 0; j &lt; 3; j++)&#123;\n                for(int k &#x3D; 0; k &lt; 3; k++)&#123;\n                    if(i &#x3D;&#x3D; j || j &#x3D;&#x3D; k) continue;\n                    int countR &#x3D; i * 100 + j * 10 + k;\n                    if(pos[countR] &#x3D;&#x3D; 0)\n                        pos[countR] &#x3D; posidx++;   \n                    for(int s &#x3D; 0; s &lt; 3; s++)&#123;\n                        for(int t &#x3D; 0; t &lt; 3; t++)&#123;\n                            for(int q &#x3D; 0; q &lt; 3; q++)&#123;\n                                if(s &#x3D;&#x3D; t || t &#x3D;&#x3D; q) continue;\n                                int countC &#x3D; s * 100 + t * 10 + q;\n                                if(pos[countC] &#x3D;&#x3D; 0)\n                                    pos[countC] &#x3D; posidx++;\n                                if(i &#x3D;&#x3D; s || j &#x3D;&#x3D; t || k &#x3D;&#x3D; q) continue;\n                                cmap[pos[countR] - 1][pos[countC] - 1] &#x3D; 1;\n                            \n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        cout &lt;&lt; posidx &lt;&lt; endl;\n&#x2F;&#x2F;          for(int i &#x3D; 0; i &lt; 12; i++) &#123;\n&#x2F;&#x2F;               for(int j &#x3D; 0; j &lt; 12; j++)\n&#x2F;&#x2F;                 cout &lt;&lt; cmap[i][j] &lt;&lt; &#39; &#39;;\n&#x2F;&#x2F;                 cout &lt;&lt; endl;\n&#x2F;&#x2F;         &#125;\n        \n        long long dp[2][12] &#x3D; &#123;0&#125;;\n        long long MOD &#x3D; 1e9 + 7;\n        for(int i &#x3D; 0; i &lt; 12; i++) dp[0][i] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n; i++)&#123;\n            int newr &#x3D; i &amp; 1;\n            int lastr &#x3D; (i - 1) &amp; 1;\n            for(int j &#x3D; 0; j &lt; 12; j++)&#123;\n                dp[newr][j] &#x3D; 0;\n                for(int k &#x3D; 0; k &lt; 12; k++)\n                    if(cmap[j][k] &#x3D;&#x3D; 1)&#123;\n                        dp[newr][j] &#x3D; (dp[newr][j] + dp[lastr][k]) % MOD; \n                    &#125;\n            &#125;\n&#x2F;&#x2F;               for(int t &#x3D; 0; t &lt; 12; t++)\n&#x2F;&#x2F;                 cout &lt;&lt; dp[newr][t] &lt;&lt; &#39; &#39;;\n&#x2F;&#x2F;                 cout &lt;&lt; endl;            \n        &#125;\n        long long  sum &#x3D; 0;\n        int newr &#x3D; (n - 1) &amp; 1;\n        for(int i &#x3D; 0; i &lt; 12; i++)&#123;\n            sum &#x3D; (sum + dp[newr][i]) % MOD;\n        &#125;\n        return sum;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"188. Best Time to Buy and Sell Stock IV","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-25T01:48:17.000Z","_content":"\n## [188. Best Time to Buy and Sell Stock IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)\n\n\n\n## 思路：\n\n把transaction拆分为买buy和卖sell，`sell[i][j]`代表对于第`i`个物品，第`j`次卖操作后最大利润。`buy`和`sell`的转移方程如代码所示。\n\n> 形式上更像一个状态转移机。\n>\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        int d = prices.size();\n        if(d < 2) return 0;\n        k = min(k, d);// 超过n的k是没有意义的\n        // buy一开始啥利润都没有应该为0，但是由于购买后利润可能会为负数，所以必须初始化为-INF\n        vector<int> buy(k + 1, INT_MIN), sell(k + 1, 0);\n        for(int i = 0;i < d; ++i){\n            for(int j = 1; j <= k; ++j){\n                buy[j] = max(buy[j], sell[j - 1] - prices[i]); \n                sell[j] = max(sell[j], buy[j] + prices[i]);\n            }\n        }\n        return sell[k];\n    }\n};\n```\n\n其中不优化空间的转移方程如下：\n\n```c++\n        for(int i = 0;i < d; ++i){\n            for(int j = 1; j <= k; ++j){\n                buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]); \n                sell[i][j] = max(sell[i - 1][j], buy[i - 1][j] + prices[i]);\n            }\n        }\n\n```\n\n","source":"_posts/刷题/DP/188-Best-Time-to-Buy-and-Sell-Stock-IV.md","raw":"---\ntitle: 188. Best Time to Buy and Sell Stock IV\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-25 09:48:17\n---\n\n## [188. Best Time to Buy and Sell Stock IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)\n\n\n\n## 思路：\n\n把transaction拆分为买buy和卖sell，`sell[i][j]`代表对于第`i`个物品，第`j`次卖操作后最大利润。`buy`和`sell`的转移方程如代码所示。\n\n> 形式上更像一个状态转移机。\n>\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        int d = prices.size();\n        if(d < 2) return 0;\n        k = min(k, d);// 超过n的k是没有意义的\n        // buy一开始啥利润都没有应该为0，但是由于购买后利润可能会为负数，所以必须初始化为-INF\n        vector<int> buy(k + 1, INT_MIN), sell(k + 1, 0);\n        for(int i = 0;i < d; ++i){\n            for(int j = 1; j <= k; ++j){\n                buy[j] = max(buy[j], sell[j - 1] - prices[i]); \n                sell[j] = max(sell[j], buy[j] + prices[i]);\n            }\n        }\n        return sell[k];\n    }\n};\n```\n\n其中不优化空间的转移方程如下：\n\n```c++\n        for(int i = 0;i < d; ++i){\n            for(int j = 1; j <= k; ++j){\n                buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]); \n                sell[i][j] = max(sell[i - 1][j], buy[i - 1][j] + prices[i]);\n            }\n        }\n\n```\n\n","slug":"刷题/DP/188-Best-Time-to-Buy-and-Sell-Stock-IV","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2o000al5uo0yh2gma7","content":"<h2 id=\"188-Best-Time-to-Buy-and-Sell-Stock-IV\"><a href=\"#188-Best-Time-to-Buy-and-Sell-Stock-IV\" class=\"headerlink\" title=\"188. Best Time to Buy and Sell Stock IV\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/\">188. Best Time to Buy and Sell Stock IV</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>把transaction拆分为买buy和卖sell，<code>sell[i][j]</code>代表对于第<code>i</code>个物品，第<code>j</code>次卖操作后最大利润。<code>buy</code>和<code>sell</code>的转移方程如代码所示。</p>\n<blockquote>\n<p>形式上更像一个状态转移机。</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size();\n        if(d &lt; 2) return 0;\n        k &#x3D; min(k, d);&#x2F;&#x2F; 超过n的k是没有意义的\n        &#x2F;&#x2F; buy一开始啥利润都没有应该为0，但是由于购买后利润可能会为负数，所以必须初始化为-INF\n        vector&lt;int&gt; buy(k + 1, INT_MIN), sell(k + 1, 0);\n        for(int i &#x3D; 0;i &lt; d; ++i)&#123;\n            for(int j &#x3D; 1; j &lt;&#x3D; k; ++j)&#123;\n                buy[j] &#x3D; max(buy[j], sell[j - 1] - prices[i]); \n                sell[j] &#x3D; max(sell[j], buy[j] + prices[i]);\n            &#125;\n        &#125;\n        return sell[k];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中不优化空间的转移方程如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(int i &#x3D; 0;i &lt; d; ++i)&#123;\n    for(int j &#x3D; 1; j &lt;&#x3D; k; ++j)&#123;\n        buy[i][j] &#x3D; max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]); \n        sell[i][j] &#x3D; max(sell[i - 1][j], buy[i - 1][j] + prices[i]);\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"09DXQP","excerpt":"<h2 id=\"188-Best-Time-to-Buy-and-Sell-Stock-IV\"><a href=\"#188-Best-Time-to-Buy-and-Sell-Stock-IV\" class=\"headerlink\" title=\"188. Best Time to Buy and Sell Stock IV\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/\">188. Best Time to Buy and Sell Stock IV</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>把transaction拆分为买buy和卖sell，<code>sell[i][j]</code>代表对于第<code>i</code>个物品，第<code>j</code>次卖操作后最大利润。<code>buy</code>和<code>sell</code>的转移方程如代码所示。</p>\n<blockquote>\n<p>形式上更像一个状态转移机。</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size();\n        if(d &lt; 2) return 0;\n        k &#x3D; min(k, d);&#x2F;&#x2F; 超过n的k是没有意义的\n        &#x2F;&#x2F; buy一开始啥利润都没有应该为0，但是由于购买后利润可能会为负数，所以必须初始化为-INF\n        vector&lt;int&gt; buy(k + 1, INT_MIN), sell(k + 1, 0);\n        for(int i &#x3D; 0;i &lt; d; ++i)&#123;\n            for(int j &#x3D; 1; j &lt;&#x3D; k; ++j)&#123;\n                buy[j] &#x3D; max(buy[j], sell[j - 1] - prices[i]); \n                sell[j] &#x3D; max(sell[j], buy[j] + prices[i]);\n            &#125;\n        &#125;\n        return sell[k];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中不优化空间的转移方程如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(int i &#x3D; 0;i &lt; d; ++i)&#123;\n    for(int j &#x3D; 1; j &lt;&#x3D; k; ++j)&#123;\n        buy[i][j] &#x3D; max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]); \n        sell[i][j] &#x3D; max(sell[i - 1][j], buy[i - 1][j] + prices[i]);\n    &#125;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"198. House Robber","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-07T01:16:58.000Z","_content":"\n\n\n## [198. House Robber](https://leetcode-cn.com/problems/house-robber/)\n\n\n\n## 思路：\n\n\n\n1. 将偷和不偷的两种状态分别记录到两个dp上，dp方程见代码1\n2. 如果不分解，记$dp[i]$为在房子$i$所能获得最大的金钱收益，应该可以比较偷窃第$i$房子加上之前$i-2$个房子所能偷窃的最大金额，和只偷窃前$i-1$房子的最大金额。\n> ![image-20201207091040289](http://static.come2rss.xyz/image-20201207091040289.png)\n\n<!-- more -->\n\n## 代码：\n\n代码1\n\n```\tc++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> dp1(n, 0);\n        vector<int> dp0(n, 0);\n        dp0[0] = 0; dp1[0] = nums[0];\n        \n        for(int i = 1; i < n; ++i){\n            dp0[i] = max(dp0[i - 1], dp1[i - 1]);\n            dp1[i] = dp0[i - 1] + nums[i];\n        }\n        return max(dp1[n - 1], dp0[n - 1]);\n    }\n};\n```\n\n\n\ndp2\n\n100%\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        else if(n == 1) return nums[0];\n        vector<int> dp(n, 0);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n        for(int i = 2; i < n; ++i){\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);            \n        }\n        return dp[n - 1];\n    }\n};\n```","source":"_posts/刷题/DP/198-House-Robber.md","raw":"---\ntitle: 198. House Robber\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-07 09:16:58\n---\n\n\n\n## [198. House Robber](https://leetcode-cn.com/problems/house-robber/)\n\n\n\n## 思路：\n\n\n\n1. 将偷和不偷的两种状态分别记录到两个dp上，dp方程见代码1\n2. 如果不分解，记$dp[i]$为在房子$i$所能获得最大的金钱收益，应该可以比较偷窃第$i$房子加上之前$i-2$个房子所能偷窃的最大金额，和只偷窃前$i-1$房子的最大金额。\n> ![image-20201207091040289](http://static.come2rss.xyz/image-20201207091040289.png)\n\n<!-- more -->\n\n## 代码：\n\n代码1\n\n```\tc++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> dp1(n, 0);\n        vector<int> dp0(n, 0);\n        dp0[0] = 0; dp1[0] = nums[0];\n        \n        for(int i = 1; i < n; ++i){\n            dp0[i] = max(dp0[i - 1], dp1[i - 1]);\n            dp1[i] = dp0[i - 1] + nums[i];\n        }\n        return max(dp1[n - 1], dp0[n - 1]);\n    }\n};\n```\n\n\n\ndp2\n\n100%\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        else if(n == 1) return nums[0];\n        vector<int> dp(n, 0);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n        for(int i = 2; i < n; ++i){\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);            \n        }\n        return dp[n - 1];\n    }\n};\n```","slug":"刷题/DP/198-House-Robber","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2q000bl5uo11nb5yiu","content":"<h2 id=\"198-House-Robber\"><a href=\"#198-House-Robber\" class=\"headerlink\" title=\"198. House Robber\"></a><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. House Robber</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>将偷和不偷的两种状态分别记录到两个dp上，dp方程见代码1</li>\n<li>如果不分解，记$dp[i]$为在房子$i$所能获得最大的金钱收益，应该可以比较偷窃第$i$房子加上之前$i-2$个房子所能偷窃的最大金额，和只偷窃前$i-1$房子的最大金额。<blockquote>\n<p><img src=\"http://static.come2rss.xyz/image-20201207091040289.png\" alt=\"image-20201207091040289\"></p>\n</blockquote>\n</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>代码1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp1(n, 0);\n        vector&lt;int&gt; dp0(n, 0);\n        dp0[0] &#x3D; 0; dp1[0] &#x3D; nums[0];\n        \n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            dp0[i] &#x3D; max(dp0[i - 1], dp1[i - 1]);\n            dp1[i] &#x3D; dp0[i - 1] + nums[i];\n        &#125;\n        return max(dp1[n - 1], dp0[n - 1]);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>dp2</p>\n<p>100%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        else if(n &#x3D;&#x3D; 1) return nums[0];\n        vector&lt;int&gt; dp(n, 0);\n        dp[0] &#x3D; nums[0];\n        dp[1] &#x3D; max(nums[0], nums[1]);\n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i]);            \n        &#125;\n        return dp[n - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2R1BCMM","excerpt":"<h2 id=\"198-House-Robber\"><a href=\"#198-House-Robber\" class=\"headerlink\" title=\"198. House Robber\"></a><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. House Robber</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>将偷和不偷的两种状态分别记录到两个dp上，dp方程见代码1</li>\n<li>如果不分解，记$dp[i]$为在房子$i$所能获得最大的金钱收益，应该可以比较偷窃第$i$房子加上之前$i-2$个房子所能偷窃的最大金额，和只偷窃前$i-1$房子的最大金额。<blockquote>\n<p><img src=\"http://static.come2rss.xyz/image-20201207091040289.png\" alt=\"image-20201207091040289\"></p>\n</blockquote>\n</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>代码1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp1(n, 0);\n        vector&lt;int&gt; dp0(n, 0);\n        dp0[0] &#x3D; 0; dp1[0] &#x3D; nums[0];\n        \n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            dp0[i] &#x3D; max(dp0[i - 1], dp1[i - 1]);\n            dp1[i] &#x3D; dp0[i - 1] + nums[i];\n        &#125;\n        return max(dp1[n - 1], dp0[n - 1]);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>dp2</p>\n<p>100%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        else if(n &#x3D;&#x3D; 1) return nums[0];\n        vector&lt;int&gt; dp(n, 0);\n        dp[0] &#x3D; nums[0];\n        dp[1] &#x3D; max(nums[0], nums[1]);\n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            dp[i] &#x3D; max(dp[i - 1], dp[i - 2] + nums[i]);            \n        &#125;\n        return dp[n - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"213. House Robber II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-28T07:41:47.000Z","_content":"\n\n\n\n\n## [213. House Robber II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n\n\n## 思路：\n\n\n\n首和尾的数字元素不能同时选择的。那么直接把列表拆分成两个$[0,...., n - 2]$和$[1,.....,n-1]$，分开DP就行了。\n\n使用$dp[i]$表示数组在元素$i$上所能获得的最大金钱。\n\n> 当然也可进行动作拆分。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        else if(n <= 1) return nums[0];\n        return max(getdp(nums, 0, n - 1), getdp(nums, 1, n));\n    }\n\n    int getdp(vector<int> nums, int s, int e){\n        if(s >= e) return 0;\n        if(s + 2 <= e) //初始化\n            nums[s + 1] = max(nums[s], nums[s + 1]); \n        for(int i = s + 2; i < e; ++i){\n            nums[i] = max(nums[i - 2] + nums[i], nums[i - 1]);\n        }\n        return nums[e - 1];\n    }\n};\n```","source":"_posts/刷题/DP/213-House-Robber-II.md","raw":"---\ntitle: 213. House Robber II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-28 15:41:47\n---\n\n\n\n\n\n## [213. House Robber II](https://leetcode-cn.com/problems/house-robber-ii/)\n\n\n\n## 思路：\n\n\n\n首和尾的数字元素不能同时选择的。那么直接把列表拆分成两个$[0,...., n - 2]$和$[1,.....,n-1]$，分开DP就行了。\n\n使用$dp[i]$表示数组在元素$i$上所能获得的最大金钱。\n\n> 当然也可进行动作拆分。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        else if(n <= 1) return nums[0];\n        return max(getdp(nums, 0, n - 1), getdp(nums, 1, n));\n    }\n\n    int getdp(vector<int> nums, int s, int e){\n        if(s >= e) return 0;\n        if(s + 2 <= e) //初始化\n            nums[s + 1] = max(nums[s], nums[s + 1]); \n        for(int i = s + 2; i < e; ++i){\n            nums[i] = max(nums[i - 2] + nums[i], nums[i - 1]);\n        }\n        return nums[e - 1];\n    }\n};\n```","slug":"刷题/DP/213-House-Robber-II","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2r000cl5uo60j36ge1","content":"<h2 id=\"213-House-Robber-II\"><a href=\"#213-House-Robber-II\" class=\"headerlink\" title=\"213. House Robber II\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">213. House Robber II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>首和尾的数字元素不能同时选择的。那么直接把列表拆分成两个$[0,…., n - 2]$和$[1,…..,n-1]$，分开DP就行了。</p>\n<p>使用$dp[i]$表示数组在元素$i$上所能获得的最大金钱。</p>\n<blockquote>\n<p>当然也可进行动作拆分。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        else if(n &lt;&#x3D; 1) return nums[0];\n        return max(getdp(nums, 0, n - 1), getdp(nums, 1, n));\n    &#125;\n\n    int getdp(vector&lt;int&gt; nums, int s, int e)&#123;\n        if(s &gt;&#x3D; e) return 0;\n        if(s + 2 &lt;&#x3D; e) &#x2F;&#x2F;初始化\n            nums[s + 1] &#x3D; max(nums[s], nums[s + 1]); \n        for(int i &#x3D; s + 2; i &lt; e; ++i)&#123;\n            nums[i] &#x3D; max(nums[i - 2] + nums[i], nums[i - 1]);\n        &#125;\n        return nums[e - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3SNS2F6","excerpt":"<h2 id=\"213-House-Robber-II\"><a href=\"#213-House-Robber-II\" class=\"headerlink\" title=\"213. House Robber II\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">213. House Robber II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>首和尾的数字元素不能同时选择的。那么直接把列表拆分成两个$[0,…., n - 2]$和$[1,…..,n-1]$，分开DP就行了。</p>\n<p>使用$dp[i]$表示数组在元素$i$上所能获得的最大金钱。</p>\n<blockquote>\n<p>当然也可进行动作拆分。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int rob(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        else if(n &lt;&#x3D; 1) return nums[0];\n        return max(getdp(nums, 0, n - 1), getdp(nums, 1, n));\n    &#125;\n\n    int getdp(vector&lt;int&gt; nums, int s, int e)&#123;\n        if(s &gt;&#x3D; e) return 0;\n        if(s + 2 &lt;&#x3D; e) &#x2F;&#x2F;初始化\n            nums[s + 1] &#x3D; max(nums[s], nums[s + 1]); \n        for(int i &#x3D; s + 2; i &lt; e; ++i)&#123;\n            nums[i] &#x3D; max(nums[i - 2] + nums[i], nums[i - 1]);\n        &#125;\n        return nums[e - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"221. Maximal Square","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-09T06:31:26.000Z","_content":"\n\n\n\n\n\n\n## [221. Maximal Square](https://leetcode-cn.com/problems/maximal-square/)\n\n## 思路：\n\n$dp[i][j]$为正方形的右下角。根据行列扩展或者三个正方形可以进行dp。\n\n<!-- more -->\n\n## 代码：\n\n\n\n思考不成熟的代码\n\n15%\n\n```c++\n\nclass Solution {\npublic:\n\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int n = matrix.size();\n        if(n == 0) return 0;\n        int m = matrix[0].size();\n        vector<vector<int>> row(n, vector<int>(m, 0));\n        vector<vector<int>> col(n, vector<int>(m, 0));\n        vector<vector<int>> squ(n, vector<int>(m, 0));\n        int maxarea = 0;\n        for(int i = 0;i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == '1'){                    \n                    row[i][j] = (i == 0) ? 1 : row[i - 1][j] + 1;\n                    col[i][j] = (j == 0) ? 1 : col[i][j - 1] + 1;\n                    int minsqu;\n                    if(i == 0 || j == 0 ) minsqu = 0;\n                    else minsqu = squ[i - 1][j - 1];\n\n                    int maxl = min(col[i][j], min(row[i][j], minsqu + 1));\n                    squ[i][j] = maxl;\n                    maxarea = max(maxarea, maxl * maxl);                \n                }else{\n                    row[i][j] = col[i][j] = squ[i][j] = 0;\n                }\n                // cout << i  << \" \" << j << squ[i][j] << endl;\n            }\n        }\n        return maxarea;\n    }\n};\n```\n\n\n\n真滴懒，再懒不能懒脑力。\n\n24%\n\n```c++\nclass Solution {\npublic:\n\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int n = matrix.size();\n        if(n == 0) return 0;\n        int m = matrix[0].size();\n        vector<vector<int>> squ(n, vector<int>(m, 0));\n        int maxarea = 1;\n        \n        for(int i = 0;i < n; ++i){\n            if(matrix[i][0] == '1') squ[i][0] = 1;\n            if(matrix[0][i] == '1') squ[0][i] = 1;\n        }\n        \n        for(int i = 1;i < n; ++i){\n            for(int j = 1; j < m; ++j){\n                if(matrix[i][j] == '1'){                                 \n                    int maxl = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                    squ[i][j] = maxl;\n                    maxarea = max(maxarea, maxl * maxl);                \n                }else{\n                    squ[i][j] = 0;\n                }\n                // cout << i  << \" \" << j << squ[i][j] << endl;\n            }\n        }\n        return maxarea;\n    }\n};\n```\n\n优化时间\n\n98%\n\n```c++\nclass Solution {\npublic:\n\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.empty()) return 0;\n        int n = matrix.size();        \n        int m = matrix[0].size();\n        vector<vector<int>> squ(n, vector<int>(m, 0));\n        int maxl = 0;        \n        for(int i = 0;i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == '1'){                                 \n                   if(i > 0 && j > 0){                        \n                        squ[i][j] = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                   }\n                   else squ[i][j] = 1;\n                   if(squ[i][j] >  maxl )\n                        maxl = squ[i][j];\n                }\n            }\n        }\n        return maxl * maxl;\n    }\n};\n```\n\n","source":"_posts/刷题/DP/221-Maximal-Square.md","raw":"---\ntitle: 221. Maximal Square\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-09 14:31:26\n---\n\n\n\n\n\n\n\n## [221. Maximal Square](https://leetcode-cn.com/problems/maximal-square/)\n\n## 思路：\n\n$dp[i][j]$为正方形的右下角。根据行列扩展或者三个正方形可以进行dp。\n\n<!-- more -->\n\n## 代码：\n\n\n\n思考不成熟的代码\n\n15%\n\n```c++\n\nclass Solution {\npublic:\n\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int n = matrix.size();\n        if(n == 0) return 0;\n        int m = matrix[0].size();\n        vector<vector<int>> row(n, vector<int>(m, 0));\n        vector<vector<int>> col(n, vector<int>(m, 0));\n        vector<vector<int>> squ(n, vector<int>(m, 0));\n        int maxarea = 0;\n        for(int i = 0;i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == '1'){                    \n                    row[i][j] = (i == 0) ? 1 : row[i - 1][j] + 1;\n                    col[i][j] = (j == 0) ? 1 : col[i][j - 1] + 1;\n                    int minsqu;\n                    if(i == 0 || j == 0 ) minsqu = 0;\n                    else minsqu = squ[i - 1][j - 1];\n\n                    int maxl = min(col[i][j], min(row[i][j], minsqu + 1));\n                    squ[i][j] = maxl;\n                    maxarea = max(maxarea, maxl * maxl);                \n                }else{\n                    row[i][j] = col[i][j] = squ[i][j] = 0;\n                }\n                // cout << i  << \" \" << j << squ[i][j] << endl;\n            }\n        }\n        return maxarea;\n    }\n};\n```\n\n\n\n真滴懒，再懒不能懒脑力。\n\n24%\n\n```c++\nclass Solution {\npublic:\n\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int n = matrix.size();\n        if(n == 0) return 0;\n        int m = matrix[0].size();\n        vector<vector<int>> squ(n, vector<int>(m, 0));\n        int maxarea = 1;\n        \n        for(int i = 0;i < n; ++i){\n            if(matrix[i][0] == '1') squ[i][0] = 1;\n            if(matrix[0][i] == '1') squ[0][i] = 1;\n        }\n        \n        for(int i = 1;i < n; ++i){\n            for(int j = 1; j < m; ++j){\n                if(matrix[i][j] == '1'){                                 \n                    int maxl = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                    squ[i][j] = maxl;\n                    maxarea = max(maxarea, maxl * maxl);                \n                }else{\n                    squ[i][j] = 0;\n                }\n                // cout << i  << \" \" << j << squ[i][j] << endl;\n            }\n        }\n        return maxarea;\n    }\n};\n```\n\n优化时间\n\n98%\n\n```c++\nclass Solution {\npublic:\n\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.empty()) return 0;\n        int n = matrix.size();        \n        int m = matrix[0].size();\n        vector<vector<int>> squ(n, vector<int>(m, 0));\n        int maxl = 0;        \n        for(int i = 0;i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == '1'){                                 \n                   if(i > 0 && j > 0){                        \n                        squ[i][j] = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                   }\n                   else squ[i][j] = 1;\n                   if(squ[i][j] >  maxl )\n                        maxl = squ[i][j];\n                }\n            }\n        }\n        return maxl * maxl;\n    }\n};\n```\n\n","slug":"刷题/DP/221-Maximal-Square","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2x000dl5uo39848qqe","content":"<h2 id=\"221-Maximal-Square\"><a href=\"#221-Maximal-Square\" class=\"headerlink\" title=\"221. Maximal Square\"></a><a href=\"https://leetcode-cn.com/problems/maximal-square/\">221. Maximal Square</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>$dp[i][j]$为正方形的右下角。根据行列扩展或者三个正方形可以进行dp。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>思考不成熟的代码</p>\n<p>15%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; row(n, vector&lt;int&gt;(m, 0));\n        vector&lt;vector&lt;int&gt;&gt; col(n, vector&lt;int&gt;(m, 0));\n        vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0));\n        int maxarea &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;                    \n                    row[i][j] &#x3D; (i &#x3D;&#x3D; 0) ? 1 : row[i - 1][j] + 1;\n                    col[i][j] &#x3D; (j &#x3D;&#x3D; 0) ? 1 : col[i][j - 1] + 1;\n                    int minsqu;\n                    if(i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0 ) minsqu &#x3D; 0;\n                    else minsqu &#x3D; squ[i - 1][j - 1];\n\n                    int maxl &#x3D; min(col[i][j], min(row[i][j], minsqu + 1));\n                    squ[i][j] &#x3D; maxl;\n                    maxarea &#x3D; max(maxarea, maxl * maxl);                \n                &#125;else&#123;\n                    row[i][j] &#x3D; col[i][j] &#x3D; squ[i][j] &#x3D; 0;\n                &#125;\n                &#x2F;&#x2F; cout &lt;&lt; i  &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl;\n            &#125;\n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>真滴懒，再懒不能懒脑力。</p>\n<p>24%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0));\n        int maxarea &#x3D; 1;\n        \n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(matrix[i][0] &#x3D;&#x3D; &#39;1&#39;) squ[i][0] &#x3D; 1;\n            if(matrix[0][i] &#x3D;&#x3D; &#39;1&#39;) squ[0][i] &#x3D; 1;\n        &#125;\n        \n        for(int i &#x3D; 1;i &lt; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;                                 \n                    int maxl &#x3D; min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                    squ[i][j] &#x3D; maxl;\n                    maxarea &#x3D; max(maxarea, maxl * maxl);                \n                &#125;else&#123;\n                    squ[i][j] &#x3D; 0;\n                &#125;\n                &#x2F;&#x2F; cout &lt;&lt; i  &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl;\n            &#125;\n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>优化时间</p>\n<p>98%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        if(matrix.empty()) return 0;\n        int n &#x3D; matrix.size();        \n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0));\n        int maxl &#x3D; 0;        \n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;                                 \n                   if(i &gt; 0 &amp;&amp; j &gt; 0)&#123;                        \n                        squ[i][j] &#x3D; min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                   &#125;\n                   else squ[i][j] &#x3D; 1;\n                   if(squ[i][j] &gt;  maxl )\n                        maxl &#x3D; squ[i][j];\n                &#125;\n            &#125;\n        &#125;\n        return maxl * maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2EEPQRJ","excerpt":"<h2 id=\"221-Maximal-Square\"><a href=\"#221-Maximal-Square\" class=\"headerlink\" title=\"221. Maximal Square\"></a><a href=\"https://leetcode-cn.com/problems/maximal-square/\">221. Maximal Square</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>$dp[i][j]$为正方形的右下角。根据行列扩展或者三个正方形可以进行dp。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>思考不成熟的代码</p>\n<p>15%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; row(n, vector&lt;int&gt;(m, 0));\n        vector&lt;vector&lt;int&gt;&gt; col(n, vector&lt;int&gt;(m, 0));\n        vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0));\n        int maxarea &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;                    \n                    row[i][j] &#x3D; (i &#x3D;&#x3D; 0) ? 1 : row[i - 1][j] + 1;\n                    col[i][j] &#x3D; (j &#x3D;&#x3D; 0) ? 1 : col[i][j - 1] + 1;\n                    int minsqu;\n                    if(i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0 ) minsqu &#x3D; 0;\n                    else minsqu &#x3D; squ[i - 1][j - 1];\n\n                    int maxl &#x3D; min(col[i][j], min(row[i][j], minsqu + 1));\n                    squ[i][j] &#x3D; maxl;\n                    maxarea &#x3D; max(maxarea, maxl * maxl);                \n                &#125;else&#123;\n                    row[i][j] &#x3D; col[i][j] &#x3D; squ[i][j] &#x3D; 0;\n                &#125;\n                &#x2F;&#x2F; cout &lt;&lt; i  &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl;\n            &#125;\n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>真滴懒，再懒不能懒脑力。</p>\n<p>24%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0));\n        int maxarea &#x3D; 1;\n        \n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(matrix[i][0] &#x3D;&#x3D; &#39;1&#39;) squ[i][0] &#x3D; 1;\n            if(matrix[0][i] &#x3D;&#x3D; &#39;1&#39;) squ[0][i] &#x3D; 1;\n        &#125;\n        \n        for(int i &#x3D; 1;i &lt; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;                                 \n                    int maxl &#x3D; min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                    squ[i][j] &#x3D; maxl;\n                    maxarea &#x3D; max(maxarea, maxl * maxl);                \n                &#125;else&#123;\n                    squ[i][j] &#x3D; 0;\n                &#125;\n                &#x2F;&#x2F; cout &lt;&lt; i  &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl;\n            &#125;\n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>优化时间</p>\n<p>98%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        if(matrix.empty()) return 0;\n        int n &#x3D; matrix.size();        \n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0));\n        int maxl &#x3D; 0;        \n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;                                 \n                   if(i &gt; 0 &amp;&amp; j &gt; 0)&#123;                        \n                        squ[i][j] &#x3D; min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1;\n                   &#125;\n                   else squ[i][j] &#x3D; 1;\n                   if(squ[i][j] &gt;  maxl )\n                        maxl &#x3D; squ[i][j];\n                &#125;\n            &#125;\n        &#125;\n        return maxl * maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"279. Perfect Squares","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-10T01:40:13.000Z","_content":"\n\n\n\n## [279. Perfect Squares](https://leetcode-cn.com/problems/perfect-squares/)\n\n## 思路：\n\n\n\n1. dp。均摊复杂度比较低\n2. 贪心算法，贪\n3. bfs+贪心\n\n<!-- more -->\n\n## 代码：\n\ndp\n\n66%\n\n```c++\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<long long> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for(long long i = 1; i <= n; ++i){\n            for(long long  j = 1; j * j <= i; ++j){\n                long long t = i - j * j;\n                dp[i] = min(dp[i], dp[t] + 1);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n贪心搜索\n\n70%\n\n```c++\nclass Solution {\npublic:\n    vector<long long> dp; //数字平方搜索值\n    int numSquares(int n) {\n        dp.resize(sqrt(n) + 1);\n        for(int  i = 1; i < dp.size(); ++i){\n            dp[i - 1] = i * i;\n        }\n        for(int i = 1; i <= n; ++i){\n            if(getLevel(n, i)) return i;\n        }\n        return 0;\n    }\n    bool getLevel(int n, int ssize){// ssize个平方数的和是否等于n\n        if(ssize == 1){ \n            if(count(dp.begin(), dp.end(), n) > 0) return true;        \n            return false;\n        }\n        for(int i = 0; i < dp.size(); ++i){\n            if(getLevel(n - dp[i], ssize - 1)) \n                return true;\n        }\n        return false;\n        \n    }\n};\n```\n\n\n\nbfs搜索\n\n17%……\n\nunordered_set的的损耗还是太大了吗\n\n```c++\nclass Solution {\npublic:\n    vector<long long> dp;\n    int numSquares(int n) {\n        dp.resize(sqrt(n) + 1);\n        for(int  i = 1; i < dp.size() + 1; ++i){\n            dp[i - 1] = i * i;\n        }\n        int level = 1;\n        unordered_set<int> que, next_que; //8%->17%\n        que.insert(n);\n        //层序遍历，整层树。\n        while(1){\n        }\n        return 0;\n    }\n   \tvoid search(unordered_set<int> que, unordered_set<int> next_que){        \n            for(auto t : que){                \n                for(int i = 0; i < dp.size() && dp[i] <= t ; ++i){\n                    // cout << t << \" \" << dp[i] << endl;                \n                    if(dp[i] == t) return level;\n                    next_que.insert(t - dp[i]);\n                }\n            }\n            level += 1;\n            que = next_que;\n            next_que.clear();\n    }\n\n};\n```\n\n再优化一下28%\n\n```c++\nclass Solution {\npublic:\n    vector<long long> dp;\n    int numSquares(int n) {\n        dp.resize(sqrt(n) + 1);\n        for(int  i = 1; i < dp.size() + 1; ++i){\n            dp[i - 1] = i * i;\n        }\n        int level = 1;\n        unordered_set<int> que1, que2; //8%->17%\n        que1.insert(n);\n        //层序遍历，整层树。\n        while(1){\n            if(level & 1){\n                if(search(que1, que2)) return level;\n            }else{\n                if(search(que2, que1)) return level;\n            } \n            level++;\n        }\n        return 0;\n    }\n   \tbool search(unordered_set<int> &que, unordered_set<int> &next_que){        \n            for(auto t : que){                \n                for(int i = 0; i < dp.size() && dp[i] <= t ; ++i){\n                    // cout << t << \" \" << dp[i] << endl;                \n                    if(dp[i] == t) return true;\n                    next_que.insert(t - dp[i]);\n                }\n            }\n            que.clear();\n            return false;\n    }\n\n};\n```\n\n","source":"_posts/刷题/DP/279-Perfect-Squares.md","raw":"---\ntitle: 279. Perfect Squares\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-10 09:40:13\n---\n\n\n\n\n## [279. Perfect Squares](https://leetcode-cn.com/problems/perfect-squares/)\n\n## 思路：\n\n\n\n1. dp。均摊复杂度比较低\n2. 贪心算法，贪\n3. bfs+贪心\n\n<!-- more -->\n\n## 代码：\n\ndp\n\n66%\n\n```c++\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<long long> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for(long long i = 1; i <= n; ++i){\n            for(long long  j = 1; j * j <= i; ++j){\n                long long t = i - j * j;\n                dp[i] = min(dp[i], dp[t] + 1);\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n贪心搜索\n\n70%\n\n```c++\nclass Solution {\npublic:\n    vector<long long> dp; //数字平方搜索值\n    int numSquares(int n) {\n        dp.resize(sqrt(n) + 1);\n        for(int  i = 1; i < dp.size(); ++i){\n            dp[i - 1] = i * i;\n        }\n        for(int i = 1; i <= n; ++i){\n            if(getLevel(n, i)) return i;\n        }\n        return 0;\n    }\n    bool getLevel(int n, int ssize){// ssize个平方数的和是否等于n\n        if(ssize == 1){ \n            if(count(dp.begin(), dp.end(), n) > 0) return true;        \n            return false;\n        }\n        for(int i = 0; i < dp.size(); ++i){\n            if(getLevel(n - dp[i], ssize - 1)) \n                return true;\n        }\n        return false;\n        \n    }\n};\n```\n\n\n\nbfs搜索\n\n17%……\n\nunordered_set的的损耗还是太大了吗\n\n```c++\nclass Solution {\npublic:\n    vector<long long> dp;\n    int numSquares(int n) {\n        dp.resize(sqrt(n) + 1);\n        for(int  i = 1; i < dp.size() + 1; ++i){\n            dp[i - 1] = i * i;\n        }\n        int level = 1;\n        unordered_set<int> que, next_que; //8%->17%\n        que.insert(n);\n        //层序遍历，整层树。\n        while(1){\n        }\n        return 0;\n    }\n   \tvoid search(unordered_set<int> que, unordered_set<int> next_que){        \n            for(auto t : que){                \n                for(int i = 0; i < dp.size() && dp[i] <= t ; ++i){\n                    // cout << t << \" \" << dp[i] << endl;                \n                    if(dp[i] == t) return level;\n                    next_que.insert(t - dp[i]);\n                }\n            }\n            level += 1;\n            que = next_que;\n            next_que.clear();\n    }\n\n};\n```\n\n再优化一下28%\n\n```c++\nclass Solution {\npublic:\n    vector<long long> dp;\n    int numSquares(int n) {\n        dp.resize(sqrt(n) + 1);\n        for(int  i = 1; i < dp.size() + 1; ++i){\n            dp[i - 1] = i * i;\n        }\n        int level = 1;\n        unordered_set<int> que1, que2; //8%->17%\n        que1.insert(n);\n        //层序遍历，整层树。\n        while(1){\n            if(level & 1){\n                if(search(que1, que2)) return level;\n            }else{\n                if(search(que2, que1)) return level;\n            } \n            level++;\n        }\n        return 0;\n    }\n   \tbool search(unordered_set<int> &que, unordered_set<int> &next_que){        \n            for(auto t : que){                \n                for(int i = 0; i < dp.size() && dp[i] <= t ; ++i){\n                    // cout << t << \" \" << dp[i] << endl;                \n                    if(dp[i] == t) return true;\n                    next_que.insert(t - dp[i]);\n                }\n            }\n            que.clear();\n            return false;\n    }\n\n};\n```\n\n","slug":"刷题/DP/279-Perfect-Squares","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j2z000el5uo44qx6ywa","content":"<h2 id=\"279-Perfect-Squares\"><a href=\"#279-Perfect-Squares\" class=\"headerlink\" title=\"279. Perfect Squares\"></a><a href=\"https://leetcode-cn.com/problems/perfect-squares/\">279. Perfect Squares</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp。均摊复杂度比较低</li>\n<li>贪心算法，贪</li>\n<li>bfs+贪心</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>dp</p>\n<p>66%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numSquares(int n) &#123;\n        vector&lt;long long&gt; dp(n + 1, INT_MAX);\n        dp[0] &#x3D; 0;\n        for(long long i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(long long  j &#x3D; 1; j * j &lt;&#x3D; i; ++j)&#123;\n                long long t &#x3D; i - j * j;\n                dp[i] &#x3D; min(dp[i], dp[t] + 1);\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>贪心搜索</p>\n<p>70%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;long long&gt; dp; &#x2F;&#x2F;数字平方搜索值\n    int numSquares(int n) &#123;\n        dp.resize(sqrt(n) + 1);\n        for(int  i &#x3D; 1; i &lt; dp.size(); ++i)&#123;\n            dp[i - 1] &#x3D; i * i;\n        &#125;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            if(getLevel(n, i)) return i;\n        &#125;\n        return 0;\n    &#125;\n    bool getLevel(int n, int ssize)&#123;&#x2F;&#x2F; ssize个平方数的和是否等于n\n        if(ssize &#x3D;&#x3D; 1)&#123; \n            if(count(dp.begin(), dp.end(), n) &gt; 0) return true;        \n            return false;\n        &#125;\n        for(int i &#x3D; 0; i &lt; dp.size(); ++i)&#123;\n            if(getLevel(n - dp[i], ssize - 1)) \n                return true;\n        &#125;\n        return false;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>bfs搜索</p>\n<p>17%……</p>\n<p>unordered_set的的损耗还是太大了吗</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;long long&gt; dp;\n    int numSquares(int n) &#123;\n        dp.resize(sqrt(n) + 1);\n        for(int  i &#x3D; 1; i &lt; dp.size() + 1; ++i)&#123;\n            dp[i - 1] &#x3D; i * i;\n        &#125;\n        int level &#x3D; 1;\n        unordered_set&lt;int&gt; que, next_que; &#x2F;&#x2F;8%-&gt;17%\n        que.insert(n);\n        &#x2F;&#x2F;层序遍历，整层树。\n        while(1)&#123;\n        &#125;\n        return 0;\n    &#125;\n   \tvoid search(unordered_set&lt;int&gt; que, unordered_set&lt;int&gt; next_que)&#123;        \n            for(auto t : que)&#123;                \n                for(int i &#x3D; 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;&#x3D; t ; ++i)&#123;\n                    &#x2F;&#x2F; cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl;                \n                    if(dp[i] &#x3D;&#x3D; t) return level;\n                    next_que.insert(t - dp[i]);\n                &#125;\n            &#125;\n            level +&#x3D; 1;\n            que &#x3D; next_que;\n            next_que.clear();\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再优化一下28%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;long long&gt; dp;\n    int numSquares(int n) &#123;\n        dp.resize(sqrt(n) + 1);\n        for(int  i &#x3D; 1; i &lt; dp.size() + 1; ++i)&#123;\n            dp[i - 1] &#x3D; i * i;\n        &#125;\n        int level &#x3D; 1;\n        unordered_set&lt;int&gt; que1, que2; &#x2F;&#x2F;8%-&gt;17%\n        que1.insert(n);\n        &#x2F;&#x2F;层序遍历，整层树。\n        while(1)&#123;\n            if(level &amp; 1)&#123;\n                if(search(que1, que2)) return level;\n            &#125;else&#123;\n                if(search(que2, que1)) return level;\n            &#125; \n            level++;\n        &#125;\n        return 0;\n    &#125;\n   \tbool search(unordered_set&lt;int&gt; &amp;que, unordered_set&lt;int&gt; &amp;next_que)&#123;        \n            for(auto t : que)&#123;                \n                for(int i &#x3D; 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;&#x3D; t ; ++i)&#123;\n                    &#x2F;&#x2F; cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl;                \n                    if(dp[i] &#x3D;&#x3D; t) return true;\n                    next_que.insert(t - dp[i]);\n                &#125;\n            &#125;\n            que.clear();\n            return false;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"20XAF5M","excerpt":"<h2 id=\"279-Perfect-Squares\"><a href=\"#279-Perfect-Squares\" class=\"headerlink\" title=\"279. Perfect Squares\"></a><a href=\"https://leetcode-cn.com/problems/perfect-squares/\">279. Perfect Squares</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp。均摊复杂度比较低</li>\n<li>贪心算法，贪</li>\n<li>bfs+贪心</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>dp</p>\n<p>66%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numSquares(int n) &#123;\n        vector&lt;long long&gt; dp(n + 1, INT_MAX);\n        dp[0] &#x3D; 0;\n        for(long long i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(long long  j &#x3D; 1; j * j &lt;&#x3D; i; ++j)&#123;\n                long long t &#x3D; i - j * j;\n                dp[i] &#x3D; min(dp[i], dp[t] + 1);\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>贪心搜索</p>\n<p>70%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;long long&gt; dp; &#x2F;&#x2F;数字平方搜索值\n    int numSquares(int n) &#123;\n        dp.resize(sqrt(n) + 1);\n        for(int  i &#x3D; 1; i &lt; dp.size(); ++i)&#123;\n            dp[i - 1] &#x3D; i * i;\n        &#125;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            if(getLevel(n, i)) return i;\n        &#125;\n        return 0;\n    &#125;\n    bool getLevel(int n, int ssize)&#123;&#x2F;&#x2F; ssize个平方数的和是否等于n\n        if(ssize &#x3D;&#x3D; 1)&#123; \n            if(count(dp.begin(), dp.end(), n) &gt; 0) return true;        \n            return false;\n        &#125;\n        for(int i &#x3D; 0; i &lt; dp.size(); ++i)&#123;\n            if(getLevel(n - dp[i], ssize - 1)) \n                return true;\n        &#125;\n        return false;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>bfs搜索</p>\n<p>17%……</p>\n<p>unordered_set的的损耗还是太大了吗</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;long long&gt; dp;\n    int numSquares(int n) &#123;\n        dp.resize(sqrt(n) + 1);\n        for(int  i &#x3D; 1; i &lt; dp.size() + 1; ++i)&#123;\n            dp[i - 1] &#x3D; i * i;\n        &#125;\n        int level &#x3D; 1;\n        unordered_set&lt;int&gt; que, next_que; &#x2F;&#x2F;8%-&gt;17%\n        que.insert(n);\n        &#x2F;&#x2F;层序遍历，整层树。\n        while(1)&#123;\n        &#125;\n        return 0;\n    &#125;\n   \tvoid search(unordered_set&lt;int&gt; que, unordered_set&lt;int&gt; next_que)&#123;        \n            for(auto t : que)&#123;                \n                for(int i &#x3D; 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;&#x3D; t ; ++i)&#123;\n                    &#x2F;&#x2F; cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl;                \n                    if(dp[i] &#x3D;&#x3D; t) return level;\n                    next_que.insert(t - dp[i]);\n                &#125;\n            &#125;\n            level +&#x3D; 1;\n            que &#x3D; next_que;\n            next_que.clear();\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再优化一下28%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;long long&gt; dp;\n    int numSquares(int n) &#123;\n        dp.resize(sqrt(n) + 1);\n        for(int  i &#x3D; 1; i &lt; dp.size() + 1; ++i)&#123;\n            dp[i - 1] &#x3D; i * i;\n        &#125;\n        int level &#x3D; 1;\n        unordered_set&lt;int&gt; que1, que2; &#x2F;&#x2F;8%-&gt;17%\n        que1.insert(n);\n        &#x2F;&#x2F;层序遍历，整层树。\n        while(1)&#123;\n            if(level &amp; 1)&#123;\n                if(search(que1, que2)) return level;\n            &#125;else&#123;\n                if(search(que2, que1)) return level;\n            &#125; \n            level++;\n        &#125;\n        return 0;\n    &#125;\n   \tbool search(unordered_set&lt;int&gt; &amp;que, unordered_set&lt;int&gt; &amp;next_que)&#123;        \n            for(auto t : que)&#123;                \n                for(int i &#x3D; 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;&#x3D; t ; ++i)&#123;\n                    &#x2F;&#x2F; cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl;                \n                    if(dp[i] &#x3D;&#x3D; t) return true;\n                    next_que.insert(t - dp[i]);\n                &#125;\n            &#125;\n            que.clear();\n            return false;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"300. Longest Increasing Subsequence","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-13T01:28:13.000Z","_content":"\n\n\n\n## [300. Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n\n\n\n## 思路：\n\n1. dp，复杂度$O(n^2)$。\n2. 贪心，用$d[i]$维护长度为i的子串结尾数字的最小值。在遍历的过程中更新，增长d[i]。同时d[i]的单调性，可轻松证明。$o(nlogn)$。\n\n> 如果求解的不是strictly increasing subsequence，只需要稍稍修改一下即可。\n\n<!-- more -->\n\n\n\n## 代码：\n\ndp\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> dp(n, 1);\n        int maxl = 1;\n        for(int  i = 1; i < n; i++){\n            for(int j = 0; j < i; ++j){\n                if(nums[j] < nums[i] && dp[j] + 1 > dp[i] ){\n                    dp[i] = dp[j] + 1;\n                    maxl = max(dp[i], maxl);\n                }\n            }\n        }\n        return maxl;\n    }\n};\n```\n\n\n\n贪心+二分\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> d;\n        int len = 0;\n        for(int i = 0;i < n; ++i){\n            if(len == 0 || d[len - 1] < nums[i]){\n                d.push_back(nums[i]);\n                len++;\n                // cout << len ;\n            }else{\n                auto it = lower_bound(d.begin(), d.end(), nums[i]);\n                if( *it > nums[i]){ //搜索第一个j，使得nums[j - 1]  < d[i] < nums[j],只需要两个条件lower_bound和大于号组合就行！\n                    *it = nums[i];                \n                }\n                \n            }\n        }\n        return len;\n    }\n};\n```","source":"_posts/刷题/DP/300-Longest-Increasing-Subsequence.md","raw":"---\ntitle: 300. Longest Increasing Subsequence\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-13 09:28:13\n---\n\n\n\n\n## [300. Longest Increasing Subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence/)\n\n\n\n## 思路：\n\n1. dp，复杂度$O(n^2)$。\n2. 贪心，用$d[i]$维护长度为i的子串结尾数字的最小值。在遍历的过程中更新，增长d[i]。同时d[i]的单调性，可轻松证明。$o(nlogn)$。\n\n> 如果求解的不是strictly increasing subsequence，只需要稍稍修改一下即可。\n\n<!-- more -->\n\n\n\n## 代码：\n\ndp\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> dp(n, 1);\n        int maxl = 1;\n        for(int  i = 1; i < n; i++){\n            for(int j = 0; j < i; ++j){\n                if(nums[j] < nums[i] && dp[j] + 1 > dp[i] ){\n                    dp[i] = dp[j] + 1;\n                    maxl = max(dp[i], maxl);\n                }\n            }\n        }\n        return maxl;\n    }\n};\n```\n\n\n\n贪心+二分\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> d;\n        int len = 0;\n        for(int i = 0;i < n; ++i){\n            if(len == 0 || d[len - 1] < nums[i]){\n                d.push_back(nums[i]);\n                len++;\n                // cout << len ;\n            }else{\n                auto it = lower_bound(d.begin(), d.end(), nums[i]);\n                if( *it > nums[i]){ //搜索第一个j，使得nums[j - 1]  < d[i] < nums[j],只需要两个条件lower_bound和大于号组合就行！\n                    *it = nums[i];                \n                }\n                \n            }\n        }\n        return len;\n    }\n};\n```","slug":"刷题/DP/300-Longest-Increasing-Subsequence","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j30000fl5uo3dqfd63x","content":"<h2 id=\"300-Longest-Increasing-Subsequence\"><a href=\"#300-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"300. Longest Increasing Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">300. Longest Increasing Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp，复杂度$O(n^2)$。</li>\n<li>贪心，用$d[i]$维护长度为i的子串结尾数字的最小值。在遍历的过程中更新，增长d[i]。同时d[i]的单调性，可轻松证明。$o(nlogn)$。</li>\n</ol>\n<blockquote>\n<p>如果求解的不是strictly increasing subsequence，只需要稍稍修改一下即可。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>dp</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp(n, 1);\n        int maxl &#x3D; 1;\n        for(int  i &#x3D; 1; i &lt; n; i++)&#123;\n            for(int j &#x3D; 0; j &lt; i; ++j)&#123;\n                if(nums[j] &lt; nums[i] &amp;&amp; dp[j] + 1 &gt; dp[i] )&#123;\n                    dp[i] &#x3D; dp[j] + 1;\n                    maxl &#x3D; max(dp[i], maxl);\n                &#125;\n            &#125;\n        &#125;\n        return maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>贪心+二分</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; d;\n        int len &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(len &#x3D;&#x3D; 0 || d[len - 1] &lt; nums[i])&#123;\n                d.push_back(nums[i]);\n                len++;\n                &#x2F;&#x2F; cout &lt;&lt; len ;\n            &#125;else&#123;\n                auto it &#x3D; lower_bound(d.begin(), d.end(), nums[i]);\n                if( *it &gt; nums[i])&#123; &#x2F;&#x2F;搜索第一个j，使得nums[j - 1]  &lt; d[i] &lt; nums[j],只需要两个条件lower_bound和大于号组合就行！\n                    *it &#x3D; nums[i];                \n                &#125;\n                \n            &#125;\n        &#125;\n        return len;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1RTDR76","excerpt":"<h2 id=\"300-Longest-Increasing-Subsequence\"><a href=\"#300-Longest-Increasing-Subsequence\" class=\"headerlink\" title=\"300. Longest Increasing Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">300. Longest Increasing Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp，复杂度$O(n^2)$。</li>\n<li>贪心，用$d[i]$维护长度为i的子串结尾数字的最小值。在遍历的过程中更新，增长d[i]。同时d[i]的单调性，可轻松证明。$o(nlogn)$。</li>\n</ol>\n<blockquote>\n<p>如果求解的不是strictly increasing subsequence，只需要稍稍修改一下即可。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>dp</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp(n, 1);\n        int maxl &#x3D; 1;\n        for(int  i &#x3D; 1; i &lt; n; i++)&#123;\n            for(int j &#x3D; 0; j &lt; i; ++j)&#123;\n                if(nums[j] &lt; nums[i] &amp;&amp; dp[j] + 1 &gt; dp[i] )&#123;\n                    dp[i] &#x3D; dp[j] + 1;\n                    maxl &#x3D; max(dp[i], maxl);\n                &#125;\n            &#125;\n        &#125;\n        return maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>贪心+二分</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; d;\n        int len &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(len &#x3D;&#x3D; 0 || d[len - 1] &lt; nums[i])&#123;\n                d.push_back(nums[i]);\n                len++;\n                &#x2F;&#x2F; cout &lt;&lt; len ;\n            &#125;else&#123;\n                auto it &#x3D; lower_bound(d.begin(), d.end(), nums[i]);\n                if( *it &gt; nums[i])&#123; &#x2F;&#x2F;搜索第一个j，使得nums[j - 1]  &lt; d[i] &lt; nums[j],只需要两个条件lower_bound和大于号组合就行！\n                    *it &#x3D; nums[i];                \n                &#125;\n                \n            &#125;\n        &#125;\n        return len;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"309. Best Time to Buy and Sell Stock with Cooldown","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-26T00:33:38.000Z","_content":"\n\n\n\n## [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n\n## 思路：\n\n无限购买，每个prices都可以设置为一个购买点。把状态按照已经购买状态$f[i][0]$、处于冷冻状态的刚卖出$f[i][1]$和不处于冷冻期的卖出状态$f[i][2]$，分成三个部分，可以写出dp转移方程：\n$$\n\\begin{split}\nf[i][0] &= max(f[i - 1][0], f[i - 1][2] - prices[i]) \\\\\\\\\nf[i][1] &= f[i - 1][0] + prices[i]\\\\\\\\\nf[i][2] &= max(f[i - 1][1],  f[i - 1][2]) \\\\\n\\end{split}\n$$\n初始化$f[0][0]= -prices[0]$，最后取结果$max(f[n-1])[1], f[n-1][2])$。\n\nDP状态方程巧妙在把一个状态拆分成不同的并行状态，同时在不同状态可以相互转移，自然的添加了一次购买，一次卖出，一次等待的限制。\n\n\n\n<!-- more -->\n\n>  ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int d = prices.size(); \n        if(d <= 1) return 0;\n        vector<vector<int>> dp(d, vector<int>(3));\n        dp[0][0] = -prices[0];\n        for(int i = 1; i < d; ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);\n            dp[i][1] = dp[i - 1][0] + prices[i];\n            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]);\n        }\n        return max(dp[d - 1][1], dp[d - 1][2]);\n    }\n};\n```","source":"_posts/刷题/DP/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown.md","raw":"---\ntitle: 309. Best Time to Buy and Sell Stock with Cooldown\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-26 08:33:38\n---\n\n\n\n\n## [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n\n## 思路：\n\n无限购买，每个prices都可以设置为一个购买点。把状态按照已经购买状态$f[i][0]$、处于冷冻状态的刚卖出$f[i][1]$和不处于冷冻期的卖出状态$f[i][2]$，分成三个部分，可以写出dp转移方程：\n$$\n\\begin{split}\nf[i][0] &= max(f[i - 1][0], f[i - 1][2] - prices[i]) \\\\\\\\\nf[i][1] &= f[i - 1][0] + prices[i]\\\\\\\\\nf[i][2] &= max(f[i - 1][1],  f[i - 1][2]) \\\\\n\\end{split}\n$$\n初始化$f[0][0]= -prices[0]$，最后取结果$max(f[n-1])[1], f[n-1][2])$。\n\nDP状态方程巧妙在把一个状态拆分成不同的并行状态，同时在不同状态可以相互转移，自然的添加了一次购买，一次卖出，一次等待的限制。\n\n\n\n<!-- more -->\n\n>  ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int d = prices.size(); \n        if(d <= 1) return 0;\n        vector<vector<int>> dp(d, vector<int>(3));\n        dp[0][0] = -prices[0];\n        for(int i = 1; i < d; ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);\n            dp[i][1] = dp[i - 1][0] + prices[i];\n            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]);\n        }\n        return max(dp[d - 1][1], dp[d - 1][2]);\n    }\n};\n```","slug":"刷题/DP/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j31000gl5uohfna98sv","content":"<h2 id=\"309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown\"><a href=\"#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown\" class=\"headerlink\" title=\"309. Best Time to Buy and Sell Stock with Cooldown\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">309. Best Time to Buy and Sell Stock with Cooldown</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>无限购买，每个prices都可以设置为一个购买点。把状态按照已经购买状态$f[i][0]$、处于冷冻状态的刚卖出$f[i][1]$和不处于冷冻期的卖出状态$f[i][2]$，分成三个部分，可以写出dp转移方程：<br>$$<br>\\begin{split}<br>f[i][0] &amp;= max(f[i - 1][0], f[i - 1][2] - prices[i]) \\\\<br>f[i][1] &amp;= f[i - 1][0] + prices[i]\\\\<br>f[i][2] &amp;= max(f[i - 1][1],  f[i - 1][2]) \\<br>\\end{split}<br>$$<br>初始化$f[0][0]= -prices[0]$，最后取结果$max(f[n-1])[1], f[n-1][2])$。</p>\n<p>DP状态方程巧妙在把一个状态拆分成不同的并行状态，同时在不同状态可以相互转移，自然的添加了一次购买，一次卖出，一次等待的限制。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p> <img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size(); \n        if(d &lt;&#x3D; 1) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(3));\n        dp[0][0] &#x3D; -prices[0];\n        for(int i &#x3D; 1; i &lt; d; ++i)&#123;\n            dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][2] - prices[i]);\n            dp[i][1] &#x3D; dp[i - 1][0] + prices[i];\n            dp[i][2] &#x3D; max(dp[i - 1][2], dp[i - 1][1]);\n        &#125;\n        return max(dp[d - 1][1], dp[d - 1][2]);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"V4CMCJ","excerpt":"<h2 id=\"309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown\"><a href=\"#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown\" class=\"headerlink\" title=\"309. Best Time to Buy and Sell Stock with Cooldown\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">309. Best Time to Buy and Sell Stock with Cooldown</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>无限购买，每个prices都可以设置为一个购买点。把状态按照已经购买状态$f[i][0]$、处于冷冻状态的刚卖出$f[i][1]$和不处于冷冻期的卖出状态$f[i][2]$，分成三个部分，可以写出dp转移方程：<br>$$<br>\\begin{split}<br>f[i][0] &amp;= max(f[i - 1][0], f[i - 1][2] - prices[i]) \\\\<br>f[i][1] &amp;= f[i - 1][0] + prices[i]\\\\<br>f[i][2] &amp;= max(f[i - 1][1],  f[i - 1][2]) \\<br>\\end{split}<br>$$<br>初始化$f[0][0]= -prices[0]$，最后取结果$max(f[n-1])[1], f[n-1][2])$。</p>\n<p>DP状态方程巧妙在把一个状态拆分成不同的并行状态，同时在不同状态可以相互转移，自然的添加了一次购买，一次卖出，一次等待的限制。</p>","more":"<blockquote>\n<p> <img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int d &#x3D; prices.size(); \n        if(d &lt;&#x3D; 1) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(3));\n        dp[0][0] &#x3D; -prices[0];\n        for(int i &#x3D; 1; i &lt; d; ++i)&#123;\n            dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][2] - prices[i]);\n            dp[i][1] &#x3D; dp[i - 1][0] + prices[i];\n            dp[i][2] &#x3D; max(dp[i - 1][2], dp[i - 1][1]);\n        &#125;\n        return max(dp[d - 1][1], dp[d - 1][2]);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"312. Burst Balloons","thumbnail":"http://static.come2rss.xyz/simptab-wallpaper-20201026154850.png","toc":true,"top":10,"date":"2021-05-05T06:50:56.000Z","_content":"\n\n\n\n\n# [312. Burst Balloons](https://leetcode-cn.com/problems/burst-balloons/)\n\n\n\n\n## 思路：\n\n `Hard`题做了才有收获啊！`lc`上题库里几道经典的具有锻炼思维和思考能力的题。\n\n1. 拿到手，首先映入脑海里明显应该是贪心或者分治算法：仔细思考一下，贪心发现没有依据，也没有例子；分治算法把考虑把求取问题`dp(l, r)`——开区间的`(l,r)`一组气球全部戳爆以后，可以获取最大金币数量。如果第一选取`k`个气球戳爆，则有子问题`(l,k)`和`(k,r)`，但是可以发现两个子问题是相互依赖的。也就是说一个问题解的选择会影响另一个问题的解的选择。所以这个思路也不行。\n\n2. `Amazing`的是，我们可以反过来考虑问题！我们把整个过程逆序，把戳爆存在的气球，变成从一个气球都不存在，添加一个个不存在的气球。`dp(l, r)`问题就是在寻找，把`(l, r)`中的所有位置填满气球，可以获得最大金币数量。思考一下如何分解为子问题：\n   $$\n   dp(l, r) = max_{i = l + 1}^{r - 1}[dp(l , i) + dp(i, r) + nums[i] * nums[l] * nums[r]]\n   $$\n   具体计算可以用记忆化搜索和DP计算。\n\n> 看了下大神的解法，居然还有用启发式搜索的！太顶了！\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n记忆化搜索（自顶向下搜索）：\n\n```c++\nclass Solution {\n    vector<vector<int>> dp;\n    int n = 0;\npublic:\n    int maxCoins(vector<int>& nums) {\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n = nums.size();\n        dp.resize(n, vector<int>(n));\n        search(nums, 0, n - 1);\n        return dp[0][n - 1];\n    }\n\n    int search(vector<int>&nums, int l, int r){ // find max coins in search scope (left, right).\n        \n        if(dp[l][r]) return dp[l][r];\n        int maxCoins = 0;\n        for(int i = l + 1; i < r; ++i){\n            int amount = search(nums, l, i) + search(nums, i, r) + nums[l] * nums[r] * nums[i];\n            maxCoins = max(maxCoins, amount);\n        }\n        return dp[l][r] = maxCoins;\n\n    }\n\n};\n```\n\n\n\nDP计算（自底向上搜索）：\n\n```c++\nclass Solution {\n    vector<vector<int>> dp;\n    int n = 0;\npublic:\n    int maxCoins(vector<int>& nums) {\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n = nums.size();\n        dp.resize(n, vector<int>(n)); // find max coins in search scope (left, right).\n\n        // for(int len = 1; len < n - 1; ++len){\n        //     for(int i = 0; i + len + 1 < n; ++i){\n        //         int j = i + len + 1;\n        //         for(int k = i + 1; k < j; ++k){\n        //             dp[i][j] = max(dp[i][j], \n        //                     dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);\n        //         }\n        //     }\n        // }\n        // 更Cache一点的写法应该是\n        for(int j = 2; j < n; ++j){\n            for(int i = j - 2; i >= 0; --i){\n                for(int k = j - 1; k > i; --k){ //从j出发更快~\n                // for(int k = i + 1; k < j; ++k){\n  \t\t\t\t\tdp[i][j] = max(dp[i][j], \n                            dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);                  \n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n\n};\n```\n\n> 考虑下`cache`优化计算过程","source":"_posts/刷题/DP/312-Burst-Balloons.md","raw":"---\ntitle: 312. Burst Balloons\nthumbnail: 'http://static.come2rss.xyz/simptab-wallpaper-20201026154850.png'\ntoc: true\ntop: 10\ndate: 2021-05-05 14:50:56\ntags:\ncategories:\n---\n\n\n\n\n\n# [312. Burst Balloons](https://leetcode-cn.com/problems/burst-balloons/)\n\n\n\n\n## 思路：\n\n `Hard`题做了才有收获啊！`lc`上题库里几道经典的具有锻炼思维和思考能力的题。\n\n1. 拿到手，首先映入脑海里明显应该是贪心或者分治算法：仔细思考一下，贪心发现没有依据，也没有例子；分治算法把考虑把求取问题`dp(l, r)`——开区间的`(l,r)`一组气球全部戳爆以后，可以获取最大金币数量。如果第一选取`k`个气球戳爆，则有子问题`(l,k)`和`(k,r)`，但是可以发现两个子问题是相互依赖的。也就是说一个问题解的选择会影响另一个问题的解的选择。所以这个思路也不行。\n\n2. `Amazing`的是，我们可以反过来考虑问题！我们把整个过程逆序，把戳爆存在的气球，变成从一个气球都不存在，添加一个个不存在的气球。`dp(l, r)`问题就是在寻找，把`(l, r)`中的所有位置填满气球，可以获得最大金币数量。思考一下如何分解为子问题：\n   $$\n   dp(l, r) = max_{i = l + 1}^{r - 1}[dp(l , i) + dp(i, r) + nums[i] * nums[l] * nums[r]]\n   $$\n   具体计算可以用记忆化搜索和DP计算。\n\n> 看了下大神的解法，居然还有用启发式搜索的！太顶了！\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n记忆化搜索（自顶向下搜索）：\n\n```c++\nclass Solution {\n    vector<vector<int>> dp;\n    int n = 0;\npublic:\n    int maxCoins(vector<int>& nums) {\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n = nums.size();\n        dp.resize(n, vector<int>(n));\n        search(nums, 0, n - 1);\n        return dp[0][n - 1];\n    }\n\n    int search(vector<int>&nums, int l, int r){ // find max coins in search scope (left, right).\n        \n        if(dp[l][r]) return dp[l][r];\n        int maxCoins = 0;\n        for(int i = l + 1; i < r; ++i){\n            int amount = search(nums, l, i) + search(nums, i, r) + nums[l] * nums[r] * nums[i];\n            maxCoins = max(maxCoins, amount);\n        }\n        return dp[l][r] = maxCoins;\n\n    }\n\n};\n```\n\n\n\nDP计算（自底向上搜索）：\n\n```c++\nclass Solution {\n    vector<vector<int>> dp;\n    int n = 0;\npublic:\n    int maxCoins(vector<int>& nums) {\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n = nums.size();\n        dp.resize(n, vector<int>(n)); // find max coins in search scope (left, right).\n\n        // for(int len = 1; len < n - 1; ++len){\n        //     for(int i = 0; i + len + 1 < n; ++i){\n        //         int j = i + len + 1;\n        //         for(int k = i + 1; k < j; ++k){\n        //             dp[i][j] = max(dp[i][j], \n        //                     dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);\n        //         }\n        //     }\n        // }\n        // 更Cache一点的写法应该是\n        for(int j = 2; j < n; ++j){\n            for(int i = j - 2; i >= 0; --i){\n                for(int k = j - 1; k > i; --k){ //从j出发更快~\n                // for(int k = i + 1; k < j; ++k){\n  \t\t\t\t\tdp[i][j] = max(dp[i][j], \n                            dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);                  \n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n\n};\n```\n\n> 考虑下`cache`优化计算过程","slug":"刷题/DP/312-Burst-Balloons","published":1,"updated":"2021-05-05T07:44:31.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j32000hl5uo99xehp4b","content":"<h1 id=\"312-Burst-Balloons\"><a href=\"#312-Burst-Balloons\" class=\"headerlink\" title=\"312. Burst Balloons\"></a><a href=\"https://leetcode-cn.com/problems/burst-balloons/\">312. Burst Balloons</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p> <code>Hard</code>题做了才有收获啊！<code>lc</code>上题库里几道经典的具有锻炼思维和思考能力的题。</p>\n<ol>\n<li><p>拿到手，首先映入脑海里明显应该是贪心或者分治算法：仔细思考一下，贪心发现没有依据，也没有例子；分治算法把考虑把求取问题<code>dp(l, r)</code>——开区间的<code>(l,r)</code>一组气球全部戳爆以后，可以获取最大金币数量。如果第一选取<code>k</code>个气球戳爆，则有子问题<code>(l,k)</code>和<code>(k,r)</code>，但是可以发现两个子问题是相互依赖的。也就是说一个问题解的选择会影响另一个问题的解的选择。所以这个思路也不行。</p>\n</li>\n<li><p><code>Amazing</code>的是，我们可以反过来考虑问题！我们把整个过程逆序，把戳爆存在的气球，变成从一个气球都不存在，添加一个个不存在的气球。<code>dp(l, r)</code>问题就是在寻找，把<code>(l, r)</code>中的所有位置填满气球，可以获得最大金币数量。思考一下如何分解为子问题：<br>$$<br>dp(l, r) = max_{i = l + 1}^{r - 1}[dp(l , i) + dp(i, r) + nums[i] * nums[l] * nums[r]]<br>$$<br>具体计算可以用记忆化搜索和DP计算。</p>\n</li>\n</ol>\n<blockquote>\n<p>看了下大神的解法，居然还有用启发式搜索的！太顶了！</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>记忆化搜索（自顶向下搜索）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int n &#x3D; 0;\npublic:\n    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n &#x3D; nums.size();\n        dp.resize(n, vector&lt;int&gt;(n));\n        search(nums, 0, n - 1);\n        return dp[0][n - 1];\n    &#125;\n\n    int search(vector&lt;int&gt;&amp;nums, int l, int r)&#123; &#x2F;&#x2F; find max coins in search scope (left, right).\n        \n        if(dp[l][r]) return dp[l][r];\n        int maxCoins &#x3D; 0;\n        for(int i &#x3D; l + 1; i &lt; r; ++i)&#123;\n            int amount &#x3D; search(nums, l, i) + search(nums, i, r) + nums[l] * nums[r] * nums[i];\n            maxCoins &#x3D; max(maxCoins, amount);\n        &#125;\n        return dp[l][r] &#x3D; maxCoins;\n\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>DP计算（自底向上搜索）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int n &#x3D; 0;\npublic:\n    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n &#x3D; nums.size();\n        dp.resize(n, vector&lt;int&gt;(n)); &#x2F;&#x2F; find max coins in search scope (left, right).\n\n        &#x2F;&#x2F; for(int len &#x3D; 1; len &lt; n - 1; ++len)&#123;\n        &#x2F;&#x2F;     for(int i &#x3D; 0; i + len + 1 &lt; n; ++i)&#123;\n        &#x2F;&#x2F;         int j &#x3D; i + len + 1;\n        &#x2F;&#x2F;         for(int k &#x3D; i + 1; k &lt; j; ++k)&#123;\n        &#x2F;&#x2F;             dp[i][j] &#x3D; max(dp[i][j], \n        &#x2F;&#x2F;                     dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);\n        &#x2F;&#x2F;         &#125;\n        &#x2F;&#x2F;     &#125;\n        &#x2F;&#x2F; &#125;\n        &#x2F;&#x2F; 更Cache一点的写法应该是\n        for(int j &#x3D; 2; j &lt; n; ++j)&#123;\n            for(int i &#x3D; j - 2; i &gt;&#x3D; 0; --i)&#123;\n                for(int k &#x3D; j - 1; k &gt; i; --k)&#123; &#x2F;&#x2F;从j出发更快~\n                &#x2F;&#x2F; for(int k &#x3D; i + 1; k &lt; j; ++k)&#123;\n  \t\t\t\t\tdp[i][j] &#x3D; max(dp[i][j], \n                            dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);                  \n                &#125;\n            &#125;\n        &#125;\n        return dp[0][n - 1];\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>考虑下<code>cache</code>优化计算过程</p>\n</blockquote>\n","site":{"data":{}},"abbrlink":"G4CWJ1","excerpt":"<h1 id=\"312-Burst-Balloons\"><a href=\"#312-Burst-Balloons\" class=\"headerlink\" title=\"312. Burst Balloons\"></a><a href=\"https://leetcode-cn.com/problems/burst-balloons/\">312. Burst Balloons</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p> <code>Hard</code>题做了才有收获啊！<code>lc</code>上题库里几道经典的具有锻炼思维和思考能力的题。</p>\n<ol>\n<li><p>拿到手，首先映入脑海里明显应该是贪心或者分治算法：仔细思考一下，贪心发现没有依据，也没有例子；分治算法把考虑把求取问题<code>dp(l, r)</code>——开区间的<code>(l,r)</code>一组气球全部戳爆以后，可以获取最大金币数量。如果第一选取<code>k</code>个气球戳爆，则有子问题<code>(l,k)</code>和<code>(k,r)</code>，但是可以发现两个子问题是相互依赖的。也就是说一个问题解的选择会影响另一个问题的解的选择。所以这个思路也不行。</p>\n</li>\n<li><p><code>Amazing</code>的是，我们可以反过来考虑问题！我们把整个过程逆序，把戳爆存在的气球，变成从一个气球都不存在，添加一个个不存在的气球。<code>dp(l, r)</code>问题就是在寻找，把<code>(l, r)</code>中的所有位置填满气球，可以获得最大金币数量。思考一下如何分解为子问题：<br>$$<br>dp(l, r) = max_{i = l + 1}^{r - 1}[dp(l , i) + dp(i, r) + nums[i] * nums[l] * nums[r]]<br>$$<br>具体计算可以用记忆化搜索和DP计算。</p>\n</li>\n</ol>\n<blockquote>\n<p>看了下大神的解法，居然还有用启发式搜索的！太顶了！</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>记忆化搜索（自顶向下搜索）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int n &#x3D; 0;\npublic:\n    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n &#x3D; nums.size();\n        dp.resize(n, vector&lt;int&gt;(n));\n        search(nums, 0, n - 1);\n        return dp[0][n - 1];\n    &#125;\n\n    int search(vector&lt;int&gt;&amp;nums, int l, int r)&#123; &#x2F;&#x2F; find max coins in search scope (left, right).\n        \n        if(dp[l][r]) return dp[l][r];\n        int maxCoins &#x3D; 0;\n        for(int i &#x3D; l + 1; i &lt; r; ++i)&#123;\n            int amount &#x3D; search(nums, l, i) + search(nums, i, r) + nums[l] * nums[r] * nums[i];\n            maxCoins &#x3D; max(maxCoins, amount);\n        &#125;\n        return dp[l][r] &#x3D; maxCoins;\n\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>DP计算（自底向上搜索）：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;vector&lt;int&gt;&gt; dp;\n    int n &#x3D; 0;\npublic:\n    int maxCoins(vector&lt;int&gt;&amp; nums) &#123;\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        n &#x3D; nums.size();\n        dp.resize(n, vector&lt;int&gt;(n)); &#x2F;&#x2F; find max coins in search scope (left, right).\n\n        &#x2F;&#x2F; for(int len &#x3D; 1; len &lt; n - 1; ++len)&#123;\n        &#x2F;&#x2F;     for(int i &#x3D; 0; i + len + 1 &lt; n; ++i)&#123;\n        &#x2F;&#x2F;         int j &#x3D; i + len + 1;\n        &#x2F;&#x2F;         for(int k &#x3D; i + 1; k &lt; j; ++k)&#123;\n        &#x2F;&#x2F;             dp[i][j] &#x3D; max(dp[i][j], \n        &#x2F;&#x2F;                     dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);\n        &#x2F;&#x2F;         &#125;\n        &#x2F;&#x2F;     &#125;\n        &#x2F;&#x2F; &#125;\n        &#x2F;&#x2F; 更Cache一点的写法应该是\n        for(int j &#x3D; 2; j &lt; n; ++j)&#123;\n            for(int i &#x3D; j - 2; i &gt;&#x3D; 0; --i)&#123;\n                for(int k &#x3D; j - 1; k &gt; i; --k)&#123; &#x2F;&#x2F;从j出发更快~\n                &#x2F;&#x2F; for(int k &#x3D; i + 1; k &lt; j; ++k)&#123;\n  \t\t\t\t\tdp[i][j] &#x3D; max(dp[i][j], \n                            dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);                  \n                &#125;\n            &#125;\n        &#125;\n        return dp[0][n - 1];\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>考虑下<code>cache</code>优化计算过程</p>\n</blockquote>"},{"title":"322. Coin Change","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-18T01:52:58.000Z","_content":"\n\n\n## [322. Coin Change](https://leetcode-cn.com/problems/coin-change/)\n\n## 思路：\n\n完全背包思路，注意一下初始值。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    const int INF =  INT_MAX / 2;\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount + 1, INF); // 简化 初始化为-1 不好利用min 过滤;使用条件 优化方向(dp[i]--)从初始条件（dp[i] = INF）开始，\n        // 也许更好的初始值是 amount + 2;\n        dp[0] = 0;\n        for(auto v : coins){\n            for(int i = v; i <= amount; ++i){\n                dp[i] = min(dp[i], dp[i - v] + 1);               \n            }\n        }\n        return dp[amount] == INF ? -1 : dp[amount];\n    }\n};\n```","source":"_posts/刷题/DP/322-Coin-Change.md","raw":"---\ntitle: 322. Coin Change\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-18 09:52:58\n---\n\n\n\n## [322. Coin Change](https://leetcode-cn.com/problems/coin-change/)\n\n## 思路：\n\n完全背包思路，注意一下初始值。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    const int INF =  INT_MAX / 2;\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount + 1, INF); // 简化 初始化为-1 不好利用min 过滤;使用条件 优化方向(dp[i]--)从初始条件（dp[i] = INF）开始，\n        // 也许更好的初始值是 amount + 2;\n        dp[0] = 0;\n        for(auto v : coins){\n            for(int i = v; i <= amount; ++i){\n                dp[i] = min(dp[i], dp[i - v] + 1);               \n            }\n        }\n        return dp[amount] == INF ? -1 : dp[amount];\n    }\n};\n```","slug":"刷题/DP/322-Coin-Change","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j33000il5uo07an2zza","content":"<h2 id=\"322-Coin-Change\"><a href=\"#322-Coin-Change\" class=\"headerlink\" title=\"322. Coin Change\"></a><a href=\"https://leetcode-cn.com/problems/coin-change/\">322. Coin Change</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>完全背包思路，注意一下初始值。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    const int INF &#x3D;  INT_MAX &#x2F; 2;\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        vector&lt;int&gt; dp(amount + 1, INF); &#x2F;&#x2F; 简化 初始化为-1 不好利用min 过滤;使用条件 优化方向(dp[i]--)从初始条件（dp[i] &#x3D; INF）开始，\n        &#x2F;&#x2F; 也许更好的初始值是 amount + 2;\n        dp[0] &#x3D; 0;\n        for(auto v : coins)&#123;\n            for(int i &#x3D; v; i &lt;&#x3D; amount; ++i)&#123;\n                dp[i] &#x3D; min(dp[i], dp[i - v] + 1);               \n            &#125;\n        &#125;\n        return dp[amount] &#x3D;&#x3D; INF ? -1 : dp[amount];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"M3GW7C","excerpt":"<h2 id=\"322-Coin-Change\"><a href=\"#322-Coin-Change\" class=\"headerlink\" title=\"322. Coin Change\"></a><a href=\"https://leetcode-cn.com/problems/coin-change/\">322. Coin Change</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>完全背包思路，注意一下初始值。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    const int INF &#x3D;  INT_MAX &#x2F; 2;\n    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;\n        vector&lt;int&gt; dp(amount + 1, INF); &#x2F;&#x2F; 简化 初始化为-1 不好利用min 过滤;使用条件 优化方向(dp[i]--)从初始条件（dp[i] &#x3D; INF）开始，\n        &#x2F;&#x2F; 也许更好的初始值是 amount + 2;\n        dp[0] &#x3D; 0;\n        for(auto v : coins)&#123;\n            for(int i &#x3D; v; i &lt;&#x3D; amount; ++i)&#123;\n                dp[i] &#x3D; min(dp[i], dp[i - v] + 1);               \n            &#125;\n        &#125;\n        return dp[amount] &#x3D;&#x3D; INF ? -1 : dp[amount];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"337. House Robber III","thumbnail":"http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png","toc":true,"top":10,"date":"2021-04-30T04:28:23.000Z","_content":"\n\n\n# [337. House Robber III](https://leetcode-cn.com/problems/house-robber-iii/)\n\n## 思路：\n\n这里的dp推错了，尴尬啊。\n\n一个简单的树上DP\n\n<!-- more -->\n\n## 代码：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    using tii =  tuple<int, int>;\npublic:\n    int rob(TreeNode* root) {\n        tii res = stelan(root);\n        return max(get<0>(res), get<1>(res));\n    }\n\n    tii stelan(TreeNode* root){\n        if(!root) return make_tuple(0, 0);\n        tii left = stelan(root->left);\n        tii right = stelan(root->right);\n        // dp 推导式： \n        // dp[i][0] = max(dp[i * 2][1], dp[i * 2][0]) +  max(dp[i * 2 + 1][1], dp[i * 2 + 1][0])\n        // dp[i][1] = val[i] + dp[i * 2][0] + dp[i * 2 + 1][0];\n        return make_tuple(max(get<0>(left), get<1>(left)) + max(get<0>(right), get<1>(right)),\n                         get<0>(left) + get<0>(right) + root->val);        \n    }\n};\n```\n\n","source":"_posts/刷题/DP/337-House-Robber-III.md","raw":"---\ntitle: 337. House Robber III\nthumbnail: 'http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png'\ntoc: true\ntop: 10\ndate: 2021-04-30 12:28:23\ntags:\ncategories:\n---\n\n\n\n# [337. House Robber III](https://leetcode-cn.com/problems/house-robber-iii/)\n\n## 思路：\n\n这里的dp推错了，尴尬啊。\n\n一个简单的树上DP\n\n<!-- more -->\n\n## 代码：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    using tii =  tuple<int, int>;\npublic:\n    int rob(TreeNode* root) {\n        tii res = stelan(root);\n        return max(get<0>(res), get<1>(res));\n    }\n\n    tii stelan(TreeNode* root){\n        if(!root) return make_tuple(0, 0);\n        tii left = stelan(root->left);\n        tii right = stelan(root->right);\n        // dp 推导式： \n        // dp[i][0] = max(dp[i * 2][1], dp[i * 2][0]) +  max(dp[i * 2 + 1][1], dp[i * 2 + 1][0])\n        // dp[i][1] = val[i] + dp[i * 2][0] + dp[i * 2 + 1][0];\n        return make_tuple(max(get<0>(left), get<1>(left)) + max(get<0>(right), get<1>(right)),\n                         get<0>(left) + get<0>(right) + root->val);        \n    }\n};\n```\n\n","slug":"刷题/DP/337-House-Robber-III","published":1,"updated":"2021-04-30T04:29:55.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j33000jl5uo373thcht","content":"<h1 id=\"337-House-Robber-III\"><a href=\"#337-House-Robber-III\" class=\"headerlink\" title=\"337. House Robber III\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-iii/\">337. House Robber III</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这里的dp推错了，尴尬啊。</p>\n<p>一个简单的树上DP</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    using tii &#x3D;  tuple&lt;int, int&gt;;\npublic:\n    int rob(TreeNode* root) &#123;\n        tii res &#x3D; stelan(root);\n        return max(get&lt;0&gt;(res), get&lt;1&gt;(res));\n    &#125;\n\n    tii stelan(TreeNode* root)&#123;\n        if(!root) return make_tuple(0, 0);\n        tii left &#x3D; stelan(root-&gt;left);\n        tii right &#x3D; stelan(root-&gt;right);\n        &#x2F;&#x2F; dp 推导式： \n        &#x2F;&#x2F; dp[i][0] &#x3D; max(dp[i * 2][1], dp[i * 2][0]) +  max(dp[i * 2 + 1][1], dp[i * 2 + 1][0])\n        &#x2F;&#x2F; dp[i][1] &#x3D; val[i] + dp[i * 2][0] + dp[i * 2 + 1][0];\n        return make_tuple(max(get&lt;0&gt;(left), get&lt;1&gt;(left)) + max(get&lt;0&gt;(right), get&lt;1&gt;(right)),\n                         get&lt;0&gt;(left) + get&lt;0&gt;(right) + root-&gt;val);        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"ME9XCD","excerpt":"<h1 id=\"337-House-Robber-III\"><a href=\"#337-House-Robber-III\" class=\"headerlink\" title=\"337. House Robber III\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-iii/\">337. House Robber III</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这里的dp推错了，尴尬啊。</p>\n<p>一个简单的树上DP</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    using tii &#x3D;  tuple&lt;int, int&gt;;\npublic:\n    int rob(TreeNode* root) &#123;\n        tii res &#x3D; stelan(root);\n        return max(get&lt;0&gt;(res), get&lt;1&gt;(res));\n    &#125;\n\n    tii stelan(TreeNode* root)&#123;\n        if(!root) return make_tuple(0, 0);\n        tii left &#x3D; stelan(root-&gt;left);\n        tii right &#x3D; stelan(root-&gt;right);\n        &#x2F;&#x2F; dp 推导式： \n        &#x2F;&#x2F; dp[i][0] &#x3D; max(dp[i * 2][1], dp[i * 2][0]) +  max(dp[i * 2 + 1][1], dp[i * 2 + 1][0])\n        &#x2F;&#x2F; dp[i][1] &#x3D; val[i] + dp[i * 2][0] + dp[i * 2 + 1][0];\n        return make_tuple(max(get&lt;0&gt;(left), get&lt;1&gt;(left)) + max(get&lt;0&gt;(right), get&lt;1&gt;(right)),\n                         get&lt;0&gt;(left) + get&lt;0&gt;(right) + root-&gt;val);        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"343. Integer Break","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-29T01:07:08.000Z","_content":"\n\n\n\n\n## [343. Integer Break](https://leetcode-cn.com/problems/integer-break/)\n\n## 思路：\n\n1. dp分解为两个和为n数字，求出最大积即可。\n\n2. [数学方法题解](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)\n\n   <!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> dp;\n    int getmaxdp(int k){\n        if(dp[k]) return dp[k];\n        int maxp = 0;\n        for(int i  = 1;i <= k / 2 ; i++){\n            maxp = max(maxp, max(i, getmaxdp(i)) \n            * max(k - i, getmaxdp(k - i)));\n            \n        }\n        dp[k] = maxp;\n        return maxp;\n    }\n\n    int integerBreak(int n) {\n        dp.resize(60);\n        dp[1] = 1;\n        dp[2] = 1;\n        return getmaxdp(n);\n    }\n};\n```\n\n更简洁的拆分方法\n\n```c++\nclass Solution {\npublic:\n    vector<int> dp;\n    int getmaxdp(int k){\n        if(dp[k]) return dp[k];\n        int maxp = 0;\n        for(int i  = 1;i < k ; i++){\n            maxp = max(maxp, max(i * (k - i), i * getmaxdp(k - i))); // 拆出一个整数作为因子\n        }\n        dp[k] = maxp;\n        return maxp;\n    }\n\n    int integerBreak(int n) {\n        dp.resize(60);\n        dp[1] = 1;\n        dp[2] = 1;\n        return getmaxdp(n);\n    }\n};\n```\n\n正向dp\n\n```c++\nclass Solution {\npublic:\n\n    int integerBreak(int n) {\n        vector<int> dp(60);\n        dp[1] = 1;\n        dp[2] = 1;\n        for(int i = 3; i <= n; ++i){\n            int cur = 1;\n            for(int j = 1; j < i; ++j){\n                cur = max(cur, max(j * (i - j), j * dp[i - j]));\n            }\n            dp[i] = cur;\n        }\n        return dp[n];\n    }\n};\n```\n\n数学方法\n\n```c++\nclass Solution {\npublic:\n\n    int integerBreak(int n) {\n        if(n < 4) return n - 1; // 2:1, 3:2\n        int res = 1;\n        while(n > 4){ // 尽量取3为分解因子\n            res *= 3;\n            n -= 3;\n        }\n        if(n == 4) res *= 4; // n % 3 == 1, 取一个4作为分解因子\n        else res *= n;\n        return res;\n    }\n};\n```","source":"_posts/刷题/DP/343-Integer-Break.md","raw":"---\ntitle: 343. Integer Break\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-29 09:07:08\n---\n\n\n\n\n\n## [343. Integer Break](https://leetcode-cn.com/problems/integer-break/)\n\n## 思路：\n\n1. dp分解为两个和为n数字，求出最大积即可。\n\n2. [数学方法题解](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)\n\n   <!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> dp;\n    int getmaxdp(int k){\n        if(dp[k]) return dp[k];\n        int maxp = 0;\n        for(int i  = 1;i <= k / 2 ; i++){\n            maxp = max(maxp, max(i, getmaxdp(i)) \n            * max(k - i, getmaxdp(k - i)));\n            \n        }\n        dp[k] = maxp;\n        return maxp;\n    }\n\n    int integerBreak(int n) {\n        dp.resize(60);\n        dp[1] = 1;\n        dp[2] = 1;\n        return getmaxdp(n);\n    }\n};\n```\n\n更简洁的拆分方法\n\n```c++\nclass Solution {\npublic:\n    vector<int> dp;\n    int getmaxdp(int k){\n        if(dp[k]) return dp[k];\n        int maxp = 0;\n        for(int i  = 1;i < k ; i++){\n            maxp = max(maxp, max(i * (k - i), i * getmaxdp(k - i))); // 拆出一个整数作为因子\n        }\n        dp[k] = maxp;\n        return maxp;\n    }\n\n    int integerBreak(int n) {\n        dp.resize(60);\n        dp[1] = 1;\n        dp[2] = 1;\n        return getmaxdp(n);\n    }\n};\n```\n\n正向dp\n\n```c++\nclass Solution {\npublic:\n\n    int integerBreak(int n) {\n        vector<int> dp(60);\n        dp[1] = 1;\n        dp[2] = 1;\n        for(int i = 3; i <= n; ++i){\n            int cur = 1;\n            for(int j = 1; j < i; ++j){\n                cur = max(cur, max(j * (i - j), j * dp[i - j]));\n            }\n            dp[i] = cur;\n        }\n        return dp[n];\n    }\n};\n```\n\n数学方法\n\n```c++\nclass Solution {\npublic:\n\n    int integerBreak(int n) {\n        if(n < 4) return n - 1; // 2:1, 3:2\n        int res = 1;\n        while(n > 4){ // 尽量取3为分解因子\n            res *= 3;\n            n -= 3;\n        }\n        if(n == 4) res *= 4; // n % 3 == 1, 取一个4作为分解因子\n        else res *= n;\n        return res;\n    }\n};\n```","slug":"刷题/DP/343-Integer-Break","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j34000kl5uo3mdlczr1","content":"<h2 id=\"343-Integer-Break\"><a href=\"#343-Integer-Break\" class=\"headerlink\" title=\"343. Integer Break\"></a><a href=\"https://leetcode-cn.com/problems/integer-break/\">343. Integer Break</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>dp分解为两个和为n数字，求出最大积即可。</p>\n</li>\n<li><p><a href=\"https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/\">数学方法题解</a></p>\n<span id=\"more\"></span>\n\n</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dp;\n    int getmaxdp(int k)&#123;\n        if(dp[k]) return dp[k];\n        int maxp &#x3D; 0;\n        for(int i  &#x3D; 1;i &lt;&#x3D; k &#x2F; 2 ; i++)&#123;\n            maxp &#x3D; max(maxp, max(i, getmaxdp(i)) \n            * max(k - i, getmaxdp(k - i)));\n            \n        &#125;\n        dp[k] &#x3D; maxp;\n        return maxp;\n    &#125;\n\n    int integerBreak(int n) &#123;\n        dp.resize(60);\n        dp[1] &#x3D; 1;\n        dp[2] &#x3D; 1;\n        return getmaxdp(n);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>更简洁的拆分方法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dp;\n    int getmaxdp(int k)&#123;\n        if(dp[k]) return dp[k];\n        int maxp &#x3D; 0;\n        for(int i  &#x3D; 1;i &lt; k ; i++)&#123;\n            maxp &#x3D; max(maxp, max(i * (k - i), i * getmaxdp(k - i))); &#x2F;&#x2F; 拆出一个整数作为因子\n        &#125;\n        dp[k] &#x3D; maxp;\n        return maxp;\n    &#125;\n\n    int integerBreak(int n) &#123;\n        dp.resize(60);\n        dp[1] &#x3D; 1;\n        dp[2] &#x3D; 1;\n        return getmaxdp(n);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>正向dp</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int integerBreak(int n) &#123;\n        vector&lt;int&gt; dp(60);\n        dp[1] &#x3D; 1;\n        dp[2] &#x3D; 1;\n        for(int i &#x3D; 3; i &lt;&#x3D; n; ++i)&#123;\n            int cur &#x3D; 1;\n            for(int j &#x3D; 1; j &lt; i; ++j)&#123;\n                cur &#x3D; max(cur, max(j * (i - j), j * dp[i - j]));\n            &#125;\n            dp[i] &#x3D; cur;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>数学方法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int integerBreak(int n) &#123;\n        if(n &lt; 4) return n - 1; &#x2F;&#x2F; 2:1, 3:2\n        int res &#x3D; 1;\n        while(n &gt; 4)&#123; &#x2F;&#x2F; 尽量取3为分解因子\n            res *&#x3D; 3;\n            n -&#x3D; 3;\n        &#125;\n        if(n &#x3D;&#x3D; 4) res *&#x3D; 4; &#x2F;&#x2F; n % 3 &#x3D;&#x3D; 1, 取一个4作为分解因子\n        else res *&#x3D; n;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"28G649R","excerpt":"<h2 id=\"343-Integer-Break\"><a href=\"#343-Integer-Break\" class=\"headerlink\" title=\"343. Integer Break\"></a><a href=\"https://leetcode-cn.com/problems/integer-break/\">343. Integer Break</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>dp分解为两个和为n数字，求出最大积即可。</p>\n</li>\n<li><p><a href=\"https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/\">数学方法题解</a></p>","more":"</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dp;\n    int getmaxdp(int k)&#123;\n        if(dp[k]) return dp[k];\n        int maxp &#x3D; 0;\n        for(int i  &#x3D; 1;i &lt;&#x3D; k &#x2F; 2 ; i++)&#123;\n            maxp &#x3D; max(maxp, max(i, getmaxdp(i)) \n            * max(k - i, getmaxdp(k - i)));\n            \n        &#125;\n        dp[k] &#x3D; maxp;\n        return maxp;\n    &#125;\n\n    int integerBreak(int n) &#123;\n        dp.resize(60);\n        dp[1] &#x3D; 1;\n        dp[2] &#x3D; 1;\n        return getmaxdp(n);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>更简洁的拆分方法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dp;\n    int getmaxdp(int k)&#123;\n        if(dp[k]) return dp[k];\n        int maxp &#x3D; 0;\n        for(int i  &#x3D; 1;i &lt; k ; i++)&#123;\n            maxp &#x3D; max(maxp, max(i * (k - i), i * getmaxdp(k - i))); &#x2F;&#x2F; 拆出一个整数作为因子\n        &#125;\n        dp[k] &#x3D; maxp;\n        return maxp;\n    &#125;\n\n    int integerBreak(int n) &#123;\n        dp.resize(60);\n        dp[1] &#x3D; 1;\n        dp[2] &#x3D; 1;\n        return getmaxdp(n);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>正向dp</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int integerBreak(int n) &#123;\n        vector&lt;int&gt; dp(60);\n        dp[1] &#x3D; 1;\n        dp[2] &#x3D; 1;\n        for(int i &#x3D; 3; i &lt;&#x3D; n; ++i)&#123;\n            int cur &#x3D; 1;\n            for(int j &#x3D; 1; j &lt; i; ++j)&#123;\n                cur &#x3D; max(cur, max(j * (i - j), j * dp[i - j]));\n            &#125;\n            dp[i] &#x3D; cur;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>数学方法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int integerBreak(int n) &#123;\n        if(n &lt; 4) return n - 1; &#x2F;&#x2F; 2:1, 3:2\n        int res &#x3D; 1;\n        while(n &gt; 4)&#123; &#x2F;&#x2F; 尽量取3为分解因子\n            res *&#x3D; 3;\n            n -&#x3D; 3;\n        &#125;\n        if(n &#x3D;&#x3D; 4) res *&#x3D; 4; &#x2F;&#x2F; n % 3 &#x3D;&#x3D; 1, 取一个4作为分解因子\n        else res *&#x3D; n;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"376. Wiggle Subsequence","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-31T02:20:30.000Z","_content":"\n\n\n\n## [376. Wiggle Subsequence](https://leetcode-cn.com/problems/wiggle-subsequence/)\n\n## 思路：\n\n\n\n注意边界，气死人。\n\n> 分析问题不够仔细透彻。\n\n <!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> up(n), down(n);\n        up[0] = down[0] = 1;\n        for(int i = 1; i < n; ++i){\n            if(nums[i] > nums[i - 1])\n                up[i] = max(down[i - 1] + 1, up[i - 1]);\n            else up[i] = up[i - 1];\n\n            if(nums[i] < nums[i - 1]) \n                down[i] = max(up[i - 1] + 1, down[i - 1]);\n            else down[i] = down[i - 1];\n        }\n        return max(up[n - 1], down[n - 1]);\n    }\n};\n```\n\n这道题也可以用贪心去做。取出最大波谷变化就可~","source":"_posts/刷题/DP/376-Wiggle-Subsequence.md","raw":"---\ntitle: 376. Wiggle Subsequence\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-31 10:20:30\n---\n\n\n\n\n## [376. Wiggle Subsequence](https://leetcode-cn.com/problems/wiggle-subsequence/)\n\n## 思路：\n\n\n\n注意边界，气死人。\n\n> 分析问题不够仔细透彻。\n\n <!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> up(n), down(n);\n        up[0] = down[0] = 1;\n        for(int i = 1; i < n; ++i){\n            if(nums[i] > nums[i - 1])\n                up[i] = max(down[i - 1] + 1, up[i - 1]);\n            else up[i] = up[i - 1];\n\n            if(nums[i] < nums[i - 1]) \n                down[i] = max(up[i - 1] + 1, down[i - 1]);\n            else down[i] = down[i - 1];\n        }\n        return max(up[n - 1], down[n - 1]);\n    }\n};\n```\n\n这道题也可以用贪心去做。取出最大波谷变化就可~","slug":"刷题/DP/376-Wiggle-Subsequence","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j35000ll5uobgczd39e","content":"<h2 id=\"376-Wiggle-Subsequence\"><a href=\"#376-Wiggle-Subsequence\" class=\"headerlink\" title=\"376. Wiggle Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/wiggle-subsequence/\">376. Wiggle Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>注意边界，气死人。</p>\n<blockquote>\n<p>分析问题不够仔细透彻。</p>\n</blockquote>\n <span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; up(n), down(n);\n        up[0] &#x3D; down[0] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            if(nums[i] &gt; nums[i - 1])\n                up[i] &#x3D; max(down[i - 1] + 1, up[i - 1]);\n            else up[i] &#x3D; up[i - 1];\n\n            if(nums[i] &lt; nums[i - 1]) \n                down[i] &#x3D; max(up[i - 1] + 1, down[i - 1]);\n            else down[i] &#x3D; down[i - 1];\n        &#125;\n        return max(up[n - 1], down[n - 1]);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这道题也可以用贪心去做。取出最大波谷变化就可~</p>\n","site":{"data":{}},"abbrlink":"QYW709","excerpt":"<h2 id=\"376-Wiggle-Subsequence\"><a href=\"#376-Wiggle-Subsequence\" class=\"headerlink\" title=\"376. Wiggle Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/wiggle-subsequence/\">376. Wiggle Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>注意边界，气死人。</p>\n<blockquote>\n<p>分析问题不够仔细透彻。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; up(n), down(n);\n        up[0] &#x3D; down[0] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            if(nums[i] &gt; nums[i - 1])\n                up[i] &#x3D; max(down[i - 1] + 1, up[i - 1]);\n            else up[i] &#x3D; up[i - 1];\n\n            if(nums[i] &lt; nums[i - 1]) \n                down[i] &#x3D; max(up[i - 1] + 1, down[i - 1]);\n            else down[i] &#x3D; down[i - 1];\n        &#125;\n        return max(up[n - 1], down[n - 1]);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这道题也可以用贪心去做。取出最大波谷变化就可~</p>"},{"title":"413. Arithmetic Slices 2刷","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-07T01:35:30.000Z","_content":"\n\n\n\n## [413. Arithmetic Slices](https://leetcode-cn.com/problems/arithmetic-slices/)\n\n\n\n## 思路：\n\n1. dp[i]以数字ith为结尾的最长arithmetic sequence的长度，（被包含的dp[k]==0）\n2. $dp[i]$以数字i th为结尾的arithmetic sequence的数目个数。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int  n = A.size();\n        vector<int> dp(n, 0);\n        if(n < 2) return 0;\n        for(int i = 2; i < n; ++i){\n            if(A[i - 1] - A[i - 2] == A[i] - A[i - 1]){\n                dp[i] = dp[i - 1] + 1; \n                dp[i - 1] = 0;                \n            }//\n        }\n        int res = 0;\n        for(int i = 2; i < n; ++i){\n            if(dp[i]){\n                res += (dp[i] +  1) * dp[i] / 2;\n            }\n        }\n        return res;\n    }\n};\n```\n\n也可以直接加\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        // vector<int> dp(A.size(), 0);\n        int sum = 0, lsum = 0;\n        \n        for(int i = 2; i < A.size(); i++){\n            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){                \n                lsum++;//长度为3，4，……，lsum的以A[i]为结尾的arithmetic sequence\n                sum += lsum;\n            }else lsum  = 0;\n// \n        }\n        return sum;\n    }\n};\n\n\n```","source":"_posts/刷题/DP/413-Arithmetic-Slices 2刷.md","raw":"---\ntitle: 413. Arithmetic Slices 2刷\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-07 09:35:30\n---\n\n\n\n\n## [413. Arithmetic Slices](https://leetcode-cn.com/problems/arithmetic-slices/)\n\n\n\n## 思路：\n\n1. dp[i]以数字ith为结尾的最长arithmetic sequence的长度，（被包含的dp[k]==0）\n2. $dp[i]$以数字i th为结尾的arithmetic sequence的数目个数。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int  n = A.size();\n        vector<int> dp(n, 0);\n        if(n < 2) return 0;\n        for(int i = 2; i < n; ++i){\n            if(A[i - 1] - A[i - 2] == A[i] - A[i - 1]){\n                dp[i] = dp[i - 1] + 1; \n                dp[i - 1] = 0;                \n            }//\n        }\n        int res = 0;\n        for(int i = 2; i < n; ++i){\n            if(dp[i]){\n                res += (dp[i] +  1) * dp[i] / 2;\n            }\n        }\n        return res;\n    }\n};\n```\n\n也可以直接加\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        // vector<int> dp(A.size(), 0);\n        int sum = 0, lsum = 0;\n        \n        for(int i = 2; i < A.size(); i++){\n            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){                \n                lsum++;//长度为3，4，……，lsum的以A[i]为结尾的arithmetic sequence\n                sum += lsum;\n            }else lsum  = 0;\n// \n        }\n        return sum;\n    }\n};\n\n\n```","slug":"刷题/DP/413-Arithmetic-Slices 2刷","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j36000ml5uodnlo0n6d","content":"<h2 id=\"413-Arithmetic-Slices\"><a href=\"#413-Arithmetic-Slices\" class=\"headerlink\" title=\"413. Arithmetic Slices\"></a><a href=\"https://leetcode-cn.com/problems/arithmetic-slices/\">413. Arithmetic Slices</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp[i]以数字ith为结尾的最长arithmetic sequence的长度，（被包含的dp[k]==0）</li>\n<li>$dp[i]$以数字i th为结尾的arithmetic sequence的数目个数。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        int  n &#x3D; A.size();\n        vector&lt;int&gt; dp(n, 0);\n        if(n &lt; 2) return 0;\n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(A[i - 1] - A[i - 2] &#x3D;&#x3D; A[i] - A[i - 1])&#123;\n                dp[i] &#x3D; dp[i - 1] + 1; \n                dp[i - 1] &#x3D; 0;                \n            &#125;&#x2F;&#x2F;\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(dp[i])&#123;\n                res +&#x3D; (dp[i] +  1) * dp[i] &#x2F; 2;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>也可以直接加</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        &#x2F;&#x2F; vector&lt;int&gt; dp(A.size(), 0);\n        int sum &#x3D; 0, lsum &#x3D; 0;\n        \n        for(int i &#x3D; 2; i &lt; A.size(); i++)&#123;\n            if(A[i] - A[i - 1] &#x3D;&#x3D; A[i - 1] - A[i - 2])&#123;                \n                lsum++;&#x2F;&#x2F;长度为3，4，……，lsum的以A[i]为结尾的arithmetic sequence\n                sum +&#x3D; lsum;\n            &#125;else lsum  &#x3D; 0;\n&#x2F;&#x2F; \n        &#125;\n        return sum;\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3D6XKBZ","excerpt":"<h2 id=\"413-Arithmetic-Slices\"><a href=\"#413-Arithmetic-Slices\" class=\"headerlink\" title=\"413. Arithmetic Slices\"></a><a href=\"https://leetcode-cn.com/problems/arithmetic-slices/\">413. Arithmetic Slices</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp[i]以数字ith为结尾的最长arithmetic sequence的长度，（被包含的dp[k]==0）</li>\n<li>$dp[i]$以数字i th为结尾的arithmetic sequence的数目个数。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        int  n &#x3D; A.size();\n        vector&lt;int&gt; dp(n, 0);\n        if(n &lt; 2) return 0;\n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(A[i - 1] - A[i - 2] &#x3D;&#x3D; A[i] - A[i - 1])&#123;\n                dp[i] &#x3D; dp[i - 1] + 1; \n                dp[i - 1] &#x3D; 0;                \n            &#125;&#x2F;&#x2F;\n        &#125;\n        int res &#x3D; 0;\n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(dp[i])&#123;\n                res +&#x3D; (dp[i] +  1) * dp[i] &#x2F; 2;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>也可以直接加</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        &#x2F;&#x2F; vector&lt;int&gt; dp(A.size(), 0);\n        int sum &#x3D; 0, lsum &#x3D; 0;\n        \n        for(int i &#x3D; 2; i &lt; A.size(); i++)&#123;\n            if(A[i] - A[i - 1] &#x3D;&#x3D; A[i - 1] - A[i - 2])&#123;                \n                lsum++;&#x2F;&#x2F;长度为3，4，……，lsum的以A[i]为结尾的arithmetic sequence\n                sum +&#x3D; lsum;\n            &#125;else lsum  &#x3D; 0;\n&#x2F;&#x2F; \n        &#125;\n        return sum;\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"413. Arithmetic Slices","thumbnail":"http://static.come2rss.xyz/北大西洋的大青鲨.jpg","toc":true,"top":10,"date":"2020-09-28T00:02:55.000Z","_content":"\n\n\n\n\n#### [413. Arithmetic Slices](https://leetcode-cn.com/problems/arithmetic-slices/)\n\n题目简单，倒是遇到一个bug：new一个size==0的数组会越界错误。\n\n<!-- more -->\n\nez\n\n\n\n## 思路：\n\ndp[i]表示以i为终点的arthmetic array的数量。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int *dp = new int[0];\n        int sum = 0;\n        memset(dp, 0, sizeof(dp));\n        for(int i = 2; i < A.size(); i++){\n            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){\n                dp[i] = dp[i - 1] + 1;                \n                sum += dp[i];\n            }\n        }\n        return sum;\n    }\n};\n\n\n// 3: 1\n// 4: 2 + 1  = 3\n// 5: 3 + 2 + 1 =6;\n```\n\n优化空间。\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        // vector<int> dp(A.size(), 0);\n        int sum = 0, lsum = 0;\n        \n        for(int i = 2; i < A.size(); i++){\n            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){                \n                lsum++;\n                sum += lsum;\n            }else lsum  = 0;\n// \n        }\n        return sum;\n    }\n};\n\n\n// 3: 1\n// 4: 2 + 1  = 3\n// 5: 3 + 2 + 1 =6;\n\n\n```\n\n","source":"_posts/刷题/DP/413-Arithmetic-Slices.md","raw":"---\ntitle: 413. Arithmetic Slices\nthumbnail: 'http://static.come2rss.xyz/北大西洋的大青鲨.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-09-28 08:02:55\n---\n\n\n\n\n\n#### [413. Arithmetic Slices](https://leetcode-cn.com/problems/arithmetic-slices/)\n\n题目简单，倒是遇到一个bug：new一个size==0的数组会越界错误。\n\n<!-- more -->\n\nez\n\n\n\n## 思路：\n\ndp[i]表示以i为终点的arthmetic array的数量。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int *dp = new int[0];\n        int sum = 0;\n        memset(dp, 0, sizeof(dp));\n        for(int i = 2; i < A.size(); i++){\n            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){\n                dp[i] = dp[i - 1] + 1;                \n                sum += dp[i];\n            }\n        }\n        return sum;\n    }\n};\n\n\n// 3: 1\n// 4: 2 + 1  = 3\n// 5: 3 + 2 + 1 =6;\n```\n\n优化空间。\n\n```c++\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        // vector<int> dp(A.size(), 0);\n        int sum = 0, lsum = 0;\n        \n        for(int i = 2; i < A.size(); i++){\n            if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){                \n                lsum++;\n                sum += lsum;\n            }else lsum  = 0;\n// \n        }\n        return sum;\n    }\n};\n\n\n// 3: 1\n// 4: 2 + 1  = 3\n// 5: 3 + 2 + 1 =6;\n\n\n```\n\n","slug":"刷题/DP/413-Arithmetic-Slices","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j39000nl5uo3e4l78c1","content":"<h4 id=\"413-Arithmetic-Slices\"><a href=\"#413-Arithmetic-Slices\" class=\"headerlink\" title=\"413. Arithmetic Slices\"></a><a href=\"https://leetcode-cn.com/problems/arithmetic-slices/\">413. Arithmetic Slices</a></h4><p>题目简单，倒是遇到一个bug：new一个size==0的数组会越界错误。</p>\n<span id=\"more\"></span>\n\n<p>ez</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dp[i]表示以i为终点的arthmetic array的数量。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        int *dp &#x3D; new int[0];\n        int sum &#x3D; 0;\n        memset(dp, 0, sizeof(dp));\n        for(int i &#x3D; 2; i &lt; A.size(); i++)&#123;\n            if(A[i] - A[i - 1] &#x3D;&#x3D; A[i - 1] - A[i - 2])&#123;\n                dp[i] &#x3D; dp[i - 1] + 1;                \n                sum +&#x3D; dp[i];\n            &#125;\n        &#125;\n        return sum;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; 3: 1\n&#x2F;&#x2F; 4: 2 + 1  &#x3D; 3\n&#x2F;&#x2F; 5: 3 + 2 + 1 &#x3D;6;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>优化空间。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        &#x2F;&#x2F; vector&lt;int&gt; dp(A.size(), 0);\n        int sum &#x3D; 0, lsum &#x3D; 0;\n        \n        for(int i &#x3D; 2; i &lt; A.size(); i++)&#123;\n            if(A[i] - A[i - 1] &#x3D;&#x3D; A[i - 1] - A[i - 2])&#123;                \n                lsum++;\n                sum +&#x3D; lsum;\n            &#125;else lsum  &#x3D; 0;\n&#x2F;&#x2F; \n        &#125;\n        return sum;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; 3: 1\n&#x2F;&#x2F; 4: 2 + 1  &#x3D; 3\n&#x2F;&#x2F; 5: 3 + 2 + 1 &#x3D;6;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"ZMEDKP","excerpt":"<h4 id=\"413-Arithmetic-Slices\"><a href=\"#413-Arithmetic-Slices\" class=\"headerlink\" title=\"413. Arithmetic Slices\"></a><a href=\"https://leetcode-cn.com/problems/arithmetic-slices/\">413. Arithmetic Slices</a></h4><p>题目简单，倒是遇到一个bug：new一个size==0的数组会越界错误。</p>","more":"<p>ez</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dp[i]表示以i为终点的arthmetic array的数量。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        int *dp &#x3D; new int[0];\n        int sum &#x3D; 0;\n        memset(dp, 0, sizeof(dp));\n        for(int i &#x3D; 2; i &lt; A.size(); i++)&#123;\n            if(A[i] - A[i - 1] &#x3D;&#x3D; A[i - 1] - A[i - 2])&#123;\n                dp[i] &#x3D; dp[i - 1] + 1;                \n                sum +&#x3D; dp[i];\n            &#125;\n        &#125;\n        return sum;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; 3: 1\n&#x2F;&#x2F; 4: 2 + 1  &#x3D; 3\n&#x2F;&#x2F; 5: 3 + 2 + 1 &#x3D;6;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>优化空间。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123;\n        &#x2F;&#x2F; vector&lt;int&gt; dp(A.size(), 0);\n        int sum &#x3D; 0, lsum &#x3D; 0;\n        \n        for(int i &#x3D; 2; i &lt; A.size(); i++)&#123;\n            if(A[i] - A[i - 1] &#x3D;&#x3D; A[i - 1] - A[i - 2])&#123;                \n                lsum++;\n                sum +&#x3D; lsum;\n            &#125;else lsum  &#x3D; 0;\n&#x2F;&#x2F; \n        &#125;\n        return sum;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F; 3: 1\n&#x2F;&#x2F; 4: 2 + 1  &#x3D; 3\n&#x2F;&#x2F; 5: 3 + 2 + 1 &#x3D;6;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"416. Partition Equal Subset Sum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-16T00:53:38.000Z","_content":"\n## [416. Partition Equal Subset Sum](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n## 思路\n\n类似01背包的题，不过不用考虑价值。\n\n<!-- more -->\n\n\n\n## 代码\n\n```c++\n\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n = nums.size();\n        int target = sum / 2;\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));\n        \n        for(int i = 0; i <= n; ++i){\n            dp[i][0] = 1;\n        }\n        for(int i = 1; i <= n; ++i){\n            for(int j = nums[i - 1]; j <= target; ++j){\n                dp[i][j] =  dp[i - 1][j - nums[i - 1]] || dp[i - 1][j];\n            }\n        }\n        return dp[n][target];\n    }\n};\n```\n\n空间压缩\n\n\n\n```c++\n\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n = nums.size();\n        int target = sum / 2;\n        vector<int> dp(target + 1, 0);    \n        dp[0] = 1;        \n        for(int i = 1; i <= n; ++i){\n            for(int j = target; j >= nums[i - 1]; --j){//逆序\n                dp[j] =  dp[j - nums[i - 1]] || dp[j];\n            }\n        }\n        return dp[target];\n    }\n};\n```","source":"_posts/刷题/DP/416-Partition-Equal-Subset-Sum.md","raw":"---\ntitle: 416. Partition Equal Subset Sum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-16 08:53:38\n---\n\n## [416. Partition Equal Subset Sum](https://leetcode-cn.com/problems/partition-equal-subset-sum/)\n\n## 思路\n\n类似01背包的题，不过不用考虑价值。\n\n<!-- more -->\n\n\n\n## 代码\n\n```c++\n\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n = nums.size();\n        int target = sum / 2;\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));\n        \n        for(int i = 0; i <= n; ++i){\n            dp[i][0] = 1;\n        }\n        for(int i = 1; i <= n; ++i){\n            for(int j = nums[i - 1]; j <= target; ++j){\n                dp[i][j] =  dp[i - 1][j - nums[i - 1]] || dp[i - 1][j];\n            }\n        }\n        return dp[n][target];\n    }\n};\n```\n\n空间压缩\n\n\n\n```c++\n\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n = nums.size();\n        int target = sum / 2;\n        vector<int> dp(target + 1, 0);    \n        dp[0] = 1;        \n        for(int i = 1; i <= n; ++i){\n            for(int j = target; j >= nums[i - 1]; --j){//逆序\n                dp[j] =  dp[j - nums[i - 1]] || dp[j];\n            }\n        }\n        return dp[target];\n    }\n};\n```","slug":"刷题/DP/416-Partition-Equal-Subset-Sum","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3a000ol5uo2ppf9pdr","content":"<h2 id=\"416-Partition-Equal-Subset-Sum\"><a href=\"#416-Partition-Equal-Subset-Sum\" class=\"headerlink\" title=\"416. Partition Equal Subset Sum\"></a><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">416. Partition Equal Subset Sum</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>类似01背包的题，不过不用考虑价值。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n &#x3D; nums.size();\n        int target &#x3D; sum &#x2F; 2;\n        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(target + 1, 0));\n        \n        for(int i &#x3D; 0; i &lt;&#x3D; n; ++i)&#123;\n            dp[i][0] &#x3D; 1;\n        &#125;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(int j &#x3D; nums[i - 1]; j &lt;&#x3D; target; ++j)&#123;\n                dp[i][j] &#x3D;  dp[i - 1][j - nums[i - 1]] || dp[i - 1][j];\n            &#125;\n        &#125;\n        return dp[n][target];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>空间压缩</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n &#x3D; nums.size();\n        int target &#x3D; sum &#x2F; 2;\n        vector&lt;int&gt; dp(target + 1, 0);    \n        dp[0] &#x3D; 1;        \n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(int j &#x3D; target; j &gt;&#x3D; nums[i - 1]; --j)&#123;&#x2F;&#x2F;逆序\n                dp[j] &#x3D;  dp[j - nums[i - 1]] || dp[j];\n            &#125;\n        &#125;\n        return dp[target];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2TNP62B","excerpt":"<h2 id=\"416-Partition-Equal-Subset-Sum\"><a href=\"#416-Partition-Equal-Subset-Sum\" class=\"headerlink\" title=\"416. Partition Equal Subset Sum\"></a><a href=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">416. Partition Equal Subset Sum</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>类似01背包的题，不过不用考虑价值。</p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n &#x3D; nums.size();\n        int target &#x3D; sum &#x2F; 2;\n        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(target + 1, 0));\n        \n        for(int i &#x3D; 0; i &lt;&#x3D; n; ++i)&#123;\n            dp[i][0] &#x3D; 1;\n        &#125;\n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(int j &#x3D; nums[i - 1]; j &lt;&#x3D; target; ++j)&#123;\n                dp[i][j] &#x3D;  dp[i - 1][j - nums[i - 1]] || dp[i - 1][j];\n            &#125;\n        &#125;\n        return dp[n][target];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>空间压缩</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;\n        int sum &#x3D; accumulate(nums.begin(), nums.end(), 0);\n        if(sum % 2) return false;\n        int n &#x3D; nums.size();\n        int target &#x3D; sum &#x2F; 2;\n        vector&lt;int&gt; dp(target + 1, 0);    \n        dp[0] &#x3D; 1;        \n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(int j &#x3D; target; j &gt;&#x3D; nums[i - 1]; --j)&#123;&#x2F;&#x2F;逆序\n                dp[j] &#x3D;  dp[j - nums[i - 1]] || dp[j];\n            &#125;\n        &#125;\n        return dp[target];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"474. Ones and Zeroes","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-18T01:30:19.000Z","_content":"\n\n\n\n## [474. Ones and Zeroes](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n## 思路：\n\n\n\n类似于01背包，但是不同 的是有两个范围限制。属于二维dp.\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        for(auto str : strs){\n            auto [c1, c2] = count(str);\n            for(int i = m; i >= c1; i--){\n                for(int j = n; j >= c2; j--){\n                    dp[i][j] = max(dp[i][j], dp[i - c1][j - c2] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n   }\n\n   pair<int, int> count(string str){\n       int c1 = 0, c2 = 0;\n       for(auto c : str){\n           if(c == '0') c1++;\n           else c2++;\n       }\n       return make_pair(c1, c2);\n   }\n};\n```","source":"_posts/刷题/DP/474-Ones-and-Zeroes.md","raw":"---\ntitle: 474. Ones and Zeroes\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-18 09:30:19\n---\n\n\n\n\n## [474. Ones and Zeroes](https://leetcode-cn.com/problems/ones-and-zeroes/)\n\n## 思路：\n\n\n\n类似于01背包，但是不同 的是有两个范围限制。属于二维dp.\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        for(auto str : strs){\n            auto [c1, c2] = count(str);\n            for(int i = m; i >= c1; i--){\n                for(int j = n; j >= c2; j--){\n                    dp[i][j] = max(dp[i][j], dp[i - c1][j - c2] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n   }\n\n   pair<int, int> count(string str){\n       int c1 = 0, c2 = 0;\n       for(auto c : str){\n           if(c == '0') c1++;\n           else c2++;\n       }\n       return make_pair(c1, c2);\n   }\n};\n```","slug":"刷题/DP/474-Ones-and-Zeroes","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3b000pl5uo8b45f38f","content":"<h2 id=\"474-Ones-and-Zeroes\"><a href=\"#474-Ones-and-Zeroes\" class=\"headerlink\" title=\"474. Ones and Zeroes\"></a><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\">474. Ones and Zeroes</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>类似于01背包，但是不同 的是有两个范围限制。属于二维dp.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n        for(auto str : strs)&#123;\n            auto [c1, c2] &#x3D; count(str);\n            for(int i &#x3D; m; i &gt;&#x3D; c1; i--)&#123;\n                for(int j &#x3D; n; j &gt;&#x3D; c2; j--)&#123;\n                    dp[i][j] &#x3D; max(dp[i][j], dp[i - c1][j - c2] + 1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[m][n];\n   &#125;\n\n   pair&lt;int, int&gt; count(string str)&#123;\n       int c1 &#x3D; 0, c2 &#x3D; 0;\n       for(auto c : str)&#123;\n           if(c &#x3D;&#x3D; &#39;0&#39;) c1++;\n           else c2++;\n       &#125;\n       return make_pair(c1, c2);\n   &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"12WMCH0","excerpt":"<h2 id=\"474-Ones-and-Zeroes\"><a href=\"#474-Ones-and-Zeroes\" class=\"headerlink\" title=\"474. Ones and Zeroes\"></a><a href=\"https://leetcode-cn.com/problems/ones-and-zeroes/\">474. Ones and Zeroes</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>类似于01背包，但是不同 的是有两个范围限制。属于二维dp.</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;\n        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n        for(auto str : strs)&#123;\n            auto [c1, c2] &#x3D; count(str);\n            for(int i &#x3D; m; i &gt;&#x3D; c1; i--)&#123;\n                for(int j &#x3D; n; j &gt;&#x3D; c2; j--)&#123;\n                    dp[i][j] &#x3D; max(dp[i][j], dp[i - c1][j - c2] + 1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[m][n];\n   &#125;\n\n   pair&lt;int, int&gt; count(string str)&#123;\n       int c1 &#x3D; 0, c2 &#x3D; 0;\n       for(auto c : str)&#123;\n           if(c &#x3D;&#x3D; &#39;0&#39;) c1++;\n           else c2++;\n       &#125;\n       return make_pair(c1, c2);\n   &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"494. Target Sum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-31T02:20:46.000Z","_content":"\n\n\n## [494. Target Sum](https://leetcode-cn.com/problems/target-sum/)\n\n\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        const int T = 2001;\n        if(nums.size() == 0) return 0;\n        int sum = 0;\n        for(auto v : nums) sum += abs(v);\n        if(sum < abs(S)) return 0;\n        int dp[23][T * 2]; //bugs: 20;\n        memset(dp, 0, sizeof(dp));\n\n        dp[0][T] = 1;\n        for(int i = 0; i < nums.size(); ++i){\n            for(int j = 0; j < T * 2; ++j){\n                if(dp[i][j]){\n                    dp[i + 1][j + nums[i]] += dp[i][j];\n                    dp[i + 1][j - nums[i]] += dp[i][j];\n        // cout << i + 1 << \" \"  << j + nums[i] <<  \" \" <<  dp[i + 1][j + nums[i]] << endl;\n        // cout << i + 1 << \" \"  << j - nums[i] <<  \" \" <<  dp[i + 1][j - nums[i]] << endl;\n                }\n            }\n            // cout << \"#\" << i <<endl;\n        }\n        return dp[nums.size()][S + T];\n    }\n};\n```","source":"_posts/刷题/DP/494-Target-Sum.md","raw":"---\ntitle: 494. Target Sum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-31 10:20:46\n---\n\n\n\n## [494. Target Sum](https://leetcode-cn.com/problems/target-sum/)\n\n\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int S) {\n        const int T = 2001;\n        if(nums.size() == 0) return 0;\n        int sum = 0;\n        for(auto v : nums) sum += abs(v);\n        if(sum < abs(S)) return 0;\n        int dp[23][T * 2]; //bugs: 20;\n        memset(dp, 0, sizeof(dp));\n\n        dp[0][T] = 1;\n        for(int i = 0; i < nums.size(); ++i){\n            for(int j = 0; j < T * 2; ++j){\n                if(dp[i][j]){\n                    dp[i + 1][j + nums[i]] += dp[i][j];\n                    dp[i + 1][j - nums[i]] += dp[i][j];\n        // cout << i + 1 << \" \"  << j + nums[i] <<  \" \" <<  dp[i + 1][j + nums[i]] << endl;\n        // cout << i + 1 << \" \"  << j - nums[i] <<  \" \" <<  dp[i + 1][j - nums[i]] << endl;\n                }\n            }\n            // cout << \"#\" << i <<endl;\n        }\n        return dp[nums.size()][S + T];\n    }\n};\n```","slug":"刷题/DP/494-Target-Sum","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3c000ql5uodj59gfp2","content":"<h2 id=\"494-Target-Sum\"><a href=\"#494-Target-Sum\" class=\"headerlink\" title=\"494. Target Sum\"></a><a href=\"https://leetcode-cn.com/problems/target-sum/\">494. Target Sum</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;\n        const int T &#x3D; 2001;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n        int sum &#x3D; 0;\n        for(auto v : nums) sum +&#x3D; abs(v);\n        if(sum &lt; abs(S)) return 0;\n        int dp[23][T * 2]; &#x2F;&#x2F;bugs: 20;\n        memset(dp, 0, sizeof(dp));\n\n        dp[0][T] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            for(int j &#x3D; 0; j &lt; T * 2; ++j)&#123;\n                if(dp[i][j])&#123;\n                    dp[i + 1][j + nums[i]] +&#x3D; dp[i][j];\n                    dp[i + 1][j - nums[i]] +&#x3D; dp[i][j];\n        &#x2F;&#x2F; cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;  &lt;&lt; j + nums[i] &lt;&lt;  &quot; &quot; &lt;&lt;  dp[i + 1][j + nums[i]] &lt;&lt; endl;\n        &#x2F;&#x2F; cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;  &lt;&lt; j - nums[i] &lt;&lt;  &quot; &quot; &lt;&lt;  dp[i + 1][j - nums[i]] &lt;&lt; endl;\n                &#125;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; &quot;#&quot; &lt;&lt; i &lt;&lt;endl;\n        &#125;\n        return dp[nums.size()][S + T];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"22BYQ0X","excerpt":"<h2 id=\"494-Target-Sum\"><a href=\"#494-Target-Sum\" class=\"headerlink\" title=\"494. Target Sum\"></a><a href=\"https://leetcode-cn.com/problems/target-sum/\">494. Target Sum</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123;\n        const int T &#x3D; 2001;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n        int sum &#x3D; 0;\n        for(auto v : nums) sum +&#x3D; abs(v);\n        if(sum &lt; abs(S)) return 0;\n        int dp[23][T * 2]; &#x2F;&#x2F;bugs: 20;\n        memset(dp, 0, sizeof(dp));\n\n        dp[0][T] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            for(int j &#x3D; 0; j &lt; T * 2; ++j)&#123;\n                if(dp[i][j])&#123;\n                    dp[i + 1][j + nums[i]] +&#x3D; dp[i][j];\n                    dp[i + 1][j - nums[i]] +&#x3D; dp[i][j];\n        &#x2F;&#x2F; cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;  &lt;&lt; j + nums[i] &lt;&lt;  &quot; &quot; &lt;&lt;  dp[i + 1][j + nums[i]] &lt;&lt; endl;\n        &#x2F;&#x2F; cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;  &lt;&lt; j - nums[i] &lt;&lt;  &quot; &quot; &lt;&lt;  dp[i + 1][j - nums[i]] &lt;&lt; endl;\n                &#125;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; &quot;#&quot; &lt;&lt; i &lt;&lt;endl;\n        &#125;\n        return dp[nums.size()][S + T];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"53. Maximum Subarray","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-28T07:41:34.000Z","_content":"\n\n\n\n\n## [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)\n\n\n\n## 思路：\n\n1. dp\n2. 线段树区间查询\n\n<!-- more -->\n\n以下的题解，摘录自LeetCode：\n\n\n\n![image-20201228154320926](http://static.come2rss.xyz/image-20201228154320926.png)\n\n![image-20201228154336934](http://static.come2rss.xyz/image-20201228154336934.png)\n\n![image-20201228154406542](http://static.come2rss.xyz/image-20201228154406542.png)\n\n\n\n> 上面的时间渐进上界大概是$o(2N)$。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        if(n <= 0 ) return 0;\n        int maxsum = nums[0];\n        int adds = 0;\n        for(int i = 0;i < n; ++i){\n            adds += nums[i];\n            maxsum = max(maxsum, adds);\n            if(adds < 0){\n                adds = 0;\n            }\n        }\n        return maxsum;\n\n    }\n};\n```\n\n线段树多段查询\n\n```c++\nclass Solution {\npublic:\n    struct sts{\n        \n        int msum, isum, lsum, rsum;\n    };\n\n    sts pushup(sts l, sts r){\n        sts a; \n        a.msum = max(max(l.msum, r.msum), l.rsum + r.lsum);\n        a.lsum = max(l.isum + r.lsum, l.lsum);\n        a.rsum = max(r.isum + l.rsum, r.rsum);\n        a.isum = l.isum + r.isum;\n        return (sts){a.msum, a.isum, a.lsum, a.rsum};\n    }\n\n    sts get(vector<int> &nums, int l, int r){\n        if(r == l){\n            return (sts){nums[r], nums[r], nums[r], nums[r]};\n        }\n        int m = (r + l) >> 1;\n        sts a = get(nums, l, m);\n        sts b = get(nums, m + 1, r);\n        return pushup(a, b);\n    }\n    int maxSubArray(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n        return get(nums, 0, nums.size() - 1).msum;\n\n    }\n};\n```","source":"_posts/刷题/DP/53-Maximum-Subarray.md","raw":"---\ntitle: 53. Maximum Subarray\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-28 15:41:34\n---\n\n\n\n\n\n## [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)\n\n\n\n## 思路：\n\n1. dp\n2. 线段树区间查询\n\n<!-- more -->\n\n以下的题解，摘录自LeetCode：\n\n\n\n![image-20201228154320926](http://static.come2rss.xyz/image-20201228154320926.png)\n\n![image-20201228154336934](http://static.come2rss.xyz/image-20201228154336934.png)\n\n![image-20201228154406542](http://static.come2rss.xyz/image-20201228154406542.png)\n\n\n\n> 上面的时间渐进上界大概是$o(2N)$。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        if(n <= 0 ) return 0;\n        int maxsum = nums[0];\n        int adds = 0;\n        for(int i = 0;i < n; ++i){\n            adds += nums[i];\n            maxsum = max(maxsum, adds);\n            if(adds < 0){\n                adds = 0;\n            }\n        }\n        return maxsum;\n\n    }\n};\n```\n\n线段树多段查询\n\n```c++\nclass Solution {\npublic:\n    struct sts{\n        \n        int msum, isum, lsum, rsum;\n    };\n\n    sts pushup(sts l, sts r){\n        sts a; \n        a.msum = max(max(l.msum, r.msum), l.rsum + r.lsum);\n        a.lsum = max(l.isum + r.lsum, l.lsum);\n        a.rsum = max(r.isum + l.rsum, r.rsum);\n        a.isum = l.isum + r.isum;\n        return (sts){a.msum, a.isum, a.lsum, a.rsum};\n    }\n\n    sts get(vector<int> &nums, int l, int r){\n        if(r == l){\n            return (sts){nums[r], nums[r], nums[r], nums[r]};\n        }\n        int m = (r + l) >> 1;\n        sts a = get(nums, l, m);\n        sts b = get(nums, m + 1, r);\n        return pushup(a, b);\n    }\n    int maxSubArray(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n        return get(nums, 0, nums.size() - 1).msum;\n\n    }\n};\n```","slug":"刷题/DP/53-Maximum-Subarray","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3d000rl5uocs2qg76x","content":"<h2 id=\"53-Maximum-Subarray\"><a href=\"#53-Maximum-Subarray\" class=\"headerlink\" title=\"53. Maximum Subarray\"></a><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\">53. Maximum Subarray</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp</li>\n<li>线段树区间查询</li>\n</ol>\n<span id=\"more\"></span>\n\n<p>以下的题解，摘录自LeetCode：</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201228154320926.png\" alt=\"image-20201228154320926\"></p>\n<p><img src=\"http://static.come2rss.xyz/image-20201228154336934.png\" alt=\"image-20201228154336934\"></p>\n<p><img src=\"http://static.come2rss.xyz/image-20201228154406542.png\" alt=\"image-20201228154406542\"></p>\n<blockquote>\n<p>上面的时间渐进上界大概是$o(2N)$。</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &lt;&#x3D; 0 ) return 0;\n        int maxsum &#x3D; nums[0];\n        int adds &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            adds +&#x3D; nums[i];\n            maxsum &#x3D; max(maxsum, adds);\n            if(adds &lt; 0)&#123;\n                adds &#x3D; 0;\n            &#125;\n        &#125;\n        return maxsum;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线段树多段查询</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    struct sts&#123;\n        \n        int msum, isum, lsum, rsum;\n    &#125;;\n\n    sts pushup(sts l, sts r)&#123;\n        sts a; \n        a.msum &#x3D; max(max(l.msum, r.msum), l.rsum + r.lsum);\n        a.lsum &#x3D; max(l.isum + r.lsum, l.lsum);\n        a.rsum &#x3D; max(r.isum + l.rsum, r.rsum);\n        a.isum &#x3D; l.isum + r.isum;\n        return (sts)&#123;a.msum, a.isum, a.lsum, a.rsum&#125;;\n    &#125;\n\n    sts get(vector&lt;int&gt; &amp;nums, int l, int r)&#123;\n        if(r &#x3D;&#x3D; l)&#123;\n            return (sts)&#123;nums[r], nums[r], nums[r], nums[r]&#125;;\n        &#125;\n        int m &#x3D; (r + l) &gt;&gt; 1;\n        sts a &#x3D; get(nums, l, m);\n        sts b &#x3D; get(nums, m + 1, r);\n        return pushup(a, b);\n    &#125;\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n        return get(nums, 0, nums.size() - 1).msum;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1V1F5J3","excerpt":"<h2 id=\"53-Maximum-Subarray\"><a href=\"#53-Maximum-Subarray\" class=\"headerlink\" title=\"53. Maximum Subarray\"></a><a href=\"https://leetcode-cn.com/problems/maximum-subarray/\">53. Maximum Subarray</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dp</li>\n<li>线段树区间查询</li>\n</ol>","more":"<p>以下的题解，摘录自LeetCode：</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201228154320926.png\" alt=\"image-20201228154320926\"></p>\n<p><img src=\"http://static.come2rss.xyz/image-20201228154336934.png\" alt=\"image-20201228154336934\"></p>\n<p><img src=\"http://static.come2rss.xyz/image-20201228154406542.png\" alt=\"image-20201228154406542\"></p>\n<blockquote>\n<p>上面的时间渐进上界大概是$o(2N)$。</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &lt;&#x3D; 0 ) return 0;\n        int maxsum &#x3D; nums[0];\n        int adds &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            adds +&#x3D; nums[i];\n            maxsum &#x3D; max(maxsum, adds);\n            if(adds &lt; 0)&#123;\n                adds &#x3D; 0;\n            &#125;\n        &#125;\n        return maxsum;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线段树多段查询</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    struct sts&#123;\n        \n        int msum, isum, lsum, rsum;\n    &#125;;\n\n    sts pushup(sts l, sts r)&#123;\n        sts a; \n        a.msum &#x3D; max(max(l.msum, r.msum), l.rsum + r.lsum);\n        a.lsum &#x3D; max(l.isum + r.lsum, l.lsum);\n        a.rsum &#x3D; max(r.isum + l.rsum, r.rsum);\n        a.isum &#x3D; l.isum + r.isum;\n        return (sts)&#123;a.msum, a.isum, a.lsum, a.rsum&#125;;\n    &#125;\n\n    sts get(vector&lt;int&gt; &amp;nums, int l, int r)&#123;\n        if(r &#x3D;&#x3D; l)&#123;\n            return (sts)&#123;nums[r], nums[r], nums[r], nums[r]&#125;;\n        &#125;\n        int m &#x3D; (r + l) &gt;&gt; 1;\n        sts a &#x3D; get(nums, l, m);\n        sts b &#x3D; get(nums, m + 1, r);\n        return pushup(a, b);\n    &#125;\n    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n        return get(nums, 0, nums.size() - 1).msum;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"542. 01 Matrix","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-08T00:55:46.000Z","_content":"\n\n\n\n\n## [542. 01 Matrix](https://leetcode-cn.com/problems/01-matrix/)\n\n## 思路：\n\n1. 从数字0开始bfs到1的最短路\n2. 由于从数字1到最近的数字零之间的最短路径，如果不是相邻，那么必定有在路径上数字1到同样的数字0有一条最短路径。如此便可以在四个移动方向上分别dp最短路径长度即可。\n\n<!-- more -->\n\n## 代码：\n\nbfs\n\n66%\n\n```c++\nclass Solution {\npublic:\n    int dx[4] = {0, 0, -1, 1};\n    int dy[4] = {-1, 1, 0, 0};\n\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> dis(n, vector<int>(m , 0));\n        vector<vector<int>> vis(n, vector<int>(m, 0));\n        queue<pair<int,int>> que;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == 0){\n                    que.push(make_pair(i ,j));\n                    vis[i][j] = 1;\n                }                    \n            }\n        }\n        int qsize;\n        while(que.size()){\n            qsize = que.size();\n            for(int i = 0; i < qsize; ++i){\n                pair<int,int> t = que.front();\n                que.pop();\n                int x = t.first;\n                int y = t.second;\n                // cout << x << y  << endl;\n                for(int j = 0; j < 4; ++j){\n                    int nx = x + dx[j];\n                    int ny = y + dy[j];\n                    // cout <<\"@\" <<  nx << ny  << endl;\n                    if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\n                    if(!vis[nx][ny]){                        \n                        vis[nx][ny] = 1; // exclude the deplucation of elements in queue.\n                        dis[nx][ny] = dis[x][y] + 1;\n                        que.push(make_pair(nx, ny));\n                        // cout << nx << ' ' << ny  << ' ' << dis[nx][ny] << endl;\n                    }\n                }\n            }\n        }\n        return dis;\n    }\n};\n```\n\n\n\ndp\n\n97%\n\n```c++\nclass Solution {\npublic:\n    int dx[4] = {0, 0, -1, 1};\n    int dy[4] = {-1, 1, 0, 0};\n\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> dp(n, vector<int>(m , INT_MAX - 3)); //bugs: max value should be bigger than m and n.\n        \n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == 0){\n                    dp[i][j] = 0;\n                    continue;\n                }\n                if(i > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);\n                if(j > 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n        for(int i = n - 1; i >=0; --i){\n            for(int j = m - 1; j >= 0; --j){\n                if(matrix[i][j] == 0) continue;\n                if(i != n - 1) dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);\n                if(j != m - 1) dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);\n            }\n        }        \n        return dp;\n    }\n};\n```","source":"_posts/刷题/DP/542-01-Matrix.md","raw":"---\ntitle: 542. 01 Matrix\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-08 08:55:46\n---\n\n\n\n\n\n## [542. 01 Matrix](https://leetcode-cn.com/problems/01-matrix/)\n\n## 思路：\n\n1. 从数字0开始bfs到1的最短路\n2. 由于从数字1到最近的数字零之间的最短路径，如果不是相邻，那么必定有在路径上数字1到同样的数字0有一条最短路径。如此便可以在四个移动方向上分别dp最短路径长度即可。\n\n<!-- more -->\n\n## 代码：\n\nbfs\n\n66%\n\n```c++\nclass Solution {\npublic:\n    int dx[4] = {0, 0, -1, 1};\n    int dy[4] = {-1, 1, 0, 0};\n\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> dis(n, vector<int>(m , 0));\n        vector<vector<int>> vis(n, vector<int>(m, 0));\n        queue<pair<int,int>> que;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == 0){\n                    que.push(make_pair(i ,j));\n                    vis[i][j] = 1;\n                }                    \n            }\n        }\n        int qsize;\n        while(que.size()){\n            qsize = que.size();\n            for(int i = 0; i < qsize; ++i){\n                pair<int,int> t = que.front();\n                que.pop();\n                int x = t.first;\n                int y = t.second;\n                // cout << x << y  << endl;\n                for(int j = 0; j < 4; ++j){\n                    int nx = x + dx[j];\n                    int ny = y + dy[j];\n                    // cout <<\"@\" <<  nx << ny  << endl;\n                    if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\n                    if(!vis[nx][ny]){                        \n                        vis[nx][ny] = 1; // exclude the deplucation of elements in queue.\n                        dis[nx][ny] = dis[x][y] + 1;\n                        que.push(make_pair(nx, ny));\n                        // cout << nx << ' ' << ny  << ' ' << dis[nx][ny] << endl;\n                    }\n                }\n            }\n        }\n        return dis;\n    }\n};\n```\n\n\n\ndp\n\n97%\n\n```c++\nclass Solution {\npublic:\n    int dx[4] = {0, 0, -1, 1};\n    int dy[4] = {-1, 1, 0, 0};\n\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int m = matrix[0].size();\n        vector<vector<int>> dp(n, vector<int>(m , INT_MAX - 3)); //bugs: max value should be bigger than m and n.\n        \n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                if(matrix[i][j] == 0){\n                    dp[i][j] = 0;\n                    continue;\n                }\n                if(i > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);\n                if(j > 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n        for(int i = n - 1; i >=0; --i){\n            for(int j = m - 1; j >= 0; --j){\n                if(matrix[i][j] == 0) continue;\n                if(i != n - 1) dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1);\n                if(j != m - 1) dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);\n            }\n        }        \n        return dp;\n    }\n};\n```","slug":"刷题/DP/542-01-Matrix","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3e000sl5uo282s4esi","content":"<h2 id=\"542-01-Matrix\"><a href=\"#542-01-Matrix\" class=\"headerlink\" title=\"542. 01 Matrix\"></a><a href=\"https://leetcode-cn.com/problems/01-matrix/\">542. 01 Matrix</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>从数字0开始bfs到1的最短路</li>\n<li>由于从数字1到最近的数字零之间的最短路径，如果不是相邻，那么必定有在路径上数字1到同样的数字0有一条最短路径。如此便可以在四个移动方向上分别dp最短路径长度即可。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>bfs</p>\n<p>66%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    int dy[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n\n    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; dis(n, vector&lt;int&gt;(m , 0));\n        vector&lt;vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0));\n        queue&lt;pair&lt;int,int&gt;&gt; que;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; 0)&#123;\n                    que.push(make_pair(i ,j));\n                    vis[i][j] &#x3D; 1;\n                &#125;                    \n            &#125;\n        &#125;\n        int qsize;\n        while(que.size())&#123;\n            qsize &#x3D; que.size();\n            for(int i &#x3D; 0; i &lt; qsize; ++i)&#123;\n                pair&lt;int,int&gt; t &#x3D; que.front();\n                que.pop();\n                int x &#x3D; t.first;\n                int y &#x3D; t.second;\n                &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; y  &lt;&lt; endl;\n                for(int j &#x3D; 0; j &lt; 4; ++j)&#123;\n                    int nx &#x3D; x + dx[j];\n                    int ny &#x3D; y + dy[j];\n                    &#x2F;&#x2F; cout &lt;&lt;&quot;@&quot; &lt;&lt;  nx &lt;&lt; ny  &lt;&lt; endl;\n                    if(nx &lt; 0 || ny &lt; 0 || nx &gt;&#x3D; n || ny &gt;&#x3D; m) continue;\n                    if(!vis[nx][ny])&#123;                        \n                        vis[nx][ny] &#x3D; 1; &#x2F;&#x2F; exclude the deplucation of elements in queue.\n                        dis[nx][ny] &#x3D; dis[x][y] + 1;\n                        que.push(make_pair(nx, ny));\n                        &#x2F;&#x2F; cout &lt;&lt; nx &lt;&lt; &#39; &#39; &lt;&lt; ny  &lt;&lt; &#39; &#39; &lt;&lt; dis[nx][ny] &lt;&lt; endl;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return dis;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>dp</p>\n<p>97%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    int dy[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n\n    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m , INT_MAX - 3)); &#x2F;&#x2F;bugs: max value should be bigger than m and n.\n        \n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; 0)&#123;\n                    dp[i][j] &#x3D; 0;\n                    continue;\n                &#125;\n                if(i &gt; 0) dp[i][j] &#x3D; min(dp[i][j], dp[i - 1][j] + 1);\n                if(j &gt; 0) dp[i][j] &#x3D; min(dp[i][j], dp[i][j - 1] + 1);\n            &#125;\n        &#125;\n        for(int i &#x3D; n - 1; i &gt;&#x3D;0; --i)&#123;\n            for(int j &#x3D; m - 1; j &gt;&#x3D; 0; --j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; 0) continue;\n                if(i !&#x3D; n - 1) dp[i][j] &#x3D; min(dp[i][j], dp[i + 1][j] + 1);\n                if(j !&#x3D; m - 1) dp[i][j] &#x3D; min(dp[i][j], dp[i][j + 1] + 1);\n            &#125;\n        &#125;        \n        return dp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2Y1V56A","excerpt":"<h2 id=\"542-01-Matrix\"><a href=\"#542-01-Matrix\" class=\"headerlink\" title=\"542. 01 Matrix\"></a><a href=\"https://leetcode-cn.com/problems/01-matrix/\">542. 01 Matrix</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>从数字0开始bfs到1的最短路</li>\n<li>由于从数字1到最近的数字零之间的最短路径，如果不是相邻，那么必定有在路径上数字1到同样的数字0有一条最短路径。如此便可以在四个移动方向上分别dp最短路径长度即可。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>bfs</p>\n<p>66%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    int dy[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n\n    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; dis(n, vector&lt;int&gt;(m , 0));\n        vector&lt;vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0));\n        queue&lt;pair&lt;int,int&gt;&gt; que;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; 0)&#123;\n                    que.push(make_pair(i ,j));\n                    vis[i][j] &#x3D; 1;\n                &#125;                    \n            &#125;\n        &#125;\n        int qsize;\n        while(que.size())&#123;\n            qsize &#x3D; que.size();\n            for(int i &#x3D; 0; i &lt; qsize; ++i)&#123;\n                pair&lt;int,int&gt; t &#x3D; que.front();\n                que.pop();\n                int x &#x3D; t.first;\n                int y &#x3D; t.second;\n                &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; y  &lt;&lt; endl;\n                for(int j &#x3D; 0; j &lt; 4; ++j)&#123;\n                    int nx &#x3D; x + dx[j];\n                    int ny &#x3D; y + dy[j];\n                    &#x2F;&#x2F; cout &lt;&lt;&quot;@&quot; &lt;&lt;  nx &lt;&lt; ny  &lt;&lt; endl;\n                    if(nx &lt; 0 || ny &lt; 0 || nx &gt;&#x3D; n || ny &gt;&#x3D; m) continue;\n                    if(!vis[nx][ny])&#123;                        \n                        vis[nx][ny] &#x3D; 1; &#x2F;&#x2F; exclude the deplucation of elements in queue.\n                        dis[nx][ny] &#x3D; dis[x][y] + 1;\n                        que.push(make_pair(nx, ny));\n                        &#x2F;&#x2F; cout &lt;&lt; nx &lt;&lt; &#39; &#39; &lt;&lt; ny  &lt;&lt; &#39; &#39; &lt;&lt; dis[nx][ny] &lt;&lt; endl;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return dis;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>dp</p>\n<p>97%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    int dy[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n\n    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size();\n        int m &#x3D; matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m , INT_MAX - 3)); &#x2F;&#x2F;bugs: max value should be bigger than m and n.\n        \n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; 0)&#123;\n                    dp[i][j] &#x3D; 0;\n                    continue;\n                &#125;\n                if(i &gt; 0) dp[i][j] &#x3D; min(dp[i][j], dp[i - 1][j] + 1);\n                if(j &gt; 0) dp[i][j] &#x3D; min(dp[i][j], dp[i][j - 1] + 1);\n            &#125;\n        &#125;\n        for(int i &#x3D; n - 1; i &gt;&#x3D;0; --i)&#123;\n            for(int j &#x3D; m - 1; j &gt;&#x3D; 0; --j)&#123;\n                if(matrix[i][j] &#x3D;&#x3D; 0) continue;\n                if(i !&#x3D; n - 1) dp[i][j] &#x3D; min(dp[i][j], dp[i + 1][j] + 1);\n                if(j !&#x3D; m - 1) dp[i][j] &#x3D; min(dp[i][j], dp[i][j + 1] + 1);\n            &#125;\n        &#125;        \n        return dp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"583. Delete Operation for Two Strings","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-29T01:06:59.000Z","_content":"\n\n\n\n\n\n## [583. Delete Operation for Two Strings](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)\n\n\n\n## 思路：\n\n此题可以转化为最长公共子序列（LCS）。用动态规划解决LCS即可。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.size(), m = word2.size();\n        // vector<vector<int>> dp(n + 1, vector<int>(m + 1)); //vector分配空间耗时很大，同时占用的空间也大 \n        int dp[n + 1][m + 1];\n        memset(dp, 0, sizeof(dp));\n        for(int i = 1; i <= n; ++i){\n            for(int j = 1; j <= m;- ++j){\n                if(word1[i - 1] == word2[j - 1]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n        return n + m - 2 * dp[n][m];\n    }\n};\n\n\n```\n\n\n\n\n\n## 运行效率：\n\nleetcode的运行时间真是的迷，不过数据集太小了，确实难以准确评估。\n\n![image-20201229090424332](D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\image-20201229090424332.png)","source":"_posts/刷题/DP/583-Delete-Operation-for-Two-Strings.md","raw":"---\ntitle: 583. Delete Operation for Two Strings\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-29 09:06:59\n---\n\n\n\n\n\n\n## [583. Delete Operation for Two Strings](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)\n\n\n\n## 思路：\n\n此题可以转化为最长公共子序列（LCS）。用动态规划解决LCS即可。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.size(), m = word2.size();\n        // vector<vector<int>> dp(n + 1, vector<int>(m + 1)); //vector分配空间耗时很大，同时占用的空间也大 \n        int dp[n + 1][m + 1];\n        memset(dp, 0, sizeof(dp));\n        for(int i = 1; i <= n; ++i){\n            for(int j = 1; j <= m;- ++j){\n                if(word1[i - 1] == word2[j - 1]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n        return n + m - 2 * dp[n][m];\n    }\n};\n\n\n```\n\n\n\n\n\n## 运行效率：\n\nleetcode的运行时间真是的迷，不过数据集太小了，确实难以准确评估。\n\n![image-20201229090424332](D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\image-20201229090424332.png)","slug":"刷题/DP/583-Delete-Operation-for-Two-Strings","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3f000tl5uo8e552zzw","content":"<h2 id=\"583-Delete-Operation-for-Two-Strings\"><a href=\"#583-Delete-Operation-for-Two-Strings\" class=\"headerlink\" title=\"583. Delete Operation for Two Strings\"></a><a href=\"https://leetcode-cn.com/problems/delete-operation-for-two-strings/\">583. Delete Operation for Two Strings</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>此题可以转化为最长公共子序列（LCS）。用动态规划解决LCS即可。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minDistance(string word1, string word2) &#123;\n        int n &#x3D; word1.size(), m &#x3D; word2.size();\n        &#x2F;&#x2F; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); &#x2F;&#x2F;vector分配空间耗时很大，同时占用的空间也大 \n        int dp[n + 1][m + 1];\n        memset(dp, 0, sizeof(dp));\n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt;&#x3D; m;- ++j)&#123;\n                if(word1[i - 1] &#x3D;&#x3D; word2[j - 1])&#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;\n                &#125;else dp[i][j] &#x3D; max(dp[i][j - 1], dp[i - 1][j]);\n            &#125;\n        &#125;\n        return n + m - 2 * dp[n][m];\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h2 id=\"运行效率：\"><a href=\"#运行效率：\" class=\"headerlink\" title=\"运行效率：\"></a>运行效率：</h2><p>leetcode的运行时间真是的迷，不过数据集太小了，确实难以准确评估。</p>\n<p><img src=\"D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\image-20201229090424332.png\" alt=\"image-20201229090424332\"></p>\n","site":{"data":{}},"abbrlink":"2FEHYY7","excerpt":"<h2 id=\"583-Delete-Operation-for-Two-Strings\"><a href=\"#583-Delete-Operation-for-Two-Strings\" class=\"headerlink\" title=\"583. Delete Operation for Two Strings\"></a><a href=\"https://leetcode-cn.com/problems/delete-operation-for-two-strings/\">583. Delete Operation for Two Strings</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>此题可以转化为最长公共子序列（LCS）。用动态规划解决LCS即可。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minDistance(string word1, string word2) &#123;\n        int n &#x3D; word1.size(), m &#x3D; word2.size();\n        &#x2F;&#x2F; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); &#x2F;&#x2F;vector分配空间耗时很大，同时占用的空间也大 \n        int dp[n + 1][m + 1];\n        memset(dp, 0, sizeof(dp));\n        for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt;&#x3D; m;- ++j)&#123;\n                if(word1[i - 1] &#x3D;&#x3D; word2[j - 1])&#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;\n                &#125;else dp[i][j] &#x3D; max(dp[i][j - 1], dp[i - 1][j]);\n            &#125;\n        &#125;\n        return n + m - 2 * dp[n][m];\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h2 id=\"运行效率：\"><a href=\"#运行效率：\" class=\"headerlink\" title=\"运行效率：\"></a>运行效率：</h2><p>leetcode的运行时间真是的迷，不过数据集太小了，确实难以准确评估。</p>\n<p><img src=\"D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\image-20201229090424332.png\" alt=\"image-20201229090424332\"></p>"},{"title":"594. Longest Harmonious Subsequence","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-30T07:11:50.000Z","_content":"\n\n\n\n\n## [594. Longest Harmonious Subsequence](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)\n\n\n\n\n\n## 思路：\n\n\n\n一道经典的最大递增子序列的变形题\n\n结果用DP思路做了半天，发现越做复杂！？？？？\n\n怀疑人生的同时发现自己的思路还是太窄了。\n\n<!-- more -->\n\n\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findLHS(vector<int>& nums) {\n        int n = nums.size();\n        unordered_map<int, int> ct;\n        int maxl = 0;\n        for(auto & v : nums){\n            ct[v]++;\n            int t = max(ct[v+1], + ct[v - 1]);\n            if(t) maxl = max(t + ct[v], maxl);            \n        }\n        return maxl;\n        \n    }\n};\n```","source":"_posts/刷题/DP/594-Longest-Harmonious-Subsequence.md","raw":"---\ntitle: 594. Longest Harmonious Subsequence\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-01-30 15:11:50\ntags:\ncategories:\n---\n\n\n\n\n\n## [594. Longest Harmonious Subsequence](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)\n\n\n\n\n\n## 思路：\n\n\n\n一道经典的最大递增子序列的变形题\n\n结果用DP思路做了半天，发现越做复杂！？？？？\n\n怀疑人生的同时发现自己的思路还是太窄了。\n\n<!-- more -->\n\n\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findLHS(vector<int>& nums) {\n        int n = nums.size();\n        unordered_map<int, int> ct;\n        int maxl = 0;\n        for(auto & v : nums){\n            ct[v]++;\n            int t = max(ct[v+1], + ct[v - 1]);\n            if(t) maxl = max(t + ct[v], maxl);            \n        }\n        return maxl;\n        \n    }\n};\n```","slug":"刷题/DP/594-Longest-Harmonious-Subsequence","published":1,"updated":"2021-01-30T07:13:52.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3g000ul5uo08zffgfh","content":"<h2 id=\"594-Longest-Harmonious-Subsequence\"><a href=\"#594-Longest-Harmonious-Subsequence\" class=\"headerlink\" title=\"594. Longest Harmonious Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-harmonious-subsequence/\">594. Longest Harmonious Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>一道经典的最大递增子序列的变形题</p>\n<p>结果用DP思路做了半天，发现越做复杂！？？？？</p>\n<p>怀疑人生的同时发现自己的思路还是太窄了。</p>\n<span id=\"more\"></span>\n\n\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findLHS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        unordered_map&lt;int, int&gt; ct;\n        int maxl &#x3D; 0;\n        for(auto &amp; v : nums)&#123;\n            ct[v]++;\n            int t &#x3D; max(ct[v+1], + ct[v - 1]);\n            if(t) maxl &#x3D; max(t + ct[v], maxl);            \n        &#125;\n        return maxl;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"254DF00","excerpt":"<h2 id=\"594-Longest-Harmonious-Subsequence\"><a href=\"#594-Longest-Harmonious-Subsequence\" class=\"headerlink\" title=\"594. Longest Harmonious Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-harmonious-subsequence/\">594. Longest Harmonious Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>一道经典的最大递增子序列的变形题</p>\n<p>结果用DP思路做了半天，发现越做复杂！？？？？</p>\n<p>怀疑人生的同时发现自己的思路还是太窄了。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findLHS(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        unordered_map&lt;int, int&gt; ct;\n        int maxl &#x3D; 0;\n        for(auto &amp; v : nums)&#123;\n            ct[v]++;\n            int t &#x3D; max(ct[v+1], + ct[v - 1]);\n            if(t) maxl &#x3D; max(t + ct[v], maxl);            \n        &#125;\n        return maxl;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"64. Minimum Path Sum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-08T00:55:55.000Z","_content":"\n\n\n\n\n\n\n## [64. Minimum Path Sum](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n## 思路:\n\ndp长度\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n = grid.size();\n        if(n == 0) return 0;\n        int m = grid[0].size();\n        if(m == 0) return 0;\n        vector<vector<int>> dp(n, vector<int>(m, 0));\n        dp[0][0] = grid[0][0];\n        for(int i = 1; i < m; ++i){\n            dp[0][i] = dp[0][i - 1] + grid[0][i];\n        }        \n        for(int i = 1; i < n; ++i){\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for(int i = 1; i < n; ++i){\n            for(int j = 1; j < m; ++j){\n                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n            }\n        }\n        return dp[n - 1][m - 1];\n\n    \n    }\n};\n```","source":"_posts/刷题/DP/64-Minimum-Path-Sum.md","raw":"---\ntitle: 64. Minimum Path Sum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-08 08:55:55\n---\n\n\n\n\n\n\n\n## [64. Minimum Path Sum](https://leetcode-cn.com/problems/minimum-path-sum/)\n\n## 思路:\n\ndp长度\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n = grid.size();\n        if(n == 0) return 0;\n        int m = grid[0].size();\n        if(m == 0) return 0;\n        vector<vector<int>> dp(n, vector<int>(m, 0));\n        dp[0][0] = grid[0][0];\n        for(int i = 1; i < m; ++i){\n            dp[0][i] = dp[0][i - 1] + grid[0][i];\n        }        \n        for(int i = 1; i < n; ++i){\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n        for(int i = 1; i < n; ++i){\n            for(int j = 1; j < m; ++j){\n                dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n            }\n        }\n        return dp[n - 1][m - 1];\n\n    \n    }\n};\n```","slug":"刷题/DP/64-Minimum-Path-Sum","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3h000vl5uo83lygzcx","content":"<h2 id=\"64-Minimum-Path-Sum\"><a href=\"#64-Minimum-Path-Sum\" class=\"headerlink\" title=\"64. Minimum Path Sum\"></a><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">64. Minimum Path Sum</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>dp长度</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int n &#x3D; grid.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        int m &#x3D; grid[0].size();\n        if(m &#x3D;&#x3D; 0) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, 0));\n        dp[0][0] &#x3D; grid[0][0];\n        for(int i &#x3D; 1; i &lt; m; ++i)&#123;\n            dp[0][i] &#x3D; dp[0][i - 1] + grid[0][i];\n        &#125;        \n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            dp[i][0] &#x3D; dp[i - 1][0] + grid[i][0];\n        &#125;\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                dp[i][j] &#x3D; min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n            &#125;\n        &#125;\n        return dp[n - 1][m - 1];\n\n    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1NGEFW0","excerpt":"<h2 id=\"64-Minimum-Path-Sum\"><a href=\"#64-Minimum-Path-Sum\" class=\"headerlink\" title=\"64. Minimum Path Sum\"></a><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">64. Minimum Path Sum</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>dp长度</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int n &#x3D; grid.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        int m &#x3D; grid[0].size();\n        if(m &#x3D;&#x3D; 0) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, 0));\n        dp[0][0] &#x3D; grid[0][0];\n        for(int i &#x3D; 1; i &lt; m; ++i)&#123;\n            dp[0][i] &#x3D; dp[0][i - 1] + grid[0][i];\n        &#125;        \n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            dp[i][0] &#x3D; dp[i - 1][0] + grid[i][0];\n        &#125;\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                dp[i][j] &#x3D; min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];\n            &#125;\n        &#125;\n        return dp[n - 1][m - 1];\n\n    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"650. 2 Keys Keyboard","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-21T00:34:03.000Z","_content":"\n\n\n\n## [650. 2 Keys Keyboard](https://leetcode-cn.com/problems/2-keys-keyboard/)\n\n\n\n## 思路：\n\ndp[i] 为长度为i的字符串需要的最小操作数。\n\n1. 反推\n2. 最小质数\n3. 素数分解\n\n<!-- more -->\n\n## 代码：\n\n这个空间速度\n\n```c++\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp( n + 1, INT_MAX);\n        dp[1] = 0;\n        for(int i = 1; i < n; i++){\n            if(dp[i] != INT_MAX){\n                if(i + i <= n){\n                    \n                    for(int j = i * 2, k = 2; j <=n; j += i, k++){\n                        dp[j] = min(dp[i] + k, dp[j]);\n                    }\n                }\n                \n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n这种思路有一点：为啥最小的j就会是dp[i]最小呢？\n\n\n\n```C++\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp( n + 1, INT_MAX);\n        dp[1] = 0;\n        int h = sqrt(n);\n        for(int i = 2; i <= n; i++){\n            dp[i] = i;\n            for(int j = 2; j <= h; j++){\n                if(i % j == 0){\n                    dp[i] = dp[j] + dp[i / j];\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n素数分解\n\n```c++\nclass Solution {\npublic:\n    int minSteps(int n) {\n        int factor = 2, ans = 0;\n        while(n > 1){\n            while(n % factor == 0 && n > 1){\n                n /= factor;\n                ans += factor; //选择（复制 + 粘粘）的一个复合操作是最快的，所以用最小的素数步骤进行一次操作\n                //之所以是素数步骤， 是因为合数都被比他小的素数因子所分解了\n            }\n            factor++;\n        }\n        return ans;\n    }\n};\n```","source":"_posts/刷题/DP/650-2-Keys-Keyboard.md","raw":"---\ntitle: 650. 2 Keys Keyboard\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-21 08:34:03\n---\n\n\n\n\n## [650. 2 Keys Keyboard](https://leetcode-cn.com/problems/2-keys-keyboard/)\n\n\n\n## 思路：\n\ndp[i] 为长度为i的字符串需要的最小操作数。\n\n1. 反推\n2. 最小质数\n3. 素数分解\n\n<!-- more -->\n\n## 代码：\n\n这个空间速度\n\n```c++\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp( n + 1, INT_MAX);\n        dp[1] = 0;\n        for(int i = 1; i < n; i++){\n            if(dp[i] != INT_MAX){\n                if(i + i <= n){\n                    \n                    for(int j = i * 2, k = 2; j <=n; j += i, k++){\n                        dp[j] = min(dp[i] + k, dp[j]);\n                    }\n                }\n                \n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n这种思路有一点：为啥最小的j就会是dp[i]最小呢？\n\n\n\n```C++\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp( n + 1, INT_MAX);\n        dp[1] = 0;\n        int h = sqrt(n);\n        for(int i = 2; i <= n; i++){\n            dp[i] = i;\n            for(int j = 2; j <= h; j++){\n                if(i % j == 0){\n                    dp[i] = dp[j] + dp[i / j];\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n素数分解\n\n```c++\nclass Solution {\npublic:\n    int minSteps(int n) {\n        int factor = 2, ans = 0;\n        while(n > 1){\n            while(n % factor == 0 && n > 1){\n                n /= factor;\n                ans += factor; //选择（复制 + 粘粘）的一个复合操作是最快的，所以用最小的素数步骤进行一次操作\n                //之所以是素数步骤， 是因为合数都被比他小的素数因子所分解了\n            }\n            factor++;\n        }\n        return ans;\n    }\n};\n```","slug":"刷题/DP/650-2-Keys-Keyboard","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3i000wl5uo4s1law8c","content":"<h2 id=\"650-2-Keys-Keyboard\"><a href=\"#650-2-Keys-Keyboard\" class=\"headerlink\" title=\"650. 2 Keys Keyboard\"></a><a href=\"https://leetcode-cn.com/problems/2-keys-keyboard/\">650. 2 Keys Keyboard</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dp[i] 为长度为i的字符串需要的最小操作数。</p>\n<ol>\n<li>反推</li>\n<li>最小质数</li>\n<li>素数分解</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>这个空间速度</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minSteps(int n) &#123;\n        vector&lt;int&gt; dp( n + 1, INT_MAX);\n        dp[1] &#x3D; 0;\n        for(int i &#x3D; 1; i &lt; n; i++)&#123;\n            if(dp[i] !&#x3D; INT_MAX)&#123;\n                if(i + i &lt;&#x3D; n)&#123;\n                    \n                    for(int j &#x3D; i * 2, k &#x3D; 2; j &lt;&#x3D;n; j +&#x3D; i, k++)&#123;\n                        dp[j] &#x3D; min(dp[i] + k, dp[j]);\n                    &#125;\n                &#125;\n                \n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>这种思路有一点：为啥最小的j就会是dp[i]最小呢？</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minSteps(int n) &#123;\n        vector&lt;int&gt; dp( n + 1, INT_MAX);\n        dp[1] &#x3D; 0;\n        int h &#x3D; sqrt(n);\n        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n            dp[i] &#x3D; i;\n            for(int j &#x3D; 2; j &lt;&#x3D; h; j++)&#123;\n                if(i % j &#x3D;&#x3D; 0)&#123;\n                    dp[i] &#x3D; dp[j] + dp[i &#x2F; j];\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>素数分解</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minSteps(int n) &#123;\n        int factor &#x3D; 2, ans &#x3D; 0;\n        while(n &gt; 1)&#123;\n            while(n % factor &#x3D;&#x3D; 0 &amp;&amp; n &gt; 1)&#123;\n                n &#x2F;&#x3D; factor;\n                ans +&#x3D; factor; &#x2F;&#x2F;选择（复制 + 粘粘）的一个复合操作是最快的，所以用最小的素数步骤进行一次操作\n                &#x2F;&#x2F;之所以是素数步骤， 是因为合数都被比他小的素数因子所分解了\n            &#125;\n            factor++;\n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"VYVP47","excerpt":"<h2 id=\"650-2-Keys-Keyboard\"><a href=\"#650-2-Keys-Keyboard\" class=\"headerlink\" title=\"650. 2 Keys Keyboard\"></a><a href=\"https://leetcode-cn.com/problems/2-keys-keyboard/\">650. 2 Keys Keyboard</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dp[i] 为长度为i的字符串需要的最小操作数。</p>\n<ol>\n<li>反推</li>\n<li>最小质数</li>\n<li>素数分解</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>这个空间速度</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minSteps(int n) &#123;\n        vector&lt;int&gt; dp( n + 1, INT_MAX);\n        dp[1] &#x3D; 0;\n        for(int i &#x3D; 1; i &lt; n; i++)&#123;\n            if(dp[i] !&#x3D; INT_MAX)&#123;\n                if(i + i &lt;&#x3D; n)&#123;\n                    \n                    for(int j &#x3D; i * 2, k &#x3D; 2; j &lt;&#x3D;n; j +&#x3D; i, k++)&#123;\n                        dp[j] &#x3D; min(dp[i] + k, dp[j]);\n                    &#125;\n                &#125;\n                \n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>这种思路有一点：为啥最小的j就会是dp[i]最小呢？</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int minSteps(int n) &#123;\n        vector&lt;int&gt; dp( n + 1, INT_MAX);\n        dp[1] &#x3D; 0;\n        int h &#x3D; sqrt(n);\n        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n            dp[i] &#x3D; i;\n            for(int j &#x3D; 2; j &lt;&#x3D; h; j++)&#123;\n                if(i % j &#x3D;&#x3D; 0)&#123;\n                    dp[i] &#x3D; dp[j] + dp[i &#x2F; j];\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>素数分解</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minSteps(int n) &#123;\n        int factor &#x3D; 2, ans &#x3D; 0;\n        while(n &gt; 1)&#123;\n            while(n % factor &#x3D;&#x3D; 0 &amp;&amp; n &gt; 1)&#123;\n                n &#x2F;&#x3D; factor;\n                ans +&#x3D; factor; &#x2F;&#x2F;选择（复制 + 粘粘）的一个复合操作是最快的，所以用最小的素数步骤进行一次操作\n                &#x2F;&#x2F;之所以是素数步骤， 是因为合数都被比他小的素数因子所分解了\n            &#125;\n            factor++;\n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"70. Climbing Stairs","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-07T01:17:08.000Z","_content":"\n## [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)\n\n\n\n## 思路：\n\ndp，用两个变量存储长度为N的数组优化空间\n\n。<!-- more --> \n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int a = 1, b = 1, c = 2, k = 2;\n        while(k <= n){\n            c = a + b;\n            a = b;\n            b = c;            \n            k++;\n        }\n        if(n == 0) return 0;\n        else if(n == 1) return 1;\n        else return c;\n    }\n};\n```","source":"_posts/刷题/DP/70-Climbing-Stairs.md","raw":"---\ntitle: 70. Climbing Stairs\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-07 09:17:08\n---\n\n## [70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)\n\n\n\n## 思路：\n\ndp，用两个变量存储长度为N的数组优化空间\n\n。<!-- more --> \n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int a = 1, b = 1, c = 2, k = 2;\n        while(k <= n){\n            c = a + b;\n            a = b;\n            b = c;            \n            k++;\n        }\n        if(n == 0) return 0;\n        else if(n == 1) return 1;\n        else return c;\n    }\n};\n```","slug":"刷题/DP/70-Climbing-Stairs","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3j000xl5uo94w57x2v","content":"<h2 id=\"70-Climbing-Stairs\"><a href=\"#70-Climbing-Stairs\" class=\"headerlink\" title=\"70. Climbing Stairs\"></a><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">70. Climbing Stairs</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dp，用两个变量存储长度为N的数组优化空间</p>\n<p>。<span id=\"more\"></span> </p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        int a &#x3D; 1, b &#x3D; 1, c &#x3D; 2, k &#x3D; 2;\n        while(k &lt;&#x3D; n)&#123;\n            c &#x3D; a + b;\n            a &#x3D; b;\n            b &#x3D; c;            \n            k++;\n        &#125;\n        if(n &#x3D;&#x3D; 0) return 0;\n        else if(n &#x3D;&#x3D; 1) return 1;\n        else return c;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3F32HBN","excerpt":"<h2 id=\"70-Climbing-Stairs\"><a href=\"#70-Climbing-Stairs\" class=\"headerlink\" title=\"70. Climbing Stairs\"></a><a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">70. Climbing Stairs</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dp，用两个变量存储长度为N的数组优化空间</p>\n<p>。","more":"</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int climbStairs(int n) &#123;\n        int a &#x3D; 1, b &#x3D; 1, c &#x3D; 2, k &#x3D; 2;\n        while(k &lt;&#x3D; n)&#123;\n            c &#x3D; a + b;\n            a &#x3D; b;\n            b &#x3D; c;            \n            k++;\n        &#125;\n        if(n &#x3D;&#x3D; 0) return 0;\n        else if(n &#x3D;&#x3D; 1) return 1;\n        else return c;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"714. Best Time to Buy and Sell Stock with Transaction Fee","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-26T00:40:39.000Z","_content":"\n\n\n\n\n\n\n\n## [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\n\n## 思路：\n\n做过了309题的话，这题就非常容易解决。注意fee的费用在交易完成后结算，不然可能有手续费没有扣完的尴尬情况。\n\n<!-- more -->\n\n>  ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n## 代码：\n\n空间可优化\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int d = prices.size(); \n        if(d <= 1) return 0;\n        vector<vector<int>> dp(d, vector<int>(2));\n        dp[0][0] = -prices[0];\n        for(int i = 1; i < d; ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n            dp[i][1] = max(dp[i -1][1], dp[i][0] + prices[i] - fee);\n        }\n        return dp[d- 1][1];\n        \n    }\n};\n```","source":"_posts/刷题/DP/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee.md","raw":"---\ntitle: 714. Best Time to Buy and Sell Stock with Transaction Fee\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-26 08:40:39\n---\n\n\n\n\n\n\n\n\n## [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\n\n## 思路：\n\n做过了309题的话，这题就非常容易解决。注意fee的费用在交易完成后结算，不然可能有手续费没有扣完的尴尬情况。\n\n<!-- more -->\n\n>  ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n## 代码：\n\n空间可优化\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int d = prices.size(); \n        if(d <= 1) return 0;\n        vector<vector<int>> dp(d, vector<int>(2));\n        dp[0][0] = -prices[0];\n        for(int i = 1; i < d; ++i){\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n            dp[i][1] = max(dp[i -1][1], dp[i][0] + prices[i] - fee);\n        }\n        return dp[d- 1][1];\n        \n    }\n};\n```","slug":"刷题/DP/714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3k000yl5uobkfb5drb","content":"<h2 id=\"714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee\"><a href=\"#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee\" class=\"headerlink\" title=\"714. Best Time to Buy and Sell Stock with Transaction Fee\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>做过了309题的话，这题就非常容易解决。注意fee的费用在交易完成后结算，不然可能有手续费没有扣完的尴尬情况。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p> <img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>空间可优化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;\n        int d &#x3D; prices.size(); \n        if(d &lt;&#x3D; 1) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(2));\n        dp[0][0] &#x3D; -prices[0];\n        for(int i &#x3D; 1; i &lt; d; ++i)&#123;\n            dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n            dp[i][1] &#x3D; max(dp[i -1][1], dp[i][0] + prices[i] - fee);\n        &#125;\n        return dp[d- 1][1];\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"29HJTNZ","excerpt":"<h2 id=\"714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee\"><a href=\"#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee\" class=\"headerlink\" title=\"714. Best Time to Buy and Sell Stock with Transaction Fee\"></a><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>做过了309题的话，这题就非常容易解决。注意fee的费用在交易完成后结算，不然可能有手续费没有扣完的尴尬情况。</p>","more":"<blockquote>\n<p> <img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>空间可优化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;\n        int d &#x3D; prices.size(); \n        if(d &lt;&#x3D; 1) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(2));\n        dp[0][0] &#x3D; -prices[0];\n        for(int i &#x3D; 1; i &lt; d; ++i)&#123;\n            dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n            dp[i][1] &#x3D; max(dp[i -1][1], dp[i][0] + prices[i] - fee);\n        &#125;\n        return dp[d- 1][1];\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"72. Edit Distance","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-21T00:33:52.000Z","_content":"\n\n\n\n#### [72. Edit Distance](https://leetcode-cn.com/problems/edit-distance/)\n\n<!-- more -->\n\n## 思路：\n\n\n\n`dp[i][j]`表示子串`word[0……i)`和子串`word[0……j)`需要变化的最小次数。\n\n非常巧妙啊，很快就可以敲出代码，注意初始化边缘值。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n        // if(n == 0 || m == 0) return 0;\n        vector<vector<int>> dp(n + 1,  vector<int>(m + 1, 0));\n        for(int i = 0; i <=n; ++i){\n            for(int j = 0; j <= m; ++j){\n                if(i == 0) dp[i][j] = j;\n                else if(j == 0) dp[i][j] = i;\n                else{\n                    dp[i][j] = min(dp[i-1][j - 1] + (word1[i - 1] == word2[j - 1]? 0 : 1), \n                        min(dp[i - 1][j], dp[i][j - 1]) +  1);\n                }\n            }\n        }\n        return dp[n][m];\n    }\n};\n```","source":"_posts/刷题/DP/72-Edit-Distance.md","raw":"---\ntitle: 72. Edit Distance\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-21 08:33:52\n---\n\n\n\n\n#### [72. Edit Distance](https://leetcode-cn.com/problems/edit-distance/)\n\n<!-- more -->\n\n## 思路：\n\n\n\n`dp[i][j]`表示子串`word[0……i)`和子串`word[0……j)`需要变化的最小次数。\n\n非常巧妙啊，很快就可以敲出代码，注意初始化边缘值。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n = word1.size();\n        int m = word2.size();\n        // if(n == 0 || m == 0) return 0;\n        vector<vector<int>> dp(n + 1,  vector<int>(m + 1, 0));\n        for(int i = 0; i <=n; ++i){\n            for(int j = 0; j <= m; ++j){\n                if(i == 0) dp[i][j] = j;\n                else if(j == 0) dp[i][j] = i;\n                else{\n                    dp[i][j] = min(dp[i-1][j - 1] + (word1[i - 1] == word2[j - 1]? 0 : 1), \n                        min(dp[i - 1][j], dp[i][j - 1]) +  1);\n                }\n            }\n        }\n        return dp[n][m];\n    }\n};\n```","slug":"刷题/DP/72-Edit-Distance","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3l000zl5uo855bbsi2","content":"<h4 id=\"72-Edit-Distance\"><a href=\"#72-Edit-Distance\" class=\"headerlink\" title=\"72. Edit Distance\"></a><a href=\"https://leetcode-cn.com/problems/edit-distance/\">72. Edit Distance</a></h4><span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>dp[i][j]</code>表示子串<code>word[0……i)</code>和子串<code>word[0……j)</code>需要变化的最小次数。</p>\n<p>非常巧妙啊，很快就可以敲出代码，注意初始化边缘值。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minDistance(string word1, string word2) &#123;\n        int n &#x3D; word1.size();\n        int m &#x3D; word2.size();\n        &#x2F;&#x2F; if(n &#x3D;&#x3D; 0 || m &#x3D;&#x3D; 0) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(n + 1,  vector&lt;int&gt;(m + 1, 0));\n        for(int i &#x3D; 0; i &lt;&#x3D;n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt;&#x3D; m; ++j)&#123;\n                if(i &#x3D;&#x3D; 0) dp[i][j] &#x3D; j;\n                else if(j &#x3D;&#x3D; 0) dp[i][j] &#x3D; i;\n                else&#123;\n                    dp[i][j] &#x3D; min(dp[i-1][j - 1] + (word1[i - 1] &#x3D;&#x3D; word2[j - 1]? 0 : 1), \n                        min(dp[i - 1][j], dp[i][j - 1]) +  1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n][m];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"19HYHAF","excerpt":"<h4 id=\"72-Edit-Distance\"><a href=\"#72-Edit-Distance\" class=\"headerlink\" title=\"72. Edit Distance\"></a><a href=\"https://leetcode-cn.com/problems/edit-distance/\">72. Edit Distance</a></h4>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>dp[i][j]</code>表示子串<code>word[0……i)</code>和子串<code>word[0……j)</code>需要变化的最小次数。</p>\n<p>非常巧妙啊，很快就可以敲出代码，注意初始化边缘值。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minDistance(string word1, string word2) &#123;\n        int n &#x3D; word1.size();\n        int m &#x3D; word2.size();\n        &#x2F;&#x2F; if(n &#x3D;&#x3D; 0 || m &#x3D;&#x3D; 0) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp(n + 1,  vector&lt;int&gt;(m + 1, 0));\n        for(int i &#x3D; 0; i &lt;&#x3D;n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt;&#x3D; m; ++j)&#123;\n                if(i &#x3D;&#x3D; 0) dp[i][j] &#x3D; j;\n                else if(j &#x3D;&#x3D; 0) dp[i][j] &#x3D; i;\n                else&#123;\n                    dp[i][j] &#x3D; min(dp[i-1][j - 1] + (word1[i - 1] &#x3D;&#x3D; word2[j - 1]? 0 : 1), \n                        min(dp[i - 1][j], dp[i][j - 1]) +  1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n][m];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"790. Domino and Tromino Tiling","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-07T03:26:39.000Z","_content":"\n这题真的需要很多考虑\n\n<!-- more -->\n\n### 思路：\n\n### DP\n\n可以进行bit dp，设置`dp[status]`为当前列为状态`status`时的拼接方法。\n\n```c++\nstatus = 0b00 : 上下格子都为空\nstatus = 0b10 : 上格子填好，下格子为空\nstatus = 0b01 : 下格子填好，上格子为空\nstatus = 0b11 : 上下格子都填好\n```\n\n所以就是有以下DP方程转移方式：\n\n![img](http://static.come2rss.xyz/possible.png)\n\n注意`dp[0]=0`。\n\n\n\n### 找规律\n\n另一种方法也是我一开始想的方法，不过想错了，没有考虑托米诺和多米诺无限增长的可能性。😑🤐\n\n\n\n参考以为大佬的[博文](https://blog.csdn.net/ccnuacmhdu/article/details/103412944)\n\n![img](http://static.come2rss.xyz/20191208142123502.png)\n\n\n\n\n\n## 代码：\n\n### DP\n\n```c++\nclass Solution {\npublic:\n    int numTilings(int N) {\n        const int MOD = 1e9 + 7;\n        // int[] dp= new int[]{1,0,0,0};\n        long  *dp = new long[]{1, 0, 0, 0};\n        for(int i = 0; i < N; ++i){\n            long *ndp = new long[4];\n            ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD;\n            ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD;\n            ndp[0b10] = (dp[0b01] + dp[0b00]) % MOD;\n            ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) %  MOD;\n            delete []dp;\n            dp = ndp;\n        }   \n\n        return dp[0];\n\n\n    }\n};\n```\n\n另外上述线性变换可以替换为矩阵乘法的变换形式，不过太稀疏了……\n\n### 找规律：\n\n```C++\n\nclass Solution {\npublic:\n    int numTilings(int N) {\n        const int MOD = 1e9 + 7;\n        int sum0 = 1, sum1 = 1, sum2 = 2, sum3 = 5, sum;\n        for(int i = 4; i <= N; ++i){\n            sum = ((sum3 * 2) % MOD + sum1) % MOD;\n            sum1 = sum2;\n            sum2 = sum3;\n            sum3 = sum;\n        }\n        if(N == 1) return 1;\n        else if(N == 2) return 2;\n        else if(N == 3) return 5;\n        return sum;\n\n\n    }\n};s\n```","source":"_posts/刷题/DP/790-Domino-and-Tromino-Tiling.md","raw":"---\ntitle: 790. Domino and Tromino Tiling\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-07 11:26:39\n---\n\n这题真的需要很多考虑\n\n<!-- more -->\n\n### 思路：\n\n### DP\n\n可以进行bit dp，设置`dp[status]`为当前列为状态`status`时的拼接方法。\n\n```c++\nstatus = 0b00 : 上下格子都为空\nstatus = 0b10 : 上格子填好，下格子为空\nstatus = 0b01 : 下格子填好，上格子为空\nstatus = 0b11 : 上下格子都填好\n```\n\n所以就是有以下DP方程转移方式：\n\n![img](http://static.come2rss.xyz/possible.png)\n\n注意`dp[0]=0`。\n\n\n\n### 找规律\n\n另一种方法也是我一开始想的方法，不过想错了，没有考虑托米诺和多米诺无限增长的可能性。😑🤐\n\n\n\n参考以为大佬的[博文](https://blog.csdn.net/ccnuacmhdu/article/details/103412944)\n\n![img](http://static.come2rss.xyz/20191208142123502.png)\n\n\n\n\n\n## 代码：\n\n### DP\n\n```c++\nclass Solution {\npublic:\n    int numTilings(int N) {\n        const int MOD = 1e9 + 7;\n        // int[] dp= new int[]{1,0,0,0};\n        long  *dp = new long[]{1, 0, 0, 0};\n        for(int i = 0; i < N; ++i){\n            long *ndp = new long[4];\n            ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD;\n            ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD;\n            ndp[0b10] = (dp[0b01] + dp[0b00]) % MOD;\n            ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) %  MOD;\n            delete []dp;\n            dp = ndp;\n        }   \n\n        return dp[0];\n\n\n    }\n};\n```\n\n另外上述线性变换可以替换为矩阵乘法的变换形式，不过太稀疏了……\n\n### 找规律：\n\n```C++\n\nclass Solution {\npublic:\n    int numTilings(int N) {\n        const int MOD = 1e9 + 7;\n        int sum0 = 1, sum1 = 1, sum2 = 2, sum3 = 5, sum;\n        for(int i = 4; i <= N; ++i){\n            sum = ((sum3 * 2) % MOD + sum1) % MOD;\n            sum1 = sum2;\n            sum2 = sum3;\n            sum3 = sum;\n        }\n        if(N == 1) return 1;\n        else if(N == 2) return 2;\n        else if(N == 3) return 5;\n        return sum;\n\n\n    }\n};s\n```","slug":"刷题/DP/790-Domino-and-Tromino-Tiling","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3m0010l5uof5plhgim","content":"<p>这题真的需要很多考虑</p>\n<span id=\"more\"></span>\n\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><p>可以进行bit dp，设置<code>dp[status]</code>为当前列为状态<code>status</code>时的拼接方法。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">status &#x3D; 0b00 : 上下格子都为空\nstatus &#x3D; 0b10 : 上格子填好，下格子为空\nstatus &#x3D; 0b01 : 下格子填好，上格子为空\nstatus &#x3D; 0b11 : 上下格子都填好<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所以就是有以下DP方程转移方式：</p>\n<p><img src=\"http://static.come2rss.xyz/possible.png\" alt=\"img\"></p>\n<p>注意<code>dp[0]=0</code>。</p>\n<h3 id=\"找规律\"><a href=\"#找规律\" class=\"headerlink\" title=\"找规律\"></a>找规律</h3><p>另一种方法也是我一开始想的方法，不过想错了，没有考虑托米诺和多米诺无限增长的可能性。😑🤐</p>\n<p>参考以为大佬的<a href=\"https://blog.csdn.net/ccnuacmhdu/article/details/103412944\">博文</a></p>\n<p><img src=\"http://static.come2rss.xyz/20191208142123502.png\" alt=\"img\"></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><h3 id=\"DP-1\"><a href=\"#DP-1\" class=\"headerlink\" title=\"DP\"></a>DP</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numTilings(int N) &#123;\n        const int MOD &#x3D; 1e9 + 7;\n        &#x2F;&#x2F; int[] dp&#x3D; new int[]&#123;1,0,0,0&#125;;\n        long  *dp &#x3D; new long[]&#123;1, 0, 0, 0&#125;;\n        for(int i &#x3D; 0; i &lt; N; ++i)&#123;\n            long *ndp &#x3D; new long[4];\n            ndp[0b00] &#x3D; (dp[0b00] + dp[0b11]) % MOD;\n            ndp[0b01] &#x3D; (dp[0b00] + dp[0b10]) % MOD;\n            ndp[0b10] &#x3D; (dp[0b01] + dp[0b00]) % MOD;\n            ndp[0b11] &#x3D; (dp[0b00] + dp[0b01] + dp[0b10]) %  MOD;\n            delete []dp;\n            dp &#x3D; ndp;\n        &#125;   \n\n        return dp[0];\n\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>另外上述线性变换可以替换为矩阵乘法的变换形式，不过太稀疏了……</p>\n<h3 id=\"找规律：\"><a href=\"#找规律：\" class=\"headerlink\" title=\"找规律：\"></a>找规律：</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\nclass Solution &#123;\npublic:\n    int numTilings(int N) &#123;\n        const int MOD &#x3D; 1e9 + 7;\n        int sum0 &#x3D; 1, sum1 &#x3D; 1, sum2 &#x3D; 2, sum3 &#x3D; 5, sum;\n        for(int i &#x3D; 4; i &lt;&#x3D; N; ++i)&#123;\n            sum &#x3D; ((sum3 * 2) % MOD + sum1) % MOD;\n            sum1 &#x3D; sum2;\n            sum2 &#x3D; sum3;\n            sum3 &#x3D; sum;\n        &#125;\n        if(N &#x3D;&#x3D; 1) return 1;\n        else if(N &#x3D;&#x3D; 2) return 2;\n        else if(N &#x3D;&#x3D; 3) return 5;\n        return sum;\n\n\n    &#125;\n&#125;;s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"7V3GVS","excerpt":"<p>这题真的需要很多考虑</p>","more":"<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><h3 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h3><p>可以进行bit dp，设置<code>dp[status]</code>为当前列为状态<code>status</code>时的拼接方法。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">status &#x3D; 0b00 : 上下格子都为空\nstatus &#x3D; 0b10 : 上格子填好，下格子为空\nstatus &#x3D; 0b01 : 下格子填好，上格子为空\nstatus &#x3D; 0b11 : 上下格子都填好<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所以就是有以下DP方程转移方式：</p>\n<p><img src=\"http://static.come2rss.xyz/possible.png\" alt=\"img\"></p>\n<p>注意<code>dp[0]=0</code>。</p>\n<h3 id=\"找规律\"><a href=\"#找规律\" class=\"headerlink\" title=\"找规律\"></a>找规律</h3><p>另一种方法也是我一开始想的方法，不过想错了，没有考虑托米诺和多米诺无限增长的可能性。😑🤐</p>\n<p>参考以为大佬的<a href=\"https://blog.csdn.net/ccnuacmhdu/article/details/103412944\">博文</a></p>\n<p><img src=\"http://static.come2rss.xyz/20191208142123502.png\" alt=\"img\"></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><h3 id=\"DP-1\"><a href=\"#DP-1\" class=\"headerlink\" title=\"DP\"></a>DP</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numTilings(int N) &#123;\n        const int MOD &#x3D; 1e9 + 7;\n        &#x2F;&#x2F; int[] dp&#x3D; new int[]&#123;1,0,0,0&#125;;\n        long  *dp &#x3D; new long[]&#123;1, 0, 0, 0&#125;;\n        for(int i &#x3D; 0; i &lt; N; ++i)&#123;\n            long *ndp &#x3D; new long[4];\n            ndp[0b00] &#x3D; (dp[0b00] + dp[0b11]) % MOD;\n            ndp[0b01] &#x3D; (dp[0b00] + dp[0b10]) % MOD;\n            ndp[0b10] &#x3D; (dp[0b01] + dp[0b00]) % MOD;\n            ndp[0b11] &#x3D; (dp[0b00] + dp[0b01] + dp[0b10]) %  MOD;\n            delete []dp;\n            dp &#x3D; ndp;\n        &#125;   \n\n        return dp[0];\n\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>另外上述线性变换可以替换为矩阵乘法的变换形式，不过太稀疏了……</p>\n<h3 id=\"找规律：\"><a href=\"#找规律：\" class=\"headerlink\" title=\"找规律：\"></a>找规律：</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\nclass Solution &#123;\npublic:\n    int numTilings(int N) &#123;\n        const int MOD &#x3D; 1e9 + 7;\n        int sum0 &#x3D; 1, sum1 &#x3D; 1, sum2 &#x3D; 2, sum3 &#x3D; 5, sum;\n        for(int i &#x3D; 4; i &lt;&#x3D; N; ++i)&#123;\n            sum &#x3D; ((sum3 * 2) % MOD + sum1) % MOD;\n            sum1 &#x3D; sum2;\n            sum2 &#x3D; sum3;\n            sum3 &#x3D; sum;\n        &#125;\n        if(N &#x3D;&#x3D; 1) return 1;\n        else if(N &#x3D;&#x3D; 2) return 2;\n        else if(N &#x3D;&#x3D; 3) return 5;\n        return sum;\n\n\n    &#125;\n&#125;;s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"91. Decode Ways","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-11T01:59:25.000Z","_content":"\n\n\n\n## [91. Decode Ways](https://leetcode-cn.com/problems/decode-ways/)\n\n## 思路：\n\n$dp[i]$表示数字字符子串$S[0...i]$所能表示的字符串数量。dp方程见代码。\n\n注意点：\n\n1. $0$无法被直接表示，因此dp方程分支扩大了一倍。\n2. 为了方便初始化，可以添加前缀零。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        s = \"00\" + s; //添加前缀，方便设置dp初始值\n        int n = s.size();\n        vector<int>dp(n, 0);\n        if(n == 2 || s[2] == '0') return 0;\n        dp[0] = dp[1] = 1;\n        \n        for(int i = 2; i < n; ++i){            \n            if(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] < '7')){                \n                if(s[i] == '0') dp[i] = dp[i - 2];\n                else dp[i] = dp[i - 2]  + dp[i - 1];\n            }\n            else if(s[i] == '0') dp[i] = 0;\n            else dp[i] = dp[i - 1];\n        }\n        return dp[n - 1];\n    }\n};\n```","source":"_posts/刷题/DP/91-Decode-Ways.md","raw":"---\ntitle: 91. Decode Ways\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-11 09:59:25\n---\n\n\n\n\n## [91. Decode Ways](https://leetcode-cn.com/problems/decode-ways/)\n\n## 思路：\n\n$dp[i]$表示数字字符子串$S[0...i]$所能表示的字符串数量。dp方程见代码。\n\n注意点：\n\n1. $0$无法被直接表示，因此dp方程分支扩大了一倍。\n2. 为了方便初始化，可以添加前缀零。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        s = \"00\" + s; //添加前缀，方便设置dp初始值\n        int n = s.size();\n        vector<int>dp(n, 0);\n        if(n == 2 || s[2] == '0') return 0;\n        dp[0] = dp[1] = 1;\n        \n        for(int i = 2; i < n; ++i){            \n            if(s[i - 1] == '1' || (s[i - 1] == '2' && s[i] < '7')){                \n                if(s[i] == '0') dp[i] = dp[i - 2];\n                else dp[i] = dp[i - 2]  + dp[i - 1];\n            }\n            else if(s[i] == '0') dp[i] = 0;\n            else dp[i] = dp[i - 1];\n        }\n        return dp[n - 1];\n    }\n};\n```","slug":"刷题/DP/91-Decode-Ways","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3m0011l5uocm04fnna","content":"<h2 id=\"91-Decode-Ways\"><a href=\"#91-Decode-Ways\" class=\"headerlink\" title=\"91. Decode Ways\"></a><a href=\"https://leetcode-cn.com/problems/decode-ways/\">91. Decode Ways</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>$dp[i]$表示数字字符子串$S[0…i]$所能表示的字符串数量。dp方程见代码。</p>\n<p>注意点：</p>\n<ol>\n<li>$0$无法被直接表示，因此dp方程分支扩大了一倍。</li>\n<li>为了方便初始化，可以添加前缀零。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int numDecodings(string s) &#123;\n        s &#x3D; &quot;00&quot; + s; &#x2F;&#x2F;添加前缀，方便设置dp初始值\n        int n &#x3D; s.size();\n        vector&lt;int&gt;dp(n, 0);\n        if(n &#x3D;&#x3D; 2 || s[2] &#x3D;&#x3D; &#39;0&#39;) return 0;\n        dp[0] &#x3D; dp[1] &#x3D; 1;\n        \n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;            \n            if(s[i - 1] &#x3D;&#x3D; &#39;1&#39; || (s[i - 1] &#x3D;&#x3D; &#39;2&#39; &amp;&amp; s[i] &lt; &#39;7&#39;))&#123;                \n                if(s[i] &#x3D;&#x3D; &#39;0&#39;) dp[i] &#x3D; dp[i - 2];\n                else dp[i] &#x3D; dp[i - 2]  + dp[i - 1];\n            &#125;\n            else if(s[i] &#x3D;&#x3D; &#39;0&#39;) dp[i] &#x3D; 0;\n            else dp[i] &#x3D; dp[i - 1];\n        &#125;\n        return dp[n - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3WK72S7","excerpt":"<h2 id=\"91-Decode-Ways\"><a href=\"#91-Decode-Ways\" class=\"headerlink\" title=\"91. Decode Ways\"></a><a href=\"https://leetcode-cn.com/problems/decode-ways/\">91. Decode Ways</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>$dp[i]$表示数字字符子串$S[0…i]$所能表示的字符串数量。dp方程见代码。</p>\n<p>注意点：</p>\n<ol>\n<li>$0$无法被直接表示，因此dp方程分支扩大了一倍。</li>\n<li>为了方便初始化，可以添加前缀零。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int numDecodings(string s) &#123;\n        s &#x3D; &quot;00&quot; + s; &#x2F;&#x2F;添加前缀，方便设置dp初始值\n        int n &#x3D; s.size();\n        vector&lt;int&gt;dp(n, 0);\n        if(n &#x3D;&#x3D; 2 || s[2] &#x3D;&#x3D; &#39;0&#39;) return 0;\n        dp[0] &#x3D; dp[1] &#x3D; 1;\n        \n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;            \n            if(s[i - 1] &#x3D;&#x3D; &#39;1&#39; || (s[i - 1] &#x3D;&#x3D; &#39;2&#39; &amp;&amp; s[i] &lt; &#39;7&#39;))&#123;                \n                if(s[i] &#x3D;&#x3D; &#39;0&#39;) dp[i] &#x3D; dp[i - 2];\n                else dp[i] &#x3D; dp[i - 2]  + dp[i - 1];\n            &#125;\n            else if(s[i] &#x3D;&#x3D; &#39;0&#39;) dp[i] &#x3D; 0;\n            else dp[i] &#x3D; dp[i - 1];\n        &#125;\n        return dp[n - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"96. Unique Binary Search Trees","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-04-29T04:55:37.000Z","_content":"\n\n\n\n# [96. Unique Binary Search Trees](https://leetcode-cn.com/problems/unique-binary-search-trees/)s\n\n## 思路：\n\n理解，只要数字不重复，子树的形状可能性就与数字具体大小无关。所以可以用DP算出长度为K的子树的可能形状。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\n    int  allmount = 0;\n    vector<int> dp;\npublic:\n    int numTrees(int n) {\n        dp.resize(n + 1);\n        dp[1] = 1;\n        dp[0] = 1;\n        return findBST(1, n);\n    }\n\n    int findBST(int L, int R){\n        if(dp[R - L + 1]) return dp[R - L + 1];\n        // if(L >= R){             \n        //      return 1;\n        // }\n        int nums = 0;\n        for(int i = L; i <= R; ++i){\n        \n            nums += findBST(L, i - 1) * findBST(i + 1, R);\n        }\n        // cout << L << ' ' << R  << ' ' << nums << endl;\n        dp[R - L + 1] = nums;\n        return nums;\n    }\n};\n```\n\n","source":"_posts/刷题/DP/96-Unique-Binary-Search-Trees.md","raw":"---\ntitle: 96. Unique Binary Search Trees\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-04-29 12:55:37\ntags:\ncategories:\n---\n\n\n\n\n# [96. Unique Binary Search Trees](https://leetcode-cn.com/problems/unique-binary-search-trees/)s\n\n## 思路：\n\n理解，只要数字不重复，子树的形状可能性就与数字具体大小无关。所以可以用DP算出长度为K的子树的可能形状。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\n    int  allmount = 0;\n    vector<int> dp;\npublic:\n    int numTrees(int n) {\n        dp.resize(n + 1);\n        dp[1] = 1;\n        dp[0] = 1;\n        return findBST(1, n);\n    }\n\n    int findBST(int L, int R){\n        if(dp[R - L + 1]) return dp[R - L + 1];\n        // if(L >= R){             \n        //      return 1;\n        // }\n        int nums = 0;\n        for(int i = L; i <= R; ++i){\n        \n            nums += findBST(L, i - 1) * findBST(i + 1, R);\n        }\n        // cout << L << ' ' << R  << ' ' << nums << endl;\n        dp[R - L + 1] = nums;\n        return nums;\n    }\n};\n```\n\n","slug":"刷题/DP/96-Unique-Binary-Search-Trees","published":1,"updated":"2021-04-29T04:58:02.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3n0012l5uoh52ihpo8","content":"<h1 id=\"96-Unique-Binary-Search-Treess\"><a href=\"#96-Unique-Binary-Search-Treess\" class=\"headerlink\" title=\"96. Unique Binary Search Treess\"></a><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\">96. Unique Binary Search Trees</a>s</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>理解，只要数字不重复，子树的形状可能性就与数字具体大小无关。所以可以用DP算出长度为K的子树的可能形状。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    int  allmount &#x3D; 0;\n    vector&lt;int&gt; dp;\npublic:\n    int numTrees(int n) &#123;\n        dp.resize(n + 1);\n        dp[1] &#x3D; 1;\n        dp[0] &#x3D; 1;\n        return findBST(1, n);\n    &#125;\n\n    int findBST(int L, int R)&#123;\n        if(dp[R - L + 1]) return dp[R - L + 1];\n        &#x2F;&#x2F; if(L &gt;&#x3D; R)&#123;             \n        &#x2F;&#x2F;      return 1;\n        &#x2F;&#x2F; &#125;\n        int nums &#x3D; 0;\n        for(int i &#x3D; L; i &lt;&#x3D; R; ++i)&#123;\n        \n            nums +&#x3D; findBST(L, i - 1) * findBST(i + 1, R);\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; L &lt;&lt; &#39; &#39; &lt;&lt; R  &lt;&lt; &#39; &#39; &lt;&lt; nums &lt;&lt; endl;\n        dp[R - L + 1] &#x3D; nums;\n        return nums;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1CH9870","excerpt":"<h1 id=\"96-Unique-Binary-Search-Treess\"><a href=\"#96-Unique-Binary-Search-Treess\" class=\"headerlink\" title=\"96. Unique Binary Search Treess\"></a><a href=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\">96. Unique Binary Search Trees</a>s</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>理解，只要数字不重复，子树的形状可能性就与数字具体大小无关。所以可以用DP算出长度为K的子树的可能形状。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    int  allmount &#x3D; 0;\n    vector&lt;int&gt; dp;\npublic:\n    int numTrees(int n) &#123;\n        dp.resize(n + 1);\n        dp[1] &#x3D; 1;\n        dp[0] &#x3D; 1;\n        return findBST(1, n);\n    &#125;\n\n    int findBST(int L, int R)&#123;\n        if(dp[R - L + 1]) return dp[R - L + 1];\n        &#x2F;&#x2F; if(L &gt;&#x3D; R)&#123;             \n        &#x2F;&#x2F;      return 1;\n        &#x2F;&#x2F; &#125;\n        int nums &#x3D; 0;\n        for(int i &#x3D; L; i &lt;&#x3D; R; ++i)&#123;\n        \n            nums +&#x3D; findBST(L, i - 1) * findBST(i + 1, R);\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; L &lt;&lt; &#39; &#39; &lt;&lt; R  &lt;&lt; &#39; &#39; &lt;&lt; nums &lt;&lt; endl;\n        dp[R - L + 1] &#x3D; nums;\n        return nums;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"P1025 数的划分","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-17T23:24:40.000Z","_content":"\n<!-- more -->\n\n\n\n## 思路：\n\n秀的一批的dp：可以把问题分解两位子问题Q1(a), Q2(b)，其中a+b==1。\n\nQ1(a): 将a分解为含有1的分解方案。将其中的一个1去掉，可转化其他问题。\n\nQ2(b): 将a分解为不含有1的分解方案。将每个数都减去1，可转化为其他问题。\n\n那么有那么`dp(n,k)=dp(n-1,k-1)+dp(n-k,k)`。\n\n保持边界`dp[i][1] = 1, i>=1 && i<=n`。\n\n\n\n## 代码：\n\n```c++\n\n#include<bits/stdc++.h>\n\nint n = 205, k = 21;\nint dp[205][20] ={0};\nint main(){\n    \n    // dp[0][0] = 1;\n    for(int i = 0;i < n; i++) dp[i][1] = 1;\n\n    for(int i = 2 ; i <= n; i++){\n        printf(\"%d \", dp[i][1]);\n        for(int j = 2; j <= i&& j < k; j++){\n            if(i >= j) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];\n        printf(\"%d \", dp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    while(scanf(\"%d%d\", &n, &k) != EOF){\n        printf(\"%d\\n\", dp[n][k]);\n    }\n    return 0;\n}\n```\n\n","source":"_posts/刷题/DP/P1025-数的划分.md","raw":"---\ntitle: P1025 数的划分\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-18 07:24:40\n---\n\n<!-- more -->\n\n\n\n## 思路：\n\n秀的一批的dp：可以把问题分解两位子问题Q1(a), Q2(b)，其中a+b==1。\n\nQ1(a): 将a分解为含有1的分解方案。将其中的一个1去掉，可转化其他问题。\n\nQ2(b): 将a分解为不含有1的分解方案。将每个数都减去1，可转化为其他问题。\n\n那么有那么`dp(n,k)=dp(n-1,k-1)+dp(n-k,k)`。\n\n保持边界`dp[i][1] = 1, i>=1 && i<=n`。\n\n\n\n## 代码：\n\n```c++\n\n#include<bits/stdc++.h>\n\nint n = 205, k = 21;\nint dp[205][20] ={0};\nint main(){\n    \n    // dp[0][0] = 1;\n    for(int i = 0;i < n; i++) dp[i][1] = 1;\n\n    for(int i = 2 ; i <= n; i++){\n        printf(\"%d \", dp[i][1]);\n        for(int j = 2; j <= i&& j < k; j++){\n            if(i >= j) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];\n        printf(\"%d \", dp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    while(scanf(\"%d%d\", &n, &k) != EOF){\n        printf(\"%d\\n\", dp[n][k]);\n    }\n    return 0;\n}\n```\n\n","slug":"刷题/DP/P1025-数的划分","published":1,"updated":"2021-01-28T14:04:37.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3o0013l5uo680g6oh2","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>秀的一批的dp：可以把问题分解两位子问题Q1(a), Q2(b)，其中a+b==1。</p>\n<p>Q1(a): 将a分解为含有1的分解方案。将其中的一个1去掉，可转化其他问题。</p>\n<p>Q2(b): 将a分解为不含有1的分解方案。将每个数都减去1，可转化为其他问题。</p>\n<p>那么有那么<code>dp(n,k)=dp(n-1,k-1)+dp(n-k,k)</code>。</p>\n<p>保持边界<code>dp[i][1] = 1, i&gt;=1 &amp;&amp; i&lt;=n</code>。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n#include&lt;bits&#x2F;stdc++.h&gt;\n\nint n &#x3D; 205, k &#x3D; 21;\nint dp[205][20] &#x3D;&#123;0&#125;;\nint main()&#123;\n    \n    &#x2F;&#x2F; dp[0][0] &#x3D; 1;\n    for(int i &#x3D; 0;i &lt; n; i++) dp[i][1] &#x3D; 1;\n\n    for(int i &#x3D; 2 ; i &lt;&#x3D; n; i++)&#123;\n        printf(&quot;%d &quot;, dp[i][1]);\n        for(int j &#x3D; 2; j &lt;&#x3D; i&amp;&amp; j &lt; k; j++)&#123;\n            if(i &gt;&#x3D; j) dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - j][j];\n        printf(&quot;%d &quot;, dp[i][j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) !&#x3D; EOF)&#123;\n        printf(&quot;%d\\n&quot;, dp[n][k]);\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"38ZTCZK","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>秀的一批的dp：可以把问题分解两位子问题Q1(a), Q2(b)，其中a+b==1。</p>\n<p>Q1(a): 将a分解为含有1的分解方案。将其中的一个1去掉，可转化其他问题。</p>\n<p>Q2(b): 将a分解为不含有1的分解方案。将每个数都减去1，可转化为其他问题。</p>\n<p>那么有那么<code>dp(n,k)=dp(n-1,k-1)+dp(n-k,k)</code>。</p>\n<p>保持边界<code>dp[i][1] = 1, i&gt;=1 &amp;&amp; i&lt;=n</code>。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n#include&lt;bits&#x2F;stdc++.h&gt;\n\nint n &#x3D; 205, k &#x3D; 21;\nint dp[205][20] &#x3D;&#123;0&#125;;\nint main()&#123;\n    \n    &#x2F;&#x2F; dp[0][0] &#x3D; 1;\n    for(int i &#x3D; 0;i &lt; n; i++) dp[i][1] &#x3D; 1;\n\n    for(int i &#x3D; 2 ; i &lt;&#x3D; n; i++)&#123;\n        printf(&quot;%d &quot;, dp[i][1]);\n        for(int j &#x3D; 2; j &lt;&#x3D; i&amp;&amp; j &lt; k; j++)&#123;\n            if(i &gt;&#x3D; j) dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - j][j];\n        printf(&quot;%d &quot;, dp[i][j]);\n        &#125;\n        printf(&quot;\\n&quot;);\n    &#125;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) !&#x3D; EOF)&#123;\n        printf(&quot;%d\\n&quot;, dp[n][k]);\n    &#125;\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题 17.24. 最大子矩阵","thumbnail":"http://static.come2rss.xyz/portal.png","toc":true,"top":10,"date":"2021-05-10T01:36:53.000Z","_content":"\n\n\n# [面试题 17.24. 最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)\n\n\n\n## 思路：\n\n本题是最大连续子数组的二维follow up.\n\n一维情况下，可以直接使用多种算法求解：\n\n1. 累加数组+二维搜索左右边界， $O(N^2)$\n\n2. 二维搜索左右边界同时累加数字，$O(N^2)$\n\n3. 分治算法，把问题`maxarr(i, j)`分解为`maxarr(i, mid)`和`maxarr(mid + 1, j)`。其中子数组可能在左右两端数组中或者横跨两个段，所以从中间向两边搜索最大连续数组和`Sum1`，如此解决了一个基本问题，并且递归的将小问题解决，获取总的问题的解。$O(NLogN)$\n\n4. 线段树做法，同样也是分治的思想，但是考虑的更多。`maxarr(i, j)`分解为`maxarr(i, mid)`和`maxarr(mid + 1, j)`。基本问题是`arr(i, j)`中的`suml`，`sumr`, `sumi`和`summ`，分别代表从左边开始的子数组的和，从右边开始的子数组的和，在中间扩展的子数组的和，和整个数组的和。而我们要大问题的`sumi`就是所要求的值，巧妙的地方在于问题的分解，`sumi`可以就是子数组的`sumi`和左子段的`sumr`与右子段的`suml`之和最大值。其他同理。\n\n5. DP做法，以`dp[i]`为`arr[i]`为结尾的和最大的连续子数组的和。状态更新方程为\n   $$\n   dp[i] = max(dp[i - 1] + arr[i], arr[i])\n   $$\n   \n\n这很有趣，实际上就是舍弃掉可能为负数的`dp[i - 1]`， 另外在舍弃时也可以记录下数组起点。更进一步的观察，空间可以优化到`O(1)`。\n\n\n\n二维情况下，虽然非常相似，但是解法一时想不到直接扩展到二维。但是问题可以化解为一维。\n\n在确定了矩阵行数据，或者首先遍历矩阵的上下界后，顺道求出该矩阵的在各各列的和。之后便可以用一维的做法求出连续列的最大和。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    int n;\n    int m;\n    vector<int> b;\npublic:\n    vector<int> getMaxMatrix(vector<vector<int>>& matrix) {\n        n = matrix.size();\n        m = matrix[0].size();\n        b.resize(m);\n        \n        vector<int> ans(4);\n        int maxval = matrix[0][0];\n        for(int i = 0; i < n; ++i){            \n            for(int j = i; j < n; ++j){\n                // accumulate the matrix in vertical sequences.\n                if(i == j){\n                    for(int k = 0; k < m; ++k) b[k] = matrix[i][k];\n                }else\n                    for(int k = 0; k < m; ++k) b[k] += matrix[j][k];\n                int sum = 0;\n                int begin = 0;\n                for(int l = 0; l < m; ++l){\n                    \n                    // sum = max(b[l], b[l] + sum);\n                    if(sum < 0){\n                        sum = 0;\n                        begin = l;\n                    }\n                    sum += b[l];\n\n                    if(sum > maxval){\n                        maxval = sum;\n                        ans[0] = i;\n                        ans[1] = begin;\n                        ans[2] = j;\n                        ans[3] = l;\n                    }\n                }        \n            }\n        }\n        return ans;\n    }\n};\n```\n\n","source":"_posts/刷题/DP/面试题-17-24-最大子矩阵.md","raw":"---\ntitle: 面试题 17.24. 最大子矩阵\nthumbnail: 'http://static.come2rss.xyz/portal.png'\ntoc: true\ntop: 10\ndate: 2021-05-10 09:36:53\ntags:\ncategories:\n---\n\n\n\n# [面试题 17.24. 最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)\n\n\n\n## 思路：\n\n本题是最大连续子数组的二维follow up.\n\n一维情况下，可以直接使用多种算法求解：\n\n1. 累加数组+二维搜索左右边界， $O(N^2)$\n\n2. 二维搜索左右边界同时累加数字，$O(N^2)$\n\n3. 分治算法，把问题`maxarr(i, j)`分解为`maxarr(i, mid)`和`maxarr(mid + 1, j)`。其中子数组可能在左右两端数组中或者横跨两个段，所以从中间向两边搜索最大连续数组和`Sum1`，如此解决了一个基本问题，并且递归的将小问题解决，获取总的问题的解。$O(NLogN)$\n\n4. 线段树做法，同样也是分治的思想，但是考虑的更多。`maxarr(i, j)`分解为`maxarr(i, mid)`和`maxarr(mid + 1, j)`。基本问题是`arr(i, j)`中的`suml`，`sumr`, `sumi`和`summ`，分别代表从左边开始的子数组的和，从右边开始的子数组的和，在中间扩展的子数组的和，和整个数组的和。而我们要大问题的`sumi`就是所要求的值，巧妙的地方在于问题的分解，`sumi`可以就是子数组的`sumi`和左子段的`sumr`与右子段的`suml`之和最大值。其他同理。\n\n5. DP做法，以`dp[i]`为`arr[i]`为结尾的和最大的连续子数组的和。状态更新方程为\n   $$\n   dp[i] = max(dp[i - 1] + arr[i], arr[i])\n   $$\n   \n\n这很有趣，实际上就是舍弃掉可能为负数的`dp[i - 1]`， 另外在舍弃时也可以记录下数组起点。更进一步的观察，空间可以优化到`O(1)`。\n\n\n\n二维情况下，虽然非常相似，但是解法一时想不到直接扩展到二维。但是问题可以化解为一维。\n\n在确定了矩阵行数据，或者首先遍历矩阵的上下界后，顺道求出该矩阵的在各各列的和。之后便可以用一维的做法求出连续列的最大和。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    int n;\n    int m;\n    vector<int> b;\npublic:\n    vector<int> getMaxMatrix(vector<vector<int>>& matrix) {\n        n = matrix.size();\n        m = matrix[0].size();\n        b.resize(m);\n        \n        vector<int> ans(4);\n        int maxval = matrix[0][0];\n        for(int i = 0; i < n; ++i){            \n            for(int j = i; j < n; ++j){\n                // accumulate the matrix in vertical sequences.\n                if(i == j){\n                    for(int k = 0; k < m; ++k) b[k] = matrix[i][k];\n                }else\n                    for(int k = 0; k < m; ++k) b[k] += matrix[j][k];\n                int sum = 0;\n                int begin = 0;\n                for(int l = 0; l < m; ++l){\n                    \n                    // sum = max(b[l], b[l] + sum);\n                    if(sum < 0){\n                        sum = 0;\n                        begin = l;\n                    }\n                    sum += b[l];\n\n                    if(sum > maxval){\n                        maxval = sum;\n                        ans[0] = i;\n                        ans[1] = begin;\n                        ans[2] = j;\n                        ans[3] = l;\n                    }\n                }        \n            }\n        }\n        return ans;\n    }\n};\n```\n\n","slug":"刷题/DP/面试题-17-24-最大子矩阵","published":1,"updated":"2021-05-10T01:55:26.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3p0014l5uoartp1rfq","content":"<h1 id=\"面试题-17-24-最大子矩阵\"><a href=\"#面试题-17-24-最大子矩阵\" class=\"headerlink\" title=\"面试题 17.24. 最大子矩阵\"></a><a href=\"https://leetcode-cn.com/problems/max-submatrix-lcci/\">面试题 17.24. 最大子矩阵</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>本题是最大连续子数组的二维follow up.</p>\n<p>一维情况下，可以直接使用多种算法求解：</p>\n<ol>\n<li><p>累加数组+二维搜索左右边界， $O(N^2)$</p>\n</li>\n<li><p>二维搜索左右边界同时累加数字，$O(N^2)$</p>\n</li>\n<li><p>分治算法，把问题<code>maxarr(i, j)</code>分解为<code>maxarr(i, mid)</code>和<code>maxarr(mid + 1, j)</code>。其中子数组可能在左右两端数组中或者横跨两个段，所以从中间向两边搜索最大连续数组和<code>Sum1</code>，如此解决了一个基本问题，并且递归的将小问题解决，获取总的问题的解。$O(NLogN)$</p>\n</li>\n<li><p>线段树做法，同样也是分治的思想，但是考虑的更多。<code>maxarr(i, j)</code>分解为<code>maxarr(i, mid)</code>和<code>maxarr(mid + 1, j)</code>。基本问题是<code>arr(i, j)</code>中的<code>suml</code>，<code>sumr</code>, <code>sumi</code>和<code>summ</code>，分别代表从左边开始的子数组的和，从右边开始的子数组的和，在中间扩展的子数组的和，和整个数组的和。而我们要大问题的<code>sumi</code>就是所要求的值，巧妙的地方在于问题的分解，<code>sumi</code>可以就是子数组的<code>sumi</code>和左子段的<code>sumr</code>与右子段的<code>suml</code>之和最大值。其他同理。</p>\n</li>\n<li><p>DP做法，以<code>dp[i]</code>为<code>arr[i]</code>为结尾的和最大的连续子数组的和。状态更新方程为<br>$$<br>dp[i] = max(dp[i - 1] + arr[i], arr[i])<br>$$</p>\n</li>\n</ol>\n<p>这很有趣，实际上就是舍弃掉可能为负数的<code>dp[i - 1]</code>， 另外在舍弃时也可以记录下数组起点。更进一步的观察，空间可以优化到<code>O(1)</code>。</p>\n<p>二维情况下，虽然非常相似，但是解法一时想不到直接扩展到二维。但是问题可以化解为一维。</p>\n<p>在确定了矩阵行数据，或者首先遍历矩阵的上下界后，顺道求出该矩阵的在各各列的和。之后便可以用一维的做法求出连续列的最大和。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    int n;\n    int m;\n    vector&lt;int&gt; b;\npublic:\n    vector&lt;int&gt; getMaxMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        n &#x3D; matrix.size();\n        m &#x3D; matrix[0].size();\n        b.resize(m);\n        \n        vector&lt;int&gt; ans(4);\n        int maxval &#x3D; matrix[0][0];\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;            \n            for(int j &#x3D; i; j &lt; n; ++j)&#123;\n                &#x2F;&#x2F; accumulate the matrix in vertical sequences.\n                if(i &#x3D;&#x3D; j)&#123;\n                    for(int k &#x3D; 0; k &lt; m; ++k) b[k] &#x3D; matrix[i][k];\n                &#125;else\n                    for(int k &#x3D; 0; k &lt; m; ++k) b[k] +&#x3D; matrix[j][k];\n                int sum &#x3D; 0;\n                int begin &#x3D; 0;\n                for(int l &#x3D; 0; l &lt; m; ++l)&#123;\n                    \n                    &#x2F;&#x2F; sum &#x3D; max(b[l], b[l] + sum);\n                    if(sum &lt; 0)&#123;\n                        sum &#x3D; 0;\n                        begin &#x3D; l;\n                    &#125;\n                    sum +&#x3D; b[l];\n\n                    if(sum &gt; maxval)&#123;\n                        maxval &#x3D; sum;\n                        ans[0] &#x3D; i;\n                        ans[1] &#x3D; begin;\n                        ans[2] &#x3D; j;\n                        ans[3] &#x3D; l;\n                    &#125;\n                &#125;        \n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"20SSMHQ","excerpt":"<h1 id=\"面试题-17-24-最大子矩阵\"><a href=\"#面试题-17-24-最大子矩阵\" class=\"headerlink\" title=\"面试题 17.24. 最大子矩阵\"></a><a href=\"https://leetcode-cn.com/problems/max-submatrix-lcci/\">面试题 17.24. 最大子矩阵</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>本题是最大连续子数组的二维follow up.</p>\n<p>一维情况下，可以直接使用多种算法求解：</p>\n<ol>\n<li><p>累加数组+二维搜索左右边界， $O(N^2)$</p>\n</li>\n<li><p>二维搜索左右边界同时累加数字，$O(N^2)$</p>\n</li>\n<li><p>分治算法，把问题<code>maxarr(i, j)</code>分解为<code>maxarr(i, mid)</code>和<code>maxarr(mid + 1, j)</code>。其中子数组可能在左右两端数组中或者横跨两个段，所以从中间向两边搜索最大连续数组和<code>Sum1</code>，如此解决了一个基本问题，并且递归的将小问题解决，获取总的问题的解。$O(NLogN)$</p>\n</li>\n<li><p>线段树做法，同样也是分治的思想，但是考虑的更多。<code>maxarr(i, j)</code>分解为<code>maxarr(i, mid)</code>和<code>maxarr(mid + 1, j)</code>。基本问题是<code>arr(i, j)</code>中的<code>suml</code>，<code>sumr</code>, <code>sumi</code>和<code>summ</code>，分别代表从左边开始的子数组的和，从右边开始的子数组的和，在中间扩展的子数组的和，和整个数组的和。而我们要大问题的<code>sumi</code>就是所要求的值，巧妙的地方在于问题的分解，<code>sumi</code>可以就是子数组的<code>sumi</code>和左子段的<code>sumr</code>与右子段的<code>suml</code>之和最大值。其他同理。</p>\n</li>\n<li><p>DP做法，以<code>dp[i]</code>为<code>arr[i]</code>为结尾的和最大的连续子数组的和。状态更新方程为<br>$$<br>dp[i] = max(dp[i - 1] + arr[i], arr[i])<br>$$</p>\n</li>\n</ol>\n<p>这很有趣，实际上就是舍弃掉可能为负数的<code>dp[i - 1]</code>， 另外在舍弃时也可以记录下数组起点。更进一步的观察，空间可以优化到<code>O(1)</code>。</p>\n<p>二维情况下，虽然非常相似，但是解法一时想不到直接扩展到二维。但是问题可以化解为一维。</p>\n<p>在确定了矩阵行数据，或者首先遍历矩阵的上下界后，顺道求出该矩阵的在各各列的和。之后便可以用一维的做法求出连续列的最大和。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    int n;\n    int m;\n    vector&lt;int&gt; b;\npublic:\n    vector&lt;int&gt; getMaxMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        n &#x3D; matrix.size();\n        m &#x3D; matrix[0].size();\n        b.resize(m);\n        \n        vector&lt;int&gt; ans(4);\n        int maxval &#x3D; matrix[0][0];\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;            \n            for(int j &#x3D; i; j &lt; n; ++j)&#123;\n                &#x2F;&#x2F; accumulate the matrix in vertical sequences.\n                if(i &#x3D;&#x3D; j)&#123;\n                    for(int k &#x3D; 0; k &lt; m; ++k) b[k] &#x3D; matrix[i][k];\n                &#125;else\n                    for(int k &#x3D; 0; k &lt; m; ++k) b[k] +&#x3D; matrix[j][k];\n                int sum &#x3D; 0;\n                int begin &#x3D; 0;\n                for(int l &#x3D; 0; l &lt; m; ++l)&#123;\n                    \n                    &#x2F;&#x2F; sum &#x3D; max(b[l], b[l] + sum);\n                    if(sum &lt; 0)&#123;\n                        sum &#x3D; 0;\n                        begin &#x3D; l;\n                    &#125;\n                    sum +&#x3D; b[l];\n\n                    if(sum &gt; maxval)&#123;\n                        maxval &#x3D; sum;\n                        ans[0] &#x3D; i;\n                        ans[1] &#x3D; begin;\n                        ans[2] &#x3D; j;\n                        ans[3] &#x3D; l;\n                    &#125;\n                &#125;        \n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题 DP 贪心","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:14:08.000Z","_content":"\n\n<!-- more -->\n\n收集贪心、DP面试题\n\n\n\n## 面14：剪绳子\n\n### 题面：\n\n将一串长为`K`的绳子剪成`m`（`m>=2`，各段长度取整数值）段，各段的长度大于`0`，求出最大的各段绳子长度之积。\n\n### 思路1：\n\n由乘法交换律可知绳子的乘积可以分解，提取出来。所以有`f(m+n)=f(n)*f(m)`，其中`f(n)`是长度`n`的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件`f(1) = 1, f(2) = 2, f(3) = 3`。同时在DP表示式为：\n\nf(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)\n\n\n所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。\n\n\n\n### 思路2：\n\n另一种就是贪心，对于长度`m`大于5的绳子尽可能的剪成长度为3的绳子，同时如果`m%3==1`，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:\n$$\nif \\ n \\geq 5\n\\\n3*(n-3) \\geq n\n\\\n2*(n-2) \\geq n\n\\\n3*(n -3 ) \\geq 2*(n-2)\n$$\n\n### 测试：\n\n```\n2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9\n```\n\n### 代码：\n\n**DP**\n\n```\nint maxProduct_DP(int length){\n    if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int* products = new int[length + 1];\n    //初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] = 0;\n    products[1] = 1;\n    products[2] = 2;\n    products[3] = 3;\n    for(int i = 4; i <= length; i++){\n        int mavV = 0;\n        for(int j = 1; j <= i / 2; j++){\n            maxV = max(maxV, products[i - j] * products[j]);\n        }\n        products[i] = maxv;\n    }\n    int res = products[length];\n    //防止内存泄漏\n    del[] products;\n    return res;\n}\n```\n\n**贪心**\n\n```\nint maxProduct_greedy(int length){\n if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int timesOf3 = length / 3;\n    if(legnth % 3 == 1) timesOf3 -= 1;\n    int timesOf2 = (length - timesOf3 * 3) / 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n}\n```\n\n## 面42：最大子数组和\n\n### 题面：\n\n如题\n\n### 思路：\n\nDP思想。数组之间的选择与历史无关，可以采取DP的方法。记`f(i)`为以`A[i]`为结尾的最大数组和。转移方程为：\n\nf(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0f(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0\n\n\n\n当然也可以直接从数据的角度理解，代码都是相同的。\n\n### 代码：\n\n```\nint MaxSumOfSubArray(int A[], int length){\n    int dp[] = new int(length);\n\tint maxSum = A[0];\n    dp[0] = A[0];   \n    for(int i = 1; i < length; i++){\n        dp[i] = max(A[i], A[i] + dp[i-1]);\n        maxSum = max(dp[i], maxSum);\n    }\n    delete[] dp;\n    return maxSum;\n    \n}\n```\n\n> 当然这里的dp数组也可以不要。\n\n## 面45：把数字排成最小的数字\n\n### 题目：\n\n给定一串数字，组合成的一个数字。求出组合后最小数字的\n\n### 思路：\n\n可以直接贪心+反证。按字典序排序数字即可。\n\n### 代码：\n\n就不写了，直接string排序输出即可。\n\n## 面46：数字翻译成字符串\n\n### 题目：\n\n把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。\n\n### 思路：\n\n第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。\n\n第二种用DP思想，考虑`dp[i]`为从`0`到`i`的字符串翻译方法。状态转移方程为：\n\ndp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else \n\n\n\n### 代码：\n\n```\nint GetTranslateCount(int A[], int length){\n    if(A == nullptr || length <= 0) return 0;\n    int dp[] = new int(length);\n    dp[0] = 1;\n    for(int i = 1; i < length; i++){\n\t\tint add = A[i - 1] * 10 + A[i];\n        if( add > 9 && add < 26){\n            if(i < 2) dp = dp[i - 1] + 1;\n            else dp[i] = dp[i - 1] + dp[i - 2];\n        } \n        else dp[i] = dp[i - 1];\n    }\n    delete[] dp;\n    return dp[length - 1];    \n}\n```\n\n## 面47：礼物的最大价值\n\n### 题目：\n\n从一在格子上装满礼物的`m*n`的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。\n\n### 思路：\n\n明显就是DP\n\n### 代码：\n\n不写了。\n\n## 面48：最长不含重复字符的子字符串\n\n### 题目：\n\n如题\n\n### 思路：\n\n暴力不可取。\n\n采用用DP思想，考虑`dp[i]`为以`S[i]`为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断`S[i]`的前一个相同字符是否在上一个`S[i-1]`为结尾的最长不重复字符串之内。记上一个字符与`S[i-1]`的长度`d`为`i - POS`。\n\n状态转移方程为：\n\ndp[i]={dp[i−1]+1,if d > dp[i - 1] d,else dp[i]={dp[i−1]+1,if d > dp[i - 1] d,else \n\n\n\n### 代码：\n\n```\nint MaxSubStr(String s){\n    int dp[] = new int(s.length());\n    int pos[26];\n    for(int i = 0; i < 26; i++) pos[[i] = -1;\n\t\n\tint maxL = 1;\n\tdp[0] = 1;\n\tfor(int i = 1; i < s.length(); i++){\n\t\tint d = i - pos[s[i] - 'a'];\n        if(dp[i - 1] < d){\n            dp[i] = dp[i - 1] + 1;\n        }else dp[i] = d;\n        maxL = max(maxL, dp[i]);\n        pos[s[i] - 'a'] = i;\n    }\n\tdelete[] dp;    \n   return maxL;            \n    \n}\n```","source":"_posts/刷题/DP/面试题-DP-贪心.md","raw":"---\ntitle: 面试题 DP 贪心\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 14:14:08\ntags:\n---\n\n\n<!-- more -->\n\n收集贪心、DP面试题\n\n\n\n## 面14：剪绳子\n\n### 题面：\n\n将一串长为`K`的绳子剪成`m`（`m>=2`，各段长度取整数值）段，各段的长度大于`0`，求出最大的各段绳子长度之积。\n\n### 思路1：\n\n由乘法交换律可知绳子的乘积可以分解，提取出来。所以有`f(m+n)=f(n)*f(m)`，其中`f(n)`是长度`n`的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件`f(1) = 1, f(2) = 2, f(3) = 3`。同时在DP表示式为：\n\nf(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)\n\n\n所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。\n\n\n\n### 思路2：\n\n另一种就是贪心，对于长度`m`大于5的绳子尽可能的剪成长度为3的绳子，同时如果`m%3==1`，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:\n$$\nif \\ n \\geq 5\n\\\n3*(n-3) \\geq n\n\\\n2*(n-2) \\geq n\n\\\n3*(n -3 ) \\geq 2*(n-2)\n$$\n\n### 测试：\n\n```\n2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9\n```\n\n### 代码：\n\n**DP**\n\n```\nint maxProduct_DP(int length){\n    if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int* products = new int[length + 1];\n    //初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] = 0;\n    products[1] = 1;\n    products[2] = 2;\n    products[3] = 3;\n    for(int i = 4; i <= length; i++){\n        int mavV = 0;\n        for(int j = 1; j <= i / 2; j++){\n            maxV = max(maxV, products[i - j] * products[j]);\n        }\n        products[i] = maxv;\n    }\n    int res = products[length];\n    //防止内存泄漏\n    del[] products;\n    return res;\n}\n```\n\n**贪心**\n\n```\nint maxProduct_greedy(int length){\n if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int timesOf3 = length / 3;\n    if(legnth % 3 == 1) timesOf3 -= 1;\n    int timesOf2 = (length - timesOf3 * 3) / 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n}\n```\n\n## 面42：最大子数组和\n\n### 题面：\n\n如题\n\n### 思路：\n\nDP思想。数组之间的选择与历史无关，可以采取DP的方法。记`f(i)`为以`A[i]`为结尾的最大数组和。转移方程为：\n\nf(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0f(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0\n\n\n\n当然也可以直接从数据的角度理解，代码都是相同的。\n\n### 代码：\n\n```\nint MaxSumOfSubArray(int A[], int length){\n    int dp[] = new int(length);\n\tint maxSum = A[0];\n    dp[0] = A[0];   \n    for(int i = 1; i < length; i++){\n        dp[i] = max(A[i], A[i] + dp[i-1]);\n        maxSum = max(dp[i], maxSum);\n    }\n    delete[] dp;\n    return maxSum;\n    \n}\n```\n\n> 当然这里的dp数组也可以不要。\n\n## 面45：把数字排成最小的数字\n\n### 题目：\n\n给定一串数字，组合成的一个数字。求出组合后最小数字的\n\n### 思路：\n\n可以直接贪心+反证。按字典序排序数字即可。\n\n### 代码：\n\n就不写了，直接string排序输出即可。\n\n## 面46：数字翻译成字符串\n\n### 题目：\n\n把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。\n\n### 思路：\n\n第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。\n\n第二种用DP思想，考虑`dp[i]`为从`0`到`i`的字符串翻译方法。状态转移方程为：\n\ndp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else \n\n\n\n### 代码：\n\n```\nint GetTranslateCount(int A[], int length){\n    if(A == nullptr || length <= 0) return 0;\n    int dp[] = new int(length);\n    dp[0] = 1;\n    for(int i = 1; i < length; i++){\n\t\tint add = A[i - 1] * 10 + A[i];\n        if( add > 9 && add < 26){\n            if(i < 2) dp = dp[i - 1] + 1;\n            else dp[i] = dp[i - 1] + dp[i - 2];\n        } \n        else dp[i] = dp[i - 1];\n    }\n    delete[] dp;\n    return dp[length - 1];    \n}\n```\n\n## 面47：礼物的最大价值\n\n### 题目：\n\n从一在格子上装满礼物的`m*n`的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。\n\n### 思路：\n\n明显就是DP\n\n### 代码：\n\n不写了。\n\n## 面48：最长不含重复字符的子字符串\n\n### 题目：\n\n如题\n\n### 思路：\n\n暴力不可取。\n\n采用用DP思想，考虑`dp[i]`为以`S[i]`为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断`S[i]`的前一个相同字符是否在上一个`S[i-1]`为结尾的最长不重复字符串之内。记上一个字符与`S[i-1]`的长度`d`为`i - POS`。\n\n状态转移方程为：\n\ndp[i]={dp[i−1]+1,if d > dp[i - 1] d,else dp[i]={dp[i−1]+1,if d > dp[i - 1] d,else \n\n\n\n### 代码：\n\n```\nint MaxSubStr(String s){\n    int dp[] = new int(s.length());\n    int pos[26];\n    for(int i = 0; i < 26; i++) pos[[i] = -1;\n\t\n\tint maxL = 1;\n\tdp[0] = 1;\n\tfor(int i = 1; i < s.length(); i++){\n\t\tint d = i - pos[s[i] - 'a'];\n        if(dp[i - 1] < d){\n            dp[i] = dp[i - 1] + 1;\n        }else dp[i] = d;\n        maxL = max(maxL, dp[i]);\n        pos[s[i] - 'a'] = i;\n    }\n\tdelete[] dp;    \n   return maxL;            \n    \n}\n```","slug":"刷题/DP/面试题-DP-贪心","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3q0015l5uodocibff4","content":"<span id=\"more\"></span>\n\n<p>收集贪心、DP面试题</p>\n<h2 id=\"面14：剪绳子\"><a href=\"#面14：剪绳子\" class=\"headerlink\" title=\"面14：剪绳子\"></a>面14：剪绳子</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>将一串长为<code>K</code>的绳子剪成<code>m</code>（<code>m&gt;=2</code>，各段长度取整数值）段，各段的长度大于<code>0</code>，求出最大的各段绳子长度之积。</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>由乘法交换律可知绳子的乘积可以分解，提取出来。所以有<code>f(m+n)=f(n)*f(m)</code>，其中<code>f(n)</code>是长度<code>n</code>的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件<code>f(1) = 1, f(2) = 2, f(3) = 3</code>。同时在DP表示式为：</p>\n<p>f(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)</p>\n<p>所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>另一种就是贪心，对于长度<code>m</code>大于5的绳子尽可能的剪成长度为3的绳子，同时如果<code>m%3==1</code>，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:<br>$$<br>if \\ n \\geq 5<br><br>3*(n-3) \\geq n<br><br>2*(n-2) \\geq n<br><br>3*(n -3 ) \\geq 2*(n-2)<br>$$</p>\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>DP</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_DP(int length)&#123;\n    if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int* products &#x3D; new int[length + 1];\n    &#x2F;&#x2F;初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] &#x3D; 0;\n    products[1] &#x3D; 1;\n    products[2] &#x3D; 2;\n    products[3] &#x3D; 3;\n    for(int i &#x3D; 4; i &lt;&#x3D; length; i++)&#123;\n        int mavV &#x3D; 0;\n        for(int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j++)&#123;\n            maxV &#x3D; max(maxV, products[i - j] * products[j]);\n        &#125;\n        products[i] &#x3D; maxv;\n    &#125;\n    int res &#x3D; products[length];\n    &#x2F;&#x2F;防止内存泄漏\n    del[] products;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>贪心</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_greedy(int length)&#123;\n if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int timesOf3 &#x3D; length &#x2F; 3;\n    if(legnth % 3 &#x3D;&#x3D; 1) timesOf3 -&#x3D; 1;\n    int timesOf2 &#x3D; (length - timesOf3 * 3) &#x2F; 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面42：最大子数组和\"><a href=\"#面42：最大子数组和\" class=\"headerlink\" title=\"面42：最大子数组和\"></a>面42：最大子数组和</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>DP思想。数组之间的选择与历史无关，可以采取DP的方法。记<code>f(i)</code>为以<code>A[i]</code>为结尾的最大数组和。转移方程为：</p>\n<p>f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0</p>\n<p>当然也可以直接从数据的角度理解，代码都是相同的。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSumOfSubArray(int A[], int length)&#123;\n    int dp[] &#x3D; new int(length);\n\tint maxSum &#x3D; A[0];\n    dp[0] &#x3D; A[0];   \n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n        dp[i] &#x3D; max(A[i], A[i] + dp[i-1]);\n        maxSum &#x3D; max(dp[i], maxSum);\n    &#125;\n    delete[] dp;\n    return maxSum;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>当然这里的dp数组也可以不要。</p>\n</blockquote>\n<h2 id=\"面45：把数字排成最小的数字\"><a href=\"#面45：把数字排成最小的数字\" class=\"headerlink\" title=\"面45：把数字排成最小的数字\"></a>面45：把数字排成最小的数字</h2><h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>给定一串数字，组合成的一个数字。求出组合后最小数字的</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以直接贪心+反证。按字典序排序数字即可。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>就不写了，直接string排序输出即可。</p>\n<h2 id=\"面46：数字翻译成字符串\"><a href=\"#面46：数字翻译成字符串\" class=\"headerlink\" title=\"面46：数字翻译成字符串\"></a>面46：数字翻译成字符串</h2><h3 id=\"题目：-1\"><a href=\"#题目：-1\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。</p>\n<p>第二种用DP思想，考虑<code>dp[i]</code>为从<code>0</code>到<code>i</code>的字符串翻译方法。状态转移方程为：</p>\n<p>dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else </p>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int GetTranslateCount(int A[], int length)&#123;\n    if(A &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0) return 0;\n    int dp[] &#x3D; new int(length);\n    dp[0] &#x3D; 1;\n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n\t\tint add &#x3D; A[i - 1] * 10 + A[i];\n        if( add &gt; 9 &amp;&amp; add &lt; 26)&#123;\n            if(i &lt; 2) dp &#x3D; dp[i - 1] + 1;\n            else dp[i] &#x3D; dp[i - 1] + dp[i - 2];\n        &#125; \n        else dp[i] &#x3D; dp[i - 1];\n    &#125;\n    delete[] dp;\n    return dp[length - 1];    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面47：礼物的最大价值\"><a href=\"#面47：礼物的最大价值\" class=\"headerlink\" title=\"面47：礼物的最大价值\"></a>面47：礼物的最大价值</h2><h3 id=\"题目：-2\"><a href=\"#题目：-2\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>从一在格子上装满礼物的<code>m*n</code>的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显就是DP</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>不写了。</p>\n<h2 id=\"面48：最长不含重复字符的子字符串\"><a href=\"#面48：最长不含重复字符的子字符串\" class=\"headerlink\" title=\"面48：最长不含重复字符的子字符串\"></a>面48：最长不含重复字符的子字符串</h2><h3 id=\"题目：-3\"><a href=\"#题目：-3\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>如题</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>暴力不可取。</p>\n<p>采用用DP思想，考虑<code>dp[i]</code>为以<code>S[i]</code>为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断<code>S[i]</code>的前一个相同字符是否在上一个<code>S[i-1]</code>为结尾的最长不重复字符串之内。记上一个字符与<code>S[i-1]</code>的长度<code>d</code>为<code>i - POS</code>。</p>\n<p>状态转移方程为：</p>\n<p>dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else </p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSubStr(String s)&#123;\n    int dp[] &#x3D; new int(s.length());\n    int pos[26];\n    for(int i &#x3D; 0; i &lt; 26; i++) pos[[i] &#x3D; -1;\n\t\n\tint maxL &#x3D; 1;\n\tdp[0] &#x3D; 1;\n\tfor(int i &#x3D; 1; i &lt; s.length(); i++)&#123;\n\t\tint d &#x3D; i - pos[s[i] - &#39;a&#39;];\n        if(dp[i - 1] &lt; d)&#123;\n            dp[i] &#x3D; dp[i - 1] + 1;\n        &#125;else dp[i] &#x3D; d;\n        maxL &#x3D; max(maxL, dp[i]);\n        pos[s[i] - &#39;a&#39;] &#x3D; i;\n    &#125;\n\tdelete[] dp;    \n   return maxL;            \n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"Q4ZBAM","excerpt":"","more":"<p>收集贪心、DP面试题</p>\n<h2 id=\"面14：剪绳子\"><a href=\"#面14：剪绳子\" class=\"headerlink\" title=\"面14：剪绳子\"></a>面14：剪绳子</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>将一串长为<code>K</code>的绳子剪成<code>m</code>（<code>m&gt;=2</code>，各段长度取整数值）段，各段的长度大于<code>0</code>，求出最大的各段绳子长度之积。</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>由乘法交换律可知绳子的乘积可以分解，提取出来。所以有<code>f(m+n)=f(n)*f(m)</code>，其中<code>f(n)</code>是长度<code>n</code>的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件<code>f(1) = 1, f(2) = 2, f(3) = 3</code>。同时在DP表示式为：</p>\n<p>f(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)</p>\n<p>所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>另一种就是贪心，对于长度<code>m</code>大于5的绳子尽可能的剪成长度为3的绳子，同时如果<code>m%3==1</code>，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:<br>$$<br>if \\ n \\geq 5<br><br>3*(n-3) \\geq n<br><br>2*(n-2) \\geq n<br><br>3*(n -3 ) \\geq 2*(n-2)<br>$$</p>\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>DP</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_DP(int length)&#123;\n    if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int* products &#x3D; new int[length + 1];\n    &#x2F;&#x2F;初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] &#x3D; 0;\n    products[1] &#x3D; 1;\n    products[2] &#x3D; 2;\n    products[3] &#x3D; 3;\n    for(int i &#x3D; 4; i &lt;&#x3D; length; i++)&#123;\n        int mavV &#x3D; 0;\n        for(int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j++)&#123;\n            maxV &#x3D; max(maxV, products[i - j] * products[j]);\n        &#125;\n        products[i] &#x3D; maxv;\n    &#125;\n    int res &#x3D; products[length];\n    &#x2F;&#x2F;防止内存泄漏\n    del[] products;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>贪心</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_greedy(int length)&#123;\n if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int timesOf3 &#x3D; length &#x2F; 3;\n    if(legnth % 3 &#x3D;&#x3D; 1) timesOf3 -&#x3D; 1;\n    int timesOf2 &#x3D; (length - timesOf3 * 3) &#x2F; 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面42：最大子数组和\"><a href=\"#面42：最大子数组和\" class=\"headerlink\" title=\"面42：最大子数组和\"></a>面42：最大子数组和</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>DP思想。数组之间的选择与历史无关，可以采取DP的方法。记<code>f(i)</code>为以<code>A[i]</code>为结尾的最大数组和。转移方程为：</p>\n<p>f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0</p>\n<p>当然也可以直接从数据的角度理解，代码都是相同的。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSumOfSubArray(int A[], int length)&#123;\n    int dp[] &#x3D; new int(length);\n\tint maxSum &#x3D; A[0];\n    dp[0] &#x3D; A[0];   \n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n        dp[i] &#x3D; max(A[i], A[i] + dp[i-1]);\n        maxSum &#x3D; max(dp[i], maxSum);\n    &#125;\n    delete[] dp;\n    return maxSum;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>当然这里的dp数组也可以不要。</p>\n</blockquote>\n<h2 id=\"面45：把数字排成最小的数字\"><a href=\"#面45：把数字排成最小的数字\" class=\"headerlink\" title=\"面45：把数字排成最小的数字\"></a>面45：把数字排成最小的数字</h2><h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>给定一串数字，组合成的一个数字。求出组合后最小数字的</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以直接贪心+反证。按字典序排序数字即可。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>就不写了，直接string排序输出即可。</p>\n<h2 id=\"面46：数字翻译成字符串\"><a href=\"#面46：数字翻译成字符串\" class=\"headerlink\" title=\"面46：数字翻译成字符串\"></a>面46：数字翻译成字符串</h2><h3 id=\"题目：-1\"><a href=\"#题目：-1\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。</p>\n<p>第二种用DP思想，考虑<code>dp[i]</code>为从<code>0</code>到<code>i</code>的字符串翻译方法。状态转移方程为：</p>\n<p>dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else </p>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int GetTranslateCount(int A[], int length)&#123;\n    if(A &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0) return 0;\n    int dp[] &#x3D; new int(length);\n    dp[0] &#x3D; 1;\n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n\t\tint add &#x3D; A[i - 1] * 10 + A[i];\n        if( add &gt; 9 &amp;&amp; add &lt; 26)&#123;\n            if(i &lt; 2) dp &#x3D; dp[i - 1] + 1;\n            else dp[i] &#x3D; dp[i - 1] + dp[i - 2];\n        &#125; \n        else dp[i] &#x3D; dp[i - 1];\n    &#125;\n    delete[] dp;\n    return dp[length - 1];    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面47：礼物的最大价值\"><a href=\"#面47：礼物的最大价值\" class=\"headerlink\" title=\"面47：礼物的最大价值\"></a>面47：礼物的最大价值</h2><h3 id=\"题目：-2\"><a href=\"#题目：-2\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>从一在格子上装满礼物的<code>m*n</code>的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显就是DP</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>不写了。</p>\n<h2 id=\"面48：最长不含重复字符的子字符串\"><a href=\"#面48：最长不含重复字符的子字符串\" class=\"headerlink\" title=\"面48：最长不含重复字符的子字符串\"></a>面48：最长不含重复字符的子字符串</h2><h3 id=\"题目：-3\"><a href=\"#题目：-3\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>如题</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>暴力不可取。</p>\n<p>采用用DP思想，考虑<code>dp[i]</code>为以<code>S[i]</code>为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断<code>S[i]</code>的前一个相同字符是否在上一个<code>S[i-1]</code>为结尾的最长不重复字符串之内。记上一个字符与<code>S[i-1]</code>的长度<code>d</code>为<code>i - POS</code>。</p>\n<p>状态转移方程为：</p>\n<p>dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else </p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSubStr(String s)&#123;\n    int dp[] &#x3D; new int(s.length());\n    int pos[26];\n    for(int i &#x3D; 0; i &lt; 26; i++) pos[[i] &#x3D; -1;\n\t\n\tint maxL &#x3D; 1;\n\tdp[0] &#x3D; 1;\n\tfor(int i &#x3D; 1; i &lt; s.length(); i++)&#123;\n\t\tint d &#x3D; i - pos[s[i] - &#39;a&#39;];\n        if(dp[i - 1] &lt; d)&#123;\n            dp[i] &#x3D; dp[i - 1] + 1;\n        &#125;else dp[i] &#x3D; d;\n        maxL &#x3D; max(maxL, dp[i]);\n        pos[s[i] - &#39;a&#39;] &#x3D; i;\n    &#125;\n\tdelete[] dp;    \n   return maxL;            \n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1286. Iterator for Combination","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-08T01:06:01.000Z","_content":"\n想了一下全组合的写法，顺便复习了一下全排列(full permutaion)的思想。\n\n<!-- more -->\n#### [1286. Iterator for Combination](https://leetcode-cn.com/problems/iterator-for-combination/) 全排列\n\n\n\n## 思路：\n\n官方给出了生成法，这种方法比较死板不去学习。\n\n我依据全排列的递归生成方法，扩展到全组合的生成方法，但是需要存储。思路就是：f(s,i,len,str)递归给出已生成i位str，获取s的len及之后的全组合字符串。\n\n大神给出了基于二进制的全组合generatorf方法。由于全组合的排列顺序在二进制看来就是相同数量的`1`和`0`的组合，因此可以由大到小排列。\n\n比如，字典序排序应该是:\n\n```\nab\nac\nad\nbc\nbd\n```\n\n刚好可以对应二进制数，从大到小:\n\n```\n1100\n1010\n1001\n0110\n0101\n0011\n```\n\n再利用`n&(n-1)`计算出0bN的1的个数。\n\n## 代码：\n\n全组合写法：\n\n```c++\n\nclass CombinationIterator {\npublic:\n    queue<string> que;\n    int len = -1;\n    CombinationIterator(string characters, int combinationLength) {\n\n        len = combinationLength;\n        printCombination(characters, 0, 0, \"\");\n    }\n    // 全排列写法，combination只是组合，而非全排列\n    void printPer(string a, int depth){\n        if(depth > len) return;\n        else if(depth == len){\n        //    cout << counter++ << ' '  << a.substr(0, len) << endl;\n            que.push(a.substr(0, len));\n            return;\n        }\n        for(int i = depth + 1;i < a.size(); i++){\n        printPer(a, depth + 1);\n            swap(a[i], a[depth]);\n        }\n        printPer(a, depth + 1);\n    }\n    // combination写法\n\n    \n \nvoid printCombination(string a, int depth, int idx, string b){\n    if(depth > len) return;\n    else if(depth == len){\n        //cout << counter++ << \" \" << b << endl;\n        que.push(b);\n        return;\n    }\n    for(int i = idx;i < a.size() - len + depth + 1; i++){\n       printCombination(a, depth + 1, i + 1, b + a[i]);\n    }\n \n\n}\n\n\n    string next() {\n        string res = que.front();\n        que.pop();\n        return res;\n    }\n    \n    bool hasNext() {\n        return !que.empty();\n    }\n};\n\n/**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);\n * string param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */\n```\n\nbit版：\n\n```c++\n\nclass CombinationIterator {\nprivate:\n    int cur;\n    int sz;\n    string chars;\npublic:\n    \n    CombinationIterator(string characters, int combinationLength) {\n\n        sz = combinationLength;\n        chars = characters;\n        cur = (1 << chars.size()) - 1;\n\n    }\n    //要求输入字符串长度<= 31\n    int countone(int n){\n        int res = 0;\n        while(n){\n            n = n & (n - 1);\n            res ++;\n        }\n        return res;\n    }\n    \n    string next() {\n        while(cur > 0 && countone(cur) != sz) cur--;\n        if(cur <= 0) return \"\";\n        string res = \"\";\n        cout << cur << endl;\n        for(int i = 0; i < chars.size(); i++){\n            if((cur & (1 << i)) != 0)\n                res = chars[chars.size() - 1 - i] + res;\n        }\n        cur--;\n        return res;\n    }\n    \n    bool hasNext() {\n        while(cur > 0 && countone(cur) != sz) cur--;\n        if(cur > 0) return true;\n        else return false;\n     }\n\n};\n\n/**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);\n * string param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */\n```\n\n\n\n","source":"_posts/刷题/位运算\n/1286-Iterator-for-Combination.md","raw":"---\ntitle: 1286. Iterator for Combination\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-08 09:06:01\n---\n\n想了一下全组合的写法，顺便复习了一下全排列(full permutaion)的思想。\n\n<!-- more -->\n#### [1286. Iterator for Combination](https://leetcode-cn.com/problems/iterator-for-combination/) 全排列\n\n\n\n## 思路：\n\n官方给出了生成法，这种方法比较死板不去学习。\n\n我依据全排列的递归生成方法，扩展到全组合的生成方法，但是需要存储。思路就是：f(s,i,len,str)递归给出已生成i位str，获取s的len及之后的全组合字符串。\n\n大神给出了基于二进制的全组合generatorf方法。由于全组合的排列顺序在二进制看来就是相同数量的`1`和`0`的组合，因此可以由大到小排列。\n\n比如，字典序排序应该是:\n\n```\nab\nac\nad\nbc\nbd\n```\n\n刚好可以对应二进制数，从大到小:\n\n```\n1100\n1010\n1001\n0110\n0101\n0011\n```\n\n再利用`n&(n-1)`计算出0bN的1的个数。\n\n## 代码：\n\n全组合写法：\n\n```c++\n\nclass CombinationIterator {\npublic:\n    queue<string> que;\n    int len = -1;\n    CombinationIterator(string characters, int combinationLength) {\n\n        len = combinationLength;\n        printCombination(characters, 0, 0, \"\");\n    }\n    // 全排列写法，combination只是组合，而非全排列\n    void printPer(string a, int depth){\n        if(depth > len) return;\n        else if(depth == len){\n        //    cout << counter++ << ' '  << a.substr(0, len) << endl;\n            que.push(a.substr(0, len));\n            return;\n        }\n        for(int i = depth + 1;i < a.size(); i++){\n        printPer(a, depth + 1);\n            swap(a[i], a[depth]);\n        }\n        printPer(a, depth + 1);\n    }\n    // combination写法\n\n    \n \nvoid printCombination(string a, int depth, int idx, string b){\n    if(depth > len) return;\n    else if(depth == len){\n        //cout << counter++ << \" \" << b << endl;\n        que.push(b);\n        return;\n    }\n    for(int i = idx;i < a.size() - len + depth + 1; i++){\n       printCombination(a, depth + 1, i + 1, b + a[i]);\n    }\n \n\n}\n\n\n    string next() {\n        string res = que.front();\n        que.pop();\n        return res;\n    }\n    \n    bool hasNext() {\n        return !que.empty();\n    }\n};\n\n/**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);\n * string param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */\n```\n\nbit版：\n\n```c++\n\nclass CombinationIterator {\nprivate:\n    int cur;\n    int sz;\n    string chars;\npublic:\n    \n    CombinationIterator(string characters, int combinationLength) {\n\n        sz = combinationLength;\n        chars = characters;\n        cur = (1 << chars.size()) - 1;\n\n    }\n    //要求输入字符串长度<= 31\n    int countone(int n){\n        int res = 0;\n        while(n){\n            n = n & (n - 1);\n            res ++;\n        }\n        return res;\n    }\n    \n    string next() {\n        while(cur > 0 && countone(cur) != sz) cur--;\n        if(cur <= 0) return \"\";\n        string res = \"\";\n        cout << cur << endl;\n        for(int i = 0; i < chars.size(); i++){\n            if((cur & (1 << i)) != 0)\n                res = chars[chars.size() - 1 - i] + res;\n        }\n        cur--;\n        return res;\n    }\n    \n    bool hasNext() {\n        while(cur > 0 && countone(cur) != sz) cur--;\n        if(cur > 0) return true;\n        else return false;\n     }\n\n};\n\n/**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);\n * string param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */\n```\n\n\n\n","slug":"刷题-位运算-1286-Iterator-for-Combination","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3q0016l5uo1lwe3229","content":"<p>想了一下全组合的写法，顺便复习了一下全排列(full permutaion)的思想。</p>\n<span id=\"more\"></span>\n<h4 id=\"1286-Iterator-for-Combination-全排列\"><a href=\"#1286-Iterator-for-Combination-全排列\" class=\"headerlink\" title=\"1286. Iterator for Combination 全排列\"></a><a href=\"https://leetcode-cn.com/problems/iterator-for-combination/\">1286. Iterator for Combination</a> 全排列</h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>官方给出了生成法，这种方法比较死板不去学习。</p>\n<p>我依据全排列的递归生成方法，扩展到全组合的生成方法，但是需要存储。思路就是：f(s,i,len,str)递归给出已生成i位str，获取s的len及之后的全组合字符串。</p>\n<p>大神给出了基于二进制的全组合generatorf方法。由于全组合的排列顺序在二进制看来就是相同数量的<code>1</code>和<code>0</code>的组合，因此可以由大到小排列。</p>\n<p>比如，字典序排序应该是:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ab\nac\nad\nbc\nbd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>刚好可以对应二进制数，从大到小:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1100\n1010\n1001\n0110\n0101\n0011<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再利用<code>n&amp;(n-1)</code>计算出0bN的1的个数。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>全组合写法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass CombinationIterator &#123;\npublic:\n    queue&lt;string&gt; que;\n    int len &#x3D; -1;\n    CombinationIterator(string characters, int combinationLength) &#123;\n\n        len &#x3D; combinationLength;\n        printCombination(characters, 0, 0, &quot;&quot;);\n    &#125;\n    &#x2F;&#x2F; 全排列写法，combination只是组合，而非全排列\n    void printPer(string a, int depth)&#123;\n        if(depth &gt; len) return;\n        else if(depth &#x3D;&#x3D; len)&#123;\n        &#x2F;&#x2F;    cout &lt;&lt; counter++ &lt;&lt; &#39; &#39;  &lt;&lt; a.substr(0, len) &lt;&lt; endl;\n            que.push(a.substr(0, len));\n            return;\n        &#125;\n        for(int i &#x3D; depth + 1;i &lt; a.size(); i++)&#123;\n        printPer(a, depth + 1);\n            swap(a[i], a[depth]);\n        &#125;\n        printPer(a, depth + 1);\n    &#125;\n    &#x2F;&#x2F; combination写法\n\n    \n \nvoid printCombination(string a, int depth, int idx, string b)&#123;\n    if(depth &gt; len) return;\n    else if(depth &#x3D;&#x3D; len)&#123;\n        &#x2F;&#x2F;cout &lt;&lt; counter++ &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;\n        que.push(b);\n        return;\n    &#125;\n    for(int i &#x3D; idx;i &lt; a.size() - len + depth + 1; i++)&#123;\n       printCombination(a, depth + 1, i + 1, b + a[i]);\n    &#125;\n \n\n&#125;\n\n\n    string next() &#123;\n        string res &#x3D; que.front();\n        que.pop();\n        return res;\n    &#125;\n    \n    bool hasNext() &#123;\n        return !que.empty();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj &#x3D; new CombinationIterator(characters, combinationLength);\n * string param_1 &#x3D; obj-&gt;next();\n * bool param_2 &#x3D; obj-&gt;hasNext();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>bit版：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass CombinationIterator &#123;\nprivate:\n    int cur;\n    int sz;\n    string chars;\npublic:\n    \n    CombinationIterator(string characters, int combinationLength) &#123;\n\n        sz &#x3D; combinationLength;\n        chars &#x3D; characters;\n        cur &#x3D; (1 &lt;&lt; chars.size()) - 1;\n\n    &#125;\n    &#x2F;&#x2F;要求输入字符串长度&lt;&#x3D; 31\n    int countone(int n)&#123;\n        int res &#x3D; 0;\n        while(n)&#123;\n            n &#x3D; n &amp; (n - 1);\n            res ++;\n        &#125;\n        return res;\n    &#125;\n    \n    string next() &#123;\n        while(cur &gt; 0 &amp;&amp; countone(cur) !&#x3D; sz) cur--;\n        if(cur &lt;&#x3D; 0) return &quot;&quot;;\n        string res &#x3D; &quot;&quot;;\n        cout &lt;&lt; cur &lt;&lt; endl;\n        for(int i &#x3D; 0; i &lt; chars.size(); i++)&#123;\n            if((cur &amp; (1 &lt;&lt; i)) !&#x3D; 0)\n                res &#x3D; chars[chars.size() - 1 - i] + res;\n        &#125;\n        cur--;\n        return res;\n    &#125;\n    \n    bool hasNext() &#123;\n        while(cur &gt; 0 &amp;&amp; countone(cur) !&#x3D; sz) cur--;\n        if(cur &gt; 0) return true;\n        else return false;\n     &#125;\n\n&#125;;\n\n&#x2F;**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj &#x3D; new CombinationIterator(characters, combinationLength);\n * string param_1 &#x3D; obj-&gt;next();\n * bool param_2 &#x3D; obj-&gt;hasNext();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","site":{"data":{}},"abbrlink":"2099429","excerpt":"<p>想了一下全组合的写法，顺便复习了一下全排列(full permutaion)的思想。</p>","more":"<h4 id=\"1286-Iterator-for-Combination-全排列\"><a href=\"#1286-Iterator-for-Combination-全排列\" class=\"headerlink\" title=\"1286. Iterator for Combination 全排列\"></a><a href=\"https://leetcode-cn.com/problems/iterator-for-combination/\">1286. Iterator for Combination</a> 全排列</h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>官方给出了生成法，这种方法比较死板不去学习。</p>\n<p>我依据全排列的递归生成方法，扩展到全组合的生成方法，但是需要存储。思路就是：f(s,i,len,str)递归给出已生成i位str，获取s的len及之后的全组合字符串。</p>\n<p>大神给出了基于二进制的全组合generatorf方法。由于全组合的排列顺序在二进制看来就是相同数量的<code>1</code>和<code>0</code>的组合，因此可以由大到小排列。</p>\n<p>比如，字典序排序应该是:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ab\nac\nad\nbc\nbd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>刚好可以对应二进制数，从大到小:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1100\n1010\n1001\n0110\n0101\n0011<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>再利用<code>n&amp;(n-1)</code>计算出0bN的1的个数。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>全组合写法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass CombinationIterator &#123;\npublic:\n    queue&lt;string&gt; que;\n    int len &#x3D; -1;\n    CombinationIterator(string characters, int combinationLength) &#123;\n\n        len &#x3D; combinationLength;\n        printCombination(characters, 0, 0, &quot;&quot;);\n    &#125;\n    &#x2F;&#x2F; 全排列写法，combination只是组合，而非全排列\n    void printPer(string a, int depth)&#123;\n        if(depth &gt; len) return;\n        else if(depth &#x3D;&#x3D; len)&#123;\n        &#x2F;&#x2F;    cout &lt;&lt; counter++ &lt;&lt; &#39; &#39;  &lt;&lt; a.substr(0, len) &lt;&lt; endl;\n            que.push(a.substr(0, len));\n            return;\n        &#125;\n        for(int i &#x3D; depth + 1;i &lt; a.size(); i++)&#123;\n        printPer(a, depth + 1);\n            swap(a[i], a[depth]);\n        &#125;\n        printPer(a, depth + 1);\n    &#125;\n    &#x2F;&#x2F; combination写法\n\n    \n \nvoid printCombination(string a, int depth, int idx, string b)&#123;\n    if(depth &gt; len) return;\n    else if(depth &#x3D;&#x3D; len)&#123;\n        &#x2F;&#x2F;cout &lt;&lt; counter++ &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;\n        que.push(b);\n        return;\n    &#125;\n    for(int i &#x3D; idx;i &lt; a.size() - len + depth + 1; i++)&#123;\n       printCombination(a, depth + 1, i + 1, b + a[i]);\n    &#125;\n \n\n&#125;\n\n\n    string next() &#123;\n        string res &#x3D; que.front();\n        que.pop();\n        return res;\n    &#125;\n    \n    bool hasNext() &#123;\n        return !que.empty();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj &#x3D; new CombinationIterator(characters, combinationLength);\n * string param_1 &#x3D; obj-&gt;next();\n * bool param_2 &#x3D; obj-&gt;hasNext();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>bit版：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass CombinationIterator &#123;\nprivate:\n    int cur;\n    int sz;\n    string chars;\npublic:\n    \n    CombinationIterator(string characters, int combinationLength) &#123;\n\n        sz &#x3D; combinationLength;\n        chars &#x3D; characters;\n        cur &#x3D; (1 &lt;&lt; chars.size()) - 1;\n\n    &#125;\n    &#x2F;&#x2F;要求输入字符串长度&lt;&#x3D; 31\n    int countone(int n)&#123;\n        int res &#x3D; 0;\n        while(n)&#123;\n            n &#x3D; n &amp; (n - 1);\n            res ++;\n        &#125;\n        return res;\n    &#125;\n    \n    string next() &#123;\n        while(cur &gt; 0 &amp;&amp; countone(cur) !&#x3D; sz) cur--;\n        if(cur &lt;&#x3D; 0) return &quot;&quot;;\n        string res &#x3D; &quot;&quot;;\n        cout &lt;&lt; cur &lt;&lt; endl;\n        for(int i &#x3D; 0; i &lt; chars.size(); i++)&#123;\n            if((cur &amp; (1 &lt;&lt; i)) !&#x3D; 0)\n                res &#x3D; chars[chars.size() - 1 - i] + res;\n        &#125;\n        cur--;\n        return res;\n    &#125;\n    \n    bool hasNext() &#123;\n        while(cur &gt; 0 &amp;&amp; countone(cur) !&#x3D; sz) cur--;\n        if(cur &gt; 0) return true;\n        else return false;\n     &#125;\n\n&#125;;\n\n&#x2F;**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator* obj &#x3D; new CombinationIterator(characters, combinationLength);\n * string param_1 &#x3D; obj-&gt;next();\n * bool param_2 &#x3D; obj-&gt;hasNext();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"136. Single Number","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-17T10:23:16.000Z","_content":"\n\n\n## [136. Single Number](https://leetcode-cn.com/problems/single-number/)\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int key = 0;\n        for(auto &k : nums){\n            key = k ^ key;\n        }\n        return key;\n    }\n};\n```","source":"_posts/刷题/位运算\n/136-Single-Number.md","raw":"---\ntitle: 136. Single Number\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-17 18:23:16\n---\n\n\n\n## [136. Single Number](https://leetcode-cn.com/problems/single-number/)\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int key = 0;\n        for(auto &k : nums){\n            key = k ^ key;\n        }\n        return key;\n    }\n};\n```","slug":"刷题-位运算-136-Single-Number","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3s0017l5uo8dz03eac","content":"<h2 id=\"136-Single-Number\"><a href=\"#136-Single-Number\" class=\"headerlink\" title=\"136. Single Number\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\">136. Single Number</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int key &#x3D; 0;\n        for(auto &amp;k : nums)&#123;\n            key &#x3D; k ^ key;\n        &#125;\n        return key;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1KA5VMG","excerpt":"<h2 id=\"136-Single-Number\"><a href=\"#136-Single-Number\" class=\"headerlink\" title=\"136. Single Number\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\">136. Single Number</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int key &#x3D; 0;\n        for(auto &amp;k : nums)&#123;\n            key &#x3D; k ^ key;\n        &#125;\n        return key;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"190. Reverse Bits","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-17T10:22:31.000Z","_content":"\n\n\n## [190. Reverse Bits](https://leetcode-cn.com/problems/reverse-bits/)\n\n\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t z = 0;\n        int k = 0;\n        while(k <= 31){\n            z = (z << 1) | (n & 1);\n            n >>= 1;\n            k++;\n        }\n        return z;\n    }\n};\n```","source":"_posts/刷题/位运算\n/190-Reverse-Bits.md","raw":"---\ntitle: 190. Reverse Bits\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-17 18:22:31\n---\n\n\n\n## [190. Reverse Bits](https://leetcode-cn.com/problems/reverse-bits/)\n\n\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t z = 0;\n        int k = 0;\n        while(k <= 31){\n            z = (z << 1) | (n & 1);\n            n >>= 1;\n            k++;\n        }\n        return z;\n    }\n};\n```","slug":"刷题-位运算-190-Reverse-Bits","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3t0018l5uo57is14aj","content":"<h2 id=\"190-Reverse-Bits\"><a href=\"#190-Reverse-Bits\" class=\"headerlink\" title=\"190. Reverse Bits\"></a><a href=\"https://leetcode-cn.com/problems/reverse-bits/\">190. Reverse Bits</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    uint32_t reverseBits(uint32_t n) &#123;\n        uint32_t z &#x3D; 0;\n        int k &#x3D; 0;\n        while(k &lt;&#x3D; 31)&#123;\n            z &#x3D; (z &lt;&lt; 1) | (n &amp; 1);\n            n &gt;&gt;&#x3D; 1;\n            k++;\n        &#125;\n        return z;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1GDFGSY","excerpt":"<h2 id=\"190-Reverse-Bits\"><a href=\"#190-Reverse-Bits\" class=\"headerlink\" title=\"190. Reverse Bits\"></a><a href=\"https://leetcode-cn.com/problems/reverse-bits/\">190. Reverse Bits</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    uint32_t reverseBits(uint32_t n) &#123;\n        uint32_t z &#x3D; 0;\n        int k &#x3D; 0;\n        while(k &lt;&#x3D; 31)&#123;\n            z &#x3D; (z &lt;&lt; 1) | (n &amp; 1);\n            n &gt;&gt;&#x3D; 1;\n            k++;\n        &#125;\n        return z;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"260. Single Number III","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-19T05:26:48.000Z","_content":"\n## [260. Single Number III](https://leetcode-cn.com/problems/single-number-iii/)\n\n\n\n## 思路：\n\n*划分数组*\n\n思路非常精巧。用异或所有数组，由于异或的性质，只有两个唯一且不等的出现的数字$x$,$y$被记录下来，记为$z$。可以推测，$z$比不为零，且第一个1要么来自$x$，要么来自$y$。同时可以根据这个“第一个1”是否在其他数字上存在，将数组划分为两部分，一组是带有$x$和成对的数字，另一组类似。\n\n如此划分数组，同时异或其中一组，就可以得到$x$或者$y$。当然也可以通过上面的$z$异或其中一个数字来得到另一个数字。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        int bitmask = 0;\n        for(auto & k : nums) bitmask ^= k;\n        long long key = (long)bitmask & (-(long)bitmask);\n        int mask = 0;\n        cout << key << endl;\n        for(auto & k : nums){\n            if(k & key){\n                mask ^= k;\n            }\n        }\n        return {mask, bitmask ^ mask};\n    }\n};\n```\n\n","source":"_posts/刷题/位运算\n/260-Single-Number-III.md","raw":"---\ntitle: 260. Single Number III\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-19 13:26:48\n---\n\n## [260. Single Number III](https://leetcode-cn.com/problems/single-number-iii/)\n\n\n\n## 思路：\n\n*划分数组*\n\n思路非常精巧。用异或所有数组，由于异或的性质，只有两个唯一且不等的出现的数字$x$,$y$被记录下来，记为$z$。可以推测，$z$比不为零，且第一个1要么来自$x$，要么来自$y$。同时可以根据这个“第一个1”是否在其他数字上存在，将数组划分为两部分，一组是带有$x$和成对的数字，另一组类似。\n\n如此划分数组，同时异或其中一组，就可以得到$x$或者$y$。当然也可以通过上面的$z$异或其中一个数字来得到另一个数字。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        int bitmask = 0;\n        for(auto & k : nums) bitmask ^= k;\n        long long key = (long)bitmask & (-(long)bitmask);\n        int mask = 0;\n        cout << key << endl;\n        for(auto & k : nums){\n            if(k & key){\n                mask ^= k;\n            }\n        }\n        return {mask, bitmask ^ mask};\n    }\n};\n```\n\n","slug":"刷题-位运算-260-Single-Number-III","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3u0019l5uo3n8obza2","content":"<h2 id=\"260-Single-Number-III\"><a href=\"#260-Single-Number-III\" class=\"headerlink\" title=\"260. Single Number III\"></a><a href=\"https://leetcode-cn.com/problems/single-number-iii/\">260. Single Number III</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><em>划分数组</em></p>\n<p>思路非常精巧。用异或所有数组，由于异或的性质，只有两个唯一且不等的出现的数字$x$,$y$被记录下来，记为$z$。可以推测，$z$比不为零，且第一个1要么来自$x$，要么来自$y$。同时可以根据这个“第一个1”是否在其他数字上存在，将数组划分为两部分，一组是带有$x$和成对的数字，另一组类似。</p>\n<p>如此划分数组，同时异或其中一组，就可以得到$x$或者$y$。当然也可以通过上面的$z$异或其中一个数字来得到另一个数字。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int bitmask &#x3D; 0;\n        for(auto &amp; k : nums) bitmask ^&#x3D; k;\n        long long key &#x3D; (long)bitmask &amp; (-(long)bitmask);\n        int mask &#x3D; 0;\n        cout &lt;&lt; key &lt;&lt; endl;\n        for(auto &amp; k : nums)&#123;\n            if(k &amp; key)&#123;\n                mask ^&#x3D; k;\n            &#125;\n        &#125;\n        return &#123;mask, bitmask ^ mask&#125;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3324YND","excerpt":"<h2 id=\"260-Single-Number-III\"><a href=\"#260-Single-Number-III\" class=\"headerlink\" title=\"260. Single Number III\"></a><a href=\"https://leetcode-cn.com/problems/single-number-iii/\">260. Single Number III</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><em>划分数组</em></p>\n<p>思路非常精巧。用异或所有数组，由于异或的性质，只有两个唯一且不等的出现的数字$x$,$y$被记录下来，记为$z$。可以推测，$z$比不为零，且第一个1要么来自$x$，要么来自$y$。同时可以根据这个“第一个1”是否在其他数字上存在，将数组划分为两部分，一组是带有$x$和成对的数字，另一组类似。</p>\n<p>如此划分数组，同时异或其中一组，就可以得到$x$或者$y$。当然也可以通过上面的$z$异或其中一个数字来得到另一个数字。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int bitmask &#x3D; 0;\n        for(auto &amp; k : nums) bitmask ^&#x3D; k;\n        long long key &#x3D; (long)bitmask &amp; (-(long)bitmask);\n        int mask &#x3D; 0;\n        cout &lt;&lt; key &lt;&lt; endl;\n        for(auto &amp; k : nums)&#123;\n            if(k &amp; key)&#123;\n                mask ^&#x3D; k;\n            &#125;\n        &#125;\n        return &#123;mask, bitmask ^ mask&#125;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"268. Missing Number","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-19T03:18:43.000Z","_content":"\n\n\n\n## [268. Missing Number](https://leetcode-cn.com/problems/missing-number/)\n\n\n\n## 思路：\n\n1. 排序\n2. 哈希\n3. 异或位运算 \n4. 高斯求和\n\n3和4实现了$O(n)$的时间复杂度和$O(1)$的空间复杂度。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```C++\n\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0 ) return 0;\n        int lose = 0;\n        for(auto & k : nums){\n            lose ^= k;\n        }\n        for(int i = 0; i <= n; ++i) lose ^= i;\n        return lose;\n    }\n};\n```","source":"_posts/刷题/位运算\n/268-Missing-Number.md","raw":"---\ntitle: 268. Missing Number\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-19 11:18:43\n---\n\n\n\n\n## [268. Missing Number](https://leetcode-cn.com/problems/missing-number/)\n\n\n\n## 思路：\n\n1. 排序\n2. 哈希\n3. 异或位运算 \n4. 高斯求和\n\n3和4实现了$O(n)$的时间复杂度和$O(1)$的空间复杂度。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```C++\n\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        if(n == 0 ) return 0;\n        int lose = 0;\n        for(auto & k : nums){\n            lose ^= k;\n        }\n        for(int i = 0; i <= n; ++i) lose ^= i;\n        return lose;\n    }\n};\n```","slug":"刷题-位运算-268-Missing-Number","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3x001al5uoabqe8nnh","content":"<h2 id=\"268-Missing-Number\"><a href=\"#268-Missing-Number\" class=\"headerlink\" title=\"268. Missing Number\"></a><a href=\"https://leetcode-cn.com/problems/missing-number/\">268. Missing Number</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>排序</li>\n<li>哈希</li>\n<li>异或位运算 </li>\n<li>高斯求和</li>\n</ol>\n<p>3和4实现了$O(n)$的时间复杂度和$O(1)$的空间复杂度。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\nclass Solution &#123;\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0 ) return 0;\n        int lose &#x3D; 0;\n        for(auto &amp; k : nums)&#123;\n            lose ^&#x3D; k;\n        &#125;\n        for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) lose ^&#x3D; i;\n        return lose;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"10QDRZ5","excerpt":"<h2 id=\"268-Missing-Number\"><a href=\"#268-Missing-Number\" class=\"headerlink\" title=\"268. Missing Number\"></a><a href=\"https://leetcode-cn.com/problems/missing-number/\">268. Missing Number</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>排序</li>\n<li>哈希</li>\n<li>异或位运算 </li>\n<li>高斯求和</li>\n</ol>\n<p>3和4实现了$O(n)$的时间复杂度和$O(1)$的空间复杂度。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\nclass Solution &#123;\npublic:\n    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0 ) return 0;\n        int lose &#x3D; 0;\n        for(auto &amp; k : nums)&#123;\n            lose ^&#x3D; k;\n        &#125;\n        for(int i &#x3D; 0; i &lt;&#x3D; n; ++i) lose ^&#x3D; i;\n        return lose;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"318. Maximum Product of Word Lengths","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-17T10:22:41.000Z","_content":"\n\n\n\n## [318. Maximum Product of Word Lengths](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)\n\n\n\n## 思路：\n\n\n\n为了避免查询时候的重复比较，可以将比较内容变成一个`标志符`，减少了比较时候的重复计算。\n\n进一步的，可以进一步优化重复标志符的查询次数。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int aderator(string s){\n        int pic = 0;\n        for(auto &c : s){\n            pic |= (1 << (c - 'a'));\n        }\n        return pic;\n    }\n    int maxProduct(vector<string>& words) {\n        vector<int> pics;\n        for(auto &s : words){\n            pics.push_back(aderator(s));\n        }\n        int maxl = 0;\n        for(int i = 0; i < pics.size(); ++i){\n            for(int j = i + 1; j < pics.size(); ++j){\n                if((pics[i] & pics[j]) == 0){\n                    maxl = max(maxl, int(words[i].size() * words[j].size()));\n                }\n            }\n        }\n        return maxl;\n    }\n};\n```\n\n在上题基础上，用hashmap记录key相同的长度最长的string，减少查询次数。\n\n```c++\nclass Solution {\npublic:\n    int aderator(string s){\n        int pic = 0;\n        for(auto &c : s){\n            pic |= (1 << (c - 'a'));\n        }\n        return pic;\n    }\n    int maxProduct(vector<string>& words) {\n        unordered_map<int, int> map;\n        for(auto &s : words){\n            int key = aderator(s);\n            map[key] = max(map[key], (int)s.size());\n        }\n        int maxl = 0;\n        for(auto &[key1, value1] : map){\n            for(auto &[key2, value2] : map){\n                if((key1 & key2) == 0){\n                    maxl = max(maxl, int(value1 * value2));\n                }\n            }\n        }\n        return maxl;\n    }\n};\n```","source":"_posts/刷题/位运算\n/318-Maximum-Product-of-Word-Lengths.md","raw":"---\ntitle: 318. Maximum Product of Word Lengths\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-17 18:22:41\n---\n\n\n\n\n## [318. Maximum Product of Word Lengths](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)\n\n\n\n## 思路：\n\n\n\n为了避免查询时候的重复比较，可以将比较内容变成一个`标志符`，减少了比较时候的重复计算。\n\n进一步的，可以进一步优化重复标志符的查询次数。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int aderator(string s){\n        int pic = 0;\n        for(auto &c : s){\n            pic |= (1 << (c - 'a'));\n        }\n        return pic;\n    }\n    int maxProduct(vector<string>& words) {\n        vector<int> pics;\n        for(auto &s : words){\n            pics.push_back(aderator(s));\n        }\n        int maxl = 0;\n        for(int i = 0; i < pics.size(); ++i){\n            for(int j = i + 1; j < pics.size(); ++j){\n                if((pics[i] & pics[j]) == 0){\n                    maxl = max(maxl, int(words[i].size() * words[j].size()));\n                }\n            }\n        }\n        return maxl;\n    }\n};\n```\n\n在上题基础上，用hashmap记录key相同的长度最长的string，减少查询次数。\n\n```c++\nclass Solution {\npublic:\n    int aderator(string s){\n        int pic = 0;\n        for(auto &c : s){\n            pic |= (1 << (c - 'a'));\n        }\n        return pic;\n    }\n    int maxProduct(vector<string>& words) {\n        unordered_map<int, int> map;\n        for(auto &s : words){\n            int key = aderator(s);\n            map[key] = max(map[key], (int)s.size());\n        }\n        int maxl = 0;\n        for(auto &[key1, value1] : map){\n            for(auto &[key2, value2] : map){\n                if((key1 & key2) == 0){\n                    maxl = max(maxl, int(value1 * value2));\n                }\n            }\n        }\n        return maxl;\n    }\n};\n```","slug":"刷题-位运算-318-Maximum-Product-of-Word-Lengths","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3y001bl5uog5q7exee","content":"<h2 id=\"318-Maximum-Product-of-Word-Lengths\"><a href=\"#318-Maximum-Product-of-Word-Lengths\" class=\"headerlink\" title=\"318. Maximum Product of Word Lengths\"></a><a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\">318. Maximum Product of Word Lengths</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>为了避免查询时候的重复比较，可以将比较内容变成一个<code>标志符</code>，减少了比较时候的重复计算。</p>\n<p>进一步的，可以进一步优化重复标志符的查询次数。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int aderator(string s)&#123;\n        int pic &#x3D; 0;\n        for(auto &amp;c : s)&#123;\n            pic |&#x3D; (1 &lt;&lt; (c - &#39;a&#39;));\n        &#125;\n        return pic;\n    &#125;\n    int maxProduct(vector&lt;string&gt;&amp; words) &#123;\n        vector&lt;int&gt; pics;\n        for(auto &amp;s : words)&#123;\n            pics.push_back(aderator(s));\n        &#125;\n        int maxl &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; pics.size(); ++i)&#123;\n            for(int j &#x3D; i + 1; j &lt; pics.size(); ++j)&#123;\n                if((pics[i] &amp; pics[j]) &#x3D;&#x3D; 0)&#123;\n                    maxl &#x3D; max(maxl, int(words[i].size() * words[j].size()));\n                &#125;\n            &#125;\n        &#125;\n        return maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上题基础上，用hashmap记录key相同的长度最长的string，减少查询次数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int aderator(string s)&#123;\n        int pic &#x3D; 0;\n        for(auto &amp;c : s)&#123;\n            pic |&#x3D; (1 &lt;&lt; (c - &#39;a&#39;));\n        &#125;\n        return pic;\n    &#125;\n    int maxProduct(vector&lt;string&gt;&amp; words) &#123;\n        unordered_map&lt;int, int&gt; map;\n        for(auto &amp;s : words)&#123;\n            int key &#x3D; aderator(s);\n            map[key] &#x3D; max(map[key], (int)s.size());\n        &#125;\n        int maxl &#x3D; 0;\n        for(auto &amp;[key1, value1] : map)&#123;\n            for(auto &amp;[key2, value2] : map)&#123;\n                if((key1 &amp; key2) &#x3D;&#x3D; 0)&#123;\n                    maxl &#x3D; max(maxl, int(value1 * value2));\n                &#125;\n            &#125;\n        &#125;\n        return maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"KTYBEG","excerpt":"<h2 id=\"318-Maximum-Product-of-Word-Lengths\"><a href=\"#318-Maximum-Product-of-Word-Lengths\" class=\"headerlink\" title=\"318. Maximum Product of Word Lengths\"></a><a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\">318. Maximum Product of Word Lengths</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>为了避免查询时候的重复比较，可以将比较内容变成一个<code>标志符</code>，减少了比较时候的重复计算。</p>\n<p>进一步的，可以进一步优化重复标志符的查询次数。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int aderator(string s)&#123;\n        int pic &#x3D; 0;\n        for(auto &amp;c : s)&#123;\n            pic |&#x3D; (1 &lt;&lt; (c - &#39;a&#39;));\n        &#125;\n        return pic;\n    &#125;\n    int maxProduct(vector&lt;string&gt;&amp; words) &#123;\n        vector&lt;int&gt; pics;\n        for(auto &amp;s : words)&#123;\n            pics.push_back(aderator(s));\n        &#125;\n        int maxl &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; pics.size(); ++i)&#123;\n            for(int j &#x3D; i + 1; j &lt; pics.size(); ++j)&#123;\n                if((pics[i] &amp; pics[j]) &#x3D;&#x3D; 0)&#123;\n                    maxl &#x3D; max(maxl, int(words[i].size() * words[j].size()));\n                &#125;\n            &#125;\n        &#125;\n        return maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上题基础上，用hashmap记录key相同的长度最长的string，减少查询次数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int aderator(string s)&#123;\n        int pic &#x3D; 0;\n        for(auto &amp;c : s)&#123;\n            pic |&#x3D; (1 &lt;&lt; (c - &#39;a&#39;));\n        &#125;\n        return pic;\n    &#125;\n    int maxProduct(vector&lt;string&gt;&amp; words) &#123;\n        unordered_map&lt;int, int&gt; map;\n        for(auto &amp;s : words)&#123;\n            int key &#x3D; aderator(s);\n            map[key] &#x3D; max(map[key], (int)s.size());\n        &#125;\n        int maxl &#x3D; 0;\n        for(auto &amp;[key1, value1] : map)&#123;\n            for(auto &amp;[key2, value2] : map)&#123;\n                if((key1 &amp; key2) &#x3D;&#x3D; 0)&#123;\n                    maxl &#x3D; max(maxl, int(value1 * value2));\n                &#125;\n            &#125;\n        &#125;\n        return maxl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"338. Counting Bits","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-19T03:18:02.000Z","_content":"\n\n\n\n## [338. Counting Bits](https://leetcode-cn.com/problems/counting-bits/)\n\n\n\n## 思路：\n\n利用二进制上数字变化，将数字计算转移。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> countBits(int nums) {\n        vector<int> dp(nums + 1);\n        for(int i = 1; i <= nums; ++i){\n            dp[i] = (i & 1) ? dp[i - 1] + 1 : dp[i >> 1];\n        }\n        return dp;\n    }\n};\n```","source":"_posts/刷题/位运算\n/338-Counting-Bits.md","raw":"---\ntitle: 338. Counting Bits\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-19 11:18:02\n---\n\n\n\n\n## [338. Counting Bits](https://leetcode-cn.com/problems/counting-bits/)\n\n\n\n## 思路：\n\n利用二进制上数字变化，将数字计算转移。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> countBits(int nums) {\n        vector<int> dp(nums + 1);\n        for(int i = 1; i <= nums; ++i){\n            dp[i] = (i & 1) ? dp[i - 1] + 1 : dp[i >> 1];\n        }\n        return dp;\n    }\n};\n```","slug":"刷题-位运算-338-Counting-Bits","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j3z001cl5uobie7fzog","content":"<h2 id=\"338-Counting-Bits\"><a href=\"#338-Counting-Bits\" class=\"headerlink\" title=\"338. Counting Bits\"></a><a href=\"https://leetcode-cn.com/problems/counting-bits/\">338. Counting Bits</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用二进制上数字变化，将数字计算转移。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int nums) &#123;\n        vector&lt;int&gt; dp(nums + 1);\n        for(int i &#x3D; 1; i &lt;&#x3D; nums; ++i)&#123;\n            dp[i] &#x3D; (i &amp; 1) ? dp[i - 1] + 1 : dp[i &gt;&gt; 1];\n        &#125;\n        return dp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"YGBD4F","excerpt":"<h2 id=\"338-Counting-Bits\"><a href=\"#338-Counting-Bits\" class=\"headerlink\" title=\"338. Counting Bits\"></a><a href=\"https://leetcode-cn.com/problems/counting-bits/\">338. Counting Bits</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用二进制上数字变化，将数字计算转移。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; countBits(int nums) &#123;\n        vector&lt;int&gt; dp(nums + 1);\n        for(int i &#x3D; 1; i &lt;&#x3D; nums; ++i)&#123;\n            dp[i] &#x3D; (i &amp; 1) ? dp[i - 1] + 1 : dp[i &gt;&gt; 1];\n        &#125;\n        return dp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"342. Power of Four","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-17T10:22:52.000Z","_content":"\n\n\n\n\n\n## [342. Power of Four](https://leetcode-cn.com/problems/power-of-four/)\n\n## 思路：\n\n1. 判断唯一的1的位置是否在1的倍数上\n2. 检查 $log_2x$是否为偶数就能判断 `x` 是否为 4 的幂\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        if(n <= 0) return false;\n        while(n != 1){\n            if((n & 3)) return false;\n            n >>= 2;\n        }\n        return true;\n    }\n};\n```","source":"_posts/刷题/位运算\n/342-Power-of-Four.md","raw":"---\ntitle: 342. Power of Four\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-17 18:22:52\n---\n\n\n\n\n\n\n## [342. Power of Four](https://leetcode-cn.com/problems/power-of-four/)\n\n## 思路：\n\n1. 判断唯一的1的位置是否在1的倍数上\n2. 检查 $log_2x$是否为偶数就能判断 `x` 是否为 4 的幂\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        if(n <= 0) return false;\n        while(n != 1){\n            if((n & 3)) return false;\n            n >>= 2;\n        }\n        return true;\n    }\n};\n```","slug":"刷题-位运算-342-Power-of-Four","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j40001dl5uo09af94hb","content":"<h2 id=\"342-Power-of-Four\"><a href=\"#342-Power-of-Four\" class=\"headerlink\" title=\"342. Power of Four\"></a><a href=\"https://leetcode-cn.com/problems/power-of-four/\">342. Power of Four</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>判断唯一的1的位置是否在1的倍数上</li>\n<li>检查 $log_2x$是否为偶数就能判断 <code>x</code> 是否为 4 的幂</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool isPowerOfFour(int n) &#123;\n        if(n &lt;&#x3D; 0) return false;\n        while(n !&#x3D; 1)&#123;\n            if((n &amp; 3)) return false;\n            n &gt;&gt;&#x3D; 2;\n        &#125;\n        return true;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"26QAT55","excerpt":"<h2 id=\"342-Power-of-Four\"><a href=\"#342-Power-of-Four\" class=\"headerlink\" title=\"342. Power of Four\"></a><a href=\"https://leetcode-cn.com/problems/power-of-four/\">342. Power of Four</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>判断唯一的1的位置是否在1的倍数上</li>\n<li>检查 $log_2x$是否为偶数就能判断 <code>x</code> 是否为 4 的幂</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool isPowerOfFour(int n) &#123;\n        if(n &lt;&#x3D; 0) return false;\n        while(n !&#x3D; 1)&#123;\n            if((n &amp; 3)) return false;\n            n &gt;&gt;&#x3D; 2;\n        &#125;\n        return true;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"461. Hamming Distance","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-17T10:23:04.000Z","_content":"\n\n\n\n## [461. Hamming Distance](https://leetcode-cn.com/problems/hamming-distance/)\n\n\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```C++\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int z = x ^ y;\n        int ct = 0;\n        while(z){\n            ct += z & 1;\n            z >>= 1;\n        }\n        return ct;\n    }\n};\n```","source":"_posts/刷题/位运算\n/461-Hamming-Distance.md","raw":"---\ntitle: 461. Hamming Distance\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-17 18:23:04\n---\n\n\n\n\n## [461. Hamming Distance](https://leetcode-cn.com/problems/hamming-distance/)\n\n\n\n## 思路：\n\n<!-- more -->\n\n## 代码：\n\n```C++\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int z = x ^ y;\n        int ct = 0;\n        while(z){\n            ct += z & 1;\n            z >>= 1;\n        }\n        return ct;\n    }\n};\n```","slug":"刷题-位运算-461-Hamming-Distance","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j40001el5uo23oggehd","content":"<h2 id=\"461-Hamming-Distance\"><a href=\"#461-Hamming-Distance\" class=\"headerlink\" title=\"461. Hamming Distance\"></a><a href=\"https://leetcode-cn.com/problems/hamming-distance/\">461. Hamming Distance</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int hammingDistance(int x, int y) &#123;\n        int z &#x3D; x ^ y;\n        int ct &#x3D; 0;\n        while(z)&#123;\n            ct +&#x3D; z &amp; 1;\n            z &gt;&gt;&#x3D; 1;\n        &#125;\n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"NJ29N5","excerpt":"<h2 id=\"461-Hamming-Distance\"><a href=\"#461-Hamming-Distance\" class=\"headerlink\" title=\"461. Hamming Distance\"></a><a href=\"https://leetcode-cn.com/problems/hamming-distance/\">461. Hamming Distance</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int hammingDistance(int x, int y) &#123;\n        int z &#x3D; x ^ y;\n        int ct &#x3D; 0;\n        while(z)&#123;\n            ct +&#x3D; z &amp; 1;\n            z &gt;&gt;&#x3D; 1;\n        &#125;\n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"476. Number Complement","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-19T03:18:16.000Z","_content":"\n\n\n## [476. Number Complement](https://leetcode-cn.com/problems/number-complement/)\n\n## 思路：\n\n数字取反前把前缀零全部转化为前缀1.\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    int findComplement(int num) {\n        int c = 1;\n        while( (num >> c) ) ++c;\n        while(c <= 31){\n            num = num | (1 << c);\n            c++;\n            // cout << num << endl;\n        }\n        return ~num;\n    }\n};\n```","source":"_posts/刷题/位运算\n/476-Number-Complement.md","raw":"---\ntitle: 476. Number Complement\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-19 11:18:16\n---\n\n\n\n## [476. Number Complement](https://leetcode-cn.com/problems/number-complement/)\n\n## 思路：\n\n数字取反前把前缀零全部转化为前缀1.\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    int findComplement(int num) {\n        int c = 1;\n        while( (num >> c) ) ++c;\n        while(c <= 31){\n            num = num | (1 << c);\n            c++;\n            // cout << num << endl;\n        }\n        return ~num;\n    }\n};\n```","slug":"刷题-位运算-476-Number-Complement","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j41001fl5uo24ri8cza","content":"<h2 id=\"476-Number-Complement\"><a href=\"#476-Number-Complement\" class=\"headerlink\" title=\"476. Number Complement\"></a><a href=\"https://leetcode-cn.com/problems/number-complement/\">476. Number Complement</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>数字取反前把前缀零全部转化为前缀1.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findComplement(int num) &#123;\n        int c &#x3D; 1;\n        while( (num &gt;&gt; c) ) ++c;\n        while(c &lt;&#x3D; 31)&#123;\n            num &#x3D; num | (1 &lt;&lt; c);\n            c++;\n            &#x2F;&#x2F; cout &lt;&lt; num &lt;&lt; endl;\n        &#125;\n        return ~num;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2913XH2","excerpt":"<h2 id=\"476-Number-Complement\"><a href=\"#476-Number-Complement\" class=\"headerlink\" title=\"476. Number Complement\"></a><a href=\"https://leetcode-cn.com/problems/number-complement/\">476. Number Complement</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>数字取反前把前缀零全部转化为前缀1.</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findComplement(int num) &#123;\n        int c &#x3D; 1;\n        while( (num &gt;&gt; c) ) ++c;\n        while(c &lt;&#x3D; 31)&#123;\n            num &#x3D; num | (1 &lt;&lt; c);\n            c++;\n            &#x2F;&#x2F; cout &lt;&lt; num &lt;&lt; endl;\n        &#125;\n        return ~num;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"693. Binary Number with Alternating Bits","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-19T03:18:28.000Z","_content":"\n\n\n\n## [693. Binary Number with Alternating Bits](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)\n\n## 思路:\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        if(n < 1) return true;\n        int obit = n & 1, bit = 0;\n        n >>= 1;\n        while(n){\n            bit = n & 1;\n            n >>= 1; \n            if(bit == obit) return false;\n            obit = bit;\n        }\n    \n        return true;\n    }\n};\n```","source":"_posts/刷题/位运算\n/693-Binary-Number-with-Alternating-Bits.md","raw":"---\ntitle: 693. Binary Number with Alternating Bits\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-19 11:18:28\n---\n\n\n\n\n## [693. Binary Number with Alternating Bits](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)\n\n## 思路:\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        if(n < 1) return true;\n        int obit = n & 1, bit = 0;\n        n >>= 1;\n        while(n){\n            bit = n & 1;\n            n >>= 1; \n            if(bit == obit) return false;\n            obit = bit;\n        }\n    \n        return true;\n    }\n};\n```","slug":"刷题-位运算-693-Binary-Number-with-Alternating-Bits","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j42001gl5uodtj70lx8","content":"<h2 id=\"693-Binary-Number-with-Alternating-Bits\"><a href=\"#693-Binary-Number-with-Alternating-Bits\" class=\"headerlink\" title=\"693. Binary Number with Alternating Bits\"></a><a href=\"https://leetcode-cn.com/problems/binary-number-with-alternating-bits/\">693. Binary Number with Alternating Bits</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool hasAlternatingBits(int n) &#123;\n        if(n &lt; 1) return true;\n        int obit &#x3D; n &amp; 1, bit &#x3D; 0;\n        n &gt;&gt;&#x3D; 1;\n        while(n)&#123;\n            bit &#x3D; n &amp; 1;\n            n &gt;&gt;&#x3D; 1; \n            if(bit &#x3D;&#x3D; obit) return false;\n            obit &#x3D; bit;\n        &#125;\n    \n        return true;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2YTMFPD","excerpt":"<h2 id=\"693-Binary-Number-with-Alternating-Bits\"><a href=\"#693-Binary-Number-with-Alternating-Bits\" class=\"headerlink\" title=\"693. Binary Number with Alternating Bits\"></a><a href=\"https://leetcode-cn.com/problems/binary-number-with-alternating-bits/\">693. Binary Number with Alternating Bits</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool hasAlternatingBits(int n) &#123;\n        if(n &lt; 1) return true;\n        int obit &#x3D; n &amp; 1, bit &#x3D; 0;\n        n &gt;&gt;&#x3D; 1;\n        while(n)&#123;\n            bit &#x3D; n &amp; 1;\n            n &gt;&gt;&#x3D; 1; \n            if(bit &#x3D;&#x3D; obit) return false;\n            obit &#x3D; bit;\n        &#125;\n    \n        return true;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题-位运算","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:29:07.000Z","_content":"\n\n\n\n\n收集位运算相关的题目。\n\n\n\n## 判断1的个数\n\n<!-- more -->\n\n### 题面：\n\n给出一个整数`K`，判断其二进制中1的个数。\n\n### 思路1：\n\n典型的二进制题目，可以使用与运算判断数字`K`某一位是否是`1`。巧妙的是，既可以在运算中移位`K`，也可以位移flag。显然后面一种可以避免`K`数字为负而导致的高位填零的右移问题。\n\n### 思路2：\n\n更巧妙的方法，是考虑到`K-1`后会把`K`的第一个低位`1`和之后的`0`全部取饭，此时`K & (K -1)`相比于`K`会少一个低位`1`。如此反复操作便可统计所有1的个数。\n\n> 思路扩展：判断一个数是2的整数次；对于数字`m`需要改变多少位才能变成数字`n`。\n\n### 代码：\n\n**思路1**\n\n```\nint NumberOf1(int n){\n    int flag = 1, count = 0;\n    while(flag){\n        if(flag & n) count++;\n        falg = flag << 1;\n    }\n    return count;\n}\n```\n\n**思路2**\n\n```\nint NumberOf1(int n){\n    int count = 0;\n    while(n){\n        count ++;\n        n = (n - 1) & n;\n    }\n    return count;\n}\n```","source":"_posts/刷题/位运算\n/面试题-位运算.md","raw":"---\ntitle: 面试题-位运算\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:29:07\ntags:\n---\n\n\n\n\n\n收集位运算相关的题目。\n\n\n\n## 判断1的个数\n\n<!-- more -->\n\n### 题面：\n\n给出一个整数`K`，判断其二进制中1的个数。\n\n### 思路1：\n\n典型的二进制题目，可以使用与运算判断数字`K`某一位是否是`1`。巧妙的是，既可以在运算中移位`K`，也可以位移flag。显然后面一种可以避免`K`数字为负而导致的高位填零的右移问题。\n\n### 思路2：\n\n更巧妙的方法，是考虑到`K-1`后会把`K`的第一个低位`1`和之后的`0`全部取饭，此时`K & (K -1)`相比于`K`会少一个低位`1`。如此反复操作便可统计所有1的个数。\n\n> 思路扩展：判断一个数是2的整数次；对于数字`m`需要改变多少位才能变成数字`n`。\n\n### 代码：\n\n**思路1**\n\n```\nint NumberOf1(int n){\n    int flag = 1, count = 0;\n    while(flag){\n        if(flag & n) count++;\n        falg = flag << 1;\n    }\n    return count;\n}\n```\n\n**思路2**\n\n```\nint NumberOf1(int n){\n    int count = 0;\n    while(n){\n        count ++;\n        n = (n - 1) & n;\n    }\n    return count;\n}\n```","slug":"刷题-位运算-面试题-位运算","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j43001hl5uo4kjvfngo","content":"<p>收集位运算相关的题目。</p>\n<h2 id=\"判断1的个数\"><a href=\"#判断1的个数\" class=\"headerlink\" title=\"判断1的个数\"></a>判断1的个数</h2><span id=\"more\"></span>\n\n<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个整数<code>K</code>，判断其二进制中1的个数。</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>典型的二进制题目，可以使用与运算判断数字<code>K</code>某一位是否是<code>1</code>。巧妙的是，既可以在运算中移位<code>K</code>，也可以位移flag。显然后面一种可以避免<code>K</code>数字为负而导致的高位填零的右移问题。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>更巧妙的方法，是考虑到<code>K-1</code>后会把<code>K</code>的第一个低位<code>1</code>和之后的<code>0</code>全部取饭，此时<code>K &amp; (K -1)</code>相比于<code>K</code>会少一个低位<code>1</code>。如此反复操作便可统计所有1的个数。</p>\n<blockquote>\n<p>思路扩展：判断一个数是2的整数次；对于数字<code>m</code>需要改变多少位才能变成数字<code>n</code>。</p>\n</blockquote>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>思路1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int NumberOf1(int n)&#123;\n    int flag &#x3D; 1, count &#x3D; 0;\n    while(flag)&#123;\n        if(flag &amp; n) count++;\n        falg &#x3D; flag &lt;&lt; 1;\n    &#125;\n    return count;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>思路2</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int NumberOf1(int n)&#123;\n    int count &#x3D; 0;\n    while(n)&#123;\n        count ++;\n        n &#x3D; (n - 1) &amp; n;\n    &#125;\n    return count;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2HQTB61","excerpt":"<p>收集位运算相关的题目。</p>\n<h2 id=\"判断1的个数\"><a href=\"#判断1的个数\" class=\"headerlink\" title=\"判断1的个数\"></a>判断1的个数</h2>","more":"<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个整数<code>K</code>，判断其二进制中1的个数。</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>典型的二进制题目，可以使用与运算判断数字<code>K</code>某一位是否是<code>1</code>。巧妙的是，既可以在运算中移位<code>K</code>，也可以位移flag。显然后面一种可以避免<code>K</code>数字为负而导致的高位填零的右移问题。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>更巧妙的方法，是考虑到<code>K-1</code>后会把<code>K</code>的第一个低位<code>1</code>和之后的<code>0</code>全部取饭，此时<code>K &amp; (K -1)</code>相比于<code>K</code>会少一个低位<code>1</code>。如此反复操作便可统计所有1的个数。</p>\n<blockquote>\n<p>思路扩展：判断一个数是2的整数次；对于数字<code>m</code>需要改变多少位才能变成数字<code>n</code>。</p>\n</blockquote>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>思路1</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int NumberOf1(int n)&#123;\n    int flag &#x3D; 1, count &#x3D; 0;\n    while(flag)&#123;\n        if(flag &amp; n) count++;\n        falg &#x3D; flag &lt;&lt; 1;\n    &#125;\n    return count;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>思路2</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int NumberOf1(int n)&#123;\n    int count &#x3D; 0;\n    while(n)&#123;\n        count ++;\n        n &#x3D; (n - 1) &amp; n;\n    &#125;\n    return count;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1025 除数博弈","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:13:01.000Z","_content":"\n<!-- more -->\n\n\n\n## [1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/)\n\n难度简单\n\n### 思路：\n\n可以从简单的例子入手发现，爱丽丝拿`1`输，拿`2`赢，拿`3`输。对于Bob则相反，如果我们可以找出小于数字`N`的数字`x`，且`N-x`可以整除于`N`，`x`对于bob是必输态，那么爱丽丝必胜。\n\n也可以从另一个角度出发：从多个例子可以大胆推测，偶数必胜，奇数必输。\n可以用归纳法证明。那么代码就简单很多。\n\n\n\n### 代码：\n\n堆维护数组\n\n```\nclass Solution {\npublic:\n    bool divisorGame(int N) {\n        if(N < 1 || N > 1000) return false;\n\n        int* dp = new int[1005];\n        dp[1] = 0;\n        dp[2] = 1;\n        for(int i = 3; i < 1001; i++){        \n            dp[i] = 0;\n            for(int j = 1; j < i; j++){\n                if(i % (i - j) == 0 && dp[j] == 0){\n                    dp[i] = 1;\n                    break;\n                }\n            }\n        }\n        return dp[N];\n    }\n};\n```\n\n","source":"_posts/刷题/其他/1025-除数博弈.md","raw":"---\ntitle: 1025 除数博弈\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 14:13:01\n---\n\n<!-- more -->\n\n\n\n## [1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/)\n\n难度简单\n\n### 思路：\n\n可以从简单的例子入手发现，爱丽丝拿`1`输，拿`2`赢，拿`3`输。对于Bob则相反，如果我们可以找出小于数字`N`的数字`x`，且`N-x`可以整除于`N`，`x`对于bob是必输态，那么爱丽丝必胜。\n\n也可以从另一个角度出发：从多个例子可以大胆推测，偶数必胜，奇数必输。\n可以用归纳法证明。那么代码就简单很多。\n\n\n\n### 代码：\n\n堆维护数组\n\n```\nclass Solution {\npublic:\n    bool divisorGame(int N) {\n        if(N < 1 || N > 1000) return false;\n\n        int* dp = new int[1005];\n        dp[1] = 0;\n        dp[2] = 1;\n        for(int i = 3; i < 1001; i++){        \n            dp[i] = 0;\n            for(int j = 1; j < i; j++){\n                if(i % (i - j) == 0 && dp[j] == 0){\n                    dp[i] = 1;\n                    break;\n                }\n            }\n        }\n        return dp[N];\n    }\n};\n```\n\n","slug":"刷题/其他/1025-除数博弈","published":1,"updated":"2021-01-28T14:17:01.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j44001il5uob8lteanj","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"1025-除数博弈\"><a href=\"#1025-除数博弈\" class=\"headerlink\" title=\"1025. 除数博弈\"></a><a href=\"https://leetcode-cn.com/problems/divisor-game/\">1025. 除数博弈</a></h2><p>难度简单</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以从简单的例子入手发现，爱丽丝拿<code>1</code>输，拿<code>2</code>赢，拿<code>3</code>输。对于Bob则相反，如果我们可以找出小于数字<code>N</code>的数字<code>x</code>，且<code>N-x</code>可以整除于<code>N</code>，<code>x</code>对于bob是必输态，那么爱丽丝必胜。</p>\n<p>也可以从另一个角度出发：从多个例子可以大胆推测，偶数必胜，奇数必输。<br>可以用归纳法证明。那么代码就简单很多。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>堆维护数组</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    bool divisorGame(int N) &#123;\n        if(N &lt; 1 || N &gt; 1000) return false;\n\n        int* dp &#x3D; new int[1005];\n        dp[1] &#x3D; 0;\n        dp[2] &#x3D; 1;\n        for(int i &#x3D; 3; i &lt; 1001; i++)&#123;        \n            dp[i] &#x3D; 0;\n            for(int j &#x3D; 1; j &lt; i; j++)&#123;\n                if(i % (i - j) &#x3D;&#x3D; 0 &amp;&amp; dp[j] &#x3D;&#x3D; 0)&#123;\n                    dp[i] &#x3D; 1;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return dp[N];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1Z5VWWY","excerpt":"","more":"<h2 id=\"1025-除数博弈\"><a href=\"#1025-除数博弈\" class=\"headerlink\" title=\"1025. 除数博弈\"></a><a href=\"https://leetcode-cn.com/problems/divisor-game/\">1025. 除数博弈</a></h2><p>难度简单</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以从简单的例子入手发现，爱丽丝拿<code>1</code>输，拿<code>2</code>赢，拿<code>3</code>输。对于Bob则相反，如果我们可以找出小于数字<code>N</code>的数字<code>x</code>，且<code>N-x</code>可以整除于<code>N</code>，<code>x</code>对于bob是必输态，那么爱丽丝必胜。</p>\n<p>也可以从另一个角度出发：从多个例子可以大胆推测，偶数必胜，奇数必输。<br>可以用归纳法证明。那么代码就简单很多。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>堆维护数组</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    bool divisorGame(int N) &#123;\n        if(N &lt; 1 || N &gt; 1000) return false;\n\n        int* dp &#x3D; new int[1005];\n        dp[1] &#x3D; 0;\n        dp[2] &#x3D; 1;\n        for(int i &#x3D; 3; i &lt; 1001; i++)&#123;        \n            dp[i] &#x3D; 0;\n            for(int j &#x3D; 1; j &lt; i; j++)&#123;\n                if(i % (i - j) &#x3D;&#x3D; 0 &amp;&amp; dp[j] &#x3D;&#x3D; 0)&#123;\n                    dp[i] &#x3D; 1;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return dp[N];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1027 最长等差数列","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:12:36.000Z","_content":"\n<!-- more -->\n\n\n\n## [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-sequence//)\n\n### 思路：\n\n求最长等差序列的长度，可以看出序列可以分解为多个序列，而且序列的选择不具有历史影响。可以可以考虑用DP做。用一个状态无法表示数列的等差量和数列的端点两个状态。所以至少得有两个状态，且可以用两个状态分别表示一个等差序列的最后两个元素下标。\n\n\nDP方程可以这么写：\n\ndp[i][j]={dp[k][i]+1,if k is element of the array 2,elsedp[i][j]={dp[k][i]+1,if k is element of the array 2,else\n\n\n\n> 为啥是最后两个？因为为最后两个元素组成的最长等差序列，可以给后续DP方程计算。而两个元素作为开头无法递推！\n\n```\nclass Solution {\npublic:\n\n    int longestArithSeqLength(vector<int>& A) {        \n        int n = A.size();\n        //优秀的初始化方法\n        // vector<int>(n, 2)动态生成了一个长度为n，每个元素为2的vector对象\n        vector<vector<int> > dp(n, vector<int>(n, 2));\n        map<int, int> idx;\n        int maxRes = 2;\n        for(int i = 0; i < (int)A.size() - 1; i++){\n            for(int j = i + 1; j < A.size(); j++){\n                int target = A[i] * 2 - A[j];\n                if( idx.count( target )) dp[i][j] = dp[idx[target]][i] + 1;\n                maxRes = max(maxRes, dp[i][j]);\n            }\n            idx[A[i]] = i;\n        }\n        return maxRes;\n    }\n};\n```","source":"_posts/刷题/其他/1027-最长等差数列.md","raw":"---\ntitle: 1027 最长等差数列\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 14:12:36\ntags:\n---\n\n<!-- more -->\n\n\n\n## [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-sequence//)\n\n### 思路：\n\n求最长等差序列的长度，可以看出序列可以分解为多个序列，而且序列的选择不具有历史影响。可以可以考虑用DP做。用一个状态无法表示数列的等差量和数列的端点两个状态。所以至少得有两个状态，且可以用两个状态分别表示一个等差序列的最后两个元素下标。\n\n\nDP方程可以这么写：\n\ndp[i][j]={dp[k][i]+1,if k is element of the array 2,elsedp[i][j]={dp[k][i]+1,if k is element of the array 2,else\n\n\n\n> 为啥是最后两个？因为为最后两个元素组成的最长等差序列，可以给后续DP方程计算。而两个元素作为开头无法递推！\n\n```\nclass Solution {\npublic:\n\n    int longestArithSeqLength(vector<int>& A) {        \n        int n = A.size();\n        //优秀的初始化方法\n        // vector<int>(n, 2)动态生成了一个长度为n，每个元素为2的vector对象\n        vector<vector<int> > dp(n, vector<int>(n, 2));\n        map<int, int> idx;\n        int maxRes = 2;\n        for(int i = 0; i < (int)A.size() - 1; i++){\n            for(int j = i + 1; j < A.size(); j++){\n                int target = A[i] * 2 - A[j];\n                if( idx.count( target )) dp[i][j] = dp[idx[target]][i] + 1;\n                maxRes = max(maxRes, dp[i][j]);\n            }\n            idx[A[i]] = i;\n        }\n        return maxRes;\n    }\n};\n```","slug":"刷题/其他/1027-最长等差数列","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j46001jl5uofccqdizt","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"1027-最长等差数列\"><a href=\"#1027-最长等差数列\" class=\"headerlink\" title=\"1027. 最长等差数列\"></a><a href=\"https://leetcode-cn.com/problems/longest-arithmetic-sequence//\">1027. 最长等差数列</a></h2><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>求最长等差序列的长度，可以看出序列可以分解为多个序列，而且序列的选择不具有历史影响。可以可以考虑用DP做。用一个状态无法表示数列的等差量和数列的端点两个状态。所以至少得有两个状态，且可以用两个状态分别表示一个等差序列的最后两个元素下标。</p>\n<p>DP方程可以这么写：</p>\n<p>dp[i][j]={dp[k][i]+1,if k is element of the array 2,elsedp[i][j]={dp[k][i]+1,if k is element of the array 2,else</p>\n<blockquote>\n<p>为啥是最后两个？因为为最后两个元素组成的最长等差序列，可以给后续DP方程计算。而两个元素作为开头无法递推！</p>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\n    int longestArithSeqLength(vector&lt;int&gt;&amp; A) &#123;        \n        int n &#x3D; A.size();\n        &#x2F;&#x2F;优秀的初始化方法\n        &#x2F;&#x2F; vector&lt;int&gt;(n, 2)动态生成了一个长度为n，每个元素为2的vector对象\n        vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 2));\n        map&lt;int, int&gt; idx;\n        int maxRes &#x3D; 2;\n        for(int i &#x3D; 0; i &lt; (int)A.size() - 1; i++)&#123;\n            for(int j &#x3D; i + 1; j &lt; A.size(); j++)&#123;\n                int target &#x3D; A[i] * 2 - A[j];\n                if( idx.count( target )) dp[i][j] &#x3D; dp[idx[target]][i] + 1;\n                maxRes &#x3D; max(maxRes, dp[i][j]);\n            &#125;\n            idx[A[i]] &#x3D; i;\n        &#125;\n        return maxRes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"KQ6MPV","excerpt":"","more":"<h2 id=\"1027-最长等差数列\"><a href=\"#1027-最长等差数列\" class=\"headerlink\" title=\"1027. 最长等差数列\"></a><a href=\"https://leetcode-cn.com/problems/longest-arithmetic-sequence//\">1027. 最长等差数列</a></h2><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>求最长等差序列的长度，可以看出序列可以分解为多个序列，而且序列的选择不具有历史影响。可以可以考虑用DP做。用一个状态无法表示数列的等差量和数列的端点两个状态。所以至少得有两个状态，且可以用两个状态分别表示一个等差序列的最后两个元素下标。</p>\n<p>DP方程可以这么写：</p>\n<p>dp[i][j]={dp[k][i]+1,if k is element of the array 2,elsedp[i][j]={dp[k][i]+1,if k is element of the array 2,else</p>\n<blockquote>\n<p>为啥是最后两个？因为为最后两个元素组成的最长等差序列，可以给后续DP方程计算。而两个元素作为开头无法递推！</p>\n</blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\n    int longestArithSeqLength(vector&lt;int&gt;&amp; A) &#123;        \n        int n &#x3D; A.size();\n        &#x2F;&#x2F;优秀的初始化方法\n        &#x2F;&#x2F; vector&lt;int&gt;(n, 2)动态生成了一个长度为n，每个元素为2的vector对象\n        vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 2));\n        map&lt;int, int&gt; idx;\n        int maxRes &#x3D; 2;\n        for(int i &#x3D; 0; i &lt; (int)A.size() - 1; i++)&#123;\n            for(int j &#x3D; i + 1; j &lt; A.size(); j++)&#123;\n                int target &#x3D; A[i] * 2 - A[j];\n                if( idx.count( target )) dp[i][j] &#x3D; dp[idx[target]][i] + 1;\n                maxRes &#x3D; max(maxRes, dp[i][j]);\n            &#125;\n            idx[A[i]] &#x3D; i;\n        &#125;\n        return maxRes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1143. Longest Common Subsequence","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-15T13:23:07.000Z","_content":"\n\n\n\n## [1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)\n\n## 思路：\n\n\n\n`dp[i][[j]`为text1和text2在位置i,j的最长公共子序列。\n\n<!-- more -->\n\n## 代码：\n\n80%\n\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size(), m = text2.size();\n        if(n == 0 || m == 0) return 0;\n        vector<vector<int>> dp;\n        dp.resize(n, vector<int>(m, 0));        \n        int flag = 0;\n        for(int i = 0; i < n; i++){            \n            if(flag || text1[i] == text2[0]){\n               flag = 1; \n                dp[i][0] = 1;\n            }\n        }\n        flag = 0;\n        for(int i = 0; i < m; i++){\n            if(flag || text1[0] == text2[i]){\n                flag = 1;\n                dp[0][i] = 1;\n            }\n        }\n\n        for(int i = 1; i < n; ++i){\n            for(int j = 1; j < m; ++j){\n                if(text1[i] == text2[j]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else dp[i][j] = max(dp[i][j -1], dp[i - 1][j]);\n                // cout << dp[i][j] << ' ';\n            }\n            // cout<< endl;\n        }\n        return dp[n - 1][m - 1];\n    }\n};\n```","source":"_posts/刷题/其他/1143-Longest-Common-Subsequence.md","raw":"---\ntitle: 1143. Longest Common Subsequence\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-12-15 21:23:07\ntags:\n---\n\n\n\n\n## [1143. Longest Common Subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)\n\n## 思路：\n\n\n\n`dp[i][[j]`为text1和text2在位置i,j的最长公共子序列。\n\n<!-- more -->\n\n## 代码：\n\n80%\n\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size(), m = text2.size();\n        if(n == 0 || m == 0) return 0;\n        vector<vector<int>> dp;\n        dp.resize(n, vector<int>(m, 0));        \n        int flag = 0;\n        for(int i = 0; i < n; i++){            \n            if(flag || text1[i] == text2[0]){\n               flag = 1; \n                dp[i][0] = 1;\n            }\n        }\n        flag = 0;\n        for(int i = 0; i < m; i++){\n            if(flag || text1[0] == text2[i]){\n                flag = 1;\n                dp[0][i] = 1;\n            }\n        }\n\n        for(int i = 1; i < n; ++i){\n            for(int j = 1; j < m; ++j){\n                if(text1[i] == text2[j]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else dp[i][j] = max(dp[i][j -1], dp[i - 1][j]);\n                // cout << dp[i][j] << ' ';\n            }\n            // cout<< endl;\n        }\n        return dp[n - 1][m - 1];\n    }\n};\n```","slug":"刷题/其他/1143-Longest-Common-Subsequence","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j48001kl5uo8biz8hkn","content":"<h2 id=\"1143-Longest-Common-Subsequence\"><a href=\"#1143-Longest-Common-Subsequence\" class=\"headerlink\" title=\"1143. Longest Common Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">1143. Longest Common Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>dp[i][[j]</code>为text1和text2在位置i,j的最长公共子序列。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>80%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestCommonSubsequence(string text1, string text2) &#123;\n        int n &#x3D; text1.size(), m &#x3D; text2.size();\n        if(n &#x3D;&#x3D; 0 || m &#x3D;&#x3D; 0) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp;\n        dp.resize(n, vector&lt;int&gt;(m, 0));        \n        int flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++)&#123;            \n            if(flag || text1[i] &#x3D;&#x3D; text2[0])&#123;\n               flag &#x3D; 1; \n                dp[i][0] &#x3D; 1;\n            &#125;\n        &#125;\n        flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; m; i++)&#123;\n            if(flag || text1[0] &#x3D;&#x3D; text2[i])&#123;\n                flag &#x3D; 1;\n                dp[0][i] &#x3D; 1;\n            &#125;\n        &#125;\n\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                if(text1[i] &#x3D;&#x3D; text2[j])&#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;\n                &#125;else dp[i][j] &#x3D; max(dp[i][j -1], dp[i - 1][j]);\n                &#x2F;&#x2F; cout &lt;&lt; dp[i][j] &lt;&lt; &#39; &#39;;\n            &#125;\n            &#x2F;&#x2F; cout&lt;&lt; endl;\n        &#125;\n        return dp[n - 1][m - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2S7G4A7","excerpt":"<h2 id=\"1143-Longest-Common-Subsequence\"><a href=\"#1143-Longest-Common-Subsequence\" class=\"headerlink\" title=\"1143. Longest Common Subsequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">1143. Longest Common Subsequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>dp[i][[j]</code>为text1和text2在位置i,j的最长公共子序列。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>80%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestCommonSubsequence(string text1, string text2) &#123;\n        int n &#x3D; text1.size(), m &#x3D; text2.size();\n        if(n &#x3D;&#x3D; 0 || m &#x3D;&#x3D; 0) return 0;\n        vector&lt;vector&lt;int&gt;&gt; dp;\n        dp.resize(n, vector&lt;int&gt;(m, 0));        \n        int flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; i++)&#123;            \n            if(flag || text1[i] &#x3D;&#x3D; text2[0])&#123;\n               flag &#x3D; 1; \n                dp[i][0] &#x3D; 1;\n            &#125;\n        &#125;\n        flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; m; i++)&#123;\n            if(flag || text1[0] &#x3D;&#x3D; text2[i])&#123;\n                flag &#x3D; 1;\n                dp[0][i] &#x3D; 1;\n            &#125;\n        &#125;\n\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                if(text1[i] &#x3D;&#x3D; text2[j])&#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;\n                &#125;else dp[i][j] &#x3D; max(dp[i][j -1], dp[i - 1][j]);\n                &#x2F;&#x2F; cout &lt;&lt; dp[i][j] &lt;&lt; &#39; &#39;;\n            &#125;\n            &#x2F;&#x2F; cout&lt;&lt; endl;\n        &#125;\n        return dp[n - 1][m - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1190. Reverse Substrings Between Each Pair of Parentheses","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:14:44.000Z","_content":"\n\n<!-- more -->\n\n[1190.Reverse Substrings Between Each Pair of Parentheses](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/)\n\n难度MD\n这个题一开始思路就错了，首先是括号匹配问题不能使用左右指针选择，其次是字符串翻转完全可以忽略掉括号（或者说连同括号一起翻转）。\n一共有两种思路。\n\n\n\n## 思路1\n\n将栈匹配+翻转，复杂度O(n2)O(n2)。\n\n```\nclass Solution {\npublic:\n    // string reverseParentheses(string s) {\n    //     string ns = \"\";\n    //     vector<int> idxl, idxr;\n    //     int singbrack = 0, calbrack = 0;\n    //     for(int i = 0; i < s.size(); i++){\n    //         if(s[i] == '(' || s[i] == ')') singbrack ++;\n    //         else ns.push_back(s[i]);\n    //     }\n    //     singbrack /=  2;\n    //     for(int i = 0, j = s.size() - 1; i < j;){\n    //         while(i < j && s[i] != '(') i++;\n    //         while(i < j && s[j] != ')') j--;\n    //         idxl.push_back(i - calbrack);\n    //         idxr.push_back(j - singbrack - (singbrack - calbrack - 1)); // reverse 翻转的范围是[),这里注意01错误\n    //         i++;\n    //         j--;\n    //         calbrack ++; \n    //     }\n    //     if(calbrack == 0) return ns;\n        \n    //     for(int i = idxl.size() - 1; i >= 0; i--){\n    //         reverse(ns.begin() + idxl[i], ns.begin() + idxr[i]);\n    //     }\n    //     return ns;\n    // }\n\n\n    string reverseParentheses(string s) {\n        string ns = \"\";\n        stack<int> sti;      \n        for(int i= 0; i < s.size(); i++){\n            if( s[i] == '(')\n                sti.push(i);\n            else if(s[i] == ')'){\n                reverse( s.begin() + sti.top(),  s.begin() + i);\n                sti.pop();\n            }   \n        }\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '(' || s[i] == ')' ) continue;\n            ns.push_back(s[i]);\n        }\n        return ns;\n    }\n};\n```\n\n## 思路2\n\n神奇的黑魔法（这个算法局限于这个应用，感觉挺死板）","source":"_posts/刷题/其他/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses.md","raw":"---\ntitle: 1190. Reverse Substrings Between Each Pair of Parentheses\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 14:14:44\ntags:\n---\n\n\n<!-- more -->\n\n[1190.Reverse Substrings Between Each Pair of Parentheses](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/)\n\n难度MD\n这个题一开始思路就错了，首先是括号匹配问题不能使用左右指针选择，其次是字符串翻转完全可以忽略掉括号（或者说连同括号一起翻转）。\n一共有两种思路。\n\n\n\n## 思路1\n\n将栈匹配+翻转，复杂度O(n2)O(n2)。\n\n```\nclass Solution {\npublic:\n    // string reverseParentheses(string s) {\n    //     string ns = \"\";\n    //     vector<int> idxl, idxr;\n    //     int singbrack = 0, calbrack = 0;\n    //     for(int i = 0; i < s.size(); i++){\n    //         if(s[i] == '(' || s[i] == ')') singbrack ++;\n    //         else ns.push_back(s[i]);\n    //     }\n    //     singbrack /=  2;\n    //     for(int i = 0, j = s.size() - 1; i < j;){\n    //         while(i < j && s[i] != '(') i++;\n    //         while(i < j && s[j] != ')') j--;\n    //         idxl.push_back(i - calbrack);\n    //         idxr.push_back(j - singbrack - (singbrack - calbrack - 1)); // reverse 翻转的范围是[),这里注意01错误\n    //         i++;\n    //         j--;\n    //         calbrack ++; \n    //     }\n    //     if(calbrack == 0) return ns;\n        \n    //     for(int i = idxl.size() - 1; i >= 0; i--){\n    //         reverse(ns.begin() + idxl[i], ns.begin() + idxr[i]);\n    //     }\n    //     return ns;\n    // }\n\n\n    string reverseParentheses(string s) {\n        string ns = \"\";\n        stack<int> sti;      \n        for(int i= 0; i < s.size(); i++){\n            if( s[i] == '(')\n                sti.push(i);\n            else if(s[i] == ')'){\n                reverse( s.begin() + sti.top(),  s.begin() + i);\n                sti.pop();\n            }   \n        }\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '(' || s[i] == ')' ) continue;\n            ns.push_back(s[i]);\n        }\n        return ns;\n    }\n};\n```\n\n## 思路2\n\n神奇的黑魔法（这个算法局限于这个应用，感觉挺死板）","slug":"刷题/其他/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j49001ll5uobo1l44vx","content":"<span id=\"more\"></span>\n\n<p><a href=\"https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/\">1190.Reverse Substrings Between Each Pair of Parentheses</a></p>\n<p>难度MD<br>这个题一开始思路就错了，首先是括号匹配问题不能使用左右指针选择，其次是字符串翻转完全可以忽略掉括号（或者说连同括号一起翻转）。<br>一共有两种思路。</p>\n<h2 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h2><p>将栈匹配+翻转，复杂度O(n2)O(n2)。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; string reverseParentheses(string s) &#123;\n    &#x2F;&#x2F;     string ns &#x3D; &quot;&quot;;\n    &#x2F;&#x2F;     vector&lt;int&gt; idxl, idxr;\n    &#x2F;&#x2F;     int singbrack &#x3D; 0, calbrack &#x3D; 0;\n    &#x2F;&#x2F;     for(int i &#x3D; 0; i &lt; s.size(); i++)&#123;\n    &#x2F;&#x2F;         if(s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39;) singbrack ++;\n    &#x2F;&#x2F;         else ns.push_back(s[i]);\n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     singbrack &#x2F;&#x3D;  2;\n    &#x2F;&#x2F;     for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j;)&#123;\n    &#x2F;&#x2F;         while(i &lt; j &amp;&amp; s[i] !&#x3D; &#39;(&#39;) i++;\n    &#x2F;&#x2F;         while(i &lt; j &amp;&amp; s[j] !&#x3D; &#39;)&#39;) j--;\n    &#x2F;&#x2F;         idxl.push_back(i - calbrack);\n    &#x2F;&#x2F;         idxr.push_back(j - singbrack - (singbrack - calbrack - 1)); &#x2F;&#x2F; reverse 翻转的范围是[),这里注意01错误\n    &#x2F;&#x2F;         i++;\n    &#x2F;&#x2F;         j--;\n    &#x2F;&#x2F;         calbrack ++; \n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     if(calbrack &#x3D;&#x3D; 0) return ns;\n        \n    &#x2F;&#x2F;     for(int i &#x3D; idxl.size() - 1; i &gt;&#x3D; 0; i--)&#123;\n    &#x2F;&#x2F;         reverse(ns.begin() + idxl[i], ns.begin() + idxr[i]);\n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     return ns;\n    &#x2F;&#x2F; &#125;\n\n\n    string reverseParentheses(string s) &#123;\n        string ns &#x3D; &quot;&quot;;\n        stack&lt;int&gt; sti;      \n        for(int i&#x3D; 0; i &lt; s.size(); i++)&#123;\n            if( s[i] &#x3D;&#x3D; &#39;(&#39;)\n                sti.push(i);\n            else if(s[i] &#x3D;&#x3D; &#39;)&#39;)&#123;\n                reverse( s.begin() + sti.top(),  s.begin() + i);\n                sti.pop();\n            &#125;   \n        &#125;\n        for(int i &#x3D; 0; i &lt; s.size(); i++)&#123;\n            if(s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39; ) continue;\n            ns.push_back(s[i]);\n        &#125;\n        return ns;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h2><p>神奇的黑魔法（这个算法局限于这个应用，感觉挺死板）</p>\n","site":{"data":{}},"abbrlink":"3HSV6M8","excerpt":"","more":"<p><a href=\"https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/\">1190.Reverse Substrings Between Each Pair of Parentheses</a></p>\n<p>难度MD<br>这个题一开始思路就错了，首先是括号匹配问题不能使用左右指针选择，其次是字符串翻转完全可以忽略掉括号（或者说连同括号一起翻转）。<br>一共有两种思路。</p>\n<h2 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h2><p>将栈匹配+翻转，复杂度O(n2)O(n2)。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; string reverseParentheses(string s) &#123;\n    &#x2F;&#x2F;     string ns &#x3D; &quot;&quot;;\n    &#x2F;&#x2F;     vector&lt;int&gt; idxl, idxr;\n    &#x2F;&#x2F;     int singbrack &#x3D; 0, calbrack &#x3D; 0;\n    &#x2F;&#x2F;     for(int i &#x3D; 0; i &lt; s.size(); i++)&#123;\n    &#x2F;&#x2F;         if(s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39;) singbrack ++;\n    &#x2F;&#x2F;         else ns.push_back(s[i]);\n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     singbrack &#x2F;&#x3D;  2;\n    &#x2F;&#x2F;     for(int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j;)&#123;\n    &#x2F;&#x2F;         while(i &lt; j &amp;&amp; s[i] !&#x3D; &#39;(&#39;) i++;\n    &#x2F;&#x2F;         while(i &lt; j &amp;&amp; s[j] !&#x3D; &#39;)&#39;) j--;\n    &#x2F;&#x2F;         idxl.push_back(i - calbrack);\n    &#x2F;&#x2F;         idxr.push_back(j - singbrack - (singbrack - calbrack - 1)); &#x2F;&#x2F; reverse 翻转的范围是[),这里注意01错误\n    &#x2F;&#x2F;         i++;\n    &#x2F;&#x2F;         j--;\n    &#x2F;&#x2F;         calbrack ++; \n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     if(calbrack &#x3D;&#x3D; 0) return ns;\n        \n    &#x2F;&#x2F;     for(int i &#x3D; idxl.size() - 1; i &gt;&#x3D; 0; i--)&#123;\n    &#x2F;&#x2F;         reverse(ns.begin() + idxl[i], ns.begin() + idxr[i]);\n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     return ns;\n    &#x2F;&#x2F; &#125;\n\n\n    string reverseParentheses(string s) &#123;\n        string ns &#x3D; &quot;&quot;;\n        stack&lt;int&gt; sti;      \n        for(int i&#x3D; 0; i &lt; s.size(); i++)&#123;\n            if( s[i] &#x3D;&#x3D; &#39;(&#39;)\n                sti.push(i);\n            else if(s[i] &#x3D;&#x3D; &#39;)&#39;)&#123;\n                reverse( s.begin() + sti.top(),  s.begin() + i);\n                sti.pop();\n            &#125;   \n        &#125;\n        for(int i &#x3D; 0; i &lt; s.size(); i++)&#123;\n            if(s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39; ) continue;\n            ns.push_back(s[i]);\n        &#125;\n        return ns;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h2><p>神奇的黑魔法（这个算法局限于这个应用，感觉挺死板）</p>"},{"title":"122. Best Time to Buy and Sell Stock II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-14T23:02:41.000Z","_content":"\n\n\n<!-- more -->\n\n\n\n## 思路：\n\n贪心做每一个可以交易的交易就行\n\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int sum = 0;\n        for(int i = 0; i < prices.size() - 1; ++i){\n            sum += (prices[i] < prices[i + 1] )? prices[i + 1] - prices[i] : 0; \n        }\n        return sum;\n    }\n};\n```\n\n","source":"_posts/刷题/其他/122-Best-Time-to-Buy-and-Sell-Stock-II.md","raw":"---\ntitle: 122. Best Time to Buy and Sell Stock II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-15 07:02:41\n---\n\n\n\n<!-- more -->\n\n\n\n## 思路：\n\n贪心做每一个可以交易的交易就行\n\n> ![image-20201226081801949](http://static.come2rss.xyz/image-20201226081801949.png)\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int sum = 0;\n        for(int i = 0; i < prices.size() - 1; ++i){\n            sum += (prices[i] < prices[i + 1] )? prices[i + 1] - prices[i] : 0; \n        }\n        return sum;\n    }\n};\n```\n\n","slug":"刷题/其他/122-Best-Time-to-Buy-and-Sell-Stock-II","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4a001ml5uo1oxb6p9s","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>贪心做每一个可以交易的交易就行</p>\n<blockquote>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int sum &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; prices.size() - 1; ++i)&#123;\n            sum +&#x3D; (prices[i] &lt; prices[i + 1] )? prices[i + 1] - prices[i] : 0; \n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3YAGY8H","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>贪心做每一个可以交易的交易就行</p>\n<blockquote>\n<p><img src=\"http://static.come2rss.xyz/image-20201226081801949.png\" alt=\"image-20201226081801949\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;\n        int sum &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; prices.size() - 1; ++i)&#123;\n            sum +&#x3D; (prices[i] &lt; prices[i + 1] )? prices[i + 1] - prices[i] : 0; \n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1254. Number of Closed Islands","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:11:56.000Z","_content":"\n<!-- more -->\n\n\n\n#### [1254. Number of Closed Islands](https://leetcode-cn.com/problems/number-of-closed-islands/)\n\n难度MD\n\n**思路**：DFS或者并查集\n\n1. 排除法：将所有接触过边界的0块排除掉，接下来统计所有的0块数量就是岛屿的数量啦~\n2. 直接法：考虑成为岛屿的条件——岛屿上所有0块都不与边界相交。\n\n接下来只需要写DFS或者BFS就👌。\n\n1. 考虑使用并查集\n\n**排除法**\n\n\n\n```\nclass Solution {\npublic:\n\t//保持和第二种写法一致，add参数实际上是多余的\n    void findBlockOf0(int x, int y,int N, int M, vector< vector<int> > &grid, int &add){\n        if(x < 0 || x >= N || y < 0 || y >= M || grid[x][y] == 1) return;\n        //if(grid[x][y] == 1) add = 1;\n        grid[x][y] = 1;\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    }\n\n    int closedIsland(vector<vector<int>>& grid) {\n        int N = grid.size(), M = grid[0].size(), counts, add;\n        //排除掉那些不是island的blocks of 0\n        for(int i=0;i < M; i++){\n            findBlockOf0(0,i, N, M, grid, counts);\n            findBlockOf0(N-1,i, N, M, grid, counts);\n        }\n        for(int i=0;i < N;i++){\n            findBlockOf0(i,0,N,M, grid, counts);\n            findBlockOf0(i,M-1, N, M, grid, counts);\n        }\n        //接下来所有的0块都可以算作island\n        counts = 0;\n        for(int x = 0 ;x < N;x++){\n            for(int y=0; y < M; y++ ){\n                if(grid[x][y] != 0) continue;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts += 1;\n            }                                         \n        }\n        return counts;\n    }\n};\n```\n\n**直接法**\n\n```\nclass Solution {\n    public:\n\t// 注意遍历的时候不能剪枝，否则就会就会出现岛屿断裂成多个“单独”岛屿而计数过多\n    void findBlockOf0(int x, int y,int N, int M, vector< vector<int> > &grid, int &add){\n        if(x < 0 || x >= N || y < 0 || y >= M || grid[x][y] == 1) return;\n        if(x == 0 || x == N-1|| y == 0 || y == M-1 ) add = 0;\n        grid[x][y] = 1;\n        // 这里的四个方向其实可以用FOR写的更优雅一些\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    }\n\n    int closedIsland(vector<vector<int>>& grid) {\n        int N = grid.size(), M = grid[0].size(), counts;\n        counts = 0;\n        for(int x = 0 ;x < N;x++){\n            for(int y=0; y < M; y++ ){\n                if(grid[x][y] != 0) continue;\n                int add = 1;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts += add;\n            }                                         \n        }\n        return counts;\n    }\n};\n```\n\n尝试使用BFS写第二种写法~\n\n```\nclass Solution {\npublic:\n\t// BFS\n    int findBlockOf0(int x, int y,int N, int M, vector< vector<int> > &grid){\n        int dX[4] = {0, 0, -1, 1}, dY[4] = {1, -1, 0, 0}, nX, nY;\n        int flag = 1;\n        queue< vector<int> > que;\n        que.push( {x, y});\n        grid[x][y] = 1;\n        while( !que.empty() ){\n            vector<int> point = que.front();\n            que.pop();\n            int x = point[0], y = point[1];\n            //注意 所有的点都需要判断是否在边界上\n            if(x  == 0 || x == N - 1 ||y == 0 || y == M - 1) flag = 0;\n            for(int i=0;i < 4; i++){\n                nX = x + dX[i];\n                nY = y + dY[i];\n                if(nY >= 0 && nY < M && nX >=0 && nX < N && grid[nX][nY] == 0){                \n                    grid[nX][nY] = 1;\n                    que.push({nX, nY});\n                    \n                }\n            }\n        }\n        return flag;\n    }\n\n    int closedIsland(vector<vector<int>>& grid) {\n        int N = grid.size(), M = grid[0].size(), counts;\n        counts = 0;\n        for(int x = 0 ;x < N;x++){\n            for(int y=0; y < M; y++ ){\n                if(grid[x][y] != 0) continue;\n                counts +=  findBlockOf0(x, y, N, M, grid);\n            }                                         \n        }\n        return counts;\n    }\n};\n```\n\n并查集\n\n改日再战","source":"_posts/刷题/其他/1254-Number-of-Closed-Islands.md","raw":"---\ntitle: 1254. Number of Closed Islands\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 14:11:56\n---\n\n<!-- more -->\n\n\n\n#### [1254. Number of Closed Islands](https://leetcode-cn.com/problems/number-of-closed-islands/)\n\n难度MD\n\n**思路**：DFS或者并查集\n\n1. 排除法：将所有接触过边界的0块排除掉，接下来统计所有的0块数量就是岛屿的数量啦~\n2. 直接法：考虑成为岛屿的条件——岛屿上所有0块都不与边界相交。\n\n接下来只需要写DFS或者BFS就👌。\n\n1. 考虑使用并查集\n\n**排除法**\n\n\n\n```\nclass Solution {\npublic:\n\t//保持和第二种写法一致，add参数实际上是多余的\n    void findBlockOf0(int x, int y,int N, int M, vector< vector<int> > &grid, int &add){\n        if(x < 0 || x >= N || y < 0 || y >= M || grid[x][y] == 1) return;\n        //if(grid[x][y] == 1) add = 1;\n        grid[x][y] = 1;\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    }\n\n    int closedIsland(vector<vector<int>>& grid) {\n        int N = grid.size(), M = grid[0].size(), counts, add;\n        //排除掉那些不是island的blocks of 0\n        for(int i=0;i < M; i++){\n            findBlockOf0(0,i, N, M, grid, counts);\n            findBlockOf0(N-1,i, N, M, grid, counts);\n        }\n        for(int i=0;i < N;i++){\n            findBlockOf0(i,0,N,M, grid, counts);\n            findBlockOf0(i,M-1, N, M, grid, counts);\n        }\n        //接下来所有的0块都可以算作island\n        counts = 0;\n        for(int x = 0 ;x < N;x++){\n            for(int y=0; y < M; y++ ){\n                if(grid[x][y] != 0) continue;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts += 1;\n            }                                         \n        }\n        return counts;\n    }\n};\n```\n\n**直接法**\n\n```\nclass Solution {\n    public:\n\t// 注意遍历的时候不能剪枝，否则就会就会出现岛屿断裂成多个“单独”岛屿而计数过多\n    void findBlockOf0(int x, int y,int N, int M, vector< vector<int> > &grid, int &add){\n        if(x < 0 || x >= N || y < 0 || y >= M || grid[x][y] == 1) return;\n        if(x == 0 || x == N-1|| y == 0 || y == M-1 ) add = 0;\n        grid[x][y] = 1;\n        // 这里的四个方向其实可以用FOR写的更优雅一些\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    }\n\n    int closedIsland(vector<vector<int>>& grid) {\n        int N = grid.size(), M = grid[0].size(), counts;\n        counts = 0;\n        for(int x = 0 ;x < N;x++){\n            for(int y=0; y < M; y++ ){\n                if(grid[x][y] != 0) continue;\n                int add = 1;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts += add;\n            }                                         \n        }\n        return counts;\n    }\n};\n```\n\n尝试使用BFS写第二种写法~\n\n```\nclass Solution {\npublic:\n\t// BFS\n    int findBlockOf0(int x, int y,int N, int M, vector< vector<int> > &grid){\n        int dX[4] = {0, 0, -1, 1}, dY[4] = {1, -1, 0, 0}, nX, nY;\n        int flag = 1;\n        queue< vector<int> > que;\n        que.push( {x, y});\n        grid[x][y] = 1;\n        while( !que.empty() ){\n            vector<int> point = que.front();\n            que.pop();\n            int x = point[0], y = point[1];\n            //注意 所有的点都需要判断是否在边界上\n            if(x  == 0 || x == N - 1 ||y == 0 || y == M - 1) flag = 0;\n            for(int i=0;i < 4; i++){\n                nX = x + dX[i];\n                nY = y + dY[i];\n                if(nY >= 0 && nY < M && nX >=0 && nX < N && grid[nX][nY] == 0){                \n                    grid[nX][nY] = 1;\n                    que.push({nX, nY});\n                    \n                }\n            }\n        }\n        return flag;\n    }\n\n    int closedIsland(vector<vector<int>>& grid) {\n        int N = grid.size(), M = grid[0].size(), counts;\n        counts = 0;\n        for(int x = 0 ;x < N;x++){\n            for(int y=0; y < M; y++ ){\n                if(grid[x][y] != 0) continue;\n                counts +=  findBlockOf0(x, y, N, M, grid);\n            }                                         \n        }\n        return counts;\n    }\n};\n```\n\n并查集\n\n改日再战","slug":"刷题/其他/1254-Number-of-Closed-Islands","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4b001nl5uoa0fse7qg","content":"<span id=\"more\"></span>\n\n\n\n<h4 id=\"1254-Number-of-Closed-Islands\"><a href=\"#1254-Number-of-Closed-Islands\" class=\"headerlink\" title=\"1254. Number of Closed Islands\"></a><a href=\"https://leetcode-cn.com/problems/number-of-closed-islands/\">1254. Number of Closed Islands</a></h4><p>难度MD</p>\n<p><strong>思路</strong>：DFS或者并查集</p>\n<ol>\n<li>排除法：将所有接触过边界的0块排除掉，接下来统计所有的0块数量就是岛屿的数量啦~</li>\n<li>直接法：考虑成为岛屿的条件——岛屿上所有0块都不与边界相交。</li>\n</ol>\n<p>接下来只需要写DFS或者BFS就👌。</p>\n<ol>\n<li>考虑使用并查集</li>\n</ol>\n<p><strong>排除法</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\t&#x2F;&#x2F;保持和第二种写法一致，add参数实际上是多余的\n    void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add)&#123;\n        if(x &lt; 0 || x &gt;&#x3D; N || y &lt; 0 || y &gt;&#x3D; M || grid[x][y] &#x3D;&#x3D; 1) return;\n        &#x2F;&#x2F;if(grid[x][y] &#x3D;&#x3D; 1) add &#x3D; 1;\n        grid[x][y] &#x3D; 1;\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    &#125;\n\n    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int N &#x3D; grid.size(), M &#x3D; grid[0].size(), counts, add;\n        &#x2F;&#x2F;排除掉那些不是island的blocks of 0\n        for(int i&#x3D;0;i &lt; M; i++)&#123;\n            findBlockOf0(0,i, N, M, grid, counts);\n            findBlockOf0(N-1,i, N, M, grid, counts);\n        &#125;\n        for(int i&#x3D;0;i &lt; N;i++)&#123;\n            findBlockOf0(i,0,N,M, grid, counts);\n            findBlockOf0(i,M-1, N, M, grid, counts);\n        &#125;\n        &#x2F;&#x2F;接下来所有的0块都可以算作island\n        counts &#x3D; 0;\n        for(int x &#x3D; 0 ;x &lt; N;x++)&#123;\n            for(int y&#x3D;0; y &lt; M; y++ )&#123;\n                if(grid[x][y] !&#x3D; 0) continue;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts +&#x3D; 1;\n            &#125;                                         \n        &#125;\n        return counts;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>直接法</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\n    public:\n\t&#x2F;&#x2F; 注意遍历的时候不能剪枝，否则就会就会出现岛屿断裂成多个“单独”岛屿而计数过多\n    void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add)&#123;\n        if(x &lt; 0 || x &gt;&#x3D; N || y &lt; 0 || y &gt;&#x3D; M || grid[x][y] &#x3D;&#x3D; 1) return;\n        if(x &#x3D;&#x3D; 0 || x &#x3D;&#x3D; N-1|| y &#x3D;&#x3D; 0 || y &#x3D;&#x3D; M-1 ) add &#x3D; 0;\n        grid[x][y] &#x3D; 1;\n        &#x2F;&#x2F; 这里的四个方向其实可以用FOR写的更优雅一些\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    &#125;\n\n    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int N &#x3D; grid.size(), M &#x3D; grid[0].size(), counts;\n        counts &#x3D; 0;\n        for(int x &#x3D; 0 ;x &lt; N;x++)&#123;\n            for(int y&#x3D;0; y &lt; M; y++ )&#123;\n                if(grid[x][y] !&#x3D; 0) continue;\n                int add &#x3D; 1;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts +&#x3D; add;\n            &#125;                                         \n        &#125;\n        return counts;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>尝试使用BFS写第二种写法~</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\t&#x2F;&#x2F; BFS\n    int findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid)&#123;\n        int dX[4] &#x3D; &#123;0, 0, -1, 1&#125;, dY[4] &#x3D; &#123;1, -1, 0, 0&#125;, nX, nY;\n        int flag &#x3D; 1;\n        queue&lt; vector&lt;int&gt; &gt; que;\n        que.push( &#123;x, y&#125;);\n        grid[x][y] &#x3D; 1;\n        while( !que.empty() )&#123;\n            vector&lt;int&gt; point &#x3D; que.front();\n            que.pop();\n            int x &#x3D; point[0], y &#x3D; point[1];\n            &#x2F;&#x2F;注意 所有的点都需要判断是否在边界上\n            if(x  &#x3D;&#x3D; 0 || x &#x3D;&#x3D; N - 1 ||y &#x3D;&#x3D; 0 || y &#x3D;&#x3D; M - 1) flag &#x3D; 0;\n            for(int i&#x3D;0;i &lt; 4; i++)&#123;\n                nX &#x3D; x + dX[i];\n                nY &#x3D; y + dY[i];\n                if(nY &gt;&#x3D; 0 &amp;&amp; nY &lt; M &amp;&amp; nX &gt;&#x3D;0 &amp;&amp; nX &lt; N &amp;&amp; grid[nX][nY] &#x3D;&#x3D; 0)&#123;                \n                    grid[nX][nY] &#x3D; 1;\n                    que.push(&#123;nX, nY&#125;);\n                    \n                &#125;\n            &#125;\n        &#125;\n        return flag;\n    &#125;\n\n    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int N &#x3D; grid.size(), M &#x3D; grid[0].size(), counts;\n        counts &#x3D; 0;\n        for(int x &#x3D; 0 ;x &lt; N;x++)&#123;\n            for(int y&#x3D;0; y &lt; M; y++ )&#123;\n                if(grid[x][y] !&#x3D; 0) continue;\n                counts +&#x3D;  findBlockOf0(x, y, N, M, grid);\n            &#125;                                         \n        &#125;\n        return counts;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>并查集</p>\n<p>改日再战</p>\n","site":{"data":{}},"abbrlink":"1WR9EZB","excerpt":"","more":"<h4 id=\"1254-Number-of-Closed-Islands\"><a href=\"#1254-Number-of-Closed-Islands\" class=\"headerlink\" title=\"1254. Number of Closed Islands\"></a><a href=\"https://leetcode-cn.com/problems/number-of-closed-islands/\">1254. Number of Closed Islands</a></h4><p>难度MD</p>\n<p><strong>思路</strong>：DFS或者并查集</p>\n<ol>\n<li>排除法：将所有接触过边界的0块排除掉，接下来统计所有的0块数量就是岛屿的数量啦~</li>\n<li>直接法：考虑成为岛屿的条件——岛屿上所有0块都不与边界相交。</li>\n</ol>\n<p>接下来只需要写DFS或者BFS就👌。</p>\n<ol>\n<li>考虑使用并查集</li>\n</ol>\n<p><strong>排除法</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\t&#x2F;&#x2F;保持和第二种写法一致，add参数实际上是多余的\n    void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add)&#123;\n        if(x &lt; 0 || x &gt;&#x3D; N || y &lt; 0 || y &gt;&#x3D; M || grid[x][y] &#x3D;&#x3D; 1) return;\n        &#x2F;&#x2F;if(grid[x][y] &#x3D;&#x3D; 1) add &#x3D; 1;\n        grid[x][y] &#x3D; 1;\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    &#125;\n\n    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int N &#x3D; grid.size(), M &#x3D; grid[0].size(), counts, add;\n        &#x2F;&#x2F;排除掉那些不是island的blocks of 0\n        for(int i&#x3D;0;i &lt; M; i++)&#123;\n            findBlockOf0(0,i, N, M, grid, counts);\n            findBlockOf0(N-1,i, N, M, grid, counts);\n        &#125;\n        for(int i&#x3D;0;i &lt; N;i++)&#123;\n            findBlockOf0(i,0,N,M, grid, counts);\n            findBlockOf0(i,M-1, N, M, grid, counts);\n        &#125;\n        &#x2F;&#x2F;接下来所有的0块都可以算作island\n        counts &#x3D; 0;\n        for(int x &#x3D; 0 ;x &lt; N;x++)&#123;\n            for(int y&#x3D;0; y &lt; M; y++ )&#123;\n                if(grid[x][y] !&#x3D; 0) continue;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts +&#x3D; 1;\n            &#125;                                         \n        &#125;\n        return counts;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>直接法</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\n    public:\n\t&#x2F;&#x2F; 注意遍历的时候不能剪枝，否则就会就会出现岛屿断裂成多个“单独”岛屿而计数过多\n    void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add)&#123;\n        if(x &lt; 0 || x &gt;&#x3D; N || y &lt; 0 || y &gt;&#x3D; M || grid[x][y] &#x3D;&#x3D; 1) return;\n        if(x &#x3D;&#x3D; 0 || x &#x3D;&#x3D; N-1|| y &#x3D;&#x3D; 0 || y &#x3D;&#x3D; M-1 ) add &#x3D; 0;\n        grid[x][y] &#x3D; 1;\n        &#x2F;&#x2F; 这里的四个方向其实可以用FOR写的更优雅一些\n        findBlockOf0(x, y+1, N, M, grid, add);\n        findBlockOf0(x, y-1, N, M, grid, add);\n        findBlockOf0(x+1, y, N, M, grid, add);\n        findBlockOf0(x-1, y, N, M, grid, add);\n        return;\n    &#125;\n\n    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int N &#x3D; grid.size(), M &#x3D; grid[0].size(), counts;\n        counts &#x3D; 0;\n        for(int x &#x3D; 0 ;x &lt; N;x++)&#123;\n            for(int y&#x3D;0; y &lt; M; y++ )&#123;\n                if(grid[x][y] !&#x3D; 0) continue;\n                int add &#x3D; 1;\n                findBlockOf0(x, y, N, M, grid, add);\n                counts +&#x3D; add;\n            &#125;                                         \n        &#125;\n        return counts;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>尝试使用BFS写第二种写法~</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n\t&#x2F;&#x2F; BFS\n    int findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid)&#123;\n        int dX[4] &#x3D; &#123;0, 0, -1, 1&#125;, dY[4] &#x3D; &#123;1, -1, 0, 0&#125;, nX, nY;\n        int flag &#x3D; 1;\n        queue&lt; vector&lt;int&gt; &gt; que;\n        que.push( &#123;x, y&#125;);\n        grid[x][y] &#x3D; 1;\n        while( !que.empty() )&#123;\n            vector&lt;int&gt; point &#x3D; que.front();\n            que.pop();\n            int x &#x3D; point[0], y &#x3D; point[1];\n            &#x2F;&#x2F;注意 所有的点都需要判断是否在边界上\n            if(x  &#x3D;&#x3D; 0 || x &#x3D;&#x3D; N - 1 ||y &#x3D;&#x3D; 0 || y &#x3D;&#x3D; M - 1) flag &#x3D; 0;\n            for(int i&#x3D;0;i &lt; 4; i++)&#123;\n                nX &#x3D; x + dX[i];\n                nY &#x3D; y + dY[i];\n                if(nY &gt;&#x3D; 0 &amp;&amp; nY &lt; M &amp;&amp; nX &gt;&#x3D;0 &amp;&amp; nX &lt; N &amp;&amp; grid[nX][nY] &#x3D;&#x3D; 0)&#123;                \n                    grid[nX][nY] &#x3D; 1;\n                    que.push(&#123;nX, nY&#125;);\n                    \n                &#125;\n            &#125;\n        &#125;\n        return flag;\n    &#125;\n\n    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;\n        int N &#x3D; grid.size(), M &#x3D; grid[0].size(), counts;\n        counts &#x3D; 0;\n        for(int x &#x3D; 0 ;x &lt; N;x++)&#123;\n            for(int y&#x3D;0; y &lt; M; y++ )&#123;\n                if(grid[x][y] !&#x3D; 0) continue;\n                counts +&#x3D;  findBlockOf0(x, y, N, M, grid);\n            &#125;                                         \n        &#125;\n        return counts;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>并查集</p>\n<p>改日再战</p>"},{"title":"15 3sum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:15:37.000Z","_content":"\n<!-- more -->\n\n## 思路：\n\n- 简单的说，先有序化，再二重循环遍历前两个指针，第三个指针采用二分法即可。注意跳过重复值\n\n- 更巧妙的解法——双指针解法。先有序化，遍历第一个数字的同时，采用双指针从两边逼近结果。\n\n  > 实际上这是对数组有序的利用。\n\n\n\n**二重循环 + 二分**\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int len = nums.size();\n        vector< vector<int> > res;\n        sort(nums.begin(), nums.end());\n        // for(int i = 0;i < len; i++)\n        //     printf(\"%d\", nums[i]);\n        for(int i=0; i < len - 2; i++){\n                //排除重复结果\n                if(i!=0 && nums[i-1] == nums[i]) continue;\n            for(int j=i + 1; j < len - 1; j++){\n                //排除重复结果\n                if(j!=i+1 && nums[j] == nums[j-1]) continue;\n                int ld = j + 1, rd = len - 1, mid;\n                while(ld < rd){\n                    mid = (ld + rd ) / 2;\n                    if( nums[mid] + nums[i] + nums[j] >= 0)\n                        rd = mid;\n                    else ld = mid + 1; // 注意这里向上二分的时候， mid没有变动，同时循环可能结束。导致了mid的值可能在某种情况下雨rdld不同 ，所以循环结束最好选ld或者rd\n                } \n                // printf(\"%d   \", mid);\n                if(nums[rd] + nums[i] + nums[j] == 0){\n                    res.push_back({nums[i], nums[j], nums[rd]});\n                }\n                \n            }\n        }\n        return res;\n    }\n};\n```\n\n**双指针法**\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int len = nums.size();\n        vector< vector<int> > res;\n        sort(nums.begin(), nums.end());\n        for(int i=0;i < len - 2; i++){\n            // 排除重复结果\n            if(i !=0 && nums[i] == nums[i-1]) continue;\n            int j = i + 1, k = len - 1;\n            while(j < k){\n                int sum = nums[i] + nums[k] + nums[j];\n                // 排除重复结果\n                if(j != i + 1 && nums[j] == nums[j-1]){\n                    j++;\n                    continue;\n\n                }\n                if(k != len -1 && nums[k] == nums[k+1]){\n                    k--;\n                    continue;\n                }\n                if(sum > 0) k--;\n                else if(sum < 0) j++;\n                else{\n                    res.push_back({nums[i], nums[j], nums[k]});\n                    j++, k--;\n                }\n            }\n\n        }\n        return res;\n    }\n};\n```\n\n\\#[二分](http://blog.come2rss.xyz/tags/二分/)[TWO POINTERS](http://blog.come2rss.xyz/tags/Two-pointers/)","source":"_posts/刷题/其他/15-3sum.md","raw":"---\ntitle: 15 3sum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 14:15:37\n---\n\n<!-- more -->\n\n## 思路：\n\n- 简单的说，先有序化，再二重循环遍历前两个指针，第三个指针采用二分法即可。注意跳过重复值\n\n- 更巧妙的解法——双指针解法。先有序化，遍历第一个数字的同时，采用双指针从两边逼近结果。\n\n  > 实际上这是对数组有序的利用。\n\n\n\n**二重循环 + 二分**\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int len = nums.size();\n        vector< vector<int> > res;\n        sort(nums.begin(), nums.end());\n        // for(int i = 0;i < len; i++)\n        //     printf(\"%d\", nums[i]);\n        for(int i=0; i < len - 2; i++){\n                //排除重复结果\n                if(i!=0 && nums[i-1] == nums[i]) continue;\n            for(int j=i + 1; j < len - 1; j++){\n                //排除重复结果\n                if(j!=i+1 && nums[j] == nums[j-1]) continue;\n                int ld = j + 1, rd = len - 1, mid;\n                while(ld < rd){\n                    mid = (ld + rd ) / 2;\n                    if( nums[mid] + nums[i] + nums[j] >= 0)\n                        rd = mid;\n                    else ld = mid + 1; // 注意这里向上二分的时候， mid没有变动，同时循环可能结束。导致了mid的值可能在某种情况下雨rdld不同 ，所以循环结束最好选ld或者rd\n                } \n                // printf(\"%d   \", mid);\n                if(nums[rd] + nums[i] + nums[j] == 0){\n                    res.push_back({nums[i], nums[j], nums[rd]});\n                }\n                \n            }\n        }\n        return res;\n    }\n};\n```\n\n**双指针法**\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int len = nums.size();\n        vector< vector<int> > res;\n        sort(nums.begin(), nums.end());\n        for(int i=0;i < len - 2; i++){\n            // 排除重复结果\n            if(i !=0 && nums[i] == nums[i-1]) continue;\n            int j = i + 1, k = len - 1;\n            while(j < k){\n                int sum = nums[i] + nums[k] + nums[j];\n                // 排除重复结果\n                if(j != i + 1 && nums[j] == nums[j-1]){\n                    j++;\n                    continue;\n\n                }\n                if(k != len -1 && nums[k] == nums[k+1]){\n                    k--;\n                    continue;\n                }\n                if(sum > 0) k--;\n                else if(sum < 0) j++;\n                else{\n                    res.push_back({nums[i], nums[j], nums[k]});\n                    j++, k--;\n                }\n            }\n\n        }\n        return res;\n    }\n};\n```\n\n\\#[二分](http://blog.come2rss.xyz/tags/二分/)[TWO POINTERS](http://blog.come2rss.xyz/tags/Two-pointers/)","slug":"刷题/其他/15-3sum","published":1,"updated":"2021-01-28T14:19:48.019Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4b001ol5uo910l5hv4","content":"<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ul>\n<li><p>简单的说，先有序化，再二重循环遍历前两个指针，第三个指针采用二分法即可。注意跳过重复值</p>\n</li>\n<li><p>更巧妙的解法——双指针解法。先有序化，遍历第一个数字的同时，采用双指针从两边逼近结果。</p>\n<blockquote>\n<p>实际上这是对数组有序的利用。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>二重循环 + 二分</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        int len &#x3D; nums.size();\n        vector&lt; vector&lt;int&gt; &gt; res;\n        sort(nums.begin(), nums.end());\n        &#x2F;&#x2F; for(int i &#x3D; 0;i &lt; len; i++)\n        &#x2F;&#x2F;     printf(&quot;%d&quot;, nums[i]);\n        for(int i&#x3D;0; i &lt; len - 2; i++)&#123;\n                &#x2F;&#x2F;排除重复结果\n                if(i!&#x3D;0 &amp;&amp; nums[i-1] &#x3D;&#x3D; nums[i]) continue;\n            for(int j&#x3D;i + 1; j &lt; len - 1; j++)&#123;\n                &#x2F;&#x2F;排除重复结果\n                if(j!&#x3D;i+1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j-1]) continue;\n                int ld &#x3D; j + 1, rd &#x3D; len - 1, mid;\n                while(ld &lt; rd)&#123;\n                    mid &#x3D; (ld + rd ) &#x2F; 2;\n                    if( nums[mid] + nums[i] + nums[j] &gt;&#x3D; 0)\n                        rd &#x3D; mid;\n                    else ld &#x3D; mid + 1; &#x2F;&#x2F; 注意这里向上二分的时候， mid没有变动，同时循环可能结束。导致了mid的值可能在某种情况下雨rdld不同 ，所以循环结束最好选ld或者rd\n                &#125; \n                &#x2F;&#x2F; printf(&quot;%d   &quot;, mid);\n                if(nums[rd] + nums[i] + nums[j] &#x3D;&#x3D; 0)&#123;\n                    res.push_back(&#123;nums[i], nums[j], nums[rd]&#125;);\n                &#125;\n                \n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>双指针法</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        int len &#x3D; nums.size();\n        vector&lt; vector&lt;int&gt; &gt; res;\n        sort(nums.begin(), nums.end());\n        for(int i&#x3D;0;i &lt; len - 2; i++)&#123;\n            &#x2F;&#x2F; 排除重复结果\n            if(i !&#x3D;0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1]) continue;\n            int j &#x3D; i + 1, k &#x3D; len - 1;\n            while(j &lt; k)&#123;\n                int sum &#x3D; nums[i] + nums[k] + nums[j];\n                &#x2F;&#x2F; 排除重复结果\n                if(j !&#x3D; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j-1])&#123;\n                    j++;\n                    continue;\n\n                &#125;\n                if(k !&#x3D; len -1 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k+1])&#123;\n                    k--;\n                    continue;\n                &#125;\n                if(sum &gt; 0) k--;\n                else if(sum &lt; 0) j++;\n                else&#123;\n                    res.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n                    j++, k--;\n                &#125;\n            &#125;\n\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>#<a href=\"http://blog.come2rss.xyz/tags/%E4%BA%8C%E5%88%86/\">二分</a><a href=\"http://blog.come2rss.xyz/tags/Two-pointers/\">TWO POINTERS</a></p>\n","site":{"data":{}},"abbrlink":"39PSPCJ","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ul>\n<li><p>简单的说，先有序化，再二重循环遍历前两个指针，第三个指针采用二分法即可。注意跳过重复值</p>\n</li>\n<li><p>更巧妙的解法——双指针解法。先有序化，遍历第一个数字的同时，采用双指针从两边逼近结果。</p>\n<blockquote>\n<p>实际上这是对数组有序的利用。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>二重循环 + 二分</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        int len &#x3D; nums.size();\n        vector&lt; vector&lt;int&gt; &gt; res;\n        sort(nums.begin(), nums.end());\n        &#x2F;&#x2F; for(int i &#x3D; 0;i &lt; len; i++)\n        &#x2F;&#x2F;     printf(&quot;%d&quot;, nums[i]);\n        for(int i&#x3D;0; i &lt; len - 2; i++)&#123;\n                &#x2F;&#x2F;排除重复结果\n                if(i!&#x3D;0 &amp;&amp; nums[i-1] &#x3D;&#x3D; nums[i]) continue;\n            for(int j&#x3D;i + 1; j &lt; len - 1; j++)&#123;\n                &#x2F;&#x2F;排除重复结果\n                if(j!&#x3D;i+1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j-1]) continue;\n                int ld &#x3D; j + 1, rd &#x3D; len - 1, mid;\n                while(ld &lt; rd)&#123;\n                    mid &#x3D; (ld + rd ) &#x2F; 2;\n                    if( nums[mid] + nums[i] + nums[j] &gt;&#x3D; 0)\n                        rd &#x3D; mid;\n                    else ld &#x3D; mid + 1; &#x2F;&#x2F; 注意这里向上二分的时候， mid没有变动，同时循环可能结束。导致了mid的值可能在某种情况下雨rdld不同 ，所以循环结束最好选ld或者rd\n                &#125; \n                &#x2F;&#x2F; printf(&quot;%d   &quot;, mid);\n                if(nums[rd] + nums[i] + nums[j] &#x3D;&#x3D; 0)&#123;\n                    res.push_back(&#123;nums[i], nums[j], nums[rd]&#125;);\n                &#125;\n                \n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>双指针法</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        int len &#x3D; nums.size();\n        vector&lt; vector&lt;int&gt; &gt; res;\n        sort(nums.begin(), nums.end());\n        for(int i&#x3D;0;i &lt; len - 2; i++)&#123;\n            &#x2F;&#x2F; 排除重复结果\n            if(i !&#x3D;0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i-1]) continue;\n            int j &#x3D; i + 1, k &#x3D; len - 1;\n            while(j &lt; k)&#123;\n                int sum &#x3D; nums[i] + nums[k] + nums[j];\n                &#x2F;&#x2F; 排除重复结果\n                if(j !&#x3D; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j-1])&#123;\n                    j++;\n                    continue;\n\n                &#125;\n                if(k !&#x3D; len -1 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k+1])&#123;\n                    k--;\n                    continue;\n                &#125;\n                if(sum &gt; 0) k--;\n                else if(sum &lt; 0) j++;\n                else&#123;\n                    res.push_back(&#123;nums[i], nums[j], nums[k]&#125;);\n                    j++, k--;\n                &#125;\n            &#125;\n\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>#<a href=\"http://blog.come2rss.xyz/tags/%E4%BA%8C%E5%88%86/\">二分</a><a href=\"http://blog.come2rss.xyz/tags/Two-pointers/\">TWO POINTERS</a></p>"},{"title":"240. Search a 2D Matrix II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-22T03:31:54.000Z","_content":"\n\n\n\n## [240. Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n\n\n\n## 思路：\n\n由于matrix在行和列上的递增， 在左下角和右上角有特殊的性质。在左下角有，`A[i][j]`比上面的数字都打， 比右边的数字都小。所以可以比较`target`和`A[i][j]`数字大小来排除，上面一列或者右边一行的所有数字。递归的下去可以搜索到应有的数字。\n\n如果没有就会出界。\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int x, y, n = matrix.size();\n        x = n - 1; \n        y = 0;\n        while(x != 0 || y != n -1){\n            if(target == matrix[x][y]) return true;\n            else if(target > matrix[x][y]) y++;\n            else if(target < matrix[x][y]) x--;\n            if(x < 0 || y >= n) return false;\n        }\n        return false;\n    }\n};\n```","source":"_posts/刷题/其他/240-Search-a-2D-Matrix-II.md","raw":"---\ntitle: 240. Search a 2D Matrix II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-22 11:31:54\n---\n\n\n\n\n## [240. Search a 2D Matrix II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n\n\n\n## 思路：\n\n由于matrix在行和列上的递增， 在左下角和右上角有特殊的性质。在左下角有，`A[i][j]`比上面的数字都打， 比右边的数字都小。所以可以比较`target`和`A[i][j]`数字大小来排除，上面一列或者右边一行的所有数字。递归的下去可以搜索到应有的数字。\n\n如果没有就会出界。\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int x, y, n = matrix.size();\n        x = n - 1; \n        y = 0;\n        while(x != 0 || y != n -1){\n            if(target == matrix[x][y]) return true;\n            else if(target > matrix[x][y]) y++;\n            else if(target < matrix[x][y]) x--;\n            if(x < 0 || y >= n) return false;\n        }\n        return false;\n    }\n};\n```","slug":"刷题/其他/240-Search-a-2D-Matrix-II","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4c001pl5uoa4cc3ffz","content":"<h2 id=\"240-Search-a-2D-Matrix-II\"><a href=\"#240-Search-a-2D-Matrix-II\" class=\"headerlink\" title=\"240. Search a 2D Matrix II\"></a><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\">240. Search a 2D Matrix II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>由于matrix在行和列上的递增， 在左下角和右上角有特殊的性质。在左下角有，<code>A[i][j]</code>比上面的数字都打， 比右边的数字都小。所以可以比较<code>target</code>和<code>A[i][j]</code>数字大小来排除，上面一列或者右边一行的所有数字。递归的下去可以搜索到应有的数字。</p>\n<p>如果没有就会出界。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;\n        int x, y, n &#x3D; matrix.size();\n        x &#x3D; n - 1; \n        y &#x3D; 0;\n        while(x !&#x3D; 0 || y !&#x3D; n -1)&#123;\n            if(target &#x3D;&#x3D; matrix[x][y]) return true;\n            else if(target &gt; matrix[x][y]) y++;\n            else if(target &lt; matrix[x][y]) x--;\n            if(x &lt; 0 || y &gt;&#x3D; n) return false;\n        &#125;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"5C41EE","excerpt":"<h2 id=\"240-Search-a-2D-Matrix-II\"><a href=\"#240-Search-a-2D-Matrix-II\" class=\"headerlink\" title=\"240. Search a 2D Matrix II\"></a><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\">240. Search a 2D Matrix II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>由于matrix在行和列上的递增， 在左下角和右上角有特殊的性质。在左下角有，<code>A[i][j]</code>比上面的数字都打， 比右边的数字都小。所以可以比较<code>target</code>和<code>A[i][j]</code>数字大小来排除，上面一列或者右边一行的所有数字。递归的下去可以搜索到应有的数字。</p>\n<p>如果没有就会出界。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;\n        int x, y, n &#x3D; matrix.size();\n        x &#x3D; n - 1; \n        y &#x3D; 0;\n        while(x !&#x3D; 0 || y !&#x3D; n -1)&#123;\n            if(target &#x3D;&#x3D; matrix[x][y]) return true;\n            else if(target &gt; matrix[x][y]) y++;\n            else if(target &lt; matrix[x][y]) x--;\n            if(x &lt; 0 || y &gt;&#x3D; n) return false;\n        &#125;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"303. Range Sum Query - Immutable","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-29T03:46:52.000Z","_content":"\n\n\n\n\n\n## [303. Range Sum Query - Immutable](https://leetcode-cn.com/problems/range-sum-query-immutable/)\n\n\n\n## 思路：\n\n前缀和<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n\n```c++\nclass NumArray {\n    vector<int> nums;\npublic:\n    \n    NumArray(vector<int>& _nums) : nums(_nums) {\n        nums.insert(nums.begin(), 0);\n        for(int i = 1; i < nums.size(); ++i) nums[i] += nums[i - 1];\n    }\n    \n    int sumRange(int i, int j) {\n        return nums[j + 1] - nums[i];\n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * int param_1 = obj->sumRange(i,j);\n */\n```","source":"_posts/刷题/其他/303-Range-Sum-Query-Immutable.md","raw":"---\ntitle: 303. Range Sum Query - Immutable\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-01-29 11:46:52\ntags:\ncategories:\n---\n\n\n\n\n\n\n## [303. Range Sum Query - Immutable](https://leetcode-cn.com/problems/range-sum-query-immutable/)\n\n\n\n## 思路：\n\n前缀和<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n\n```c++\nclass NumArray {\n    vector<int> nums;\npublic:\n    \n    NumArray(vector<int>& _nums) : nums(_nums) {\n        nums.insert(nums.begin(), 0);\n        for(int i = 1; i < nums.size(); ++i) nums[i] += nums[i - 1];\n    }\n    \n    int sumRange(int i, int j) {\n        return nums[j + 1] - nums[i];\n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * int param_1 = obj->sumRange(i,j);\n */\n```","slug":"刷题/其他/303-Range-Sum-Query-Immutable","published":1,"updated":"2021-01-29T03:48:00.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4d001ql5uo84t040et","content":"<h2 id=\"303-Range-Sum-Query-Immutable\"><a href=\"#303-Range-Sum-Query-Immutable\" class=\"headerlink\" title=\"303. Range Sum Query - Immutable\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\">303. Range Sum Query - Immutable</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>前缀和<span id=\"more\"></span></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class NumArray &#123;\n    vector&lt;int&gt; nums;\npublic:\n    \n    NumArray(vector&lt;int&gt;&amp; _nums) : nums(_nums) &#123;\n        nums.insert(nums.begin(), 0);\n        for(int i &#x3D; 1; i &lt; nums.size(); ++i) nums[i] +&#x3D; nums[i - 1];\n    &#125;\n    \n    int sumRange(int i, int j) &#123;\n        return nums[j + 1] - nums[i];\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj &#x3D; new NumArray(nums);\n * int param_1 &#x3D; obj-&gt;sumRange(i,j);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2227CQG","excerpt":"<h2 id=\"303-Range-Sum-Query-Immutable\"><a href=\"#303-Range-Sum-Query-Immutable\" class=\"headerlink\" title=\"303. Range Sum Query - Immutable\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\">303. Range Sum Query - Immutable</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>前缀和","more":"</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class NumArray &#123;\n    vector&lt;int&gt; nums;\npublic:\n    \n    NumArray(vector&lt;int&gt;&amp; _nums) : nums(_nums) &#123;\n        nums.insert(nums.begin(), 0);\n        for(int i &#x3D; 1; i &lt; nums.size(); ++i) nums[i] +&#x3D; nums[i - 1];\n    &#125;\n    \n    int sumRange(int i, int j) &#123;\n        return nums[j + 1] - nums[i];\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj &#x3D; new NumArray(nums);\n * int param_1 &#x3D; obj-&gt;sumRange(i,j);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"304. Range Sum Query 2D - Immutable","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-29T03:47:00.000Z","_content":"\n\n\n\n\n## [304. Range Sum Query 2D - Immutable](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)\n\n\n\n## 思路：\n\n二维前缀和，不仅是计算二维矩阵之和的过程可以用二维矩阵组合起来，而且二维前缀和的计算过程也可以用之前计算的矩阵简化计算。\n\n$o(n^2)$\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\n\nclass NumMatrix {\n    vector<vector<int>> summax;\npublic:\n    NumMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size() + 1;\n        if(n == 1) return;\n        int m = matrix[0].size() + 1;\n        summax.resize(n);\n        summax[0].resize(m);\n        \n        for(int i = 1; i < n; ++i){\n            summax[i].resize(m + 1);\n            for(int j = 1; j < m; ++j){\n                summax[i][j] = matrix[i - 1][j - 1] + summax[i - 1][j] + summax[i][j - 1] - summax[i - 1][j - 1];   \n                // cout << summax[i][j] << ' ';\n            }\n            // cout << endl;\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {                \n        return summax[row2 + 1][col2 + 1] -  summax[row2 + 1][col1] -  summax[row1][col2 + 1] +  summax[row1][col1];\n        // return 0;\n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj = new NumMatrix(matrix);\n * int param_1 = obj->sumRegion(row1,col1,row2,col2);\n */\n```","source":"_posts/刷题/其他/304-Range-Sum-Query-2D-Immutable.md","raw":"---\ntitle: 304. Range Sum Query 2D - Immutable\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-01-29 11:47:00\ntags:\ncategories:\n---\n\n\n\n\n\n## [304. Range Sum Query 2D - Immutable](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)\n\n\n\n## 思路：\n\n二维前缀和，不仅是计算二维矩阵之和的过程可以用二维矩阵组合起来，而且二维前缀和的计算过程也可以用之前计算的矩阵简化计算。\n\n$o(n^2)$\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\n\nclass NumMatrix {\n    vector<vector<int>> summax;\npublic:\n    NumMatrix(vector<vector<int>>& matrix) {\n        int n = matrix.size() + 1;\n        if(n == 1) return;\n        int m = matrix[0].size() + 1;\n        summax.resize(n);\n        summax[0].resize(m);\n        \n        for(int i = 1; i < n; ++i){\n            summax[i].resize(m + 1);\n            for(int j = 1; j < m; ++j){\n                summax[i][j] = matrix[i - 1][j - 1] + summax[i - 1][j] + summax[i][j - 1] - summax[i - 1][j - 1];   \n                // cout << summax[i][j] << ' ';\n            }\n            // cout << endl;\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {                \n        return summax[row2 + 1][col2 + 1] -  summax[row2 + 1][col1] -  summax[row1][col2 + 1] +  summax[row1][col1];\n        // return 0;\n    }\n};\n\n/**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj = new NumMatrix(matrix);\n * int param_1 = obj->sumRegion(row1,col1,row2,col2);\n */\n```","slug":"刷题/其他/304-Range-Sum-Query-2D-Immutable","published":1,"updated":"2021-01-29T03:47:55.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4f001rl5uocd6jhiy6","content":"<h2 id=\"304-Range-Sum-Query-2D-Immutable\"><a href=\"#304-Range-Sum-Query-2D-Immutable\" class=\"headerlink\" title=\"304. Range Sum Query 2D - Immutable\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">304. Range Sum Query 2D - Immutable</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二维前缀和，不仅是计算二维矩阵之和的过程可以用二维矩阵组合起来，而且二维前缀和的计算过程也可以用之前计算的矩阵简化计算。</p>\n<p>$o(n^2)$</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass NumMatrix &#123;\n    vector&lt;vector&lt;int&gt;&gt; summax;\npublic:\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size() + 1;\n        if(n &#x3D;&#x3D; 1) return;\n        int m &#x3D; matrix[0].size() + 1;\n        summax.resize(n);\n        summax[0].resize(m);\n        \n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            summax[i].resize(m + 1);\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                summax[i][j] &#x3D; matrix[i - 1][j - 1] + summax[i - 1][j] + summax[i][j - 1] - summax[i - 1][j - 1];   \n                &#x2F;&#x2F; cout &lt;&lt; summax[i][j] &lt;&lt; &#39; &#39;;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n        &#125;\n    &#125;\n    \n    int sumRegion(int row1, int col1, int row2, int col2) &#123;                \n        return summax[row2 + 1][col2 + 1] -  summax[row2 + 1][col1] -  summax[row1][col2 + 1] +  summax[row1][col1];\n        &#x2F;&#x2F; return 0;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj &#x3D; new NumMatrix(matrix);\n * int param_1 &#x3D; obj-&gt;sumRegion(row1,col1,row2,col2);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1DE9EJM","excerpt":"<h2 id=\"304-Range-Sum-Query-2D-Immutable\"><a href=\"#304-Range-Sum-Query-2D-Immutable\" class=\"headerlink\" title=\"304. Range Sum Query 2D - Immutable\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">304. Range Sum Query 2D - Immutable</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二维前缀和，不仅是计算二维矩阵之和的过程可以用二维矩阵组合起来，而且二维前缀和的计算过程也可以用之前计算的矩阵简化计算。</p>\n<p>$o(n^2)$</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass NumMatrix &#123;\n    vector&lt;vector&lt;int&gt;&gt; summax;\npublic:\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int n &#x3D; matrix.size() + 1;\n        if(n &#x3D;&#x3D; 1) return;\n        int m &#x3D; matrix[0].size() + 1;\n        summax.resize(n);\n        summax[0].resize(m);\n        \n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            summax[i].resize(m + 1);\n            for(int j &#x3D; 1; j &lt; m; ++j)&#123;\n                summax[i][j] &#x3D; matrix[i - 1][j - 1] + summax[i - 1][j] + summax[i][j - 1] - summax[i - 1][j - 1];   \n                &#x2F;&#x2F; cout &lt;&lt; summax[i][j] &lt;&lt; &#39; &#39;;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n        &#125;\n    &#125;\n    \n    int sumRegion(int row1, int col1, int row2, int col2) &#123;                \n        return summax[row2 + 1][col2 + 1] -  summax[row2 + 1][col1] -  summax[row1][col2 + 1] +  summax[row1][col1];\n        &#x2F;&#x2F; return 0;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NumMatrix object will be instantiated and called as such:\n * NumMatrix* obj &#x3D; new NumMatrix(matrix);\n * int param_1 &#x3D; obj-&gt;sumRegion(row1,col1,row2,col2);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"326. Power of Three","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-08T02:16:01.000Z","_content":"\n\n\n\n\n\n\n\n## [326. Power of Three](https://leetcode-cn.com/problems/power-of-three/)\n\n直接上代码：\n\n<!-- more -->\n\n思路\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if(n == 1) return true;\n        if(n < 3) return false;\n        int newn;\n        while(n >= 3){\n            newn = n / 3;\n            if(newn * 3 != n) return false;\n            n = newn;\n        }\n        return n == 1;\n    }\n};\n```\n\n不断整除判断余数是否为零\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {        \n        if(n < 1) return false;        \n        while(n % 3 == 0){\n            n /= 3;\n        }\n        return n == 1;\n    }\n};\n```\n\n3的k+1次幂必定可以被3的k次幂整除\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {        \n        // int  maxn = pow(3,floor(log(INT_MAX) / log(3))); //1162261467\n        // cout << maxn << endl;\n        return n > 0 && 1162261467 % n == 0;\n    }\n};\n```\n\n\n\n3进制算法：数1\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {        \n        int ct = 0, oldn = n;\n        while(n){\n            ct += n % 3;\n            if(ct > 1) return false;\n            n /= 3;\n        }\n        return oldn > 0;\n    }\n};\n```","source":"_posts/刷题/其他/326-Power-of-Three.md","raw":"---\ntitle: 326. Power of Three\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2021-01-08 10:16:01\ntags:\n---\n\n\n\n\n\n\n\n\n## [326. Power of Three](https://leetcode-cn.com/problems/power-of-three/)\n\n直接上代码：\n\n<!-- more -->\n\n思路\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if(n == 1) return true;\n        if(n < 3) return false;\n        int newn;\n        while(n >= 3){\n            newn = n / 3;\n            if(newn * 3 != n) return false;\n            n = newn;\n        }\n        return n == 1;\n    }\n};\n```\n\n不断整除判断余数是否为零\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {        \n        if(n < 1) return false;        \n        while(n % 3 == 0){\n            n /= 3;\n        }\n        return n == 1;\n    }\n};\n```\n\n3的k+1次幂必定可以被3的k次幂整除\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {        \n        // int  maxn = pow(3,floor(log(INT_MAX) / log(3))); //1162261467\n        // cout << maxn << endl;\n        return n > 0 && 1162261467 % n == 0;\n    }\n};\n```\n\n\n\n3进制算法：数1\n\n```c++\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {        \n        int ct = 0, oldn = n;\n        while(n){\n            ct += n % 3;\n            if(ct > 1) return false;\n            n /= 3;\n        }\n        return oldn > 0;\n    }\n};\n```","slug":"刷题/其他/326-Power-of-Three","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4g001sl5uocnp6d9ro","content":"<h2 id=\"326-Power-of-Three\"><a href=\"#326-Power-of-Three\" class=\"headerlink\" title=\"326. Power of Three\"></a><a href=\"https://leetcode-cn.com/problems/power-of-three/\">326. Power of Three</a></h2><p>直接上代码：</p>\n<span id=\"more\"></span>\n\n<p>思路</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        if(n &#x3D;&#x3D; 1) return true;\n        if(n &lt; 3) return false;\n        int newn;\n        while(n &gt;&#x3D; 3)&#123;\n            newn &#x3D; n &#x2F; 3;\n            if(newn * 3 !&#x3D; n) return false;\n            n &#x3D; newn;\n        &#125;\n        return n &#x3D;&#x3D; 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>不断整除判断余数是否为零</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;        \n        if(n &lt; 1) return false;        \n        while(n % 3 &#x3D;&#x3D; 0)&#123;\n            n &#x2F;&#x3D; 3;\n        &#125;\n        return n &#x3D;&#x3D; 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3的k+1次幂必定可以被3的k次幂整除</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;        \n        &#x2F;&#x2F; int  maxn &#x3D; pow(3,floor(log(INT_MAX) &#x2F; log(3))); &#x2F;&#x2F;1162261467\n        &#x2F;&#x2F; cout &lt;&lt; maxn &lt;&lt; endl;\n        return n &gt; 0 &amp;&amp; 1162261467 % n &#x3D;&#x3D; 0;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>3进制算法：数1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;        \n        int ct &#x3D; 0, oldn &#x3D; n;\n        while(n)&#123;\n            ct +&#x3D; n % 3;\n            if(ct &gt; 1) return false;\n            n &#x2F;&#x3D; 3;\n        &#125;\n        return oldn &gt; 0;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2ST9BAQ","excerpt":"<h2 id=\"326-Power-of-Three\"><a href=\"#326-Power-of-Three\" class=\"headerlink\" title=\"326. Power of Three\"></a><a href=\"https://leetcode-cn.com/problems/power-of-three/\">326. Power of Three</a></h2><p>直接上代码：</p>","more":"<p>思路</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;\n        if(n &#x3D;&#x3D; 1) return true;\n        if(n &lt; 3) return false;\n        int newn;\n        while(n &gt;&#x3D; 3)&#123;\n            newn &#x3D; n &#x2F; 3;\n            if(newn * 3 !&#x3D; n) return false;\n            n &#x3D; newn;\n        &#125;\n        return n &#x3D;&#x3D; 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>不断整除判断余数是否为零</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;        \n        if(n &lt; 1) return false;        \n        while(n % 3 &#x3D;&#x3D; 0)&#123;\n            n &#x2F;&#x3D; 3;\n        &#125;\n        return n &#x3D;&#x3D; 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>3的k+1次幂必定可以被3的k次幂整除</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;        \n        &#x2F;&#x2F; int  maxn &#x3D; pow(3,floor(log(INT_MAX) &#x2F; log(3))); &#x2F;&#x2F;1162261467\n        &#x2F;&#x2F; cout &lt;&lt; maxn &lt;&lt; endl;\n        return n &gt; 0 &amp;&amp; 1162261467 % n &#x3D;&#x3D; 0;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>3进制算法：数1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isPowerOfThree(int n) &#123;        \n        int ct &#x3D; 0, oldn &#x3D; n;\n        while(n)&#123;\n            ct +&#x3D; n % 3;\n            if(ct &gt; 1) return false;\n            n &#x2F;&#x3D; 3;\n        &#125;\n        return oldn &gt; 0;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"341. Flatten Nested List Iterator","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-09-25T01:14:36.000Z","_content":"\n\n\n\n\n## [341. Flatten Nested List Iterator](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)\n\n<!-- more -->\n\n## 思路：\n\n缓存lazy法\n\nstack存储遍历空间法\n\n\n\n## 代码：\n\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\npublic:\n    int pos = 0;\n    queue<int> que;\n    vector<NestedInteger> nestedList;\n    NestedIterator(vector<NestedInteger> &_nestedList) {\n        // que.clear();\n        nestedList = _nestedList;\n    }\n    \n    int next() {\n        if(hasNext()){\n            int nexti = que.front();\n            que.pop();\n            return nexti;\n        }\n        return -1;\n    }\n    \n    bool hasNext() {\n        if(que.empty()){\n            if(nestedList.size() == pos){\n                return false;\n            }\n            //不要忘记pos+\n            while(pos != nestedList.size() && que.empty()){\n                getInt2que(nestedList[pos++]);\n            }\n            \n        }\n        if(que.empty()) return false;\n        else return true;\n    }\n\n    void getInt2que(NestedInteger ni){\n        if(ni.isInteger()){\n              que.push(ni.getInteger());\n        }else{\n            vector<NestedInteger> list = ni.getList();\n            for(auto item :list){\n                getInt2que(item);\n            }\n        }\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n\n\n不够机智的实现\n\n\n\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\n    using nestedVecIt = vector<NestedInteger>::iterator;\n    stack<pair<nestedVecIt, nestedVecIt> > nested;\npublic:\n\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        if(nestedList.size() > 0) nested.push({nestedList.begin(), nestedList.end()});\n    }\n    bool hasNext() { \n        locate();\n        return !nested.empty();        \n    }\n\n    void locate(){\n        if(nested.size() == 0) return;\n\n         while(nested.size()){  \n            auto& [itnested, itend]  = nested.top();  \n            if(itnested == itend) nested.pop();\n            else if(!itnested->isInteger()){\n                auto & veclist = itnested->getList();\n                ++itnested;\n                nested.push({veclist.begin(), veclist.end()});\n            }\n            else break;            \n        }         \n\n    }\n\n    int next() {\n        if( hasNext()){ \n            auto& [itnested, itend]  = nested.top();\n         \n            int nextv = 0;\n            if(itnested->isInteger()){\n                nextv = itnested->getInteger();\n                ++itnested;\n                return nextv;\n            }\n            else{\n                auto & nestedList = itnested->getList();\n                ++itnested; // 无论是数字还是数组都要向前遍历\n                nested.push({nestedList.begin(), nestedList.end()});\n                return next();\n            }            \n        }\n        return -1;\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n更优雅的实现\n\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\n    using nestedVecIt = vector<NestedInteger>::iterator;\n    stack<pair<nestedVecIt, nestedVecIt> > nested;\npublic:\n\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        if(nestedList.size() > 0) nested.push({nestedList.begin(), nestedList.end()});\n    }\n    bool hasNext() { \n         while(nested.size()){  \n            auto& [itnested, itend]  = nested.top();  \n            if(itnested == itend) nested.pop();\n            else if(!itnested->isInteger()){\n                auto & veclist = itnested++->getList(); // 自增后获取 nestedList                \n                nested.push({veclist.begin(), veclist.end()});\n            }\n            else break;            \n        }         \n        return !nested.empty();        \n    }\n\n    // 保证调用前 指针指向的元素存在且为数字\n    int next() {\n        return nested.top().first++->getInteger();\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n","source":"_posts/刷题/其他/341-Flatten-Nested-List-Iterator.md","raw":"---\ntitle: 341. Flatten Nested List Iterator\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-09-25 09:14:36\ntags:\n---\n\n\n\n\n\n## [341. Flatten Nested List Iterator](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)\n\n<!-- more -->\n\n## 思路：\n\n缓存lazy法\n\nstack存储遍历空间法\n\n\n\n## 代码：\n\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\npublic:\n    int pos = 0;\n    queue<int> que;\n    vector<NestedInteger> nestedList;\n    NestedIterator(vector<NestedInteger> &_nestedList) {\n        // que.clear();\n        nestedList = _nestedList;\n    }\n    \n    int next() {\n        if(hasNext()){\n            int nexti = que.front();\n            que.pop();\n            return nexti;\n        }\n        return -1;\n    }\n    \n    bool hasNext() {\n        if(que.empty()){\n            if(nestedList.size() == pos){\n                return false;\n            }\n            //不要忘记pos+\n            while(pos != nestedList.size() && que.empty()){\n                getInt2que(nestedList[pos++]);\n            }\n            \n        }\n        if(que.empty()) return false;\n        else return true;\n    }\n\n    void getInt2que(NestedInteger ni){\n        if(ni.isInteger()){\n              que.push(ni.getInteger());\n        }else{\n            vector<NestedInteger> list = ni.getList();\n            for(auto item :list){\n                getInt2que(item);\n            }\n        }\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n\n\n不够机智的实现\n\n\n\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\n    using nestedVecIt = vector<NestedInteger>::iterator;\n    stack<pair<nestedVecIt, nestedVecIt> > nested;\npublic:\n\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        if(nestedList.size() > 0) nested.push({nestedList.begin(), nestedList.end()});\n    }\n    bool hasNext() { \n        locate();\n        return !nested.empty();        \n    }\n\n    void locate(){\n        if(nested.size() == 0) return;\n\n         while(nested.size()){  \n            auto& [itnested, itend]  = nested.top();  \n            if(itnested == itend) nested.pop();\n            else if(!itnested->isInteger()){\n                auto & veclist = itnested->getList();\n                ++itnested;\n                nested.push({veclist.begin(), veclist.end()});\n            }\n            else break;            \n        }         \n\n    }\n\n    int next() {\n        if( hasNext()){ \n            auto& [itnested, itend]  = nested.top();\n         \n            int nextv = 0;\n            if(itnested->isInteger()){\n                nextv = itnested->getInteger();\n                ++itnested;\n                return nextv;\n            }\n            else{\n                auto & nestedList = itnested->getList();\n                ++itnested; // 无论是数字还是数组都要向前遍历\n                nested.push({nestedList.begin(), nestedList.end()});\n                return next();\n            }            \n        }\n        return -1;\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n更优雅的实现\n\n```c++\n/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * class NestedInteger {\n *   public:\n *     // Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     // Return the single integer that this NestedInteger holds, if it holds a single integer\n *     // The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     // Return the nested list that this NestedInteger holds, if it holds a nested list\n *     // The result is undefined if this NestedInteger holds a single integer\n *     const vector<NestedInteger> &getList() const;\n * };\n */\n\nclass NestedIterator {\n    using nestedVecIt = vector<NestedInteger>::iterator;\n    stack<pair<nestedVecIt, nestedVecIt> > nested;\npublic:\n\n    NestedIterator(vector<NestedInteger> &nestedList) {\n        if(nestedList.size() > 0) nested.push({nestedList.begin(), nestedList.end()});\n    }\n    bool hasNext() { \n         while(nested.size()){  \n            auto& [itnested, itend]  = nested.top();  \n            if(itnested == itend) nested.pop();\n            else if(!itnested->isInteger()){\n                auto & veclist = itnested++->getList(); // 自增后获取 nestedList                \n                nested.push({veclist.begin(), veclist.end()});\n            }\n            else break;            \n        }         \n        return !nested.empty();        \n    }\n\n    // 保证调用前 指针指向的元素存在且为数字\n    int next() {\n        return nested.top().first++->getInteger();\n    }\n};\n\n/**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout << i.next();\n */\n```\n\n","slug":"刷题/其他/341-Flatten-Nested-List-Iterator","published":1,"updated":"2021-03-23T08:23:33.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4h001tl5uobdd76mxe","content":"<h2 id=\"341-Flatten-Nested-List-Iterator\"><a href=\"#341-Flatten-Nested-List-Iterator\" class=\"headerlink\" title=\"341. Flatten Nested List Iterator\"></a><a href=\"https://leetcode-cn.com/problems/flatten-nested-list-iterator/\">341. Flatten Nested List Iterator</a></h2><span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>缓存lazy法</p>\n<p>stack存储遍历空间法</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * &#x2F;&#x2F; This is the interface that allows for creating nested lists.\n * &#x2F;&#x2F; You should not implement it, or speculate about its implementation\n * class NestedInteger &#123;\n *   public:\n *     &#x2F;&#x2F; Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     &#x2F;&#x2F; Return the single integer that this NestedInteger holds, if it holds a single integer\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     &#x2F;&#x2F; Return the nested list that this NestedInteger holds, if it holds a nested list\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a single integer\n *     const vector&lt;NestedInteger&gt; &amp;getList() const;\n * &#125;;\n *&#x2F;\n\nclass NestedIterator &#123;\npublic:\n    int pos &#x3D; 0;\n    queue&lt;int&gt; que;\n    vector&lt;NestedInteger&gt; nestedList;\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;_nestedList) &#123;\n        &#x2F;&#x2F; que.clear();\n        nestedList &#x3D; _nestedList;\n    &#125;\n    \n    int next() &#123;\n        if(hasNext())&#123;\n            int nexti &#x3D; que.front();\n            que.pop();\n            return nexti;\n        &#125;\n        return -1;\n    &#125;\n    \n    bool hasNext() &#123;\n        if(que.empty())&#123;\n            if(nestedList.size() &#x3D;&#x3D; pos)&#123;\n                return false;\n            &#125;\n            &#x2F;&#x2F;不要忘记pos+\n            while(pos !&#x3D; nestedList.size() &amp;&amp; que.empty())&#123;\n                getInt2que(nestedList[pos++]);\n            &#125;\n            \n        &#125;\n        if(que.empty()) return false;\n        else return true;\n    &#125;\n\n    void getInt2que(NestedInteger ni)&#123;\n        if(ni.isInteger())&#123;\n              que.push(ni.getInteger());\n        &#125;else&#123;\n            vector&lt;NestedInteger&gt; list &#x3D; ni.getList();\n            for(auto item :list)&#123;\n                getInt2que(item);\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout &lt;&lt; i.next();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>不够机智的实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * &#x2F;&#x2F; This is the interface that allows for creating nested lists.\n * &#x2F;&#x2F; You should not implement it, or speculate about its implementation\n * class NestedInteger &#123;\n *   public:\n *     &#x2F;&#x2F; Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     &#x2F;&#x2F; Return the single integer that this NestedInteger holds, if it holds a single integer\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     &#x2F;&#x2F; Return the nested list that this NestedInteger holds, if it holds a nested list\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a single integer\n *     const vector&lt;NestedInteger&gt; &amp;getList() const;\n * &#125;;\n *&#x2F;\n\nclass NestedIterator &#123;\n    using nestedVecIt &#x3D; vector&lt;NestedInteger&gt;::iterator;\n    stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested;\npublic:\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        if(nestedList.size() &gt; 0) nested.push(&#123;nestedList.begin(), nestedList.end()&#125;);\n    &#125;\n    bool hasNext() &#123; \n        locate();\n        return !nested.empty();        \n    &#125;\n\n    void locate()&#123;\n        if(nested.size() &#x3D;&#x3D; 0) return;\n\n         while(nested.size())&#123;  \n            auto&amp; [itnested, itend]  &#x3D; nested.top();  \n            if(itnested &#x3D;&#x3D; itend) nested.pop();\n            else if(!itnested-&gt;isInteger())&#123;\n                auto &amp; veclist &#x3D; itnested-&gt;getList();\n                ++itnested;\n                nested.push(&#123;veclist.begin(), veclist.end()&#125;);\n            &#125;\n            else break;            \n        &#125;         \n\n    &#125;\n\n    int next() &#123;\n        if( hasNext())&#123; \n            auto&amp; [itnested, itend]  &#x3D; nested.top();\n         \n            int nextv &#x3D; 0;\n            if(itnested-&gt;isInteger())&#123;\n                nextv &#x3D; itnested-&gt;getInteger();\n                ++itnested;\n                return nextv;\n            &#125;\n            else&#123;\n                auto &amp; nestedList &#x3D; itnested-&gt;getList();\n                ++itnested; &#x2F;&#x2F; 无论是数字还是数组都要向前遍历\n                nested.push(&#123;nestedList.begin(), nestedList.end()&#125;);\n                return next();\n            &#125;            \n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout &lt;&lt; i.next();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>更优雅的实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * &#x2F;&#x2F; This is the interface that allows for creating nested lists.\n * &#x2F;&#x2F; You should not implement it, or speculate about its implementation\n * class NestedInteger &#123;\n *   public:\n *     &#x2F;&#x2F; Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     &#x2F;&#x2F; Return the single integer that this NestedInteger holds, if it holds a single integer\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     &#x2F;&#x2F; Return the nested list that this NestedInteger holds, if it holds a nested list\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a single integer\n *     const vector&lt;NestedInteger&gt; &amp;getList() const;\n * &#125;;\n *&#x2F;\n\nclass NestedIterator &#123;\n    using nestedVecIt &#x3D; vector&lt;NestedInteger&gt;::iterator;\n    stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested;\npublic:\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        if(nestedList.size() &gt; 0) nested.push(&#123;nestedList.begin(), nestedList.end()&#125;);\n    &#125;\n    bool hasNext() &#123; \n         while(nested.size())&#123;  \n            auto&amp; [itnested, itend]  &#x3D; nested.top();  \n            if(itnested &#x3D;&#x3D; itend) nested.pop();\n            else if(!itnested-&gt;isInteger())&#123;\n                auto &amp; veclist &#x3D; itnested++-&gt;getList(); &#x2F;&#x2F; 自增后获取 nestedList                \n                nested.push(&#123;veclist.begin(), veclist.end()&#125;);\n            &#125;\n            else break;            \n        &#125;         \n        return !nested.empty();        \n    &#125;\n\n    &#x2F;&#x2F; 保证调用前 指针指向的元素存在且为数字\n    int next() &#123;\n        return nested.top().first++-&gt;getInteger();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout &lt;&lt; i.next();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"30EAX7D","excerpt":"<h2 id=\"341-Flatten-Nested-List-Iterator\"><a href=\"#341-Flatten-Nested-List-Iterator\" class=\"headerlink\" title=\"341. Flatten Nested List Iterator\"></a><a href=\"https://leetcode-cn.com/problems/flatten-nested-list-iterator/\">341. Flatten Nested List Iterator</a></h2>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>缓存lazy法</p>\n<p>stack存储遍历空间法</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * &#x2F;&#x2F; This is the interface that allows for creating nested lists.\n * &#x2F;&#x2F; You should not implement it, or speculate about its implementation\n * class NestedInteger &#123;\n *   public:\n *     &#x2F;&#x2F; Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     &#x2F;&#x2F; Return the single integer that this NestedInteger holds, if it holds a single integer\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     &#x2F;&#x2F; Return the nested list that this NestedInteger holds, if it holds a nested list\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a single integer\n *     const vector&lt;NestedInteger&gt; &amp;getList() const;\n * &#125;;\n *&#x2F;\n\nclass NestedIterator &#123;\npublic:\n    int pos &#x3D; 0;\n    queue&lt;int&gt; que;\n    vector&lt;NestedInteger&gt; nestedList;\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;_nestedList) &#123;\n        &#x2F;&#x2F; que.clear();\n        nestedList &#x3D; _nestedList;\n    &#125;\n    \n    int next() &#123;\n        if(hasNext())&#123;\n            int nexti &#x3D; que.front();\n            que.pop();\n            return nexti;\n        &#125;\n        return -1;\n    &#125;\n    \n    bool hasNext() &#123;\n        if(que.empty())&#123;\n            if(nestedList.size() &#x3D;&#x3D; pos)&#123;\n                return false;\n            &#125;\n            &#x2F;&#x2F;不要忘记pos+\n            while(pos !&#x3D; nestedList.size() &amp;&amp; que.empty())&#123;\n                getInt2que(nestedList[pos++]);\n            &#125;\n            \n        &#125;\n        if(que.empty()) return false;\n        else return true;\n    &#125;\n\n    void getInt2que(NestedInteger ni)&#123;\n        if(ni.isInteger())&#123;\n              que.push(ni.getInteger());\n        &#125;else&#123;\n            vector&lt;NestedInteger&gt; list &#x3D; ni.getList();\n            for(auto item :list)&#123;\n                getInt2que(item);\n            &#125;\n        &#125;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout &lt;&lt; i.next();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>不够机智的实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * &#x2F;&#x2F; This is the interface that allows for creating nested lists.\n * &#x2F;&#x2F; You should not implement it, or speculate about its implementation\n * class NestedInteger &#123;\n *   public:\n *     &#x2F;&#x2F; Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     &#x2F;&#x2F; Return the single integer that this NestedInteger holds, if it holds a single integer\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     &#x2F;&#x2F; Return the nested list that this NestedInteger holds, if it holds a nested list\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a single integer\n *     const vector&lt;NestedInteger&gt; &amp;getList() const;\n * &#125;;\n *&#x2F;\n\nclass NestedIterator &#123;\n    using nestedVecIt &#x3D; vector&lt;NestedInteger&gt;::iterator;\n    stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested;\npublic:\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        if(nestedList.size() &gt; 0) nested.push(&#123;nestedList.begin(), nestedList.end()&#125;);\n    &#125;\n    bool hasNext() &#123; \n        locate();\n        return !nested.empty();        \n    &#125;\n\n    void locate()&#123;\n        if(nested.size() &#x3D;&#x3D; 0) return;\n\n         while(nested.size())&#123;  \n            auto&amp; [itnested, itend]  &#x3D; nested.top();  \n            if(itnested &#x3D;&#x3D; itend) nested.pop();\n            else if(!itnested-&gt;isInteger())&#123;\n                auto &amp; veclist &#x3D; itnested-&gt;getList();\n                ++itnested;\n                nested.push(&#123;veclist.begin(), veclist.end()&#125;);\n            &#125;\n            else break;            \n        &#125;         \n\n    &#125;\n\n    int next() &#123;\n        if( hasNext())&#123; \n            auto&amp; [itnested, itend]  &#x3D; nested.top();\n         \n            int nextv &#x3D; 0;\n            if(itnested-&gt;isInteger())&#123;\n                nextv &#x3D; itnested-&gt;getInteger();\n                ++itnested;\n                return nextv;\n            &#125;\n            else&#123;\n                auto &amp; nestedList &#x3D; itnested-&gt;getList();\n                ++itnested; &#x2F;&#x2F; 无论是数字还是数组都要向前遍历\n                nested.push(&#123;nestedList.begin(), nestedList.end()&#125;);\n                return next();\n            &#125;            \n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout &lt;&lt; i.next();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>更优雅的实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * &#x2F;&#x2F; This is the interface that allows for creating nested lists.\n * &#x2F;&#x2F; You should not implement it, or speculate about its implementation\n * class NestedInteger &#123;\n *   public:\n *     &#x2F;&#x2F; Return true if this NestedInteger holds a single integer, rather than a nested list.\n *     bool isInteger() const;\n *\n *     &#x2F;&#x2F; Return the single integer that this NestedInteger holds, if it holds a single integer\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a nested list\n *     int getInteger() const;\n *\n *     &#x2F;&#x2F; Return the nested list that this NestedInteger holds, if it holds a nested list\n *     &#x2F;&#x2F; The result is undefined if this NestedInteger holds a single integer\n *     const vector&lt;NestedInteger&gt; &amp;getList() const;\n * &#125;;\n *&#x2F;\n\nclass NestedIterator &#123;\n    using nestedVecIt &#x3D; vector&lt;NestedInteger&gt;::iterator;\n    stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested;\npublic:\n\n    NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;\n        if(nestedList.size() &gt; 0) nested.push(&#123;nestedList.begin(), nestedList.end()&#125;);\n    &#125;\n    bool hasNext() &#123; \n         while(nested.size())&#123;  \n            auto&amp; [itnested, itend]  &#x3D; nested.top();  \n            if(itnested &#x3D;&#x3D; itend) nested.pop();\n            else if(!itnested-&gt;isInteger())&#123;\n                auto &amp; veclist &#x3D; itnested++-&gt;getList(); &#x2F;&#x2F; 自增后获取 nestedList                \n                nested.push(&#123;veclist.begin(), veclist.end()&#125;);\n            &#125;\n            else break;            \n        &#125;         \n        return !nested.empty();        \n    &#125;\n\n    &#x2F;&#x2F; 保证调用前 指针指向的元素存在且为数字\n    int next() &#123;\n        return nested.top().first++-&gt;getInteger();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your NestedIterator object will be instantiated and called as such:\n * NestedIterator i(nestedList);\n * while (i.hasNext()) cout &lt;&lt; i.next();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"406. Queue Reconstruction by Height","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-15T00:43:44.000Z","_content":"\n<!-- more -->\n\n## 思路：\n\n贪心策略，因为队列的唯一性，从头到尾`reconstruct`即可。\n\n按`k`升序再按`h`降序，再按`k`值插入。需要在插入的同时统计维护前面身高大于`h`的人数即可。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int countBigger(int pos, vector<vector<int>> &people){\n        int res = 0;\n        for(int i = pos -1; i >= 0; --i){\n            if(people[i][0] >= people[pos][0]) res++;\n        }\n        return res;\n    }\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort(people.begin(), people.end(), [](vector<int>a, vector<int>b){\n            if(a[1] == b[1]) return a[0] < b[0];\n            else return a[1] < b[1];\n        });\n        int n = people.size();\n        for(int i = 0; i < n; ++i){\n            int c = countBigger(i, people);\n            int k = i;\n            while(c > people[k][1]){\n                if(people[k-1][0] >= people[k][0]) c--;\n                swap(people[k], people[k - 1]);\n                k--;\n                \n            }\n\n            \n        }\n        return people;\n    }\n};\n```\n\n","source":"_posts/刷题/其他/406-Queue-Reconstruction-by-Height.md","raw":"---\ntitle: 406. Queue Reconstruction by Height\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-15 08:43:44\n---\n\n<!-- more -->\n\n## 思路：\n\n贪心策略，因为队列的唯一性，从头到尾`reconstruct`即可。\n\n按`k`升序再按`h`降序，再按`k`值插入。需要在插入的同时统计维护前面身高大于`h`的人数即可。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int countBigger(int pos, vector<vector<int>> &people){\n        int res = 0;\n        for(int i = pos -1; i >= 0; --i){\n            if(people[i][0] >= people[pos][0]) res++;\n        }\n        return res;\n    }\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort(people.begin(), people.end(), [](vector<int>a, vector<int>b){\n            if(a[1] == b[1]) return a[0] < b[0];\n            else return a[1] < b[1];\n        });\n        int n = people.size();\n        for(int i = 0; i < n; ++i){\n            int c = countBigger(i, people);\n            int k = i;\n            while(c > people[k][1]){\n                if(people[k-1][0] >= people[k][0]) c--;\n                swap(people[k], people[k - 1]);\n                k--;\n                \n            }\n\n            \n        }\n        return people;\n    }\n};\n```\n\n","slug":"刷题/其他/406-Queue-Reconstruction-by-Height","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4h001ul5uo6udddq4z","content":"<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>贪心策略，因为队列的唯一性，从头到尾<code>reconstruct</code>即可。</p>\n<p>按<code>k</code>升序再按<code>h</code>降序，再按<code>k</code>值插入。需要在插入的同时统计维护前面身高大于<code>h</code>的人数即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countBigger(int pos, vector&lt;vector&lt;int&gt;&gt; &amp;people)&#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; pos -1; i &gt;&#x3D; 0; --i)&#123;\n            if(people[i][0] &gt;&#x3D; people[pos][0]) res++;\n        &#125;\n        return res;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;\n        sort(people.begin(), people.end(), [](vector&lt;int&gt;a, vector&lt;int&gt;b)&#123;\n            if(a[1] &#x3D;&#x3D; b[1]) return a[0] &lt; b[0];\n            else return a[1] &lt; b[1];\n        &#125;);\n        int n &#x3D; people.size();\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            int c &#x3D; countBigger(i, people);\n            int k &#x3D; i;\n            while(c &gt; people[k][1])&#123;\n                if(people[k-1][0] &gt;&#x3D; people[k][0]) c--;\n                swap(people[k], people[k - 1]);\n                k--;\n                \n            &#125;\n\n            \n        &#125;\n        return people;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"36NBTE6","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>贪心策略，因为队列的唯一性，从头到尾<code>reconstruct</code>即可。</p>\n<p>按<code>k</code>升序再按<code>h</code>降序，再按<code>k</code>值插入。需要在插入的同时统计维护前面身高大于<code>h</code>的人数即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countBigger(int pos, vector&lt;vector&lt;int&gt;&gt; &amp;people)&#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; pos -1; i &gt;&#x3D; 0; --i)&#123;\n            if(people[i][0] &gt;&#x3D; people[pos][0]) res++;\n        &#125;\n        return res;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;\n        sort(people.begin(), people.end(), [](vector&lt;int&gt;a, vector&lt;int&gt;b)&#123;\n            if(a[1] &#x3D;&#x3D; b[1]) return a[0] &lt; b[0];\n            else return a[1] &lt; b[1];\n        &#125;);\n        int n &#x3D; people.size();\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            int c &#x3D; countBigger(i, people);\n            int k &#x3D; i;\n            while(c &gt; people[k][1])&#123;\n                if(people[k-1][0] &gt;&#x3D; people[k][0]) c--;\n                swap(people[k], people[k - 1]);\n                k--;\n                \n            &#125;\n\n            \n        &#125;\n        return people;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"448. Find All Numbers Disappeared in an Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-22T03:32:10.000Z","_content":"\n\n\n\n## [448. Find All Numbers Disappeared in an Array](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)\n\n## 思路：\n\n把nums当做已经出现的元素的向量表，重点是遍历的元素过程中\"递归\"地置位元素。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        for(int i = 0; i < nums.size(); ++i){\n            int t = nums[i];\n            if(t < 0) continue;\n            while(nums[t - 1] > 0){\n                int newt = nums[t - 1];\n                nums[t - 1] =  nums[t - 1] == -1 ? -2 : -1;\n                t = newt;\n            }\n        }\n        vector<int> ans;\n        for(int i = 0; i < nums.size(); ++i){\n            if(nums[i] > 0) ans.push_back(i + 1);\n        }\n        return ans;\n\n    }\n};\n```","source":"_posts/刷题/其他/448-Find-All-Numbers-Disappeared-in-an-Array.md","raw":"---\ntitle: 448. Find All Numbers Disappeared in an Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-22 11:32:10\n---\n\n\n\n\n## [448. Find All Numbers Disappeared in an Array](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)\n\n## 思路：\n\n把nums当做已经出现的元素的向量表，重点是遍历的元素过程中\"递归\"地置位元素。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        for(int i = 0; i < nums.size(); ++i){\n            int t = nums[i];\n            if(t < 0) continue;\n            while(nums[t - 1] > 0){\n                int newt = nums[t - 1];\n                nums[t - 1] =  nums[t - 1] == -1 ? -2 : -1;\n                t = newt;\n            }\n        }\n        vector<int> ans;\n        for(int i = 0; i < nums.size(); ++i){\n            if(nums[i] > 0) ans.push_back(i + 1);\n        }\n        return ans;\n\n    }\n};\n```","slug":"刷题/其他/448-Find-All-Numbers-Disappeared-in-an-Array","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4i001vl5uo437cc22o","content":"<h2 id=\"448-Find-All-Numbers-Disappeared-in-an-Array\"><a href=\"#448-Find-All-Numbers-Disappeared-in-an-Array\" class=\"headerlink\" title=\"448. Find All Numbers Disappeared in an Array\"></a><a href=\"https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/\">448. Find All Numbers Disappeared in an Array</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>把nums当做已经出现的元素的向量表，重点是遍历的元素过程中”递归”地置位元素。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            int t &#x3D; nums[i];\n            if(t &lt; 0) continue;\n            while(nums[t - 1] &gt; 0)&#123;\n                int newt &#x3D; nums[t - 1];\n                nums[t - 1] &#x3D;  nums[t - 1] &#x3D;&#x3D; -1 ? -2 : -1;\n                t &#x3D; newt;\n            &#125;\n        &#125;\n        vector&lt;int&gt; ans;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            if(nums[i] &gt; 0) ans.push_back(i + 1);\n        &#125;\n        return ans;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1AKM5PW","excerpt":"<h2 id=\"448-Find-All-Numbers-Disappeared-in-an-Array\"><a href=\"#448-Find-All-Numbers-Disappeared-in-an-Array\" class=\"headerlink\" title=\"448. Find All Numbers Disappeared in an Array\"></a><a href=\"https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/\">448. Find All Numbers Disappeared in an Array</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>把nums当做已经出现的元素的向量表，重点是遍历的元素过程中”递归”地置位元素。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            int t &#x3D; nums[i];\n            if(t &lt; 0) continue;\n            while(nums[t - 1] &gt; 0)&#123;\n                int newt &#x3D; nums[t - 1];\n                nums[t - 1] &#x3D;  nums[t - 1] &#x3D;&#x3D; -1 ? -2 : -1;\n                t &#x3D; newt;\n            &#125;\n        &#125;\n        vector&lt;int&gt; ans;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            if(nums[i] &gt; 0) ans.push_back(i + 1);\n        &#125;\n        return ans;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"48. Rotate Image","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-22T03:31:37.000Z","_content":"\n\n\n## [48. Rotate Image](https://leetcode-cn.com/problems/rotate-image/)\n\n\n\n## 思路：\n\n\n\n原地翻转的思路：比较简单。\n\n1. 翻转做法。先上下翻转， 后对角线翻转\n2. 四个对应的矩阵元素作为旋转点，顺势将矩阵划分为四个旋转部分。遍历一个部分并旋转其中成组的所有元素即可。\n\n<!-- more -->\n\n## 代码：\n\n\n\n沙雕代码：\n\n```c++\nclass Solution {\npublic:\n\n    void rotate_ele(int x, int y, vector<vector<int>> &matrix){\n        int n = matrix.size() - 1;\n        vector<pair<int, int>>  idx;\n        idx.push_back({x, y});\n        idx.push_back({y, n - x});\n        idx.push_back({n - x, n- y});\n        idx.push_back({n- y, x});\n        int ordv = matrix[idx[0].first][idx[0].second];\n        for(int i = 0; i < 4; ++i){\n            int bi = (i + 1) % 4;\n            int &rotated = matrix[idx[bi].first][idx[bi].second]; // alias;\n            int newv = rotated;\n            rotated = ordv;\n            ordv = newv;\n        }\n        // for(int i = 0; i < n + 1; ++i){\n        //     for(int j = 0; j < n + 1; ++j){\n        //         cout << matrix[i][j] << \" \";                \n        //     }\n        //     cout << endl;\n        // }\n    \n    }\n    //发现旋转规律\n    // 1, 0 \n    // 0, 2\n    // 2, 3\n    // 3, 1\n\n    // 0, 0\n    // 0, 3\n    // 3, 3\n    // 3, 0\n    void rotate(vector<vector<int>>& matrix) {\n        if(matrix.size() == 0) return;\n        int cerX, cerY; \n        cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标\n        \n        //划分旋转点\n        // 按一个点旋转对应的4个点，组成一组进行旋转。各个组的旋转起点如下：\n        //  1 1 1 0\n        //  0 1 0 0 \n        //  0 0 0 0\n        //  0 0 0 0 \n\n        // 1 1 0 \n        // 0 1 0\n        // 0 0 0\n        for(int i = 0; i <= cerX; ++i){\n            for(int j = i; j < matrix.size() - 1 - i; ++j){                \n                rotate_ele(i, j, matrix);\n            }            \n        }\n    }\n};\n```\n\n\n\n简化一下\n\n```c++\n\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        if(matrix.size() == 0) return;\n        int cerX, cerY, n = matrix.size() - 1; \n        cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标\n        \n        for(int i = 0; i <= cerX; ++i){\n            for(int j = i; j < matrix.size() - 1 - i; ++j){                \n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - j][i];\n                matrix[n - j][i] = matrix[n - i][n - j];\n                matrix[n - i][n - j] = matrix[j][n - i];\n                matrix[j][n - i] = temp;\n            }            \n        }\n    }\n};\n```\n\n\n\n翻转做法\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        if(matrix.size() == 0) return;\n        int cerX, cerY, n = matrix.size() - 1; \n        cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标\n\t\t// 上下翻转        \n        for(int i = 0; i <= cerX; ++i){\n            for(int j = 0; j < matrix.size(); ++j){                \n                swap(matrix[i][j], matrix[n - i][j]);\n            }            \n        }\n\t\t// 对角线翻转\n        for(int i = 0; i <= matrix.size(); ++i){\n            for(int j = i + 1; j < matrix.size(); ++j){                \n                swap(matrix[i][j], matrix[j][i]);\n            }            \n        }\n    }\n};\n```","source":"_posts/刷题/其他/48-Rotate-Image.md","raw":"---\ntitle: 48. Rotate Image\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-22 11:31:37\n---\n\n\n\n## [48. Rotate Image](https://leetcode-cn.com/problems/rotate-image/)\n\n\n\n## 思路：\n\n\n\n原地翻转的思路：比较简单。\n\n1. 翻转做法。先上下翻转， 后对角线翻转\n2. 四个对应的矩阵元素作为旋转点，顺势将矩阵划分为四个旋转部分。遍历一个部分并旋转其中成组的所有元素即可。\n\n<!-- more -->\n\n## 代码：\n\n\n\n沙雕代码：\n\n```c++\nclass Solution {\npublic:\n\n    void rotate_ele(int x, int y, vector<vector<int>> &matrix){\n        int n = matrix.size() - 1;\n        vector<pair<int, int>>  idx;\n        idx.push_back({x, y});\n        idx.push_back({y, n - x});\n        idx.push_back({n - x, n- y});\n        idx.push_back({n- y, x});\n        int ordv = matrix[idx[0].first][idx[0].second];\n        for(int i = 0; i < 4; ++i){\n            int bi = (i + 1) % 4;\n            int &rotated = matrix[idx[bi].first][idx[bi].second]; // alias;\n            int newv = rotated;\n            rotated = ordv;\n            ordv = newv;\n        }\n        // for(int i = 0; i < n + 1; ++i){\n        //     for(int j = 0; j < n + 1; ++j){\n        //         cout << matrix[i][j] << \" \";                \n        //     }\n        //     cout << endl;\n        // }\n    \n    }\n    //发现旋转规律\n    // 1, 0 \n    // 0, 2\n    // 2, 3\n    // 3, 1\n\n    // 0, 0\n    // 0, 3\n    // 3, 3\n    // 3, 0\n    void rotate(vector<vector<int>>& matrix) {\n        if(matrix.size() == 0) return;\n        int cerX, cerY; \n        cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标\n        \n        //划分旋转点\n        // 按一个点旋转对应的4个点，组成一组进行旋转。各个组的旋转起点如下：\n        //  1 1 1 0\n        //  0 1 0 0 \n        //  0 0 0 0\n        //  0 0 0 0 \n\n        // 1 1 0 \n        // 0 1 0\n        // 0 0 0\n        for(int i = 0; i <= cerX; ++i){\n            for(int j = i; j < matrix.size() - 1 - i; ++j){                \n                rotate_ele(i, j, matrix);\n            }            \n        }\n    }\n};\n```\n\n\n\n简化一下\n\n```c++\n\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        if(matrix.size() == 0) return;\n        int cerX, cerY, n = matrix.size() - 1; \n        cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标\n        \n        for(int i = 0; i <= cerX; ++i){\n            for(int j = i; j < matrix.size() - 1 - i; ++j){                \n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - j][i];\n                matrix[n - j][i] = matrix[n - i][n - j];\n                matrix[n - i][n - j] = matrix[j][n - i];\n                matrix[j][n - i] = temp;\n            }            \n        }\n    }\n};\n```\n\n\n\n翻转做法\n\n```c++\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        if(matrix.size() == 0) return;\n        int cerX, cerY, n = matrix.size() - 1; \n        cerX = cerY = (matrix.size() - 1) / 2; // 中间数下标\n\t\t// 上下翻转        \n        for(int i = 0; i <= cerX; ++i){\n            for(int j = 0; j < matrix.size(); ++j){                \n                swap(matrix[i][j], matrix[n - i][j]);\n            }            \n        }\n\t\t// 对角线翻转\n        for(int i = 0; i <= matrix.size(); ++i){\n            for(int j = i + 1; j < matrix.size(); ++j){                \n                swap(matrix[i][j], matrix[j][i]);\n            }            \n        }\n    }\n};\n```","slug":"刷题/其他/48-Rotate-Image","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4j001wl5uoh5v9dqb6","content":"<h2 id=\"48-Rotate-Image\"><a href=\"#48-Rotate-Image\" class=\"headerlink\" title=\"48. Rotate Image\"></a><a href=\"https://leetcode-cn.com/problems/rotate-image/\">48. Rotate Image</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>原地翻转的思路：比较简单。</p>\n<ol>\n<li>翻转做法。先上下翻转， 后对角线翻转</li>\n<li>四个对应的矩阵元素作为旋转点，顺势将矩阵划分为四个旋转部分。遍历一个部分并旋转其中成组的所有元素即可。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>沙雕代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    void rotate_ele(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;matrix)&#123;\n        int n &#x3D; matrix.size() - 1;\n        vector&lt;pair&lt;int, int&gt;&gt;  idx;\n        idx.push_back(&#123;x, y&#125;);\n        idx.push_back(&#123;y, n - x&#125;);\n        idx.push_back(&#123;n - x, n- y&#125;);\n        idx.push_back(&#123;n- y, x&#125;);\n        int ordv &#x3D; matrix[idx[0].first][idx[0].second];\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            int bi &#x3D; (i + 1) % 4;\n            int &amp;rotated &#x3D; matrix[idx[bi].first][idx[bi].second]; &#x2F;&#x2F; alias;\n            int newv &#x3D; rotated;\n            rotated &#x3D; ordv;\n            ordv &#x3D; newv;\n        &#125;\n        &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n + 1; ++i)&#123;\n        &#x2F;&#x2F;     for(int j &#x3D; 0; j &lt; n + 1; ++j)&#123;\n        &#x2F;&#x2F;         cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;                \n        &#x2F;&#x2F;     &#125;\n        &#x2F;&#x2F;     cout &lt;&lt; endl;\n        &#x2F;&#x2F; &#125;\n    \n    &#125;\n    &#x2F;&#x2F;发现旋转规律\n    &#x2F;&#x2F; 1, 0 \n    &#x2F;&#x2F; 0, 2\n    &#x2F;&#x2F; 2, 3\n    &#x2F;&#x2F; 3, 1\n\n    &#x2F;&#x2F; 0, 0\n    &#x2F;&#x2F; 0, 3\n    &#x2F;&#x2F; 3, 3\n    &#x2F;&#x2F; 3, 0\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.size() &#x3D;&#x3D; 0) return;\n        int cerX, cerY; \n        cerX &#x3D; cerY &#x3D; (matrix.size() - 1) &#x2F; 2; &#x2F;&#x2F; 中间数下标\n        \n        &#x2F;&#x2F;划分旋转点\n        &#x2F;&#x2F; 按一个点旋转对应的4个点，组成一组进行旋转。各个组的旋转起点如下：\n        &#x2F;&#x2F;  1 1 1 0\n        &#x2F;&#x2F;  0 1 0 0 \n        &#x2F;&#x2F;  0 0 0 0\n        &#x2F;&#x2F;  0 0 0 0 \n\n        &#x2F;&#x2F; 1 1 0 \n        &#x2F;&#x2F; 0 1 0\n        &#x2F;&#x2F; 0 0 0\n        for(int i &#x3D; 0; i &lt;&#x3D; cerX; ++i)&#123;\n            for(int j &#x3D; i; j &lt; matrix.size() - 1 - i; ++j)&#123;                \n                rotate_ele(i, j, matrix);\n            &#125;            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>简化一下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n\nclass Solution &#123;\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.size() &#x3D;&#x3D; 0) return;\n        int cerX, cerY, n &#x3D; matrix.size() - 1; \n        cerX &#x3D; cerY &#x3D; (matrix.size() - 1) &#x2F; 2; &#x2F;&#x2F; 中间数下标\n        \n        for(int i &#x3D; 0; i &lt;&#x3D; cerX; ++i)&#123;\n            for(int j &#x3D; i; j &lt; matrix.size() - 1 - i; ++j)&#123;                \n                int temp &#x3D; matrix[i][j];\n                matrix[i][j] &#x3D; matrix[n - j][i];\n                matrix[n - j][i] &#x3D; matrix[n - i][n - j];\n                matrix[n - i][n - j] &#x3D; matrix[j][n - i];\n                matrix[j][n - i] &#x3D; temp;\n            &#125;            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>翻转做法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.size() &#x3D;&#x3D; 0) return;\n        int cerX, cerY, n &#x3D; matrix.size() - 1; \n        cerX &#x3D; cerY &#x3D; (matrix.size() - 1) &#x2F; 2; &#x2F;&#x2F; 中间数下标\n\t\t&#x2F;&#x2F; 上下翻转        \n        for(int i &#x3D; 0; i &lt;&#x3D; cerX; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; matrix.size(); ++j)&#123;                \n                swap(matrix[i][j], matrix[n - i][j]);\n            &#125;            \n        &#125;\n\t\t&#x2F;&#x2F; 对角线翻转\n        for(int i &#x3D; 0; i &lt;&#x3D; matrix.size(); ++i)&#123;\n            for(int j &#x3D; i + 1; j &lt; matrix.size(); ++j)&#123;                \n                swap(matrix[i][j], matrix[j][i]);\n            &#125;            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3P0TYQT","excerpt":"<h2 id=\"48-Rotate-Image\"><a href=\"#48-Rotate-Image\" class=\"headerlink\" title=\"48. Rotate Image\"></a><a href=\"https://leetcode-cn.com/problems/rotate-image/\">48. Rotate Image</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>原地翻转的思路：比较简单。</p>\n<ol>\n<li>翻转做法。先上下翻转， 后对角线翻转</li>\n<li>四个对应的矩阵元素作为旋转点，顺势将矩阵划分为四个旋转部分。遍历一个部分并旋转其中成组的所有元素即可。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>沙雕代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    void rotate_ele(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;matrix)&#123;\n        int n &#x3D; matrix.size() - 1;\n        vector&lt;pair&lt;int, int&gt;&gt;  idx;\n        idx.push_back(&#123;x, y&#125;);\n        idx.push_back(&#123;y, n - x&#125;);\n        idx.push_back(&#123;n - x, n- y&#125;);\n        idx.push_back(&#123;n- y, x&#125;);\n        int ordv &#x3D; matrix[idx[0].first][idx[0].second];\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            int bi &#x3D; (i + 1) % 4;\n            int &amp;rotated &#x3D; matrix[idx[bi].first][idx[bi].second]; &#x2F;&#x2F; alias;\n            int newv &#x3D; rotated;\n            rotated &#x3D; ordv;\n            ordv &#x3D; newv;\n        &#125;\n        &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n + 1; ++i)&#123;\n        &#x2F;&#x2F;     for(int j &#x3D; 0; j &lt; n + 1; ++j)&#123;\n        &#x2F;&#x2F;         cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;                \n        &#x2F;&#x2F;     &#125;\n        &#x2F;&#x2F;     cout &lt;&lt; endl;\n        &#x2F;&#x2F; &#125;\n    \n    &#125;\n    &#x2F;&#x2F;发现旋转规律\n    &#x2F;&#x2F; 1, 0 \n    &#x2F;&#x2F; 0, 2\n    &#x2F;&#x2F; 2, 3\n    &#x2F;&#x2F; 3, 1\n\n    &#x2F;&#x2F; 0, 0\n    &#x2F;&#x2F; 0, 3\n    &#x2F;&#x2F; 3, 3\n    &#x2F;&#x2F; 3, 0\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.size() &#x3D;&#x3D; 0) return;\n        int cerX, cerY; \n        cerX &#x3D; cerY &#x3D; (matrix.size() - 1) &#x2F; 2; &#x2F;&#x2F; 中间数下标\n        \n        &#x2F;&#x2F;划分旋转点\n        &#x2F;&#x2F; 按一个点旋转对应的4个点，组成一组进行旋转。各个组的旋转起点如下：\n        &#x2F;&#x2F;  1 1 1 0\n        &#x2F;&#x2F;  0 1 0 0 \n        &#x2F;&#x2F;  0 0 0 0\n        &#x2F;&#x2F;  0 0 0 0 \n\n        &#x2F;&#x2F; 1 1 0 \n        &#x2F;&#x2F; 0 1 0\n        &#x2F;&#x2F; 0 0 0\n        for(int i &#x3D; 0; i &lt;&#x3D; cerX; ++i)&#123;\n            for(int j &#x3D; i; j &lt; matrix.size() - 1 - i; ++j)&#123;                \n                rotate_ele(i, j, matrix);\n            &#125;            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>简化一下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n\nclass Solution &#123;\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.size() &#x3D;&#x3D; 0) return;\n        int cerX, cerY, n &#x3D; matrix.size() - 1; \n        cerX &#x3D; cerY &#x3D; (matrix.size() - 1) &#x2F; 2; &#x2F;&#x2F; 中间数下标\n        \n        for(int i &#x3D; 0; i &lt;&#x3D; cerX; ++i)&#123;\n            for(int j &#x3D; i; j &lt; matrix.size() - 1 - i; ++j)&#123;                \n                int temp &#x3D; matrix[i][j];\n                matrix[i][j] &#x3D; matrix[n - j][i];\n                matrix[n - j][i] &#x3D; matrix[n - i][n - j];\n                matrix[n - i][n - j] &#x3D; matrix[j][n - i];\n                matrix[j][n - i] &#x3D; temp;\n            &#125;            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>翻转做法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        if(matrix.size() &#x3D;&#x3D; 0) return;\n        int cerX, cerY, n &#x3D; matrix.size() - 1; \n        cerX &#x3D; cerY &#x3D; (matrix.size() - 1) &#x2F; 2; &#x2F;&#x2F; 中间数下标\n\t\t&#x2F;&#x2F; 上下翻转        \n        for(int i &#x3D; 0; i &lt;&#x3D; cerX; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; matrix.size(); ++j)&#123;                \n                swap(matrix[i][j], matrix[n - i][j]);\n            &#125;            \n        &#125;\n\t\t&#x2F;&#x2F; 对角线翻转\n        for(int i &#x3D; 0; i &lt;&#x3D; matrix.size(); ++i)&#123;\n            for(int j &#x3D; i + 1; j &lt; matrix.size(); ++j)&#123;                \n                swap(matrix[i][j], matrix[j][i]);\n            &#125;            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"524. Longest Word in Dictionary through Deleting","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-22T01:15:18.000Z","_content":"\n\n\n\n#### [524. Longest Word in Dictionary through Deleting](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n2020.10.22日\n\n这题还是稍微锻炼了一下我、\n\n<!-- more -->\n\n## 思路：\n\n为了尽量降低代码复杂度，我选择了用hash保留地址法存储每个相同字符的位置。在遍历字典中每个字符中，判断每个字符串的字符合理出现位置，二分hash链式表中每个字符的可能位置即可。\n\n代码虽然复杂一点，但是很快，时间复杂度为：$O(logL(s) * L(d[argmax\\  len(d[i])] * d.size()))$\n\n## 代码：\n\n\n\n其他人的的双指针法：很慢\n\n```\n\nclass Solution \n{\nprivate:\n    bool isZichuan(string target, string s)\n    {   \n        //分别从左端开始索引，检测是否为子列\n        int i = 0, j = 0;\n        while(i < target.size() && j < s.size())\n        {\n            if(target[i] == s[j])\n                i++;\n            j++;  \n        }\n        return i == target.size();\n    }\n\npublic:\n\n    string findLongestWord(string s, vector<string>& d) \n    {\n        string str = \"\";\n        for(int i = 0; i < d.size(); i++)\n        {\n            int tag = str.length();\n            int leng = d[i].length();\n            //若字符串更短或者一样长且字母顺序较大的直接舍去\n            if(tag > leng || (tag == leng && str.compare(d[i]) < 0))\n                continue;\n            \n            if(isZichuan(d[i], s))\n            {\n                str = d[i];\n            }\n        }a\n        return str;\n    }\n};\n\n作者：lu-guo-de-feng-2\n链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/zhi-xing-yong-shi-60-ms-zai-suo-you-c-ti-jiao-zh-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```\n\n击败99.7%\n\n```\nclass Solution {\npublic:\n    string findLongestWord(string s, vector<string>& d) {\n        vector<int> map[26];\n        for(int i = 0; i < s.size(); i++){\n            map[s[i] - 'a'].push_back(i);\n        }\n        string maxs = \"\";\n        for(int i = 0; i < d.size(); ++i){\n            int s = -1, flag = 1;\n            for(int j = 0; j < d[i].size(); ++j){\n                int cp = d[i][j] - 'a';\n                int l = 0, r = map[cp].size(), mid;\n                while(l < r){\n                    mid = (l + r) / 2;\n                    if(map[cp][mid] > s) r = mid;\n                    else l = mid + 1;\n                }\n                if(l == map[cp].size() || s >= map[cp][l]){\n                    flag = 0;\n                    break;\n                } \n                s = map[cp][l];\n            }\n            // cout << endl;\n            if(flag && ( maxs.size() < d[i].size() || maxs.size() == d[i].size() && maxs > d[i]))\n                maxs = d[i]; \n        }\n        return maxs;\n        \n    }\n};\n```","source":"_posts/刷题/其他/524-Longest-Word-in-Dictionary-through-Deleting.md","raw":"---\ntitle: 524. Longest Word in Dictionary through Deleting\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-10-22 09:15:18\ntags:\n---\n\n\n\n\n#### [524. Longest Word in Dictionary through Deleting](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)\n\n2020.10.22日\n\n这题还是稍微锻炼了一下我、\n\n<!-- more -->\n\n## 思路：\n\n为了尽量降低代码复杂度，我选择了用hash保留地址法存储每个相同字符的位置。在遍历字典中每个字符中，判断每个字符串的字符合理出现位置，二分hash链式表中每个字符的可能位置即可。\n\n代码虽然复杂一点，但是很快，时间复杂度为：$O(logL(s) * L(d[argmax\\  len(d[i])] * d.size()))$\n\n## 代码：\n\n\n\n其他人的的双指针法：很慢\n\n```\n\nclass Solution \n{\nprivate:\n    bool isZichuan(string target, string s)\n    {   \n        //分别从左端开始索引，检测是否为子列\n        int i = 0, j = 0;\n        while(i < target.size() && j < s.size())\n        {\n            if(target[i] == s[j])\n                i++;\n            j++;  \n        }\n        return i == target.size();\n    }\n\npublic:\n\n    string findLongestWord(string s, vector<string>& d) \n    {\n        string str = \"\";\n        for(int i = 0; i < d.size(); i++)\n        {\n            int tag = str.length();\n            int leng = d[i].length();\n            //若字符串更短或者一样长且字母顺序较大的直接舍去\n            if(tag > leng || (tag == leng && str.compare(d[i]) < 0))\n                continue;\n            \n            if(isZichuan(d[i], s))\n            {\n                str = d[i];\n            }\n        }a\n        return str;\n    }\n};\n\n作者：lu-guo-de-feng-2\n链接：https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/zhi-xing-yong-shi-60-ms-zai-suo-you-c-ti-jiao-zh-3/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```\n\n击败99.7%\n\n```\nclass Solution {\npublic:\n    string findLongestWord(string s, vector<string>& d) {\n        vector<int> map[26];\n        for(int i = 0; i < s.size(); i++){\n            map[s[i] - 'a'].push_back(i);\n        }\n        string maxs = \"\";\n        for(int i = 0; i < d.size(); ++i){\n            int s = -1, flag = 1;\n            for(int j = 0; j < d[i].size(); ++j){\n                int cp = d[i][j] - 'a';\n                int l = 0, r = map[cp].size(), mid;\n                while(l < r){\n                    mid = (l + r) / 2;\n                    if(map[cp][mid] > s) r = mid;\n                    else l = mid + 1;\n                }\n                if(l == map[cp].size() || s >= map[cp][l]){\n                    flag = 0;\n                    break;\n                } \n                s = map[cp][l];\n            }\n            // cout << endl;\n            if(flag && ( maxs.size() < d[i].size() || maxs.size() == d[i].size() && maxs > d[i]))\n                maxs = d[i]; \n        }\n        return maxs;\n        \n    }\n};\n```","slug":"刷题/其他/524-Longest-Word-in-Dictionary-through-Deleting","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4j001xl5uobac08rd1","content":"<h4 id=\"524-Longest-Word-in-Dictionary-through-Deleting\"><a href=\"#524-Longest-Word-in-Dictionary-through-Deleting\" class=\"headerlink\" title=\"524. Longest Word in Dictionary through Deleting\"></a><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">524. Longest Word in Dictionary through Deleting</a></h4><p>2020.10.22日</p>\n<p>这题还是稍微锻炼了一下我、</p>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>为了尽量降低代码复杂度，我选择了用hash保留地址法存储每个相同字符的位置。在遍历字典中每个字符中，判断每个字符串的字符合理出现位置，二分hash链式表中每个字符的可能位置即可。</p>\n<p>代码虽然复杂一点，但是很快，时间复杂度为：$O(logL(s) * L(d[argmax\\  len(d[i])] * d.size()))$</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>其他人的的双指针法：很慢</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nclass Solution \n&#123;\nprivate:\n    bool isZichuan(string target, string s)\n    &#123;   \n        &#x2F;&#x2F;分别从左端开始索引，检测是否为子列\n        int i &#x3D; 0, j &#x3D; 0;\n        while(i &lt; target.size() &amp;&amp; j &lt; s.size())\n        &#123;\n            if(target[i] &#x3D;&#x3D; s[j])\n                i++;\n            j++;  \n        &#125;\n        return i &#x3D;&#x3D; target.size();\n    &#125;\n\npublic:\n\n    string findLongestWord(string s, vector&lt;string&gt;&amp; d) \n    &#123;\n        string str &#x3D; &quot;&quot;;\n        for(int i &#x3D; 0; i &lt; d.size(); i++)\n        &#123;\n            int tag &#x3D; str.length();\n            int leng &#x3D; d[i].length();\n            &#x2F;&#x2F;若字符串更短或者一样长且字母顺序较大的直接舍去\n            if(tag &gt; leng || (tag &#x3D;&#x3D; leng &amp;&amp; str.compare(d[i]) &lt; 0))\n                continue;\n            \n            if(isZichuan(d[i], s))\n            &#123;\n                str &#x3D; d[i];\n            &#125;\n        &#125;a\n        return str;\n    &#125;\n&#125;;\n\n作者：lu-guo-de-feng-2\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-word-in-dictionary-through-deleting&#x2F;solution&#x2F;zhi-xing-yong-shi-60-ms-zai-suo-you-c-ti-jiao-zh-3&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>击败99.7%</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123;\n        vector&lt;int&gt; map[26];\n        for(int i &#x3D; 0; i &lt; s.size(); i++)&#123;\n            map[s[i] - &#39;a&#39;].push_back(i);\n        &#125;\n        string maxs &#x3D; &quot;&quot;;\n        for(int i &#x3D; 0; i &lt; d.size(); ++i)&#123;\n            int s &#x3D; -1, flag &#x3D; 1;\n            for(int j &#x3D; 0; j &lt; d[i].size(); ++j)&#123;\n                int cp &#x3D; d[i][j] - &#39;a&#39;;\n                int l &#x3D; 0, r &#x3D; map[cp].size(), mid;\n                while(l &lt; r)&#123;\n                    mid &#x3D; (l + r) &#x2F; 2;\n                    if(map[cp][mid] &gt; s) r &#x3D; mid;\n                    else l &#x3D; mid + 1;\n                &#125;\n                if(l &#x3D;&#x3D; map[cp].size() || s &gt;&#x3D; map[cp][l])&#123;\n                    flag &#x3D; 0;\n                    break;\n                &#125; \n                s &#x3D; map[cp][l];\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n            if(flag &amp;&amp; ( maxs.size() &lt; d[i].size() || maxs.size() &#x3D;&#x3D; d[i].size() &amp;&amp; maxs &gt; d[i]))\n                maxs &#x3D; d[i]; \n        &#125;\n        return maxs;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3MMKX3H","excerpt":"<h4 id=\"524-Longest-Word-in-Dictionary-through-Deleting\"><a href=\"#524-Longest-Word-in-Dictionary-through-Deleting\" class=\"headerlink\" title=\"524. Longest Word in Dictionary through Deleting\"></a><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">524. Longest Word in Dictionary through Deleting</a></h4><p>2020.10.22日</p>\n<p>这题还是稍微锻炼了一下我、</p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>为了尽量降低代码复杂度，我选择了用hash保留地址法存储每个相同字符的位置。在遍历字典中每个字符中，判断每个字符串的字符合理出现位置，二分hash链式表中每个字符的可能位置即可。</p>\n<p>代码虽然复杂一点，但是很快，时间复杂度为：$O(logL(s) * L(d[argmax\\  len(d[i])] * d.size()))$</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>其他人的的双指针法：很慢</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nclass Solution \n&#123;\nprivate:\n    bool isZichuan(string target, string s)\n    &#123;   \n        &#x2F;&#x2F;分别从左端开始索引，检测是否为子列\n        int i &#x3D; 0, j &#x3D; 0;\n        while(i &lt; target.size() &amp;&amp; j &lt; s.size())\n        &#123;\n            if(target[i] &#x3D;&#x3D; s[j])\n                i++;\n            j++;  \n        &#125;\n        return i &#x3D;&#x3D; target.size();\n    &#125;\n\npublic:\n\n    string findLongestWord(string s, vector&lt;string&gt;&amp; d) \n    &#123;\n        string str &#x3D; &quot;&quot;;\n        for(int i &#x3D; 0; i &lt; d.size(); i++)\n        &#123;\n            int tag &#x3D; str.length();\n            int leng &#x3D; d[i].length();\n            &#x2F;&#x2F;若字符串更短或者一样长且字母顺序较大的直接舍去\n            if(tag &gt; leng || (tag &#x3D;&#x3D; leng &amp;&amp; str.compare(d[i]) &lt; 0))\n                continue;\n            \n            if(isZichuan(d[i], s))\n            &#123;\n                str &#x3D; d[i];\n            &#125;\n        &#125;a\n        return str;\n    &#125;\n&#125;;\n\n作者：lu-guo-de-feng-2\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-word-in-dictionary-through-deleting&#x2F;solution&#x2F;zhi-xing-yong-shi-60-ms-zai-suo-you-c-ti-jiao-zh-3&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>击败99.7%</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123;\n        vector&lt;int&gt; map[26];\n        for(int i &#x3D; 0; i &lt; s.size(); i++)&#123;\n            map[s[i] - &#39;a&#39;].push_back(i);\n        &#125;\n        string maxs &#x3D; &quot;&quot;;\n        for(int i &#x3D; 0; i &lt; d.size(); ++i)&#123;\n            int s &#x3D; -1, flag &#x3D; 1;\n            for(int j &#x3D; 0; j &lt; d[i].size(); ++j)&#123;\n                int cp &#x3D; d[i][j] - &#39;a&#39;;\n                int l &#x3D; 0, r &#x3D; map[cp].size(), mid;\n                while(l &lt; r)&#123;\n                    mid &#x3D; (l + r) &#x2F; 2;\n                    if(map[cp][mid] &gt; s) r &#x3D; mid;\n                    else l &#x3D; mid + 1;\n                &#125;\n                if(l &#x3D;&#x3D; map[cp].size() || s &gt;&#x3D; map[cp][l])&#123;\n                    flag &#x3D; 0;\n                    break;\n                &#125; \n                s &#x3D; map[cp][l];\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n            if(flag &amp;&amp; ( maxs.size() &lt; d[i].size() || maxs.size() &#x3D;&#x3D; d[i].size() &amp;&amp; maxs &gt; d[i]))\n                maxs &#x3D; d[i]; \n        &#125;\n        return maxs;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"540. Single Element in a Sorted Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-08T23:55:11.000Z","_content":"\n## [540. Single Element in a Sorted Array](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)\n\n## 思路：\n\n设计一个二分即可。\n\n\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int n = nums.size();\n        int l = 0, r = n - 1, mid;\n        while(l < r){\n            mid = (l + r) / 2;\n            int ct;\n            if(mid == 0) return nums[0];\n            if(nums[mid] == nums[mid + 1])\n                ct = mid;\n            else if(nums[mid] == nums[mid - 1])\n                ct = mid - 1;\n            else return nums[mid];\n            if( (n - ct) % 2 == 0) r = mid;\n            else l = mid + 1;\n        }\n        return nums[l];\n\n    }\n};\n```\n\n","source":"_posts/刷题/其他/540-Single-Element-in-a-Sorted-Array.md","raw":"---\ntitle: 540. Single Element in a Sorted Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-11-09 07:55:11\ntags:\n---\n\n## [540. Single Element in a Sorted Array](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)\n\n## 思路：\n\n设计一个二分即可。\n\n\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int n = nums.size();\n        int l = 0, r = n - 1, mid;\n        while(l < r){\n            mid = (l + r) / 2;\n            int ct;\n            if(mid == 0) return nums[0];\n            if(nums[mid] == nums[mid + 1])\n                ct = mid;\n            else if(nums[mid] == nums[mid - 1])\n                ct = mid - 1;\n            else return nums[mid];\n            if( (n - ct) % 2 == 0) r = mid;\n            else l = mid + 1;\n        }\n        return nums[l];\n\n    }\n};\n```\n\n","slug":"刷题/其他/540-Single-Element-in-a-Sorted-Array","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4k001yl5uo750mfzle","content":"<h2 id=\"540-Single-Element-in-a-Sorted-Array\"><a href=\"#540-Single-Element-in-a-Sorted-Array\" class=\"headerlink\" title=\"540. Single Element in a Sorted Array\"></a><a href=\"https://leetcode-cn.com/problems/single-element-in-a-sorted-array/\">540. Single Element in a Sorted Array</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>设计一个二分即可。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int l &#x3D; 0, r &#x3D; n - 1, mid;\n        while(l &lt; r)&#123;\n            mid &#x3D; (l + r) &#x2F; 2;\n            int ct;\n            if(mid &#x3D;&#x3D; 0) return nums[0];\n            if(nums[mid] &#x3D;&#x3D; nums[mid + 1])\n                ct &#x3D; mid;\n            else if(nums[mid] &#x3D;&#x3D; nums[mid - 1])\n                ct &#x3D; mid - 1;\n            else return nums[mid];\n            if( (n - ct) % 2 &#x3D;&#x3D; 0) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n        return nums[l];\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1RWA9BP","excerpt":"<h2 id=\"540-Single-Element-in-a-Sorted-Array\"><a href=\"#540-Single-Element-in-a-Sorted-Array\" class=\"headerlink\" title=\"540. Single Element in a Sorted Array\"></a><a href=\"https://leetcode-cn.com/problems/single-element-in-a-sorted-array/\">540. Single Element in a Sorted Array</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>设计一个二分即可。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int l &#x3D; 0, r &#x3D; n - 1, mid;\n        while(l &lt; r)&#123;\n            mid &#x3D; (l + r) &#x2F; 2;\n            int ct;\n            if(mid &#x3D;&#x3D; 0) return nums[0];\n            if(nums[mid] &#x3D;&#x3D; nums[mid + 1])\n                ct &#x3D; mid;\n            else if(nums[mid] &#x3D;&#x3D; nums[mid - 1])\n                ct &#x3D; mid - 1;\n            else return nums[mid];\n            if( (n - ct) % 2 &#x3D;&#x3D; 0) r &#x3D; mid;\n            else l &#x3D; mid + 1;\n        &#125;\n        return nums[l];\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"560. Subarray Sum Equals K","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-29T03:47:14.000Z","_content":"\n\n\n\n\n\n## [560. Subarray Sum Equals K](https://leetcode-cn.com/problems/subarray-sum-equals-k/)\n\n\n\n## 思路：\n\nhash+ 前缀。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> dp(n + 1);\n        unordered_map<int, int> map;\n        int ct = 0;\n        map[0] = 1;\n        for(int i = 1; i < n + 1; ++i) {\n            dp[i] = dp[i - 1 ] + nums[i - 1];\n            ct += map[dp[i] - k];\n            map[dp[i]]++;\n        }\n\n        return ct;\n    }\n};\n\n\n//错误二分，数组不保证都为正数\n// class Solution {\n// public:\n//     int subarraySum(vector<int>& nums, int k) {\n//         int n = nums.size();\n//         if(n == 0) return 0;\n//         vector<int> dp(n + 1);\n\n//         for(int i = 1; i < n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1];\n\n//         int ct = 0;\n//         for(int i = 0; i < n; ++i){\n//             int r = n - 1;\n//             int l = i;\n//             while(l < r){\n//                 int mid = (l + r) / 2;\n//                 if(dp[mid + 1] - dp[i] >= k) r = mid;\n//                 else l = mid + 1;\n//             }\n//             if(l < n && dp[l + 1] - dp[i] == k) ct++;\n//         }\n//         return ct;\n//     }\n// };\n\n\n// class Solution {\n// public:\n//     int subarraySum(vector<int>& nums, int k) {\n//         int n = nums.size();\n//         if(n == 0) return 0;\n//         vector<int> dp(n + 1);\n\n//         for(int i = 1; i < n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1];\n\n//         int ct = 0;\n//         for(int i = 0; i < n; ++i){\n//             for(int j = i; j < n; ++j)\n//                 if(k == dp[j + 1] - dp[i]) ct++;\n            \n//         }\n//         return ct;\n//     }\n// };\n\n```","source":"_posts/刷题/其他/560-Subarray-Sum-Equals-K.md","raw":"---\ntitle: 560. Subarray Sum Equals K\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-01-29 11:47:14\ntags:\ncategories:\n---\n\n\n\n\n\n\n## [560. Subarray Sum Equals K](https://leetcode-cn.com/problems/subarray-sum-equals-k/)\n\n\n\n## 思路：\n\nhash+ 前缀。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(n == 0) return 0;\n        vector<int> dp(n + 1);\n        unordered_map<int, int> map;\n        int ct = 0;\n        map[0] = 1;\n        for(int i = 1; i < n + 1; ++i) {\n            dp[i] = dp[i - 1 ] + nums[i - 1];\n            ct += map[dp[i] - k];\n            map[dp[i]]++;\n        }\n\n        return ct;\n    }\n};\n\n\n//错误二分，数组不保证都为正数\n// class Solution {\n// public:\n//     int subarraySum(vector<int>& nums, int k) {\n//         int n = nums.size();\n//         if(n == 0) return 0;\n//         vector<int> dp(n + 1);\n\n//         for(int i = 1; i < n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1];\n\n//         int ct = 0;\n//         for(int i = 0; i < n; ++i){\n//             int r = n - 1;\n//             int l = i;\n//             while(l < r){\n//                 int mid = (l + r) / 2;\n//                 if(dp[mid + 1] - dp[i] >= k) r = mid;\n//                 else l = mid + 1;\n//             }\n//             if(l < n && dp[l + 1] - dp[i] == k) ct++;\n//         }\n//         return ct;\n//     }\n// };\n\n\n// class Solution {\n// public:\n//     int subarraySum(vector<int>& nums, int k) {\n//         int n = nums.size();\n//         if(n == 0) return 0;\n//         vector<int> dp(n + 1);\n\n//         for(int i = 1; i < n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1];\n\n//         int ct = 0;\n//         for(int i = 0; i < n; ++i){\n//             for(int j = i; j < n; ++j)\n//                 if(k == dp[j + 1] - dp[i]) ct++;\n            \n//         }\n//         return ct;\n//     }\n// };\n\n```","slug":"刷题/其他/560-Subarray-Sum-Equals-K","published":1,"updated":"2021-01-29T03:48:15.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4l001zl5uobz469rzt","content":"<h2 id=\"560-Subarray-Sum-Equals-K\"><a href=\"#560-Subarray-Sum-Equals-K\" class=\"headerlink\" title=\"560. Subarray Sum Equals K\"></a><a href=\"https://leetcode-cn.com/problems/subarray-sum-equals-k/\">560. Subarray Sum Equals K</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>hash+ 前缀。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp(n + 1);\n        unordered_map&lt;int, int&gt; map;\n        int ct &#x3D; 0;\n        map[0] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n + 1; ++i) &#123;\n            dp[i] &#x3D; dp[i - 1 ] + nums[i - 1];\n            ct +&#x3D; map[dp[i] - k];\n            map[dp[i]]++;\n        &#125;\n\n        return ct;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;错误二分，数组不保证都为正数\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n&#x2F;&#x2F;     int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         if(n &#x3D;&#x3D; 0) return 0;\n&#x2F;&#x2F;         vector&lt;int&gt; dp(n + 1);\n\n&#x2F;&#x2F;         for(int i &#x3D; 1; i &lt; n + 1; ++i) dp[i] &#x3D; dp[i - 1 ] + nums[i - 1];\n\n&#x2F;&#x2F;         int ct &#x3D; 0;\n&#x2F;&#x2F;         for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n&#x2F;&#x2F;             int r &#x3D; n - 1;\n&#x2F;&#x2F;             int l &#x3D; i;\n&#x2F;&#x2F;             while(l &lt; r)&#123;\n&#x2F;&#x2F;                 int mid &#x3D; (l + r) &#x2F; 2;\n&#x2F;&#x2F;                 if(dp[mid + 1] - dp[i] &gt;&#x3D; k) r &#x3D; mid;\n&#x2F;&#x2F;                 else l &#x3D; mid + 1;\n&#x2F;&#x2F;             &#125;\n&#x2F;&#x2F;             if(l &lt; n &amp;&amp; dp[l + 1] - dp[i] &#x3D;&#x3D; k) ct++;\n&#x2F;&#x2F;         &#125;\n&#x2F;&#x2F;         return ct;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\n\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n&#x2F;&#x2F;     int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         if(n &#x3D;&#x3D; 0) return 0;\n&#x2F;&#x2F;         vector&lt;int&gt; dp(n + 1);\n\n&#x2F;&#x2F;         for(int i &#x3D; 1; i &lt; n + 1; ++i) dp[i] &#x3D; dp[i - 1 ] + nums[i - 1];\n\n&#x2F;&#x2F;         int ct &#x3D; 0;\n&#x2F;&#x2F;         for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n&#x2F;&#x2F;             for(int j &#x3D; i; j &lt; n; ++j)\n&#x2F;&#x2F;                 if(k &#x3D;&#x3D; dp[j + 1] - dp[i]) ct++;\n            \n&#x2F;&#x2F;         &#125;\n&#x2F;&#x2F;         return ct;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"AE09Y9","excerpt":"<h2 id=\"560-Subarray-Sum-Equals-K\"><a href=\"#560-Subarray-Sum-Equals-K\" class=\"headerlink\" title=\"560. Subarray Sum Equals K\"></a><a href=\"https://leetcode-cn.com/problems/subarray-sum-equals-k/\">560. Subarray Sum Equals K</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>hash+ 前缀。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        vector&lt;int&gt; dp(n + 1);\n        unordered_map&lt;int, int&gt; map;\n        int ct &#x3D; 0;\n        map[0] &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n + 1; ++i) &#123;\n            dp[i] &#x3D; dp[i - 1 ] + nums[i - 1];\n            ct +&#x3D; map[dp[i] - k];\n            map[dp[i]]++;\n        &#125;\n\n        return ct;\n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;错误二分，数组不保证都为正数\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n&#x2F;&#x2F;     int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         if(n &#x3D;&#x3D; 0) return 0;\n&#x2F;&#x2F;         vector&lt;int&gt; dp(n + 1);\n\n&#x2F;&#x2F;         for(int i &#x3D; 1; i &lt; n + 1; ++i) dp[i] &#x3D; dp[i - 1 ] + nums[i - 1];\n\n&#x2F;&#x2F;         int ct &#x3D; 0;\n&#x2F;&#x2F;         for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n&#x2F;&#x2F;             int r &#x3D; n - 1;\n&#x2F;&#x2F;             int l &#x3D; i;\n&#x2F;&#x2F;             while(l &lt; r)&#123;\n&#x2F;&#x2F;                 int mid &#x3D; (l + r) &#x2F; 2;\n&#x2F;&#x2F;                 if(dp[mid + 1] - dp[i] &gt;&#x3D; k) r &#x3D; mid;\n&#x2F;&#x2F;                 else l &#x3D; mid + 1;\n&#x2F;&#x2F;             &#125;\n&#x2F;&#x2F;             if(l &lt; n &amp;&amp; dp[l + 1] - dp[i] &#x3D;&#x3D; k) ct++;\n&#x2F;&#x2F;         &#125;\n&#x2F;&#x2F;         return ct;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\n\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n&#x2F;&#x2F;     int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         if(n &#x3D;&#x3D; 0) return 0;\n&#x2F;&#x2F;         vector&lt;int&gt; dp(n + 1);\n\n&#x2F;&#x2F;         for(int i &#x3D; 1; i &lt; n + 1; ++i) dp[i] &#x3D; dp[i - 1 ] + nums[i - 1];\n\n&#x2F;&#x2F;         int ct &#x3D; 0;\n&#x2F;&#x2F;         for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n&#x2F;&#x2F;             for(int j &#x3D; i; j &lt; n; ++j)\n&#x2F;&#x2F;                 if(k &#x3D;&#x3D; dp[j + 1] - dp[i]) ct++;\n            \n&#x2F;&#x2F;         &#125;\n&#x2F;&#x2F;         return ct;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"566. Reshape the Matrix","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-30T07:12:10.000Z","_content":"\n\n\n\n## [566. Reshape the Matrix](https://leetcode-cn.com/problems/reshape-the-matrix/)\n\n\n\n\n\n## 思路：\n\n\n\n> 从今天起，有些水题就不写了。浪费时间了。\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    class Iter{\n        \n        int i ,j;\n        int n, m;\n    public:\n        vector<vector<int>> &nums;\n        // Iter(vector<vector<int>> &_nums): nums(_nums){\n        Iter(vector<vector<int>> &_nums): nums(_nums){\n            i =0, j = 0;\n            n = nums.size();\n            m = (n == 0) ? 0 : nums[0].size();\n        }\n        bool empty(){\n            return i > n - 1 || i == n - 1 && j > m - 1;\n        }\n\n        int& next(){\n            if(j == m){\n                j = 0;\n                i = i + 1;\n            }\n            // cout << nums[i][j] << endl;\n            return nums[i][j++];\n        }\n        \n    };\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\n        if(nums.size() == 0 || nums.size() * nums[0].size() != r * c)\n            return vector<vector<int>>(nums);\n        int n = nums.size();\n        int m = nums[0].size();\n\n        vector<vector<int>> mat(r, vector<int>(c));\n        Iter p1(nums), p2(mat);\n        while(!p1.empty()){\n            p2.next() = p1.next();\n        }\n        // cout << p1.nums[0][0] << endl;\n        // cout << p2.nums[0][0] << endl;\n        return p2.nums;\n    }\n};\n```","source":"_posts/刷题/其他/566-Reshape-the-Matrix.md","raw":"---\ntitle: 566. Reshape the Matrix\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-01-30 15:12:10\ntags:\ncategories:\n---\n\n\n\n\n## [566. Reshape the Matrix](https://leetcode-cn.com/problems/reshape-the-matrix/)\n\n\n\n\n\n## 思路：\n\n\n\n> 从今天起，有些水题就不写了。浪费时间了。\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    class Iter{\n        \n        int i ,j;\n        int n, m;\n    public:\n        vector<vector<int>> &nums;\n        // Iter(vector<vector<int>> &_nums): nums(_nums){\n        Iter(vector<vector<int>> &_nums): nums(_nums){\n            i =0, j = 0;\n            n = nums.size();\n            m = (n == 0) ? 0 : nums[0].size();\n        }\n        bool empty(){\n            return i > n - 1 || i == n - 1 && j > m - 1;\n        }\n\n        int& next(){\n            if(j == m){\n                j = 0;\n                i = i + 1;\n            }\n            // cout << nums[i][j] << endl;\n            return nums[i][j++];\n        }\n        \n    };\n    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {\n        if(nums.size() == 0 || nums.size() * nums[0].size() != r * c)\n            return vector<vector<int>>(nums);\n        int n = nums.size();\n        int m = nums[0].size();\n\n        vector<vector<int>> mat(r, vector<int>(c));\n        Iter p1(nums), p2(mat);\n        while(!p1.empty()){\n            p2.next() = p1.next();\n        }\n        // cout << p1.nums[0][0] << endl;\n        // cout << p2.nums[0][0] << endl;\n        return p2.nums;\n    }\n};\n```","slug":"刷题/其他/566-Reshape-the-Matrix","published":1,"updated":"2021-01-30T07:13:17.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4m0020l5uo8ks3f8ht","content":"<h2 id=\"566-Reshape-the-Matrix\"><a href=\"#566-Reshape-the-Matrix\" class=\"headerlink\" title=\"566. Reshape the Matrix\"></a><a href=\"https://leetcode-cn.com/problems/reshape-the-matrix/\">566. Reshape the Matrix</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><blockquote>\n<p>从今天起，有些水题就不写了。浪费时间了。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    class Iter&#123;\n        \n        int i ,j;\n        int n, m;\n    public:\n        vector&lt;vector&lt;int&gt;&gt; &amp;nums;\n        &#x2F;&#x2F; Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums)&#123;\n        Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums)&#123;\n            i &#x3D;0, j &#x3D; 0;\n            n &#x3D; nums.size();\n            m &#x3D; (n &#x3D;&#x3D; 0) ? 0 : nums[0].size();\n        &#125;\n        bool empty()&#123;\n            return i &gt; n - 1 || i &#x3D;&#x3D; n - 1 &amp;&amp; j &gt; m - 1;\n        &#125;\n\n        int&amp; next()&#123;\n            if(j &#x3D;&#x3D; m)&#123;\n                j &#x3D; 0;\n                i &#x3D; i + 1;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; nums[i][j] &lt;&lt; endl;\n            return nums[i][j++];\n        &#125;\n        \n    &#125;;\n    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123;\n        if(nums.size() &#x3D;&#x3D; 0 || nums.size() * nums[0].size() !&#x3D; r * c)\n            return vector&lt;vector&lt;int&gt;&gt;(nums);\n        int n &#x3D; nums.size();\n        int m &#x3D; nums[0].size();\n\n        vector&lt;vector&lt;int&gt;&gt; mat(r, vector&lt;int&gt;(c));\n        Iter p1(nums), p2(mat);\n        while(!p1.empty())&#123;\n            p2.next() &#x3D; p1.next();\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; p1.nums[0][0] &lt;&lt; endl;\n        &#x2F;&#x2F; cout &lt;&lt; p2.nums[0][0] &lt;&lt; endl;\n        return p2.nums;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"13G3E7T","excerpt":"<h2 id=\"566-Reshape-the-Matrix\"><a href=\"#566-Reshape-the-Matrix\" class=\"headerlink\" title=\"566. Reshape the Matrix\"></a><a href=\"https://leetcode-cn.com/problems/reshape-the-matrix/\">566. Reshape the Matrix</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><blockquote>\n<p>从今天起，有些水题就不写了。浪费时间了。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    class Iter&#123;\n        \n        int i ,j;\n        int n, m;\n    public:\n        vector&lt;vector&lt;int&gt;&gt; &amp;nums;\n        &#x2F;&#x2F; Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums)&#123;\n        Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums)&#123;\n            i &#x3D;0, j &#x3D; 0;\n            n &#x3D; nums.size();\n            m &#x3D; (n &#x3D;&#x3D; 0) ? 0 : nums[0].size();\n        &#125;\n        bool empty()&#123;\n            return i &gt; n - 1 || i &#x3D;&#x3D; n - 1 &amp;&amp; j &gt; m - 1;\n        &#125;\n\n        int&amp; next()&#123;\n            if(j &#x3D;&#x3D; m)&#123;\n                j &#x3D; 0;\n                i &#x3D; i + 1;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; nums[i][j] &lt;&lt; endl;\n            return nums[i][j++];\n        &#125;\n        \n    &#125;;\n    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) &#123;\n        if(nums.size() &#x3D;&#x3D; 0 || nums.size() * nums[0].size() !&#x3D; r * c)\n            return vector&lt;vector&lt;int&gt;&gt;(nums);\n        int n &#x3D; nums.size();\n        int m &#x3D; nums[0].size();\n\n        vector&lt;vector&lt;int&gt;&gt; mat(r, vector&lt;int&gt;(c));\n        Iter p1(nums), p2(mat);\n        while(!p1.empty())&#123;\n            p2.next() &#x3D; p1.next();\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; p1.nums[0][0] &lt;&lt; endl;\n        &#x2F;&#x2F; cout &lt;&lt; p2.nums[0][0] &lt;&lt; endl;\n        return p2.nums;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"605. Can Place Flowers","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-13T00:26:22.000Z","_content":"\n<!-- more -->\n\n\n\n#### [605. Can Place Flowers](https://leetcode-cn.com/problems/can-place-flowers/)\n\n这题还是典型的贪心，不过写的时候nt；\n\n## 思路：\n\n用贪心的策略尽可能先种花，这种策略不会影响结果。只需要在遍历下考虑两边和边界情况就行了。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int res = 0, fn = flowerbed.size();\n\n        for(int i = 0; i < flowerbed.size(); ++i){\n            if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (fn - 1 == i ||flowerbed[i + 1] == 0 )){\n                 ++res;\n                 flowerbed[i] = 1;\n             }\n\n        }\n        return res >= n;\n    }\n};\n```\n\n版本二：\n\n```c++\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int res = 0, fn = flowerbed.size();\n        if(fn == 1 && flowerbed[0] == 0)\n            return n <= 1;\n        for(int i = 0; i < flowerbed.size(); ++i){\n            if(flowerbed[i] == 0 &&\n             ( i == 0 && flowerbed[1] == 0 || i == (fn - 1) && flowerbed[fn - 2] == 0 || (i < fn - 1 && i > 0 && flowerbed[i -1] ==0 && flowerbed[i + 1] == 0))){\n                 ++res;\n                 flowerbed[i] = 1;\n             }\n\n        }\n        return res >= n;\n    }\n};\n```\n\n","source":"_posts/刷题/其他/605-Can-Place-Flowers.md","raw":"---\ntitle: 605. Can Place Flowers\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-10-13 08:26:22\ntags:\n---\n\n<!-- more -->\n\n\n\n#### [605. Can Place Flowers](https://leetcode-cn.com/problems/can-place-flowers/)\n\n这题还是典型的贪心，不过写的时候nt；\n\n## 思路：\n\n用贪心的策略尽可能先种花，这种策略不会影响结果。只需要在遍历下考虑两边和边界情况就行了。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int res = 0, fn = flowerbed.size();\n\n        for(int i = 0; i < flowerbed.size(); ++i){\n            if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (fn - 1 == i ||flowerbed[i + 1] == 0 )){\n                 ++res;\n                 flowerbed[i] = 1;\n             }\n\n        }\n        return res >= n;\n    }\n};\n```\n\n版本二：\n\n```c++\nclass Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int res = 0, fn = flowerbed.size();\n        if(fn == 1 && flowerbed[0] == 0)\n            return n <= 1;\n        for(int i = 0; i < flowerbed.size(); ++i){\n            if(flowerbed[i] == 0 &&\n             ( i == 0 && flowerbed[1] == 0 || i == (fn - 1) && flowerbed[fn - 2] == 0 || (i < fn - 1 && i > 0 && flowerbed[i -1] ==0 && flowerbed[i + 1] == 0))){\n                 ++res;\n                 flowerbed[i] = 1;\n             }\n\n        }\n        return res >= n;\n    }\n};\n```\n\n","slug":"刷题/其他/605-Can-Place-Flowers","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4n0021l5uoejkg1shg","content":"<span id=\"more\"></span>\n\n\n\n<h4 id=\"605-Can-Place-Flowers\"><a href=\"#605-Can-Place-Flowers\" class=\"headerlink\" title=\"605. Can Place Flowers\"></a><a href=\"https://leetcode-cn.com/problems/can-place-flowers/\">605. Can Place Flowers</a></h4><p>这题还是典型的贪心，不过写的时候nt；</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用贪心的策略尽可能先种花，这种策略不会影响结果。只需要在遍历下考虑两边和边界情况就行了。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;\n        int res &#x3D; 0, fn &#x3D; flowerbed.size();\n\n        for(int i &#x3D; 0; i &lt; flowerbed.size(); ++i)&#123;\n            if(flowerbed[i] &#x3D;&#x3D; 0 &amp;&amp; (i &#x3D;&#x3D; 0 || flowerbed[i - 1] &#x3D;&#x3D; 0) &amp;&amp; (fn - 1 &#x3D;&#x3D; i ||flowerbed[i + 1] &#x3D;&#x3D; 0 ))&#123;\n                 ++res;\n                 flowerbed[i] &#x3D; 1;\n             &#125;\n\n        &#125;\n        return res &gt;&#x3D; n;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>版本二：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;\n        int res &#x3D; 0, fn &#x3D; flowerbed.size();\n        if(fn &#x3D;&#x3D; 1 &amp;&amp; flowerbed[0] &#x3D;&#x3D; 0)\n            return n &lt;&#x3D; 1;\n        for(int i &#x3D; 0; i &lt; flowerbed.size(); ++i)&#123;\n            if(flowerbed[i] &#x3D;&#x3D; 0 &amp;&amp;\n             ( i &#x3D;&#x3D; 0 &amp;&amp; flowerbed[1] &#x3D;&#x3D; 0 || i &#x3D;&#x3D; (fn - 1) &amp;&amp; flowerbed[fn - 2] &#x3D;&#x3D; 0 || (i &lt; fn - 1 &amp;&amp; i &gt; 0 &amp;&amp; flowerbed[i -1] &#x3D;&#x3D;0 &amp;&amp; flowerbed[i + 1] &#x3D;&#x3D; 0)))&#123;\n                 ++res;\n                 flowerbed[i] &#x3D; 1;\n             &#125;\n\n        &#125;\n        return res &gt;&#x3D; n;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2PYPWTH","excerpt":"","more":"<h4 id=\"605-Can-Place-Flowers\"><a href=\"#605-Can-Place-Flowers\" class=\"headerlink\" title=\"605. Can Place Flowers\"></a><a href=\"https://leetcode-cn.com/problems/can-place-flowers/\">605. Can Place Flowers</a></h4><p>这题还是典型的贪心，不过写的时候nt；</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用贪心的策略尽可能先种花，这种策略不会影响结果。只需要在遍历下考虑两边和边界情况就行了。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;\n        int res &#x3D; 0, fn &#x3D; flowerbed.size();\n\n        for(int i &#x3D; 0; i &lt; flowerbed.size(); ++i)&#123;\n            if(flowerbed[i] &#x3D;&#x3D; 0 &amp;&amp; (i &#x3D;&#x3D; 0 || flowerbed[i - 1] &#x3D;&#x3D; 0) &amp;&amp; (fn - 1 &#x3D;&#x3D; i ||flowerbed[i + 1] &#x3D;&#x3D; 0 ))&#123;\n                 ++res;\n                 flowerbed[i] &#x3D; 1;\n             &#125;\n\n        &#125;\n        return res &gt;&#x3D; n;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>版本二：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;\n        int res &#x3D; 0, fn &#x3D; flowerbed.size();\n        if(fn &#x3D;&#x3D; 1 &amp;&amp; flowerbed[0] &#x3D;&#x3D; 0)\n            return n &lt;&#x3D; 1;\n        for(int i &#x3D; 0; i &lt; flowerbed.size(); ++i)&#123;\n            if(flowerbed[i] &#x3D;&#x3D; 0 &amp;&amp;\n             ( i &#x3D;&#x3D; 0 &amp;&amp; flowerbed[1] &#x3D;&#x3D; 0 || i &#x3D;&#x3D; (fn - 1) &amp;&amp; flowerbed[fn - 2] &#x3D;&#x3D; 0 || (i &lt; fn - 1 &amp;&amp; i &gt; 0 &amp;&amp; flowerbed[i -1] &#x3D;&#x3D;0 &amp;&amp; flowerbed[i + 1] &#x3D;&#x3D; 0)))&#123;\n                 ++res;\n                 flowerbed[i] &#x3D; 1;\n             &#125;\n\n        &#125;\n        return res &gt;&#x3D; n;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"697. Degree of an Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-11T00:28:27.000Z","_content":"\n\n\n#### [697. Degree of an Array](https://leetcode-cn.com/problems/degree-of-an-array/)\n\n## 思路：\n\n简单遍历，不过数据给的水，可以稍稍放松一下遍历的范围，就不用写这么长了0\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findShortestSubArray(vector<int>& nums) {\n        map<int, int> s ,e, fre;\n        int maxfre = 1;\n        vector<int> maxnum(1, nums[0]);\n        for(int i = 0; i < nums.size(); i++){\n            int t = nums[i];\n            if(fre[t] == 0){\n                s[t] = i;\n                \n            }\n            fre[t]++;\n\n            if(maxfre < fre[t]){\n                maxfre = fre[t];\n                maxnum.clear();\n                maxnum.push_back(t);\n            }else if(maxfre == fre[t])\n                maxnum.push_back(t);\n            e[t] = i;\n        } \n\n        int lens = 0x0fffffff;\n        for(int i = 0;i < maxnum.size(); i++){\n            lens = min(e[maxnum[i]] - s[maxnum[i]] + 1, lens);\n        }\n        return lens;\n    }\n};\n```","source":"_posts/刷题/其他/697-Degree-of-an-Array.md","raw":"---\ntitle: 697. Degree of an Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-10-11 08:28:27\ntags:\n---\n\n\n\n#### [697. Degree of an Array](https://leetcode-cn.com/problems/degree-of-an-array/)\n\n## 思路：\n\n简单遍历，不过数据给的水，可以稍稍放松一下遍历的范围，就不用写这么长了0\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findShortestSubArray(vector<int>& nums) {\n        map<int, int> s ,e, fre;\n        int maxfre = 1;\n        vector<int> maxnum(1, nums[0]);\n        for(int i = 0; i < nums.size(); i++){\n            int t = nums[i];\n            if(fre[t] == 0){\n                s[t] = i;\n                \n            }\n            fre[t]++;\n\n            if(maxfre < fre[t]){\n                maxfre = fre[t];\n                maxnum.clear();\n                maxnum.push_back(t);\n            }else if(maxfre == fre[t])\n                maxnum.push_back(t);\n            e[t] = i;\n        } \n\n        int lens = 0x0fffffff;\n        for(int i = 0;i < maxnum.size(); i++){\n            lens = min(e[maxnum[i]] - s[maxnum[i]] + 1, lens);\n        }\n        return lens;\n    }\n};\n```","slug":"刷题/其他/697-Degree-of-an-Array","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4p0022l5uohy0kauaw","content":"<h4 id=\"697-Degree-of-an-Array\"><a href=\"#697-Degree-of-an-Array\" class=\"headerlink\" title=\"697. Degree of an Array\"></a><a href=\"https://leetcode-cn.com/problems/degree-of-an-array/\">697. Degree of an Array</a></h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>简单遍历，不过数据给的水，可以稍稍放松一下遍历的范围，就不用写这么长了0</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        map&lt;int, int&gt; s ,e, fre;\n        int maxfre &#x3D; 1;\n        vector&lt;int&gt; maxnum(1, nums[0]);\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n            int t &#x3D; nums[i];\n            if(fre[t] &#x3D;&#x3D; 0)&#123;\n                s[t] &#x3D; i;\n                \n            &#125;\n            fre[t]++;\n\n            if(maxfre &lt; fre[t])&#123;\n                maxfre &#x3D; fre[t];\n                maxnum.clear();\n                maxnum.push_back(t);\n            &#125;else if(maxfre &#x3D;&#x3D; fre[t])\n                maxnum.push_back(t);\n            e[t] &#x3D; i;\n        &#125; \n\n        int lens &#x3D; 0x0fffffff;\n        for(int i &#x3D; 0;i &lt; maxnum.size(); i++)&#123;\n            lens &#x3D; min(e[maxnum[i]] - s[maxnum[i]] + 1, lens);\n        &#125;\n        return lens;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"KRBYR9","excerpt":"<h4 id=\"697-Degree-of-an-Array\"><a href=\"#697-Degree-of-an-Array\" class=\"headerlink\" title=\"697. Degree of an Array\"></a><a href=\"https://leetcode-cn.com/problems/degree-of-an-array/\">697. Degree of an Array</a></h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>简单遍历，不过数据给的水，可以稍稍放松一下遍历的范围，就不用写这么长了0</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123;\n        map&lt;int, int&gt; s ,e, fre;\n        int maxfre &#x3D; 1;\n        vector&lt;int&gt; maxnum(1, nums[0]);\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n            int t &#x3D; nums[i];\n            if(fre[t] &#x3D;&#x3D; 0)&#123;\n                s[t] &#x3D; i;\n                \n            &#125;\n            fre[t]++;\n\n            if(maxfre &lt; fre[t])&#123;\n                maxfre &#x3D; fre[t];\n                maxnum.clear();\n                maxnum.push_back(t);\n            &#125;else if(maxfre &#x3D;&#x3D; fre[t])\n                maxnum.push_back(t);\n            e[t] &#x3D; i;\n        &#125; \n\n        int lens &#x3D; 0x0fffffff;\n        for(int i &#x3D; 0;i &lt; maxnum.size(); i++)&#123;\n            lens &#x3D; min(e[maxnum[i]] - s[maxnum[i]] + 1, lens);\n        &#125;\n        return lens;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"747. Largest Number At Least Twice of Others","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-09-24T01:05:25.000Z","_content":"\n#### [747. Largest Number At Least Twice of Others](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/)\n\n<!-- more -->\n\nEZ\n\n## 思路：\n\n沙雕题目。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int dominantIndex(vector<int>& nums) {\n        int numbig = -1, numlitter= -1, idx = -1;\n        if(nums.size() == 1) return 0;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] > numbig){\n                idx = i;\n                numlitter = numbig;\n                numbig = nums[i];\n            }\n            else if(nums[i] > numlitter){\n                numlitter = nums[i];\n            }\n        }\n        if(numbig >= numlitter * 2 ){\n            return idx;\n        }\n        else return -1;\n    }\n};\n```\n\n","source":"_posts/刷题/其他/747-Largest-Number-At-Least-Twice-of-Others.md","raw":"---\ntitle: 747. Largest Number At Least Twice of Others\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-09-24 09:05:25\ntags:\n---\n\n#### [747. Largest Number At Least Twice of Others](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/)\n\n<!-- more -->\n\nEZ\n\n## 思路：\n\n沙雕题目。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int dominantIndex(vector<int>& nums) {\n        int numbig = -1, numlitter= -1, idx = -1;\n        if(nums.size() == 1) return 0;\n        for(int i = 0; i < nums.size(); i++){\n            if(nums[i] > numbig){\n                idx = i;\n                numlitter = numbig;\n                numbig = nums[i];\n            }\n            else if(nums[i] > numlitter){\n                numlitter = nums[i];\n            }\n        }\n        if(numbig >= numlitter * 2 ){\n            return idx;\n        }\n        else return -1;\n    }\n};\n```\n\n","slug":"刷题/其他/747-Largest-Number-At-Least-Twice-of-Others","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4r0023l5uocukufkhb","content":"<h4 id=\"747-Largest-Number-At-Least-Twice-of-Others\"><a href=\"#747-Largest-Number-At-Least-Twice-of-Others\" class=\"headerlink\" title=\"747. Largest Number At Least Twice of Others\"></a><a href=\"https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/\">747. Largest Number At Least Twice of Others</a></h4><span id=\"more\"></span>\n\n<p>EZ</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>沙雕题目。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dominantIndex(vector&lt;int&gt;&amp; nums) &#123;\n        int numbig &#x3D; -1, numlitter&#x3D; -1, idx &#x3D; -1;\n        if(nums.size() &#x3D;&#x3D; 1) return 0;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n            if(nums[i] &gt; numbig)&#123;\n                idx &#x3D; i;\n                numlitter &#x3D; numbig;\n                numbig &#x3D; nums[i];\n            &#125;\n            else if(nums[i] &gt; numlitter)&#123;\n                numlitter &#x3D; nums[i];\n            &#125;\n        &#125;\n        if(numbig &gt;&#x3D; numlitter * 2 )&#123;\n            return idx;\n        &#125;\n        else return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"68Q4E1","excerpt":"<h4 id=\"747-Largest-Number-At-Least-Twice-of-Others\"><a href=\"#747-Largest-Number-At-Least-Twice-of-Others\" class=\"headerlink\" title=\"747. Largest Number At Least Twice of Others\"></a><a href=\"https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/\">747. Largest Number At Least Twice of Others</a></h4>","more":"<p>EZ</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>沙雕题目。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dominantIndex(vector&lt;int&gt;&amp; nums) &#123;\n        int numbig &#x3D; -1, numlitter&#x3D; -1, idx &#x3D; -1;\n        if(nums.size() &#x3D;&#x3D; 1) return 0;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n            if(nums[i] &gt; numbig)&#123;\n                idx &#x3D; i;\n                numlitter &#x3D; numbig;\n                numbig &#x3D; nums[i];\n            &#125;\n            else if(nums[i] &gt; numlitter)&#123;\n                numlitter &#x3D; nums[i];\n            &#125;\n        &#125;\n        if(numbig &gt;&#x3D; numlitter * 2 )&#123;\n            return idx;\n        &#125;\n        else return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"769. Max Chunks To Make Sorted","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-22T03:31:42.000Z","_content":"\n\n\n## [769. Max Chunks To Make Sorted](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)\n\n\n\n\n\n## 思路：\n\n暴力法。\n\n简单的思路，\n\n从左到右划分chrunk，判断最左边的chrunk最大值，其值+1就是chrunk的size。\n\n依次进行就可以获得多个chrunk的size。<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int split = -1;\n        int num = 0;\n        for(int i = 0; i < arr.size(); ++i){\n            split = arr[i];\n            for(int j = 0; j < split + 1; ++j){\n                split = max(split, arr[j]);\n            }\n            num++;\n            i = split;\n        }\n        return num;\n    }\n};\n```","source":"_posts/刷题/其他/769-Max-Chunks-To-Make-Sorted.md","raw":"---\ntitle: 769. Max Chunks To Make Sorted\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-22 11:31:42\n---\n\n\n\n## [769. Max Chunks To Make Sorted](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)\n\n\n\n\n\n## 思路：\n\n暴力法。\n\n简单的思路，\n\n从左到右划分chrunk，判断最左边的chrunk最大值，其值+1就是chrunk的size。\n\n依次进行就可以获得多个chrunk的size。<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int split = -1;\n        int num = 0;\n        for(int i = 0; i < arr.size(); ++i){\n            split = arr[i];\n            for(int j = 0; j < split + 1; ++j){\n                split = max(split, arr[j]);\n            }\n            num++;\n            i = split;\n        }\n        return num;\n    }\n};\n```","slug":"刷题/其他/769-Max-Chunks-To-Make-Sorted","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4s0024l5uo516k4qyy","content":"<h2 id=\"769-Max-Chunks-To-Make-Sorted\"><a href=\"#769-Max-Chunks-To-Make-Sorted\" class=\"headerlink\" title=\"769. Max Chunks To Make Sorted\"></a><a href=\"https://leetcode-cn.com/problems/max-chunks-to-make-sorted/\">769. Max Chunks To Make Sorted</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>暴力法。</p>\n<p>简单的思路，</p>\n<p>从左到右划分chrunk，判断最左边的chrunk最大值，其值+1就是chrunk的size。</p>\n<p>依次进行就可以获得多个chrunk的size。<span id=\"more\"></span></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxChunksToSorted(vector&lt;int&gt;&amp; arr) &#123;\n        int split &#x3D; -1;\n        int num &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; arr.size(); ++i)&#123;\n            split &#x3D; arr[i];\n            for(int j &#x3D; 0; j &lt; split + 1; ++j)&#123;\n                split &#x3D; max(split, arr[j]);\n            &#125;\n            num++;\n            i &#x3D; split;\n        &#125;\n        return num;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1F0P9S0","excerpt":"<h2 id=\"769-Max-Chunks-To-Make-Sorted\"><a href=\"#769-Max-Chunks-To-Make-Sorted\" class=\"headerlink\" title=\"769. Max Chunks To Make Sorted\"></a><a href=\"https://leetcode-cn.com/problems/max-chunks-to-make-sorted/\">769. Max Chunks To Make Sorted</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>暴力法。</p>\n<p>简单的思路，</p>\n<p>从左到右划分chrunk，判断最左边的chrunk最大值，其值+1就是chrunk的size。</p>\n<p>依次进行就可以获得多个chrunk的size。","more":"</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxChunksToSorted(vector&lt;int&gt;&amp; arr) &#123;\n        int split &#x3D; -1;\n        int num &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; arr.size(); ++i)&#123;\n            split &#x3D; arr[i];\n            for(int j &#x3D; 0; j &lt; split + 1; ++j)&#123;\n                split &#x3D; max(split, arr[j]);\n            &#125;\n            num++;\n            i &#x3D; split;\n        &#125;\n        return num;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"786. 第 K 个最小的素数分数","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:13:32.000Z","_content":"\n\n<!-- more -->\n\n## [786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)\n\n难度hard\n\n### 思路：\n\n明显的有`A[i] < A[j]`，能够推出`A[i]/A[j] > A[i]/A[j+1]`，但是不能推出`A[i+1]/A[j]`和`A[i]/A[j+1]`的关系，毫无用处。\n\n自然可以想到要用堆来维护第K小的数，而然超时。\n\n评论里提出一种二分的方法，\n\n\n\n### 代码：\n\n堆维护数组\n\n```\nstruct cmp{\n    bool operator () (pair<int, int> x, pair<int, int> y){\n        return x.first * 1.0 / x.second  < y.first * 1.0 / y.second;        \n    }\n};\n\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\n        priority_queue<pair<int, int>, vector<pair<int, int> >, cmp> pq;\n        for(int i = 0; i < A.size() - 1; i++){\n            for(int j = i + 1; j < A.size(); j++){\n                double temp = A[i] * 1.0 /  A[j];\n                if(pq.size() < K){\n                    pq.push(make_pair(A[i], A[j]));\n                }else if(pq.top().first * 1.0 / pq.top().second > temp){\n                    pq.pop();\n                    pq.push(make_pair(A[i], A[j]));\n                }\n            }\n        }\n        vector<int> res = vector(2, 0);\n        res[0] = pq.top().first, res[1] = pq.top().second;\n        return res;\n\n    }    \n};\n```","source":"_posts/刷题/其他/786-第-K-个最小的素数分数.md","raw":"---\ntitle: 786. 第 K 个最小的素数分数\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 14:13:32\ntags:\n---\n\n\n<!-- more -->\n\n## [786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)\n\n难度hard\n\n### 思路：\n\n明显的有`A[i] < A[j]`，能够推出`A[i]/A[j] > A[i]/A[j+1]`，但是不能推出`A[i+1]/A[j]`和`A[i]/A[j+1]`的关系，毫无用处。\n\n自然可以想到要用堆来维护第K小的数，而然超时。\n\n评论里提出一种二分的方法，\n\n\n\n### 代码：\n\n堆维护数组\n\n```\nstruct cmp{\n    bool operator () (pair<int, int> x, pair<int, int> y){\n        return x.first * 1.0 / x.second  < y.first * 1.0 / y.second;        \n    }\n};\n\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\n        priority_queue<pair<int, int>, vector<pair<int, int> >, cmp> pq;\n        for(int i = 0; i < A.size() - 1; i++){\n            for(int j = i + 1; j < A.size(); j++){\n                double temp = A[i] * 1.0 /  A[j];\n                if(pq.size() < K){\n                    pq.push(make_pair(A[i], A[j]));\n                }else if(pq.top().first * 1.0 / pq.top().second > temp){\n                    pq.pop();\n                    pq.push(make_pair(A[i], A[j]));\n                }\n            }\n        }\n        vector<int> res = vector(2, 0);\n        res[0] = pq.top().first, res[1] = pq.top().second;\n        return res;\n\n    }    \n};\n```","slug":"刷题/其他/786-第-K-个最小的素数分数","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4t0025l5uoa4jz4n9l","content":"<span id=\"more\"></span>\n\n<h2 id=\"786-第-K-个最小的素数分数\"><a href=\"#786-第-K-个最小的素数分数\" class=\"headerlink\" title=\"786. 第 K 个最小的素数分数\"></a><a href=\"https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/\">786. 第 K 个最小的素数分数</a></h2><p>难度hard</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显的有<code>A[i] &lt; A[j]</code>，能够推出<code>A[i]/A[j] &gt; A[i]/A[j+1]</code>，但是不能推出<code>A[i+1]/A[j]</code>和<code>A[i]/A[j+1]</code>的关系，毫无用处。</p>\n<p>自然可以想到要用堆来维护第K小的数，而然超时。</p>\n<p>评论里提出一种二分的方法，</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>堆维护数组</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct cmp&#123;\n    bool operator () (pair&lt;int, int&gt; x, pair&lt;int, int&gt; y)&#123;\n        return x.first * 1.0 &#x2F; x.second  &lt; y.first * 1.0 &#x2F; y.second;        \n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; kthSmallestPrimeFraction(vector&lt;int&gt;&amp; A, int K) &#123;\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, cmp&gt; pq;\n        for(int i &#x3D; 0; i &lt; A.size() - 1; i++)&#123;\n            for(int j &#x3D; i + 1; j &lt; A.size(); j++)&#123;\n                double temp &#x3D; A[i] * 1.0 &#x2F;  A[j];\n                if(pq.size() &lt; K)&#123;\n                    pq.push(make_pair(A[i], A[j]));\n                &#125;else if(pq.top().first * 1.0 &#x2F; pq.top().second &gt; temp)&#123;\n                    pq.pop();\n                    pq.push(make_pair(A[i], A[j]));\n                &#125;\n            &#125;\n        &#125;\n        vector&lt;int&gt; res &#x3D; vector(2, 0);\n        res[0] &#x3D; pq.top().first, res[1] &#x3D; pq.top().second;\n        return res;\n\n    &#125;    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"0EWH00","excerpt":"","more":"<h2 id=\"786-第-K-个最小的素数分数\"><a href=\"#786-第-K-个最小的素数分数\" class=\"headerlink\" title=\"786. 第 K 个最小的素数分数\"></a><a href=\"https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/\">786. 第 K 个最小的素数分数</a></h2><p>难度hard</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显的有<code>A[i] &lt; A[j]</code>，能够推出<code>A[i]/A[j] &gt; A[i]/A[j+1]</code>，但是不能推出<code>A[i+1]/A[j]</code>和<code>A[i]/A[j+1]</code>的关系，毫无用处。</p>\n<p>自然可以想到要用堆来维护第K小的数，而然超时。</p>\n<p>评论里提出一种二分的方法，</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>堆维护数组</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">struct cmp&#123;\n    bool operator () (pair&lt;int, int&gt; x, pair&lt;int, int&gt; y)&#123;\n        return x.first * 1.0 &#x2F; x.second  &lt; y.first * 1.0 &#x2F; y.second;        \n    &#125;\n&#125;;\n\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; kthSmallestPrimeFraction(vector&lt;int&gt;&amp; A, int K) &#123;\n        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, cmp&gt; pq;\n        for(int i &#x3D; 0; i &lt; A.size() - 1; i++)&#123;\n            for(int j &#x3D; i + 1; j &lt; A.size(); j++)&#123;\n                double temp &#x3D; A[i] * 1.0 &#x2F;  A[j];\n                if(pq.size() &lt; K)&#123;\n                    pq.push(make_pair(A[i], A[j]));\n                &#125;else if(pq.top().first * 1.0 &#x2F; pq.top().second &gt; temp)&#123;\n                    pq.pop();\n                    pq.push(make_pair(A[i], A[j]));\n                &#125;\n            &#125;\n        &#125;\n        vector&lt;int&gt; res &#x3D; vector(2, 0);\n        res[0] &#x3D; pq.top().first, res[1] &#x3D; pq.top().second;\n        return res;\n\n    &#125;    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"79. Word Search","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-26T00:42:40.000Z","_content":"\n\n\n\n\n## [79. Word Search](https://leetcode-cn.com/problems/word-search/)\n\n\n\n\n\n## 思路：\n\n回溯直接k.o.\n\n<!-- more -->\n\n## 代码：\n\n官方\n\n```C++\nclass Solution {\npublic:\n    bool check(vector<vector<char>>& board, vector<vector<int>>& visited, int i, int j, string& s, int k) {\n        if (board[i][j] != s[k]) {\n            return false;\n        } else if (k == s.length() - 1) {\n            return true;\n        }\n        visited[i][j] = true;\n        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        bool result = false;\n        for (const auto& dir: directions) {\n            int newi = i + dir.first, newj = j + dir.second;\n            if (newi >= 0 && newi < board.size() && newj >= 0 && newj < board[0].size()) {\n                if (!visited[newi][newj]) {\n                    bool flag = check(board, visited, newi, newj, s, k + 1);\n                    if (flag) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        visited[i][j] = false;\n        return result;\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n        int h = board.size(), w = board[0].size();\n        vector<vector<int>> visited(h, vector<int>(w));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                bool flag = check(board, visited, i, j, word, 0);\n                if (flag) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\n作者：LeetCode-Solution\n链接：https://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n我滴，不过由于没有把判断条件写在dfs函数入口那，性能显得不太好。\n\n```C++\nclass Solution {\npublic:\n    int m, n;\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    bool dfs(vector<vector<char>>& board, string word, vector<vector<bool>> &vis, int x, int y, int pos){ //BUGS VECTOR &\n        if(x < 0 || y < 0 || x >= m || y >= n || vis[x][y] || pos == word.size()) return false;\n        vis[x][y] = true;\n        cout << x << ' ' << y << endl;        \n        if(board[x][y] == word[pos]){\n            if(pos == word.size() - 1) return true;\n            for(int i = 0;i < 4; ++i){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(dfs(board, word, vis, nx, ny, pos + 1))\n                    return true;\n            }\n        }\n        return false;\n    }   \n    bool exist(vector<vector<char>>& board, string word) {\n        m = board.size();\n        if(m > 0){\n            n = board[0].size();\n        }\n        \n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(word[0] == board[i][j]){\n                    cout << \"i * j\" ;\n                    vector<vector<bool>> vis(m, vector<bool>(n, 0));\n                    if(dfs(board, word, vis, i, j, 0))\n                        return true;\n                }                \n            }\n        }\n        return false;\n    }\n};\n```","source":"_posts/刷题/其他/79-Word-Search.md","raw":"---\ntitle: 79. Word Search\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-11-26 08:42:40\ntags:\n---\n\n\n\n\n\n## [79. Word Search](https://leetcode-cn.com/problems/word-search/)\n\n\n\n\n\n## 思路：\n\n回溯直接k.o.\n\n<!-- more -->\n\n## 代码：\n\n官方\n\n```C++\nclass Solution {\npublic:\n    bool check(vector<vector<char>>& board, vector<vector<int>>& visited, int i, int j, string& s, int k) {\n        if (board[i][j] != s[k]) {\n            return false;\n        } else if (k == s.length() - 1) {\n            return true;\n        }\n        visited[i][j] = true;\n        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        bool result = false;\n        for (const auto& dir: directions) {\n            int newi = i + dir.first, newj = j + dir.second;\n            if (newi >= 0 && newi < board.size() && newj >= 0 && newj < board[0].size()) {\n                if (!visited[newi][newj]) {\n                    bool flag = check(board, visited, newi, newj, s, k + 1);\n                    if (flag) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        visited[i][j] = false;\n        return result;\n    }\n\n    bool exist(vector<vector<char>>& board, string word) {\n        int h = board.size(), w = board[0].size();\n        vector<vector<int>> visited(h, vector<int>(w));\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                bool flag = check(board, visited, i, j, word, 0);\n                if (flag) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\n作者：LeetCode-Solution\n链接：https://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n\n\n我滴，不过由于没有把判断条件写在dfs函数入口那，性能显得不太好。\n\n```C++\nclass Solution {\npublic:\n    int m, n;\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    bool dfs(vector<vector<char>>& board, string word, vector<vector<bool>> &vis, int x, int y, int pos){ //BUGS VECTOR &\n        if(x < 0 || y < 0 || x >= m || y >= n || vis[x][y] || pos == word.size()) return false;\n        vis[x][y] = true;\n        cout << x << ' ' << y << endl;        \n        if(board[x][y] == word[pos]){\n            if(pos == word.size() - 1) return true;\n            for(int i = 0;i < 4; ++i){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(dfs(board, word, vis, nx, ny, pos + 1))\n                    return true;\n            }\n        }\n        return false;\n    }   \n    bool exist(vector<vector<char>>& board, string word) {\n        m = board.size();\n        if(m > 0){\n            n = board[0].size();\n        }\n        \n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(word[0] == board[i][j]){\n                    cout << \"i * j\" ;\n                    vector<vector<bool>> vis(m, vector<bool>(n, 0));\n                    if(dfs(board, word, vis, i, j, 0))\n                        return true;\n                }                \n            }\n        }\n        return false;\n    }\n};\n```","slug":"刷题/其他/79-Word-Search","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4u0026l5uo28z384jw","content":"<h2 id=\"79-Word-Search\"><a href=\"#79-Word-Search\" class=\"headerlink\" title=\"79. Word Search\"></a><a href=\"https://leetcode-cn.com/problems/word-search/\">79. Word Search</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯直接k.o.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>官方</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool check(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; s, int k) &#123;\n        if (board[i][j] !&#x3D; s[k]) &#123;\n            return false;\n        &#125; else if (k &#x3D;&#x3D; s.length() - 1) &#123;\n            return true;\n        &#125;\n        visited[i][j] &#x3D; true;\n        vector&lt;pair&lt;int, int&gt;&gt; directions&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;\n        bool result &#x3D; false;\n        for (const auto&amp; dir: directions) &#123;\n            int newi &#x3D; i + dir.first, newj &#x3D; j + dir.second;\n            if (newi &gt;&#x3D; 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;&#x3D; 0 &amp;&amp; newj &lt; board[0].size()) &#123;\n                if (!visited[newi][newj]) &#123;\n                    bool flag &#x3D; check(board, visited, newi, newj, s, k + 1);\n                    if (flag) &#123;\n                        result &#x3D; true;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        visited[i][j] &#x3D; false;\n        return result;\n    &#125;\n\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;\n        int h &#x3D; board.size(), w &#x3D; board[0].size();\n        vector&lt;vector&lt;int&gt;&gt; visited(h, vector&lt;int&gt;(w));\n        for (int i &#x3D; 0; i &lt; h; i++) &#123;\n            for (int j &#x3D; 0; j &lt; w; j++) &#123;\n                bool flag &#x3D; check(board, visited, i, j, word, 0);\n                if (flag) &#123;\n                    return true;\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n作者：LeetCode-Solution\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;word-search&#x2F;solution&#x2F;dan-ci-sou-suo-by-leetcode-solution&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>我滴，不过由于没有把判断条件写在dfs函数入口那，性能显得不太好。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int m, n;\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, vector&lt;vector&lt;bool&gt;&gt; &amp;vis, int x, int y, int pos)&#123; &#x2F;&#x2F;BUGS VECTOR &amp;\n        if(x &lt; 0 || y &lt; 0 || x &gt;&#x3D; m || y &gt;&#x3D; n || vis[x][y] || pos &#x3D;&#x3D; word.size()) return false;\n        vis[x][y] &#x3D; true;\n        cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;        \n        if(board[x][y] &#x3D;&#x3D; word[pos])&#123;\n            if(pos &#x3D;&#x3D; word.size() - 1) return true;\n            for(int i &#x3D; 0;i &lt; 4; ++i)&#123;\n                int nx &#x3D; x + dx[i];\n                int ny &#x3D; y + dy[i];\n                if(dfs(board, word, vis, nx, ny, pos + 1))\n                    return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;   \n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;\n        m &#x3D; board.size();\n        if(m &gt; 0)&#123;\n            n &#x3D; board[0].size();\n        &#125;\n        \n        for(int i &#x3D; 0; i &lt; m; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(word[0] &#x3D;&#x3D; board[i][j])&#123;\n                    cout &lt;&lt; &quot;i * j&quot; ;\n                    vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, 0));\n                    if(dfs(board, word, vis, i, j, 0))\n                        return true;\n                &#125;                \n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3HE47M3","excerpt":"<h2 id=\"79-Word-Search\"><a href=\"#79-Word-Search\" class=\"headerlink\" title=\"79. Word Search\"></a><a href=\"https://leetcode-cn.com/problems/word-search/\">79. Word Search</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯直接k.o.</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>官方</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    bool check(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; s, int k) &#123;\n        if (board[i][j] !&#x3D; s[k]) &#123;\n            return false;\n        &#125; else if (k &#x3D;&#x3D; s.length() - 1) &#123;\n            return true;\n        &#125;\n        visited[i][j] &#x3D; true;\n        vector&lt;pair&lt;int, int&gt;&gt; directions&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;\n        bool result &#x3D; false;\n        for (const auto&amp; dir: directions) &#123;\n            int newi &#x3D; i + dir.first, newj &#x3D; j + dir.second;\n            if (newi &gt;&#x3D; 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;&#x3D; 0 &amp;&amp; newj &lt; board[0].size()) &#123;\n                if (!visited[newi][newj]) &#123;\n                    bool flag &#x3D; check(board, visited, newi, newj, s, k + 1);\n                    if (flag) &#123;\n                        result &#x3D; true;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        visited[i][j] &#x3D; false;\n        return result;\n    &#125;\n\n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;\n        int h &#x3D; board.size(), w &#x3D; board[0].size();\n        vector&lt;vector&lt;int&gt;&gt; visited(h, vector&lt;int&gt;(w));\n        for (int i &#x3D; 0; i &lt; h; i++) &#123;\n            for (int j &#x3D; 0; j &lt; w; j++) &#123;\n                bool flag &#x3D; check(board, visited, i, j, word, 0);\n                if (flag) &#123;\n                    return true;\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n\n作者：LeetCode-Solution\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;word-search&#x2F;solution&#x2F;dan-ci-sou-suo-by-leetcode-solution&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>我滴，不过由于没有把判断条件写在dfs函数入口那，性能显得不太好。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    int m, n;\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, vector&lt;vector&lt;bool&gt;&gt; &amp;vis, int x, int y, int pos)&#123; &#x2F;&#x2F;BUGS VECTOR &amp;\n        if(x &lt; 0 || y &lt; 0 || x &gt;&#x3D; m || y &gt;&#x3D; n || vis[x][y] || pos &#x3D;&#x3D; word.size()) return false;\n        vis[x][y] &#x3D; true;\n        cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;        \n        if(board[x][y] &#x3D;&#x3D; word[pos])&#123;\n            if(pos &#x3D;&#x3D; word.size() - 1) return true;\n            for(int i &#x3D; 0;i &lt; 4; ++i)&#123;\n                int nx &#x3D; x + dx[i];\n                int ny &#x3D; y + dy[i];\n                if(dfs(board, word, vis, nx, ny, pos + 1))\n                    return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;   \n    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;\n        m &#x3D; board.size();\n        if(m &gt; 0)&#123;\n            n &#x3D; board[0].size();\n        &#125;\n        \n        for(int i &#x3D; 0; i &lt; m; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(word[0] &#x3D;&#x3D; board[i][j])&#123;\n                    cout &lt;&lt; &quot;i * j&quot; ;\n                    vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, 0));\n                    if(dfs(board, word, vis, i, j, 0))\n                        return true;\n                &#125;                \n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"833.字符串中的查找与替换","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:11:15.000Z","_content":"\n\n<!-- more -->\n\n中等题\n\n这题坑还是很多的，如输入数据非有序，考虑在同一字符串插入时多个字符串替换时原字符串的下标维持或是可插入性。\n\n**思路1:**\n\n将indexes所标记出的下标映射为输入数据的次序，在排序indexes来有序遍历S。之后就是判断哪些S的字母可以替换并替换。\n\n**思路2（官方）：**\n\n为了顺序地构造目标字符串，先标记出S中所有可替换的位置，并顺序遍历（逆序或者正序都可以，构造方法不同罢了）。\n\n\n\n依据题意，可以推出从后向前替换，可以避免下标变换的问题。\n\n```\nclass Solution {\npublic:\n    //题目没看清,多写了一个转化大小写函数\n    string lowercase(string S){\n        // return A iterator;\n        std::transform(S.begin(), S.end(), S.begin(), [](unsigned char c){return std::tolower(c);} );\n        return S;\n    }\n    //思路1 \n    string findReplaceString(string S, vector<int>& indexes, vector<string>& sources, vector<string>& targets) {\n        int idx2 = indexes.size() - 1;\n        vector<int> repl( indexes.size() );\n        //将排序后的字符串下标映射回原来的下标\n            //同时不能 把排序后的index下标映射或者被映射;\n        map<int, int> match;        \n        for(int i=0;i<indexes.size();i++) \n            match[ indexes[i] ] = i;\n        sort(indexes.begin(), indexes.end());\n        //判断逆序判断能否替换，若可以则逆序替换；  \n        //逆序替换不影响之前的可替换性判断\n        for(int i=S.size()-1;i>=0 && idx2 >=0 ;i--){\n            if(i == indexes[idx2]){\n                if(lowercase( S.substr(i, sources[match[i]].size())) == sources[match[i]] )                \n                    S.replace(i, sources[match[i]].size(), targets[match[i]]);    \n                idx2 --;                \n            }\n        }\n\n        return S;\n    }\n    \n    // 思路2：官方解的实现，也是空间换时间\n    string findReplaceString(string S, vector<int>& indexes, vector<string>& sources, vector<string>& targets) {\n        //对S每个字母对有效替换的判断, 并记录下标\n        vector<int> match(S.size(), -1);\n        for(int i=0 ;i<indexes.size();i++){\n            if( S.substr(indexes[i], sources[i].size()) == sources[i])\n                match[ indexes[i] ] = i;\n        }\n\n        //判断逆序判断能否替换，若可以则逆序替换；          \n        for(int i=S.size()-1;i>=0 ;i--){\n            if(match[i] != -1){\n                S.replace(i, sources[match[i]].size(), targets[match[i]] );\n            }\n            cout<< S << endl;\n        }\n\n        return S;\n    }\n    \n};\n```","source":"_posts/刷题/其他/833-字符串中的查找与替换.md","raw":"---\ntitle: 833.字符串中的查找与替换\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 14:11:15\ntags:\n---\n\n\n<!-- more -->\n\n中等题\n\n这题坑还是很多的，如输入数据非有序，考虑在同一字符串插入时多个字符串替换时原字符串的下标维持或是可插入性。\n\n**思路1:**\n\n将indexes所标记出的下标映射为输入数据的次序，在排序indexes来有序遍历S。之后就是判断哪些S的字母可以替换并替换。\n\n**思路2（官方）：**\n\n为了顺序地构造目标字符串，先标记出S中所有可替换的位置，并顺序遍历（逆序或者正序都可以，构造方法不同罢了）。\n\n\n\n依据题意，可以推出从后向前替换，可以避免下标变换的问题。\n\n```\nclass Solution {\npublic:\n    //题目没看清,多写了一个转化大小写函数\n    string lowercase(string S){\n        // return A iterator;\n        std::transform(S.begin(), S.end(), S.begin(), [](unsigned char c){return std::tolower(c);} );\n        return S;\n    }\n    //思路1 \n    string findReplaceString(string S, vector<int>& indexes, vector<string>& sources, vector<string>& targets) {\n        int idx2 = indexes.size() - 1;\n        vector<int> repl( indexes.size() );\n        //将排序后的字符串下标映射回原来的下标\n            //同时不能 把排序后的index下标映射或者被映射;\n        map<int, int> match;        \n        for(int i=0;i<indexes.size();i++) \n            match[ indexes[i] ] = i;\n        sort(indexes.begin(), indexes.end());\n        //判断逆序判断能否替换，若可以则逆序替换；  \n        //逆序替换不影响之前的可替换性判断\n        for(int i=S.size()-1;i>=0 && idx2 >=0 ;i--){\n            if(i == indexes[idx2]){\n                if(lowercase( S.substr(i, sources[match[i]].size())) == sources[match[i]] )                \n                    S.replace(i, sources[match[i]].size(), targets[match[i]]);    \n                idx2 --;                \n            }\n        }\n\n        return S;\n    }\n    \n    // 思路2：官方解的实现，也是空间换时间\n    string findReplaceString(string S, vector<int>& indexes, vector<string>& sources, vector<string>& targets) {\n        //对S每个字母对有效替换的判断, 并记录下标\n        vector<int> match(S.size(), -1);\n        for(int i=0 ;i<indexes.size();i++){\n            if( S.substr(indexes[i], sources[i].size()) == sources[i])\n                match[ indexes[i] ] = i;\n        }\n\n        //判断逆序判断能否替换，若可以则逆序替换；          \n        for(int i=S.size()-1;i>=0 ;i--){\n            if(match[i] != -1){\n                S.replace(i, sources[match[i]].size(), targets[match[i]] );\n            }\n            cout<< S << endl;\n        }\n\n        return S;\n    }\n    \n};\n```","slug":"刷题/其他/833-字符串中的查找与替换","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4v0027l5uohar8byxt","content":"<span id=\"more\"></span>\n\n<p>中等题</p>\n<p>这题坑还是很多的，如输入数据非有序，考虑在同一字符串插入时多个字符串替换时原字符串的下标维持或是可插入性。</p>\n<p><strong>思路1:</strong></p>\n<p>将indexes所标记出的下标映射为输入数据的次序，在排序indexes来有序遍历S。之后就是判断哪些S的字母可以替换并替换。</p>\n<p><strong>思路2（官方）：</strong></p>\n<p>为了顺序地构造目标字符串，先标记出S中所有可替换的位置，并顺序遍历（逆序或者正序都可以，构造方法不同罢了）。</p>\n<p>依据题意，可以推出从后向前替换，可以避免下标变换的问题。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;题目没看清,多写了一个转化大小写函数\n    string lowercase(string S)&#123;\n        &#x2F;&#x2F; return A iterator;\n        std::transform(S.begin(), S.end(), S.begin(), [](unsigned char c)&#123;return std::tolower(c);&#125; );\n        return S;\n    &#125;\n    &#x2F;&#x2F;思路1 \n    string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) &#123;\n        int idx2 &#x3D; indexes.size() - 1;\n        vector&lt;int&gt; repl( indexes.size() );\n        &#x2F;&#x2F;将排序后的字符串下标映射回原来的下标\n            &#x2F;&#x2F;同时不能 把排序后的index下标映射或者被映射;\n        map&lt;int, int&gt; match;        \n        for(int i&#x3D;0;i&lt;indexes.size();i++) \n            match[ indexes[i] ] &#x3D; i;\n        sort(indexes.begin(), indexes.end());\n        &#x2F;&#x2F;判断逆序判断能否替换，若可以则逆序替换；  \n        &#x2F;&#x2F;逆序替换不影响之前的可替换性判断\n        for(int i&#x3D;S.size()-1;i&gt;&#x3D;0 &amp;&amp; idx2 &gt;&#x3D;0 ;i--)&#123;\n            if(i &#x3D;&#x3D; indexes[idx2])&#123;\n                if(lowercase( S.substr(i, sources[match[i]].size())) &#x3D;&#x3D; sources[match[i]] )                \n                    S.replace(i, sources[match[i]].size(), targets[match[i]]);    \n                idx2 --;                \n            &#125;\n        &#125;\n\n        return S;\n    &#125;\n    \n    &#x2F;&#x2F; 思路2：官方解的实现，也是空间换时间\n    string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) &#123;\n        &#x2F;&#x2F;对S每个字母对有效替换的判断, 并记录下标\n        vector&lt;int&gt; match(S.size(), -1);\n        for(int i&#x3D;0 ;i&lt;indexes.size();i++)&#123;\n            if( S.substr(indexes[i], sources[i].size()) &#x3D;&#x3D; sources[i])\n                match[ indexes[i] ] &#x3D; i;\n        &#125;\n\n        &#x2F;&#x2F;判断逆序判断能否替换，若可以则逆序替换；          \n        for(int i&#x3D;S.size()-1;i&gt;&#x3D;0 ;i--)&#123;\n            if(match[i] !&#x3D; -1)&#123;\n                S.replace(i, sources[match[i]].size(), targets[match[i]] );\n            &#125;\n            cout&lt;&lt; S &lt;&lt; endl;\n        &#125;\n\n        return S;\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"20CPYR8","excerpt":"","more":"<p>中等题</p>\n<p>这题坑还是很多的，如输入数据非有序，考虑在同一字符串插入时多个字符串替换时原字符串的下标维持或是可插入性。</p>\n<p><strong>思路1:</strong></p>\n<p>将indexes所标记出的下标映射为输入数据的次序，在排序indexes来有序遍历S。之后就是判断哪些S的字母可以替换并替换。</p>\n<p><strong>思路2（官方）：</strong></p>\n<p>为了顺序地构造目标字符串，先标记出S中所有可替换的位置，并顺序遍历（逆序或者正序都可以，构造方法不同罢了）。</p>\n<p>依据题意，可以推出从后向前替换，可以避免下标变换的问题。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;题目没看清,多写了一个转化大小写函数\n    string lowercase(string S)&#123;\n        &#x2F;&#x2F; return A iterator;\n        std::transform(S.begin(), S.end(), S.begin(), [](unsigned char c)&#123;return std::tolower(c);&#125; );\n        return S;\n    &#125;\n    &#x2F;&#x2F;思路1 \n    string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) &#123;\n        int idx2 &#x3D; indexes.size() - 1;\n        vector&lt;int&gt; repl( indexes.size() );\n        &#x2F;&#x2F;将排序后的字符串下标映射回原来的下标\n            &#x2F;&#x2F;同时不能 把排序后的index下标映射或者被映射;\n        map&lt;int, int&gt; match;        \n        for(int i&#x3D;0;i&lt;indexes.size();i++) \n            match[ indexes[i] ] &#x3D; i;\n        sort(indexes.begin(), indexes.end());\n        &#x2F;&#x2F;判断逆序判断能否替换，若可以则逆序替换；  \n        &#x2F;&#x2F;逆序替换不影响之前的可替换性判断\n        for(int i&#x3D;S.size()-1;i&gt;&#x3D;0 &amp;&amp; idx2 &gt;&#x3D;0 ;i--)&#123;\n            if(i &#x3D;&#x3D; indexes[idx2])&#123;\n                if(lowercase( S.substr(i, sources[match[i]].size())) &#x3D;&#x3D; sources[match[i]] )                \n                    S.replace(i, sources[match[i]].size(), targets[match[i]]);    \n                idx2 --;                \n            &#125;\n        &#125;\n\n        return S;\n    &#125;\n    \n    &#x2F;&#x2F; 思路2：官方解的实现，也是空间换时间\n    string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) &#123;\n        &#x2F;&#x2F;对S每个字母对有效替换的判断, 并记录下标\n        vector&lt;int&gt; match(S.size(), -1);\n        for(int i&#x3D;0 ;i&lt;indexes.size();i++)&#123;\n            if( S.substr(indexes[i], sources[i].size()) &#x3D;&#x3D; sources[i])\n                match[ indexes[i] ] &#x3D; i;\n        &#125;\n\n        &#x2F;&#x2F;判断逆序判断能否替换，若可以则逆序替换；          \n        for(int i&#x3D;S.size()-1;i&gt;&#x3D;0 ;i--)&#123;\n            if(match[i] !&#x3D; -1)&#123;\n                S.replace(i, sources[match[i]].size(), targets[match[i]] );\n            &#125;\n            cout&lt;&lt; S &lt;&lt; endl;\n        &#125;\n\n        return S;\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"88. Merge Sorted Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-17T00:50:57.000Z","_content":"\n\n<!-- more -->\n\n## 思路：\n\n双指针从后向前合并即可，时间复杂度为$n(o)$，空间复杂度$O(1)$。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {        \n        int pos = m + n - 1, p1 = m - 1, p2 = n - 1;\n        while(p1 >= 0 && p2 >= 0){\n            if(nums1[p1] > nums2[p2]){\n                nums1[pos] = nums1[p1--];\n            }else{\n                nums1[pos] = nums2[p2--];\n            }\n            pos--;\n        }\n        while(p2 >= 0){\n            nums1[pos--] = nums2[p2--];\n        }\n    }\n};\n```\n\n","source":"_posts/刷题/其他/88-Merge-Sorted-Array.md","raw":"---\ntitle: 88. Merge Sorted Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-10-17 08:50:57\ntags:\n---\n\n\n<!-- more -->\n\n## 思路：\n\n双指针从后向前合并即可，时间复杂度为$n(o)$，空间复杂度$O(1)$。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {        \n        int pos = m + n - 1, p1 = m - 1, p2 = n - 1;\n        while(p1 >= 0 && p2 >= 0){\n            if(nums1[p1] > nums2[p2]){\n                nums1[pos] = nums1[p1--];\n            }else{\n                nums1[pos] = nums2[p2--];\n            }\n            pos--;\n        }\n        while(p2 >= 0){\n            nums1[pos--] = nums2[p2--];\n        }\n    }\n};\n```\n\n","slug":"刷题/其他/88-Merge-Sorted-Array","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4w0028l5uo13361nb4","content":"<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>双指针从后向前合并即可，时间复杂度为$n(o)$，空间复杂度$O(1)$。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;        \n        int pos &#x3D; m + n - 1, p1 &#x3D; m - 1, p2 &#x3D; n - 1;\n        while(p1 &gt;&#x3D; 0 &amp;&amp; p2 &gt;&#x3D; 0)&#123;\n            if(nums1[p1] &gt; nums2[p2])&#123;\n                nums1[pos] &#x3D; nums1[p1--];\n            &#125;else&#123;\n                nums1[pos] &#x3D; nums2[p2--];\n            &#125;\n            pos--;\n        &#125;\n        while(p2 &gt;&#x3D; 0)&#123;\n            nums1[pos--] &#x3D; nums2[p2--];\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"24M7DNC","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>双指针从后向前合并即可，时间复杂度为$n(o)$，空间复杂度$O(1)$。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;        \n        int pos &#x3D; m + n - 1, p1 &#x3D; m - 1, p2 &#x3D; n - 1;\n        while(p1 &gt;&#x3D; 0 &amp;&amp; p2 &gt;&#x3D; 0)&#123;\n            if(nums1[p1] &gt; nums2[p2])&#123;\n                nums1[pos] &#x3D; nums1[p1--];\n            &#125;else&#123;\n                nums1[pos] &#x3D; nums2[p2--];\n            &#125;\n            pos--;\n        &#125;\n        while(p2 &gt;&#x3D; 0)&#123;\n            nums1[pos--] &#x3D; nums2[p2--];\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"934. Shortest Bridge","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-28T02:04:11.000Z","_content":"\n\n\n\n## [934. Shortest Bridge](https://leetcode-cn.com/problems/shortest-bridge/)\n\n\n\n## 思路：\n\n一次dfs搜索一个岛屿，一次bfs搜最短路径。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int n, m;\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    class Point{\n    public:\n        int x;\n        int y;\n        int dis;\n        Point(int _dis, int _x, int _y){\n            x = _x;\n            y = _y;\n            dis = _dis;\n        }        \n        friend bool operator <(const Point &a, const Point &b){\n            return a.dis > b.dis;\n        }\n    };\n\n    bool check(int x, int y){\n        return !(x < 0 || x >= m || y < 0 || y >= n );\n    }\n    void getIslang(vector<vector<int>>& A, vector<vector<int>>& vis, \n                priority_queue<Point> &island, int x, int y){\n        if( !check(x,y) || vis[x][y] || A[x][y] == 0) return;\n        island.push(Point(0, x, y));\n        vis[x][y] = 1;\n        for(int i = 0; i < 4; ++i){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            getIslang(A, vis, island, nx , ny);\n        }\n    }\n\n    int shortestBridge(vector<vector<int>>& A) {\n        m = A.size();\n        if(m == 0) return -1;\n        n = A[0].size();\n        vector<vector<int>> vis(m, vector<int>(n, 0));\n        priority_queue<Point> que;\n        int flag = 1;\n        for(int i = 0; flag &&  i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(A[i][j] == 1){\n                    flag = 0;\n                    getIslang(A, vis, que, i, j);\n                    break;\n                }\n\n            }\n        }\n        // cout << que.size() << endl;\n        while(que.size()){\n            Point p = que.top();\n            que.pop();\n            // cout << p.x  << \" \" << p.y  << endl;\n            for(int i = 0; i < 4; ++i){\n                int nx = p.x + dx[i];\n                int ny = p.y + dy[i];\n                \n                if(!check(nx, ny)) continue;\n\n                if(!vis[nx][ny]){\n                    vis[nx][ny] = 1;\n                    \n                    if(A[nx][ny] == 1){\n                        return p.dis;\n                    }else{\n                        que.push(Point(p.dis + 1, nx, ny));\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n};\n```","source":"_posts/刷题/其他/934-Shortest-Bridge.md","raw":"---\ntitle: 934. Shortest Bridge\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-11-28 10:04:11\ntags:\n---\n\n\n\n\n## [934. Shortest Bridge](https://leetcode-cn.com/problems/shortest-bridge/)\n\n\n\n## 思路：\n\n一次dfs搜索一个岛屿，一次bfs搜最短路径。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int n, m;\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    class Point{\n    public:\n        int x;\n        int y;\n        int dis;\n        Point(int _dis, int _x, int _y){\n            x = _x;\n            y = _y;\n            dis = _dis;\n        }        \n        friend bool operator <(const Point &a, const Point &b){\n            return a.dis > b.dis;\n        }\n    };\n\n    bool check(int x, int y){\n        return !(x < 0 || x >= m || y < 0 || y >= n );\n    }\n    void getIslang(vector<vector<int>>& A, vector<vector<int>>& vis, \n                priority_queue<Point> &island, int x, int y){\n        if( !check(x,y) || vis[x][y] || A[x][y] == 0) return;\n        island.push(Point(0, x, y));\n        vis[x][y] = 1;\n        for(int i = 0; i < 4; ++i){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            getIslang(A, vis, island, nx , ny);\n        }\n    }\n\n    int shortestBridge(vector<vector<int>>& A) {\n        m = A.size();\n        if(m == 0) return -1;\n        n = A[0].size();\n        vector<vector<int>> vis(m, vector<int>(n, 0));\n        priority_queue<Point> que;\n        int flag = 1;\n        for(int i = 0; flag &&  i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(A[i][j] == 1){\n                    flag = 0;\n                    getIslang(A, vis, que, i, j);\n                    break;\n                }\n\n            }\n        }\n        // cout << que.size() << endl;\n        while(que.size()){\n            Point p = que.top();\n            que.pop();\n            // cout << p.x  << \" \" << p.y  << endl;\n            for(int i = 0; i < 4; ++i){\n                int nx = p.x + dx[i];\n                int ny = p.y + dy[i];\n                \n                if(!check(nx, ny)) continue;\n\n                if(!vis[nx][ny]){\n                    vis[nx][ny] = 1;\n                    \n                    if(A[nx][ny] == 1){\n                        return p.dis;\n                    }else{\n                        que.push(Point(p.dis + 1, nx, ny));\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n};\n```","slug":"刷题/其他/934-Shortest-Bridge","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4w0029l5uo7nrhda3t","content":"<h2 id=\"934-Shortest-Bridge\"><a href=\"#934-Shortest-Bridge\" class=\"headerlink\" title=\"934. Shortest Bridge\"></a><a href=\"https://leetcode-cn.com/problems/shortest-bridge/\">934. Shortest Bridge</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>一次dfs搜索一个岛屿，一次bfs搜最短路径。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int n, m;\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    class Point&#123;\n    public:\n        int x;\n        int y;\n        int dis;\n        Point(int _dis, int _x, int _y)&#123;\n            x &#x3D; _x;\n            y &#x3D; _y;\n            dis &#x3D; _dis;\n        &#125;        \n        friend bool operator &lt;(const Point &amp;a, const Point &amp;b)&#123;\n            return a.dis &gt; b.dis;\n        &#125;\n    &#125;;\n\n    bool check(int x, int y)&#123;\n        return !(x &lt; 0 || x &gt;&#x3D; m || y &lt; 0 || y &gt;&#x3D; n );\n    &#125;\n    void getIslang(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; vis, \n                priority_queue&lt;Point&gt; &amp;island, int x, int y)&#123;\n        if( !check(x,y) || vis[x][y] || A[x][y] &#x3D;&#x3D; 0) return;\n        island.push(Point(0, x, y));\n        vis[x][y] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            int nx &#x3D; x + dx[i];\n            int ny &#x3D; y + dy[i];\n            getIslang(A, vis, island, nx , ny);\n        &#125;\n    &#125;\n\n    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;\n        m &#x3D; A.size();\n        if(m &#x3D;&#x3D; 0) return -1;\n        n &#x3D; A[0].size();\n        vector&lt;vector&lt;int&gt;&gt; vis(m, vector&lt;int&gt;(n, 0));\n        priority_queue&lt;Point&gt; que;\n        int flag &#x3D; 1;\n        for(int i &#x3D; 0; flag &amp;&amp;  i &lt; m; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(A[i][j] &#x3D;&#x3D; 1)&#123;\n                    flag &#x3D; 0;\n                    getIslang(A, vis, que, i, j);\n                    break;\n                &#125;\n\n            &#125;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; que.size() &lt;&lt; endl;\n        while(que.size())&#123;\n            Point p &#x3D; que.top();\n            que.pop();\n            &#x2F;&#x2F; cout &lt;&lt; p.x  &lt;&lt; &quot; &quot; &lt;&lt; p.y  &lt;&lt; endl;\n            for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n                int nx &#x3D; p.x + dx[i];\n                int ny &#x3D; p.y + dy[i];\n                \n                if(!check(nx, ny)) continue;\n\n                if(!vis[nx][ny])&#123;\n                    vis[nx][ny] &#x3D; 1;\n                    \n                    if(A[nx][ny] &#x3D;&#x3D; 1)&#123;\n                        return p.dis;\n                    &#125;else&#123;\n                        que.push(Point(p.dis + 1, nx, ny));\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"390XNS2","excerpt":"<h2 id=\"934-Shortest-Bridge\"><a href=\"#934-Shortest-Bridge\" class=\"headerlink\" title=\"934. Shortest Bridge\"></a><a href=\"https://leetcode-cn.com/problems/shortest-bridge/\">934. Shortest Bridge</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>一次dfs搜索一个岛屿，一次bfs搜最短路径。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int n, m;\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    class Point&#123;\n    public:\n        int x;\n        int y;\n        int dis;\n        Point(int _dis, int _x, int _y)&#123;\n            x &#x3D; _x;\n            y &#x3D; _y;\n            dis &#x3D; _dis;\n        &#125;        \n        friend bool operator &lt;(const Point &amp;a, const Point &amp;b)&#123;\n            return a.dis &gt; b.dis;\n        &#125;\n    &#125;;\n\n    bool check(int x, int y)&#123;\n        return !(x &lt; 0 || x &gt;&#x3D; m || y &lt; 0 || y &gt;&#x3D; n );\n    &#125;\n    void getIslang(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; vis, \n                priority_queue&lt;Point&gt; &amp;island, int x, int y)&#123;\n        if( !check(x,y) || vis[x][y] || A[x][y] &#x3D;&#x3D; 0) return;\n        island.push(Point(0, x, y));\n        vis[x][y] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            int nx &#x3D; x + dx[i];\n            int ny &#x3D; y + dy[i];\n            getIslang(A, vis, island, nx , ny);\n        &#125;\n    &#125;\n\n    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;\n        m &#x3D; A.size();\n        if(m &#x3D;&#x3D; 0) return -1;\n        n &#x3D; A[0].size();\n        vector&lt;vector&lt;int&gt;&gt; vis(m, vector&lt;int&gt;(n, 0));\n        priority_queue&lt;Point&gt; que;\n        int flag &#x3D; 1;\n        for(int i &#x3D; 0; flag &amp;&amp;  i &lt; m; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(A[i][j] &#x3D;&#x3D; 1)&#123;\n                    flag &#x3D; 0;\n                    getIslang(A, vis, que, i, j);\n                    break;\n                &#125;\n\n            &#125;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; que.size() &lt;&lt; endl;\n        while(que.size())&#123;\n            Point p &#x3D; que.top();\n            que.pop();\n            &#x2F;&#x2F; cout &lt;&lt; p.x  &lt;&lt; &quot; &quot; &lt;&lt; p.y  &lt;&lt; endl;\n            for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n                int nx &#x3D; p.x + dx[i];\n                int ny &#x3D; p.y + dy[i];\n                \n                if(!check(nx, ny)) continue;\n\n                if(!vis[nx][ny])&#123;\n                    vis[nx][ny] &#x3D; 1;\n                    \n                    if(A[nx][ny] &#x3D;&#x3D; 1)&#123;\n                        return p.dis;\n                    &#125;else&#123;\n                        que.push(Point(p.dis + 1, nx, ny));\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面16-数值的N次方","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:26:33.000Z","_content":"\n\n\n### 题面：\n\n给一个浮点数，求出其数值的整数次方。\n\n### 思路：\n\n主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。\n\n<!-- more -->\n\n\n\n### 代码：\n\n```\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    unsigned int posExponent = (unsigned int)exponent;\n    double mulBase = base, mulRes = 1;\n    while(posExponent > 0){\n        if(posExponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        posExponent = posExponent >> 1;\n    }\n   if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```\n\n可能降低耦合更好一点\n\n```\ndouble PowerWithUnsighedExponent(double base, unsigned int exponent){\n    //特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes = 1;\n    while(exponent > 0){\n        if(exponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        exponent = exponent >> 1;\n    }\n   return mulRes;\n}\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    double mulRes = PowerWithUnsignedExponent(base, exponent);\n    if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```","source":"_posts/刷题/其他/面16-数值的N次方.md","raw":"---\ntitle: 面16-数值的N次方\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:26:33\ntags:\n---\n\n\n\n### 题面：\n\n给一个浮点数，求出其数值的整数次方。\n\n### 思路：\n\n主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。\n\n<!-- more -->\n\n\n\n### 代码：\n\n```\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    unsigned int posExponent = (unsigned int)exponent;\n    double mulBase = base, mulRes = 1;\n    while(posExponent > 0){\n        if(posExponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        posExponent = posExponent >> 1;\n    }\n   if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```\n\n可能降低耦合更好一点\n\n```\ndouble PowerWithUnsighedExponent(double base, unsigned int exponent){\n    //特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes = 1;\n    while(exponent > 0){\n        if(exponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        exponent = exponent >> 1;\n    }\n   return mulRes;\n}\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    double mulRes = PowerWithUnsignedExponent(base, exponent);\n    if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```","slug":"刷题/其他/面16-数值的N次方","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4x002al5uocge17mjg","content":"<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给一个浮点数，求出其数值的整数次方。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    unsigned int posExponent &#x3D; (unsigned int)exponent;\n    double mulBase &#x3D; base, mulRes &#x3D; 1;\n    while(posExponent &gt; 0)&#123;\n        if(posExponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        posExponent &#x3D; posExponent &gt;&gt; 1;\n    &#125;\n   if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可能降低耦合更好一点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">double PowerWithUnsighedExponent(double base, unsigned int exponent)&#123;\n    &#x2F;&#x2F;特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes &#x3D; 1;\n    while(exponent &gt; 0)&#123;\n        if(exponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        exponent &#x3D; exponent &gt;&gt; 1;\n    &#125;\n   return mulRes;\n&#125;\nint power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    double mulRes &#x3D; PowerWithUnsignedExponent(base, exponent);\n    if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"298BYBX","excerpt":"<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给一个浮点数，求出其数值的整数次方。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。</p>","more":"<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    unsigned int posExponent &#x3D; (unsigned int)exponent;\n    double mulBase &#x3D; base, mulRes &#x3D; 1;\n    while(posExponent &gt; 0)&#123;\n        if(posExponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        posExponent &#x3D; posExponent &gt;&gt; 1;\n    &#125;\n   if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可能降低耦合更好一点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">double PowerWithUnsighedExponent(double base, unsigned int exponent)&#123;\n    &#x2F;&#x2F;特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes &#x3D; 1;\n    while(exponent &gt; 0)&#123;\n        if(exponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        exponent &#x3D; exponent &gt;&gt; 1;\n    &#125;\n   return mulRes;\n&#125;\nint power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    double mulRes &#x3D; PowerWithUnsignedExponent(base, exponent);\n    if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题-递归迭代","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:31:32.000Z","_content":"\n收集一些经典的题目\n\n\n\n## 斐波那契数列计算\n\n<!-- more -->\n\n\n\n三种思路：递归、dp和快速矩阵乘\n\n**dp**\n\n```\nlong long Fobonacci(unsigned n){\n    if(n <= 0) return -1;\n    long long fibN1 = 0;\n    long long fibN2 = 1;\n    if(n == 1) return fibN1;\n    else if(n == 2) return fibN2;\n    \n    for(int k = 2; k <= n; k++){\n\t\tint temp = fibN2;\n        fibN2 = fibN2 + fibN2;\n        fibN1 = temp;\n    }\n    return fibN2;\n}\n```\n\n思路扩展：青蛙跳台阶问题，1*2方块铺设问题，","source":"_posts/刷题/其他/面试题-递归迭代.md","raw":"---\ntitle: 面试题-递归迭代\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:31:32\ntags:\n---\n\n收集一些经典的题目\n\n\n\n## 斐波那契数列计算\n\n<!-- more -->\n\n\n\n三种思路：递归、dp和快速矩阵乘\n\n**dp**\n\n```\nlong long Fobonacci(unsigned n){\n    if(n <= 0) return -1;\n    long long fibN1 = 0;\n    long long fibN2 = 1;\n    if(n == 1) return fibN1;\n    else if(n == 2) return fibN2;\n    \n    for(int k = 2; k <= n; k++){\n\t\tint temp = fibN2;\n        fibN2 = fibN2 + fibN2;\n        fibN1 = temp;\n    }\n    return fibN2;\n}\n```\n\n思路扩展：青蛙跳台阶问题，1*2方块铺设问题，","slug":"刷题/其他/面试题-递归迭代","published":1,"updated":"2021-01-28T14:04:37.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4x002bl5uo9jqoa3ij","content":"<p>收集一些经典的题目</p>\n<h2 id=\"斐波那契数列计算\"><a href=\"#斐波那契数列计算\" class=\"headerlink\" title=\"斐波那契数列计算\"></a>斐波那契数列计算</h2><span id=\"more\"></span>\n\n\n\n<p>三种思路：递归、dp和快速矩阵乘</p>\n<p><strong>dp</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">long long Fobonacci(unsigned n)&#123;\n    if(n &lt;&#x3D; 0) return -1;\n    long long fibN1 &#x3D; 0;\n    long long fibN2 &#x3D; 1;\n    if(n &#x3D;&#x3D; 1) return fibN1;\n    else if(n &#x3D;&#x3D; 2) return fibN2;\n    \n    for(int k &#x3D; 2; k &lt;&#x3D; n; k++)&#123;\n\t\tint temp &#x3D; fibN2;\n        fibN2 &#x3D; fibN2 + fibN2;\n        fibN1 &#x3D; temp;\n    &#125;\n    return fibN2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>思路扩展：青蛙跳台阶问题，1*2方块铺设问题，</p>\n","site":{"data":{}},"abbrlink":"HEV1G5","excerpt":"<p>收集一些经典的题目</p>\n<h2 id=\"斐波那契数列计算\"><a href=\"#斐波那契数列计算\" class=\"headerlink\" title=\"斐波那契数列计算\"></a>斐波那契数列计算</h2>","more":"<p>三种思路：递归、dp和快速矩阵乘</p>\n<p><strong>dp</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">long long Fobonacci(unsigned n)&#123;\n    if(n &lt;&#x3D; 0) return -1;\n    long long fibN1 &#x3D; 0;\n    long long fibN2 &#x3D; 1;\n    if(n &#x3D;&#x3D; 1) return fibN1;\n    else if(n &#x3D;&#x3D; 2) return fibN2;\n    \n    for(int k &#x3D; 2; k &lt;&#x3D; n; k++)&#123;\n\t\tint temp &#x3D; fibN2;\n        fibN2 &#x3D; fibN2 + fibN2;\n        fibN1 &#x3D; temp;\n    &#125;\n    return fibN2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>思路扩展：青蛙跳台阶问题，1*2方块铺设问题，</p>"},{"title":"面试题44：1出现的个数","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:22:13.000Z","_content":"\n\n\n\n\n广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理\n\n<!-- more -->\n\n### 题目：\n\n统计从1到N的所有数字的1的出现次数。\n\n### 思路：\n\n第一种：所有人都能想出直接暴力解的算法。\n\n第二种：参考其他人的解法。\n\n> 设N = abcde ,其中abcde分别为十进制中各位上的数字。\n> 如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。\n> ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~~199，1100~~1199,2100~~2199，，…，11100~~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。\n> ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~~199，1100~~1199,2100~~2199，，….，11100~~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~~12113,一共114个，等于低位数字（113）+1。\n> ③ 如果百位上数字大于1（2~~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~~199,1100~~1199，2100~~2199，…，11100~~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。\n> ——参考牛客网@藍裙子的百合魂\n\n### 代码：\n\n```\nint CounterOf1(int x){\n\tif(x <=  0) return 0;\n    int len = 0, tempX = x, judugNum = 1;\n    while(tempX){\n        tempX = tempX / 10;\n        len ++;\n    }\n    \n    int power = 10, counter = 0 ;\n    for(int i = 0; i < len; i++){\n        int liPower = power / 10;\n        int num = x % power / liPower;\n        if(num > judugNum ){\n            counter += (x / power + 1) * liPower;\n        }else if(num == judugNum ){\n            counter += (x / power) * liPower + x % liPower + 1;            \n        }else\n            counter += x / power * liPower;\n    \tpower *= 10;\n    }\n    return counter;\n}\n```\n\n测试可见 [牛客](https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6)\n\n","source":"_posts/刷题/其他/面试题44：1出现的个数.md","raw":"---\ntitle: 面试题44：1出现的个数\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:22:13\ntags:\n---\n\n\n\n\n\n广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理\n\n<!-- more -->\n\n### 题目：\n\n统计从1到N的所有数字的1的出现次数。\n\n### 思路：\n\n第一种：所有人都能想出直接暴力解的算法。\n\n第二种：参考其他人的解法。\n\n> 设N = abcde ,其中abcde分别为十进制中各位上的数字。\n> 如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。\n> ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~~199，1100~~1199,2100~~2199，，…，11100~~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。\n> ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~~199，1100~~1199,2100~~2199，，….，11100~~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~~12113,一共114个，等于低位数字（113）+1。\n> ③ 如果百位上数字大于1（2~~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~~199,1100~~1199，2100~~2199，…，11100~~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。\n> ——参考牛客网@藍裙子的百合魂\n\n### 代码：\n\n```\nint CounterOf1(int x){\n\tif(x <=  0) return 0;\n    int len = 0, tempX = x, judugNum = 1;\n    while(tempX){\n        tempX = tempX / 10;\n        len ++;\n    }\n    \n    int power = 10, counter = 0 ;\n    for(int i = 0; i < len; i++){\n        int liPower = power / 10;\n        int num = x % power / liPower;\n        if(num > judugNum ){\n            counter += (x / power + 1) * liPower;\n        }else if(num == judugNum ){\n            counter += (x / power) * liPower + x % liPower + 1;            \n        }else\n            counter += x / power * liPower;\n    \tpower *= 10;\n    }\n    return counter;\n}\n```\n\n测试可见 [牛客](https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6)\n\n","slug":"刷题/其他/面试题44：1出现的个数","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4y002cl5uoh7te2fq0","content":"<p>广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理</p>\n<span id=\"more\"></span>\n\n<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>统计从1到N的所有数字的1的出现次数。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种：所有人都能想出直接暴力解的算法。</p>\n<p>第二种：参考其他人的解法。</p>\n<blockquote>\n<p>设N = abcde ,其中abcde分别为十进制中各位上的数字。<br>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。<br>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100<del>199，1100</del>1199,2100<del>2199，，…，11100</del>11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。<br>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100<del>199，1100</del>1199,2100<del>2199，，….，11100</del>11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100<del>12113,一共114个，等于低位数字（113）+1。<br>③ 如果百位上数字大于1（2</del>9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100<del>199,1100</del>1199，2100<del>2199，…，11100</del>11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。<br>——参考牛客网@藍裙子的百合魂</p>\n</blockquote>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int CounterOf1(int x)&#123;\n\tif(x &lt;&#x3D;  0) return 0;\n    int len &#x3D; 0, tempX &#x3D; x, judugNum &#x3D; 1;\n    while(tempX)&#123;\n        tempX &#x3D; tempX &#x2F; 10;\n        len ++;\n    &#125;\n    \n    int power &#x3D; 10, counter &#x3D; 0 ;\n    for(int i &#x3D; 0; i &lt; len; i++)&#123;\n        int liPower &#x3D; power &#x2F; 10;\n        int num &#x3D; x % power &#x2F; liPower;\n        if(num &gt; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power + 1) * liPower;\n        &#125;else if(num &#x3D;&#x3D; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power) * liPower + x % liPower + 1;            \n        &#125;else\n            counter +&#x3D; x &#x2F; power * liPower;\n    \tpower *&#x3D; 10;\n    &#125;\n    return counter;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试可见 <a href=\"https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6\">牛客</a></p>\n","site":{"data":{}},"abbrlink":"1TG6JR8","excerpt":"<p>广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理</p>","more":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>统计从1到N的所有数字的1的出现次数。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种：所有人都能想出直接暴力解的算法。</p>\n<p>第二种：参考其他人的解法。</p>\n<blockquote>\n<p>设N = abcde ,其中abcde分别为十进制中各位上的数字。<br>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。<br>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100<del>199，1100</del>1199,2100<del>2199，，…，11100</del>11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。<br>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100<del>199，1100</del>1199,2100<del>2199，，….，11100</del>11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100<del>12113,一共114个，等于低位数字（113）+1。<br>③ 如果百位上数字大于1（2</del>9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100<del>199,1100</del>1199，2100<del>2199，…，11100</del>11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。<br>——参考牛客网@藍裙子的百合魂</p>\n</blockquote>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int CounterOf1(int x)&#123;\n\tif(x &lt;&#x3D;  0) return 0;\n    int len &#x3D; 0, tempX &#x3D; x, judugNum &#x3D; 1;\n    while(tempX)&#123;\n        tempX &#x3D; tempX &#x2F; 10;\n        len ++;\n    &#125;\n    \n    int power &#x3D; 10, counter &#x3D; 0 ;\n    for(int i &#x3D; 0; i &lt; len; i++)&#123;\n        int liPower &#x3D; power &#x2F; 10;\n        int num &#x3D; x % power &#x2F; liPower;\n        if(num &gt; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power + 1) * liPower;\n        &#125;else if(num &#x3D;&#x3D; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power) * liPower + x % liPower + 1;            \n        &#125;else\n            counter +&#x3D; x &#x2F; power * liPower;\n    \tpower *&#x3D; 10;\n    &#125;\n    return counter;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试可见 <a href=\"https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6\">牛客</a></p>"},{"title":"面试题49：丑数","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:22:01.000Z","_content":"\n\n<!-- more -->","source":"_posts/刷题/其他/面试题49：丑数.md","raw":"---\ntitle: 面试题49：丑数\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:22:01\ntags:\n---\n\n\n<!-- more -->","slug":"刷题/其他/面试题49：丑数","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4z002dl5uo2d3bgcz2","content":"<span id=\"more\"></span>","site":{"data":{}},"abbrlink":"1RX02Z6","excerpt":"","more":""},{"title":"241. Different Ways to Add Parentheses","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-02T13:53:55.000Z","_content":"\n\n\n\n## [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n\n\n## 思路：\n\n\n\n分解算术式子，分开计算即可。\n\n1. 分治法自上而下求取答案，当然可以用上记忆化的技巧。\n2. DP自下而上求取答案，速度和内存消耗更少。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string input) {\n        vector<int> nums;\n        vector<char> ops;\n        int a = 0;\n        char op = ' ';\n        input = input + '+';\n        for(int i = 0; i < input.size(); ++i){\n            if(input[i] == '+' || input[i] == '-' || input[i] == '*'){\n                nums.push_back(a);\n                cout << a;\n                a = 0;\n                op = input[i];\n                \n            }\n            else{\n                a *= 10;\n                a += input[i] - '0';\n                if(op != ' '){\n                    ops.push_back(op);\n                    op = ' ';\n                }\n            }\n        }\n        \n        set<int> res = getDivide(nums, ops, 0, nums.size() - 1);\n        vector<int> ans = {};\n        for(auto it = res.begin(); it != res.end(); it++)\n            ans.push_back(*it);\n        return ans;\n    }\n\n    set<int> getDivide( vector<int> &nums, vector<char> &ops, int s, int e){\n        set<int> temp;\n        if(s == e){\n            temp.insert(nums[s]);\n            return temp;\n        }\n        for(int i = s; i < e; ++i){            \n            set<int> res1 = getDivide( nums, ops, s, i);\n            set<int> res2 = getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 = res1.begin(); it1 != res1.end(); it1++){\n                for(auto it2 = res2.begin(); it2 != res2.end(); it2++){\n                    if(ops[i] == '+') temp.insert(*it1 + *it2);\n                    else if(ops[i] == '-') temp.insert(*it1 - *it2);\n                    else if(ops[i] == '*') temp.insert(*it1 * *it2);            \n                }\n            }\n        }\n\n        return temp;\n    }\n};\n```\n\n\n\n\n\nAC80%\n\n```c++\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string input) {\n        vector<int> nums;\n        vector<char> ops;\n        int a = 0;\n        char op = ' ';\n        input = input + '+';\n        for(int i = 0; i < input.size(); ++i){\n            if(input[i] == '+' || input[i] == '-' || input[i] == '*'){\n                nums.push_back(a);\n                // cout << a;\n                a = 0;\n                op = input[i];\n                \n            }\n            else{\n                a *= 10;\n                a += input[i] - '0';\n                if(op != ' '){\n                    ops.push_back(op);\n                    op = ' ';\n                }\n            }\n        }\n        \n         \n        return getDivide(nums, ops, 0, nums.size() - 1);\n    }\n\n    vector<int> getDivide( vector<int> &nums, vector<char> &ops, int s, int e){\n        vector<int> temp;\n        if(s == e){\n            temp.push_back(nums[s]);\n            return temp;\n        }\n        for(int i = s; i < e; ++i){            \n            vector<int> res1 = getDivide( nums, ops, s, i);\n            vector<int> res2 = getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 = res1.begin(); it1 != res1.end(); it1++){\n                for(auto it2 = res2.begin(); it2 != res2.end(); it2++){\n                    if(ops[i] == '+') temp.push_back(*it1 + *it2);\n                    else if(ops[i] == '-') temp.push_back(*it1 - *it2);\n                    else if(ops[i] == '*') temp.push_back(*it1 * *it2);            \n                }\n            }\n        }\n\n        return temp;\n    }\n};\n```\n\n\n\nDP记忆化方法 100%\n\n```c++\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string input) {\n        vector<int> nums;\n        vector<char> ops;\n        int num;\n        char op; \n        istringstream ss(input + \"+\"); //! istringstream\n        while(ss >> num && ss >> op){\n            nums.push_back(num);\n            ops.push_back(op);\n        }\n        int n = nums.size();\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>()));\n        for(int i = 0; i < n; ++i){\n            for(int j = i; j >=0; j--){\n                if(i == j){\n                    dp[j][i].push_back(nums[i]);\n                }else{\n                    for(int k = j; k < i; k++){\n                        for(auto l : dp[j][k]){\n                            for(auto r : dp[k+1][i]){\n                                int val = 0;\n                                switch(ops[k]){\n                                    case '+': val = l + r; break;\n                                    case '-': val = l - r; break;\n                                    case '*': val = l * r; break;\n                                }\n                                dp[j][i].push_back(val);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n         \n        return dp[0][n - 1];\n    }\n};\n```\n\n","source":"_posts/刷题/分治\n/241-Different-Ways-to-Add-Parentheses.md","raw":"---\ntitle: 241. Different Ways to Add Parentheses\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-02 21:53:55\n---\n\n\n\n\n## [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)\n\n\n\n## 思路：\n\n\n\n分解算术式子，分开计算即可。\n\n1. 分治法自上而下求取答案，当然可以用上记忆化的技巧。\n2. DP自下而上求取答案，速度和内存消耗更少。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string input) {\n        vector<int> nums;\n        vector<char> ops;\n        int a = 0;\n        char op = ' ';\n        input = input + '+';\n        for(int i = 0; i < input.size(); ++i){\n            if(input[i] == '+' || input[i] == '-' || input[i] == '*'){\n                nums.push_back(a);\n                cout << a;\n                a = 0;\n                op = input[i];\n                \n            }\n            else{\n                a *= 10;\n                a += input[i] - '0';\n                if(op != ' '){\n                    ops.push_back(op);\n                    op = ' ';\n                }\n            }\n        }\n        \n        set<int> res = getDivide(nums, ops, 0, nums.size() - 1);\n        vector<int> ans = {};\n        for(auto it = res.begin(); it != res.end(); it++)\n            ans.push_back(*it);\n        return ans;\n    }\n\n    set<int> getDivide( vector<int> &nums, vector<char> &ops, int s, int e){\n        set<int> temp;\n        if(s == e){\n            temp.insert(nums[s]);\n            return temp;\n        }\n        for(int i = s; i < e; ++i){            \n            set<int> res1 = getDivide( nums, ops, s, i);\n            set<int> res2 = getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 = res1.begin(); it1 != res1.end(); it1++){\n                for(auto it2 = res2.begin(); it2 != res2.end(); it2++){\n                    if(ops[i] == '+') temp.insert(*it1 + *it2);\n                    else if(ops[i] == '-') temp.insert(*it1 - *it2);\n                    else if(ops[i] == '*') temp.insert(*it1 * *it2);            \n                }\n            }\n        }\n\n        return temp;\n    }\n};\n```\n\n\n\n\n\nAC80%\n\n```c++\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string input) {\n        vector<int> nums;\n        vector<char> ops;\n        int a = 0;\n        char op = ' ';\n        input = input + '+';\n        for(int i = 0; i < input.size(); ++i){\n            if(input[i] == '+' || input[i] == '-' || input[i] == '*'){\n                nums.push_back(a);\n                // cout << a;\n                a = 0;\n                op = input[i];\n                \n            }\n            else{\n                a *= 10;\n                a += input[i] - '0';\n                if(op != ' '){\n                    ops.push_back(op);\n                    op = ' ';\n                }\n            }\n        }\n        \n         \n        return getDivide(nums, ops, 0, nums.size() - 1);\n    }\n\n    vector<int> getDivide( vector<int> &nums, vector<char> &ops, int s, int e){\n        vector<int> temp;\n        if(s == e){\n            temp.push_back(nums[s]);\n            return temp;\n        }\n        for(int i = s; i < e; ++i){            \n            vector<int> res1 = getDivide( nums, ops, s, i);\n            vector<int> res2 = getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 = res1.begin(); it1 != res1.end(); it1++){\n                for(auto it2 = res2.begin(); it2 != res2.end(); it2++){\n                    if(ops[i] == '+') temp.push_back(*it1 + *it2);\n                    else if(ops[i] == '-') temp.push_back(*it1 - *it2);\n                    else if(ops[i] == '*') temp.push_back(*it1 * *it2);            \n                }\n            }\n        }\n\n        return temp;\n    }\n};\n```\n\n\n\nDP记忆化方法 100%\n\n```c++\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string input) {\n        vector<int> nums;\n        vector<char> ops;\n        int num;\n        char op; \n        istringstream ss(input + \"+\"); //! istringstream\n        while(ss >> num && ss >> op){\n            nums.push_back(num);\n            ops.push_back(op);\n        }\n        int n = nums.size();\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>()));\n        for(int i = 0; i < n; ++i){\n            for(int j = i; j >=0; j--){\n                if(i == j){\n                    dp[j][i].push_back(nums[i]);\n                }else{\n                    for(int k = j; k < i; k++){\n                        for(auto l : dp[j][k]){\n                            for(auto r : dp[k+1][i]){\n                                int val = 0;\n                                switch(ops[k]){\n                                    case '+': val = l + r; break;\n                                    case '-': val = l - r; break;\n                                    case '*': val = l * r; break;\n                                }\n                                dp[j][i].push_back(val);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n         \n        return dp[0][n - 1];\n    }\n};\n```\n\n","slug":"刷题-分治-241-Different-Ways-to-Add-Parentheses","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j4z002el5uofldef59r","content":"<h2 id=\"241-为运算表达式设计优先级\"><a href=\"#241-为运算表达式设计优先级\" class=\"headerlink\" title=\"241. 为运算表达式设计优先级\"></a><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">241. 为运算表达式设计优先级</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>分解算术式子，分开计算即可。</p>\n<ol>\n<li>分治法自上而下求取答案，当然可以用上记忆化的技巧。</li>\n<li>DP自下而上求取答案，速度和内存消耗更少。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string input) &#123;\n        vector&lt;int&gt; nums;\n        vector&lt;char&gt; ops;\n        int a &#x3D; 0;\n        char op &#x3D; &#39; &#39;;\n        input &#x3D; input + &#39;+&#39;;\n        for(int i &#x3D; 0; i &lt; input.size(); ++i)&#123;\n            if(input[i] &#x3D;&#x3D; &#39;+&#39; || input[i] &#x3D;&#x3D; &#39;-&#39; || input[i] &#x3D;&#x3D; &#39;*&#39;)&#123;\n                nums.push_back(a);\n                cout &lt;&lt; a;\n                a &#x3D; 0;\n                op &#x3D; input[i];\n                \n            &#125;\n            else&#123;\n                a *&#x3D; 10;\n                a +&#x3D; input[i] - &#39;0&#39;;\n                if(op !&#x3D; &#39; &#39;)&#123;\n                    ops.push_back(op);\n                    op &#x3D; &#39; &#39;;\n                &#125;\n            &#125;\n        &#125;\n        \n        set&lt;int&gt; res &#x3D; getDivide(nums, ops, 0, nums.size() - 1);\n        vector&lt;int&gt; ans &#x3D; &#123;&#125;;\n        for(auto it &#x3D; res.begin(); it !&#x3D; res.end(); it++)\n            ans.push_back(*it);\n        return ans;\n    &#125;\n\n    set&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e)&#123;\n        set&lt;int&gt; temp;\n        if(s &#x3D;&#x3D; e)&#123;\n            temp.insert(nums[s]);\n            return temp;\n        &#125;\n        for(int i &#x3D; s; i &lt; e; ++i)&#123;            \n            set&lt;int&gt; res1 &#x3D; getDivide( nums, ops, s, i);\n            set&lt;int&gt; res2 &#x3D; getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 &#x3D; res1.begin(); it1 !&#x3D; res1.end(); it1++)&#123;\n                for(auto it2 &#x3D; res2.begin(); it2 !&#x3D; res2.end(); it2++)&#123;\n                    if(ops[i] &#x3D;&#x3D; &#39;+&#39;) temp.insert(*it1 + *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;-&#39;) temp.insert(*it1 - *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;*&#39;) temp.insert(*it1 * *it2);            \n                &#125;\n            &#125;\n        &#125;\n\n        return temp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>AC80%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string input) &#123;\n        vector&lt;int&gt; nums;\n        vector&lt;char&gt; ops;\n        int a &#x3D; 0;\n        char op &#x3D; &#39; &#39;;\n        input &#x3D; input + &#39;+&#39;;\n        for(int i &#x3D; 0; i &lt; input.size(); ++i)&#123;\n            if(input[i] &#x3D;&#x3D; &#39;+&#39; || input[i] &#x3D;&#x3D; &#39;-&#39; || input[i] &#x3D;&#x3D; &#39;*&#39;)&#123;\n                nums.push_back(a);\n                &#x2F;&#x2F; cout &lt;&lt; a;\n                a &#x3D; 0;\n                op &#x3D; input[i];\n                \n            &#125;\n            else&#123;\n                a *&#x3D; 10;\n                a +&#x3D; input[i] - &#39;0&#39;;\n                if(op !&#x3D; &#39; &#39;)&#123;\n                    ops.push_back(op);\n                    op &#x3D; &#39; &#39;;\n                &#125;\n            &#125;\n        &#125;\n        \n         \n        return getDivide(nums, ops, 0, nums.size() - 1);\n    &#125;\n\n    vector&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e)&#123;\n        vector&lt;int&gt; temp;\n        if(s &#x3D;&#x3D; e)&#123;\n            temp.push_back(nums[s]);\n            return temp;\n        &#125;\n        for(int i &#x3D; s; i &lt; e; ++i)&#123;            \n            vector&lt;int&gt; res1 &#x3D; getDivide( nums, ops, s, i);\n            vector&lt;int&gt; res2 &#x3D; getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 &#x3D; res1.begin(); it1 !&#x3D; res1.end(); it1++)&#123;\n                for(auto it2 &#x3D; res2.begin(); it2 !&#x3D; res2.end(); it2++)&#123;\n                    if(ops[i] &#x3D;&#x3D; &#39;+&#39;) temp.push_back(*it1 + *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;-&#39;) temp.push_back(*it1 - *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;*&#39;) temp.push_back(*it1 * *it2);            \n                &#125;\n            &#125;\n        &#125;\n\n        return temp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>DP记忆化方法 100%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string input) &#123;\n        vector&lt;int&gt; nums;\n        vector&lt;char&gt; ops;\n        int num;\n        char op; \n        istringstream ss(input + &quot;+&quot;); &#x2F;&#x2F;! istringstream\n        while(ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op)&#123;\n            nums.push_back(num);\n            ops.push_back(op);\n        &#125;\n        int n &#x3D; nums.size();\n        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;()));\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; i; j &gt;&#x3D;0; j--)&#123;\n                if(i &#x3D;&#x3D; j)&#123;\n                    dp[j][i].push_back(nums[i]);\n                &#125;else&#123;\n                    for(int k &#x3D; j; k &lt; i; k++)&#123;\n                        for(auto l : dp[j][k])&#123;\n                            for(auto r : dp[k+1][i])&#123;\n                                int val &#x3D; 0;\n                                switch(ops[k])&#123;\n                                    case &#39;+&#39;: val &#x3D; l + r; break;\n                                    case &#39;-&#39;: val &#x3D; l - r; break;\n                                    case &#39;*&#39;: val &#x3D; l * r; break;\n                                &#125;\n                                dp[j][i].push_back(val);\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n         \n        return dp[0][n - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1CBNS3E","excerpt":"<h2 id=\"241-为运算表达式设计优先级\"><a href=\"#241-为运算表达式设计优先级\" class=\"headerlink\" title=\"241. 为运算表达式设计优先级\"></a><a href=\"https://leetcode-cn.com/problems/different-ways-to-add-parentheses/\">241. 为运算表达式设计优先级</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>分解算术式子，分开计算即可。</p>\n<ol>\n<li>分治法自上而下求取答案，当然可以用上记忆化的技巧。</li>\n<li>DP自下而上求取答案，速度和内存消耗更少。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string input) &#123;\n        vector&lt;int&gt; nums;\n        vector&lt;char&gt; ops;\n        int a &#x3D; 0;\n        char op &#x3D; &#39; &#39;;\n        input &#x3D; input + &#39;+&#39;;\n        for(int i &#x3D; 0; i &lt; input.size(); ++i)&#123;\n            if(input[i] &#x3D;&#x3D; &#39;+&#39; || input[i] &#x3D;&#x3D; &#39;-&#39; || input[i] &#x3D;&#x3D; &#39;*&#39;)&#123;\n                nums.push_back(a);\n                cout &lt;&lt; a;\n                a &#x3D; 0;\n                op &#x3D; input[i];\n                \n            &#125;\n            else&#123;\n                a *&#x3D; 10;\n                a +&#x3D; input[i] - &#39;0&#39;;\n                if(op !&#x3D; &#39; &#39;)&#123;\n                    ops.push_back(op);\n                    op &#x3D; &#39; &#39;;\n                &#125;\n            &#125;\n        &#125;\n        \n        set&lt;int&gt; res &#x3D; getDivide(nums, ops, 0, nums.size() - 1);\n        vector&lt;int&gt; ans &#x3D; &#123;&#125;;\n        for(auto it &#x3D; res.begin(); it !&#x3D; res.end(); it++)\n            ans.push_back(*it);\n        return ans;\n    &#125;\n\n    set&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e)&#123;\n        set&lt;int&gt; temp;\n        if(s &#x3D;&#x3D; e)&#123;\n            temp.insert(nums[s]);\n            return temp;\n        &#125;\n        for(int i &#x3D; s; i &lt; e; ++i)&#123;            \n            set&lt;int&gt; res1 &#x3D; getDivide( nums, ops, s, i);\n            set&lt;int&gt; res2 &#x3D; getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 &#x3D; res1.begin(); it1 !&#x3D; res1.end(); it1++)&#123;\n                for(auto it2 &#x3D; res2.begin(); it2 !&#x3D; res2.end(); it2++)&#123;\n                    if(ops[i] &#x3D;&#x3D; &#39;+&#39;) temp.insert(*it1 + *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;-&#39;) temp.insert(*it1 - *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;*&#39;) temp.insert(*it1 * *it2);            \n                &#125;\n            &#125;\n        &#125;\n\n        return temp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>AC80%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string input) &#123;\n        vector&lt;int&gt; nums;\n        vector&lt;char&gt; ops;\n        int a &#x3D; 0;\n        char op &#x3D; &#39; &#39;;\n        input &#x3D; input + &#39;+&#39;;\n        for(int i &#x3D; 0; i &lt; input.size(); ++i)&#123;\n            if(input[i] &#x3D;&#x3D; &#39;+&#39; || input[i] &#x3D;&#x3D; &#39;-&#39; || input[i] &#x3D;&#x3D; &#39;*&#39;)&#123;\n                nums.push_back(a);\n                &#x2F;&#x2F; cout &lt;&lt; a;\n                a &#x3D; 0;\n                op &#x3D; input[i];\n                \n            &#125;\n            else&#123;\n                a *&#x3D; 10;\n                a +&#x3D; input[i] - &#39;0&#39;;\n                if(op !&#x3D; &#39; &#39;)&#123;\n                    ops.push_back(op);\n                    op &#x3D; &#39; &#39;;\n                &#125;\n            &#125;\n        &#125;\n        \n         \n        return getDivide(nums, ops, 0, nums.size() - 1);\n    &#125;\n\n    vector&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e)&#123;\n        vector&lt;int&gt; temp;\n        if(s &#x3D;&#x3D; e)&#123;\n            temp.push_back(nums[s]);\n            return temp;\n        &#125;\n        for(int i &#x3D; s; i &lt; e; ++i)&#123;            \n            vector&lt;int&gt; res1 &#x3D; getDivide( nums, ops, s, i);\n            vector&lt;int&gt; res2 &#x3D; getDivide( nums, ops, i + 1, e);\n\n            for(auto it1 &#x3D; res1.begin(); it1 !&#x3D; res1.end(); it1++)&#123;\n                for(auto it2 &#x3D; res2.begin(); it2 !&#x3D; res2.end(); it2++)&#123;\n                    if(ops[i] &#x3D;&#x3D; &#39;+&#39;) temp.push_back(*it1 + *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;-&#39;) temp.push_back(*it1 - *it2);\n                    else if(ops[i] &#x3D;&#x3D; &#39;*&#39;) temp.push_back(*it1 * *it2);            \n                &#125;\n            &#125;\n        &#125;\n\n        return temp;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>DP记忆化方法 100%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; diffWaysToCompute(string input) &#123;\n        vector&lt;int&gt; nums;\n        vector&lt;char&gt; ops;\n        int num;\n        char op; \n        istringstream ss(input + &quot;+&quot;); &#x2F;&#x2F;! istringstream\n        while(ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op)&#123;\n            nums.push_back(num);\n            ops.push_back(op);\n        &#125;\n        int n &#x3D; nums.size();\n        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;()));\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; i; j &gt;&#x3D;0; j--)&#123;\n                if(i &#x3D;&#x3D; j)&#123;\n                    dp[j][i].push_back(nums[i]);\n                &#125;else&#123;\n                    for(int k &#x3D; j; k &lt; i; k++)&#123;\n                        for(auto l : dp[j][k])&#123;\n                            for(auto r : dp[k+1][i])&#123;\n                                int val &#x3D; 0;\n                                switch(ops[k])&#123;\n                                    case &#39;+&#39;: val &#x3D; l + r; break;\n                                    case &#39;-&#39;: val &#x3D; l - r; break;\n                                    case &#39;*&#39;: val &#x3D; l * r; break;\n                                &#125;\n                                dp[j][i].push_back(val);\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n         \n        return dp[0][n - 1];\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"932. Beautiful Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-04T02:17:46.000Z","_content":"\n\n\n\n## [932. Beautiful Array](https://leetcode-cn.com/problems/beautiful-array/)\n\n## 思路：\n\n这题的难度是怎么想出一个策略来保存漂亮数组的存在。<!-- more -->\n\n将1~N的数字划分为奇数和偶数，并放到数组两边，即可保证。同时可以发现仿射变化对漂亮数组的性质没有影响。\n$$\n2 *(k *  a[k] + b) =  k *  a[i] + b + k *  a[j] + b\n$$\n\n\n那么就有任意一边的数字都可以通过仿射变化变为`1-(N/2+1/2)`的问题。比如，原本左边有$(n + 1) / 2$个奇数数字，右边有$N/2$个偶数数字。那么左边的奇数数字可以通过仿射变化$a[i]'= a[i]/2 + 1/2$，右边的偶数数字可以通过仿射变化$a[i]'= a[i]/2$，将问题分解成了规模减半的两个子问题。\n\n通过递归分治我们可以解决该问题。\n\n## 代码：\n\n100%\n\n```c++\nclass Solution {\npublic:\n    vector<int> beautifulArray(int N) {\n        vector<int> arr(N);\n        for(int i = 0; i < arr.size(); ++i)\n            arr[i] = i + 1;\n        f(0, N - 1, N, arr);\n        return arr;\n    }\n\n    void f(int s, int e, int N, vector<int> &arr){\n        if(s == e){\n            arr[s] =  1;\n            return;\n        }\n        int odd = (N + 1) / 2;\n        f(s, s + odd - 1, odd, arr);\n        for(int i = s; i < s + odd; i++)\n            arr[i] = arr[i] * 2 - 1;\n        f(s + odd, e, N - odd, arr);\n        for(int i = s + odd; i <= e; ++i)\n            arr[i] = arr[i] * 2;\n    }\n};\n```","source":"_posts/刷题/分治\n/932-Beautiful-Array.md","raw":"---\ntitle: 932. Beautiful Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-04 10:17:46\n---\n\n\n\n\n## [932. Beautiful Array](https://leetcode-cn.com/problems/beautiful-array/)\n\n## 思路：\n\n这题的难度是怎么想出一个策略来保存漂亮数组的存在。<!-- more -->\n\n将1~N的数字划分为奇数和偶数，并放到数组两边，即可保证。同时可以发现仿射变化对漂亮数组的性质没有影响。\n$$\n2 *(k *  a[k] + b) =  k *  a[i] + b + k *  a[j] + b\n$$\n\n\n那么就有任意一边的数字都可以通过仿射变化变为`1-(N/2+1/2)`的问题。比如，原本左边有$(n + 1) / 2$个奇数数字，右边有$N/2$个偶数数字。那么左边的奇数数字可以通过仿射变化$a[i]'= a[i]/2 + 1/2$，右边的偶数数字可以通过仿射变化$a[i]'= a[i]/2$，将问题分解成了规模减半的两个子问题。\n\n通过递归分治我们可以解决该问题。\n\n## 代码：\n\n100%\n\n```c++\nclass Solution {\npublic:\n    vector<int> beautifulArray(int N) {\n        vector<int> arr(N);\n        for(int i = 0; i < arr.size(); ++i)\n            arr[i] = i + 1;\n        f(0, N - 1, N, arr);\n        return arr;\n    }\n\n    void f(int s, int e, int N, vector<int> &arr){\n        if(s == e){\n            arr[s] =  1;\n            return;\n        }\n        int odd = (N + 1) / 2;\n        f(s, s + odd - 1, odd, arr);\n        for(int i = s; i < s + odd; i++)\n            arr[i] = arr[i] * 2 - 1;\n        f(s + odd, e, N - odd, arr);\n        for(int i = s + odd; i <= e; ++i)\n            arr[i] = arr[i] * 2;\n    }\n};\n```","slug":"刷题-分治-932-Beautiful-Array","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j50002fl5uoeg9aeni4","content":"<h2 id=\"932-Beautiful-Array\"><a href=\"#932-Beautiful-Array\" class=\"headerlink\" title=\"932. Beautiful Array\"></a><a href=\"https://leetcode-cn.com/problems/beautiful-array/\">932. Beautiful Array</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题的难度是怎么想出一个策略来保存漂亮数组的存在。<span id=\"more\"></span></p>\n<p>将1~N的数字划分为奇数和偶数，并放到数组两边，即可保证。同时可以发现仿射变化对漂亮数组的性质没有影响。<br>$$<br>2 *(k *  a[k] + b) =  k *  a[i] + b + k *  a[j] + b<br>$$</p>\n<p>那么就有任意一边的数字都可以通过仿射变化变为<code>1-(N/2+1/2)</code>的问题。比如，原本左边有$(n + 1) / 2$个奇数数字，右边有$N/2$个偶数数字。那么左边的奇数数字可以通过仿射变化$a[i]’= a[i]/2 + 1/2$，右边的偶数数字可以通过仿射变化$a[i]’= a[i]/2$，将问题分解成了规模减半的两个子问题。</p>\n<p>通过递归分治我们可以解决该问题。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>100%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; beautifulArray(int N) &#123;\n        vector&lt;int&gt; arr(N);\n        for(int i &#x3D; 0; i &lt; arr.size(); ++i)\n            arr[i] &#x3D; i + 1;\n        f(0, N - 1, N, arr);\n        return arr;\n    &#125;\n\n    void f(int s, int e, int N, vector&lt;int&gt; &amp;arr)&#123;\n        if(s &#x3D;&#x3D; e)&#123;\n            arr[s] &#x3D;  1;\n            return;\n        &#125;\n        int odd &#x3D; (N + 1) &#x2F; 2;\n        f(s, s + odd - 1, odd, arr);\n        for(int i &#x3D; s; i &lt; s + odd; i++)\n            arr[i] &#x3D; arr[i] * 2 - 1;\n        f(s + odd, e, N - odd, arr);\n        for(int i &#x3D; s + odd; i &lt;&#x3D; e; ++i)\n            arr[i] &#x3D; arr[i] * 2;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3AN1PPN","excerpt":"<h2 id=\"932-Beautiful-Array\"><a href=\"#932-Beautiful-Array\" class=\"headerlink\" title=\"932. Beautiful Array\"></a><a href=\"https://leetcode-cn.com/problems/beautiful-array/\">932. Beautiful Array</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题的难度是怎么想出一个策略来保存漂亮数组的存在。","more":"</p>\n<p>将1~N的数字划分为奇数和偶数，并放到数组两边，即可保证。同时可以发现仿射变化对漂亮数组的性质没有影响。<br>$$<br>2 *(k *  a[k] + b) =  k *  a[i] + b + k *  a[j] + b<br>$$</p>\n<p>那么就有任意一边的数字都可以通过仿射变化变为<code>1-(N/2+1/2)</code>的问题。比如，原本左边有$(n + 1) / 2$个奇数数字，右边有$N/2$个偶数数字。那么左边的奇数数字可以通过仿射变化$a[i]’= a[i]/2 + 1/2$，右边的偶数数字可以通过仿射变化$a[i]’= a[i]/2$，将问题分解成了规模减半的两个子问题。</p>\n<p>通过递归分治我们可以解决该问题。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>100%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; beautifulArray(int N) &#123;\n        vector&lt;int&gt; arr(N);\n        for(int i &#x3D; 0; i &lt; arr.size(); ++i)\n            arr[i] &#x3D; i + 1;\n        f(0, N - 1, N, arr);\n        return arr;\n    &#125;\n\n    void f(int s, int e, int N, vector&lt;int&gt; &amp;arr)&#123;\n        if(s &#x3D;&#x3D; e)&#123;\n            arr[s] &#x3D;  1;\n            return;\n        &#125;\n        int odd &#x3D; (N + 1) &#x2F; 2;\n        f(s, s + odd - 1, odd, arr);\n        for(int i &#x3D; s; i &lt; s + odd; i++)\n            arr[i] &#x3D; arr[i] * 2 - 1;\n        f(s + odd, e, N - odd, arr);\n        for(int i &#x3D; s + odd; i &lt;&#x3D; e; ++i)\n            arr[i] &#x3D; arr[i] * 2;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"142. Linked List Cycle II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-19T05:53:17.000Z","_content":"\n\n<!-- more -->\n\n\n\n## 思路：\n\n用快慢指针`fast`，`slow`去发现链表中的圆，再使用一个指针和`p1`一起遍历链表：\n\n![fig1](http://static.come2rss.xyz/142_fig1.png)\n\n`2(a + b)  = a + b + (b + c ) *n `得到\n\n`a = c + (b + c ) *(n - 1)` \n\n如此可以推得，如果从`p0`从head和`slow`一起出发，会在环的入口处相遇。如此就可以推得算法的正确性。\n\n另外开始验证，`fast`和`low`会在第一个`low`指针的第一圈相遇。\n\n> 设置两个指针相遇时，`low`指针走了路程`s1 = a + s + n(b + c)`，`fast`指针走了路程`s2 = a + s + k(b + c)`。同时有`s1 * 2 = s2`，则有`a + s = (k - 2n)(b +c)`。\n\n上面的证法不行：\n\n设`slow`刚入环的时候，`fast`在距离环入口的位置`B`，慢指针走了`C`,最后设环长为`L`。\n\n`C % L = (2 *C + B) % L`\n\n等价于\n\n`C + NL =  2 * C + B`\n\n`C = NL - B ` 当N==1，有`0<=C<=B`\n\n当然，需要另外一个推理：\n\n两个步长分别为1和2的指针，经过必定能相遇，可以通过遍历所有状态得知。\n\n\n\n## 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *p1 = head, *p2 = head;\n        int flag = 0, cyclen = 0, tlen = 0;\n        while(p1){\n            p1 = p1->next;\n            if(p1 == nullptr) return nullptr;\n            p1 = p1->next;\n            p2 = p2->next;\n            if(p1 == p2) break;            \n        }\n        if(p1 == nullptr) return nullptr;\n        // while(1){\n        //     p1 = p1->next->next;\n        //     p2 = p2->next;\n        //     cyclen++;   \n        //     if(p1 == p2) break;         \n        // }\n        ListNode *p0 = head;\n        while(p0 != p1){\n            p0 = p0->next;\n            p1 = p1->next;\n            tlen++;\n        }\n        return p0;\n    }\n};\n```\n\n","source":"_posts/刷题/双指针/142-Linked-List-Cycle-II.md","raw":"---\ntitle: 142. Linked List Cycle II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-19 13:53:17\n---\n\n\n<!-- more -->\n\n\n\n## 思路：\n\n用快慢指针`fast`，`slow`去发现链表中的圆，再使用一个指针和`p1`一起遍历链表：\n\n![fig1](http://static.come2rss.xyz/142_fig1.png)\n\n`2(a + b)  = a + b + (b + c ) *n `得到\n\n`a = c + (b + c ) *(n - 1)` \n\n如此可以推得，如果从`p0`从head和`slow`一起出发，会在环的入口处相遇。如此就可以推得算法的正确性。\n\n另外开始验证，`fast`和`low`会在第一个`low`指针的第一圈相遇。\n\n> 设置两个指针相遇时，`low`指针走了路程`s1 = a + s + n(b + c)`，`fast`指针走了路程`s2 = a + s + k(b + c)`。同时有`s1 * 2 = s2`，则有`a + s = (k - 2n)(b +c)`。\n\n上面的证法不行：\n\n设`slow`刚入环的时候，`fast`在距离环入口的位置`B`，慢指针走了`C`,最后设环长为`L`。\n\n`C % L = (2 *C + B) % L`\n\n等价于\n\n`C + NL =  2 * C + B`\n\n`C = NL - B ` 当N==1，有`0<=C<=B`\n\n当然，需要另外一个推理：\n\n两个步长分别为1和2的指针，经过必定能相遇，可以通过遍历所有状态得知。\n\n\n\n## 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *p1 = head, *p2 = head;\n        int flag = 0, cyclen = 0, tlen = 0;\n        while(p1){\n            p1 = p1->next;\n            if(p1 == nullptr) return nullptr;\n            p1 = p1->next;\n            p2 = p2->next;\n            if(p1 == p2) break;            \n        }\n        if(p1 == nullptr) return nullptr;\n        // while(1){\n        //     p1 = p1->next->next;\n        //     p2 = p2->next;\n        //     cyclen++;   \n        //     if(p1 == p2) break;         \n        // }\n        ListNode *p0 = head;\n        while(p0 != p1){\n            p0 = p0->next;\n            p1 = p1->next;\n            tlen++;\n        }\n        return p0;\n    }\n};\n```\n\n","slug":"刷题/双指针/142-Linked-List-Cycle-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j51002gl5uo14e2ftp5","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用快慢指针<code>fast</code>，<code>slow</code>去发现链表中的圆，再使用一个指针和<code>p1</code>一起遍历链表：</p>\n<p><img src=\"http://static.come2rss.xyz/142_fig1.png\" alt=\"fig1\"></p>\n<p><code>2(a + b)  = a + b + (b + c ) *n </code>得到</p>\n<p><code>a = c + (b + c ) *(n - 1)</code> </p>\n<p>如此可以推得，如果从<code>p0</code>从head和<code>slow</code>一起出发，会在环的入口处相遇。如此就可以推得算法的正确性。</p>\n<p>另外开始验证，<code>fast</code>和<code>low</code>会在第一个<code>low</code>指针的第一圈相遇。</p>\n<blockquote>\n<p>设置两个指针相遇时，<code>low</code>指针走了路程<code>s1 = a + s + n(b + c)</code>，<code>fast</code>指针走了路程<code>s2 = a + s + k(b + c)</code>。同时有<code>s1 * 2 = s2</code>，则有<code>a + s = (k - 2n)(b +c)</code>。</p>\n</blockquote>\n<p>上面的证法不行：</p>\n<p>设<code>slow</code>刚入环的时候，<code>fast</code>在距离环入口的位置<code>B</code>，慢指针走了<code>C</code>,最后设环长为<code>L</code>。</p>\n<p><code>C % L = (2 *C + B) % L</code></p>\n<p>等价于</p>\n<p><code>C + NL =  2 * C + B</code></p>\n<p><code>C = NL - B </code> 当N==1，有<code>0&lt;=C&lt;=B</code></p>\n<p>当然，需要另外一个推理：</p>\n<p>两个步长分别为1和2的指针，经过必定能相遇，可以通过遍历所有状态得知。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        ListNode *p1 &#x3D; head, *p2 &#x3D; head;\n        int flag &#x3D; 0, cyclen &#x3D; 0, tlen &#x3D; 0;\n        while(p1)&#123;\n            p1 &#x3D; p1-&gt;next;\n            if(p1 &#x3D;&#x3D; nullptr) return nullptr;\n            p1 &#x3D; p1-&gt;next;\n            p2 &#x3D; p2-&gt;next;\n            if(p1 &#x3D;&#x3D; p2) break;            \n        &#125;\n        if(p1 &#x3D;&#x3D; nullptr) return nullptr;\n        &#x2F;&#x2F; while(1)&#123;\n        &#x2F;&#x2F;     p1 &#x3D; p1-&gt;next-&gt;next;\n        &#x2F;&#x2F;     p2 &#x3D; p2-&gt;next;\n        &#x2F;&#x2F;     cyclen++;   \n        &#x2F;&#x2F;     if(p1 &#x3D;&#x3D; p2) break;         \n        &#x2F;&#x2F; &#125;\n        ListNode *p0 &#x3D; head;\n        while(p0 !&#x3D; p1)&#123;\n            p0 &#x3D; p0-&gt;next;\n            p1 &#x3D; p1-&gt;next;\n            tlen++;\n        &#125;\n        return p0;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"32RASR8","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用快慢指针<code>fast</code>，<code>slow</code>去发现链表中的圆，再使用一个指针和<code>p1</code>一起遍历链表：</p>\n<p><img src=\"http://static.come2rss.xyz/142_fig1.png\" alt=\"fig1\"></p>\n<p><code>2(a + b)  = a + b + (b + c ) *n </code>得到</p>\n<p><code>a = c + (b + c ) *(n - 1)</code> </p>\n<p>如此可以推得，如果从<code>p0</code>从head和<code>slow</code>一起出发，会在环的入口处相遇。如此就可以推得算法的正确性。</p>\n<p>另外开始验证，<code>fast</code>和<code>low</code>会在第一个<code>low</code>指针的第一圈相遇。</p>\n<blockquote>\n<p>设置两个指针相遇时，<code>low</code>指针走了路程<code>s1 = a + s + n(b + c)</code>，<code>fast</code>指针走了路程<code>s2 = a + s + k(b + c)</code>。同时有<code>s1 * 2 = s2</code>，则有<code>a + s = (k - 2n)(b +c)</code>。</p>\n</blockquote>\n<p>上面的证法不行：</p>\n<p>设<code>slow</code>刚入环的时候，<code>fast</code>在距离环入口的位置<code>B</code>，慢指针走了<code>C</code>,最后设环长为<code>L</code>。</p>\n<p><code>C % L = (2 *C + B) % L</code></p>\n<p>等价于</p>\n<p><code>C + NL =  2 * C + B</code></p>\n<p><code>C = NL - B </code> 当N==1，有<code>0&lt;=C&lt;=B</code></p>\n<p>当然，需要另外一个推理：</p>\n<p>两个步长分别为1和2的指针，经过必定能相遇，可以通过遍历所有状态得知。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        ListNode *p1 &#x3D; head, *p2 &#x3D; head;\n        int flag &#x3D; 0, cyclen &#x3D; 0, tlen &#x3D; 0;\n        while(p1)&#123;\n            p1 &#x3D; p1-&gt;next;\n            if(p1 &#x3D;&#x3D; nullptr) return nullptr;\n            p1 &#x3D; p1-&gt;next;\n            p2 &#x3D; p2-&gt;next;\n            if(p1 &#x3D;&#x3D; p2) break;            \n        &#125;\n        if(p1 &#x3D;&#x3D; nullptr) return nullptr;\n        &#x2F;&#x2F; while(1)&#123;\n        &#x2F;&#x2F;     p1 &#x3D; p1-&gt;next-&gt;next;\n        &#x2F;&#x2F;     p2 &#x3D; p2-&gt;next;\n        &#x2F;&#x2F;     cyclen++;   \n        &#x2F;&#x2F;     if(p1 &#x3D;&#x3D; p2) break;         \n        &#x2F;&#x2F; &#125;\n        ListNode *p0 &#x3D; head;\n        while(p0 !&#x3D; p1)&#123;\n            p0 &#x3D; p0-&gt;next;\n            p1 &#x3D; p1-&gt;next;\n            tlen++;\n        &#125;\n        return p0;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"167. Two Sum II - Input array is sorted","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-17T00:41:18.000Z","_content":"\n<!-- more -->\n\n## 思路：\n\n双指针遍历。复杂度$O(n)$。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int n = numbers.size();\n        int l = 0, r = n - 1;\n        while(l < r){\n            int s = numbers[l] + numbers[r];\n            if(s > target) r--;\n            else if(s < target) l++;\n            else break;\n        }\n        // vector<int> v(2,0);\n        // v[0] = l + 1; v[1] = r + 1;\n        // return v;\n        return {l + 1, r + 1};    \n    }\n};\n```\n\n","source":"_posts/刷题/双指针/167-Two-Sum-II-Input-array-is-sorted.md","raw":"---\ntitle: 167. Two Sum II - Input array is sorted\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-17 08:41:18\n---\n\n<!-- more -->\n\n## 思路：\n\n双指针遍历。复杂度$O(n)$。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int n = numbers.size();\n        int l = 0, r = n - 1;\n        while(l < r){\n            int s = numbers[l] + numbers[r];\n            if(s > target) r--;\n            else if(s < target) l++;\n            else break;\n        }\n        // vector<int> v(2,0);\n        // v[0] = l + 1; v[1] = r + 1;\n        // return v;\n        return {l + 1, r + 1};    \n    }\n};\n```\n\n","slug":"刷题/双指针/167-Two-Sum-II-Input-array-is-sorted","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j52002hl5uo1ljqfxqs","content":"<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>双指针遍历。复杂度$O(n)$。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;\n        int n &#x3D; numbers.size();\n        int l &#x3D; 0, r &#x3D; n - 1;\n        while(l &lt; r)&#123;\n            int s &#x3D; numbers[l] + numbers[r];\n            if(s &gt; target) r--;\n            else if(s &lt; target) l++;\n            else break;\n        &#125;\n        &#x2F;&#x2F; vector&lt;int&gt; v(2,0);\n        &#x2F;&#x2F; v[0] &#x3D; l + 1; v[1] &#x3D; r + 1;\n        &#x2F;&#x2F; return v;\n        return &#123;l + 1, r + 1&#125;;    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"V0NZ7T","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>双指针遍历。复杂度$O(n)$。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;\n        int n &#x3D; numbers.size();\n        int l &#x3D; 0, r &#x3D; n - 1;\n        while(l &lt; r)&#123;\n            int s &#x3D; numbers[l] + numbers[r];\n            if(s &gt; target) r--;\n            else if(s &lt; target) l++;\n            else break;\n        &#125;\n        &#x2F;&#x2F; vector&lt;int&gt; v(2,0);\n        &#x2F;&#x2F; v[0] &#x3D; l + 1; v[1] &#x3D; r + 1;\n        &#x2F;&#x2F; return v;\n        return &#123;l + 1, r + 1&#125;;    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"287. Find the Duplicate Number","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-05T12:37:27.000Z","_content":"\n\n\n\n\n\n\n\n\n\n# [287. Find the Duplicate Number](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n## 思路\n\n快慢指针算法，$o(n), o(1)$。\n\n这题的难点是看出能把数组转化为链表，而且链表中有环。<!-- more -->\n\n## 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2;\n        int p1 = 0, p2 = 0;\n        do{\n            p1 = nums[nums[p1]];\n            p2 = nums[p2];\n        }while(p1 != p2);\n        p2 = 0;\n        while(p1 != p2){\n            p1 = nums[p1];\n            p2 = nums[p2];\n        }\n      return p1; // p1才是重复的数字/idx\n    }\n};\n```\n\n\n\n","source":"_posts/刷题/双指针/287-Find-the-Duplicate-Number.md","raw":"---\ntitle: 287. Find the Duplicate Number\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-05 20:37:27\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n\n\n\n# [287. Find the Duplicate Number](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n## 思路\n\n快慢指针算法，$o(n), o(1)$。\n\n这题的难点是看出能把数组转化为链表，而且链表中有环。<!-- more -->\n\n## 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2;\n        int p1 = 0, p2 = 0;\n        do{\n            p1 = nums[nums[p1]];\n            p2 = nums[p2];\n        }while(p1 != p2);\n        p2 = 0;\n        while(p1 != p2){\n            p1 = nums[p1];\n            p2 = nums[p2];\n        }\n      return p1; // p1才是重复的数字/idx\n    }\n};\n```\n\n\n\n","slug":"刷题/双指针/287-Find-the-Duplicate-Number","published":1,"updated":"2021-02-05T12:39:26.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j53002il5uo05rx1uaa","content":"<h1 id=\"287-Find-the-Duplicate-Number\"><a href=\"#287-Find-the-Duplicate-Number\" class=\"headerlink\" title=\"287. Find the Duplicate Number\"></a><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\">287. Find the Duplicate Number</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>快慢指针算法，$o(n), o(1)$。</p>\n<p>这题的难点是看出能把数组转化为链表，而且链表中有环。<span id=\"more\"></span></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() &#x2F; 2;\n        int p1 &#x3D; 0, p2 &#x3D; 0;\n        do&#123;\n            p1 &#x3D; nums[nums[p1]];\n            p2 &#x3D; nums[p2];\n        &#125;while(p1 !&#x3D; p2);\n        p2 &#x3D; 0;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; nums[p1];\n            p2 &#x3D; nums[p2];\n        &#125;\n      return p1; &#x2F;&#x2F; p1才是重复的数字&#x2F;idx\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","site":{"data":{}},"abbrlink":"2PFCP41","excerpt":"<h1 id=\"287-Find-the-Duplicate-Number\"><a href=\"#287-Find-the-Duplicate-Number\" class=\"headerlink\" title=\"287. Find the Duplicate Number\"></a><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\">287. Find the Duplicate Number</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>快慢指针算法，$o(n), o(1)$。</p>\n<p>这题的难点是看出能把数组转化为链表，而且链表中有环。","more":"</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() &#x2F; 2;\n        int p1 &#x3D; 0, p2 &#x3D; 0;\n        do&#123;\n            p1 &#x3D; nums[nums[p1]];\n            p2 &#x3D; nums[p2];\n        &#125;while(p1 !&#x3D; p2);\n        p2 &#x3D; 0;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; nums[p1];\n            p2 &#x3D; nums[p2];\n        &#125;\n      return p1; &#x2F;&#x2F; p1才是重复的数字&#x2F;idx\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"438. Find All Anagrams in a String","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-04-30T05:15:01.000Z","_content":"\n\n\n\n\n\n\n\n## 思路：\n\n双指针，指向模式串`str`的子串首位`s`和末尾+1`e`。\n\n遍历思路：\n\n1. 不断添加`e`位置上的字符`c`\n2. 如果`c`不属于`p`，则双指针跳过`c`\n3. 如果`c`属于`p`，则更新。\n   1. 但是如果包括的`c`字符太多了，则移动`s`直至数量符合条件\n   2. 如果所有字符数量都添加完全一致，则添加结果。移动`s`一位，更新即可。\n\n\n\n\n\n看了其他题解，发现有一个条件我忽略了，指针之间的距离是相等的，也就是说这是一个滑动窗口问题~草了。\n\n那这很简单，维护一下窗口值就行了。\n\n> 可以说滑动窗口就是一个简单的双指针。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\n    map<char, int> group, times;// group: [s, e) 之间的字符出现次数， time: p字符出现次数\npublic:\n    vector<int> findAnagrams(string str, string p) {\n        int s = 0, e = 0;\n        for(auto c : p) ++times[c];\n        int groopsize = p.size();\n        vector<int> indexes;\n\n        while( s < str.size() && e < str.size()){\n            \n            if(times[str[e]] == 0) {\n                s = e + 1;\n                group.clear();\n                groopsize = p.size();\n            }else{\n                ++group[str[e]];\n                --groopsize;  \n                // 出现次数过多， 向前收缩s\n                while( group[str[e]] > times[str[e]]){    \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                       \n                }\n                // [s, e)内是p的anagram\n                if(groopsize == 0){\n                    indexes.push_back(s);                \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                    \n                }\n            }\n\n            ++e;\n            // cout << s << ' ' << e << \" \" << groopsize << endl;\n        }\n        // cout << endl;\n        return indexes;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {    \npublic:\n    vector<int> findAnagrams(string str, string p) {\n        int s = 0, e = 0;\n        vector<int> indexes, window, need;\n        if(p.size()>str.size()) return {};\n        window.resize(128);\n        need.resize(128);\n        for(int i = 0; i < p.size(); ++i){\n            ++window[str[i]];\n            ++need[p[i]];\n        } \n        e = p.size();    \n        while(e <= str.size()){\n            if(window == need) indexes.push_back(s);\n            if(str.size() == e) break;\n            window[str[e++]]++;\n        \n            window[str[s++]]--;\n            \n        }  \n          \n        return indexes;\n    }\n};\n```\n\n","source":"_posts/刷题/双指针/438-Find-All-Anagrams-in-a-String.md","raw":"---\ntitle: 438. Find All Anagrams in a String\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-04-30 13:15:01\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n\n## 思路：\n\n双指针，指向模式串`str`的子串首位`s`和末尾+1`e`。\n\n遍历思路：\n\n1. 不断添加`e`位置上的字符`c`\n2. 如果`c`不属于`p`，则双指针跳过`c`\n3. 如果`c`属于`p`，则更新。\n   1. 但是如果包括的`c`字符太多了，则移动`s`直至数量符合条件\n   2. 如果所有字符数量都添加完全一致，则添加结果。移动`s`一位，更新即可。\n\n\n\n\n\n看了其他题解，发现有一个条件我忽略了，指针之间的距离是相等的，也就是说这是一个滑动窗口问题~草了。\n\n那这很简单，维护一下窗口值就行了。\n\n> 可以说滑动窗口就是一个简单的双指针。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\n    map<char, int> group, times;// group: [s, e) 之间的字符出现次数， time: p字符出现次数\npublic:\n    vector<int> findAnagrams(string str, string p) {\n        int s = 0, e = 0;\n        for(auto c : p) ++times[c];\n        int groopsize = p.size();\n        vector<int> indexes;\n\n        while( s < str.size() && e < str.size()){\n            \n            if(times[str[e]] == 0) {\n                s = e + 1;\n                group.clear();\n                groopsize = p.size();\n            }else{\n                ++group[str[e]];\n                --groopsize;  \n                // 出现次数过多， 向前收缩s\n                while( group[str[e]] > times[str[e]]){    \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                       \n                }\n                // [s, e)内是p的anagram\n                if(groopsize == 0){\n                    indexes.push_back(s);                \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                    \n                }\n            }\n\n            ++e;\n            // cout << s << ' ' << e << \" \" << groopsize << endl;\n        }\n        // cout << endl;\n        return indexes;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {    \npublic:\n    vector<int> findAnagrams(string str, string p) {\n        int s = 0, e = 0;\n        vector<int> indexes, window, need;\n        if(p.size()>str.size()) return {};\n        window.resize(128);\n        need.resize(128);\n        for(int i = 0; i < p.size(); ++i){\n            ++window[str[i]];\n            ++need[p[i]];\n        } \n        e = p.size();    \n        while(e <= str.size()){\n            if(window == need) indexes.push_back(s);\n            if(str.size() == e) break;\n            window[str[e++]]++;\n        \n            window[str[s++]]--;\n            \n        }  \n          \n        return indexes;\n    }\n};\n```\n\n","slug":"刷题/双指针/438-Find-All-Anagrams-in-a-String","published":1,"updated":"2021-04-30T06:24:07.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j53002jl5uo175b2keg","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>双指针，指向模式串<code>str</code>的子串首位<code>s</code>和末尾+1<code>e</code>。</p>\n<p>遍历思路：</p>\n<ol>\n<li>不断添加<code>e</code>位置上的字符<code>c</code></li>\n<li>如果<code>c</code>不属于<code>p</code>，则双指针跳过<code>c</code></li>\n<li>如果<code>c</code>属于<code>p</code>，则更新。<ol>\n<li>但是如果包括的<code>c</code>字符太多了，则移动<code>s</code>直至数量符合条件</li>\n<li>如果所有字符数量都添加完全一致，则添加结果。移动<code>s</code>一位，更新即可。</li>\n</ol>\n</li>\n</ol>\n<p>看了其他题解，发现有一个条件我忽略了，指针之间的距离是相等的，也就是说这是一个滑动窗口问题~草了。</p>\n<p>那这很简单，维护一下窗口值就行了。</p>\n<blockquote>\n<p>可以说滑动窗口就是一个简单的双指针。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    map&lt;char, int&gt; group, times;&#x2F;&#x2F; group: [s, e) 之间的字符出现次数， time: p字符出现次数\npublic:\n    vector&lt;int&gt; findAnagrams(string str, string p) &#123;\n        int s &#x3D; 0, e &#x3D; 0;\n        for(auto c : p) ++times[c];\n        int groopsize &#x3D; p.size();\n        vector&lt;int&gt; indexes;\n\n        while( s &lt; str.size() &amp;&amp; e &lt; str.size())&#123;\n            \n            if(times[str[e]] &#x3D;&#x3D; 0) &#123;\n                s &#x3D; e + 1;\n                group.clear();\n                groopsize &#x3D; p.size();\n            &#125;else&#123;\n                ++group[str[e]];\n                --groopsize;  \n                &#x2F;&#x2F; 出现次数过多， 向前收缩s\n                while( group[str[e]] &gt; times[str[e]])&#123;    \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                       \n                &#125;\n                &#x2F;&#x2F; [s, e)内是p的anagram\n                if(groopsize &#x3D;&#x3D; 0)&#123;\n                    indexes.push_back(s);                \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                    \n                &#125;\n            &#125;\n\n            ++e;\n            &#x2F;&#x2F; cout &lt;&lt; s &lt;&lt; &#39; &#39; &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; groopsize &lt;&lt; endl;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        return indexes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;    \npublic:\n    vector&lt;int&gt; findAnagrams(string str, string p) &#123;\n        int s &#x3D; 0, e &#x3D; 0;\n        vector&lt;int&gt; indexes, window, need;\n        if(p.size()&gt;str.size()) return &#123;&#125;;\n        window.resize(128);\n        need.resize(128);\n        for(int i &#x3D; 0; i &lt; p.size(); ++i)&#123;\n            ++window[str[i]];\n            ++need[p[i]];\n        &#125; \n        e &#x3D; p.size();    \n        while(e &lt;&#x3D; str.size())&#123;\n            if(window &#x3D;&#x3D; need) indexes.push_back(s);\n            if(str.size() &#x3D;&#x3D; e) break;\n            window[str[e++]]++;\n        \n            window[str[s++]]--;\n            \n        &#125;  \n          \n        return indexes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1DQN9KW","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>双指针，指向模式串<code>str</code>的子串首位<code>s</code>和末尾+1<code>e</code>。</p>\n<p>遍历思路：</p>\n<ol>\n<li>不断添加<code>e</code>位置上的字符<code>c</code></li>\n<li>如果<code>c</code>不属于<code>p</code>，则双指针跳过<code>c</code></li>\n<li>如果<code>c</code>属于<code>p</code>，则更新。<ol>\n<li>但是如果包括的<code>c</code>字符太多了，则移动<code>s</code>直至数量符合条件</li>\n<li>如果所有字符数量都添加完全一致，则添加结果。移动<code>s</code>一位，更新即可。</li>\n</ol>\n</li>\n</ol>\n<p>看了其他题解，发现有一个条件我忽略了，指针之间的距离是相等的，也就是说这是一个滑动窗口问题~草了。</p>\n<p>那这很简单，维护一下窗口值就行了。</p>\n<blockquote>\n<p>可以说滑动窗口就是一个简单的双指针。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    map&lt;char, int&gt; group, times;&#x2F;&#x2F; group: [s, e) 之间的字符出现次数， time: p字符出现次数\npublic:\n    vector&lt;int&gt; findAnagrams(string str, string p) &#123;\n        int s &#x3D; 0, e &#x3D; 0;\n        for(auto c : p) ++times[c];\n        int groopsize &#x3D; p.size();\n        vector&lt;int&gt; indexes;\n\n        while( s &lt; str.size() &amp;&amp; e &lt; str.size())&#123;\n            \n            if(times[str[e]] &#x3D;&#x3D; 0) &#123;\n                s &#x3D; e + 1;\n                group.clear();\n                groopsize &#x3D; p.size();\n            &#125;else&#123;\n                ++group[str[e]];\n                --groopsize;  \n                &#x2F;&#x2F; 出现次数过多， 向前收缩s\n                while( group[str[e]] &gt; times[str[e]])&#123;    \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                       \n                &#125;\n                &#x2F;&#x2F; [s, e)内是p的anagram\n                if(groopsize &#x3D;&#x3D; 0)&#123;\n                    indexes.push_back(s);                \n                    --group[str[s]];\n                    ++s;\n                    ++groopsize;                    \n                &#125;\n            &#125;\n\n            ++e;\n            &#x2F;&#x2F; cout &lt;&lt; s &lt;&lt; &#39; &#39; &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; groopsize &lt;&lt; endl;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        return indexes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;    \npublic:\n    vector&lt;int&gt; findAnagrams(string str, string p) &#123;\n        int s &#x3D; 0, e &#x3D; 0;\n        vector&lt;int&gt; indexes, window, need;\n        if(p.size()&gt;str.size()) return &#123;&#125;;\n        window.resize(128);\n        need.resize(128);\n        for(int i &#x3D; 0; i &lt; p.size(); ++i)&#123;\n            ++window[str[i]];\n            ++need[p[i]];\n        &#125; \n        e &#x3D; p.size();    \n        while(e &lt;&#x3D; str.size())&#123;\n            if(window &#x3D;&#x3D; need) indexes.push_back(s);\n            if(str.size() &#x3D;&#x3D; e) break;\n            window[str[e++]]++;\n        \n            window[str[s++]]--;\n            \n        &#125;  \n          \n        return indexes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"633. Sum of Square Numbers","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-24T01:34:40.000Z","_content":"\n## [633. Sum of Square Numbers](https://leetcode-cn.com/problems/sum-of-square-numbers/)\n\n<!-- more -->\n\n## 思路：\n\n1. 二分\n\n2. 分解质因子判断费马平方定理条件是否成立\n\n   >  任何一个等于两个数的平方之和的数的所有值为$(4k+3)$的因子次幂是偶数的。\n\n3. 双指针法遍历即可（击败100%）\n\n\n\n## 代码：\n\n双指针法\n\n```c++\n\nclass Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        long long  sum, a = 0, b = (long long)(sqrt(c));\n        while(a <= b ){\n            sum  = a * a + b * b;\n            if(sum > c) b--;\n            else if(sum < c) a++;\n            else break;\n        }\n        if(sum == c) return true;\n        else return false;\n    }\n};\n\n\n\n\n```\n\n\n\n判断费马平方定理：\n\n```c++\nclass Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        // int d = (int)sqrt(c), ori  = c ;\n        // for(int i = 2; i <= d + 1 && c != 1; ++i){\n        for(int i = 2; i <= c; ++i){\n            if(c % i == 0){\n                int t = 0;\n                while(c % i == 0){\n                    ++t;\n                    c /= i;\n                }\n                if((i + 1) % 4 == 0){\n                    if(t & 1) return false;\n                }\n            }\n        }\n        // if(c == ori && (c + 1) % 4 == 0) return false;\n        return true;\n\n    }\n};\n```\n\n","source":"_posts/刷题/双指针/633-Sum-of-Square-Numbers.md","raw":"---\ntitle: 633. Sum of Square Numbers\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-24 09:34:40\n---\n\n## [633. Sum of Square Numbers](https://leetcode-cn.com/problems/sum-of-square-numbers/)\n\n<!-- more -->\n\n## 思路：\n\n1. 二分\n\n2. 分解质因子判断费马平方定理条件是否成立\n\n   >  任何一个等于两个数的平方之和的数的所有值为$(4k+3)$的因子次幂是偶数的。\n\n3. 双指针法遍历即可（击败100%）\n\n\n\n## 代码：\n\n双指针法\n\n```c++\n\nclass Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        long long  sum, a = 0, b = (long long)(sqrt(c));\n        while(a <= b ){\n            sum  = a * a + b * b;\n            if(sum > c) b--;\n            else if(sum < c) a++;\n            else break;\n        }\n        if(sum == c) return true;\n        else return false;\n    }\n};\n\n\n\n\n```\n\n\n\n判断费马平方定理：\n\n```c++\nclass Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        // int d = (int)sqrt(c), ori  = c ;\n        // for(int i = 2; i <= d + 1 && c != 1; ++i){\n        for(int i = 2; i <= c; ++i){\n            if(c % i == 0){\n                int t = 0;\n                while(c % i == 0){\n                    ++t;\n                    c /= i;\n                }\n                if((i + 1) % 4 == 0){\n                    if(t & 1) return false;\n                }\n            }\n        }\n        // if(c == ori && (c + 1) % 4 == 0) return false;\n        return true;\n\n    }\n};\n```\n\n","slug":"刷题/双指针/633-Sum-of-Square-Numbers","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j54002kl5uoh5cy5awk","content":"<h2 id=\"633-Sum-of-Square-Numbers\"><a href=\"#633-Sum-of-Square-Numbers\" class=\"headerlink\" title=\"633. Sum of Square Numbers\"></a><a href=\"https://leetcode-cn.com/problems/sum-of-square-numbers/\">633. Sum of Square Numbers</a></h2><span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>二分</p>\n</li>\n<li><p>分解质因子判断费马平方定理条件是否成立</p>\n<blockquote>\n<p> 任何一个等于两个数的平方之和的数的所有值为$(4k+3)$的因子次幂是偶数的。</p>\n</blockquote>\n</li>\n<li><p>双指针法遍历即可（击败100%）</p>\n</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>双指针法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool judgeSquareSum(int c) &#123;\n        long long  sum, a &#x3D; 0, b &#x3D; (long long)(sqrt(c));\n        while(a &lt;&#x3D; b )&#123;\n            sum  &#x3D; a * a + b * b;\n            if(sum &gt; c) b--;\n            else if(sum &lt; c) a++;\n            else break;\n        &#125;\n        if(sum &#x3D;&#x3D; c) return true;\n        else return false;\n    &#125;\n&#125;;\n\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>判断费马平方定理：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool judgeSquareSum(int c) &#123;\n        &#x2F;&#x2F; int d &#x3D; (int)sqrt(c), ori  &#x3D; c ;\n        &#x2F;&#x2F; for(int i &#x3D; 2; i &lt;&#x3D; d + 1 &amp;&amp; c !&#x3D; 1; ++i)&#123;\n        for(int i &#x3D; 2; i &lt;&#x3D; c; ++i)&#123;\n            if(c % i &#x3D;&#x3D; 0)&#123;\n                int t &#x3D; 0;\n                while(c % i &#x3D;&#x3D; 0)&#123;\n                    ++t;\n                    c &#x2F;&#x3D; i;\n                &#125;\n                if((i + 1) % 4 &#x3D;&#x3D; 0)&#123;\n                    if(t &amp; 1) return false;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; if(c &#x3D;&#x3D; ori &amp;&amp; (c + 1) % 4 &#x3D;&#x3D; 0) return false;\n        return true;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"24W38AQ","excerpt":"<h2 id=\"633-Sum-of-Square-Numbers\"><a href=\"#633-Sum-of-Square-Numbers\" class=\"headerlink\" title=\"633. Sum of Square Numbers\"></a><a href=\"https://leetcode-cn.com/problems/sum-of-square-numbers/\">633. Sum of Square Numbers</a></h2>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>二分</p>\n</li>\n<li><p>分解质因子判断费马平方定理条件是否成立</p>\n<blockquote>\n<p> 任何一个等于两个数的平方之和的数的所有值为$(4k+3)$的因子次幂是偶数的。</p>\n</blockquote>\n</li>\n<li><p>双指针法遍历即可（击败100%）</p>\n</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>双指针法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool judgeSquareSum(int c) &#123;\n        long long  sum, a &#x3D; 0, b &#x3D; (long long)(sqrt(c));\n        while(a &lt;&#x3D; b )&#123;\n            sum  &#x3D; a * a + b * b;\n            if(sum &gt; c) b--;\n            else if(sum &lt; c) a++;\n            else break;\n        &#125;\n        if(sum &#x3D;&#x3D; c) return true;\n        else return false;\n    &#125;\n&#125;;\n\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>判断费马平方定理：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool judgeSquareSum(int c) &#123;\n        &#x2F;&#x2F; int d &#x3D; (int)sqrt(c), ori  &#x3D; c ;\n        &#x2F;&#x2F; for(int i &#x3D; 2; i &lt;&#x3D; d + 1 &amp;&amp; c !&#x3D; 1; ++i)&#123;\n        for(int i &#x3D; 2; i &lt;&#x3D; c; ++i)&#123;\n            if(c % i &#x3D;&#x3D; 0)&#123;\n                int t &#x3D; 0;\n                while(c % i &#x3D;&#x3D; 0)&#123;\n                    ++t;\n                    c &#x2F;&#x3D; i;\n                &#125;\n                if((i + 1) % 4 &#x3D;&#x3D; 0)&#123;\n                    if(t &amp; 1) return false;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; if(c &#x3D;&#x3D; ori &amp;&amp; (c + 1) % 4 &#x3D;&#x3D; 0) return false;\n        return true;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"680. Valid Palindrome II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-26T02:01:17.000Z","_content":"\n#### [680. Valid Palindrome II](https://leetcode-cn.com/problems/valid-palindrome-ii/)\n\n## 思路：\n\n典型的贪心题 + 二指针。这题还蛮不错的。\n\n<!-- more -->\n\n运用题目给出的最多删一个的关键信息，就可以写出一个简单的算法：用两个指针变量遍历`string`两边，如果有不用的字符。尝试删除掉两个中的一个，判断剩下的字符串是否是Palindrome.\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n\n    bool isPartialPalindrome(string &s, int l, int r)\n    {\n        while(l < r){\n            if(s[l] != s[r]) return false;\n            ++l;\n            --r;\n        }\n        return true;\n    }\n    bool validPalindrome(string s) {\n        int l = 0, r = s.size() - 1;\n        while(l < r){\n            if(s[l] != s[r]){                \n                return isPartialPalindrome(s, l + 1, r) || isPartialPalindrome(s, l , r - 1);                 \n            }\n            ++l;\n            --r;\n        }\n        return true;\n        \n    }\n};\n```\n\n","source":"_posts/刷题/双指针/680-Valid-Palindrome-II.md","raw":"---\ntitle: 680. Valid Palindrome II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-26 10:01:17\n---\n\n#### [680. Valid Palindrome II](https://leetcode-cn.com/problems/valid-palindrome-ii/)\n\n## 思路：\n\n典型的贪心题 + 二指针。这题还蛮不错的。\n\n<!-- more -->\n\n运用题目给出的最多删一个的关键信息，就可以写出一个简单的算法：用两个指针变量遍历`string`两边，如果有不用的字符。尝试删除掉两个中的一个，判断剩下的字符串是否是Palindrome.\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n\n    bool isPartialPalindrome(string &s, int l, int r)\n    {\n        while(l < r){\n            if(s[l] != s[r]) return false;\n            ++l;\n            --r;\n        }\n        return true;\n    }\n    bool validPalindrome(string s) {\n        int l = 0, r = s.size() - 1;\n        while(l < r){\n            if(s[l] != s[r]){                \n                return isPartialPalindrome(s, l + 1, r) || isPartialPalindrome(s, l , r - 1);                 \n            }\n            ++l;\n            --r;\n        }\n        return true;\n        \n    }\n};\n```\n\n","slug":"刷题/双指针/680-Valid-Palindrome-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j55002ll5uo8wu62jvf","content":"<h4 id=\"680-Valid-Palindrome-II\"><a href=\"#680-Valid-Palindrome-II\" class=\"headerlink\" title=\"680. Valid Palindrome II\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/\">680. Valid Palindrome II</a></h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>典型的贪心题 + 二指针。这题还蛮不错的。</p>\n<span id=\"more\"></span>\n\n<p>运用题目给出的最多删一个的关键信息，就可以写出一个简单的算法：用两个指针变量遍历<code>string</code>两边，如果有不用的字符。尝试删除掉两个中的一个，判断剩下的字符串是否是Palindrome.</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    bool isPartialPalindrome(string &amp;s, int l, int r)\n    &#123;\n        while(l &lt; r)&#123;\n            if(s[l] !&#x3D; s[r]) return false;\n            ++l;\n            --r;\n        &#125;\n        return true;\n    &#125;\n    bool validPalindrome(string s) &#123;\n        int l &#x3D; 0, r &#x3D; s.size() - 1;\n        while(l &lt; r)&#123;\n            if(s[l] !&#x3D; s[r])&#123;                \n                return isPartialPalindrome(s, l + 1, r) || isPartialPalindrome(s, l , r - 1);                 \n            &#125;\n            ++l;\n            --r;\n        &#125;\n        return true;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3BAMZ06","excerpt":"<h4 id=\"680-Valid-Palindrome-II\"><a href=\"#680-Valid-Palindrome-II\" class=\"headerlink\" title=\"680. Valid Palindrome II\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/\">680. Valid Palindrome II</a></h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>典型的贪心题 + 二指针。这题还蛮不错的。</p>","more":"<p>运用题目给出的最多删一个的关键信息，就可以写出一个简单的算法：用两个指针变量遍历<code>string</code>两边，如果有不用的字符。尝试删除掉两个中的一个，判断剩下的字符串是否是Palindrome.</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    bool isPartialPalindrome(string &amp;s, int l, int r)\n    &#123;\n        while(l &lt; r)&#123;\n            if(s[l] !&#x3D; s[r]) return false;\n            ++l;\n            --r;\n        &#125;\n        return true;\n    &#125;\n    bool validPalindrome(string s) &#123;\n        int l &#x3D; 0, r &#x3D; s.size() - 1;\n        while(l &lt; r)&#123;\n            if(s[l] !&#x3D; s[r])&#123;                \n                return isPartialPalindrome(s, l + 1, r) || isPartialPalindrome(s, l , r - 1);                 \n            &#125;\n            ++l;\n            --r;\n        &#125;\n        return true;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"76. Minimum Window Substring","thumbnail":"http://static.come2rss.xyz/黑色幽默.jpg","toc":true,"top":10,"date":"2020-10-23T02:48:10.000Z","_content":"\n\n\n\n## [76. Minimum Window Substring](https://leetcode-cn.com/problems/minimum-window-substring/)\n\n\n\n## 思路1:\n\n经典双指针下的滑动窗口算法。滑动窗口的左右部分分别由两个指针`l`,`r`指向。\n\n<!-- more -->\n\n使用滑动窗口观察可能符号的条件的子串，并用`unordered_map`或者`map`来记录原字符串`s`和滑动窗口`win`中的元素个数。\n\n其算法过程如下：\n\n1. 窗口的右指针向右滑动一次，并检查窗口内是否有足够元素。若是，则左指针向右收缩窗口。重复上述步骤即可。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n\n    map<char, int> cur, ori;\n    //优化: 去除无效字符\n    int ahash[800] = {0};\n    bool check(){\n        for(const auto &p : ori){\n            if(cur[p.first] < p.second)\n                return false;                \n        }\n        return true;\n    }\n    string minWindow(string s, string t) {\n        for(int i = 0; i < t.size(); ++i){\n            ++ori[t[i]];\n            ahash[t[i]] = 1;\n        }\n        int l = 0, r = -1, maxLen = 0x7fffffff;\n        string ans = \"\" ;\n        \n        while(r < int(s.size())){            \n            while(++r < s.size() && !ahash[s[r]]);\n            if(r == s.size()) break;\n            ++cur[s[r]];\n            \n            // cout << l << ' ' << r << endl;\n            while(check() && l <= r){                \n                if(maxLen > r - l + 1){\n                    ans = s.substr(l, r - l + 1);\n                    maxLen = r - l + 1;\n                }\n                //先减再移动……这个bug\n                --cur[s[l]];   \n                while(++l <= r && !ahash[s[l]]);\n                    \n            }\n        } \n        return ans;\n    }\n};\n```\n\n\n\n## 思路2：\n\n更巧妙的方法：\n\n音量模拟：想象一排音量，分别代表着每个t中元素的个数。\n\n\n\n![音量图图片大全_uc今日头条新闻网](D:\\Blogfile\\pic\\76-Minimum-Window-Substring\\images)\n\n在滑动窗口向`r`指针在`t`向右扩展窗口中， 每遇到一个`s`中的元素就减去对应的音量值。如果滑动窗口中包含了`s`中的各个元素（包括种类和数量），那么就有音量图的每个柱子都在水平下以下或者持平，如果我们记录在水平线之上的数值变动——用`cnt`记录`--yin[s[i]] >=0`的剩余次数即可。\n\n如果`cnt==0`，说明窗口已经包括了所有元素，可以缩小范围，把左指针向👉右滑动。`cnt`的变动也是同理的。\n\n代码如下：\n\n## 代码2：\n\n```c++\nclass Solution {\npublic:\n\n    // 音量模拟\n    unordered_map<char, int> map;\n    string minWindow(string s, string t){\n        for(int i = 0; i < t.size(); ++i) ++map[t[i]];\n        int cnt = t.size(), l = 0, r = -1, start = l, maxl = s.size() + 1;\n        while(r < int(s.size())){\n            if(--map[s[++r]] >= 0) --cnt;\n            // cout << l << ' ' << r << ' ' << cnt << endl;\n            while(l <= r && cnt == 0){\n                if(maxl > r - l + 1){\n                    start = l;\n                    maxl = r - l + 1;\n                }\n                if(++map[s[l]] > 0) cnt++;\n                l++;  \n            }\n        }\n          return maxl == s.size() + 1 ? \"\" : s.substr(start, maxl);\n    }\n};\n\n```\n\n\n\n## 代码3：（二刷）\n\n\n\n```c++\nclass Solution {\npublic: \n    // 双指针必定都搜索到所有匹配串的原因是 所有以 g为终点的符合题意的的字符串s1，\n    // 其左端点必定可以向左移动，因为移动会包含到更多字符串\n    // 反过来想，从起点出发，右端点移动先尽可能包含多直到足够的字符，\n    // 再向右移动左端点尽可能减少多余的字符，获取一个尽可能短的字符串\n    // 为了尝试其他结果，不断地进行以下活动\n    //  移动右端点一次，缩短左端点，可以搜索到其他结果\n    \n    // 比较细节的是控制过程和循环结束\n    // \n    string minWindow(string s, string t) {\n        int ct[256] = {0}, allct = t.size();\n        string ans; \n        // s += 'A';\n        for(int i = 0; i < t.size(); ++i) ++ct[t[i]];\n        int p1 = 0, p2 = 0; // [)左闭右开空间，秒在不需要初始化\n        int minlen = s.size() + 1, minp1 = 0;\n        while(p2 < s.size()){\n            // 要么右移p2直到t字符串全部被囊括，要么试探性移动p2一个位置，进行其他位置的探索\n            while(p2 < s.size()){ // p2 <= s.size()\n                if(ct[s[p2]] > 0) --allct; // allct统计是否当前[p1, p2)是否有t的全部字符\n                --ct[s[p2]]; // 更新字符数量\n                ++p2;\n                if(allct == 0) break; //前进一步\n            }\n            while(ct[s[p1]] < 0){ // 如果该字符多余了，缩小左端点\n                ++ct[s[p1]];\n                ++p1;\n            }\n            if(allct == 0 && p2 - p1 < minlen){\n                minp1 = p1;                \n                minlen = p2 - p1;\n            } \n            // cout << p1 << ' ' << p2 << ' ' <<  allct << endl;\n        }\n        if(minlen > s.size())ans = \"\";\n        else ans = s.substr(minp1, minlen);\n        return ans;\n    }\n};\n```\n\n","source":"_posts/刷题/双指针/76-Minimum-Window-Substring.md","raw":"---\ntitle: 76. Minimum Window Substring\nthumbnail: 'http://static.come2rss.xyz/黑色幽默.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-23 10:48:10\n---\n\n\n\n\n## [76. Minimum Window Substring](https://leetcode-cn.com/problems/minimum-window-substring/)\n\n\n\n## 思路1:\n\n经典双指针下的滑动窗口算法。滑动窗口的左右部分分别由两个指针`l`,`r`指向。\n\n<!-- more -->\n\n使用滑动窗口观察可能符号的条件的子串，并用`unordered_map`或者`map`来记录原字符串`s`和滑动窗口`win`中的元素个数。\n\n其算法过程如下：\n\n1. 窗口的右指针向右滑动一次，并检查窗口内是否有足够元素。若是，则左指针向右收缩窗口。重复上述步骤即可。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n\n    map<char, int> cur, ori;\n    //优化: 去除无效字符\n    int ahash[800] = {0};\n    bool check(){\n        for(const auto &p : ori){\n            if(cur[p.first] < p.second)\n                return false;                \n        }\n        return true;\n    }\n    string minWindow(string s, string t) {\n        for(int i = 0; i < t.size(); ++i){\n            ++ori[t[i]];\n            ahash[t[i]] = 1;\n        }\n        int l = 0, r = -1, maxLen = 0x7fffffff;\n        string ans = \"\" ;\n        \n        while(r < int(s.size())){            \n            while(++r < s.size() && !ahash[s[r]]);\n            if(r == s.size()) break;\n            ++cur[s[r]];\n            \n            // cout << l << ' ' << r << endl;\n            while(check() && l <= r){                \n                if(maxLen > r - l + 1){\n                    ans = s.substr(l, r - l + 1);\n                    maxLen = r - l + 1;\n                }\n                //先减再移动……这个bug\n                --cur[s[l]];   \n                while(++l <= r && !ahash[s[l]]);\n                    \n            }\n        } \n        return ans;\n    }\n};\n```\n\n\n\n## 思路2：\n\n更巧妙的方法：\n\n音量模拟：想象一排音量，分别代表着每个t中元素的个数。\n\n\n\n![音量图图片大全_uc今日头条新闻网](D:\\Blogfile\\pic\\76-Minimum-Window-Substring\\images)\n\n在滑动窗口向`r`指针在`t`向右扩展窗口中， 每遇到一个`s`中的元素就减去对应的音量值。如果滑动窗口中包含了`s`中的各个元素（包括种类和数量），那么就有音量图的每个柱子都在水平下以下或者持平，如果我们记录在水平线之上的数值变动——用`cnt`记录`--yin[s[i]] >=0`的剩余次数即可。\n\n如果`cnt==0`，说明窗口已经包括了所有元素，可以缩小范围，把左指针向👉右滑动。`cnt`的变动也是同理的。\n\n代码如下：\n\n## 代码2：\n\n```c++\nclass Solution {\npublic:\n\n    // 音量模拟\n    unordered_map<char, int> map;\n    string minWindow(string s, string t){\n        for(int i = 0; i < t.size(); ++i) ++map[t[i]];\n        int cnt = t.size(), l = 0, r = -1, start = l, maxl = s.size() + 1;\n        while(r < int(s.size())){\n            if(--map[s[++r]] >= 0) --cnt;\n            // cout << l << ' ' << r << ' ' << cnt << endl;\n            while(l <= r && cnt == 0){\n                if(maxl > r - l + 1){\n                    start = l;\n                    maxl = r - l + 1;\n                }\n                if(++map[s[l]] > 0) cnt++;\n                l++;  \n            }\n        }\n          return maxl == s.size() + 1 ? \"\" : s.substr(start, maxl);\n    }\n};\n\n```\n\n\n\n## 代码3：（二刷）\n\n\n\n```c++\nclass Solution {\npublic: \n    // 双指针必定都搜索到所有匹配串的原因是 所有以 g为终点的符合题意的的字符串s1，\n    // 其左端点必定可以向左移动，因为移动会包含到更多字符串\n    // 反过来想，从起点出发，右端点移动先尽可能包含多直到足够的字符，\n    // 再向右移动左端点尽可能减少多余的字符，获取一个尽可能短的字符串\n    // 为了尝试其他结果，不断地进行以下活动\n    //  移动右端点一次，缩短左端点，可以搜索到其他结果\n    \n    // 比较细节的是控制过程和循环结束\n    // \n    string minWindow(string s, string t) {\n        int ct[256] = {0}, allct = t.size();\n        string ans; \n        // s += 'A';\n        for(int i = 0; i < t.size(); ++i) ++ct[t[i]];\n        int p1 = 0, p2 = 0; // [)左闭右开空间，秒在不需要初始化\n        int minlen = s.size() + 1, minp1 = 0;\n        while(p2 < s.size()){\n            // 要么右移p2直到t字符串全部被囊括，要么试探性移动p2一个位置，进行其他位置的探索\n            while(p2 < s.size()){ // p2 <= s.size()\n                if(ct[s[p2]] > 0) --allct; // allct统计是否当前[p1, p2)是否有t的全部字符\n                --ct[s[p2]]; // 更新字符数量\n                ++p2;\n                if(allct == 0) break; //前进一步\n            }\n            while(ct[s[p1]] < 0){ // 如果该字符多余了，缩小左端点\n                ++ct[s[p1]];\n                ++p1;\n            }\n            if(allct == 0 && p2 - p1 < minlen){\n                minp1 = p1;                \n                minlen = p2 - p1;\n            } \n            // cout << p1 << ' ' << p2 << ' ' <<  allct << endl;\n        }\n        if(minlen > s.size())ans = \"\";\n        else ans = s.substr(minp1, minlen);\n        return ans;\n    }\n};\n```\n\n","slug":"刷题/双指针/76-Minimum-Window-Substring","published":1,"updated":"2021-04-24T13:28:03.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j55002ml5uogwy005um","content":"<h2 id=\"76-Minimum-Window-Substring\"><a href=\"#76-Minimum-Window-Substring\" class=\"headerlink\" title=\"76. Minimum Window Substring\"></a><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\">76. Minimum Window Substring</a></h2><h2 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1:\"></a>思路1:</h2><p>经典双指针下的滑动窗口算法。滑动窗口的左右部分分别由两个指针<code>l</code>,<code>r</code>指向。</p>\n<span id=\"more\"></span>\n\n<p>使用滑动窗口观察可能符号的条件的子串，并用<code>unordered_map</code>或者<code>map</code>来记录原字符串<code>s</code>和滑动窗口<code>win</code>中的元素个数。</p>\n<p>其算法过程如下：</p>\n<ol>\n<li>窗口的右指针向右滑动一次，并检查窗口内是否有足够元素。若是，则左指针向右收缩窗口。重复上述步骤即可。</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n\n    map&lt;char, int&gt; cur, ori;\n    &#x2F;&#x2F;优化: 去除无效字符\n    int ahash[800] &#x3D; &#123;0&#125;;\n    bool check()&#123;\n        for(const auto &amp;p : ori)&#123;\n            if(cur[p.first] &lt; p.second)\n                return false;                \n        &#125;\n        return true;\n    &#125;\n    string minWindow(string s, string t) &#123;\n        for(int i &#x3D; 0; i &lt; t.size(); ++i)&#123;\n            ++ori[t[i]];\n            ahash[t[i]] &#x3D; 1;\n        &#125;\n        int l &#x3D; 0, r &#x3D; -1, maxLen &#x3D; 0x7fffffff;\n        string ans &#x3D; &quot;&quot; ;\n        \n        while(r &lt; int(s.size()))&#123;            \n            while(++r &lt; s.size() &amp;&amp; !ahash[s[r]]);\n            if(r &#x3D;&#x3D; s.size()) break;\n            ++cur[s[r]];\n            \n            &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; endl;\n            while(check() &amp;&amp; l &lt;&#x3D; r)&#123;                \n                if(maxLen &gt; r - l + 1)&#123;\n                    ans &#x3D; s.substr(l, r - l + 1);\n                    maxLen &#x3D; r - l + 1;\n                &#125;\n                &#x2F;&#x2F;先减再移动……这个bug\n                --cur[s[l]];   \n                while(++l &lt;&#x3D; r &amp;&amp; !ahash[s[l]]);\n                    \n            &#125;\n        &#125; \n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h2><p>更巧妙的方法：</p>\n<p>音量模拟：想象一排音量，分别代表着每个t中元素的个数。</p>\n<p><img src=\"D:\\Blogfile\\pic\\76-Minimum-Window-Substring\\images\" alt=\"音量图图片大全_uc今日头条新闻网\"></p>\n<p>在滑动窗口向<code>r</code>指针在<code>t</code>向右扩展窗口中， 每遇到一个<code>s</code>中的元素就减去对应的音量值。如果滑动窗口中包含了<code>s</code>中的各个元素（包括种类和数量），那么就有音量图的每个柱子都在水平下以下或者持平，如果我们记录在水平线之上的数值变动——用<code>cnt</code>记录<code>--yin[s[i]] &gt;=0</code>的剩余次数即可。</p>\n<p>如果<code>cnt==0</code>，说明窗口已经包括了所有元素，可以缩小范围，把左指针向👉右滑动。<code>cnt</code>的变动也是同理的。</p>\n<p>代码如下：</p>\n<h2 id=\"代码2：\"><a href=\"#代码2：\" class=\"headerlink\" title=\"代码2：\"></a>代码2：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    &#x2F;&#x2F; 音量模拟\n    unordered_map&lt;char, int&gt; map;\n    string minWindow(string s, string t)&#123;\n        for(int i &#x3D; 0; i &lt; t.size(); ++i) ++map[t[i]];\n        int cnt &#x3D; t.size(), l &#x3D; 0, r &#x3D; -1, start &#x3D; l, maxl &#x3D; s.size() + 1;\n        while(r &lt; int(s.size()))&#123;\n            if(--map[s[++r]] &gt;&#x3D; 0) --cnt;\n            &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; &#39; &#39; &lt;&lt; cnt &lt;&lt; endl;\n            while(l &lt;&#x3D; r &amp;&amp; cnt &#x3D;&#x3D; 0)&#123;\n                if(maxl &gt; r - l + 1)&#123;\n                    start &#x3D; l;\n                    maxl &#x3D; r - l + 1;\n                &#125;\n                if(++map[s[l]] &gt; 0) cnt++;\n                l++;  \n            &#125;\n        &#125;\n          return maxl &#x3D;&#x3D; s.size() + 1 ? &quot;&quot; : s.substr(start, maxl);\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"代码3：（二刷）\"><a href=\"#代码3：（二刷）\" class=\"headerlink\" title=\"代码3：（二刷）\"></a>代码3：（二刷）</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic: \n    &#x2F;&#x2F; 双指针必定都搜索到所有匹配串的原因是 所有以 g为终点的符合题意的的字符串s1，\n    &#x2F;&#x2F; 其左端点必定可以向左移动，因为移动会包含到更多字符串\n    &#x2F;&#x2F; 反过来想，从起点出发，右端点移动先尽可能包含多直到足够的字符，\n    &#x2F;&#x2F; 再向右移动左端点尽可能减少多余的字符，获取一个尽可能短的字符串\n    &#x2F;&#x2F; 为了尝试其他结果，不断地进行以下活动\n    &#x2F;&#x2F;  移动右端点一次，缩短左端点，可以搜索到其他结果\n    \n    &#x2F;&#x2F; 比较细节的是控制过程和循环结束\n    &#x2F;&#x2F; \n    string minWindow(string s, string t) &#123;\n        int ct[256] &#x3D; &#123;0&#125;, allct &#x3D; t.size();\n        string ans; \n        &#x2F;&#x2F; s +&#x3D; &#39;A&#39;;\n        for(int i &#x3D; 0; i &lt; t.size(); ++i) ++ct[t[i]];\n        int p1 &#x3D; 0, p2 &#x3D; 0; &#x2F;&#x2F; [)左闭右开空间，秒在不需要初始化\n        int minlen &#x3D; s.size() + 1, minp1 &#x3D; 0;\n        while(p2 &lt; s.size())&#123;\n            &#x2F;&#x2F; 要么右移p2直到t字符串全部被囊括，要么试探性移动p2一个位置，进行其他位置的探索\n            while(p2 &lt; s.size())&#123; &#x2F;&#x2F; p2 &lt;&#x3D; s.size()\n                if(ct[s[p2]] &gt; 0) --allct; &#x2F;&#x2F; allct统计是否当前[p1, p2)是否有t的全部字符\n                --ct[s[p2]]; &#x2F;&#x2F; 更新字符数量\n                ++p2;\n                if(allct &#x3D;&#x3D; 0) break; &#x2F;&#x2F;前进一步\n            &#125;\n            while(ct[s[p1]] &lt; 0)&#123; &#x2F;&#x2F; 如果该字符多余了，缩小左端点\n                ++ct[s[p1]];\n                ++p1;\n            &#125;\n            if(allct &#x3D;&#x3D; 0 &amp;&amp; p2 - p1 &lt; minlen)&#123;\n                minp1 &#x3D; p1;                \n                minlen &#x3D; p2 - p1;\n            &#125; \n            &#x2F;&#x2F; cout &lt;&lt; p1 &lt;&lt; &#39; &#39; &lt;&lt; p2 &lt;&lt; &#39; &#39; &lt;&lt;  allct &lt;&lt; endl;\n        &#125;\n        if(minlen &gt; s.size())ans &#x3D; &quot;&quot;;\n        else ans &#x3D; s.substr(minp1, minlen);\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"10TW2H7","excerpt":"<h2 id=\"76-Minimum-Window-Substring\"><a href=\"#76-Minimum-Window-Substring\" class=\"headerlink\" title=\"76. Minimum Window Substring\"></a><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\">76. Minimum Window Substring</a></h2><h2 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1:\"></a>思路1:</h2><p>经典双指针下的滑动窗口算法。滑动窗口的左右部分分别由两个指针<code>l</code>,<code>r</code>指向。</p>","more":"<p>使用滑动窗口观察可能符号的条件的子串，并用<code>unordered_map</code>或者<code>map</code>来记录原字符串<code>s</code>和滑动窗口<code>win</code>中的元素个数。</p>\n<p>其算法过程如下：</p>\n<ol>\n<li>窗口的右指针向右滑动一次，并检查窗口内是否有足够元素。若是，则左指针向右收缩窗口。重复上述步骤即可。</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n\n    map&lt;char, int&gt; cur, ori;\n    &#x2F;&#x2F;优化: 去除无效字符\n    int ahash[800] &#x3D; &#123;0&#125;;\n    bool check()&#123;\n        for(const auto &amp;p : ori)&#123;\n            if(cur[p.first] &lt; p.second)\n                return false;                \n        &#125;\n        return true;\n    &#125;\n    string minWindow(string s, string t) &#123;\n        for(int i &#x3D; 0; i &lt; t.size(); ++i)&#123;\n            ++ori[t[i]];\n            ahash[t[i]] &#x3D; 1;\n        &#125;\n        int l &#x3D; 0, r &#x3D; -1, maxLen &#x3D; 0x7fffffff;\n        string ans &#x3D; &quot;&quot; ;\n        \n        while(r &lt; int(s.size()))&#123;            \n            while(++r &lt; s.size() &amp;&amp; !ahash[s[r]]);\n            if(r &#x3D;&#x3D; s.size()) break;\n            ++cur[s[r]];\n            \n            &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; endl;\n            while(check() &amp;&amp; l &lt;&#x3D; r)&#123;                \n                if(maxLen &gt; r - l + 1)&#123;\n                    ans &#x3D; s.substr(l, r - l + 1);\n                    maxLen &#x3D; r - l + 1;\n                &#125;\n                &#x2F;&#x2F;先减再移动……这个bug\n                --cur[s[l]];   \n                while(++l &lt;&#x3D; r &amp;&amp; !ahash[s[l]]);\n                    \n            &#125;\n        &#125; \n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h2><p>更巧妙的方法：</p>\n<p>音量模拟：想象一排音量，分别代表着每个t中元素的个数。</p>\n<p><img src=\"D:\\Blogfile\\pic\\76-Minimum-Window-Substring\\images\" alt=\"音量图图片大全_uc今日头条新闻网\"></p>\n<p>在滑动窗口向<code>r</code>指针在<code>t</code>向右扩展窗口中， 每遇到一个<code>s</code>中的元素就减去对应的音量值。如果滑动窗口中包含了<code>s</code>中的各个元素（包括种类和数量），那么就有音量图的每个柱子都在水平下以下或者持平，如果我们记录在水平线之上的数值变动——用<code>cnt</code>记录<code>--yin[s[i]] &gt;=0</code>的剩余次数即可。</p>\n<p>如果<code>cnt==0</code>，说明窗口已经包括了所有元素，可以缩小范围，把左指针向👉右滑动。<code>cnt</code>的变动也是同理的。</p>\n<p>代码如下：</p>\n<h2 id=\"代码2：\"><a href=\"#代码2：\" class=\"headerlink\" title=\"代码2：\"></a>代码2：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    &#x2F;&#x2F; 音量模拟\n    unordered_map&lt;char, int&gt; map;\n    string minWindow(string s, string t)&#123;\n        for(int i &#x3D; 0; i &lt; t.size(); ++i) ++map[t[i]];\n        int cnt &#x3D; t.size(), l &#x3D; 0, r &#x3D; -1, start &#x3D; l, maxl &#x3D; s.size() + 1;\n        while(r &lt; int(s.size()))&#123;\n            if(--map[s[++r]] &gt;&#x3D; 0) --cnt;\n            &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; &#39; &#39; &lt;&lt; cnt &lt;&lt; endl;\n            while(l &lt;&#x3D; r &amp;&amp; cnt &#x3D;&#x3D; 0)&#123;\n                if(maxl &gt; r - l + 1)&#123;\n                    start &#x3D; l;\n                    maxl &#x3D; r - l + 1;\n                &#125;\n                if(++map[s[l]] &gt; 0) cnt++;\n                l++;  \n            &#125;\n        &#125;\n          return maxl &#x3D;&#x3D; s.size() + 1 ? &quot;&quot; : s.substr(start, maxl);\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"代码3：（二刷）\"><a href=\"#代码3：（二刷）\" class=\"headerlink\" title=\"代码3：（二刷）\"></a>代码3：（二刷）</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic: \n    &#x2F;&#x2F; 双指针必定都搜索到所有匹配串的原因是 所有以 g为终点的符合题意的的字符串s1，\n    &#x2F;&#x2F; 其左端点必定可以向左移动，因为移动会包含到更多字符串\n    &#x2F;&#x2F; 反过来想，从起点出发，右端点移动先尽可能包含多直到足够的字符，\n    &#x2F;&#x2F; 再向右移动左端点尽可能减少多余的字符，获取一个尽可能短的字符串\n    &#x2F;&#x2F; 为了尝试其他结果，不断地进行以下活动\n    &#x2F;&#x2F;  移动右端点一次，缩短左端点，可以搜索到其他结果\n    \n    &#x2F;&#x2F; 比较细节的是控制过程和循环结束\n    &#x2F;&#x2F; \n    string minWindow(string s, string t) &#123;\n        int ct[256] &#x3D; &#123;0&#125;, allct &#x3D; t.size();\n        string ans; \n        &#x2F;&#x2F; s +&#x3D; &#39;A&#39;;\n        for(int i &#x3D; 0; i &lt; t.size(); ++i) ++ct[t[i]];\n        int p1 &#x3D; 0, p2 &#x3D; 0; &#x2F;&#x2F; [)左闭右开空间，秒在不需要初始化\n        int minlen &#x3D; s.size() + 1, minp1 &#x3D; 0;\n        while(p2 &lt; s.size())&#123;\n            &#x2F;&#x2F; 要么右移p2直到t字符串全部被囊括，要么试探性移动p2一个位置，进行其他位置的探索\n            while(p2 &lt; s.size())&#123; &#x2F;&#x2F; p2 &lt;&#x3D; s.size()\n                if(ct[s[p2]] &gt; 0) --allct; &#x2F;&#x2F; allct统计是否当前[p1, p2)是否有t的全部字符\n                --ct[s[p2]]; &#x2F;&#x2F; 更新字符数量\n                ++p2;\n                if(allct &#x3D;&#x3D; 0) break; &#x2F;&#x2F;前进一步\n            &#125;\n            while(ct[s[p1]] &lt; 0)&#123; &#x2F;&#x2F; 如果该字符多余了，缩小左端点\n                ++ct[s[p1]];\n                ++p1;\n            &#125;\n            if(allct &#x3D;&#x3D; 0 &amp;&amp; p2 - p1 &lt; minlen)&#123;\n                minp1 &#x3D; p1;                \n                minlen &#x3D; p2 - p1;\n            &#125; \n            &#x2F;&#x2F; cout &lt;&lt; p1 &lt;&lt; &#39; &#39; &lt;&lt; p2 &lt;&lt; &#39; &#39; &lt;&lt;  allct &lt;&lt; endl;\n        &#125;\n        if(minlen &gt; s.size())ans &#x3D; &quot;&quot;;\n        else ans &#x3D; s.substr(minp1, minlen);\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"132. Palindrome Partitioning II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-08T03:48:05.000Z","_content":"\n\n\n\n\n\n\n\n# [132. Palindrome Partitioning II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)\n\n\n\n\n\n\n\n## 思路：\n\n`dp`，`dp[i]`表示最小分割子串数，状态转移方程为：\n\n![image-20210308114617311](http://static.come2rss.xyz/image-20210308114617311.png)\n\n其中子串是否为回文串可以预计算，这样就把复杂度从`o(N^3)`降到`o(N^2)`。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```C++\nclass Solution {\n    vector<int> dp;\npublic:\n    \n    int minCut(string s) {\n        int n = s.size();\n        dp.resize(n);\n        for(int i = 0; i < n; ++i){\n            dp[i] = i + 1;\n            for(int j = i; j >= 0; --j){\n                if(isPalindrome(s, j, i)){\n                    dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                }\n            }\n        }\n        return dp[n - 1] - 1;\n    }\n    \n    bool isPalindrome(string &s, int i, int j){\n        if(i >= j) swap(i, j);\n        while(i != j && i < j){\n            if(s[i] != s[j]) return false;\n            --j;\n            ++i;\n        }\n        return true;\n    }\n\n \n    \n\n};\n```\n\n预计算\n\n\n\n```\nclass Solution {\n    vector<int> dp;\n    vector<vector<int>> isPal;\npublic:\n    \n    int minCut(string s) {\n        int n = s.size();\n        dp.resize(n);\n        isPal.resize(n, vector<int>(n,1));\n        for(int i = n - 1; i >= 0; --i){\n            for(int j = i + 1; j < n; ++j){\n                   // if(i == j) isPal[i][j] = 1;\n                // else if(i != n- 1 && j != 0)     \n                isPal[i][j] = isPal[i + 1][j - 1] && s[i] == s[j]; // s[i,j]的回文需要s[i + 1, j - 1]的回文，那么反向遍历即可。\n            }\n        }\n        for(int i = 0; i < n; ++i){\n            dp[i] = i + 1;\n            for(int j = i; j >= 0; --j){\n                if(isPal[j][i]){\n                    dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                }\n            }\n        }\n\n        return dp[n - 1] - 1;\n    }\n    \n \n    \n\n};\n```\n\n","source":"_posts/刷题/字符串/132-Palindrome-Partitioning-II.md","raw":"---\ntitle: 132. Palindrome Partitioning II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-08 11:48:05\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n\n# [132. Palindrome Partitioning II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)\n\n\n\n\n\n\n\n## 思路：\n\n`dp`，`dp[i]`表示最小分割子串数，状态转移方程为：\n\n![image-20210308114617311](http://static.come2rss.xyz/image-20210308114617311.png)\n\n其中子串是否为回文串可以预计算，这样就把复杂度从`o(N^3)`降到`o(N^2)`。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```C++\nclass Solution {\n    vector<int> dp;\npublic:\n    \n    int minCut(string s) {\n        int n = s.size();\n        dp.resize(n);\n        for(int i = 0; i < n; ++i){\n            dp[i] = i + 1;\n            for(int j = i; j >= 0; --j){\n                if(isPalindrome(s, j, i)){\n                    dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                }\n            }\n        }\n        return dp[n - 1] - 1;\n    }\n    \n    bool isPalindrome(string &s, int i, int j){\n        if(i >= j) swap(i, j);\n        while(i != j && i < j){\n            if(s[i] != s[j]) return false;\n            --j;\n            ++i;\n        }\n        return true;\n    }\n\n \n    \n\n};\n```\n\n预计算\n\n\n\n```\nclass Solution {\n    vector<int> dp;\n    vector<vector<int>> isPal;\npublic:\n    \n    int minCut(string s) {\n        int n = s.size();\n        dp.resize(n);\n        isPal.resize(n, vector<int>(n,1));\n        for(int i = n - 1; i >= 0; --i){\n            for(int j = i + 1; j < n; ++j){\n                   // if(i == j) isPal[i][j] = 1;\n                // else if(i != n- 1 && j != 0)     \n                isPal[i][j] = isPal[i + 1][j - 1] && s[i] == s[j]; // s[i,j]的回文需要s[i + 1, j - 1]的回文，那么反向遍历即可。\n            }\n        }\n        for(int i = 0; i < n; ++i){\n            dp[i] = i + 1;\n            for(int j = i; j >= 0; --j){\n                if(isPal[j][i]){\n                    dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                }\n            }\n        }\n\n        return dp[n - 1] - 1;\n    }\n    \n \n    \n\n};\n```\n\n","slug":"刷题/字符串/132-Palindrome-Partitioning-II","published":1,"updated":"2021-03-08T03:48:42.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j56002nl5uo6y8n3nmm","content":"<h1 id=\"132-Palindrome-Partitioning-II\"><a href=\"#132-Palindrome-Partitioning-II\" class=\"headerlink\" title=\"132. Palindrome Partitioning II\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-partitioning-ii/\">132. Palindrome Partitioning II</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>dp</code>，<code>dp[i]</code>表示最小分割子串数，状态转移方程为：</p>\n<p><img src=\"http://static.come2rss.xyz/image-20210308114617311.png\" alt=\"image-20210308114617311\"></p>\n<p>其中子串是否为回文串可以预计算，这样就把复杂度从<code>o(N^3)</code>降到<code>o(N^2)</code>。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\n    vector&lt;int&gt; dp;\npublic:\n    \n    int minCut(string s) &#123;\n        int n &#x3D; s.size();\n        dp.resize(n);\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            dp[i] &#x3D; i + 1;\n            for(int j &#x3D; i; j &gt;&#x3D; 0; --j)&#123;\n                if(isPalindrome(s, j, i))&#123;\n                    dp[i] &#x3D; min(j &#x3D;&#x3D; 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n - 1] - 1;\n    &#125;\n    \n    bool isPalindrome(string &amp;s, int i, int j)&#123;\n        if(i &gt;&#x3D; j) swap(i, j);\n        while(i !&#x3D; j &amp;&amp; i &lt; j)&#123;\n            if(s[i] !&#x3D; s[j]) return false;\n            --j;\n            ++i;\n        &#125;\n        return true;\n    &#125;\n\n \n    \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>预计算</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\n    vector&lt;int&gt; dp;\n    vector&lt;vector&lt;int&gt;&gt; isPal;\npublic:\n    \n    int minCut(string s) &#123;\n        int n &#x3D; s.size();\n        dp.resize(n);\n        isPal.resize(n, vector&lt;int&gt;(n,1));\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)&#123;\n            for(int j &#x3D; i + 1; j &lt; n; ++j)&#123;\n                   &#x2F;&#x2F; if(i &#x3D;&#x3D; j) isPal[i][j] &#x3D; 1;\n                &#x2F;&#x2F; else if(i !&#x3D; n- 1 &amp;&amp; j !&#x3D; 0)     \n                isPal[i][j] &#x3D; isPal[i + 1][j - 1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]; &#x2F;&#x2F; s[i,j]的回文需要s[i + 1, j - 1]的回文，那么反向遍历即可。\n            &#125;\n        &#125;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            dp[i] &#x3D; i + 1;\n            for(int j &#x3D; i; j &gt;&#x3D; 0; --j)&#123;\n                if(isPal[j][i])&#123;\n                    dp[i] &#x3D; min(j &#x3D;&#x3D; 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                &#125;\n            &#125;\n        &#125;\n\n        return dp[n - 1] - 1;\n    &#125;\n    \n \n    \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"65YX8E","excerpt":"<h1 id=\"132-Palindrome-Partitioning-II\"><a href=\"#132-Palindrome-Partitioning-II\" class=\"headerlink\" title=\"132. Palindrome Partitioning II\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-partitioning-ii/\">132. Palindrome Partitioning II</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>dp</code>，<code>dp[i]</code>表示最小分割子串数，状态转移方程为：</p>\n<p><img src=\"http://static.come2rss.xyz/image-20210308114617311.png\" alt=\"image-20210308114617311\"></p>\n<p>其中子串是否为回文串可以预计算，这样就把复杂度从<code>o(N^3)</code>降到<code>o(N^2)</code>。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\n    vector&lt;int&gt; dp;\npublic:\n    \n    int minCut(string s) &#123;\n        int n &#x3D; s.size();\n        dp.resize(n);\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            dp[i] &#x3D; i + 1;\n            for(int j &#x3D; i; j &gt;&#x3D; 0; --j)&#123;\n                if(isPalindrome(s, j, i))&#123;\n                    dp[i] &#x3D; min(j &#x3D;&#x3D; 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n - 1] - 1;\n    &#125;\n    \n    bool isPalindrome(string &amp;s, int i, int j)&#123;\n        if(i &gt;&#x3D; j) swap(i, j);\n        while(i !&#x3D; j &amp;&amp; i &lt; j)&#123;\n            if(s[i] !&#x3D; s[j]) return false;\n            --j;\n            ++i;\n        &#125;\n        return true;\n    &#125;\n\n \n    \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>预计算</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Solution &#123;\n    vector&lt;int&gt; dp;\n    vector&lt;vector&lt;int&gt;&gt; isPal;\npublic:\n    \n    int minCut(string s) &#123;\n        int n &#x3D; s.size();\n        dp.resize(n);\n        isPal.resize(n, vector&lt;int&gt;(n,1));\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)&#123;\n            for(int j &#x3D; i + 1; j &lt; n; ++j)&#123;\n                   &#x2F;&#x2F; if(i &#x3D;&#x3D; j) isPal[i][j] &#x3D; 1;\n                &#x2F;&#x2F; else if(i !&#x3D; n- 1 &amp;&amp; j !&#x3D; 0)     \n                isPal[i][j] &#x3D; isPal[i + 1][j - 1] &amp;&amp; s[i] &#x3D;&#x3D; s[j]; &#x2F;&#x2F; s[i,j]的回文需要s[i + 1, j - 1]的回文，那么反向遍历即可。\n            &#125;\n        &#125;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            dp[i] &#x3D; i + 1;\n            for(int j &#x3D; i; j &gt;&#x3D; 0; --j)&#123;\n                if(isPal[j][i])&#123;\n                    dp[i] &#x3D; min(j &#x3D;&#x3D; 0 ? 1 : dp[j - 1] + 1, dp[i]);\n                &#125;\n            &#125;\n        &#125;\n\n        return dp[n - 1] - 1;\n    &#125;\n    \n \n    \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"227. Basic Calculator II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-12T12:22:37.000Z","_content":"\n\n\n# [227. Basic Calculator II](https://leetcode-cn.com/problems/basic-calculator-ii/)\n\n\n\n## 思路\n\n经典的中缀转后缀练手题，但是我偏不。\n\n在遍历字符串把数字和运算符存储到一个数字栈和运算栈中，考虑到运算顺序是乘除>加减，且左边>右边，所以在压入新运算符`op`前把栈中优先级大于等于`op`的运算法弹出，并计算。\n\n遍历完了运算栈可能还有运算符，逆向计算即可。最后数据栈弹出结果就完事。\n\n\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    using ull = unsigned long long;\n    ull func(char c, ull num1, ull num2){\n        if(c == '+') return num1 + num2;\n        if(c == '-') return num1 - num2;\n        if(c == '*') return num1 * num2;\n        if(c == '/') return num1 / num2;\n        return 0;\n    }\n    int calculate(string s) {\n        s += ']';\n        stack<char> op;\n        stack<ull> num;\n        map<char, int> pri{{'+', 1},{'-', 1},{'*', 2},{'/', 2}};\n        ull cal = 0;\n        for(auto c : s){\n            if(isdigit(c)) cal = cal * 10 + c - '0';\n            else{\n                if(c == ' ') continue;\n                // cout << c << ' ' << cal << endl; \n                num.push(cal); \n                cal = 0;\n                if(c == ']') continue;\n                \n                while(op.size() &&  pri[c] <= pri[op.top()]){\n                    int num2 = num.top(); num.pop();\n                    int num1 = num.top(); num.pop();\n                    num.push( func(op.top(), num1, num2) );\n                    op.pop();\n                }\n                op.push(c);\n            }\n        }\n        // cout << num.size() << ' ' << op.size() << endl;\n        while(op.size()){\n            int num2 = num.top(); num.pop();\n            int num1 = num.top(); num.pop();\n            num.push( func(op.top(), num1, num2) );\n            op.pop();\n        }\n        return num.top();\n\n\n    }\n};\n```\n\n","source":"_posts/刷题/字符串/227-Basic-Calculator-II.md","raw":"---\ntitle: 227. Basic Calculator II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-12 20:22:37\ntags:\ncategories:\n---\n\n\n\n# [227. Basic Calculator II](https://leetcode-cn.com/problems/basic-calculator-ii/)\n\n\n\n## 思路\n\n经典的中缀转后缀练手题，但是我偏不。\n\n在遍历字符串把数字和运算符存储到一个数字栈和运算栈中，考虑到运算顺序是乘除>加减，且左边>右边，所以在压入新运算符`op`前把栈中优先级大于等于`op`的运算法弹出，并计算。\n\n遍历完了运算栈可能还有运算符，逆向计算即可。最后数据栈弹出结果就完事。\n\n\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    using ull = unsigned long long;\n    ull func(char c, ull num1, ull num2){\n        if(c == '+') return num1 + num2;\n        if(c == '-') return num1 - num2;\n        if(c == '*') return num1 * num2;\n        if(c == '/') return num1 / num2;\n        return 0;\n    }\n    int calculate(string s) {\n        s += ']';\n        stack<char> op;\n        stack<ull> num;\n        map<char, int> pri{{'+', 1},{'-', 1},{'*', 2},{'/', 2}};\n        ull cal = 0;\n        for(auto c : s){\n            if(isdigit(c)) cal = cal * 10 + c - '0';\n            else{\n                if(c == ' ') continue;\n                // cout << c << ' ' << cal << endl; \n                num.push(cal); \n                cal = 0;\n                if(c == ']') continue;\n                \n                while(op.size() &&  pri[c] <= pri[op.top()]){\n                    int num2 = num.top(); num.pop();\n                    int num1 = num.top(); num.pop();\n                    num.push( func(op.top(), num1, num2) );\n                    op.pop();\n                }\n                op.push(c);\n            }\n        }\n        // cout << num.size() << ' ' << op.size() << endl;\n        while(op.size()){\n            int num2 = num.top(); num.pop();\n            int num1 = num.top(); num.pop();\n            num.push( func(op.top(), num1, num2) );\n            op.pop();\n        }\n        return num.top();\n\n\n    }\n};\n```\n\n","slug":"刷题/字符串/227-Basic-Calculator-II","published":1,"updated":"2021-02-12T12:29:13.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j56002ol5uo5zaoec8n","content":"<h1 id=\"227-Basic-Calculator-II\"><a href=\"#227-Basic-Calculator-II\" class=\"headerlink\" title=\"227. Basic Calculator II\"></a><a href=\"https://leetcode-cn.com/problems/basic-calculator-ii/\">227. Basic Calculator II</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>经典的中缀转后缀练手题，但是我偏不。</p>\n<p>在遍历字符串把数字和运算符存储到一个数字栈和运算栈中，考虑到运算顺序是乘除&gt;加减，且左边&gt;右边，所以在压入新运算符<code>op</code>前把栈中优先级大于等于<code>op</code>的运算法弹出，并计算。</p>\n<p>遍历完了运算栈可能还有运算符，逆向计算即可。最后数据栈弹出结果就完事。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ull &#x3D; unsigned long long;\n    ull func(char c, ull num1, ull num2)&#123;\n        if(c &#x3D;&#x3D; &#39;+&#39;) return num1 + num2;\n        if(c &#x3D;&#x3D; &#39;-&#39;) return num1 - num2;\n        if(c &#x3D;&#x3D; &#39;*&#39;) return num1 * num2;\n        if(c &#x3D;&#x3D; &#39;&#x2F;&#39;) return num1 &#x2F; num2;\n        return 0;\n    &#125;\n    int calculate(string s) &#123;\n        s +&#x3D; &#39;]&#39;;\n        stack&lt;char&gt; op;\n        stack&lt;ull&gt; num;\n        map&lt;char, int&gt; pri&#123;&#123;&#39;+&#39;, 1&#125;,&#123;&#39;-&#39;, 1&#125;,&#123;&#39;*&#39;, 2&#125;,&#123;&#39;&#x2F;&#39;, 2&#125;&#125;;\n        ull cal &#x3D; 0;\n        for(auto c : s)&#123;\n            if(isdigit(c)) cal &#x3D; cal * 10 + c - &#39;0&#39;;\n            else&#123;\n                if(c &#x3D;&#x3D; &#39; &#39;) continue;\n                &#x2F;&#x2F; cout &lt;&lt; c &lt;&lt; &#39; &#39; &lt;&lt; cal &lt;&lt; endl; \n                num.push(cal); \n                cal &#x3D; 0;\n                if(c &#x3D;&#x3D; &#39;]&#39;) continue;\n                \n                while(op.size() &amp;&amp;  pri[c] &lt;&#x3D; pri[op.top()])&#123;\n                    int num2 &#x3D; num.top(); num.pop();\n                    int num1 &#x3D; num.top(); num.pop();\n                    num.push( func(op.top(), num1, num2) );\n                    op.pop();\n                &#125;\n                op.push(c);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; num.size() &lt;&lt; &#39; &#39; &lt;&lt; op.size() &lt;&lt; endl;\n        while(op.size())&#123;\n            int num2 &#x3D; num.top(); num.pop();\n            int num1 &#x3D; num.top(); num.pop();\n            num.push( func(op.top(), num1, num2) );\n            op.pop();\n        &#125;\n        return num.top();\n\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3P182G5","excerpt":"","more":"<h1 id=\"227-Basic-Calculator-II\"><a href=\"#227-Basic-Calculator-II\" class=\"headerlink\" title=\"227. Basic Calculator II\"></a><a href=\"https://leetcode-cn.com/problems/basic-calculator-ii/\">227. Basic Calculator II</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>经典的中缀转后缀练手题，但是我偏不。</p>\n<p>在遍历字符串把数字和运算符存储到一个数字栈和运算栈中，考虑到运算顺序是乘除&gt;加减，且左边&gt;右边，所以在压入新运算符<code>op</code>前把栈中优先级大于等于<code>op</code>的运算法弹出，并计算。</p>\n<p>遍历完了运算栈可能还有运算符，逆向计算即可。最后数据栈弹出结果就完事。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ull &#x3D; unsigned long long;\n    ull func(char c, ull num1, ull num2)&#123;\n        if(c &#x3D;&#x3D; &#39;+&#39;) return num1 + num2;\n        if(c &#x3D;&#x3D; &#39;-&#39;) return num1 - num2;\n        if(c &#x3D;&#x3D; &#39;*&#39;) return num1 * num2;\n        if(c &#x3D;&#x3D; &#39;&#x2F;&#39;) return num1 &#x2F; num2;\n        return 0;\n    &#125;\n    int calculate(string s) &#123;\n        s +&#x3D; &#39;]&#39;;\n        stack&lt;char&gt; op;\n        stack&lt;ull&gt; num;\n        map&lt;char, int&gt; pri&#123;&#123;&#39;+&#39;, 1&#125;,&#123;&#39;-&#39;, 1&#125;,&#123;&#39;*&#39;, 2&#125;,&#123;&#39;&#x2F;&#39;, 2&#125;&#125;;\n        ull cal &#x3D; 0;\n        for(auto c : s)&#123;\n            if(isdigit(c)) cal &#x3D; cal * 10 + c - &#39;0&#39;;\n            else&#123;\n                if(c &#x3D;&#x3D; &#39; &#39;) continue;\n                &#x2F;&#x2F; cout &lt;&lt; c &lt;&lt; &#39; &#39; &lt;&lt; cal &lt;&lt; endl; \n                num.push(cal); \n                cal &#x3D; 0;\n                if(c &#x3D;&#x3D; &#39;]&#39;) continue;\n                \n                while(op.size() &amp;&amp;  pri[c] &lt;&#x3D; pri[op.top()])&#123;\n                    int num2 &#x3D; num.top(); num.pop();\n                    int num1 &#x3D; num.top(); num.pop();\n                    num.push( func(op.top(), num1, num2) );\n                    op.pop();\n                &#125;\n                op.push(c);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; num.size() &lt;&lt; &#39; &#39; &lt;&lt; op.size() &lt;&lt; endl;\n        while(op.size())&#123;\n            int num2 &#x3D; num.top(); num.pop();\n            int num1 &#x3D; num.top(); num.pop();\n            num.push( func(op.top(), num1, num2) );\n            op.pop();\n        &#125;\n        return num.top();\n\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n"},{"title":"28. Implement strStr()","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-15T02:18:48.000Z","_content":"\n\n\n\n\n## 思路：\n\n经典的字符子串匹配问题：\n\n1. 暴力匹配，$O(mn)$\n2. Rabin Karp $O(n)$\n3. [KMP算法](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/)\n\n<!-- more -->\n\n### KMP算法\n\nKMP算法的核心在于`next`数组，其`next[i]`记录了字符串`str[0...i]`的最长相同前后缀子串（不包括子串本身）的前缀尾下标。如此，我们在母子串在匹配`i`（母串`Sa`），`j`（子串`Sb`）失败时，子串的`k = next[j - 1]`记录了保证了最长`Sa`与`Sb[0, k]`可匹配成功（`k`不断减小，但`i`没有减小），重新判断`Sa[i]==?Sb[k+1]`即可。重复这个步骤，直到`k`无法缩小，或者匹配成功。若成功，`++i`，`++j`；若失败，则`++i`，`j=0`。\n\n但在此之前，还有构造`next`数组。神奇的是，`next[i]`构造与匹配的过程极其类似。首先`next[0] = -1`。记`k = next[i - 1]`，比较`Sb[k + 1] == ? Sb[i]`，若成功，则`Sb[i]= k + 1`；若失败，则寻找更小的公共前后缀（为了寻找最长的公共前缀长度，利用了`Sb[0,..,i-1]`子串的最长前缀后子串，以及更短的前后缀子串！（后两者的性质保证了属于前者的后缀子串✨✨）），缩小`k`为`next[k]`，再次比较。其中`k>-1`。如果还是失败了，明显的不存在相同的前后缀子串`next[i] = -1`。\n\n\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    //暴力\n    int strStr(string haystack, string needle) {\n        int m = haystack.size(), n = needle.size();\n        if(n == 0) return 0;\n\n        int k = 0, j = 0;\n        //aaaaaf\n        //-----fs\n        while(k <= m - n){ \n            while(j < n && haystack[k] == needle[j]) ++k, ++j;\n            if(j == n) return k - j;\n            k = k - j + 1;\n            j = 0;\n        }\n        return -1;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    //暴力\n    \n\n    int strStr(string haystack, string needle) {\n        auto tonum = [](char a){return a -  'a';};\n        int m = haystack.size(), n = needle.size();\n        if(n == 0) return 0;\n        using ktype =  long long;\n        ktype base = 26, key = 0; //MOD 超过上限自然溢出?\n        ktype point = 0, hpow = 1, MOD = 1e9 + 7;\n\n        for(int i = 0; i < n; ++i){ // 字符串前位权重高\n            key = (key * base + tonum(needle[i])) % MOD;\n            hpow = (hpow * base) % MOD; // bugs\n            point = (point * base + tonum(haystack[i])) % MOD;\n        }\n        // if(point < 0 || key < 0) cout << \"+\";\n        if(key == point) return 0;\n        for(int j = n; j < m; ++j){    \n            point = (((point * base  - tonum(haystack[j - n]) * hpow) % MOD + MOD) + tonum(haystack[j])) % MOD; //疯狂使用运算符限制和e取余运算防止溢出\n            // if(point < 0 ) cout << '-';\n            if(key == point){\n                return j - n + 1;\n            }\n        }\n\n        return -1;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    //KMP     100% \n\n    int strStr(string haystack, string needle) {\n\n        int n = haystack.size(), m = needle.size();\n        if(m == 0 ) return 0;\n        vector<int> next(m, -1); //next[i] 为needle[0,...., i]相同最长前后缀的前缀末下标\n        \n        for(int i = 1; i < m; ++i){\n            int k = next[i - 1]; // needle[0,...., i - 1]相同最长前后缀的前缀末下标\n            while(k != -1 && needle[k + 1] != needle[i]){ // 尝试扩展前后缀 needle[0, k + 1], needle[,..,i-1,i]\n                k = next[k]; //匹配失败，缩短前后缀\n            }\n            if(needle[k + 1] != needle[i]) next[i] = -1;\n            else next[i] = k + 1;\n            // cout << next[i] << endl;\n        }\n\n        int i = 0, j = 0;\n        for(; i < n; ++i ){ // i, j 为当前匹配的下标字符\n            while(haystack[i] != needle[j] && j > 0){  // 两串匹配失败，且j可压缩\n                j = next[j - 1] + 1; // 压缩needle串的最长相等前后缀长度， 最小为0\n            }\n            if(haystack[i] == needle[j]){\n                ++j;\n                if(j == m) return i - j + 1;\n            }\n\n        }\n        return -1;\n    }\n};\n\n\n\n\n\n\n```\n\n","source":"_posts/刷题/字符串/28-Implement-strStr.md","raw":"---\ntitle: 28. Implement strStr()\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-15 10:18:48\ntags:\ncategories:\n---\n\n\n\n\n\n## 思路：\n\n经典的字符子串匹配问题：\n\n1. 暴力匹配，$O(mn)$\n2. Rabin Karp $O(n)$\n3. [KMP算法](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/)\n\n<!-- more -->\n\n### KMP算法\n\nKMP算法的核心在于`next`数组，其`next[i]`记录了字符串`str[0...i]`的最长相同前后缀子串（不包括子串本身）的前缀尾下标。如此，我们在母子串在匹配`i`（母串`Sa`），`j`（子串`Sb`）失败时，子串的`k = next[j - 1]`记录了保证了最长`Sa`与`Sb[0, k]`可匹配成功（`k`不断减小，但`i`没有减小），重新判断`Sa[i]==?Sb[k+1]`即可。重复这个步骤，直到`k`无法缩小，或者匹配成功。若成功，`++i`，`++j`；若失败，则`++i`，`j=0`。\n\n但在此之前，还有构造`next`数组。神奇的是，`next[i]`构造与匹配的过程极其类似。首先`next[0] = -1`。记`k = next[i - 1]`，比较`Sb[k + 1] == ? Sb[i]`，若成功，则`Sb[i]= k + 1`；若失败，则寻找更小的公共前后缀（为了寻找最长的公共前缀长度，利用了`Sb[0,..,i-1]`子串的最长前缀后子串，以及更短的前后缀子串！（后两者的性质保证了属于前者的后缀子串✨✨）），缩小`k`为`next[k]`，再次比较。其中`k>-1`。如果还是失败了，明显的不存在相同的前后缀子串`next[i] = -1`。\n\n\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    //暴力\n    int strStr(string haystack, string needle) {\n        int m = haystack.size(), n = needle.size();\n        if(n == 0) return 0;\n\n        int k = 0, j = 0;\n        //aaaaaf\n        //-----fs\n        while(k <= m - n){ \n            while(j < n && haystack[k] == needle[j]) ++k, ++j;\n            if(j == n) return k - j;\n            k = k - j + 1;\n            j = 0;\n        }\n        return -1;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    //暴力\n    \n\n    int strStr(string haystack, string needle) {\n        auto tonum = [](char a){return a -  'a';};\n        int m = haystack.size(), n = needle.size();\n        if(n == 0) return 0;\n        using ktype =  long long;\n        ktype base = 26, key = 0; //MOD 超过上限自然溢出?\n        ktype point = 0, hpow = 1, MOD = 1e9 + 7;\n\n        for(int i = 0; i < n; ++i){ // 字符串前位权重高\n            key = (key * base + tonum(needle[i])) % MOD;\n            hpow = (hpow * base) % MOD; // bugs\n            point = (point * base + tonum(haystack[i])) % MOD;\n        }\n        // if(point < 0 || key < 0) cout << \"+\";\n        if(key == point) return 0;\n        for(int j = n; j < m; ++j){    \n            point = (((point * base  - tonum(haystack[j - n]) * hpow) % MOD + MOD) + tonum(haystack[j])) % MOD; //疯狂使用运算符限制和e取余运算防止溢出\n            // if(point < 0 ) cout << '-';\n            if(key == point){\n                return j - n + 1;\n            }\n        }\n\n        return -1;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    //KMP     100% \n\n    int strStr(string haystack, string needle) {\n\n        int n = haystack.size(), m = needle.size();\n        if(m == 0 ) return 0;\n        vector<int> next(m, -1); //next[i] 为needle[0,...., i]相同最长前后缀的前缀末下标\n        \n        for(int i = 1; i < m; ++i){\n            int k = next[i - 1]; // needle[0,...., i - 1]相同最长前后缀的前缀末下标\n            while(k != -1 && needle[k + 1] != needle[i]){ // 尝试扩展前后缀 needle[0, k + 1], needle[,..,i-1,i]\n                k = next[k]; //匹配失败，缩短前后缀\n            }\n            if(needle[k + 1] != needle[i]) next[i] = -1;\n            else next[i] = k + 1;\n            // cout << next[i] << endl;\n        }\n\n        int i = 0, j = 0;\n        for(; i < n; ++i ){ // i, j 为当前匹配的下标字符\n            while(haystack[i] != needle[j] && j > 0){  // 两串匹配失败，且j可压缩\n                j = next[j - 1] + 1; // 压缩needle串的最长相等前后缀长度， 最小为0\n            }\n            if(haystack[i] == needle[j]){\n                ++j;\n                if(j == m) return i - j + 1;\n            }\n\n        }\n        return -1;\n    }\n};\n\n\n\n\n\n\n```\n\n","slug":"刷题/字符串/28-Implement-strStr","published":1,"updated":"2021-02-17T12:53:55.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j57002pl5uogwxlehp8","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>经典的字符子串匹配问题：</p>\n<ol>\n<li>暴力匹配，$O(mn)$</li>\n<li>Rabin Karp $O(n)$</li>\n<li><a href=\"https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/\">KMP算法</a></li>\n</ol>\n<span id=\"more\"></span>\n\n<h3 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h3><p>KMP算法的核心在于<code>next</code>数组，其<code>next[i]</code>记录了字符串<code>str[0...i]</code>的最长相同前后缀子串（不包括子串本身）的前缀尾下标。如此，我们在母子串在匹配<code>i</code>（母串<code>Sa</code>），<code>j</code>（子串<code>Sb</code>）失败时，子串的<code>k = next[j - 1]</code>记录了保证了最长<code>Sa</code>与<code>Sb[0, k]</code>可匹配成功（<code>k</code>不断减小，但<code>i</code>没有减小），重新判断<code>Sa[i]==?Sb[k+1]</code>即可。重复这个步骤，直到<code>k</code>无法缩小，或者匹配成功。若成功，<code>++i</code>，<code>++j</code>；若失败，则<code>++i</code>，<code>j=0</code>。</p>\n<p>但在此之前，还有构造<code>next</code>数组。神奇的是，<code>next[i]</code>构造与匹配的过程极其类似。首先<code>next[0] = -1</code>。记<code>k = next[i - 1]</code>，比较<code>Sb[k + 1] == ? Sb[i]</code>，若成功，则<code>Sb[i]= k + 1</code>；若失败，则寻找更小的公共前后缀（为了寻找最长的公共前缀长度，利用了<code>Sb[0,..,i-1]</code>子串的最长前缀后子串，以及更短的前后缀子串！（后两者的性质保证了属于前者的后缀子串✨✨）），缩小<code>k</code>为<code>next[k]</code>，再次比较。其中<code>k&gt;-1</code>。如果还是失败了，明显的不存在相同的前后缀子串<code>next[i] = -1</code>。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;暴力\n    int strStr(string haystack, string needle) &#123;\n        int m &#x3D; haystack.size(), n &#x3D; needle.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n\n        int k &#x3D; 0, j &#x3D; 0;\n        &#x2F;&#x2F;aaaaaf\n        &#x2F;&#x2F;-----fs\n        while(k &lt;&#x3D; m - n)&#123; \n            while(j &lt; n &amp;&amp; haystack[k] &#x3D;&#x3D; needle[j]) ++k, ++j;\n            if(j &#x3D;&#x3D; n) return k - j;\n            k &#x3D; k - j + 1;\n            j &#x3D; 0;\n        &#125;\n        return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;暴力\n    \n\n    int strStr(string haystack, string needle) &#123;\n        auto tonum &#x3D; [](char a)&#123;return a -  &#39;a&#39;;&#125;;\n        int m &#x3D; haystack.size(), n &#x3D; needle.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        using ktype &#x3D;  long long;\n        ktype base &#x3D; 26, key &#x3D; 0; &#x2F;&#x2F;MOD 超过上限自然溢出?\n        ktype point &#x3D; 0, hpow &#x3D; 1, MOD &#x3D; 1e9 + 7;\n\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123; &#x2F;&#x2F; 字符串前位权重高\n            key &#x3D; (key * base + tonum(needle[i])) % MOD;\n            hpow &#x3D; (hpow * base) % MOD; &#x2F;&#x2F; bugs\n            point &#x3D; (point * base + tonum(haystack[i])) % MOD;\n        &#125;\n        &#x2F;&#x2F; if(point &lt; 0 || key &lt; 0) cout &lt;&lt; &quot;+&quot;;\n        if(key &#x3D;&#x3D; point) return 0;\n        for(int j &#x3D; n; j &lt; m; ++j)&#123;    \n            point &#x3D; (((point * base  - tonum(haystack[j - n]) * hpow) % MOD + MOD) + tonum(haystack[j])) % MOD; &#x2F;&#x2F;疯狂使用运算符限制和e取余运算防止溢出\n            &#x2F;&#x2F; if(point &lt; 0 ) cout &lt;&lt; &#39;-&#39;;\n            if(key &#x3D;&#x3D; point)&#123;\n                return j - n + 1;\n            &#125;\n        &#125;\n\n        return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;KMP     100% \n\n    int strStr(string haystack, string needle) &#123;\n\n        int n &#x3D; haystack.size(), m &#x3D; needle.size();\n        if(m &#x3D;&#x3D; 0 ) return 0;\n        vector&lt;int&gt; next(m, -1); &#x2F;&#x2F;next[i] 为needle[0,...., i]相同最长前后缀的前缀末下标\n        \n        for(int i &#x3D; 1; i &lt; m; ++i)&#123;\n            int k &#x3D; next[i - 1]; &#x2F;&#x2F; needle[0,...., i - 1]相同最长前后缀的前缀末下标\n            while(k !&#x3D; -1 &amp;&amp; needle[k + 1] !&#x3D; needle[i])&#123; &#x2F;&#x2F; 尝试扩展前后缀 needle[0, k + 1], needle[,..,i-1,i]\n                k &#x3D; next[k]; &#x2F;&#x2F;匹配失败，缩短前后缀\n            &#125;\n            if(needle[k + 1] !&#x3D; needle[i]) next[i] &#x3D; -1;\n            else next[i] &#x3D; k + 1;\n            &#x2F;&#x2F; cout &lt;&lt; next[i] &lt;&lt; endl;\n        &#125;\n\n        int i &#x3D; 0, j &#x3D; 0;\n        for(; i &lt; n; ++i )&#123; &#x2F;&#x2F; i, j 为当前匹配的下标字符\n            while(haystack[i] !&#x3D; needle[j] &amp;&amp; j &gt; 0)&#123;  &#x2F;&#x2F; 两串匹配失败，且j可压缩\n                j &#x3D; next[j - 1] + 1; &#x2F;&#x2F; 压缩needle串的最长相等前后缀长度， 最小为0\n            &#125;\n            if(haystack[i] &#x3D;&#x3D; needle[j])&#123;\n                ++j;\n                if(j &#x3D;&#x3D; m) return i - j + 1;\n            &#125;\n\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n\n\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2GZ1B7X","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>经典的字符子串匹配问题：</p>\n<ol>\n<li>暴力匹配，$O(mn)$</li>\n<li>Rabin Karp $O(n)$</li>\n<li><a href=\"https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/\">KMP算法</a></li>\n</ol>","more":"<h3 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h3><p>KMP算法的核心在于<code>next</code>数组，其<code>next[i]</code>记录了字符串<code>str[0...i]</code>的最长相同前后缀子串（不包括子串本身）的前缀尾下标。如此，我们在母子串在匹配<code>i</code>（母串<code>Sa</code>），<code>j</code>（子串<code>Sb</code>）失败时，子串的<code>k = next[j - 1]</code>记录了保证了最长<code>Sa</code>与<code>Sb[0, k]</code>可匹配成功（<code>k</code>不断减小，但<code>i</code>没有减小），重新判断<code>Sa[i]==?Sb[k+1]</code>即可。重复这个步骤，直到<code>k</code>无法缩小，或者匹配成功。若成功，<code>++i</code>，<code>++j</code>；若失败，则<code>++i</code>，<code>j=0</code>。</p>\n<p>但在此之前，还有构造<code>next</code>数组。神奇的是，<code>next[i]</code>构造与匹配的过程极其类似。首先<code>next[0] = -1</code>。记<code>k = next[i - 1]</code>，比较<code>Sb[k + 1] == ? Sb[i]</code>，若成功，则<code>Sb[i]= k + 1</code>；若失败，则寻找更小的公共前后缀（为了寻找最长的公共前缀长度，利用了<code>Sb[0,..,i-1]</code>子串的最长前缀后子串，以及更短的前后缀子串！（后两者的性质保证了属于前者的后缀子串✨✨）），缩小<code>k</code>为<code>next[k]</code>，再次比较。其中<code>k&gt;-1</code>。如果还是失败了，明显的不存在相同的前后缀子串<code>next[i] = -1</code>。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;暴力\n    int strStr(string haystack, string needle) &#123;\n        int m &#x3D; haystack.size(), n &#x3D; needle.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n\n        int k &#x3D; 0, j &#x3D; 0;\n        &#x2F;&#x2F;aaaaaf\n        &#x2F;&#x2F;-----fs\n        while(k &lt;&#x3D; m - n)&#123; \n            while(j &lt; n &amp;&amp; haystack[k] &#x3D;&#x3D; needle[j]) ++k, ++j;\n            if(j &#x3D;&#x3D; n) return k - j;\n            k &#x3D; k - j + 1;\n            j &#x3D; 0;\n        &#125;\n        return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;暴力\n    \n\n    int strStr(string haystack, string needle) &#123;\n        auto tonum &#x3D; [](char a)&#123;return a -  &#39;a&#39;;&#125;;\n        int m &#x3D; haystack.size(), n &#x3D; needle.size();\n        if(n &#x3D;&#x3D; 0) return 0;\n        using ktype &#x3D;  long long;\n        ktype base &#x3D; 26, key &#x3D; 0; &#x2F;&#x2F;MOD 超过上限自然溢出?\n        ktype point &#x3D; 0, hpow &#x3D; 1, MOD &#x3D; 1e9 + 7;\n\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123; &#x2F;&#x2F; 字符串前位权重高\n            key &#x3D; (key * base + tonum(needle[i])) % MOD;\n            hpow &#x3D; (hpow * base) % MOD; &#x2F;&#x2F; bugs\n            point &#x3D; (point * base + tonum(haystack[i])) % MOD;\n        &#125;\n        &#x2F;&#x2F; if(point &lt; 0 || key &lt; 0) cout &lt;&lt; &quot;+&quot;;\n        if(key &#x3D;&#x3D; point) return 0;\n        for(int j &#x3D; n; j &lt; m; ++j)&#123;    \n            point &#x3D; (((point * base  - tonum(haystack[j - n]) * hpow) % MOD + MOD) + tonum(haystack[j])) % MOD; &#x2F;&#x2F;疯狂使用运算符限制和e取余运算防止溢出\n            &#x2F;&#x2F; if(point &lt; 0 ) cout &lt;&lt; &#39;-&#39;;\n            if(key &#x3D;&#x3D; point)&#123;\n                return j - n + 1;\n            &#125;\n        &#125;\n\n        return -1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F;KMP     100% \n\n    int strStr(string haystack, string needle) &#123;\n\n        int n &#x3D; haystack.size(), m &#x3D; needle.size();\n        if(m &#x3D;&#x3D; 0 ) return 0;\n        vector&lt;int&gt; next(m, -1); &#x2F;&#x2F;next[i] 为needle[0,...., i]相同最长前后缀的前缀末下标\n        \n        for(int i &#x3D; 1; i &lt; m; ++i)&#123;\n            int k &#x3D; next[i - 1]; &#x2F;&#x2F; needle[0,...., i - 1]相同最长前后缀的前缀末下标\n            while(k !&#x3D; -1 &amp;&amp; needle[k + 1] !&#x3D; needle[i])&#123; &#x2F;&#x2F; 尝试扩展前后缀 needle[0, k + 1], needle[,..,i-1,i]\n                k &#x3D; next[k]; &#x2F;&#x2F;匹配失败，缩短前后缀\n            &#125;\n            if(needle[k + 1] !&#x3D; needle[i]) next[i] &#x3D; -1;\n            else next[i] &#x3D; k + 1;\n            &#x2F;&#x2F; cout &lt;&lt; next[i] &lt;&lt; endl;\n        &#125;\n\n        int i &#x3D; 0, j &#x3D; 0;\n        for(; i &lt; n; ++i )&#123; &#x2F;&#x2F; i, j 为当前匹配的下标字符\n            while(haystack[i] !&#x3D; needle[j] &amp;&amp; j &gt; 0)&#123;  &#x2F;&#x2F; 两串匹配失败，且j可压缩\n                j &#x3D; next[j - 1] + 1; &#x2F;&#x2F; 压缩needle串的最长相等前后缀长度， 最小为0\n            &#125;\n            if(haystack[i] &#x3D;&#x3D; needle[j])&#123;\n                ++j;\n                if(j &#x3D;&#x3D; m) return i - j + 1;\n            &#125;\n\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n\n\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"3. Longest Substring Without Repeating Characters","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-18T05:25:07.000Z","_content":"\n\n\n# [3. Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n\n\n## 思路：\n\n1. 暴力\n2. 双指针\n\n> 可以观察到，符合题意的子串在按左端下标从小到大排序时，右端下标也是非严格递增的。\n>\n> 惊喜的是，双指针便可以派上用场了，`i`，`j`分别指向子串两端，并维护不重复的性质即可。\n\n<!-- more -->\n\n## 代码：\n\n暴力：\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n        int ct= 0;\n        for(int i = 0; i < s.size(); ++i){\n            vector<int> pos(259, -1);\n            for(int j = i; j < s.size(); ++j){\n                if(pos[s[j]] != -1) break;\n                pos[s[j]] = 1;\n                ct = max(ct, j - i + 1);\n            }\n        }\n            \n        return ct;\n    }\n};\n```\n\n\n\n双指针\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n        unordered_set<char> hash;\n        int i, j, ct, n = s.size(); \n        i = j = ct = 0;\n        while(j < n){\n            if(!hash.count(s[j])){\n                ct = max(ct, j - i + 1);\n                hash.insert(s[j++]);\n            } \n            else{\n                hash.erase(s[i++]);\n            }\n        }\n        return ct;\n    }\n};\n```\n\n","source":"_posts/刷题/字符串/3-Longest-Substring-Without-Repeating-Characters.md","raw":"---\ntitle: 3. Longest Substring Without Repeating Characters\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-18 13:25:07\ntags:\ncategories:\n---\n\n\n\n# [3. Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n\n\n## 思路：\n\n1. 暴力\n2. 双指针\n\n> 可以观察到，符合题意的子串在按左端下标从小到大排序时，右端下标也是非严格递增的。\n>\n> 惊喜的是，双指针便可以派上用场了，`i`，`j`分别指向子串两端，并维护不重复的性质即可。\n\n<!-- more -->\n\n## 代码：\n\n暴力：\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n        int ct= 0;\n        for(int i = 0; i < s.size(); ++i){\n            vector<int> pos(259, -1);\n            for(int j = i; j < s.size(); ++j){\n                if(pos[s[j]] != -1) break;\n                pos[s[j]] = 1;\n                ct = max(ct, j - i + 1);\n            }\n        }\n            \n        return ct;\n    }\n};\n```\n\n\n\n双指针\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n        unordered_set<char> hash;\n        int i, j, ct, n = s.size(); \n        i = j = ct = 0;\n        while(j < n){\n            if(!hash.count(s[j])){\n                ct = max(ct, j - i + 1);\n                hash.insert(s[j++]);\n            } \n            else{\n                hash.erase(s[i++]);\n            }\n        }\n        return ct;\n    }\n};\n```\n\n","slug":"刷题/字符串/3-Longest-Substring-Without-Repeating-Characters","published":1,"updated":"2021-02-18T05:33:20.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j58002ql5uobziz9avc","content":"<h1 id=\"3-Longest-Substring-Without-Repeating-Characters\"><a href=\"#3-Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"3. Longest Substring Without Repeating Characters\"></a><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3. Longest Substring Without Repeating Characters</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>暴力</li>\n<li>双指针</li>\n</ol>\n<blockquote>\n<p>可以观察到，符合题意的子串在按左端下标从小到大排序时，右端下标也是非严格递增的。</p>\n<p>惊喜的是，双指针便可以派上用场了，<code>i</code>，<code>j</code>分别指向子串两端，并维护不重复的性质即可。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>暴力：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLongestSubstring(string s) &#123;\n        \n        int ct&#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); ++i)&#123;\n            vector&lt;int&gt; pos(259, -1);\n            for(int j &#x3D; i; j &lt; s.size(); ++j)&#123;\n                if(pos[s[j]] !&#x3D; -1) break;\n                pos[s[j]] &#x3D; 1;\n                ct &#x3D; max(ct, j - i + 1);\n            &#125;\n        &#125;\n            \n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>双指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLongestSubstring(string s) &#123;\n        \n        unordered_set&lt;char&gt; hash;\n        int i, j, ct, n &#x3D; s.size(); \n        i &#x3D; j &#x3D; ct &#x3D; 0;\n        while(j &lt; n)&#123;\n            if(!hash.count(s[j]))&#123;\n                ct &#x3D; max(ct, j - i + 1);\n                hash.insert(s[j++]);\n            &#125; \n            else&#123;\n                hash.erase(s[i++]);\n            &#125;\n        &#125;\n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"32T5C4R","excerpt":"<h1 id=\"3-Longest-Substring-Without-Repeating-Characters\"><a href=\"#3-Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"3. Longest Substring Without Repeating Characters\"></a><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3. Longest Substring Without Repeating Characters</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>暴力</li>\n<li>双指针</li>\n</ol>\n<blockquote>\n<p>可以观察到，符合题意的子串在按左端下标从小到大排序时，右端下标也是非严格递增的。</p>\n<p>惊喜的是，双指针便可以派上用场了，<code>i</code>，<code>j</code>分别指向子串两端，并维护不重复的性质即可。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>暴力：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLongestSubstring(string s) &#123;\n        \n        int ct&#x3D; 0;\n        for(int i &#x3D; 0; i &lt; s.size(); ++i)&#123;\n            vector&lt;int&gt; pos(259, -1);\n            for(int j &#x3D; i; j &lt; s.size(); ++j)&#123;\n                if(pos[s[j]] !&#x3D; -1) break;\n                pos[s[j]] &#x3D; 1;\n                ct &#x3D; max(ct, j - i + 1);\n            &#125;\n        &#125;\n            \n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>双指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLongestSubstring(string s) &#123;\n        \n        unordered_set&lt;char&gt; hash;\n        int i, j, ct, n &#x3D; s.size(); \n        i &#x3D; j &#x3D; ct &#x3D; 0;\n        while(j &lt; n)&#123;\n            if(!hash.count(s[j]))&#123;\n                ct &#x3D; max(ct, j - i + 1);\n                hash.insert(s[j++]);\n            &#125; \n            else&#123;\n                hash.erase(s[i++]);\n            &#125;\n        &#125;\n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"647. Palindromic Substrings","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-14T13:02:17.000Z","_content":"\n\n\n\n\n# [647. Palindromic Substrings](https://leetcode-cn.com/problems/palindromic-substrings/)1\n\n\n\n## 思路：\n\n`Manacher`算法：\n\n回文字符串的判断方式方式会从中心点从发向外不断扩展，`Manacher`算法给出了缩减了字符串判断回文的重复步骤。其核心思想在于，一段回文`s`上的呈对称状的左右`A`和`B`两点，`B`点的最小回文长度可以通过`A`点的回文长度和`B`到`s`边右边界的长度最小值决定。另外，为了改变回文串长度为偶数和奇数的不同，在每个字符前和后都插入一个`#`，如此插入后的`T`的最长回文串**半径**`d`，与`S`最长回文串**半径**的`k`有， `k = [d / 2]` 。\n\n> `[]`向下取整。\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        string t = \"!#\"; // 插入哨兵\n        for(char c : s){\n            t += c + string(\"#\"); \n        }\n        t +=\"$\";\n        int amount = 0, n = t.size();\n        vector<int> f(n);\n        int curmid = 1, right = 1;\n        for(int i = 1; i < n; ++i){\n            int j = curmid * 2 - i;\n            int len = i > right ? 1 : min(f[j], right - i + 1);\n            while(t[i + len] == t[i - len]) ++len; //$ !作为哨兵自动控制边界\n            f[i] = len;\n            if(i + len - 1 > right){\n                curmid = i;\n                right = i + len - 1;\n            }\n            amount += f[i] / 2;\n            // cout<< f[i] << \" \";\n        }\n        // cout << endl;\n        return amount;\n    }\n};\n```\n\n","source":"_posts/刷题/字符串/647-Palindromic-Substrings.md","raw":"---\ntitle: 647. Palindromic Substrings\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-14 21:02:17\ntags:\ncategories:\n---\n\n\n\n\n\n# [647. Palindromic Substrings](https://leetcode-cn.com/problems/palindromic-substrings/)1\n\n\n\n## 思路：\n\n`Manacher`算法：\n\n回文字符串的判断方式方式会从中心点从发向外不断扩展，`Manacher`算法给出了缩减了字符串判断回文的重复步骤。其核心思想在于，一段回文`s`上的呈对称状的左右`A`和`B`两点，`B`点的最小回文长度可以通过`A`点的回文长度和`B`到`s`边右边界的长度最小值决定。另外，为了改变回文串长度为偶数和奇数的不同，在每个字符前和后都插入一个`#`，如此插入后的`T`的最长回文串**半径**`d`，与`S`最长回文串**半径**的`k`有， `k = [d / 2]` 。\n\n> `[]`向下取整。\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        string t = \"!#\"; // 插入哨兵\n        for(char c : s){\n            t += c + string(\"#\"); \n        }\n        t +=\"$\";\n        int amount = 0, n = t.size();\n        vector<int> f(n);\n        int curmid = 1, right = 1;\n        for(int i = 1; i < n; ++i){\n            int j = curmid * 2 - i;\n            int len = i > right ? 1 : min(f[j], right - i + 1);\n            while(t[i + len] == t[i - len]) ++len; //$ !作为哨兵自动控制边界\n            f[i] = len;\n            if(i + len - 1 > right){\n                curmid = i;\n                right = i + len - 1;\n            }\n            amount += f[i] / 2;\n            // cout<< f[i] << \" \";\n        }\n        // cout << endl;\n        return amount;\n    }\n};\n```\n\n","slug":"刷题/字符串/647-Palindromic-Substrings","published":1,"updated":"2021-02-14T13:11:16.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j58002rl5uo9yrycara","content":"<h1 id=\"647-Palindromic-Substrings1\"><a href=\"#647-Palindromic-Substrings1\" class=\"headerlink\" title=\"647. Palindromic Substrings1\"></a><a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">647. Palindromic Substrings</a>1</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>Manacher</code>算法：</p>\n<p>回文字符串的判断方式方式会从中心点从发向外不断扩展，<code>Manacher</code>算法给出了缩减了字符串判断回文的重复步骤。其核心思想在于，一段回文<code>s</code>上的呈对称状的左右<code>A</code>和<code>B</code>两点，<code>B</code>点的最小回文长度可以通过<code>A</code>点的回文长度和<code>B</code>到<code>s</code>边右边界的长度最小值决定。另外，为了改变回文串长度为偶数和奇数的不同，在每个字符前和后都插入一个<code>#</code>，如此插入后的<code>T</code>的最长回文串<strong>半径</strong><code>d</code>，与<code>S</code>最长回文串<strong>半径</strong>的<code>k</code>有， <code>k = [d / 2]</code> 。</p>\n<blockquote>\n<p><code>[]</code>向下取整。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countSubstrings(string s) &#123;\n        string t &#x3D; &quot;!#&quot;; &#x2F;&#x2F; 插入哨兵\n        for(char c : s)&#123;\n            t +&#x3D; c + string(&quot;#&quot;); \n        &#125;\n        t +&#x3D;&quot;$&quot;;\n        int amount &#x3D; 0, n &#x3D; t.size();\n        vector&lt;int&gt; f(n);\n        int curmid &#x3D; 1, right &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            int j &#x3D; curmid * 2 - i;\n            int len &#x3D; i &gt; right ? 1 : min(f[j], right - i + 1);\n            while(t[i + len] &#x3D;&#x3D; t[i - len]) ++len; &#x2F;&#x2F;$ !作为哨兵自动控制边界\n            f[i] &#x3D; len;\n            if(i + len - 1 &gt; right)&#123;\n                curmid &#x3D; i;\n                right &#x3D; i + len - 1;\n            &#125;\n            amount +&#x3D; f[i] &#x2F; 2;\n            &#x2F;&#x2F; cout&lt;&lt; f[i] &lt;&lt; &quot; &quot;;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        return amount;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2PKBGY7","excerpt":"<h1 id=\"647-Palindromic-Substrings1\"><a href=\"#647-Palindromic-Substrings1\" class=\"headerlink\" title=\"647. Palindromic Substrings1\"></a><a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">647. Palindromic Substrings</a>1</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>Manacher</code>算法：</p>\n<p>回文字符串的判断方式方式会从中心点从发向外不断扩展，<code>Manacher</code>算法给出了缩减了字符串判断回文的重复步骤。其核心思想在于，一段回文<code>s</code>上的呈对称状的左右<code>A</code>和<code>B</code>两点，<code>B</code>点的最小回文长度可以通过<code>A</code>点的回文长度和<code>B</code>到<code>s</code>边右边界的长度最小值决定。另外，为了改变回文串长度为偶数和奇数的不同，在每个字符前和后都插入一个<code>#</code>，如此插入后的<code>T</code>的最长回文串<strong>半径</strong><code>d</code>，与<code>S</code>最长回文串<strong>半径</strong>的<code>k</code>有， <code>k = [d / 2]</code> 。</p>\n<blockquote>\n<p><code>[]</code>向下取整。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countSubstrings(string s) &#123;\n        string t &#x3D; &quot;!#&quot;; &#x2F;&#x2F; 插入哨兵\n        for(char c : s)&#123;\n            t +&#x3D; c + string(&quot;#&quot;); \n        &#125;\n        t +&#x3D;&quot;$&quot;;\n        int amount &#x3D; 0, n &#x3D; t.size();\n        vector&lt;int&gt; f(n);\n        int curmid &#x3D; 1, right &#x3D; 1;\n        for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n            int j &#x3D; curmid * 2 - i;\n            int len &#x3D; i &gt; right ? 1 : min(f[j], right - i + 1);\n            while(t[i + len] &#x3D;&#x3D; t[i - len]) ++len; &#x2F;&#x2F;$ !作为哨兵自动控制边界\n            f[i] &#x3D; len;\n            if(i + len - 1 &gt; right)&#123;\n                curmid &#x3D; i;\n                right &#x3D; i + len - 1;\n            &#125;\n            amount +&#x3D; f[i] &#x2F; 2;\n            &#x2F;&#x2F; cout&lt;&lt; f[i] &lt;&lt; &quot; &quot;;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        return amount;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"215. Kth Largest Element in an Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-14T02:11:48.000Z","_content":"\n\n\n\n## [215. Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n\n\n复习一遍第K大算法的三 ➕ 一种经典解法\n\n<!-- more -->\n\n## 思路：\n\n1. 暴力排序\n2. 快速排序的Partition\n3. 建长度为`k`的小顶堆\n4. ⭐⭐⭐快速指针算法, $O(N)$ \n\n> 这题的算法非常巧妙！同样也是`partition`思想，取一个`nums[k]`作为`pivot`，并放在数组最右边作为哨兵。用两个指针`i`和`j`从左到右遍历数组，其意义在于指向比`pivot`小的数字区间左右闭区间。如果`nums[j]>pivot`，则`swap(nums[j++], nums[i++])`。否则，`j++`。这一遍历动作维持了指针的性质。最后遍历结束后后，可能有`[2, 1, 3, pivot, pivot, pivot, 10,9,]`，其中`i=4`。\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {    \n        int pos = -1;\n        int s = 0, e = nums.size();\n        k = (int)nums.size() - k + 1;\n        pos = sortPartVec(nums, s, e);\n        while(1){    \n            // cout << s << ' ' << e << \" \" << pos << endl;        \n            if(pos + 1 == k) return nums[pos];\n            else if(pos + 1 > k){\n                s = s;\n                e = pos;\n                pos = sortPartVec(nums, s, e); \n            } \n            else{\n                s = pos + 1;\n                e = e;\n                pos = sortPartVec(nums, s, e);\n            }\n        }\n    }\n\n    int sortPartVec(vector<int>& nums, int s, int e){\n        int len =  min((int)nums.size(), e - s);\n        if(len == 1) return s;\n        else if(len == 0) return -1;\n        // if(nums[len / 2] > nums[0]) swap(nums[0], nums[len / 2]);\n        int l = s, r = e - 1, pivot = nums[s];\n        while(l  < r){\n            while(l < r && nums[r] > pivot) r--;\n            nums[l] = nums[r];            \n            while(l < r && nums[l] <= pivot) l++;\n            nums[r] = nums[l];\n        }\n        nums[r] = pivot;\n        return r;       \n\n    }\n};\n```\n\n建堆算法\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> heap;\n    int maxlen;\n    int findKthLargest(vector<int>& nums, int k) {    \n        maxlen = k + 1;\n        heap.push_back(1);\n        for(int i = 0; i < nums.size(); ++i)\n            insert_heap(nums[i]);\n        return heap[1];\n\n    }\n\n    void upAdjust(int p, int len){\n        for(int x = p / 2; x >= 1; x /= 2){            \n            if(heap[x] < heap[p]) break;\n            swap(heap[x], heap[p]);\n            p = x;\n        }\n    }\n\n    void downAdjust(int p, int len){\n        for(int x = p * 2; x < len; x += x){\n            if(x + 1 < len)\n                x = (heap[x] < heap[x + 1]) ? x : x + 1;\n            if(heap[x] >= heap[p]) break;\n            swap(heap[x], heap[p]);\n            p = x;\n        }\n    }\n\n    void insert_heap(int x){\n         int len = heap.size();\n         if(len == maxlen){\n             if(heap[1] < x){\n                 pop_heap();\n                 len--;\n             }\n             else return;\n        }\n        heap.push_back(x);\n        heap[len] = x;\n        upAdjust(len, len + 1);         \n    }\n\n    void pop_heap(){\n        int pos = 1, len = heap.size();\n        heap[1] = heap[len - 1];\n        len--;\n        heap.pop_back();\n        downAdjust(1, len);    \n    }\n};\n```\n\n利用STL模板\n\n```c++\nclass Solution {\npublic:\n \n    priority_queue<int, vector<int>, greater<int> > que;\n    int findKthLargest(vector<int>& nums, int k) {    \n        for(int i = 0; i < nums.size(); ++i){\n            if(que.size() == k && que.top() < nums[i]){\n                que.pop();\n                que.push(nums[i]);\n            }\n            else if(que.size() < k) que.push(nums[i]);\n        }            \n        return que.top();\n\n    }\n\n \n\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    // 最优解 快速选择算法\n    int findth(vector<int>& nums, int l, int r){\n        swap(nums[r], nums[rand() % (r - l + 1) + l]);\n        int i, j;\n        i = j = 0;\n        while(j <= r){\n            if(nums[j] > nums[r]) ++j;\n            else{\n                swap(nums[j++], nums[i++]);\n            }\n        }\n        // cout << l << ' ' << r << \" \" << nums[i - 1] << endl;;\n        return i - 1; //povit\n    }\n    int recurfindth(vector<int>& nums, int l, int r, int k){\n        int th = findth(nums, l, r);\n        int findk = nums.size() - th;\n        if( k == findk) return nums[th];\n        else if(k < findk) return recurfindth(nums, th + 1, r, k);\n        else return recurfindth(nums, l, th - 1, k);\n    }\n    int findKthLargest(vector<int>& nums, int k) {    \n        return recurfindth(nums, 0, nums.size() - 1, k);\n    }\n\n \n\n};\n```","source":"_posts/刷题/排序\n/215-Kth-Largest-Element-in-an-Array.md","raw":"---\ntitle: 215. Kth Largest Element in an Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-14 10:11:48\n---\n\n\n\n\n## [215. Kth Largest Element in an Array](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n\n\n复习一遍第K大算法的三 ➕ 一种经典解法\n\n<!-- more -->\n\n## 思路：\n\n1. 暴力排序\n2. 快速排序的Partition\n3. 建长度为`k`的小顶堆\n4. ⭐⭐⭐快速指针算法, $O(N)$ \n\n> 这题的算法非常巧妙！同样也是`partition`思想，取一个`nums[k]`作为`pivot`，并放在数组最右边作为哨兵。用两个指针`i`和`j`从左到右遍历数组，其意义在于指向比`pivot`小的数字区间左右闭区间。如果`nums[j]>pivot`，则`swap(nums[j++], nums[i++])`。否则，`j++`。这一遍历动作维持了指针的性质。最后遍历结束后后，可能有`[2, 1, 3, pivot, pivot, pivot, 10,9,]`，其中`i=4`。\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {    \n        int pos = -1;\n        int s = 0, e = nums.size();\n        k = (int)nums.size() - k + 1;\n        pos = sortPartVec(nums, s, e);\n        while(1){    \n            // cout << s << ' ' << e << \" \" << pos << endl;        \n            if(pos + 1 == k) return nums[pos];\n            else if(pos + 1 > k){\n                s = s;\n                e = pos;\n                pos = sortPartVec(nums, s, e); \n            } \n            else{\n                s = pos + 1;\n                e = e;\n                pos = sortPartVec(nums, s, e);\n            }\n        }\n    }\n\n    int sortPartVec(vector<int>& nums, int s, int e){\n        int len =  min((int)nums.size(), e - s);\n        if(len == 1) return s;\n        else if(len == 0) return -1;\n        // if(nums[len / 2] > nums[0]) swap(nums[0], nums[len / 2]);\n        int l = s, r = e - 1, pivot = nums[s];\n        while(l  < r){\n            while(l < r && nums[r] > pivot) r--;\n            nums[l] = nums[r];            \n            while(l < r && nums[l] <= pivot) l++;\n            nums[r] = nums[l];\n        }\n        nums[r] = pivot;\n        return r;       \n\n    }\n};\n```\n\n建堆算法\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> heap;\n    int maxlen;\n    int findKthLargest(vector<int>& nums, int k) {    \n        maxlen = k + 1;\n        heap.push_back(1);\n        for(int i = 0; i < nums.size(); ++i)\n            insert_heap(nums[i]);\n        return heap[1];\n\n    }\n\n    void upAdjust(int p, int len){\n        for(int x = p / 2; x >= 1; x /= 2){            \n            if(heap[x] < heap[p]) break;\n            swap(heap[x], heap[p]);\n            p = x;\n        }\n    }\n\n    void downAdjust(int p, int len){\n        for(int x = p * 2; x < len; x += x){\n            if(x + 1 < len)\n                x = (heap[x] < heap[x + 1]) ? x : x + 1;\n            if(heap[x] >= heap[p]) break;\n            swap(heap[x], heap[p]);\n            p = x;\n        }\n    }\n\n    void insert_heap(int x){\n         int len = heap.size();\n         if(len == maxlen){\n             if(heap[1] < x){\n                 pop_heap();\n                 len--;\n             }\n             else return;\n        }\n        heap.push_back(x);\n        heap[len] = x;\n        upAdjust(len, len + 1);         \n    }\n\n    void pop_heap(){\n        int pos = 1, len = heap.size();\n        heap[1] = heap[len - 1];\n        len--;\n        heap.pop_back();\n        downAdjust(1, len);    \n    }\n};\n```\n\n利用STL模板\n\n```c++\nclass Solution {\npublic:\n \n    priority_queue<int, vector<int>, greater<int> > que;\n    int findKthLargest(vector<int>& nums, int k) {    \n        for(int i = 0; i < nums.size(); ++i){\n            if(que.size() == k && que.top() < nums[i]){\n                que.pop();\n                que.push(nums[i]);\n            }\n            else if(que.size() < k) que.push(nums[i]);\n        }            \n        return que.top();\n\n    }\n\n \n\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    // 最优解 快速选择算法\n    int findth(vector<int>& nums, int l, int r){\n        swap(nums[r], nums[rand() % (r - l + 1) + l]);\n        int i, j;\n        i = j = 0;\n        while(j <= r){\n            if(nums[j] > nums[r]) ++j;\n            else{\n                swap(nums[j++], nums[i++]);\n            }\n        }\n        // cout << l << ' ' << r << \" \" << nums[i - 1] << endl;;\n        return i - 1; //povit\n    }\n    int recurfindth(vector<int>& nums, int l, int r, int k){\n        int th = findth(nums, l, r);\n        int findk = nums.size() - th;\n        if( k == findk) return nums[th];\n        else if(k < findk) return recurfindth(nums, th + 1, r, k);\n        else return recurfindth(nums, l, th - 1, k);\n    }\n    int findKthLargest(vector<int>& nums, int k) {    \n        return recurfindth(nums, 0, nums.size() - 1, k);\n    }\n\n \n\n};\n```","slug":"刷题-排序-215-Kth-Largest-Element-in-an-Array","published":1,"updated":"2021-02-18T05:07:34.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j59002sl5uo4fpv4lq2","content":"<h2 id=\"215-Kth-Largest-Element-in-an-Array\"><a href=\"#215-Kth-Largest-Element-in-an-Array\" class=\"headerlink\" title=\"215. Kth Largest Element in an Array\"></a><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">215. Kth Largest Element in an Array</a></h2><p>复习一遍第K大算法的三 ➕ 一种经典解法</p>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>暴力排序</li>\n<li>快速排序的Partition</li>\n<li>建长度为<code>k</code>的小顶堆</li>\n<li>⭐⭐⭐快速指针算法, $O(N)$ </li>\n</ol>\n<blockquote>\n<p>这题的算法非常巧妙！同样也是<code>partition</code>思想，取一个<code>nums[k]</code>作为<code>pivot</code>，并放在数组最右边作为哨兵。用两个指针<code>i</code>和<code>j</code>从左到右遍历数组，其意义在于指向比<code>pivot</code>小的数字区间左右闭区间。如果<code>nums[j]&gt;pivot</code>，则<code>swap(nums[j++], nums[i++])</code>。否则，<code>j++</code>。这一遍历动作维持了指针的性质。最后遍历结束后后，可能有<code>[2, 1, 3, pivot, pivot, pivot, 10,9,]</code>，其中<code>i=4</code>。</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        int pos &#x3D; -1;\n        int s &#x3D; 0, e &#x3D; nums.size();\n        k &#x3D; (int)nums.size() - k + 1;\n        pos &#x3D; sortPartVec(nums, s, e);\n        while(1)&#123;    \n            &#x2F;&#x2F; cout &lt;&lt; s &lt;&lt; &#39; &#39; &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; pos &lt;&lt; endl;        \n            if(pos + 1 &#x3D;&#x3D; k) return nums[pos];\n            else if(pos + 1 &gt; k)&#123;\n                s &#x3D; s;\n                e &#x3D; pos;\n                pos &#x3D; sortPartVec(nums, s, e); \n            &#125; \n            else&#123;\n                s &#x3D; pos + 1;\n                e &#x3D; e;\n                pos &#x3D; sortPartVec(nums, s, e);\n            &#125;\n        &#125;\n    &#125;\n\n    int sortPartVec(vector&lt;int&gt;&amp; nums, int s, int e)&#123;\n        int len &#x3D;  min((int)nums.size(), e - s);\n        if(len &#x3D;&#x3D; 1) return s;\n        else if(len &#x3D;&#x3D; 0) return -1;\n        &#x2F;&#x2F; if(nums[len &#x2F; 2] &gt; nums[0]) swap(nums[0], nums[len &#x2F; 2]);\n        int l &#x3D; s, r &#x3D; e - 1, pivot &#x3D; nums[s];\n        while(l  &lt; r)&#123;\n            while(l &lt; r &amp;&amp; nums[r] &gt; pivot) r--;\n            nums[l] &#x3D; nums[r];            \n            while(l &lt; r &amp;&amp; nums[l] &lt;&#x3D; pivot) l++;\n            nums[r] &#x3D; nums[l];\n        &#125;\n        nums[r] &#x3D; pivot;\n        return r;       \n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>建堆算法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; heap;\n    int maxlen;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        maxlen &#x3D; k + 1;\n        heap.push_back(1);\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)\n            insert_heap(nums[i]);\n        return heap[1];\n\n    &#125;\n\n    void upAdjust(int p, int len)&#123;\n        for(int x &#x3D; p &#x2F; 2; x &gt;&#x3D; 1; x &#x2F;&#x3D; 2)&#123;            \n            if(heap[x] &lt; heap[p]) break;\n            swap(heap[x], heap[p]);\n            p &#x3D; x;\n        &#125;\n    &#125;\n\n    void downAdjust(int p, int len)&#123;\n        for(int x &#x3D; p * 2; x &lt; len; x +&#x3D; x)&#123;\n            if(x + 1 &lt; len)\n                x &#x3D; (heap[x] &lt; heap[x + 1]) ? x : x + 1;\n            if(heap[x] &gt;&#x3D; heap[p]) break;\n            swap(heap[x], heap[p]);\n            p &#x3D; x;\n        &#125;\n    &#125;\n\n    void insert_heap(int x)&#123;\n         int len &#x3D; heap.size();\n         if(len &#x3D;&#x3D; maxlen)&#123;\n             if(heap[1] &lt; x)&#123;\n                 pop_heap();\n                 len--;\n             &#125;\n             else return;\n        &#125;\n        heap.push_back(x);\n        heap[len] &#x3D; x;\n        upAdjust(len, len + 1);         \n    &#125;\n\n    void pop_heap()&#123;\n        int pos &#x3D; 1, len &#x3D; heap.size();\n        heap[1] &#x3D; heap[len - 1];\n        len--;\n        heap.pop_back();\n        downAdjust(1, len);    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>利用STL模板</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n \n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            if(que.size() &#x3D;&#x3D; k &amp;&amp; que.top() &lt; nums[i])&#123;\n                que.pop();\n                que.push(nums[i]);\n            &#125;\n            else if(que.size() &lt; k) que.push(nums[i]);\n        &#125;            \n        return que.top();\n\n    &#125;\n\n \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 最优解 快速选择算法\n    int findth(vector&lt;int&gt;&amp; nums, int l, int r)&#123;\n        swap(nums[r], nums[rand() % (r - l + 1) + l]);\n        int i, j;\n        i &#x3D; j &#x3D; 0;\n        while(j &lt;&#x3D; r)&#123;\n            if(nums[j] &gt; nums[r]) ++j;\n            else&#123;\n                swap(nums[j++], nums[i++]);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; nums[i - 1] &lt;&lt; endl;;\n        return i - 1; &#x2F;&#x2F;povit\n    &#125;\n    int recurfindth(vector&lt;int&gt;&amp; nums, int l, int r, int k)&#123;\n        int th &#x3D; findth(nums, l, r);\n        int findk &#x3D; nums.size() - th;\n        if( k &#x3D;&#x3D; findk) return nums[th];\n        else if(k &lt; findk) return recurfindth(nums, th + 1, r, k);\n        else return recurfindth(nums, l, th - 1, k);\n    &#125;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        return recurfindth(nums, 0, nums.size() - 1, k);\n    &#125;\n\n \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"22VP3T0","excerpt":"<h2 id=\"215-Kth-Largest-Element-in-an-Array\"><a href=\"#215-Kth-Largest-Element-in-an-Array\" class=\"headerlink\" title=\"215. Kth Largest Element in an Array\"></a><a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">215. Kth Largest Element in an Array</a></h2><p>复习一遍第K大算法的三 ➕ 一种经典解法</p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>暴力排序</li>\n<li>快速排序的Partition</li>\n<li>建长度为<code>k</code>的小顶堆</li>\n<li>⭐⭐⭐快速指针算法, $O(N)$ </li>\n</ol>\n<blockquote>\n<p>这题的算法非常巧妙！同样也是<code>partition</code>思想，取一个<code>nums[k]</code>作为<code>pivot</code>，并放在数组最右边作为哨兵。用两个指针<code>i</code>和<code>j</code>从左到右遍历数组，其意义在于指向比<code>pivot</code>小的数字区间左右闭区间。如果<code>nums[j]&gt;pivot</code>，则<code>swap(nums[j++], nums[i++])</code>。否则，<code>j++</code>。这一遍历动作维持了指针的性质。最后遍历结束后后，可能有<code>[2, 1, 3, pivot, pivot, pivot, 10,9,]</code>，其中<code>i=4</code>。</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        int pos &#x3D; -1;\n        int s &#x3D; 0, e &#x3D; nums.size();\n        k &#x3D; (int)nums.size() - k + 1;\n        pos &#x3D; sortPartVec(nums, s, e);\n        while(1)&#123;    \n            &#x2F;&#x2F; cout &lt;&lt; s &lt;&lt; &#39; &#39; &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; pos &lt;&lt; endl;        \n            if(pos + 1 &#x3D;&#x3D; k) return nums[pos];\n            else if(pos + 1 &gt; k)&#123;\n                s &#x3D; s;\n                e &#x3D; pos;\n                pos &#x3D; sortPartVec(nums, s, e); \n            &#125; \n            else&#123;\n                s &#x3D; pos + 1;\n                e &#x3D; e;\n                pos &#x3D; sortPartVec(nums, s, e);\n            &#125;\n        &#125;\n    &#125;\n\n    int sortPartVec(vector&lt;int&gt;&amp; nums, int s, int e)&#123;\n        int len &#x3D;  min((int)nums.size(), e - s);\n        if(len &#x3D;&#x3D; 1) return s;\n        else if(len &#x3D;&#x3D; 0) return -1;\n        &#x2F;&#x2F; if(nums[len &#x2F; 2] &gt; nums[0]) swap(nums[0], nums[len &#x2F; 2]);\n        int l &#x3D; s, r &#x3D; e - 1, pivot &#x3D; nums[s];\n        while(l  &lt; r)&#123;\n            while(l &lt; r &amp;&amp; nums[r] &gt; pivot) r--;\n            nums[l] &#x3D; nums[r];            \n            while(l &lt; r &amp;&amp; nums[l] &lt;&#x3D; pivot) l++;\n            nums[r] &#x3D; nums[l];\n        &#125;\n        nums[r] &#x3D; pivot;\n        return r;       \n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>建堆算法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; heap;\n    int maxlen;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        maxlen &#x3D; k + 1;\n        heap.push_back(1);\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)\n            insert_heap(nums[i]);\n        return heap[1];\n\n    &#125;\n\n    void upAdjust(int p, int len)&#123;\n        for(int x &#x3D; p &#x2F; 2; x &gt;&#x3D; 1; x &#x2F;&#x3D; 2)&#123;            \n            if(heap[x] &lt; heap[p]) break;\n            swap(heap[x], heap[p]);\n            p &#x3D; x;\n        &#125;\n    &#125;\n\n    void downAdjust(int p, int len)&#123;\n        for(int x &#x3D; p * 2; x &lt; len; x +&#x3D; x)&#123;\n            if(x + 1 &lt; len)\n                x &#x3D; (heap[x] &lt; heap[x + 1]) ? x : x + 1;\n            if(heap[x] &gt;&#x3D; heap[p]) break;\n            swap(heap[x], heap[p]);\n            p &#x3D; x;\n        &#125;\n    &#125;\n\n    void insert_heap(int x)&#123;\n         int len &#x3D; heap.size();\n         if(len &#x3D;&#x3D; maxlen)&#123;\n             if(heap[1] &lt; x)&#123;\n                 pop_heap();\n                 len--;\n             &#125;\n             else return;\n        &#125;\n        heap.push_back(x);\n        heap[len] &#x3D; x;\n        upAdjust(len, len + 1);         \n    &#125;\n\n    void pop_heap()&#123;\n        int pos &#x3D; 1, len &#x3D; heap.size();\n        heap[1] &#x3D; heap[len - 1];\n        len--;\n        heap.pop_back();\n        downAdjust(1, len);    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>利用STL模板</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n \n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            if(que.size() &#x3D;&#x3D; k &amp;&amp; que.top() &lt; nums[i])&#123;\n                que.pop();\n                que.push(nums[i]);\n            &#125;\n            else if(que.size() &lt; k) que.push(nums[i]);\n        &#125;            \n        return que.top();\n\n    &#125;\n\n \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; 最优解 快速选择算法\n    int findth(vector&lt;int&gt;&amp; nums, int l, int r)&#123;\n        swap(nums[r], nums[rand() % (r - l + 1) + l]);\n        int i, j;\n        i &#x3D; j &#x3D; 0;\n        while(j &lt;&#x3D; r)&#123;\n            if(nums[j] &gt; nums[r]) ++j;\n            else&#123;\n                swap(nums[j++], nums[i++]);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; nums[i - 1] &lt;&lt; endl;;\n        return i - 1; &#x2F;&#x2F;povit\n    &#125;\n    int recurfindth(vector&lt;int&gt;&amp; nums, int l, int r, int k)&#123;\n        int th &#x3D; findth(nums, l, r);\n        int findk &#x3D; nums.size() - th;\n        if( k &#x3D;&#x3D; findk) return nums[th];\n        else if(k &lt; findk) return recurfindth(nums, th + 1, r, k);\n        else return recurfindth(nums, l, th - 1, k);\n    &#125;\n    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    \n        return recurfindth(nums, 0, nums.size() - 1, k);\n    &#125;\n\n \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"451. Sort Characters By Frequency","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-16T01:15:47.000Z","_content":"\n\n\n\n## [451. Sort Characters By Frequency](https://leetcode-cn.com/problems/sort-characters-by-frequency/)\n\n## 思路：\n\n统计每个字符出现的频率， 按频率排序或者建立堆获取最大值。\n\n<!-- more -->\n\n>  击败100\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    string frequencySort(string s) {\n        int count[258] = {0};\n        int len = s.size();\n        for(int i = 0; i < len ; ++i){\n            count[s[i]]++;\n        }\n        priority_queue< pair<int, int>, vector<pair<int, int>>, less<pair<int, int> > > pq; \n        for(int i = 0; i < 258; ++i){\n            if(count[i] != 0)\n                pq.push( make_pair(count[i], i));\n        }\n        string ans = \"\";\n        while(pq.size()){\n            pair<int, int> t = pq.top(); \n            pq.pop();\n            int time = t.first;\n            int ichar = t.second;\n            string single(time, (char)ichar);\n            ans +=  single;        \n        }\n        return ans;\n    }\n};\n```","source":"_posts/刷题/排序\n/451-Sort-Characters-By-Frequency.md","raw":"---\ntitle: 451. Sort Characters By Frequency\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-16 09:15:47\n---\n\n\n\n\n## [451. Sort Characters By Frequency](https://leetcode-cn.com/problems/sort-characters-by-frequency/)\n\n## 思路：\n\n统计每个字符出现的频率， 按频率排序或者建立堆获取最大值。\n\n<!-- more -->\n\n>  击败100\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    string frequencySort(string s) {\n        int count[258] = {0};\n        int len = s.size();\n        for(int i = 0; i < len ; ++i){\n            count[s[i]]++;\n        }\n        priority_queue< pair<int, int>, vector<pair<int, int>>, less<pair<int, int> > > pq; \n        for(int i = 0; i < 258; ++i){\n            if(count[i] != 0)\n                pq.push( make_pair(count[i], i));\n        }\n        string ans = \"\";\n        while(pq.size()){\n            pair<int, int> t = pq.top(); \n            pq.pop();\n            int time = t.first;\n            int ichar = t.second;\n            string single(time, (char)ichar);\n            ans +=  single;        \n        }\n        return ans;\n    }\n};\n```","slug":"刷题-排序-451-Sort-Characters-By-Frequency","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5a002tl5uo2v0d3ns7","content":"<h2 id=\"451-Sort-Characters-By-Frequency\"><a href=\"#451-Sort-Characters-By-Frequency\" class=\"headerlink\" title=\"451. Sort Characters By Frequency\"></a><a href=\"https://leetcode-cn.com/problems/sort-characters-by-frequency/\">451. Sort Characters By Frequency</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>统计每个字符出现的频率， 按频率排序或者建立堆获取最大值。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p> 击败100</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        int count[258] &#x3D; &#123;0&#125;;\n        int len &#x3D; s.size();\n        for(int i &#x3D; 0; i &lt; len ; ++i)&#123;\n            count[s[i]]++;\n        &#125;\n        priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, less&lt;pair&lt;int, int&gt; &gt; &gt; pq; \n        for(int i &#x3D; 0; i &lt; 258; ++i)&#123;\n            if(count[i] !&#x3D; 0)\n                pq.push( make_pair(count[i], i));\n        &#125;\n        string ans &#x3D; &quot;&quot;;\n        while(pq.size())&#123;\n            pair&lt;int, int&gt; t &#x3D; pq.top(); \n            pq.pop();\n            int time &#x3D; t.first;\n            int ichar &#x3D; t.second;\n            string single(time, (char)ichar);\n            ans +&#x3D;  single;        \n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"12K3YG8","excerpt":"<h2 id=\"451-Sort-Characters-By-Frequency\"><a href=\"#451-Sort-Characters-By-Frequency\" class=\"headerlink\" title=\"451. Sort Characters By Frequency\"></a><a href=\"https://leetcode-cn.com/problems/sort-characters-by-frequency/\">451. Sort Characters By Frequency</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>统计每个字符出现的频率， 按频率排序或者建立堆获取最大值。</p>","more":"<blockquote>\n<p> 击败100</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    string frequencySort(string s) &#123;\n        int count[258] &#x3D; &#123;0&#125;;\n        int len &#x3D; s.size();\n        for(int i &#x3D; 0; i &lt; len ; ++i)&#123;\n            count[s[i]]++;\n        &#125;\n        priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, less&lt;pair&lt;int, int&gt; &gt; &gt; pq; \n        for(int i &#x3D; 0; i &lt; 258; ++i)&#123;\n            if(count[i] !&#x3D; 0)\n                pq.push( make_pair(count[i], i));\n        &#125;\n        string ans &#x3D; &quot;&quot;;\n        while(pq.size())&#123;\n            pair&lt;int, int&gt; t &#x3D; pq.top(); \n            pq.pop();\n            int time &#x3D; t.first;\n            int ichar &#x3D; t.second;\n            string single(time, (char)ichar);\n            ans +&#x3D;  single;        \n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题51:逆序数","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:21:31.000Z","_content":"\n\n\n\n\n这道题目还是比较神奇的。\n\n<!-- more -->\n\n### 题目：\n\n在一个数组中找出所有的逆序数。\n\n逆序数就是指前一个数字大于后一个数组的一对数字。\n\n### 思路：\n\n可以暴力查找，但是复杂度是O(N)O(N)。\n\n想尝试用DP，但是没有明确的子问题分解界线。\n\n最优算法是分治算法。将序列递归的一分为二，直到分割成长度为1的数组。在回朔地合并相邻的两个数组，同时统计序列的逆序数。在回朔的一个合并过程中，两个数组已经保持有序，也就是说数组内部的逆序数都不存在，只统计两个数组间的逆序数。\n\n### 代码：\n\n```\nint InversePairCore(int *A, int *copy, int start, int end){\n    // the the len of array should be looger than 1.\n    // for example, the function will struggle with [0, 1].\n    // becaues start = 0, mid = 0, end = 1. Moreover the situtaion never change.\n    if(start + 1 >= end) return 0;\n    int mid = (end + start) / 2;\n\tint leftCount = InversePairCore(A, copy, start, mid);\n\tint rightCount = InversePairCore(A, copy, mid, end);\n    int midCount = 0;\n    int p1 = mid - 1, p2 = end - 1, p3 = end - 1;\n\twhile(p1 >= start && p2 >= mid){\n        if(A[p1] > A[p2]){\n            copy[p3] = A[p1];\n            p3--;\n            p1--;\n        \t\n           midCount += p2 - mid + 1;\n        } else{\n            copy[p3] = A[p2];\n            p3--;\n            p2--;        \t\n        }        \n    }\n    while(p1 >= start){\n          copy[p3] = A[p1];\n            p3--;\n            p1--;        \n    }\n    while(p2 >= mid){\n            copy[p3] = A[p2];\n            p3--;\n            p2--;        \t        \n    }\n    for(int i = start; i < end; i++) A[i] = copy[i];\n    return rightCount + midCount + leftCount;\n}\n\nint InversePair(int A[], int length){\n    if(A == nullptr || length <= 0) return 0;\n    int *copy = new int(length);\n//    for(int i = 0; i < length; i++) copy[i] = A[i];\n    return InversePairCore(A, copy, 0, length);    \n}\n```\n\n","source":"_posts/刷题/排序\n/面试题51-逆序数.md","raw":"---\ntitle: '面试题51:逆序数'\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:21:31\ntags:\n---\n\n\n\n\n\n这道题目还是比较神奇的。\n\n<!-- more -->\n\n### 题目：\n\n在一个数组中找出所有的逆序数。\n\n逆序数就是指前一个数字大于后一个数组的一对数字。\n\n### 思路：\n\n可以暴力查找，但是复杂度是O(N)O(N)。\n\n想尝试用DP，但是没有明确的子问题分解界线。\n\n最优算法是分治算法。将序列递归的一分为二，直到分割成长度为1的数组。在回朔地合并相邻的两个数组，同时统计序列的逆序数。在回朔的一个合并过程中，两个数组已经保持有序，也就是说数组内部的逆序数都不存在，只统计两个数组间的逆序数。\n\n### 代码：\n\n```\nint InversePairCore(int *A, int *copy, int start, int end){\n    // the the len of array should be looger than 1.\n    // for example, the function will struggle with [0, 1].\n    // becaues start = 0, mid = 0, end = 1. Moreover the situtaion never change.\n    if(start + 1 >= end) return 0;\n    int mid = (end + start) / 2;\n\tint leftCount = InversePairCore(A, copy, start, mid);\n\tint rightCount = InversePairCore(A, copy, mid, end);\n    int midCount = 0;\n    int p1 = mid - 1, p2 = end - 1, p3 = end - 1;\n\twhile(p1 >= start && p2 >= mid){\n        if(A[p1] > A[p2]){\n            copy[p3] = A[p1];\n            p3--;\n            p1--;\n        \t\n           midCount += p2 - mid + 1;\n        } else{\n            copy[p3] = A[p2];\n            p3--;\n            p2--;        \t\n        }        \n    }\n    while(p1 >= start){\n          copy[p3] = A[p1];\n            p3--;\n            p1--;        \n    }\n    while(p2 >= mid){\n            copy[p3] = A[p2];\n            p3--;\n            p2--;        \t        \n    }\n    for(int i = start; i < end; i++) A[i] = copy[i];\n    return rightCount + midCount + leftCount;\n}\n\nint InversePair(int A[], int length){\n    if(A == nullptr || length <= 0) return 0;\n    int *copy = new int(length);\n//    for(int i = 0; i < length; i++) copy[i] = A[i];\n    return InversePairCore(A, copy, 0, length);    \n}\n```\n\n","slug":"刷题-排序-面试题51-逆序数","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5a002ul5uoenh6bazg","content":"<p>这道题目还是比较神奇的。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>在一个数组中找出所有的逆序数。</p>\n<p>逆序数就是指前一个数字大于后一个数组的一对数字。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以暴力查找，但是复杂度是O(N)O(N)。</p>\n<p>想尝试用DP，但是没有明确的子问题分解界线。</p>\n<p>最优算法是分治算法。将序列递归的一分为二，直到分割成长度为1的数组。在回朔地合并相邻的两个数组，同时统计序列的逆序数。在回朔的一个合并过程中，两个数组已经保持有序，也就是说数组内部的逆序数都不存在，只统计两个数组间的逆序数。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int InversePairCore(int *A, int *copy, int start, int end)&#123;\n    &#x2F;&#x2F; the the len of array should be looger than 1.\n    &#x2F;&#x2F; for example, the function will struggle with [0, 1].\n    &#x2F;&#x2F; becaues start &#x3D; 0, mid &#x3D; 0, end &#x3D; 1. Moreover the situtaion never change.\n    if(start + 1 &gt;&#x3D; end) return 0;\n    int mid &#x3D; (end + start) &#x2F; 2;\n\tint leftCount &#x3D; InversePairCore(A, copy, start, mid);\n\tint rightCount &#x3D; InversePairCore(A, copy, mid, end);\n    int midCount &#x3D; 0;\n    int p1 &#x3D; mid - 1, p2 &#x3D; end - 1, p3 &#x3D; end - 1;\n\twhile(p1 &gt;&#x3D; start &amp;&amp; p2 &gt;&#x3D; mid)&#123;\n        if(A[p1] &gt; A[p2])&#123;\n            copy[p3] &#x3D; A[p1];\n            p3--;\n            p1--;\n        \t\n           midCount +&#x3D; p2 - mid + 1;\n        &#125; else&#123;\n            copy[p3] &#x3D; A[p2];\n            p3--;\n            p2--;        \t\n        &#125;        \n    &#125;\n    while(p1 &gt;&#x3D; start)&#123;\n          copy[p3] &#x3D; A[p1];\n            p3--;\n            p1--;        \n    &#125;\n    while(p2 &gt;&#x3D; mid)&#123;\n            copy[p3] &#x3D; A[p2];\n            p3--;\n            p2--;        \t        \n    &#125;\n    for(int i &#x3D; start; i &lt; end; i++) A[i] &#x3D; copy[i];\n    return rightCount + midCount + leftCount;\n&#125;\n\nint InversePair(int A[], int length)&#123;\n    if(A &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0) return 0;\n    int *copy &#x3D; new int(length);\n&#x2F;&#x2F;    for(int i &#x3D; 0; i &lt; length; i++) copy[i] &#x3D; A[i];\n    return InversePairCore(A, copy, 0, length);    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3ZXKV9D","excerpt":"<p>这道题目还是比较神奇的。</p>","more":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>在一个数组中找出所有的逆序数。</p>\n<p>逆序数就是指前一个数字大于后一个数组的一对数字。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以暴力查找，但是复杂度是O(N)O(N)。</p>\n<p>想尝试用DP，但是没有明确的子问题分解界线。</p>\n<p>最优算法是分治算法。将序列递归的一分为二，直到分割成长度为1的数组。在回朔地合并相邻的两个数组，同时统计序列的逆序数。在回朔的一个合并过程中，两个数组已经保持有序，也就是说数组内部的逆序数都不存在，只统计两个数组间的逆序数。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int InversePairCore(int *A, int *copy, int start, int end)&#123;\n    &#x2F;&#x2F; the the len of array should be looger than 1.\n    &#x2F;&#x2F; for example, the function will struggle with [0, 1].\n    &#x2F;&#x2F; becaues start &#x3D; 0, mid &#x3D; 0, end &#x3D; 1. Moreover the situtaion never change.\n    if(start + 1 &gt;&#x3D; end) return 0;\n    int mid &#x3D; (end + start) &#x2F; 2;\n\tint leftCount &#x3D; InversePairCore(A, copy, start, mid);\n\tint rightCount &#x3D; InversePairCore(A, copy, mid, end);\n    int midCount &#x3D; 0;\n    int p1 &#x3D; mid - 1, p2 &#x3D; end - 1, p3 &#x3D; end - 1;\n\twhile(p1 &gt;&#x3D; start &amp;&amp; p2 &gt;&#x3D; mid)&#123;\n        if(A[p1] &gt; A[p2])&#123;\n            copy[p3] &#x3D; A[p1];\n            p3--;\n            p1--;\n        \t\n           midCount +&#x3D; p2 - mid + 1;\n        &#125; else&#123;\n            copy[p3] &#x3D; A[p2];\n            p3--;\n            p2--;        \t\n        &#125;        \n    &#125;\n    while(p1 &gt;&#x3D; start)&#123;\n          copy[p3] &#x3D; A[p1];\n            p3--;\n            p1--;        \n    &#125;\n    while(p2 &gt;&#x3D; mid)&#123;\n            copy[p3] &#x3D; A[p2];\n            p3--;\n            p2--;        \t        \n    &#125;\n    for(int i &#x3D; start; i &lt; end; i++) A[i] &#x3D; copy[i];\n    return rightCount + midCount + leftCount;\n&#125;\n\nint InversePair(int A[], int length)&#123;\n    if(A &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0) return 0;\n    int *copy &#x3D; new int(length);\n&#x2F;&#x2F;    for(int i &#x3D; 0; i &lt; length; i++) copy[i] &#x3D; A[i];\n    return InversePairCore(A, copy, 0, length);    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"168. Excel Sheet Column Title","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-12T03:09:54.000Z","_content":"\n\n\n\n\n## [168. Excel Sheet Column Title](https://leetcode-cn.com/problems/excel-sheet-column-title/)\n\n\n\n\n\n\n\n从进制的根源出发可以更彻底的探究算法的本源。26进制的的10进制数值计算如下：\n$$\ns = 26^3*x_3 + 26^2*x_2+ 26^1*x_1 + 26^0*x_0\n$$\n在该题目条件下，$A-Z$分别代表$1-26$，不符合上述计算公式。一般除数取余法直接除于进制值K，（在本题中$K=26$）即可获取低位$x_i$，但是由于零的缺失，$Z=26$的情况，如下公式，除数取余法失效了。\n\n<!-- more -->\n$$\ns / 26 = 26^2*x_3 + 26^1*x_2+ 26^0*x_1 + 1, if\\ x_0 = 26\n$$\n修改的话，当我们发现当前位是 26 的时候，我们应该在等式两边减去一个 1 。就可以把\n$$\ns - 1 =  26^3*x_3 + 26^2*x_2+ 26^1*x_1 + 26^0*(x_0 -1), if\\ x_0 = 26\n$$\n\n\n这样两边再同时除以 26 的时候，就可以把 x1 去掉了。\n\n这种思路的代码：\n\n```c++\nclass Solution {\npublic:\n    string convertToTitle(int n) {\n        string ans;\n        \n        while(n){\n            int c = n % 26;\n            if(c == 0){ //更深层次\t的说，我们从商借了一个1给余数！\n                c = 26;\n                --n;\n            }\n            ans += c - 1 + 'A';\n            n /=  26;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n\n\n换一种想法，举个🌰有:\n$$\n\\begin{split}\n54  &= 26 * 2 + 2 \\\\\n27  &= 26 * 1 + 1\n\\end{split}\n$$\n54有个位数2，十位数2，分别对应B和B，27有个数为1，十位数1，分别对应A,A。所以有\n\n```c++\nclass Solution {\npublic:\n    string convertToTitle(int n) {\n        string ans;\n        \n        while(n){\n            // 注意这里为什么不是 ans = (n - 1) % 26 + 'A'， 而是让 n--;\n            // 实际上经过取余过后，后续受影响的结果只有 n % 26 == 0的情况\n            // 也就是说 本质上 n-- 也是为了向商了借一个数字\n            n--; \n            ans += n % 26 +  'A';\n            n /=  26;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n感觉好简单粗暴有效啊！","source":"_posts/刷题/数学\n/168-Excel-Sheet-Column-Title.md","raw":"---\ntitle: 168. Excel Sheet Column Title\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-12 11:09:54\n---\n\n\n\n\n\n## [168. Excel Sheet Column Title](https://leetcode-cn.com/problems/excel-sheet-column-title/)\n\n\n\n\n\n\n\n从进制的根源出发可以更彻底的探究算法的本源。26进制的的10进制数值计算如下：\n$$\ns = 26^3*x_3 + 26^2*x_2+ 26^1*x_1 + 26^0*x_0\n$$\n在该题目条件下，$A-Z$分别代表$1-26$，不符合上述计算公式。一般除数取余法直接除于进制值K，（在本题中$K=26$）即可获取低位$x_i$，但是由于零的缺失，$Z=26$的情况，如下公式，除数取余法失效了。\n\n<!-- more -->\n$$\ns / 26 = 26^2*x_3 + 26^1*x_2+ 26^0*x_1 + 1, if\\ x_0 = 26\n$$\n修改的话，当我们发现当前位是 26 的时候，我们应该在等式两边减去一个 1 。就可以把\n$$\ns - 1 =  26^3*x_3 + 26^2*x_2+ 26^1*x_1 + 26^0*(x_0 -1), if\\ x_0 = 26\n$$\n\n\n这样两边再同时除以 26 的时候，就可以把 x1 去掉了。\n\n这种思路的代码：\n\n```c++\nclass Solution {\npublic:\n    string convertToTitle(int n) {\n        string ans;\n        \n        while(n){\n            int c = n % 26;\n            if(c == 0){ //更深层次\t的说，我们从商借了一个1给余数！\n                c = 26;\n                --n;\n            }\n            ans += c - 1 + 'A';\n            n /=  26;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n\n\n换一种想法，举个🌰有:\n$$\n\\begin{split}\n54  &= 26 * 2 + 2 \\\\\n27  &= 26 * 1 + 1\n\\end{split}\n$$\n54有个位数2，十位数2，分别对应B和B，27有个数为1，十位数1，分别对应A,A。所以有\n\n```c++\nclass Solution {\npublic:\n    string convertToTitle(int n) {\n        string ans;\n        \n        while(n){\n            // 注意这里为什么不是 ans = (n - 1) % 26 + 'A'， 而是让 n--;\n            // 实际上经过取余过后，后续受影响的结果只有 n % 26 == 0的情况\n            // 也就是说 本质上 n-- 也是为了向商了借一个数字\n            n--; \n            ans += n % 26 +  'A';\n            n /=  26;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n感觉好简单粗暴有效啊！","slug":"刷题-数学-168-Excel-Sheet-Column-Title","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5b002vl5uo00itfiki","content":"<h2 id=\"168-Excel-Sheet-Column-Title\"><a href=\"#168-Excel-Sheet-Column-Title\" class=\"headerlink\" title=\"168. Excel Sheet Column Title\"></a><a href=\"https://leetcode-cn.com/problems/excel-sheet-column-title/\">168. Excel Sheet Column Title</a></h2><p>从进制的根源出发可以更彻底的探究算法的本源。26进制的的10进制数值计算如下：<br>$$<br>s = 26^3<em>x_3 + 26^2</em>x_2+ 26^1<em>x_1 + 26^0</em>x_0<br>$$<br>在该题目条件下，$A-Z$分别代表$1-26$，不符合上述计算公式。一般除数取余法直接除于进制值K，（在本题中$K=26$）即可获取低位$x_i$，但是由于零的缺失，$Z=26$的情况，如下公式，除数取余法失效了。</p>\n<span id=\"more\"></span>\n<p>$$<br>s / 26 = 26^2<em>x_3 + 26^1</em>x_2+ 26^0<em>x_1 + 1, if\\ x_0 = 26<br>$$<br>修改的话，当我们发现当前位是 26 的时候，我们应该在等式两边减去一个 1 。就可以把<br>$$<br>s - 1 =  26^3</em>x_3 + 26^2<em>x_2+ 26^1</em>x_1 + 26^0*(x_0 -1), if\\ x_0 = 26<br>$$</p>\n<p>这样两边再同时除以 26 的时候，就可以把 x1 去掉了。</p>\n<p>这种思路的代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convertToTitle(int n) &#123;\n        string ans;\n        \n        while(n)&#123;\n            int c &#x3D; n % 26;\n            if(c &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;更深层次\t的说，我们从商借了一个1给余数！\n                c &#x3D; 26;\n                --n;\n            &#125;\n            ans +&#x3D; c - 1 + &#39;A&#39;;\n            n &#x2F;&#x3D;  26;\n        &#125;\n        reverse(ans.begin(), ans.end());\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>换一种想法，举个🌰有:<br>$$<br>\\begin{split}<br>54  &amp;= 26 * 2 + 2 \\<br>27  &amp;= 26 * 1 + 1<br>\\end{split}<br>$$<br>54有个位数2，十位数2，分别对应B和B，27有个数为1，十位数1，分别对应A,A。所以有</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convertToTitle(int n) &#123;\n        string ans;\n        \n        while(n)&#123;\n            &#x2F;&#x2F; 注意这里为什么不是 ans &#x3D; (n - 1) % 26 + &#39;A&#39;， 而是让 n--;\n            &#x2F;&#x2F; 实际上经过取余过后，后续受影响的结果只有 n % 26 &#x3D;&#x3D; 0的情况\n            &#x2F;&#x2F; 也就是说 本质上 n-- 也是为了向商了借一个数字\n            n--; \n            ans +&#x3D; n % 26 +  &#39;A&#39;;\n            n &#x2F;&#x3D;  26;\n        &#125;\n        reverse(ans.begin(), ans.end());\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>感觉好简单粗暴有效啊！</p>\n","site":{"data":{}},"abbrlink":"TNPEGP","excerpt":"<h2 id=\"168-Excel-Sheet-Column-Title\"><a href=\"#168-Excel-Sheet-Column-Title\" class=\"headerlink\" title=\"168. Excel Sheet Column Title\"></a><a href=\"https://leetcode-cn.com/problems/excel-sheet-column-title/\">168. Excel Sheet Column Title</a></h2><p>从进制的根源出发可以更彻底的探究算法的本源。26进制的的10进制数值计算如下：<br>$$<br>s = 26^3<em>x_3 + 26^2</em>x_2+ 26^1<em>x_1 + 26^0</em>x_0<br>$$<br>在该题目条件下，$A-Z$分别代表$1-26$，不符合上述计算公式。一般除数取余法直接除于进制值K，（在本题中$K=26$）即可获取低位$x_i$，但是由于零的缺失，$Z=26$的情况，如下公式，除数取余法失效了。</p>","more":"<p>$$<br>s / 26 = 26^2<em>x_3 + 26^1</em>x_2+ 26^0<em>x_1 + 1, if\\ x_0 = 26<br>$$<br>修改的话，当我们发现当前位是 26 的时候，我们应该在等式两边减去一个 1 。就可以把<br>$$<br>s - 1 =  26^3</em>x_3 + 26^2<em>x_2+ 26^1</em>x_1 + 26^0*(x_0 -1), if\\ x_0 = 26<br>$$</p>\n<p>这样两边再同时除以 26 的时候，就可以把 x1 去掉了。</p>\n<p>这种思路的代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convertToTitle(int n) &#123;\n        string ans;\n        \n        while(n)&#123;\n            int c &#x3D; n % 26;\n            if(c &#x3D;&#x3D; 0)&#123; &#x2F;&#x2F;更深层次\t的说，我们从商借了一个1给余数！\n                c &#x3D; 26;\n                --n;\n            &#125;\n            ans +&#x3D; c - 1 + &#39;A&#39;;\n            n &#x2F;&#x3D;  26;\n        &#125;\n        reverse(ans.begin(), ans.end());\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>换一种想法，举个🌰有:<br>$$<br>\\begin{split}<br>54  &amp;= 26 * 2 + 2 \\<br>27  &amp;= 26 * 1 + 1<br>\\end{split}<br>$$<br>54有个位数2，十位数2，分别对应B和B，27有个数为1，十位数1，分别对应A,A。所以有</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convertToTitle(int n) &#123;\n        string ans;\n        \n        while(n)&#123;\n            &#x2F;&#x2F; 注意这里为什么不是 ans &#x3D; (n - 1) % 26 + &#39;A&#39;， 而是让 n--;\n            &#x2F;&#x2F; 实际上经过取余过后，后续受影响的结果只有 n % 26 &#x3D;&#x3D; 0的情况\n            &#x2F;&#x2F; 也就是说 本质上 n-- 也是为了向商了借一个数字\n            n--; \n            ans +&#x3D; n % 26 +  &#39;A&#39;;\n            n &#x2F;&#x3D;  26;\n        &#125;\n        reverse(ans.begin(), ans.end());\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>感觉好简单粗暴有效啊！</p>"},{"title":"169. Majority Element","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-15T01:20:03.000Z","_content":"\n\n\n\n\n## [169. Majority Element](https://leetcode-cn.com/problems/majority-element/)\n\n\n\n## 思路：\n\n\n\n#### Boyer-Moore 投票算法\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        if(nums.size() == 0) return -1;\n        int a = nums[0];\n        int ct = 0;\n        for(auto k : nums){\n            if(k == a){\n                ++ct;\n            }else if(ct > 0){\n                --ct;\n            }else{\n                a = k;\n                ++ct;\n            }\n        }\n       return a;\n       \n    }\n};\n```\n\n\n\n稍微简洁一点\n\n```c++\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        if(nums.size() == 0) return -1;\n        int a = nums[0];\n        int ct = 0;\n        for(auto k : nums){\n            if(ct == 0){\n                a = k;\n            }\n            ct += k == a ? 1 : -1;\n        }\n        return a;\n       \n    }\n};\n```","source":"_posts/刷题/数学\n/169-Majority-Element.md","raw":"---\ntitle: 169. Majority Element\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-15 09:20:03\n---\n\n\n\n\n\n## [169. Majority Element](https://leetcode-cn.com/problems/majority-element/)\n\n\n\n## 思路：\n\n\n\n#### Boyer-Moore 投票算法\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        if(nums.size() == 0) return -1;\n        int a = nums[0];\n        int ct = 0;\n        for(auto k : nums){\n            if(k == a){\n                ++ct;\n            }else if(ct > 0){\n                --ct;\n            }else{\n                a = k;\n                ++ct;\n            }\n        }\n       return a;\n       \n    }\n};\n```\n\n\n\n稍微简洁一点\n\n```c++\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        if(nums.size() == 0) return -1;\n        int a = nums[0];\n        int ct = 0;\n        for(auto k : nums){\n            if(ct == 0){\n                a = k;\n            }\n            ct += k == a ? 1 : -1;\n        }\n        return a;\n       \n    }\n};\n```","slug":"刷题-数学-169-Majority-Element","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5c002wl5uoas9ab7g2","content":"<h2 id=\"169-Majority-Element\"><a href=\"#169-Majority-Element\" class=\"headerlink\" title=\"169. Majority Element\"></a><a href=\"https://leetcode-cn.com/problems/majority-element/\">169. Majority Element</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><h4 id=\"Boyer-Moore-投票算法\"><a href=\"#Boyer-Moore-投票算法\" class=\"headerlink\" title=\"Boyer-Moore 投票算法\"></a>Boyer-Moore 投票算法</h4><span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int a &#x3D; nums[0];\n        int ct &#x3D; 0;\n        for(auto k : nums)&#123;\n            if(k &#x3D;&#x3D; a)&#123;\n                ++ct;\n            &#125;else if(ct &gt; 0)&#123;\n                --ct;\n            &#125;else&#123;\n                a &#x3D; k;\n                ++ct;\n            &#125;\n        &#125;\n       return a;\n       \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>稍微简洁一点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int a &#x3D; nums[0];\n        int ct &#x3D; 0;\n        for(auto k : nums)&#123;\n            if(ct &#x3D;&#x3D; 0)&#123;\n                a &#x3D; k;\n            &#125;\n            ct +&#x3D; k &#x3D;&#x3D; a ? 1 : -1;\n        &#125;\n        return a;\n       \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3Y964GW","excerpt":"<h2 id=\"169-Majority-Element\"><a href=\"#169-Majority-Element\" class=\"headerlink\" title=\"169. Majority Element\"></a><a href=\"https://leetcode-cn.com/problems/majority-element/\">169. Majority Element</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><h4 id=\"Boyer-Moore-投票算法\"><a href=\"#Boyer-Moore-投票算法\" class=\"headerlink\" title=\"Boyer-Moore 投票算法\"></a>Boyer-Moore 投票算法</h4>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int a &#x3D; nums[0];\n        int ct &#x3D; 0;\n        for(auto k : nums)&#123;\n            if(k &#x3D;&#x3D; a)&#123;\n                ++ct;\n            &#125;else if(ct &gt; 0)&#123;\n                --ct;\n            &#125;else&#123;\n                a &#x3D; k;\n                ++ct;\n            &#125;\n        &#125;\n       return a;\n       \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>稍微简洁一点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int a &#x3D; nums[0];\n        int ct &#x3D; 0;\n        for(auto k : nums)&#123;\n            if(ct &#x3D;&#x3D; 0)&#123;\n                a &#x3D; k;\n            &#125;\n            ct +&#x3D; k &#x3D;&#x3D; a ? 1 : -1;\n        &#125;\n        return a;\n       \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"172. Factorial Trailing Zeroes","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-07T03:36:19.000Z","_content":"\n\n\n\n\n\n\n## 思路：\n\n通过判断1 ~n所有数字因子5的个数判断尾零的数量。快速判断方法是：整除 5， 25， 125等等5的倍数的数字其商就是5的倍数的因子数量。\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int trailingZeroes(int n) {\n        int res = 0;\n        while(n){\n            n /= 5;\n            res += n;\n            \n        }\n        return res;\n    }\n};\n```\n\n","source":"_posts/刷题/数学\n/172-Factorial-Trailing-Zeroes.md","raw":"---\ntitle: 172. Factorial Trailing Zeroes\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-07 11:36:19\n---\n\n\n\n\n\n\n\n## 思路：\n\n通过判断1 ~n所有数字因子5的个数判断尾零的数量。快速判断方法是：整除 5， 25， 125等等5的倍数的数字其商就是5的倍数的因子数量。\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    int trailingZeroes(int n) {\n        int res = 0;\n        while(n){\n            n /= 5;\n            res += n;\n            \n        }\n        return res;\n    }\n};\n```\n\n","slug":"刷题-数学-172-Factorial-Trailing-Zeroes","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5c002xl5uo8vx42j6i","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>通过判断1 ~n所有数字因子5的个数判断尾零的数量。快速判断方法是：整除 5， 25， 125等等5的倍数的数字其商就是5的倍数的因子数量。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int trailingZeroes(int n) &#123;\n        int res &#x3D; 0;\n        while(n)&#123;\n            n &#x2F;&#x3D; 5;\n            res +&#x3D; n;\n            \n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1TWM2W6","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>通过判断1 ~n所有数字因子5的个数判断尾零的数量。快速判断方法是：整除 5， 25， 125等等5的倍数的数字其商就是5的倍数的因子数量。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int trailingZeroes(int n) &#123;\n        int res &#x3D; 0;\n        while(n)&#123;\n            n &#x2F;&#x3D; 5;\n            res +&#x3D; n;\n            \n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"202. Happy Number","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-15T01:18:59.000Z","_content":"\n\n\n## [202. Happy Number](https://leetcode-cn.com/problems/happy-number/)\n\n## 思路：\n\n1. set查重复数字作为重复数字的抽取方法，循环遍历\n2. 假设该步骤总会找到一个数字环，快慢指针法可以类比到该算法。值得注意的，最后happy number最后形成是的数字`1`的自环，必定停留在`1`上。而非 happy number最后形成的环一定没有1。\n3. <!-- more -->\n\n![fig1](http://static.come2rss.xyz/202_fig1.png)\n\n\n\n![fig2](http://static.come2rss.xyz/202_fig2.png)\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    bool isHappy(int n) {\n        unordered_set<int> nums; //hashset更快\n        while(n != 1 && nums.count(n) == 0){\n            int newn = n,sum = 0;\n            while(newn){\n                sum += (newn % 10 ) * ( newn % 10 );\n                newn /= 10;\n            }\n            nums.insert(n);\n            n = sum;\n        }\n        if(n == 1) return true;\n        else return false;\n\n    }\n};\n```\n\n\n\n\n\n快慢指针法\n\n```c++\nclass Solution {\npublic:\n    int next(int n){\n        int newn = n,sum = 0;\n        while(newn){\n            sum += (newn % 10 ) * ( newn % 10 );\n            newn /= 10;\n        }\n        return sum;    \n    }\n    bool isHappy(int n) {\n        int p1 = next(n);\n        int p2 = next(next(n));\n        while(p1 != p2){\n            p1 = next(p1);\n            p2 = next(next(p2));\n        }\n        if(p1 == 1) return true;\n        else return false;\n\n    }\n};\n```","source":"_posts/刷题/数学\n/202-Happy-Number.md","raw":"---\ntitle: 202. Happy Number\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-15 09:18:59\n---\n\n\n\n## [202. Happy Number](https://leetcode-cn.com/problems/happy-number/)\n\n## 思路：\n\n1. set查重复数字作为重复数字的抽取方法，循环遍历\n2. 假设该步骤总会找到一个数字环，快慢指针法可以类比到该算法。值得注意的，最后happy number最后形成是的数字`1`的自环，必定停留在`1`上。而非 happy number最后形成的环一定没有1。\n3. <!-- more -->\n\n![fig1](http://static.come2rss.xyz/202_fig1.png)\n\n\n\n![fig2](http://static.come2rss.xyz/202_fig2.png)\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    bool isHappy(int n) {\n        unordered_set<int> nums; //hashset更快\n        while(n != 1 && nums.count(n) == 0){\n            int newn = n,sum = 0;\n            while(newn){\n                sum += (newn % 10 ) * ( newn % 10 );\n                newn /= 10;\n            }\n            nums.insert(n);\n            n = sum;\n        }\n        if(n == 1) return true;\n        else return false;\n\n    }\n};\n```\n\n\n\n\n\n快慢指针法\n\n```c++\nclass Solution {\npublic:\n    int next(int n){\n        int newn = n,sum = 0;\n        while(newn){\n            sum += (newn % 10 ) * ( newn % 10 );\n            newn /= 10;\n        }\n        return sum;    \n    }\n    bool isHappy(int n) {\n        int p1 = next(n);\n        int p2 = next(next(n));\n        while(p1 != p2){\n            p1 = next(p1);\n            p2 = next(next(p2));\n        }\n        if(p1 == 1) return true;\n        else return false;\n\n    }\n};\n```","slug":"刷题-数学-202-Happy-Number","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5d002yl5uohklebbmb","content":"<h2 id=\"202-Happy-Number\"><a href=\"#202-Happy-Number\" class=\"headerlink\" title=\"202. Happy Number\"></a><a href=\"https://leetcode-cn.com/problems/happy-number/\">202. Happy Number</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>set查重复数字作为重复数字的抽取方法，循环遍历</li>\n<li>假设该步骤总会找到一个数字环，快慢指针法可以类比到该算法。值得注意的，最后happy number最后形成是的数字<code>1</code>的自环，必定停留在<code>1</code>上。而非 happy number最后形成的环一定没有1。</li>\n<li><span id=\"more\"></span>\n\n</li>\n</ol>\n<p><img src=\"http://static.come2rss.xyz/202_fig1.png\" alt=\"fig1\"></p>\n<p><img src=\"http://static.come2rss.xyz/202_fig2.png\" alt=\"fig2\"></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isHappy(int n) &#123;\n        unordered_set&lt;int&gt; nums; &#x2F;&#x2F;hashset更快\n        while(n !&#x3D; 1 &amp;&amp; nums.count(n) &#x3D;&#x3D; 0)&#123;\n            int newn &#x3D; n,sum &#x3D; 0;\n            while(newn)&#123;\n                sum +&#x3D; (newn % 10 ) * ( newn % 10 );\n                newn &#x2F;&#x3D; 10;\n            &#125;\n            nums.insert(n);\n            n &#x3D; sum;\n        &#125;\n        if(n &#x3D;&#x3D; 1) return true;\n        else return false;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>快慢指针法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int next(int n)&#123;\n        int newn &#x3D; n,sum &#x3D; 0;\n        while(newn)&#123;\n            sum +&#x3D; (newn % 10 ) * ( newn % 10 );\n            newn &#x2F;&#x3D; 10;\n        &#125;\n        return sum;    \n    &#125;\n    bool isHappy(int n) &#123;\n        int p1 &#x3D; next(n);\n        int p2 &#x3D; next(next(n));\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; next(p1);\n            p2 &#x3D; next(next(p2));\n        &#125;\n        if(p1 &#x3D;&#x3D; 1) return true;\n        else return false;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3WHMFXE","excerpt":"<h2 id=\"202-Happy-Number\"><a href=\"#202-Happy-Number\" class=\"headerlink\" title=\"202. Happy Number\"></a><a href=\"https://leetcode-cn.com/problems/happy-number/\">202. Happy Number</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>set查重复数字作为重复数字的抽取方法，循环遍历</li>\n<li>假设该步骤总会找到一个数字环，快慢指针法可以类比到该算法。值得注意的，最后happy number最后形成是的数字<code>1</code>的自环，必定停留在<code>1</code>上。而非 happy number最后形成的环一定没有1。</li>\n<li>","more":"</li>\n</ol>\n<p><img src=\"http://static.come2rss.xyz/202_fig1.png\" alt=\"fig1\"></p>\n<p><img src=\"http://static.come2rss.xyz/202_fig2.png\" alt=\"fig2\"></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isHappy(int n) &#123;\n        unordered_set&lt;int&gt; nums; &#x2F;&#x2F;hashset更快\n        while(n !&#x3D; 1 &amp;&amp; nums.count(n) &#x3D;&#x3D; 0)&#123;\n            int newn &#x3D; n,sum &#x3D; 0;\n            while(newn)&#123;\n                sum +&#x3D; (newn % 10 ) * ( newn % 10 );\n                newn &#x2F;&#x3D; 10;\n            &#125;\n            nums.insert(n);\n            n &#x3D; sum;\n        &#125;\n        if(n &#x3D;&#x3D; 1) return true;\n        else return false;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>快慢指针法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int next(int n)&#123;\n        int newn &#x3D; n,sum &#x3D; 0;\n        while(newn)&#123;\n            sum +&#x3D; (newn % 10 ) * ( newn % 10 );\n            newn &#x2F;&#x3D; 10;\n        &#125;\n        return sum;    \n    &#125;\n    bool isHappy(int n) &#123;\n        int p1 &#x3D; next(n);\n        int p2 &#x3D; next(next(n));\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; next(p1);\n            p2 &#x3D; next(next(p2));\n        &#125;\n        if(p1 &#x3D;&#x3D; 1) return true;\n        else return false;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"204. Count Primes","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-07T03:06:15.000Z","_content":"\n\n\n\n## [204. Count Primes](https://leetcode-cn.com/problems/count-primes/)\n\n## 思路：\n\n1. 埃氏筛 $O(nloglogn)$\n2. 线性筛$O(nlogn)$，不过由于取模的运算量太大，速度可能还不如埃氏筛\n\n<!-- more -->\n\n## 代码：\n\n埃氏筛\n\n```c++\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n <= 1) return 0;\n        vector<int> prime(n + 10);\n        int idx = 0;        \n        for(int i = 2; i < n; ++i){\n            if(prime[i] == 0){\n                prime[idx++] = i;\n                if(sqrt(INT_MAX) > i)\n                for(int j = i * i; j <= n; j += i)\n                    prime[j] = 1;\n            }\n        }\n        return idx;\n    }\n};\n```\n\n线性筛\n\n```c++\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n <= 1) return 0;\n        vector<int> prime(n + 10);\n        int idx = 0;        \n        for(int i = 2; i < n; ++i){\n            if(prime[i] == 0)\n                prime[idx++] = i;\n\n            for(int j = 0; j < idx && prime[j] * i < n; ++j){\n                prime[prime[j] * i] = 1;\n                if(i % prime[j] == 0) break;\n            }\n            \n        }\n        return idx;\n    }\n};\n```\n\n","source":"_posts/刷题/数学\n/204-Count-Primes.md","raw":"---\ntitle: 204. Count Primes\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-07 11:06:15\n---\n\n\n\n\n## [204. Count Primes](https://leetcode-cn.com/problems/count-primes/)\n\n## 思路：\n\n1. 埃氏筛 $O(nloglogn)$\n2. 线性筛$O(nlogn)$，不过由于取模的运算量太大，速度可能还不如埃氏筛\n\n<!-- more -->\n\n## 代码：\n\n埃氏筛\n\n```c++\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n <= 1) return 0;\n        vector<int> prime(n + 10);\n        int idx = 0;        \n        for(int i = 2; i < n; ++i){\n            if(prime[i] == 0){\n                prime[idx++] = i;\n                if(sqrt(INT_MAX) > i)\n                for(int j = i * i; j <= n; j += i)\n                    prime[j] = 1;\n            }\n        }\n        return idx;\n    }\n};\n```\n\n线性筛\n\n```c++\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if(n <= 1) return 0;\n        vector<int> prime(n + 10);\n        int idx = 0;        \n        for(int i = 2; i < n; ++i){\n            if(prime[i] == 0)\n                prime[idx++] = i;\n\n            for(int j = 0; j < idx && prime[j] * i < n; ++j){\n                prime[prime[j] * i] = 1;\n                if(i % prime[j] == 0) break;\n            }\n            \n        }\n        return idx;\n    }\n};\n```\n\n","slug":"刷题-数学-204-Count-Primes","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5d002zl5uo3bfeg4xw","content":"<h2 id=\"204-Count-Primes\"><a href=\"#204-Count-Primes\" class=\"headerlink\" title=\"204. Count Primes\"></a><a href=\"https://leetcode-cn.com/problems/count-primes/\">204. Count Primes</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>埃氏筛 $O(nloglogn)$</li>\n<li>线性筛$O(nlogn)$，不过由于取模的运算量太大，速度可能还不如埃氏筛</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>埃氏筛</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countPrimes(int n) &#123;\n        if(n &lt;&#x3D; 1) return 0;\n        vector&lt;int&gt; prime(n + 10);\n        int idx &#x3D; 0;        \n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(prime[i] &#x3D;&#x3D; 0)&#123;\n                prime[idx++] &#x3D; i;\n                if(sqrt(INT_MAX) &gt; i)\n                for(int j &#x3D; i * i; j &lt;&#x3D; n; j +&#x3D; i)\n                    prime[j] &#x3D; 1;\n            &#125;\n        &#125;\n        return idx;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线性筛</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countPrimes(int n) &#123;\n        if(n &lt;&#x3D; 1) return 0;\n        vector&lt;int&gt; prime(n + 10);\n        int idx &#x3D; 0;        \n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(prime[i] &#x3D;&#x3D; 0)\n                prime[idx++] &#x3D; i;\n\n            for(int j &#x3D; 0; j &lt; idx &amp;&amp; prime[j] * i &lt; n; ++j)&#123;\n                prime[prime[j] * i] &#x3D; 1;\n                if(i % prime[j] &#x3D;&#x3D; 0) break;\n            &#125;\n            \n        &#125;\n        return idx;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2CYYZ15","excerpt":"<h2 id=\"204-Count-Primes\"><a href=\"#204-Count-Primes\" class=\"headerlink\" title=\"204. Count Primes\"></a><a href=\"https://leetcode-cn.com/problems/count-primes/\">204. Count Primes</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>埃氏筛 $O(nloglogn)$</li>\n<li>线性筛$O(nlogn)$，不过由于取模的运算量太大，速度可能还不如埃氏筛</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>埃氏筛</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countPrimes(int n) &#123;\n        if(n &lt;&#x3D; 1) return 0;\n        vector&lt;int&gt; prime(n + 10);\n        int idx &#x3D; 0;        \n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(prime[i] &#x3D;&#x3D; 0)&#123;\n                prime[idx++] &#x3D; i;\n                if(sqrt(INT_MAX) &gt; i)\n                for(int j &#x3D; i * i; j &lt;&#x3D; n; j +&#x3D; i)\n                    prime[j] &#x3D; 1;\n            &#125;\n        &#125;\n        return idx;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>线性筛</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countPrimes(int n) &#123;\n        if(n &lt;&#x3D; 1) return 0;\n        vector&lt;int&gt; prime(n + 10);\n        int idx &#x3D; 0;        \n        for(int i &#x3D; 2; i &lt; n; ++i)&#123;\n            if(prime[i] &#x3D;&#x3D; 0)\n                prime[idx++] &#x3D; i;\n\n            for(int j &#x3D; 0; j &lt; idx &amp;&amp; prime[j] * i &lt; n; ++j)&#123;\n                prime[prime[j] * i] &#x3D; 1;\n                if(i % prime[j] &#x3D;&#x3D; 0) break;\n            &#125;\n            \n        &#125;\n        return idx;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"238. Product of Array Except Self","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-12T03:10:16.000Z","_content":"\n\n\n## [238. Product of Array Except Self](https://leetcode-cn.com/problems/product-of-array-except-self/)\n\n\n\n## 思路：\n\nfollow up 要求空间为$O(n)$，如果输输出数组不算空间的话，可以这是可以达到的。\n\n<!-- more -->\n\n## 代码：\n\n```c+\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        getProduct(0, 1, nums);\n        return nums;\n    }\n\n    using ll = long long;\n    ll getProduct(int i, ll lprod, vector<int> &nums){        \n        if(i == nums.size()) return 1;\n        ll nprod = lprod * nums[i];\n        ll rprod = getProduct(i + 1, nprod, nums);\n        int val = nums[i];\n        nums[i] = lprod * rprod;\n        return val * rprod;\n    }\n};\n```","source":"_posts/刷题/数学\n/238-Product-of-Array-Except-Self.md","raw":"---\ntitle: 238. Product of Array Except Self\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-12 11:10:16\n---\n\n\n\n## [238. Product of Array Except Self](https://leetcode-cn.com/problems/product-of-array-except-self/)\n\n\n\n## 思路：\n\nfollow up 要求空间为$O(n)$，如果输输出数组不算空间的话，可以这是可以达到的。\n\n<!-- more -->\n\n## 代码：\n\n```c+\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        getProduct(0, 1, nums);\n        return nums;\n    }\n\n    using ll = long long;\n    ll getProduct(int i, ll lprod, vector<int> &nums){        \n        if(i == nums.size()) return 1;\n        ll nprod = lprod * nums[i];\n        ll rprod = getProduct(i + 1, nprod, nums);\n        int val = nums[i];\n        nums[i] = lprod * rprod;\n        return val * rprod;\n    }\n};\n```","slug":"刷题-数学-238-Product-of-Array-Except-Self","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5e0030l5uo0mv09kjj","content":"<h2 id=\"238-Product-of-Array-Except-Self\"><a href=\"#238-Product-of-Array-Except-Self\" class=\"headerlink\" title=\"238. Product of Array Except Self\"></a><a href=\"https://leetcode-cn.com/problems/product-of-array-except-self/\">238. Product of Array Except Self</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>follow up 要求空间为$O(n)$，如果输输出数组不算空间的话，可以这是可以达到的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c+\" data-language=\"c+\"><code class=\"language-c+\">class Solution &#123;\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;\n        getProduct(0, 1, nums);\n        return nums;\n    &#125;\n\n    using ll &#x3D; long long;\n    ll getProduct(int i, ll lprod, vector&lt;int&gt; &amp;nums)&#123;        \n        if(i &#x3D;&#x3D; nums.size()) return 1;\n        ll nprod &#x3D; lprod * nums[i];\n        ll rprod &#x3D; getProduct(i + 1, nprod, nums);\n        int val &#x3D; nums[i];\n        nums[i] &#x3D; lprod * rprod;\n        return val * rprod;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"25TNVWD","excerpt":"<h2 id=\"238-Product-of-Array-Except-Self\"><a href=\"#238-Product-of-Array-Except-Self\" class=\"headerlink\" title=\"238. Product of Array Except Self\"></a><a href=\"https://leetcode-cn.com/problems/product-of-array-except-self/\">238. Product of Array Except Self</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>follow up 要求空间为$O(n)$，如果输输出数组不算空间的话，可以这是可以达到的。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c+\" data-language=\"c+\"><code class=\"language-c+\">class Solution &#123;\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;\n        getProduct(0, 1, nums);\n        return nums;\n    &#125;\n\n    using ll &#x3D; long long;\n    ll getProduct(int i, ll lprod, vector&lt;int&gt; &amp;nums)&#123;        \n        if(i &#x3D;&#x3D; nums.size()) return 1;\n        ll nprod &#x3D; lprod * nums[i];\n        ll rprod &#x3D; getProduct(i + 1, nprod, nums);\n        int val &#x3D; nums[i];\n        nums[i] &#x3D; lprod * rprod;\n        return val * rprod;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"313. Super Ugly Number","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-05T12:38:02.000Z","_content":"\n\n\n\n# [313. Super Ugly Number](https://leetcode-cn.com/problems/super-ugly-number/)\n\n\n\n\n\n## 思路\n\n丑数的每个前身都是丑数，丑上加丑。<!-- more -->\n\n\n\n## 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2;\n        int p1 = 0, p2 = 0;\n        do{\n            p1 = nums[nums[p1]];\n            p2 = nums[p2];\n        }while(p1 != p2);\n        p2 = 0;\n        while(p1 != p2){\n            p1 = nums[p1];\n            p2 = nums[p2];\n        }\n      return p1; // p1才是重复的数字/idx\n    }\n};\n```\n\n\n\n","source":"_posts/刷题/数学\n/313-Super-Ugly-Number.md","raw":"---\ntitle: 313. Super Ugly Number\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-05 20:38:02\ntags:\ncategories:\n---\n\n\n\n\n# [313. Super Ugly Number](https://leetcode-cn.com/problems/super-ugly-number/)\n\n\n\n\n\n## 思路\n\n丑数的每个前身都是丑数，丑上加丑。<!-- more -->\n\n\n\n## 代码\n\n\n\n```c++\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2;\n        int p1 = 0, p2 = 0;\n        do{\n            p1 = nums[nums[p1]];\n            p2 = nums[p2];\n        }while(p1 != p2);\n        p2 = 0;\n        while(p1 != p2){\n            p1 = nums[p1];\n            p2 = nums[p2];\n        }\n      return p1; // p1才是重复的数字/idx\n    }\n};\n```\n\n\n\n","slug":"刷题-数学-313-Super-Ugly-Number","published":1,"updated":"2021-02-05T12:39:15.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5f0031l5uofk3j34k2","content":"<h1 id=\"313-Super-Ugly-Number\"><a href=\"#313-Super-Ugly-Number\" class=\"headerlink\" title=\"313. Super Ugly Number\"></a><a href=\"https://leetcode-cn.com/problems/super-ugly-number/\">313. Super Ugly Number</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>丑数的每个前身都是丑数，丑上加丑。<span id=\"more\"></span></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() &#x2F; 2;\n        int p1 &#x3D; 0, p2 &#x3D; 0;\n        do&#123;\n            p1 &#x3D; nums[nums[p1]];\n            p2 &#x3D; nums[p2];\n        &#125;while(p1 !&#x3D; p2);\n        p2 &#x3D; 0;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; nums[p1];\n            p2 &#x3D; nums[p2];\n        &#125;\n      return p1; &#x2F;&#x2F; p1才是重复的数字&#x2F;idx\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","site":{"data":{}},"abbrlink":"3JK7THT","excerpt":"<h1 id=\"313-Super-Ugly-Number\"><a href=\"#313-Super-Ugly-Number\" class=\"headerlink\" title=\"313. Super Ugly Number\"></a><a href=\"https://leetcode-cn.com/problems/super-ugly-number/\">313. Super Ugly Number</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>丑数的每个前身都是丑数，丑上加丑。","more":"</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;\n        &#x2F;&#x2F; return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() &#x2F; 2;\n        int p1 &#x3D; 0, p2 &#x3D; 0;\n        do&#123;\n            p1 &#x3D; nums[nums[p1]];\n            p2 &#x3D; nums[p2];\n        &#125;while(p1 !&#x3D; p2);\n        p2 &#x3D; 0;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; nums[p1];\n            p2 &#x3D; nums[p2];\n        &#125;\n      return p1; &#x2F;&#x2F; p1才是重复的数字&#x2F;idx\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"382. Linked List Random Node","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-10T02:05:02.000Z","_content":"\n\n\n\n## [382. Linked List Random Node](https://leetcode-cn.com/problems/linked-list-random-node/)\n\n\n\n## 思路：\n\n让我想起来之前来宁大讲座的美国教授的出的抽取车流题目。\n\n我们可以使用蓄水池抽样算法（Reservoir Sampling）:\n\n考虑抽取一个样例的情况：我们从头遍历一个List，并以$1/k$的概率把第k个元素保留下来。\n\n可以由归纳法得：\n\n第k-1个元素的保留概率是$1/(k - 1)$，在第K个元素遍历时，第K-1次遍历是被保留的元素在这次被保留的概率是$\\frac{1}{k-1} * \\frac{k - 1}{k}= \\frac{1}{k}$ 。\n\n这就保证了遍历一遍全部数组后，各个元素被抽取的等概率性质。\n\n<!-- more -->\n\n再考虑k>1的情况，证明更复杂一点：\n\n![1.png](http://static.come2rss.xyz/831bdf1ea840c47b79007f206fb9fe6f1a1effb6c5ceed15509fe0abb23ed2f9.jpg)\n\n\n\n实现代码：\n\n```c++\n\nimport java.util.Random;\n\nClass Solution{\n    public static void main(String[] args){\n        int[] nums = new int[]{1, 2, 3, 4, 5};\n        Solution s = new Solution();\n        int[] ans = s.sample(nums, 3);\n        for(int i = 0; i < ans.length; i++){\n            System.out.printf(\"%d \", ans[i]);\n        }\n    }\n    private int[] sample(int[] nums, int n){\n        Random rd = new Random();\n        int[] ans = new int[n];\n        for(int i = 0; i < nums.length; i++){\n            if(i < n){\n                ans[i] = nums[i];\n            } else {\n                if(rd.nextInt(i+1) < n){\n                    ans[rd.nextInt(n)] = nums[i];\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n\n\n## 代码\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode* head;\n    int ct = 0;\npublic:\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    Solution(ListNode* _head): head(_head) {\n        // newp = p = head;\n    }\n    \n    /** Returns a random node's value. */\n    int getRandom() {  //蓄水池随机抽取算法\n        ListNode *p = head, *newp = head;\n        int ct = 0;\n        while(newp){\n            ++ct;\n            if(rand() % ct == 0){\n                p = newp;\n            }\n            newp = newp->next;\n        }   \n        return p->val;\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(head);\n * int param_1 = obj->getRandom();\n */\n```","source":"_posts/刷题/数学\n/382-Linked-List-Random-Node.md","raw":"---\ntitle: 382. Linked List Random Node\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-10 10:05:02\n---\n\n\n\n\n## [382. Linked List Random Node](https://leetcode-cn.com/problems/linked-list-random-node/)\n\n\n\n## 思路：\n\n让我想起来之前来宁大讲座的美国教授的出的抽取车流题目。\n\n我们可以使用蓄水池抽样算法（Reservoir Sampling）:\n\n考虑抽取一个样例的情况：我们从头遍历一个List，并以$1/k$的概率把第k个元素保留下来。\n\n可以由归纳法得：\n\n第k-1个元素的保留概率是$1/(k - 1)$，在第K个元素遍历时，第K-1次遍历是被保留的元素在这次被保留的概率是$\\frac{1}{k-1} * \\frac{k - 1}{k}= \\frac{1}{k}$ 。\n\n这就保证了遍历一遍全部数组后，各个元素被抽取的等概率性质。\n\n<!-- more -->\n\n再考虑k>1的情况，证明更复杂一点：\n\n![1.png](http://static.come2rss.xyz/831bdf1ea840c47b79007f206fb9fe6f1a1effb6c5ceed15509fe0abb23ed2f9.jpg)\n\n\n\n实现代码：\n\n```c++\n\nimport java.util.Random;\n\nClass Solution{\n    public static void main(String[] args){\n        int[] nums = new int[]{1, 2, 3, 4, 5};\n        Solution s = new Solution();\n        int[] ans = s.sample(nums, 3);\n        for(int i = 0; i < ans.length; i++){\n            System.out.printf(\"%d \", ans[i]);\n        }\n    }\n    private int[] sample(int[] nums, int n){\n        Random rd = new Random();\n        int[] ans = new int[n];\n        for(int i = 0; i < nums.length; i++){\n            if(i < n){\n                ans[i] = nums[i];\n            } else {\n                if(rd.nextInt(i+1) < n){\n                    ans[rd.nextInt(n)] = nums[i];\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n\n\n## 代码\n\n```c++\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\nprivate:\n    ListNode* head;\n    int ct = 0;\npublic:\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    Solution(ListNode* _head): head(_head) {\n        // newp = p = head;\n    }\n    \n    /** Returns a random node's value. */\n    int getRandom() {  //蓄水池随机抽取算法\n        ListNode *p = head, *newp = head;\n        int ct = 0;\n        while(newp){\n            ++ct;\n            if(rand() % ct == 0){\n                p = newp;\n            }\n            newp = newp->next;\n        }   \n        return p->val;\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(head);\n * int param_1 = obj->getRandom();\n */\n```","slug":"刷题-数学-382-Linked-List-Random-Node","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5f0032l5uo7y0wcwl3","content":"<h2 id=\"382-Linked-List-Random-Node\"><a href=\"#382-Linked-List-Random-Node\" class=\"headerlink\" title=\"382. Linked List Random Node\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-random-node/\">382. Linked List Random Node</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>让我想起来之前来宁大讲座的美国教授的出的抽取车流题目。</p>\n<p>我们可以使用蓄水池抽样算法（Reservoir Sampling）:</p>\n<p>考虑抽取一个样例的情况：我们从头遍历一个List，并以$1/k$的概率把第k个元素保留下来。</p>\n<p>可以由归纳法得：</p>\n<p>第k-1个元素的保留概率是$1/(k - 1)$，在第K个元素遍历时，第K-1次遍历是被保留的元素在这次被保留的概率是$\\frac{1}{k-1} * \\frac{k - 1}{k}= \\frac{1}{k}$ 。</p>\n<p>这就保证了遍历一遍全部数组后，各个元素被抽取的等概率性质。</p>\n<span id=\"more\"></span>\n\n<p>再考虑k&gt;1的情况，证明更复杂一点：</p>\n<p><img src=\"http://static.come2rss.xyz/831bdf1ea840c47b79007f206fb9fe6f1a1effb6c5ceed15509fe0abb23ed2f9.jpg\" alt=\"1.png\"></p>\n<p>实现代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nimport java.util.Random;\n\nClass Solution&#123;\n    public static void main(String[] args)&#123;\n        int[] nums &#x3D; new int[]&#123;1, 2, 3, 4, 5&#125;;\n        Solution s &#x3D; new Solution();\n        int[] ans &#x3D; s.sample(nums, 3);\n        for(int i &#x3D; 0; i &lt; ans.length; i++)&#123;\n            System.out.printf(&quot;%d &quot;, ans[i]);\n        &#125;\n    &#125;\n    private int[] sample(int[] nums, int n)&#123;\n        Random rd &#x3D; new Random();\n        int[] ans &#x3D; new int[n];\n        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;\n            if(i &lt; n)&#123;\n                ans[i] &#x3D; nums[i];\n            &#125; else &#123;\n                if(rd.nextInt(i+1) &lt; n)&#123;\n                    ans[rd.nextInt(n)] &#x3D; nums[i];\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\nprivate:\n    ListNode* head;\n    int ct &#x3D; 0;\npublic:\n    &#x2F;** @param head The linked list&#39;s head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. *&#x2F;\n    Solution(ListNode* _head): head(_head) &#123;\n        &#x2F;&#x2F; newp &#x3D; p &#x3D; head;\n    &#125;\n    \n    &#x2F;** Returns a random node&#39;s value. *&#x2F;\n    int getRandom() &#123;  &#x2F;&#x2F;蓄水池随机抽取算法\n        ListNode *p &#x3D; head, *newp &#x3D; head;\n        int ct &#x3D; 0;\n        while(newp)&#123;\n            ++ct;\n            if(rand() % ct &#x3D;&#x3D; 0)&#123;\n                p &#x3D; newp;\n            &#125;\n            newp &#x3D; newp-&gt;next;\n        &#125;   \n        return p-&gt;val;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(head);\n * int param_1 &#x3D; obj-&gt;getRandom();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3ZBXFXG","excerpt":"<h2 id=\"382-Linked-List-Random-Node\"><a href=\"#382-Linked-List-Random-Node\" class=\"headerlink\" title=\"382. Linked List Random Node\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-random-node/\">382. Linked List Random Node</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>让我想起来之前来宁大讲座的美国教授的出的抽取车流题目。</p>\n<p>我们可以使用蓄水池抽样算法（Reservoir Sampling）:</p>\n<p>考虑抽取一个样例的情况：我们从头遍历一个List，并以$1/k$的概率把第k个元素保留下来。</p>\n<p>可以由归纳法得：</p>\n<p>第k-1个元素的保留概率是$1/(k - 1)$，在第K个元素遍历时，第K-1次遍历是被保留的元素在这次被保留的概率是$\\frac{1}{k-1} * \\frac{k - 1}{k}= \\frac{1}{k}$ 。</p>\n<p>这就保证了遍历一遍全部数组后，各个元素被抽取的等概率性质。</p>","more":"<p>再考虑k&gt;1的情况，证明更复杂一点：</p>\n<p><img src=\"http://static.come2rss.xyz/831bdf1ea840c47b79007f206fb9fe6f1a1effb6c5ceed15509fe0abb23ed2f9.jpg\" alt=\"1.png\"></p>\n<p>实现代码：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nimport java.util.Random;\n\nClass Solution&#123;\n    public static void main(String[] args)&#123;\n        int[] nums &#x3D; new int[]&#123;1, 2, 3, 4, 5&#125;;\n        Solution s &#x3D; new Solution();\n        int[] ans &#x3D; s.sample(nums, 3);\n        for(int i &#x3D; 0; i &lt; ans.length; i++)&#123;\n            System.out.printf(&quot;%d &quot;, ans[i]);\n        &#125;\n    &#125;\n    private int[] sample(int[] nums, int n)&#123;\n        Random rd &#x3D; new Random();\n        int[] ans &#x3D; new int[n];\n        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;\n            if(i &lt; n)&#123;\n                ans[i] &#x3D; nums[i];\n            &#125; else &#123;\n                if(rd.nextInt(i+1) &lt; n)&#123;\n                    ans[rd.nextInt(n)] &#x3D; nums[i];\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\nprivate:\n    ListNode* head;\n    int ct &#x3D; 0;\npublic:\n    &#x2F;** @param head The linked list&#39;s head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. *&#x2F;\n    Solution(ListNode* _head): head(_head) &#123;\n        &#x2F;&#x2F; newp &#x3D; p &#x3D; head;\n    &#125;\n    \n    &#x2F;** Returns a random node&#39;s value. *&#x2F;\n    int getRandom() &#123;  &#x2F;&#x2F;蓄水池随机抽取算法\n        ListNode *p &#x3D; head, *newp &#x3D; head;\n        int ct &#x3D; 0;\n        while(newp)&#123;\n            ++ct;\n            if(rand() % ct &#x3D;&#x3D; 0)&#123;\n                p &#x3D; newp;\n            &#125;\n            newp &#x3D; newp-&gt;next;\n        &#125;   \n        return p-&gt;val;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(head);\n * int param_1 &#x3D; obj-&gt;getRandom();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"384. Shuffle an Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-09T11:33:02.000Z","_content":"\n\n\n## 思路：\n\nFisher-Yates shuffle洗牌算法：逐个遍历交换后续随机元素。\n\n<!-- more -->\n\n## 代码\n\n反洗算法\n\n```c++\nclass Solution {\n    vector<int> origin;\npublic:\n    Solution(vector<int>& nums) :origin(nums) {}\n    \n    /** Resets the array to its original configuration and return it. */\n    vector<int> reset() {\n        return origin;\n    }\n    \n    /** Returns a random shuffling of the array. */\n    vector<int> shuffle() {        \n        vector<int> shuffled(origin); \n        if(origin.size() == 0) return shuffled;\n        for(int i = origin.size() - 1; i >= 0; --i){ //还可以反着洗\n            swap(shuffled[i], shuffled[rand() % (i + 1)]);\n        }\n        return shuffled;\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(nums);\n * vector<int> param_1 = obj->reset();\n * vector<int> param_2 = obj->shuffle();\n */\n```\n\n","source":"_posts/刷题/数学\n/384-Shuffle-an-Array.md","raw":"---\ntitle: 384. Shuffle an Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-09 19:33:02\n---\n\n\n\n## 思路：\n\nFisher-Yates shuffle洗牌算法：逐个遍历交换后续随机元素。\n\n<!-- more -->\n\n## 代码\n\n反洗算法\n\n```c++\nclass Solution {\n    vector<int> origin;\npublic:\n    Solution(vector<int>& nums) :origin(nums) {}\n    \n    /** Resets the array to its original configuration and return it. */\n    vector<int> reset() {\n        return origin;\n    }\n    \n    /** Returns a random shuffling of the array. */\n    vector<int> shuffle() {        \n        vector<int> shuffled(origin); \n        if(origin.size() == 0) return shuffled;\n        for(int i = origin.size() - 1; i >= 0; --i){ //还可以反着洗\n            swap(shuffled[i], shuffled[rand() % (i + 1)]);\n        }\n        return shuffled;\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(nums);\n * vector<int> param_1 = obj->reset();\n * vector<int> param_2 = obj->shuffle();\n */\n```\n\n","slug":"刷题-数学-384-Shuffle-an-Array","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5g0033l5uockdzfjeu","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>Fisher-Yates shuffle洗牌算法：逐个遍历交换后续随机元素。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>反洗算法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;int&gt; origin;\npublic:\n    Solution(vector&lt;int&gt;&amp; nums) :origin(nums) &#123;&#125;\n    \n    &#x2F;** Resets the array to its original configuration and return it. *&#x2F;\n    vector&lt;int&gt; reset() &#123;\n        return origin;\n    &#125;\n    \n    &#x2F;** Returns a random shuffling of the array. *&#x2F;\n    vector&lt;int&gt; shuffle() &#123;        \n        vector&lt;int&gt; shuffled(origin); \n        if(origin.size() &#x3D;&#x3D; 0) return shuffled;\n        for(int i &#x3D; origin.size() - 1; i &gt;&#x3D; 0; --i)&#123; &#x2F;&#x2F;还可以反着洗\n            swap(shuffled[i], shuffled[rand() % (i + 1)]);\n        &#125;\n        return shuffled;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(nums);\n * vector&lt;int&gt; param_1 &#x3D; obj-&gt;reset();\n * vector&lt;int&gt; param_2 &#x3D; obj-&gt;shuffle();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3ANH353","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>Fisher-Yates shuffle洗牌算法：逐个遍历交换后续随机元素。</p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>反洗算法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;int&gt; origin;\npublic:\n    Solution(vector&lt;int&gt;&amp; nums) :origin(nums) &#123;&#125;\n    \n    &#x2F;** Resets the array to its original configuration and return it. *&#x2F;\n    vector&lt;int&gt; reset() &#123;\n        return origin;\n    &#125;\n    \n    &#x2F;** Returns a random shuffling of the array. *&#x2F;\n    vector&lt;int&gt; shuffle() &#123;        \n        vector&lt;int&gt; shuffled(origin); \n        if(origin.size() &#x3D;&#x3D; 0) return shuffled;\n        for(int i &#x3D; origin.size() - 1; i &gt;&#x3D; 0; --i)&#123; &#x2F;&#x2F;还可以反着洗\n            swap(shuffled[i], shuffled[rand() % (i + 1)]);\n        &#125;\n        return shuffled;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(nums);\n * vector&lt;int&gt; param_1 &#x3D; obj-&gt;reset();\n * vector&lt;int&gt; param_2 &#x3D; obj-&gt;shuffle();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"415. Add Strings","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-07T03:53:27.000Z","_content":"\n\n\n\n\n## [415. Add Strings](https://leetcode-cn.com/problems/add-strings/)\n\n## 思路：\n\n一般的大数相加，不过用高位补零的方法可以大大减少代码复杂度，方便编程。<!-- more -->\n\n\n\n## 思路：\n\n```c++\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string ans; \n        int add = 0;\n        int i = num1.size() - 1, j = num2.size() - 1;\n        //低位相加\n        while(i >= 0 && j >= 0){\n            int sum = add + num1[i--] + num2[j--] - 2 * '0';\n            ans = to_string(sum % 10) + ans;\n            add = sum / 10;\n        }\n        \n        string c; //剩余高位\n        if(i >= 0) c = num1.substr(0, i + 1);\n        if(j >= 0) c = num2.substr(0, j + 1);\n        string num3; // 高位与add相加\n        if(add){\n            int k = c.size() - 1;\n            while(k >= 0){\n                int sum = add + c[k--] - '0';\n                num3 = to_string(sum % 10) + num3;//重建一个string太耗时间了\n                add = sum / 10;\n            }\n            if(add) num3 = to_string(add) + num3;\n        }else num3 = c;\n\n        return num3 + ans;\n    \n    }\n};\n```\n\n\n\n优化一下\n\n```c++\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string ans; \n        int add = 0;\n        int i = num1.size() - 1, j = num2.size() - 1;\n        \n        while(i >= 0 || j >= 0){\n            int a1 = i >= 0 ? num1[i--] - '0' : 0;\n            int a2 = j >= 0 ? num2[j--] - '0' : 0;\n            int sum = add + a1 + a2;\n            ans = to_string(sum % 10) + ans;\n            add = sum / 10;\n        }\n        return (add == 0 ? \"\" : \"1\") + ans;\n    \n    }\n};\n```\n\n","source":"_posts/刷题/数学\n/415-Add-Strings.md","raw":"---\ntitle: 415. Add Strings\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-07 11:53:27\n---\n\n\n\n\n\n## [415. Add Strings](https://leetcode-cn.com/problems/add-strings/)\n\n## 思路：\n\n一般的大数相加，不过用高位补零的方法可以大大减少代码复杂度，方便编程。<!-- more -->\n\n\n\n## 思路：\n\n```c++\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string ans; \n        int add = 0;\n        int i = num1.size() - 1, j = num2.size() - 1;\n        //低位相加\n        while(i >= 0 && j >= 0){\n            int sum = add + num1[i--] + num2[j--] - 2 * '0';\n            ans = to_string(sum % 10) + ans;\n            add = sum / 10;\n        }\n        \n        string c; //剩余高位\n        if(i >= 0) c = num1.substr(0, i + 1);\n        if(j >= 0) c = num2.substr(0, j + 1);\n        string num3; // 高位与add相加\n        if(add){\n            int k = c.size() - 1;\n            while(k >= 0){\n                int sum = add + c[k--] - '0';\n                num3 = to_string(sum % 10) + num3;//重建一个string太耗时间了\n                add = sum / 10;\n            }\n            if(add) num3 = to_string(add) + num3;\n        }else num3 = c;\n\n        return num3 + ans;\n    \n    }\n};\n```\n\n\n\n优化一下\n\n```c++\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        string ans; \n        int add = 0;\n        int i = num1.size() - 1, j = num2.size() - 1;\n        \n        while(i >= 0 || j >= 0){\n            int a1 = i >= 0 ? num1[i--] - '0' : 0;\n            int a2 = j >= 0 ? num2[j--] - '0' : 0;\n            int sum = add + a1 + a2;\n            ans = to_string(sum % 10) + ans;\n            add = sum / 10;\n        }\n        return (add == 0 ? \"\" : \"1\") + ans;\n    \n    }\n};\n```\n\n","slug":"刷题-数学-415-Add-Strings","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5h0034l5uobo89fe3d","content":"<h2 id=\"415-Add-Strings\"><a href=\"#415-Add-Strings\" class=\"headerlink\" title=\"415. Add Strings\"></a><a href=\"https://leetcode-cn.com/problems/add-strings/\">415. Add Strings</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>一般的大数相加，不过用高位补零的方法可以大大减少代码复杂度，方便编程。<span id=\"more\"></span></p>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string addStrings(string num1, string num2) &#123;\n        string ans; \n        int add &#x3D; 0;\n        int i &#x3D; num1.size() - 1, j &#x3D; num2.size() - 1;\n        &#x2F;&#x2F;低位相加\n        while(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0)&#123;\n            int sum &#x3D; add + num1[i--] + num2[j--] - 2 * &#39;0&#39;;\n            ans &#x3D; to_string(sum % 10) + ans;\n            add &#x3D; sum &#x2F; 10;\n        &#125;\n        \n        string c; &#x2F;&#x2F;剩余高位\n        if(i &gt;&#x3D; 0) c &#x3D; num1.substr(0, i + 1);\n        if(j &gt;&#x3D; 0) c &#x3D; num2.substr(0, j + 1);\n        string num3; &#x2F;&#x2F; 高位与add相加\n        if(add)&#123;\n            int k &#x3D; c.size() - 1;\n            while(k &gt;&#x3D; 0)&#123;\n                int sum &#x3D; add + c[k--] - &#39;0&#39;;\n                num3 &#x3D; to_string(sum % 10) + num3;&#x2F;&#x2F;重建一个string太耗时间了\n                add &#x3D; sum &#x2F; 10;\n            &#125;\n            if(add) num3 &#x3D; to_string(add) + num3;\n        &#125;else num3 &#x3D; c;\n\n        return num3 + ans;\n    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>优化一下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string addStrings(string num1, string num2) &#123;\n        string ans; \n        int add &#x3D; 0;\n        int i &#x3D; num1.size() - 1, j &#x3D; num2.size() - 1;\n        \n        while(i &gt;&#x3D; 0 || j &gt;&#x3D; 0)&#123;\n            int a1 &#x3D; i &gt;&#x3D; 0 ? num1[i--] - &#39;0&#39; : 0;\n            int a2 &#x3D; j &gt;&#x3D; 0 ? num2[j--] - &#39;0&#39; : 0;\n            int sum &#x3D; add + a1 + a2;\n            ans &#x3D; to_string(sum % 10) + ans;\n            add &#x3D; sum &#x2F; 10;\n        &#125;\n        return (add &#x3D;&#x3D; 0 ? &quot;&quot; : &quot;1&quot;) + ans;\n    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"9PNMN0","excerpt":"<h2 id=\"415-Add-Strings\"><a href=\"#415-Add-Strings\" class=\"headerlink\" title=\"415. Add Strings\"></a><a href=\"https://leetcode-cn.com/problems/add-strings/\">415. Add Strings</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>一般的大数相加，不过用高位补零的方法可以大大减少代码复杂度，方便编程。","more":"</p>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string addStrings(string num1, string num2) &#123;\n        string ans; \n        int add &#x3D; 0;\n        int i &#x3D; num1.size() - 1, j &#x3D; num2.size() - 1;\n        &#x2F;&#x2F;低位相加\n        while(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0)&#123;\n            int sum &#x3D; add + num1[i--] + num2[j--] - 2 * &#39;0&#39;;\n            ans &#x3D; to_string(sum % 10) + ans;\n            add &#x3D; sum &#x2F; 10;\n        &#125;\n        \n        string c; &#x2F;&#x2F;剩余高位\n        if(i &gt;&#x3D; 0) c &#x3D; num1.substr(0, i + 1);\n        if(j &gt;&#x3D; 0) c &#x3D; num2.substr(0, j + 1);\n        string num3; &#x2F;&#x2F; 高位与add相加\n        if(add)&#123;\n            int k &#x3D; c.size() - 1;\n            while(k &gt;&#x3D; 0)&#123;\n                int sum &#x3D; add + c[k--] - &#39;0&#39;;\n                num3 &#x3D; to_string(sum % 10) + num3;&#x2F;&#x2F;重建一个string太耗时间了\n                add &#x3D; sum &#x2F; 10;\n            &#125;\n            if(add) num3 &#x3D; to_string(add) + num3;\n        &#125;else num3 &#x3D; c;\n\n        return num3 + ans;\n    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>优化一下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string addStrings(string num1, string num2) &#123;\n        string ans; \n        int add &#x3D; 0;\n        int i &#x3D; num1.size() - 1, j &#x3D; num2.size() - 1;\n        \n        while(i &gt;&#x3D; 0 || j &gt;&#x3D; 0)&#123;\n            int a1 &#x3D; i &gt;&#x3D; 0 ? num1[i--] - &#39;0&#39; : 0;\n            int a2 &#x3D; j &gt;&#x3D; 0 ? num2[j--] - &#39;0&#39; : 0;\n            int sum &#x3D; add + a1 + a2;\n            ans &#x3D; to_string(sum % 10) + ans;\n            add &#x3D; sum &#x2F; 10;\n        &#125;\n        return (add &#x3D;&#x3D; 0 ? &quot;&quot; : &quot;1&quot;) + ans;\n    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"462. Minimum Moves to Equal Array Elements II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-14T03:04:09.000Z","_content":"\n\n\n\n## [462. Minimum Moves to Equal Array Elements II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)  第K大\n\n\n\n\n\n## 思路：\n\n\n\n1. 第一次做，看看数据的形式似乎具有凹函数的性质，于是用三分法搜索数值。菜鸡如我，没有总结过三分，有些地方写错了，wa了一次，int超范围了一次。这题好坏啊。算法复杂度$o(nlogn)$。\n\n   <!-- more -->\n\n2. 还有一种思路是排序后，依照凹函数性质二分搜索也可以！复杂度$o(nlogn + nlogn)$ ，还是我快，不过我的n不是他的n。\n\n3. 看题解，发现寻找中位数的方法，更好更容易证明，\n\n可以发现，奇数个数组的中位数容易的，如果在偶数个数字的数组中，中位数公式：\n$$\nmid\\_element = \\frac{Arr[size / 2] + Arr[size / 2 + 1]}{2}\n$$\n幸运的是，在该题意下，直接使用$Arr[size / 2]$的计算值和使用$min\\_element$效果一致。题意可以化简。\n\n4. 上题的代码，还可是使用第$k$大数字题目使用的算法来求解。\n\n## 代码：\n\n1\n\n\n\n```c++\n\nclass Solution {\npublic:\n    using ll = long long; //这题太坏了\n    ll gap(vector<int> & nums, ll g){\n        ll res = 0;\n        for(auto k : nums){\n            res += abs(k - g);\n        }\n        return res;\n    }\n    ll minMoves2(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n        int maxv = *max_element(nums.begin(), nums.end());\n        int minv = *min_element(nums.begin(), nums.end());\n\n        while(minv < maxv){\n            int mid1 = (maxv - minv) / 3 + minv;\n            int mid2 = (maxv - minv)  * 2 / 3  + minv;\n            if(mid1 == mid2) ++mid2; //[minv, maxv] = [0, 1]\n            ll r1 =gap(nums, mid1), r2 = gap(nums, mid2);\n            if(r1 > r2){\n                minv = mid1 + 1;\n            }else if(r2 > r1){\n                maxv = mid2 - 1;\n            }else{\n                if(mid1 == mid2){\n                    minv = maxv = mid1;\n                    break;\n                }\n                minv = mid1  + 1;\n                maxv = mid2 - 1;\n            }\n            // cout << minv << ' ' << maxv << endl;\n        }\n        return gap(nums, minv);\n    }\n};\n```\n\n\n\n2\n\n```c++\n\nclass Solution {\npublic:\n    int minMoves2(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int l=0,r=nums.size()-1,mid;\n        while(l<r){\n            mid=(l+r)>>1;\n            if(sumof(nums[mid],nums)<sumof(nums[mid]+1,nums)) r=mid; //利用了凹函数的特性\n            else l=mid+1;\n        }\n        return sumof(nums[l],nums);\n    }\n    long sumof(int n,vector<int>& nums){\n        long sum=0;\n        for(int i=0;i<nums.size();i++){\n            sum+=abs(nums[i]-n);\n        }\n        return sum;\n    }\n};\n```\n\n\n\n3\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        sort(nums.begin(), nums.end());\n        ll sum = 0;\n        for(auto k : nums){\n            sum+=abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n};\n```\n\n4\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());//偷懒\n        ll sum = 0;\n        for(auto k : nums){\n            sum+=abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n};\n```\n\n\n\n我的实现：效率巨低\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        my_nth_element(nums, 0, nums.size(), nums.size() / 2);\n        ll sum = 0;\n        for(auto k : nums){\n            sum+= abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n    \n    int partition(vector<int> &nums, int s, int e){        \n        int l = s, r = e - 1, temp = nums[s];\n        while(l < r){\n            while(l < r && nums[r] >= temp) --r;\n            swap(nums[r], nums[l]);\n            while(l < r && nums[l] <= temp) ++l;\n            swap(nums[r], nums[l]);\n        }\n        // nums[l] = temp;\n        return l;\n    }\n\n    void my_nth_element(vector<int> &nums, int s, int e, int k){\n        if(s == e) return;\n        int idx = partition(nums, s, e);\n        if(idx == k) return;\n        else if(idx < k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); // bugs, e 是边界， 所以不能取 s - 1\n    }\n};\n```\n\n第K大算法中另一种patition算法。\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        my_nth_element(nums, 0, nums.size(), nums.size() / 2);\n        ll sum = 0;\n        for(auto k : nums){\n            sum+= abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n    \n    // int partition(vector<int> &nums, int s, int e){        \n    //     int l = s, r = e - 1, temp = nums[s];\n    //     while(l < r){\n    //         while(l < r && nums[r] >= temp) --r;\n    //         swap(nums[r], nums[l]);\n    //         while(l < r && nums[l] <= temp) ++l;\n    //         swap(nums[r], nums[l]);\n    //     }\n    //     // nums[l] = temp;\n    //     return l;\n    // }\n\n    // 该算法基于一种朴素的想法：把小的前面，大的放后面\n    int partition(vector<int> &nums, int s, int e){     \n        int i = s, pivot = nums[e - 1];\n        for(int j = s; j < e; ++j){\n            if(nums[j] < pivot){\n                swap(nums[i], nums[j]);\n                ++i;\n            }\n        }\n        swap(nums[i], nums[e - 1]);\n        return i;\n    }\n    void my_nth_element(vector<int> &nums, int s, int e, int k){\n        if(s == e) return;\n        int idx = partition(nums, s, e);\n        if(idx == k) return;\n        else if(idx < k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); // bugs, e 是边界， 所以不能取 s - 1\n    }\n};\n```","source":"_posts/刷题/数学\n/462-Minimum-Moves-to-Equal-Array-Elements-II.md","raw":"---\ntitle: 462. Minimum Moves to Equal Array Elements II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\n\ncategories:\ndate: 2021-01-14 11:04:09\n---\n\n\n\n\n## [462. Minimum Moves to Equal Array Elements II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)  第K大\n\n\n\n\n\n## 思路：\n\n\n\n1. 第一次做，看看数据的形式似乎具有凹函数的性质，于是用三分法搜索数值。菜鸡如我，没有总结过三分，有些地方写错了，wa了一次，int超范围了一次。这题好坏啊。算法复杂度$o(nlogn)$。\n\n   <!-- more -->\n\n2. 还有一种思路是排序后，依照凹函数性质二分搜索也可以！复杂度$o(nlogn + nlogn)$ ，还是我快，不过我的n不是他的n。\n\n3. 看题解，发现寻找中位数的方法，更好更容易证明，\n\n可以发现，奇数个数组的中位数容易的，如果在偶数个数字的数组中，中位数公式：\n$$\nmid\\_element = \\frac{Arr[size / 2] + Arr[size / 2 + 1]}{2}\n$$\n幸运的是，在该题意下，直接使用$Arr[size / 2]$的计算值和使用$min\\_element$效果一致。题意可以化简。\n\n4. 上题的代码，还可是使用第$k$大数字题目使用的算法来求解。\n\n## 代码：\n\n1\n\n\n\n```c++\n\nclass Solution {\npublic:\n    using ll = long long; //这题太坏了\n    ll gap(vector<int> & nums, ll g){\n        ll res = 0;\n        for(auto k : nums){\n            res += abs(k - g);\n        }\n        return res;\n    }\n    ll minMoves2(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n        int maxv = *max_element(nums.begin(), nums.end());\n        int minv = *min_element(nums.begin(), nums.end());\n\n        while(minv < maxv){\n            int mid1 = (maxv - minv) / 3 + minv;\n            int mid2 = (maxv - minv)  * 2 / 3  + minv;\n            if(mid1 == mid2) ++mid2; //[minv, maxv] = [0, 1]\n            ll r1 =gap(nums, mid1), r2 = gap(nums, mid2);\n            if(r1 > r2){\n                minv = mid1 + 1;\n            }else if(r2 > r1){\n                maxv = mid2 - 1;\n            }else{\n                if(mid1 == mid2){\n                    minv = maxv = mid1;\n                    break;\n                }\n                minv = mid1  + 1;\n                maxv = mid2 - 1;\n            }\n            // cout << minv << ' ' << maxv << endl;\n        }\n        return gap(nums, minv);\n    }\n};\n```\n\n\n\n2\n\n```c++\n\nclass Solution {\npublic:\n    int minMoves2(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int l=0,r=nums.size()-1,mid;\n        while(l<r){\n            mid=(l+r)>>1;\n            if(sumof(nums[mid],nums)<sumof(nums[mid]+1,nums)) r=mid; //利用了凹函数的特性\n            else l=mid+1;\n        }\n        return sumof(nums[l],nums);\n    }\n    long sumof(int n,vector<int>& nums){\n        long sum=0;\n        for(int i=0;i<nums.size();i++){\n            sum+=abs(nums[i]-n);\n        }\n        return sum;\n    }\n};\n```\n\n\n\n3\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        sort(nums.begin(), nums.end());\n        ll sum = 0;\n        for(auto k : nums){\n            sum+=abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n};\n```\n\n4\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());//偷懒\n        ll sum = 0;\n        for(auto k : nums){\n            sum+=abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n};\n```\n\n\n\n我的实现：效率巨低\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        my_nth_element(nums, 0, nums.size(), nums.size() / 2);\n        ll sum = 0;\n        for(auto k : nums){\n            sum+= abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n    \n    int partition(vector<int> &nums, int s, int e){        \n        int l = s, r = e - 1, temp = nums[s];\n        while(l < r){\n            while(l < r && nums[r] >= temp) --r;\n            swap(nums[r], nums[l]);\n            while(l < r && nums[l] <= temp) ++l;\n            swap(nums[r], nums[l]);\n        }\n        // nums[l] = temp;\n        return l;\n    }\n\n    void my_nth_element(vector<int> &nums, int s, int e, int k){\n        if(s == e) return;\n        int idx = partition(nums, s, e);\n        if(idx == k) return;\n        else if(idx < k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); // bugs, e 是边界， 所以不能取 s - 1\n    }\n};\n```\n\n第K大算法中另一种patition算法。\n\n```c++\nclass Solution {\npublic:\n    using ll = long long;\n    long minMoves2(vector<int>& nums){\n        my_nth_element(nums, 0, nums.size(), nums.size() / 2);\n        ll sum = 0;\n        for(auto k : nums){\n            sum+= abs(k - nums[nums.size() / 2]);\n        }\n        return sum;\n    }\n    \n    // int partition(vector<int> &nums, int s, int e){        \n    //     int l = s, r = e - 1, temp = nums[s];\n    //     while(l < r){\n    //         while(l < r && nums[r] >= temp) --r;\n    //         swap(nums[r], nums[l]);\n    //         while(l < r && nums[l] <= temp) ++l;\n    //         swap(nums[r], nums[l]);\n    //     }\n    //     // nums[l] = temp;\n    //     return l;\n    // }\n\n    // 该算法基于一种朴素的想法：把小的前面，大的放后面\n    int partition(vector<int> &nums, int s, int e){     \n        int i = s, pivot = nums[e - 1];\n        for(int j = s; j < e; ++j){\n            if(nums[j] < pivot){\n                swap(nums[i], nums[j]);\n                ++i;\n            }\n        }\n        swap(nums[i], nums[e - 1]);\n        return i;\n    }\n    void my_nth_element(vector<int> &nums, int s, int e, int k){\n        if(s == e) return;\n        int idx = partition(nums, s, e);\n        if(idx == k) return;\n        else if(idx < k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); // bugs, e 是边界， 所以不能取 s - 1\n    }\n};\n```","slug":"刷题-数学-462-Minimum-Moves-to-Equal-Array-Elements-II","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5h0035l5uo5h3b7isu","content":"<h2 id=\"462-Minimum-Moves-to-Equal-Array-Elements-II-第K大\"><a href=\"#462-Minimum-Moves-to-Equal-Array-Elements-II-第K大\" class=\"headerlink\" title=\"462. Minimum Moves to Equal Array Elements II  第K大\"></a><a href=\"https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/\">462. Minimum Moves to Equal Array Elements II</a>  第K大</h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>第一次做，看看数据的形式似乎具有凹函数的性质，于是用三分法搜索数值。菜鸡如我，没有总结过三分，有些地方写错了，wa了一次，int超范围了一次。这题好坏啊。算法复杂度$o(nlogn)$。</p>\n<span id=\"more\"></span>\n</li>\n<li><p>还有一种思路是排序后，依照凹函数性质二分搜索也可以！复杂度$o(nlogn + nlogn)$ ，还是我快，不过我的n不是他的n。</p>\n</li>\n<li><p>看题解，发现寻找中位数的方法，更好更容易证明，</p>\n</li>\n</ol>\n<p>可以发现，奇数个数组的中位数容易的，如果在偶数个数字的数组中，中位数公式：<br>$$<br>mid_element = \\frac{Arr[size / 2] + Arr[size / 2 + 1]}{2}<br>$$<br>幸运的是，在该题意下，直接使用$Arr[size / 2]$的计算值和使用$min_element$效果一致。题意可以化简。</p>\n<ol start=\"4\">\n<li>上题的代码，还可是使用第$k$大数字题目使用的算法来求解。</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    using ll &#x3D; long long; &#x2F;&#x2F;这题太坏了\n    ll gap(vector&lt;int&gt; &amp; nums, ll g)&#123;\n        ll res &#x3D; 0;\n        for(auto k : nums)&#123;\n            res +&#x3D; abs(k - g);\n        &#125;\n        return res;\n    &#125;\n    ll minMoves2(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n        int maxv &#x3D; *max_element(nums.begin(), nums.end());\n        int minv &#x3D; *min_element(nums.begin(), nums.end());\n\n        while(minv &lt; maxv)&#123;\n            int mid1 &#x3D; (maxv - minv) &#x2F; 3 + minv;\n            int mid2 &#x3D; (maxv - minv)  * 2 &#x2F; 3  + minv;\n            if(mid1 &#x3D;&#x3D; mid2) ++mid2; &#x2F;&#x2F;[minv, maxv] &#x3D; [0, 1]\n            ll r1 &#x3D;gap(nums, mid1), r2 &#x3D; gap(nums, mid2);\n            if(r1 &gt; r2)&#123;\n                minv &#x3D; mid1 + 1;\n            &#125;else if(r2 &gt; r1)&#123;\n                maxv &#x3D; mid2 - 1;\n            &#125;else&#123;\n                if(mid1 &#x3D;&#x3D; mid2)&#123;\n                    minv &#x3D; maxv &#x3D; mid1;\n                    break;\n                &#125;\n                minv &#x3D; mid1  + 1;\n                maxv &#x3D; mid2 - 1;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; minv &lt;&lt; &#39; &#39; &lt;&lt; maxv &lt;&lt; endl;\n        &#125;\n        return gap(nums, minv);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>2</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int minMoves2(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(),nums.end());\n        int l&#x3D;0,r&#x3D;nums.size()-1,mid;\n        while(l&lt;r)&#123;\n            mid&#x3D;(l+r)&gt;&gt;1;\n            if(sumof(nums[mid],nums)&lt;sumof(nums[mid]+1,nums)) r&#x3D;mid; &#x2F;&#x2F;利用了凹函数的特性\n            else l&#x3D;mid+1;\n        &#125;\n        return sumof(nums[l],nums);\n    &#125;\n    long sumof(int n,vector&lt;int&gt;&amp; nums)&#123;\n        long sum&#x3D;0;\n        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;\n            sum+&#x3D;abs(nums[i]-n);\n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>3</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        sort(nums.begin(), nums.end());\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D;abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>4</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        nth_element(nums.begin(), nums.begin() + nums.size() &#x2F; 2, nums.end());&#x2F;&#x2F;偷懒\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D;abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>我的实现：效率巨低</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        my_nth_element(nums, 0, nums.size(), nums.size() &#x2F; 2);\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D; abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n    \n    int partition(vector&lt;int&gt; &amp;nums, int s, int e)&#123;        \n        int l &#x3D; s, r &#x3D; e - 1, temp &#x3D; nums[s];\n        while(l &lt; r)&#123;\n            while(l &lt; r &amp;&amp; nums[r] &gt;&#x3D; temp) --r;\n            swap(nums[r], nums[l]);\n            while(l &lt; r &amp;&amp; nums[l] &lt;&#x3D; temp) ++l;\n            swap(nums[r], nums[l]);\n        &#125;\n        &#x2F;&#x2F; nums[l] &#x3D; temp;\n        return l;\n    &#125;\n\n    void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k)&#123;\n        if(s &#x3D;&#x3D; e) return;\n        int idx &#x3D; partition(nums, s, e);\n        if(idx &#x3D;&#x3D; k) return;\n        else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); &#x2F;&#x2F; bugs, e 是边界， 所以不能取 s - 1\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第K大算法中另一种patition算法。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        my_nth_element(nums, 0, nums.size(), nums.size() &#x2F; 2);\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D; abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n    \n    &#x2F;&#x2F; int partition(vector&lt;int&gt; &amp;nums, int s, int e)&#123;        \n    &#x2F;&#x2F;     int l &#x3D; s, r &#x3D; e - 1, temp &#x3D; nums[s];\n    &#x2F;&#x2F;     while(l &lt; r)&#123;\n    &#x2F;&#x2F;         while(l &lt; r &amp;&amp; nums[r] &gt;&#x3D; temp) --r;\n    &#x2F;&#x2F;         swap(nums[r], nums[l]);\n    &#x2F;&#x2F;         while(l &lt; r &amp;&amp; nums[l] &lt;&#x3D; temp) ++l;\n    &#x2F;&#x2F;         swap(nums[r], nums[l]);\n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     &#x2F;&#x2F; nums[l] &#x3D; temp;\n    &#x2F;&#x2F;     return l;\n    &#x2F;&#x2F; &#125;\n\n    &#x2F;&#x2F; 该算法基于一种朴素的想法：把小的前面，大的放后面\n    int partition(vector&lt;int&gt; &amp;nums, int s, int e)&#123;     \n        int i &#x3D; s, pivot &#x3D; nums[e - 1];\n        for(int j &#x3D; s; j &lt; e; ++j)&#123;\n            if(nums[j] &lt; pivot)&#123;\n                swap(nums[i], nums[j]);\n                ++i;\n            &#125;\n        &#125;\n        swap(nums[i], nums[e - 1]);\n        return i;\n    &#125;\n    void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k)&#123;\n        if(s &#x3D;&#x3D; e) return;\n        int idx &#x3D; partition(nums, s, e);\n        if(idx &#x3D;&#x3D; k) return;\n        else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); &#x2F;&#x2F; bugs, e 是边界， 所以不能取 s - 1\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1FV85TM","excerpt":"<h2 id=\"462-Minimum-Moves-to-Equal-Array-Elements-II-第K大\"><a href=\"#462-Minimum-Moves-to-Equal-Array-Elements-II-第K大\" class=\"headerlink\" title=\"462. Minimum Moves to Equal Array Elements II  第K大\"></a><a href=\"https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/\">462. Minimum Moves to Equal Array Elements II</a>  第K大</h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>第一次做，看看数据的形式似乎具有凹函数的性质，于是用三分法搜索数值。菜鸡如我，没有总结过三分，有些地方写错了，wa了一次，int超范围了一次。这题好坏啊。算法复杂度$o(nlogn)$。</p>","more":"</li>\n<li><p>还有一种思路是排序后，依照凹函数性质二分搜索也可以！复杂度$o(nlogn + nlogn)$ ，还是我快，不过我的n不是他的n。</p>\n</li>\n<li><p>看题解，发现寻找中位数的方法，更好更容易证明，</p>\n</li>\n</ol>\n<p>可以发现，奇数个数组的中位数容易的，如果在偶数个数字的数组中，中位数公式：<br>$$<br>mid_element = \\frac{Arr[size / 2] + Arr[size / 2 + 1]}{2}<br>$$<br>幸运的是，在该题意下，直接使用$Arr[size / 2]$的计算值和使用$min_element$效果一致。题意可以化简。</p>\n<ol start=\"4\">\n<li>上题的代码，还可是使用第$k$大数字题目使用的算法来求解。</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>1</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    using ll &#x3D; long long; &#x2F;&#x2F;这题太坏了\n    ll gap(vector&lt;int&gt; &amp; nums, ll g)&#123;\n        ll res &#x3D; 0;\n        for(auto k : nums)&#123;\n            res +&#x3D; abs(k - g);\n        &#125;\n        return res;\n    &#125;\n    ll minMoves2(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n        int maxv &#x3D; *max_element(nums.begin(), nums.end());\n        int minv &#x3D; *min_element(nums.begin(), nums.end());\n\n        while(minv &lt; maxv)&#123;\n            int mid1 &#x3D; (maxv - minv) &#x2F; 3 + minv;\n            int mid2 &#x3D; (maxv - minv)  * 2 &#x2F; 3  + minv;\n            if(mid1 &#x3D;&#x3D; mid2) ++mid2; &#x2F;&#x2F;[minv, maxv] &#x3D; [0, 1]\n            ll r1 &#x3D;gap(nums, mid1), r2 &#x3D; gap(nums, mid2);\n            if(r1 &gt; r2)&#123;\n                minv &#x3D; mid1 + 1;\n            &#125;else if(r2 &gt; r1)&#123;\n                maxv &#x3D; mid2 - 1;\n            &#125;else&#123;\n                if(mid1 &#x3D;&#x3D; mid2)&#123;\n                    minv &#x3D; maxv &#x3D; mid1;\n                    break;\n                &#125;\n                minv &#x3D; mid1  + 1;\n                maxv &#x3D; mid2 - 1;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; minv &lt;&lt; &#39; &#39; &lt;&lt; maxv &lt;&lt; endl;\n        &#125;\n        return gap(nums, minv);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>2</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int minMoves2(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(),nums.end());\n        int l&#x3D;0,r&#x3D;nums.size()-1,mid;\n        while(l&lt;r)&#123;\n            mid&#x3D;(l+r)&gt;&gt;1;\n            if(sumof(nums[mid],nums)&lt;sumof(nums[mid]+1,nums)) r&#x3D;mid; &#x2F;&#x2F;利用了凹函数的特性\n            else l&#x3D;mid+1;\n        &#125;\n        return sumof(nums[l],nums);\n    &#125;\n    long sumof(int n,vector&lt;int&gt;&amp; nums)&#123;\n        long sum&#x3D;0;\n        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;\n            sum+&#x3D;abs(nums[i]-n);\n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>3</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        sort(nums.begin(), nums.end());\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D;abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>4</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        nth_element(nums.begin(), nums.begin() + nums.size() &#x2F; 2, nums.end());&#x2F;&#x2F;偷懒\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D;abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>我的实现：效率巨低</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        my_nth_element(nums, 0, nums.size(), nums.size() &#x2F; 2);\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D; abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n    \n    int partition(vector&lt;int&gt; &amp;nums, int s, int e)&#123;        \n        int l &#x3D; s, r &#x3D; e - 1, temp &#x3D; nums[s];\n        while(l &lt; r)&#123;\n            while(l &lt; r &amp;&amp; nums[r] &gt;&#x3D; temp) --r;\n            swap(nums[r], nums[l]);\n            while(l &lt; r &amp;&amp; nums[l] &lt;&#x3D; temp) ++l;\n            swap(nums[r], nums[l]);\n        &#125;\n        &#x2F;&#x2F; nums[l] &#x3D; temp;\n        return l;\n    &#125;\n\n    void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k)&#123;\n        if(s &#x3D;&#x3D; e) return;\n        int idx &#x3D; partition(nums, s, e);\n        if(idx &#x3D;&#x3D; k) return;\n        else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); &#x2F;&#x2F; bugs, e 是边界， 所以不能取 s - 1\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>第K大算法中另一种patition算法。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    using ll &#x3D; long long;\n    long minMoves2(vector&lt;int&gt;&amp; nums)&#123;\n        my_nth_element(nums, 0, nums.size(), nums.size() &#x2F; 2);\n        ll sum &#x3D; 0;\n        for(auto k : nums)&#123;\n            sum+&#x3D; abs(k - nums[nums.size() &#x2F; 2]);\n        &#125;\n        return sum;\n    &#125;\n    \n    &#x2F;&#x2F; int partition(vector&lt;int&gt; &amp;nums, int s, int e)&#123;        \n    &#x2F;&#x2F;     int l &#x3D; s, r &#x3D; e - 1, temp &#x3D; nums[s];\n    &#x2F;&#x2F;     while(l &lt; r)&#123;\n    &#x2F;&#x2F;         while(l &lt; r &amp;&amp; nums[r] &gt;&#x3D; temp) --r;\n    &#x2F;&#x2F;         swap(nums[r], nums[l]);\n    &#x2F;&#x2F;         while(l &lt; r &amp;&amp; nums[l] &lt;&#x3D; temp) ++l;\n    &#x2F;&#x2F;         swap(nums[r], nums[l]);\n    &#x2F;&#x2F;     &#125;\n    &#x2F;&#x2F;     &#x2F;&#x2F; nums[l] &#x3D; temp;\n    &#x2F;&#x2F;     return l;\n    &#x2F;&#x2F; &#125;\n\n    &#x2F;&#x2F; 该算法基于一种朴素的想法：把小的前面，大的放后面\n    int partition(vector&lt;int&gt; &amp;nums, int s, int e)&#123;     \n        int i &#x3D; s, pivot &#x3D; nums[e - 1];\n        for(int j &#x3D; s; j &lt; e; ++j)&#123;\n            if(nums[j] &lt; pivot)&#123;\n                swap(nums[i], nums[j]);\n                ++i;\n            &#125;\n        &#125;\n        swap(nums[i], nums[e - 1]);\n        return i;\n    &#125;\n    void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k)&#123;\n        if(s &#x3D;&#x3D; e) return;\n        int idx &#x3D; partition(nums, s, e);\n        if(idx &#x3D;&#x3D; k) return;\n        else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k);\n        else my_nth_element(nums, s, idx, k); &#x2F;&#x2F; bugs, e 是边界， 所以不能取 s - 1\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"470. Implement Rand10() Using Rand7()","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-15T01:20:43.000Z","_content":"\n\n\n## [470. Implement Rand10() Using Rand7()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)\n\n\n\n## 思路：\n\n利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等\n\n<!-- more -->\n\n\n\n## 代码：\n\n第一次wa是因没有考虑取余后映射的数字的生成概率不等了。\n\n\n\n```c++\n// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    //利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等\n    int rand10() {\n        int c;\n        do{            \n            int a = rand7()- 1;\n            int b = rand7() - 1;\n            c = a * 7 + b;\n        }while(c >= 40);\n        return c % 10 + 1;\n    }\n};\n```","source":"_posts/刷题/数学\n/470-Implement-Rand10-Using-Rand7.md","raw":"---\ntitle: 470. Implement Rand10() Using Rand7()\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-15 09:20:43\n---\n\n\n\n## [470. Implement Rand10() Using Rand7()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)\n\n\n\n## 思路：\n\n利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等\n\n<!-- more -->\n\n\n\n## 代码：\n\n第一次wa是因没有考虑取余后映射的数字的生成概率不等了。\n\n\n\n```c++\n// The rand7() API is already defined for you.\n// int rand7();\n// @return a random integer in the range 1 to 7\n\nclass Solution {\npublic:\n    //利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等\n    int rand10() {\n        int c;\n        do{            \n            int a = rand7()- 1;\n            int b = rand7() - 1;\n            c = a * 7 + b;\n        }while(c >= 40);\n        return c % 10 + 1;\n    }\n};\n```","slug":"刷题-数学-470-Implement-Rand10-Using-Rand7","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5i0036l5uodbh9hj3j","content":"<h2 id=\"470-Implement-Rand10-Using-Rand7\"><a href=\"#470-Implement-Rand10-Using-Rand7\" class=\"headerlink\" title=\"470. Implement Rand10() Using Rand7()\"></a><a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/\">470. Implement Rand10() Using Rand7()</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>第一次wa是因没有考虑取余后映射的数字的生成概率不等了。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; The rand7() API is already defined for you.\n&#x2F;&#x2F; int rand7();\n&#x2F;&#x2F; @return a random integer in the range 1 to 7\n\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等\n    int rand10() &#123;\n        int c;\n        do&#123;            \n            int a &#x3D; rand7()- 1;\n            int b &#x3D; rand7() - 1;\n            c &#x3D; a * 7 + b;\n        &#125;while(c &gt;&#x3D; 40);\n        return c % 10 + 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2JN8Y54","excerpt":"<h2 id=\"470-Implement-Rand10-Using-Rand7\"><a href=\"#470-Implement-Rand10-Using-Rand7\" class=\"headerlink\" title=\"470. Implement Rand10() Using Rand7()\"></a><a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/\">470. Implement Rand10() Using Rand7()</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>第一次wa是因没有考虑取余后映射的数字的生成概率不等了。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; The rand7() API is already defined for you.\n&#x2F;&#x2F; int rand7();\n&#x2F;&#x2F; @return a random integer in the range 1 to 7\n\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;利用7进制生成等概率数值，同时限制生成数的范围，保证取余的范围内各个余数的生成概率相等\n    int rand10() &#123;\n        int c;\n        do&#123;            \n            int a &#x3D; rand7()- 1;\n            int b &#x3D; rand7() - 1;\n            c &#x3D; a * 7 + b;\n        &#125;while(c &gt;&#x3D; 40);\n        return c % 10 + 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"504. Base 7","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-07T03:28:47.000Z","_content":"\n## [504. Base 7](https://leetcode-cn.com/problems/base-7/)\n\n## 思路：\n\n利用取余和求模获取各个位的数值，要注意零，正负符号，数字大小（可能会溢出）等条件。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    string convertToBase7(int num) {\n        if(num == 0) return \"0\";        \n        string res , flag;\n        if( num < 0){\n            flag = \"-\";\n            num = -num;\n        }\n        while(num){\n            int w = num % 7;\n            num = num / 7;\n            res =  char('0' + w) + res; //这里的强制类型转换是必要的\n        }\n        return flag + res;\n    }\n};\n\n```\n\n","source":"_posts/刷题/数学\n/504-Base-7.md","raw":"---\ntitle: 504. Base 7\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-07 11:28:47\n---\n\n## [504. Base 7](https://leetcode-cn.com/problems/base-7/)\n\n## 思路：\n\n利用取余和求模获取各个位的数值，要注意零，正负符号，数字大小（可能会溢出）等条件。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    string convertToBase7(int num) {\n        if(num == 0) return \"0\";        \n        string res , flag;\n        if( num < 0){\n            flag = \"-\";\n            num = -num;\n        }\n        while(num){\n            int w = num % 7;\n            num = num / 7;\n            res =  char('0' + w) + res; //这里的强制类型转换是必要的\n        }\n        return flag + res;\n    }\n};\n\n```\n\n","slug":"刷题-数学-504-Base-7","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5j0037l5uo7jba9xmb","content":"<h2 id=\"504-Base-7\"><a href=\"#504-Base-7\" class=\"headerlink\" title=\"504. Base 7\"></a><a href=\"https://leetcode-cn.com/problems/base-7/\">504. Base 7</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用取余和求模获取各个位的数值，要注意零，正负符号，数字大小（可能会溢出）等条件。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convertToBase7(int num) &#123;\n        if(num &#x3D;&#x3D; 0) return &quot;0&quot;;        \n        string res , flag;\n        if( num &lt; 0)&#123;\n            flag &#x3D; &quot;-&quot;;\n            num &#x3D; -num;\n        &#125;\n        while(num)&#123;\n            int w &#x3D; num % 7;\n            num &#x3D; num &#x2F; 7;\n            res &#x3D;  char(&#39;0&#39; + w) + res; &#x2F;&#x2F;这里的强制类型转换是必要的\n        &#125;\n        return flag + res;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3VBGZH2","excerpt":"<h2 id=\"504-Base-7\"><a href=\"#504-Base-7\" class=\"headerlink\" title=\"504. Base 7\"></a><a href=\"https://leetcode-cn.com/problems/base-7/\">504. Base 7</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用取余和求模获取各个位的数值，要注意零，正负符号，数字大小（可能会溢出）等条件。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string convertToBase7(int num) &#123;\n        if(num &#x3D;&#x3D; 0) return &quot;0&quot;;        \n        string res , flag;\n        if( num &lt; 0)&#123;\n            flag &#x3D; &quot;-&quot;;\n            num &#x3D; -num;\n        &#125;\n        while(num)&#123;\n            int w &#x3D; num % 7;\n            num &#x3D; num &#x2F; 7;\n            res &#x3D;  char(&#39;0&#39; + w) + res; &#x2F;&#x2F;这里的强制类型转换是必要的\n        &#125;\n        return flag + res;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"528. Random Pick with Weight","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-10T02:05:09.000Z","_content":"\n\n\n\n## [528. Random Pick with Weight](https://leetcode-cn.com/problems/random-pick-with-weight/)\n\n## 思路：\n\n通过前缀和映射权重到数组，方便通过二分查找进行随机抽取。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    vector<int> w;\n    int n;\n    int mod;\npublic:\n    Solution(vector<int>& _w) : w(_w) {\n        int sum = 0;\n        for(auto &i : w){\n            sum += i;\n            i = sum;\n        }\n        mod = sum;\n        n = w.size();\n    }\n    \n    int pickIndex() {\n        int s = rand() % mod; // 在[0, sum) 随机抽取一个数，作为映射下标\n        auto it = lower_bound(w.begin(), w.end(), s); // find the first iterator that this element is not less the value; value <= (*it)\n        if(*it == s) it++;\n        return it - w.begin();\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(w);\n * int param_1 = obj->pickIndex();\n */\n```\n\n手写二分\n\n```c++\nclass Solution {\n    vector<int> w;\n    int n;\n    int mod;\npublic:\n    Solution(vector<int>& _w) : w(_w) {\n        int sum = 0;\n        for(auto &i : w){\n            sum += i;\n            i = sum;\n        }\n        mod = sum;\n        n = w.size();\n    }\n    \n    int pickIndex() {\n        int s = rand() % mod; // 在[0, sum) 随机抽取一个数，作为映射下标\n        int l = 0, r = n - 1;\n        while(l < r){\n            int mid = (r - l) / 2 + l;\n            if(w[mid] <= s) l = mid + 1;\n            else r = mid;\n        }\n        return r;\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(w);\n * int param_1 = obj->pickIndex();\n */\n```","source":"_posts/刷题/数学\n/528-Random-Pick-with-Weight.md","raw":"---\ntitle: 528. Random Pick with Weight\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-10 10:05:09\n---\n\n\n\n\n## [528. Random Pick with Weight](https://leetcode-cn.com/problems/random-pick-with-weight/)\n\n## 思路：\n\n通过前缀和映射权重到数组，方便通过二分查找进行随机抽取。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    vector<int> w;\n    int n;\n    int mod;\npublic:\n    Solution(vector<int>& _w) : w(_w) {\n        int sum = 0;\n        for(auto &i : w){\n            sum += i;\n            i = sum;\n        }\n        mod = sum;\n        n = w.size();\n    }\n    \n    int pickIndex() {\n        int s = rand() % mod; // 在[0, sum) 随机抽取一个数，作为映射下标\n        auto it = lower_bound(w.begin(), w.end(), s); // find the first iterator that this element is not less the value; value <= (*it)\n        if(*it == s) it++;\n        return it - w.begin();\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(w);\n * int param_1 = obj->pickIndex();\n */\n```\n\n手写二分\n\n```c++\nclass Solution {\n    vector<int> w;\n    int n;\n    int mod;\npublic:\n    Solution(vector<int>& _w) : w(_w) {\n        int sum = 0;\n        for(auto &i : w){\n            sum += i;\n            i = sum;\n        }\n        mod = sum;\n        n = w.size();\n    }\n    \n    int pickIndex() {\n        int s = rand() % mod; // 在[0, sum) 随机抽取一个数，作为映射下标\n        int l = 0, r = n - 1;\n        while(l < r){\n            int mid = (r - l) / 2 + l;\n            if(w[mid] <= s) l = mid + 1;\n            else r = mid;\n        }\n        return r;\n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(w);\n * int param_1 = obj->pickIndex();\n */\n```","slug":"刷题-数学-528-Random-Pick-with-Weight","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5k0038l5uodjhw8joj","content":"<h2 id=\"528-Random-Pick-with-Weight\"><a href=\"#528-Random-Pick-with-Weight\" class=\"headerlink\" title=\"528. Random Pick with Weight\"></a><a href=\"https://leetcode-cn.com/problems/random-pick-with-weight/\">528. Random Pick with Weight</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>通过前缀和映射权重到数组，方便通过二分查找进行随机抽取。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;int&gt; w;\n    int n;\n    int mod;\npublic:\n    Solution(vector&lt;int&gt;&amp; _w) : w(_w) &#123;\n        int sum &#x3D; 0;\n        for(auto &amp;i : w)&#123;\n            sum +&#x3D; i;\n            i &#x3D; sum;\n        &#125;\n        mod &#x3D; sum;\n        n &#x3D; w.size();\n    &#125;\n    \n    int pickIndex() &#123;\n        int s &#x3D; rand() % mod; &#x2F;&#x2F; 在[0, sum) 随机抽取一个数，作为映射下标\n        auto it &#x3D; lower_bound(w.begin(), w.end(), s); &#x2F;&#x2F; find the first iterator that this element is not less the value; value &lt;&#x3D; (*it)\n        if(*it &#x3D;&#x3D; s) it++;\n        return it - w.begin();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(w);\n * int param_1 &#x3D; obj-&gt;pickIndex();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>手写二分</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;int&gt; w;\n    int n;\n    int mod;\npublic:\n    Solution(vector&lt;int&gt;&amp; _w) : w(_w) &#123;\n        int sum &#x3D; 0;\n        for(auto &amp;i : w)&#123;\n            sum +&#x3D; i;\n            i &#x3D; sum;\n        &#125;\n        mod &#x3D; sum;\n        n &#x3D; w.size();\n    &#125;\n    \n    int pickIndex() &#123;\n        int s &#x3D; rand() % mod; &#x2F;&#x2F; 在[0, sum) 随机抽取一个数，作为映射下标\n        int l &#x3D; 0, r &#x3D; n - 1;\n        while(l &lt; r)&#123;\n            int mid &#x3D; (r - l) &#x2F; 2 + l;\n            if(w[mid] &lt;&#x3D; s) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(w);\n * int param_1 &#x3D; obj-&gt;pickIndex();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"12EZ5HT","excerpt":"<h2 id=\"528-Random-Pick-with-Weight\"><a href=\"#528-Random-Pick-with-Weight\" class=\"headerlink\" title=\"528. Random Pick with Weight\"></a><a href=\"https://leetcode-cn.com/problems/random-pick-with-weight/\">528. Random Pick with Weight</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>通过前缀和映射权重到数组，方便通过二分查找进行随机抽取。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;int&gt; w;\n    int n;\n    int mod;\npublic:\n    Solution(vector&lt;int&gt;&amp; _w) : w(_w) &#123;\n        int sum &#x3D; 0;\n        for(auto &amp;i : w)&#123;\n            sum +&#x3D; i;\n            i &#x3D; sum;\n        &#125;\n        mod &#x3D; sum;\n        n &#x3D; w.size();\n    &#125;\n    \n    int pickIndex() &#123;\n        int s &#x3D; rand() % mod; &#x2F;&#x2F; 在[0, sum) 随机抽取一个数，作为映射下标\n        auto it &#x3D; lower_bound(w.begin(), w.end(), s); &#x2F;&#x2F; find the first iterator that this element is not less the value; value &lt;&#x3D; (*it)\n        if(*it &#x3D;&#x3D; s) it++;\n        return it - w.begin();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(w);\n * int param_1 &#x3D; obj-&gt;pickIndex();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>手写二分</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;int&gt; w;\n    int n;\n    int mod;\npublic:\n    Solution(vector&lt;int&gt;&amp; _w) : w(_w) &#123;\n        int sum &#x3D; 0;\n        for(auto &amp;i : w)&#123;\n            sum +&#x3D; i;\n            i &#x3D; sum;\n        &#125;\n        mod &#x3D; sum;\n        n &#x3D; w.size();\n    &#125;\n    \n    int pickIndex() &#123;\n        int s &#x3D; rand() % mod; &#x2F;&#x2F; 在[0, sum) 随机抽取一个数，作为映射下标\n        int l &#x3D; 0, r &#x3D; n - 1;\n        while(l &lt; r)&#123;\n            int mid &#x3D; (r - l) &#x2F; 2 + l;\n            if(w[mid] &lt;&#x3D; s) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n        return r;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj &#x3D; new Solution(w);\n * int param_1 &#x3D; obj-&gt;pickIndex();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"67. Add Binary","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-12T03:10:02.000Z","_content":"\n\n\n\n## [67. Add Binary](https://leetcode-cn.com/problems/add-binary/)\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        if(a == \"\" || b == \"\") return a == \"\" ? b : a;\n        int i = a.size() - 1, j = b.size() - 1, add = 0;\n        string ans = \"\";\n        while(i >= 0 || j >= 0){\n            int numa = i < 0 ? 0 : a[i] - '0';\n            int numb = j < 0 ? 0 : b[j] - '0';\n            --i, --j;\n            int sum = numa + numb + add;\n            add = sum / 2;\n            sum %= 2;\n            ans.push_back(sum + '0');\n        }\n        if(add){\n            ans.push_back(add + '0');\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    }\n};\n```","source":"_posts/刷题/数学\n/67-Add-Binary.md","raw":"---\ntitle: 67. Add Binary\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-12 11:10:02\n---\n\n\n\n\n## [67. Add Binary](https://leetcode-cn.com/problems/add-binary/)\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        if(a == \"\" || b == \"\") return a == \"\" ? b : a;\n        int i = a.size() - 1, j = b.size() - 1, add = 0;\n        string ans = \"\";\n        while(i >= 0 || j >= 0){\n            int numa = i < 0 ? 0 : a[i] - '0';\n            int numb = j < 0 ? 0 : b[j] - '0';\n            --i, --j;\n            int sum = numa + numb + add;\n            add = sum / 2;\n            sum %= 2;\n            ans.push_back(sum + '0');\n        }\n        if(add){\n            ans.push_back(add + '0');\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    }\n};\n```","slug":"刷题-数学-67-Add-Binary","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5k0039l5uodix7evso","content":"<h2 id=\"67-Add-Binary\"><a href=\"#67-Add-Binary\" class=\"headerlink\" title=\"67. Add Binary\"></a><a href=\"https://leetcode-cn.com/problems/add-binary/\">67. Add Binary</a></h2><span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string addBinary(string a, string b) &#123;\n        if(a &#x3D;&#x3D; &quot;&quot; || b &#x3D;&#x3D; &quot;&quot;) return a &#x3D;&#x3D; &quot;&quot; ? b : a;\n        int i &#x3D; a.size() - 1, j &#x3D; b.size() - 1, add &#x3D; 0;\n        string ans &#x3D; &quot;&quot;;\n        while(i &gt;&#x3D; 0 || j &gt;&#x3D; 0)&#123;\n            int numa &#x3D; i &lt; 0 ? 0 : a[i] - &#39;0&#39;;\n            int numb &#x3D; j &lt; 0 ? 0 : b[j] - &#39;0&#39;;\n            --i, --j;\n            int sum &#x3D; numa + numb + add;\n            add &#x3D; sum &#x2F; 2;\n            sum %&#x3D; 2;\n            ans.push_back(sum + &#39;0&#39;);\n        &#125;\n        if(add)&#123;\n            ans.push_back(add + &#39;0&#39;);\n        &#125;\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"A5RZ7R","excerpt":"<h2 id=\"67-Add-Binary\"><a href=\"#67-Add-Binary\" class=\"headerlink\" title=\"67. Add Binary\"></a><a href=\"https://leetcode-cn.com/problems/add-binary/\">67. Add Binary</a></h2>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string addBinary(string a, string b) &#123;\n        if(a &#x3D;&#x3D; &quot;&quot; || b &#x3D;&#x3D; &quot;&quot;) return a &#x3D;&#x3D; &quot;&quot; ? b : a;\n        int i &#x3D; a.size() - 1, j &#x3D; b.size() - 1, add &#x3D; 0;\n        string ans &#x3D; &quot;&quot;;\n        while(i &gt;&#x3D; 0 || j &gt;&#x3D; 0)&#123;\n            int numa &#x3D; i &lt; 0 ? 0 : a[i] - &#39;0&#39;;\n            int numb &#x3D; j &lt; 0 ? 0 : b[j] - &#39;0&#39;;\n            --i, --j;\n            int sum &#x3D; numa + numb + add;\n            add &#x3D; sum &#x2F; 2;\n            sum %&#x3D; 2;\n            ans.push_back(sum + &#39;0&#39;);\n        &#125;\n        if(add)&#123;\n            ans.push_back(add + &#39;0&#39;);\n        &#125;\n        reverse(ans.begin(), ans.end());\n        return ans;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"972.Equal Rational Numbers","thumbnail":"http://static.come2rss.xyz/紫色石楠.jpg","toc":true,"top":5,"date":"2020-09-21T01:59:40.000Z","_content":"\n\n\n\n\n#### [972. Equal Rational Numbers](https://leetcode-cn.com/problems/equal-rational-numbers/)\n\n思路不止一种，老老实实敲敲代码但不想优化方法的人是没有前途的。\n\n<!-- more -->\n\n## 思路：\n\n第一种：按字符匹配模式分类讨论\n\n+ 两个字符串都没有重复字符串：直接去尾零比较相等值。\n+ 只有一个字符串有重复字符串：只有一种情况可以相等，就是题目中无限接近的情况，比如“0.9(9)==1.0”。当然可以用数学证明的，两者相等。用语言描述比较麻烦，意会吧。\n+ 两个字符串都有重复字符串：将重复字符串展开多次，尽可能比较相同长度内容即可。\n\n第二种：化为数值法！\n\n重复模式串的数值部分可以计算,比如：\n$$\n0.00(66)=\\frac{1}{100} + \\frac{66}{100} + \\frac{66}{10000}\\cdots\n$$\n那么一般就有\n$$\n0.(s) = \\frac{s}{10^k }+ \\frac{s}{10^{2k} \\cdots} \\\\\\\\\n= s*(\\frac{1}{10^k} + \\frac{1}{10^{2k}} \\cdots)\\\\\\\\\n= s * (limt_{ \\ n\\rightarrow\\infty}\\frac{\\frac{1}{10^k}-\\frac{1}{(10^k)^n}}{1-\\frac{1}{10^k}})\\\\\\\\\\\n= s * \\frac{\\frac{1}{10^k}}{1-\\frac{1}{10^k}}\\\\\\\\\nwhich\\ k \\ is \\ the\\ len\\ of\\ s.\n$$\n非重复部分更容易计算。\n\n那么之后用分数类来计算结果即可。\n\n\n\n## 代码：\n\n老实人代码\n\n```c++\nclass Solution {\npublic:\n\n\n//  if find() cant find the char or string, it will retunr str::string::npos;\n// static const size_t npos = -1;  the size_t is unsigned int type. \n\n    \n    void getNum(string input, string &integerS, string &nonreS, string &reS){\n        int pointPos = input.find(\".\");\n        if(pointPos != string::npos)\n            integerS = input.substr(0, pointPos);\n        else{\n            integerS = input;\n            nonreS = reS = \"\";\n            return;\n        } \n\n        int parPos = input.find(\"(\");\n        if(parPos != string::npos){\n            nonreS = input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        }else{\n            nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS = \"\"; \n        }\n\n        if( reS == \"\" || stol(reS) == 0){\n            reS = \"\";\n            int pos =  nonreS.size() - 1;\n            while(pos >= 0 && nonreS[pos] == '0') pos--;\n            if(pos >= 0) nonreS = nonreS.substr(0, pos + 1);\n            else nonreS = \"\";\n            if(integerS == \"\" || stol(integerS) == 0) integerS = \"0\";\n        } \n    }\n    \n    bool isNineNum(string S){\n        for(int i = 0; i < S.size(); i++)\n        {\n            if(S[i] != '9') return false;\n        }\n        return true;\n    }   \n\n\n    string strmul(string s, int time){\n        string res = \"\";\n        for(int i = 0; i < time; i++){\n            res += s;\n        }\n        return res;\n    }\n    //must comfire reS2 == \"\"\n    bool isfiniteEqual(string integerS1, string nonreS1, string reS1, string integerS2, string nonreS2, string reS2){    \n        if(!isNineNum(reS1) || reS2.size() != 0) return false;\n\n        int pos = nonreS1.size() - 1;\n        for(;pos >= 0; pos --){\n            if(nonreS1[pos] != '9') break;\n        }\n        if(nonreS2.size() != pos + 1) return false;\n\n        int num1 = stol(integerS1 + nonreS1.substr(0, pos + 1));\n        int num2 = stol(integerS2 + nonreS2);\n        if(num1 + 1 != num2) return false;\n        return true;\n    }\n\n    bool ispartEqual(string s1, string s2){\n        //\n        cout << s1 << endl << s2 << endl;\n        if(s1.size() > s2.size()) return false;\n        if(s2.substr(0, s1.size()) == s1) return true;\n        return false;\n    }\n\n\n    bool isRationalEqual(string S, string T) {\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        if(reS1.size() == 0 && reS2.size() == 0){\n            if(integerS1 == integerS2 && nonreS1 == nonreS2) return true;\n        }\n        else if(reS1.size() == 0 || reS2.size() == 0){\n            if(isfiniteEqual(integerS1, nonreS1, reS1, integerS2, nonreS2, reS2) \n            || isfiniteEqual(integerS2, nonreS2, reS2, integerS1, nonreS1, reS1))\n                 return true;\n        }\n        else{\n            int l1 = reS1.size(), l2= reS2.size();\n            string str1 = integerS1 + nonreS1 + strmul(reS1, reS2.size() + 2);\n            string str2 = integerS2 + nonreS2 + strmul(reS2, reS1.size() + 2);\n            if(ispartEqual(str1, str2) || ispartEqual(str2, str1)) return true;\n        }\n        return false;\n    }\n};\n```\n\n数值计算\n\n\n\n弱鸡的代码\n\n```c++\ntypedef long long ll;\nclass fraction{\npublic:\n    ll n, d;\n    fraction(ll _n, ll _d){\n        n = _n;\n        d = _d;\n        if(_d  == 0) d = 1;\n      }\n\n    void add(fraction s){\n        n = n * s.d + d * s.n;\n        d *= s.d;\n         clear();\n        print(fraction(n, d));\n        print(s);\n    }\n\n    bool equal(fraction s){            \n        if(s.d == d && s.n == n) return true;\n        return false;\n    }\n\nprivate:\n    ll gcd(ll a, ll b){\n        return b?gcd(b, a%b):a;\n    }\n    void clear(){\n        int gcdN = 1;\n        if(n == 0)   \n            gcdN = 1;\n        else   \n            gcdN = gcd(d , n);\n        n /= gcdN;\n        d /= gcdN;\n        if(n == 0) d = 1;\n    }\n\n};\n\n\n// \nclass Solution {\npublic:\n\n    void getNum(string input, string &integerS, string &nonreS, string &reS){\n        int pointPos = input.find(\".\");\n        if(pointPos != string::npos)\n            integerS = input.substr(0, pointPos);\n        else{\n            integerS = input;\n            nonreS = reS = \"\";\n            return;\n        } \n\n        int parPos = input.find(\"(\");\n        if(parPos != string::npos){\n            nonreS = input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        }else{\n            nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS = \"\"; \n        }\n\n    }\n    \n    ll pow10(ll l){\n        ll ans = 1;\n        while(l > 0){\n            ans *= 10;\n            l--;\n        }\n        return ans;\n    }\n\n    ll mystol(string s){\n        if(s == \"\") return 0;\n        else return stol(s);\n    }\n\n    fraction getFraction(string integer, string nonreS, string reS){\n        \n        fraction no1 = fraction(mystol(integer), 1);\n        int nonreLen = nonreS.size();\n        int reLen = reS.size();\n        fraction no2 = fraction(mystol(nonreS), pow10(nonreLen));\n        fraction no3 = fraction(mystol(reS), pow10(nonreLen) * (pow10(reLen) - 1) );\n\n        no1.add(no2);\n        no1.add(no3);\n        return no1;\n    }\n\n    bool isRationalEqual(string S, string T) {\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        \n        fraction frac1 = getFraction(integerS1, nonreS1, reS1);\n        fraction frac2 = getFraction(integerS2, nonreS2, reS2);\n        if(frac1.equal(frac2)) return true;\n        return false;\n    }\n};\n```\n\n","source":"_posts/刷题/数学\n/972-Equal-Rational-Numbers.md","raw":"---\ntitle: 972.Equal Rational Numbers\nthumbnail: 'http://static.come2rss.xyz/紫色石楠.jpg'\ntoc: true\ntop: 5\ntags:\ncategories:\ndate: 2020-09-21 09:59:40\n---\n\n\n\n\n\n#### [972. Equal Rational Numbers](https://leetcode-cn.com/problems/equal-rational-numbers/)\n\n思路不止一种，老老实实敲敲代码但不想优化方法的人是没有前途的。\n\n<!-- more -->\n\n## 思路：\n\n第一种：按字符匹配模式分类讨论\n\n+ 两个字符串都没有重复字符串：直接去尾零比较相等值。\n+ 只有一个字符串有重复字符串：只有一种情况可以相等，就是题目中无限接近的情况，比如“0.9(9)==1.0”。当然可以用数学证明的，两者相等。用语言描述比较麻烦，意会吧。\n+ 两个字符串都有重复字符串：将重复字符串展开多次，尽可能比较相同长度内容即可。\n\n第二种：化为数值法！\n\n重复模式串的数值部分可以计算,比如：\n$$\n0.00(66)=\\frac{1}{100} + \\frac{66}{100} + \\frac{66}{10000}\\cdots\n$$\n那么一般就有\n$$\n0.(s) = \\frac{s}{10^k }+ \\frac{s}{10^{2k} \\cdots} \\\\\\\\\n= s*(\\frac{1}{10^k} + \\frac{1}{10^{2k}} \\cdots)\\\\\\\\\n= s * (limt_{ \\ n\\rightarrow\\infty}\\frac{\\frac{1}{10^k}-\\frac{1}{(10^k)^n}}{1-\\frac{1}{10^k}})\\\\\\\\\\\n= s * \\frac{\\frac{1}{10^k}}{1-\\frac{1}{10^k}}\\\\\\\\\nwhich\\ k \\ is \\ the\\ len\\ of\\ s.\n$$\n非重复部分更容易计算。\n\n那么之后用分数类来计算结果即可。\n\n\n\n## 代码：\n\n老实人代码\n\n```c++\nclass Solution {\npublic:\n\n\n//  if find() cant find the char or string, it will retunr str::string::npos;\n// static const size_t npos = -1;  the size_t is unsigned int type. \n\n    \n    void getNum(string input, string &integerS, string &nonreS, string &reS){\n        int pointPos = input.find(\".\");\n        if(pointPos != string::npos)\n            integerS = input.substr(0, pointPos);\n        else{\n            integerS = input;\n            nonreS = reS = \"\";\n            return;\n        } \n\n        int parPos = input.find(\"(\");\n        if(parPos != string::npos){\n            nonreS = input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        }else{\n            nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS = \"\"; \n        }\n\n        if( reS == \"\" || stol(reS) == 0){\n            reS = \"\";\n            int pos =  nonreS.size() - 1;\n            while(pos >= 0 && nonreS[pos] == '0') pos--;\n            if(pos >= 0) nonreS = nonreS.substr(0, pos + 1);\n            else nonreS = \"\";\n            if(integerS == \"\" || stol(integerS) == 0) integerS = \"0\";\n        } \n    }\n    \n    bool isNineNum(string S){\n        for(int i = 0; i < S.size(); i++)\n        {\n            if(S[i] != '9') return false;\n        }\n        return true;\n    }   \n\n\n    string strmul(string s, int time){\n        string res = \"\";\n        for(int i = 0; i < time; i++){\n            res += s;\n        }\n        return res;\n    }\n    //must comfire reS2 == \"\"\n    bool isfiniteEqual(string integerS1, string nonreS1, string reS1, string integerS2, string nonreS2, string reS2){    \n        if(!isNineNum(reS1) || reS2.size() != 0) return false;\n\n        int pos = nonreS1.size() - 1;\n        for(;pos >= 0; pos --){\n            if(nonreS1[pos] != '9') break;\n        }\n        if(nonreS2.size() != pos + 1) return false;\n\n        int num1 = stol(integerS1 + nonreS1.substr(0, pos + 1));\n        int num2 = stol(integerS2 + nonreS2);\n        if(num1 + 1 != num2) return false;\n        return true;\n    }\n\n    bool ispartEqual(string s1, string s2){\n        //\n        cout << s1 << endl << s2 << endl;\n        if(s1.size() > s2.size()) return false;\n        if(s2.substr(0, s1.size()) == s1) return true;\n        return false;\n    }\n\n\n    bool isRationalEqual(string S, string T) {\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        if(reS1.size() == 0 && reS2.size() == 0){\n            if(integerS1 == integerS2 && nonreS1 == nonreS2) return true;\n        }\n        else if(reS1.size() == 0 || reS2.size() == 0){\n            if(isfiniteEqual(integerS1, nonreS1, reS1, integerS2, nonreS2, reS2) \n            || isfiniteEqual(integerS2, nonreS2, reS2, integerS1, nonreS1, reS1))\n                 return true;\n        }\n        else{\n            int l1 = reS1.size(), l2= reS2.size();\n            string str1 = integerS1 + nonreS1 + strmul(reS1, reS2.size() + 2);\n            string str2 = integerS2 + nonreS2 + strmul(reS2, reS1.size() + 2);\n            if(ispartEqual(str1, str2) || ispartEqual(str2, str1)) return true;\n        }\n        return false;\n    }\n};\n```\n\n数值计算\n\n\n\n弱鸡的代码\n\n```c++\ntypedef long long ll;\nclass fraction{\npublic:\n    ll n, d;\n    fraction(ll _n, ll _d){\n        n = _n;\n        d = _d;\n        if(_d  == 0) d = 1;\n      }\n\n    void add(fraction s){\n        n = n * s.d + d * s.n;\n        d *= s.d;\n         clear();\n        print(fraction(n, d));\n        print(s);\n    }\n\n    bool equal(fraction s){            \n        if(s.d == d && s.n == n) return true;\n        return false;\n    }\n\nprivate:\n    ll gcd(ll a, ll b){\n        return b?gcd(b, a%b):a;\n    }\n    void clear(){\n        int gcdN = 1;\n        if(n == 0)   \n            gcdN = 1;\n        else   \n            gcdN = gcd(d , n);\n        n /= gcdN;\n        d /= gcdN;\n        if(n == 0) d = 1;\n    }\n\n};\n\n\n// \nclass Solution {\npublic:\n\n    void getNum(string input, string &integerS, string &nonreS, string &reS){\n        int pointPos = input.find(\".\");\n        if(pointPos != string::npos)\n            integerS = input.substr(0, pointPos);\n        else{\n            integerS = input;\n            nonreS = reS = \"\";\n            return;\n        } \n\n        int parPos = input.find(\"(\");\n        if(parPos != string::npos){\n            nonreS = input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        }else{\n            nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS = \"\"; \n        }\n\n    }\n    \n    ll pow10(ll l){\n        ll ans = 1;\n        while(l > 0){\n            ans *= 10;\n            l--;\n        }\n        return ans;\n    }\n\n    ll mystol(string s){\n        if(s == \"\") return 0;\n        else return stol(s);\n    }\n\n    fraction getFraction(string integer, string nonreS, string reS){\n        \n        fraction no1 = fraction(mystol(integer), 1);\n        int nonreLen = nonreS.size();\n        int reLen = reS.size();\n        fraction no2 = fraction(mystol(nonreS), pow10(nonreLen));\n        fraction no3 = fraction(mystol(reS), pow10(nonreLen) * (pow10(reLen) - 1) );\n\n        no1.add(no2);\n        no1.add(no3);\n        return no1;\n    }\n\n    bool isRationalEqual(string S, string T) {\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        \n        fraction frac1 = getFraction(integerS1, nonreS1, reS1);\n        fraction frac2 = getFraction(integerS2, nonreS2, reS2);\n        if(frac1.equal(frac2)) return true;\n        return false;\n    }\n};\n```\n\n","slug":"刷题-数学-972-Equal-Rational-Numbers","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5l003al5uoe4dt82m4","content":"<h4 id=\"972-Equal-Rational-Numbers\"><a href=\"#972-Equal-Rational-Numbers\" class=\"headerlink\" title=\"972. Equal Rational Numbers\"></a><a href=\"https://leetcode-cn.com/problems/equal-rational-numbers/\">972. Equal Rational Numbers</a></h4><p>思路不止一种，老老实实敲敲代码但不想优化方法的人是没有前途的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>第一种：按字符匹配模式分类讨论</p>\n<ul>\n<li>两个字符串都没有重复字符串：直接去尾零比较相等值。</li>\n<li>只有一个字符串有重复字符串：只有一种情况可以相等，就是题目中无限接近的情况，比如“0.9(9)==1.0”。当然可以用数学证明的，两者相等。用语言描述比较麻烦，意会吧。</li>\n<li>两个字符串都有重复字符串：将重复字符串展开多次，尽可能比较相同长度内容即可。</li>\n</ul>\n<p>第二种：化为数值法！</p>\n<p>重复模式串的数值部分可以计算,比如：<br>$$<br>0.00(66)=\\frac{1}{100} + \\frac{66}{100} + \\frac{66}{10000}\\cdots<br>$$<br>那么一般就有<br>$$<br>0.(s) = \\frac{s}{10^k }+ \\frac{s}{10^{2k} \\cdots} \\\\<br>= s*(\\frac{1}{10^k} + \\frac{1}{10^{2k}} \\cdots)\\\\<br>= s * (limt_{ \\ n\\rightarrow\\infty}\\frac{\\frac{1}{10^k}-\\frac{1}{(10^k)^n}}{1-\\frac{1}{10^k}})\\\\<br>= s * \\frac{\\frac{1}{10^k}}{1-\\frac{1}{10^k}}\\\\<br>which\\ k \\ is \\ the\\ len\\ of\\ s.<br>$$<br>非重复部分更容易计算。</p>\n<p>那么之后用分数类来计算结果即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>老实人代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n\n&#x2F;&#x2F;  if find() cant find the char or string, it will retunr str::string::npos;\n&#x2F;&#x2F; static const size_t npos &#x3D; -1;  the size_t is unsigned int type. \n\n    \n    void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS)&#123;\n        int pointPos &#x3D; input.find(&quot;.&quot;);\n        if(pointPos !&#x3D; string::npos)\n            integerS &#x3D; input.substr(0, pointPos);\n        else&#123;\n            integerS &#x3D; input;\n            nonreS &#x3D; reS &#x3D; &quot;&quot;;\n            return;\n        &#125; \n\n        int parPos &#x3D; input.find(&quot;(&quot;);\n        if(parPos !&#x3D; string::npos)&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS &#x3D; input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        &#125;else&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS &#x3D; &quot;&quot;; \n        &#125;\n\n        if( reS &#x3D;&#x3D; &quot;&quot; || stol(reS) &#x3D;&#x3D; 0)&#123;\n            reS &#x3D; &quot;&quot;;\n            int pos &#x3D;  nonreS.size() - 1;\n            while(pos &gt;&#x3D; 0 &amp;&amp; nonreS[pos] &#x3D;&#x3D; &#39;0&#39;) pos--;\n            if(pos &gt;&#x3D; 0) nonreS &#x3D; nonreS.substr(0, pos + 1);\n            else nonreS &#x3D; &quot;&quot;;\n            if(integerS &#x3D;&#x3D; &quot;&quot; || stol(integerS) &#x3D;&#x3D; 0) integerS &#x3D; &quot;0&quot;;\n        &#125; \n    &#125;\n    \n    bool isNineNum(string S)&#123;\n        for(int i &#x3D; 0; i &lt; S.size(); i++)\n        &#123;\n            if(S[i] !&#x3D; &#39;9&#39;) return false;\n        &#125;\n        return true;\n    &#125;   \n\n\n    string strmul(string s, int time)&#123;\n        string res &#x3D; &quot;&quot;;\n        for(int i &#x3D; 0; i &lt; time; i++)&#123;\n            res +&#x3D; s;\n        &#125;\n        return res;\n    &#125;\n    &#x2F;&#x2F;must comfire reS2 &#x3D;&#x3D; &quot;&quot;\n    bool isfiniteEqual(string integerS1, string nonreS1, string reS1, string integerS2, string nonreS2, string reS2)&#123;    \n        if(!isNineNum(reS1) || reS2.size() !&#x3D; 0) return false;\n\n        int pos &#x3D; nonreS1.size() - 1;\n        for(;pos &gt;&#x3D; 0; pos --)&#123;\n            if(nonreS1[pos] !&#x3D; &#39;9&#39;) break;\n        &#125;\n        if(nonreS2.size() !&#x3D; pos + 1) return false;\n\n        int num1 &#x3D; stol(integerS1 + nonreS1.substr(0, pos + 1));\n        int num2 &#x3D; stol(integerS2 + nonreS2);\n        if(num1 + 1 !&#x3D; num2) return false;\n        return true;\n    &#125;\n\n    bool ispartEqual(string s1, string s2)&#123;\n        &#x2F;&#x2F;\n        cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2 &lt;&lt; endl;\n        if(s1.size() &gt; s2.size()) return false;\n        if(s2.substr(0, s1.size()) &#x3D;&#x3D; s1) return true;\n        return false;\n    &#125;\n\n\n    bool isRationalEqual(string S, string T) &#123;\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        if(reS1.size() &#x3D;&#x3D; 0 &amp;&amp; reS2.size() &#x3D;&#x3D; 0)&#123;\n            if(integerS1 &#x3D;&#x3D; integerS2 &amp;&amp; nonreS1 &#x3D;&#x3D; nonreS2) return true;\n        &#125;\n        else if(reS1.size() &#x3D;&#x3D; 0 || reS2.size() &#x3D;&#x3D; 0)&#123;\n            if(isfiniteEqual(integerS1, nonreS1, reS1, integerS2, nonreS2, reS2) \n            || isfiniteEqual(integerS2, nonreS2, reS2, integerS1, nonreS1, reS1))\n                 return true;\n        &#125;\n        else&#123;\n            int l1 &#x3D; reS1.size(), l2&#x3D; reS2.size();\n            string str1 &#x3D; integerS1 + nonreS1 + strmul(reS1, reS2.size() + 2);\n            string str2 &#x3D; integerS2 + nonreS2 + strmul(reS2, reS1.size() + 2);\n            if(ispartEqual(str1, str2) || ispartEqual(str2, str1)) return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>数值计算</p>\n<p>弱鸡的代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef long long ll;\nclass fraction&#123;\npublic:\n    ll n, d;\n    fraction(ll _n, ll _d)&#123;\n        n &#x3D; _n;\n        d &#x3D; _d;\n        if(_d  &#x3D;&#x3D; 0) d &#x3D; 1;\n      &#125;\n\n    void add(fraction s)&#123;\n        n &#x3D; n * s.d + d * s.n;\n        d *&#x3D; s.d;\n         clear();\n        print(fraction(n, d));\n        print(s);\n    &#125;\n\n    bool equal(fraction s)&#123;            \n        if(s.d &#x3D;&#x3D; d &amp;&amp; s.n &#x3D;&#x3D; n) return true;\n        return false;\n    &#125;\n\nprivate:\n    ll gcd(ll a, ll b)&#123;\n        return b?gcd(b, a%b):a;\n    &#125;\n    void clear()&#123;\n        int gcdN &#x3D; 1;\n        if(n &#x3D;&#x3D; 0)   \n            gcdN &#x3D; 1;\n        else   \n            gcdN &#x3D; gcd(d , n);\n        n &#x2F;&#x3D; gcdN;\n        d &#x2F;&#x3D; gcdN;\n        if(n &#x3D;&#x3D; 0) d &#x3D; 1;\n    &#125;\n\n&#125;;\n\n\n&#x2F;&#x2F; \nclass Solution &#123;\npublic:\n\n    void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS)&#123;\n        int pointPos &#x3D; input.find(&quot;.&quot;);\n        if(pointPos !&#x3D; string::npos)\n            integerS &#x3D; input.substr(0, pointPos);\n        else&#123;\n            integerS &#x3D; input;\n            nonreS &#x3D; reS &#x3D; &quot;&quot;;\n            return;\n        &#125; \n\n        int parPos &#x3D; input.find(&quot;(&quot;);\n        if(parPos !&#x3D; string::npos)&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS &#x3D; input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        &#125;else&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS &#x3D; &quot;&quot;; \n        &#125;\n\n    &#125;\n    \n    ll pow10(ll l)&#123;\n        ll ans &#x3D; 1;\n        while(l &gt; 0)&#123;\n            ans *&#x3D; 10;\n            l--;\n        &#125;\n        return ans;\n    &#125;\n\n    ll mystol(string s)&#123;\n        if(s &#x3D;&#x3D; &quot;&quot;) return 0;\n        else return stol(s);\n    &#125;\n\n    fraction getFraction(string integer, string nonreS, string reS)&#123;\n        \n        fraction no1 &#x3D; fraction(mystol(integer), 1);\n        int nonreLen &#x3D; nonreS.size();\n        int reLen &#x3D; reS.size();\n        fraction no2 &#x3D; fraction(mystol(nonreS), pow10(nonreLen));\n        fraction no3 &#x3D; fraction(mystol(reS), pow10(nonreLen) * (pow10(reLen) - 1) );\n\n        no1.add(no2);\n        no1.add(no3);\n        return no1;\n    &#125;\n\n    bool isRationalEqual(string S, string T) &#123;\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        \n        fraction frac1 &#x3D; getFraction(integerS1, nonreS1, reS1);\n        fraction frac2 &#x3D; getFraction(integerS2, nonreS2, reS2);\n        if(frac1.equal(frac2)) return true;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3EFF1Q9","excerpt":"<h4 id=\"972-Equal-Rational-Numbers\"><a href=\"#972-Equal-Rational-Numbers\" class=\"headerlink\" title=\"972. Equal Rational Numbers\"></a><a href=\"https://leetcode-cn.com/problems/equal-rational-numbers/\">972. Equal Rational Numbers</a></h4><p>思路不止一种，老老实实敲敲代码但不想优化方法的人是没有前途的。</p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>第一种：按字符匹配模式分类讨论</p>\n<ul>\n<li>两个字符串都没有重复字符串：直接去尾零比较相等值。</li>\n<li>只有一个字符串有重复字符串：只有一种情况可以相等，就是题目中无限接近的情况，比如“0.9(9)==1.0”。当然可以用数学证明的，两者相等。用语言描述比较麻烦，意会吧。</li>\n<li>两个字符串都有重复字符串：将重复字符串展开多次，尽可能比较相同长度内容即可。</li>\n</ul>\n<p>第二种：化为数值法！</p>\n<p>重复模式串的数值部分可以计算,比如：<br>$$<br>0.00(66)=\\frac{1}{100} + \\frac{66}{100} + \\frac{66}{10000}\\cdots<br>$$<br>那么一般就有<br>$$<br>0.(s) = \\frac{s}{10^k }+ \\frac{s}{10^{2k} \\cdots} \\\\<br>= s*(\\frac{1}{10^k} + \\frac{1}{10^{2k}} \\cdots)\\\\<br>= s * (limt_{ \\ n\\rightarrow\\infty}\\frac{\\frac{1}{10^k}-\\frac{1}{(10^k)^n}}{1-\\frac{1}{10^k}})\\\\<br>= s * \\frac{\\frac{1}{10^k}}{1-\\frac{1}{10^k}}\\\\<br>which\\ k \\ is \\ the\\ len\\ of\\ s.<br>$$<br>非重复部分更容易计算。</p>\n<p>那么之后用分数类来计算结果即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>老实人代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n\n&#x2F;&#x2F;  if find() cant find the char or string, it will retunr str::string::npos;\n&#x2F;&#x2F; static const size_t npos &#x3D; -1;  the size_t is unsigned int type. \n\n    \n    void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS)&#123;\n        int pointPos &#x3D; input.find(&quot;.&quot;);\n        if(pointPos !&#x3D; string::npos)\n            integerS &#x3D; input.substr(0, pointPos);\n        else&#123;\n            integerS &#x3D; input;\n            nonreS &#x3D; reS &#x3D; &quot;&quot;;\n            return;\n        &#125; \n\n        int parPos &#x3D; input.find(&quot;(&quot;);\n        if(parPos !&#x3D; string::npos)&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS &#x3D; input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        &#125;else&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS &#x3D; &quot;&quot;; \n        &#125;\n\n        if( reS &#x3D;&#x3D; &quot;&quot; || stol(reS) &#x3D;&#x3D; 0)&#123;\n            reS &#x3D; &quot;&quot;;\n            int pos &#x3D;  nonreS.size() - 1;\n            while(pos &gt;&#x3D; 0 &amp;&amp; nonreS[pos] &#x3D;&#x3D; &#39;0&#39;) pos--;\n            if(pos &gt;&#x3D; 0) nonreS &#x3D; nonreS.substr(0, pos + 1);\n            else nonreS &#x3D; &quot;&quot;;\n            if(integerS &#x3D;&#x3D; &quot;&quot; || stol(integerS) &#x3D;&#x3D; 0) integerS &#x3D; &quot;0&quot;;\n        &#125; \n    &#125;\n    \n    bool isNineNum(string S)&#123;\n        for(int i &#x3D; 0; i &lt; S.size(); i++)\n        &#123;\n            if(S[i] !&#x3D; &#39;9&#39;) return false;\n        &#125;\n        return true;\n    &#125;   \n\n\n    string strmul(string s, int time)&#123;\n        string res &#x3D; &quot;&quot;;\n        for(int i &#x3D; 0; i &lt; time; i++)&#123;\n            res +&#x3D; s;\n        &#125;\n        return res;\n    &#125;\n    &#x2F;&#x2F;must comfire reS2 &#x3D;&#x3D; &quot;&quot;\n    bool isfiniteEqual(string integerS1, string nonreS1, string reS1, string integerS2, string nonreS2, string reS2)&#123;    \n        if(!isNineNum(reS1) || reS2.size() !&#x3D; 0) return false;\n\n        int pos &#x3D; nonreS1.size() - 1;\n        for(;pos &gt;&#x3D; 0; pos --)&#123;\n            if(nonreS1[pos] !&#x3D; &#39;9&#39;) break;\n        &#125;\n        if(nonreS2.size() !&#x3D; pos + 1) return false;\n\n        int num1 &#x3D; stol(integerS1 + nonreS1.substr(0, pos + 1));\n        int num2 &#x3D; stol(integerS2 + nonreS2);\n        if(num1 + 1 !&#x3D; num2) return false;\n        return true;\n    &#125;\n\n    bool ispartEqual(string s1, string s2)&#123;\n        &#x2F;&#x2F;\n        cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2 &lt;&lt; endl;\n        if(s1.size() &gt; s2.size()) return false;\n        if(s2.substr(0, s1.size()) &#x3D;&#x3D; s1) return true;\n        return false;\n    &#125;\n\n\n    bool isRationalEqual(string S, string T) &#123;\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        if(reS1.size() &#x3D;&#x3D; 0 &amp;&amp; reS2.size() &#x3D;&#x3D; 0)&#123;\n            if(integerS1 &#x3D;&#x3D; integerS2 &amp;&amp; nonreS1 &#x3D;&#x3D; nonreS2) return true;\n        &#125;\n        else if(reS1.size() &#x3D;&#x3D; 0 || reS2.size() &#x3D;&#x3D; 0)&#123;\n            if(isfiniteEqual(integerS1, nonreS1, reS1, integerS2, nonreS2, reS2) \n            || isfiniteEqual(integerS2, nonreS2, reS2, integerS1, nonreS1, reS1))\n                 return true;\n        &#125;\n        else&#123;\n            int l1 &#x3D; reS1.size(), l2&#x3D; reS2.size();\n            string str1 &#x3D; integerS1 + nonreS1 + strmul(reS1, reS2.size() + 2);\n            string str2 &#x3D; integerS2 + nonreS2 + strmul(reS2, reS1.size() + 2);\n            if(ispartEqual(str1, str2) || ispartEqual(str2, str1)) return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>数值计算</p>\n<p>弱鸡的代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef long long ll;\nclass fraction&#123;\npublic:\n    ll n, d;\n    fraction(ll _n, ll _d)&#123;\n        n &#x3D; _n;\n        d &#x3D; _d;\n        if(_d  &#x3D;&#x3D; 0) d &#x3D; 1;\n      &#125;\n\n    void add(fraction s)&#123;\n        n &#x3D; n * s.d + d * s.n;\n        d *&#x3D; s.d;\n         clear();\n        print(fraction(n, d));\n        print(s);\n    &#125;\n\n    bool equal(fraction s)&#123;            \n        if(s.d &#x3D;&#x3D; d &amp;&amp; s.n &#x3D;&#x3D; n) return true;\n        return false;\n    &#125;\n\nprivate:\n    ll gcd(ll a, ll b)&#123;\n        return b?gcd(b, a%b):a;\n    &#125;\n    void clear()&#123;\n        int gcdN &#x3D; 1;\n        if(n &#x3D;&#x3D; 0)   \n            gcdN &#x3D; 1;\n        else   \n            gcdN &#x3D; gcd(d , n);\n        n &#x2F;&#x3D; gcdN;\n        d &#x2F;&#x3D; gcdN;\n        if(n &#x3D;&#x3D; 0) d &#x3D; 1;\n    &#125;\n\n&#125;;\n\n\n&#x2F;&#x2F; \nclass Solution &#123;\npublic:\n\n    void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS)&#123;\n        int pointPos &#x3D; input.find(&quot;.&quot;);\n        if(pointPos !&#x3D; string::npos)\n            integerS &#x3D; input.substr(0, pointPos);\n        else&#123;\n            integerS &#x3D; input;\n            nonreS &#x3D; reS &#x3D; &quot;&quot;;\n            return;\n        &#125; \n\n        int parPos &#x3D; input.find(&quot;(&quot;);\n        if(parPos !&#x3D; string::npos)&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, parPos - pointPos - 1);\n            reS &#x3D; input.substr(parPos + 1, input.size() - 1 - parPos - 1);\n        &#125;else&#123;\n            nonreS &#x3D; input.substr(pointPos + 1, input.size() - pointPos - 1);\n            reS &#x3D; &quot;&quot;; \n        &#125;\n\n    &#125;\n    \n    ll pow10(ll l)&#123;\n        ll ans &#x3D; 1;\n        while(l &gt; 0)&#123;\n            ans *&#x3D; 10;\n            l--;\n        &#125;\n        return ans;\n    &#125;\n\n    ll mystol(string s)&#123;\n        if(s &#x3D;&#x3D; &quot;&quot;) return 0;\n        else return stol(s);\n    &#125;\n\n    fraction getFraction(string integer, string nonreS, string reS)&#123;\n        \n        fraction no1 &#x3D; fraction(mystol(integer), 1);\n        int nonreLen &#x3D; nonreS.size();\n        int reLen &#x3D; reS.size();\n        fraction no2 &#x3D; fraction(mystol(nonreS), pow10(nonreLen));\n        fraction no3 &#x3D; fraction(mystol(reS), pow10(nonreLen) * (pow10(reLen) - 1) );\n\n        no1.add(no2);\n        no1.add(no3);\n        return no1;\n    &#125;\n\n    bool isRationalEqual(string S, string T) &#123;\n        string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2;\n        getNum(S, integerS1, nonreS1, reS1);\n        getNum(T, integerS2, nonreS2, reS2);\n        \n        fraction frac1 &#x3D; getFraction(integerS1, nonreS1, reS1);\n        fraction frac2 &#x3D; getFraction(integerS2, nonreS2, reS2);\n        if(frac1.equal(frac2)) return true;\n        return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"错排问题:年会抽奖","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-10T10:07:43.000Z","_content":"\n\n\n所谓错排问题就是N个1~N数字的序列都恰好不在对应位上，比如序列`3 1 2 `。\n\n### 题目：年会抽奖\n\n今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：\n\n1. 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；\n2. 待所有字条加入完毕，每人从箱中取一个字条；\n3. 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”\n   现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？\n\n<!-- more -->\n\n\n\n### 思路\n\n首先所有数字可能的排列顺序为$n!$，我们只需要求出所有可能出现的错排书就行。\n\n采用排除法，记$a_i$是$i$个数字错排的数量，\n\n通过并集计算公式，排除掉$k,  1 <= k <= n $个数字排列正确排列的所有情况\n$$\nP(A) =  n! - n * a_{n -1} + n * (n -1) /2 * a_{n-2} ....  \\\\\\\\ \n= n! - n * (n - 1)! + \\frac{n!}{2!} - \\frac{n!}{3!} ....\n=\\frac{n!}{2!} - \\frac{n!}{3!} ....\n= \\sum_{k=2}^{n}{(-1)^k} \\frac{n!}{k!}\n$$\n上式中，1个数字排列正确的序列保护了2个数列排列正确的情况，2个数字排列正确的序列保护了3个数列排列正确的情况，所以可以使用并集公式。\n\n\n\n换一种想法：\n\n可以观察到，错排的序列`3 4 1 2`有位置对换的数字2和4，如果固定这两个数字，剩下的数字进行错排有`3 1`。可以观察到序列数量减少了，不由有递推的味道。\n\n那如果最后一个数字没有与位置对换呢？如`2 3 4 1 `，为了同样获取`n-1`个可以错排的数据（数据和坑位可以一一对应），把`4`排除去，我们可以把第四个数字看成被`4`占据的第三位，构成了`2 3 1`。\n\n公式化一下：\n\n由题意`a1=0`，`a2=1`，当`n≥3`时，在错排中`n`必不在第`n`位，设`n`放在第`k`位上（`1≤k≤n-1`），则第`n`位上有两种可能：\n\n（1）如果第`n`位上不是`k`，那么把第`n`位看作第`k`位，将`n`以外的`n－1`个数进行错排，错排个数是`an-1`；\n\n（2）如果第`n`位上是`k`，那么除`n`和`k`以外的`n－2`个数的错排是`an-2`，\n\n所以n在第k位上的错排数共有`an-1＋an-2`，由于`k`可取`1、2、3、4、……、n－1`共 `n -1 `种取法，所以`n`个数的错排个数。\n\n所以有递推公式：`an= (n - 1)(an-1 + an-2)`。\n\n\n\n\n\n\n\n","source":"_posts/刷题/数学\n/错排问题-年会抽奖.md","raw":"---\ntitle: '错排问题:年会抽奖'\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-10 18:07:43\ntags:\ncategories:\n---\n\n\n\n所谓错排问题就是N个1~N数字的序列都恰好不在对应位上，比如序列`3 1 2 `。\n\n### 题目：年会抽奖\n\n今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：\n\n1. 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；\n2. 待所有字条加入完毕，每人从箱中取一个字条；\n3. 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”\n   现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？\n\n<!-- more -->\n\n\n\n### 思路\n\n首先所有数字可能的排列顺序为$n!$，我们只需要求出所有可能出现的错排书就行。\n\n采用排除法，记$a_i$是$i$个数字错排的数量，\n\n通过并集计算公式，排除掉$k,  1 <= k <= n $个数字排列正确排列的所有情况\n$$\nP(A) =  n! - n * a_{n -1} + n * (n -1) /2 * a_{n-2} ....  \\\\\\\\ \n= n! - n * (n - 1)! + \\frac{n!}{2!} - \\frac{n!}{3!} ....\n=\\frac{n!}{2!} - \\frac{n!}{3!} ....\n= \\sum_{k=2}^{n}{(-1)^k} \\frac{n!}{k!}\n$$\n上式中，1个数字排列正确的序列保护了2个数列排列正确的情况，2个数字排列正确的序列保护了3个数列排列正确的情况，所以可以使用并集公式。\n\n\n\n换一种想法：\n\n可以观察到，错排的序列`3 4 1 2`有位置对换的数字2和4，如果固定这两个数字，剩下的数字进行错排有`3 1`。可以观察到序列数量减少了，不由有递推的味道。\n\n那如果最后一个数字没有与位置对换呢？如`2 3 4 1 `，为了同样获取`n-1`个可以错排的数据（数据和坑位可以一一对应），把`4`排除去，我们可以把第四个数字看成被`4`占据的第三位，构成了`2 3 1`。\n\n公式化一下：\n\n由题意`a1=0`，`a2=1`，当`n≥3`时，在错排中`n`必不在第`n`位，设`n`放在第`k`位上（`1≤k≤n-1`），则第`n`位上有两种可能：\n\n（1）如果第`n`位上不是`k`，那么把第`n`位看作第`k`位，将`n`以外的`n－1`个数进行错排，错排个数是`an-1`；\n\n（2）如果第`n`位上是`k`，那么除`n`和`k`以外的`n－2`个数的错排是`an-2`，\n\n所以n在第k位上的错排数共有`an-1＋an-2`，由于`k`可取`1、2、3、4、……、n－1`共 `n -1 `种取法，所以`n`个数的错排个数。\n\n所以有递推公式：`an= (n - 1)(an-1 + an-2)`。\n\n\n\n\n\n\n\n","slug":"刷题-数学-错排问题-年会抽奖","published":1,"updated":"2021-03-10T14:29:22.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5m003bl5uo32447jhd","content":"<p>所谓错排问题就是N个1~N数字的序列都恰好不在对应位上，比如序列<code>3 1 2 </code>。</p>\n<h3 id=\"题目：年会抽奖\"><a href=\"#题目：年会抽奖\" class=\"headerlink\" title=\"题目：年会抽奖\"></a>题目：年会抽奖</h3><p>今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：</p>\n<ol>\n<li>首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；</li>\n<li>待所有字条加入完毕，每人从箱中取一个字条；</li>\n<li>如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”<br>现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？</li>\n</ol>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>首先所有数字可能的排列顺序为$n!$，我们只需要求出所有可能出现的错排书就行。</p>\n<p>采用排除法，记$a_i$是$i$个数字错排的数量，</p>\n<p>通过并集计算公式，排除掉$k,  1 &lt;= k &lt;= n $个数字排列正确排列的所有情况<br>$$<br>P(A) =  n! - n * a_{n -1} + n * (n -1) /2 * a_{n-2} ….  \\\\<br>= n! - n * (n - 1)! + \\frac{n!}{2!} - \\frac{n!}{3!} ….<br>=\\frac{n!}{2!} - \\frac{n!}{3!} ….<br>= \\sum_{k=2}^{n}{(-1)^k} \\frac{n!}{k!}<br>$$<br>上式中，1个数字排列正确的序列保护了2个数列排列正确的情况，2个数字排列正确的序列保护了3个数列排列正确的情况，所以可以使用并集公式。</p>\n<p>换一种想法：</p>\n<p>可以观察到，错排的序列<code>3 4 1 2</code>有位置对换的数字2和4，如果固定这两个数字，剩下的数字进行错排有<code>3 1</code>。可以观察到序列数量减少了，不由有递推的味道。</p>\n<p>那如果最后一个数字没有与位置对换呢？如<code>2 3 4 1 </code>，为了同样获取<code>n-1</code>个可以错排的数据（数据和坑位可以一一对应），把<code>4</code>排除去，我们可以把第四个数字看成被<code>4</code>占据的第三位，构成了<code>2 3 1</code>。</p>\n<p>公式化一下：</p>\n<p>由题意<code>a1=0</code>，<code>a2=1</code>，当<code>n≥3</code>时，在错排中<code>n</code>必不在第<code>n</code>位，设<code>n</code>放在第<code>k</code>位上（<code>1≤k≤n-1</code>），则第<code>n</code>位上有两种可能：</p>\n<p>（1）如果第<code>n</code>位上不是<code>k</code>，那么把第<code>n</code>位看作第<code>k</code>位，将<code>n</code>以外的<code>n－1</code>个数进行错排，错排个数是<code>an-1</code>；</p>\n<p>（2）如果第<code>n</code>位上是<code>k</code>，那么除<code>n</code>和<code>k</code>以外的<code>n－2</code>个数的错排是<code>an-2</code>，</p>\n<p>所以n在第k位上的错排数共有<code>an-1＋an-2</code>，由于<code>k</code>可取<code>1、2、3、4、……、n－1</code>共 <code>n -1 </code>种取法，所以<code>n</code>个数的错排个数。</p>\n<p>所以有递推公式：<code>an= (n - 1)(an-1 + an-2)</code>。</p>\n","site":{"data":{}},"abbrlink":"DEHW3P","excerpt":"<p>所谓错排问题就是N个1~N数字的序列都恰好不在对应位上，比如序列<code>3 1 2 </code>。</p>\n<h3 id=\"题目：年会抽奖\"><a href=\"#题目：年会抽奖\" class=\"headerlink\" title=\"题目：年会抽奖\"></a>题目：年会抽奖</h3><p>今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：</p>\n<ol>\n<li>首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；</li>\n<li>待所有字条加入完毕，每人从箱中取一个字条；</li>\n<li>如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”<br>现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？</li>\n</ol>","more":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>首先所有数字可能的排列顺序为$n!$，我们只需要求出所有可能出现的错排书就行。</p>\n<p>采用排除法，记$a_i$是$i$个数字错排的数量，</p>\n<p>通过并集计算公式，排除掉$k,  1 &lt;= k &lt;= n $个数字排列正确排列的所有情况<br>$$<br>P(A) =  n! - n * a_{n -1} + n * (n -1) /2 * a_{n-2} ….  \\\\<br>= n! - n * (n - 1)! + \\frac{n!}{2!} - \\frac{n!}{3!} ….<br>=\\frac{n!}{2!} - \\frac{n!}{3!} ….<br>= \\sum_{k=2}^{n}{(-1)^k} \\frac{n!}{k!}<br>$$<br>上式中，1个数字排列正确的序列保护了2个数列排列正确的情况，2个数字排列正确的序列保护了3个数列排列正确的情况，所以可以使用并集公式。</p>\n<p>换一种想法：</p>\n<p>可以观察到，错排的序列<code>3 4 1 2</code>有位置对换的数字2和4，如果固定这两个数字，剩下的数字进行错排有<code>3 1</code>。可以观察到序列数量减少了，不由有递推的味道。</p>\n<p>那如果最后一个数字没有与位置对换呢？如<code>2 3 4 1 </code>，为了同样获取<code>n-1</code>个可以错排的数据（数据和坑位可以一一对应），把<code>4</code>排除去，我们可以把第四个数字看成被<code>4</code>占据的第三位，构成了<code>2 3 1</code>。</p>\n<p>公式化一下：</p>\n<p>由题意<code>a1=0</code>，<code>a2=1</code>，当<code>n≥3</code>时，在错排中<code>n</code>必不在第<code>n</code>位，设<code>n</code>放在第<code>k</code>位上（<code>1≤k≤n-1</code>），则第<code>n</code>位上有两种可能：</p>\n<p>（1）如果第<code>n</code>位上不是<code>k</code>，那么把第<code>n</code>位看作第<code>k</code>位，将<code>n</code>以外的<code>n－1</code>个数进行错排，错排个数是<code>an-1</code>；</p>\n<p>（2）如果第<code>n</code>位上是<code>k</code>，那么除<code>n</code>和<code>k</code>以外的<code>n－2</code>个数的错排是<code>an-2</code>，</p>\n<p>所以n在第k位上的错排数共有<code>an-1＋an-2</code>，由于<code>k</code>可取<code>1、2、3、4、……、n－1</code>共 <code>n -1 </code>种取法，所以<code>n</code>个数的错排个数。</p>\n<p>所以有递推公式：<code>an= (n - 1)(an-1 + an-2)</code>。</p>"},{"title":"面16-数值的N次方","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:26:33.000Z","_content":"\n\n\n### 题面：\n\n给一个浮点数，求出其数值的整数次方。\n\n### 思路：\n\n主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。\n\n<!-- more -->\n\n\n\n### 代码：\n\n```\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    unsigned int posExponent = (unsigned int)exponent;\n    double mulBase = base, mulRes = 1;\n    while(posExponent > 0){\n        if(posExponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        posExponent = posExponent >> 1;\n    }\n   if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```\n\n可能降低耦合更好一点\n\n```\ndouble PowerWithUnsighedExponent(double base, unsigned int exponent){\n    //特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes = 1;\n    while(exponent > 0){\n        if(exponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        exponent = exponent >> 1;\n    }\n   return mulRes;\n}\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    double mulRes = PowerWithUnsignedExponent(base, exponent);\n    if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```","source":"_posts/刷题/数学\n/面16-数值的N次方.md","raw":"---\ntitle: 面16-数值的N次方\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:26:33\ntags:\n---\n\n\n\n### 题面：\n\n给一个浮点数，求出其数值的整数次方。\n\n### 思路：\n\n主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。\n\n<!-- more -->\n\n\n\n### 代码：\n\n```\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    unsigned int posExponent = (unsigned int)exponent;\n    double mulBase = base, mulRes = 1;\n    while(posExponent > 0){\n        if(posExponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        posExponent = posExponent >> 1;\n    }\n   if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```\n\n可能降低耦合更好一点\n\n```\ndouble PowerWithUnsighedExponent(double base, unsigned int exponent){\n    //特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes = 1;\n    while(exponent > 0){\n        if(exponent & 1)\n            mulRes *= mulBase;\n        mulBase *= mulBase;\n        exponent = exponent >> 1;\n    }\n   return mulRes;\n}\nint power(double base, int exponent){\n    //无穷大的非法计算值\n    if( equal(base, 0.0) && exponent < 0) \n        throw new exception(\"Invalid parameters.\");\n    \n    double mulRes = PowerWithUnsignedExponent(base, exponent);\n    if(exponent < 0) mulRes = 1 / mulRes;\n   return mulRes;\n}\n```","slug":"刷题-数学-面16-数值的N次方","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5m003cl5uog8mhgt9y","content":"<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给一个浮点数，求出其数值的整数次方。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    unsigned int posExponent &#x3D; (unsigned int)exponent;\n    double mulBase &#x3D; base, mulRes &#x3D; 1;\n    while(posExponent &gt; 0)&#123;\n        if(posExponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        posExponent &#x3D; posExponent &gt;&gt; 1;\n    &#125;\n   if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可能降低耦合更好一点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">double PowerWithUnsighedExponent(double base, unsigned int exponent)&#123;\n    &#x2F;&#x2F;特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes &#x3D; 1;\n    while(exponent &gt; 0)&#123;\n        if(exponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        exponent &#x3D; exponent &gt;&gt; 1;\n    &#125;\n   return mulRes;\n&#125;\nint power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    double mulRes &#x3D; PowerWithUnsignedExponent(base, exponent);\n    if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"298BYBX","excerpt":"<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给一个浮点数，求出其数值的整数次方。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>主要考点还是在异常处理这方面。由于幂为整数，在效率上可以考虑快速幂。</p>","more":"<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    unsigned int posExponent &#x3D; (unsigned int)exponent;\n    double mulBase &#x3D; base, mulRes &#x3D; 1;\n    while(posExponent &gt; 0)&#123;\n        if(posExponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        posExponent &#x3D; posExponent &gt;&gt; 1;\n    &#125;\n   if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可能降低耦合更好一点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">double PowerWithUnsighedExponent(double base, unsigned int exponent)&#123;\n    &#x2F;&#x2F;特判：基数为0；指数为0无需特判\n    if( equla(base, 0.0)) return 0.0;\n    double mulRes &#x3D; 1;\n    while(exponent &gt; 0)&#123;\n        if(exponent &amp; 1)\n            mulRes *&#x3D; mulBase;\n        mulBase *&#x3D; mulBase;\n        exponent &#x3D; exponent &gt;&gt; 1;\n    &#125;\n   return mulRes;\n&#125;\nint power(double base, int exponent)&#123;\n    &#x2F;&#x2F;无穷大的非法计算值\n    if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) \n        throw new exception(&quot;Invalid parameters.&quot;);\n    \n    double mulRes &#x3D; PowerWithUnsignedExponent(base, exponent);\n    if(exponent &lt; 0) mulRes &#x3D; 1 &#x2F; mulRes;\n   return mulRes;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题 16.05. Factorial Zeros LCCI","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-09-24T01:24:55.000Z","_content":"\n#### [面试题 16.05. Factorial Zeros LCCI](https://leetcode-cn.com/problems/factorial-zeros-lcci/)\n\n<!-- more -->\n\n## 思路：\n\n尾零个数等于所有相乘数字的5的质因子个数，比如$f(11)= 1 + 1$\n\n关于快速求出：可以使用整除5，25，125……$5^k$的思路求出。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n\n    int trailingZeroes(int n) {\n        int numof5 = 0;\n        while(n >= 5){\n            n /= 5;\n            numof5 += n;\n        }\n        return numof5;\n    }\n};\n```\n\n","source":"_posts/刷题/数学\n/面试题-16-05-Factorial-Zeros-LCCI.md","raw":"---\ntitle: 面试题 16.05. Factorial Zeros LCCI\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-09-24 09:24:55\n---\n\n#### [面试题 16.05. Factorial Zeros LCCI](https://leetcode-cn.com/problems/factorial-zeros-lcci/)\n\n<!-- more -->\n\n## 思路：\n\n尾零个数等于所有相乘数字的5的质因子个数，比如$f(11)= 1 + 1$\n\n关于快速求出：可以使用整除5，25，125……$5^k$的思路求出。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n\n    int trailingZeroes(int n) {\n        int numof5 = 0;\n        while(n >= 5){\n            n /= 5;\n            numof5 += n;\n        }\n        return numof5;\n    }\n};\n```\n\n","slug":"刷题-数学-面试题-16-05-Factorial-Zeros-LCCI","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5n003dl5uo1i1v0ovt","content":"<h4 id=\"面试题-16-05-Factorial-Zeros-LCCI\"><a href=\"#面试题-16-05-Factorial-Zeros-LCCI\" class=\"headerlink\" title=\"面试题 16.05. Factorial Zeros LCCI\"></a><a href=\"https://leetcode-cn.com/problems/factorial-zeros-lcci/\">面试题 16.05. Factorial Zeros LCCI</a></h4><span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>尾零个数等于所有相乘数字的5的质因子个数，比如$f(11)= 1 + 1$</p>\n<p>关于快速求出：可以使用整除5，25，125……$5^k$的思路求出。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int trailingZeroes(int n) &#123;\n        int numof5 &#x3D; 0;\n        while(n &gt;&#x3D; 5)&#123;\n            n &#x2F;&#x3D; 5;\n            numof5 +&#x3D; n;\n        &#125;\n        return numof5;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1CQT405","excerpt":"<h4 id=\"面试题-16-05-Factorial-Zeros-LCCI\"><a href=\"#面试题-16-05-Factorial-Zeros-LCCI\" class=\"headerlink\" title=\"面试题 16.05. Factorial Zeros LCCI\"></a><a href=\"https://leetcode-cn.com/problems/factorial-zeros-lcci/\">面试题 16.05. Factorial Zeros LCCI</a></h4>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>尾零个数等于所有相乘数字的5的质因子个数，比如$f(11)= 1 + 1$</p>\n<p>关于快速求出：可以使用整除5，25，125……$5^k$的思路求出。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int trailingZeroes(int n) &#123;\n        int numof5 &#x3D; 0;\n        while(n &gt;&#x3D; 5)&#123;\n            n &#x2F;&#x3D; 5;\n            numof5 +&#x3D; n;\n        &#125;\n        return numof5;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题-大数","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:27:41.000Z","_content":"\n<!-- more -->\n\n\n\n大数相关\n\n\n\n## 面17：打印从1到最大的n位数\n\n### 题目：\n\n如题\n\n### 思路1：\n\n明显的太简单了。坑还是在数据范围上，考虑使用大数加法模拟计算。\n\n### 思路2：\n\n也可以使用全排列的思路，思考除了开头为0的n个`0~9`数字的排列组合就是题目所要求的的数据。\n\n### 代码：\n\n**大数**\n\n```\n#include<string>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n){\n    for(int i = 0; n[i] != '\\0'; i++)\n        if(numbers[i] != n[i] - '0') return true;\n\treturn false;\n}\n\nvoid PrintNumber(int *numbers, int MAXLEN){\n    int idx = MAXLEN - 1;\n    while(idx >= 0 && numbers[idx] == 0) idx --;\n    for(int i = idx; i >= 0; --i)\n        putchar(numbers[i] + '0');\n    putchar('\\n');\n}\n\nvoid Print1ToMaxDigits(char *n){\n    const int MAXLEN = 1000;\n\tif(n == nullptr || strlen(n) <= 0 || strlen(n) >= MAXLEN) return;\n    char test0[2] = \"0\";\n\tif(strcmp(test0, n) == 0){\n        printf(\"0\\n\");\n        return;\n    }\n    \n\t//reverse the input string\n\tchar *newN = new char(MAXLEN);\n\tint lenN = strlen(n);\n\tfor(int i = 0; i < lenN; i++)\n\t\tnewN[lenN - i - 1] = n[i];\n    \n\t//big data.\n    int *numbers = new int[MAXLEN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t//Calculate the numbers.\n    while(isIncreaseDigit(numbers, newN)){\n        numbers[0]++;\n\t\tint idx = 0;\n        while(numbers[idx] == 10){\n            numbers[idx] = 0;\n            ++idx;\n            numbers[idx]++;\n        \t\n        }\n\t\tPrintNumber(numbers, MAXLEN);\n    }\n    delete  []numbers;\n    \n}\nint main(){\n    //freopen(\"data.in\", \"r\", stdin);\n\tchar a[5] = {\"1239\"};\n\tPrint1ToMaxDigits(a);\n}\n```\n\n**全排列组合**\n\n```\n#include<string>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n){\n    for(int i = 0; n[i] != '\\0'; i++)\n        if(numbers[i] != n[i] - '0') return true;\n\treturn false;\n}\n\nvoid PrintNumber(int *numbers, int MAXLEN){\n    int idx = MAXLEN - 1;\n\t//不输出前置零和全零\n    while(idx >= 0 && numbers[idx] == 0) idx --;\n\tif(idx == -1) return;\n\tfor(int i = idx; i >= 0; --i)\n        putchar(numbers[i] + '0');\n    putchar('\\n');\n}\n\nvoid Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &flag){\n\tif(flag) return;\n\tif(pos == -1) {\n\t\t//直接用flag剪枝\n\t\tif(!isIncreaseDigit(numbers, newN)) flag  = 1;\n        PrintNumber(numbers, lenOfN);\n        return;\n    }\n\n\tif(!isIncreaseDigit(numbers, newN)) return;\n    for(int i = 0; i <= 9; i++){\n        numbers[pos] = i;        \n        Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag);\t\t\n\t}\n}\n    \nvoid Print1ToMaxDigits(char *n){\n\tif(n == nullptr || strlen(n) <= 0) return;\n    char test0[2] = \"0\";\n\tif(strcmp(test0, n) == 0){\n        printf(\"0\\n\");\n        return;\n    }\n    \n\t//reverse the input string\n\tint lenOfN = strlen(n);\n\tchar *newN = new char(lenOfN);\n\t\n\tfor(int i = 0; i < lenOfN; i++)\n\t\tnewN[lenOfN - i - 1] = n[i];\n    newN[lenOfN] = '\\0';\n\n\t//big data.\n    int *numbers = new int[lenOfN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t//Calculate the numbers.\n\tint flag = 0;\n    Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag);\n    delete  []numbers;\n    \n}\nint main(){\n    //freopen(\"data.in\", \"r\", stdin);\n\t// char a[5] = {\"1239\"};\n\t// char a[5] = {\"0\"};\n\tchar a[50] = {\"100\"};\n\tPrint1ToMaxDigits(a);\n\t// int t1[5] = {1, 2};\n\t// printf(\"%d\", isIncreaseDigit(t1, a));\n\n}\n```\n\n> 把自己写懵逼了，调试了好久，原来发现自己剪枝错了。\n>\n> 由于判断条件在变化，而剪枝条件是不变的，所以不能在更变条件后剪枝","source":"_posts/刷题/数学\n/面试题-大数.md","raw":"---\ntitle: 面试题-大数\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:27:41\ntags:\n---\n\n<!-- more -->\n\n\n\n大数相关\n\n\n\n## 面17：打印从1到最大的n位数\n\n### 题目：\n\n如题\n\n### 思路1：\n\n明显的太简单了。坑还是在数据范围上，考虑使用大数加法模拟计算。\n\n### 思路2：\n\n也可以使用全排列的思路，思考除了开头为0的n个`0~9`数字的排列组合就是题目所要求的的数据。\n\n### 代码：\n\n**大数**\n\n```\n#include<string>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n){\n    for(int i = 0; n[i] != '\\0'; i++)\n        if(numbers[i] != n[i] - '0') return true;\n\treturn false;\n}\n\nvoid PrintNumber(int *numbers, int MAXLEN){\n    int idx = MAXLEN - 1;\n    while(idx >= 0 && numbers[idx] == 0) idx --;\n    for(int i = idx; i >= 0; --i)\n        putchar(numbers[i] + '0');\n    putchar('\\n');\n}\n\nvoid Print1ToMaxDigits(char *n){\n    const int MAXLEN = 1000;\n\tif(n == nullptr || strlen(n) <= 0 || strlen(n) >= MAXLEN) return;\n    char test0[2] = \"0\";\n\tif(strcmp(test0, n) == 0){\n        printf(\"0\\n\");\n        return;\n    }\n    \n\t//reverse the input string\n\tchar *newN = new char(MAXLEN);\n\tint lenN = strlen(n);\n\tfor(int i = 0; i < lenN; i++)\n\t\tnewN[lenN - i - 1] = n[i];\n    \n\t//big data.\n    int *numbers = new int[MAXLEN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t//Calculate the numbers.\n    while(isIncreaseDigit(numbers, newN)){\n        numbers[0]++;\n\t\tint idx = 0;\n        while(numbers[idx] == 10){\n            numbers[idx] = 0;\n            ++idx;\n            numbers[idx]++;\n        \t\n        }\n\t\tPrintNumber(numbers, MAXLEN);\n    }\n    delete  []numbers;\n    \n}\nint main(){\n    //freopen(\"data.in\", \"r\", stdin);\n\tchar a[5] = {\"1239\"};\n\tPrint1ToMaxDigits(a);\n}\n```\n\n**全排列组合**\n\n```\n#include<string>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n){\n    for(int i = 0; n[i] != '\\0'; i++)\n        if(numbers[i] != n[i] - '0') return true;\n\treturn false;\n}\n\nvoid PrintNumber(int *numbers, int MAXLEN){\n    int idx = MAXLEN - 1;\n\t//不输出前置零和全零\n    while(idx >= 0 && numbers[idx] == 0) idx --;\n\tif(idx == -1) return;\n\tfor(int i = idx; i >= 0; --i)\n        putchar(numbers[i] + '0');\n    putchar('\\n');\n}\n\nvoid Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &flag){\n\tif(flag) return;\n\tif(pos == -1) {\n\t\t//直接用flag剪枝\n\t\tif(!isIncreaseDigit(numbers, newN)) flag  = 1;\n        PrintNumber(numbers, lenOfN);\n        return;\n    }\n\n\tif(!isIncreaseDigit(numbers, newN)) return;\n    for(int i = 0; i <= 9; i++){\n        numbers[pos] = i;        \n        Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag);\t\t\n\t}\n}\n    \nvoid Print1ToMaxDigits(char *n){\n\tif(n == nullptr || strlen(n) <= 0) return;\n    char test0[2] = \"0\";\n\tif(strcmp(test0, n) == 0){\n        printf(\"0\\n\");\n        return;\n    }\n    \n\t//reverse the input string\n\tint lenOfN = strlen(n);\n\tchar *newN = new char(lenOfN);\n\t\n\tfor(int i = 0; i < lenOfN; i++)\n\t\tnewN[lenOfN - i - 1] = n[i];\n    newN[lenOfN] = '\\0';\n\n\t//big data.\n    int *numbers = new int[lenOfN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t//Calculate the numbers.\n\tint flag = 0;\n    Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag);\n    delete  []numbers;\n    \n}\nint main(){\n    //freopen(\"data.in\", \"r\", stdin);\n\t// char a[5] = {\"1239\"};\n\t// char a[5] = {\"0\"};\n\tchar a[50] = {\"100\"};\n\tPrint1ToMaxDigits(a);\n\t// int t1[5] = {1, 2};\n\t// printf(\"%d\", isIncreaseDigit(t1, a));\n\n}\n```\n\n> 把自己写懵逼了，调试了好久，原来发现自己剪枝错了。\n>\n> 由于判断条件在变化，而剪枝条件是不变的，所以不能在更变条件后剪枝","slug":"刷题-数学-面试题-大数","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5n003el5uo773ug7mr","content":"<span id=\"more\"></span>\n\n\n\n<p>大数相关</p>\n<h2 id=\"面17：打印从1到最大的n位数\"><a href=\"#面17：打印从1到最大的n位数\" class=\"headerlink\" title=\"面17：打印从1到最大的n位数\"></a>面17：打印从1到最大的n位数</h2><h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>如题</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>明显的太简单了。坑还是在数据范围上，考虑使用大数加法模拟计算。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>也可以使用全排列的思路，思考除了开头为0的n个<code>0~9</code>数字的排列组合就是题目所要求的的数据。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>大数</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n)&#123;\n    for(int i &#x3D; 0; n[i] !&#x3D; &#39;\\0&#39;; i++)\n        if(numbers[i] !&#x3D; n[i] - &#39;0&#39;) return true;\n\treturn false;\n&#125;\n\nvoid PrintNumber(int *numbers, int MAXLEN)&#123;\n    int idx &#x3D; MAXLEN - 1;\n    while(idx &gt;&#x3D; 0 &amp;&amp; numbers[idx] &#x3D;&#x3D; 0) idx --;\n    for(int i &#x3D; idx; i &gt;&#x3D; 0; --i)\n        putchar(numbers[i] + &#39;0&#39;);\n    putchar(&#39;\\n&#39;);\n&#125;\n\nvoid Print1ToMaxDigits(char *n)&#123;\n    const int MAXLEN &#x3D; 1000;\n\tif(n &#x3D;&#x3D; nullptr || strlen(n) &lt;&#x3D; 0 || strlen(n) &gt;&#x3D; MAXLEN) return;\n    char test0[2] &#x3D; &quot;0&quot;;\n\tif(strcmp(test0, n) &#x3D;&#x3D; 0)&#123;\n        printf(&quot;0\\n&quot;);\n        return;\n    &#125;\n    \n\t&#x2F;&#x2F;reverse the input string\n\tchar *newN &#x3D; new char(MAXLEN);\n\tint lenN &#x3D; strlen(n);\n\tfor(int i &#x3D; 0; i &lt; lenN; i++)\n\t\tnewN[lenN - i - 1] &#x3D; n[i];\n    \n\t&#x2F;&#x2F;big data.\n    int *numbers &#x3D; new int[MAXLEN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t&#x2F;&#x2F;Calculate the numbers.\n    while(isIncreaseDigit(numbers, newN))&#123;\n        numbers[0]++;\n\t\tint idx &#x3D; 0;\n        while(numbers[idx] &#x3D;&#x3D; 10)&#123;\n            numbers[idx] &#x3D; 0;\n            ++idx;\n            numbers[idx]++;\n        \t\n        &#125;\n\t\tPrintNumber(numbers, MAXLEN);\n    &#125;\n    delete  []numbers;\n    \n&#125;\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);\n\tchar a[5] &#x3D; &#123;&quot;1239&quot;&#125;;\n\tPrint1ToMaxDigits(a);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>全排列组合</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n)&#123;\n    for(int i &#x3D; 0; n[i] !&#x3D; &#39;\\0&#39;; i++)\n        if(numbers[i] !&#x3D; n[i] - &#39;0&#39;) return true;\n\treturn false;\n&#125;\n\nvoid PrintNumber(int *numbers, int MAXLEN)&#123;\n    int idx &#x3D; MAXLEN - 1;\n\t&#x2F;&#x2F;不输出前置零和全零\n    while(idx &gt;&#x3D; 0 &amp;&amp; numbers[idx] &#x3D;&#x3D; 0) idx --;\n\tif(idx &#x3D;&#x3D; -1) return;\n\tfor(int i &#x3D; idx; i &gt;&#x3D; 0; --i)\n        putchar(numbers[i] + &#39;0&#39;);\n    putchar(&#39;\\n&#39;);\n&#125;\n\nvoid Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &amp;flag)&#123;\n\tif(flag) return;\n\tif(pos &#x3D;&#x3D; -1) &#123;\n\t\t&#x2F;&#x2F;直接用flag剪枝\n\t\tif(!isIncreaseDigit(numbers, newN)) flag  &#x3D; 1;\n        PrintNumber(numbers, lenOfN);\n        return;\n    &#125;\n\n\tif(!isIncreaseDigit(numbers, newN)) return;\n    for(int i &#x3D; 0; i &lt;&#x3D; 9; i++)&#123;\n        numbers[pos] &#x3D; i;        \n        Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag);\t\t\n\t&#125;\n&#125;\n    \nvoid Print1ToMaxDigits(char *n)&#123;\n\tif(n &#x3D;&#x3D; nullptr || strlen(n) &lt;&#x3D; 0) return;\n    char test0[2] &#x3D; &quot;0&quot;;\n\tif(strcmp(test0, n) &#x3D;&#x3D; 0)&#123;\n        printf(&quot;0\\n&quot;);\n        return;\n    &#125;\n    \n\t&#x2F;&#x2F;reverse the input string\n\tint lenOfN &#x3D; strlen(n);\n\tchar *newN &#x3D; new char(lenOfN);\n\t\n\tfor(int i &#x3D; 0; i &lt; lenOfN; i++)\n\t\tnewN[lenOfN - i - 1] &#x3D; n[i];\n    newN[lenOfN] &#x3D; &#39;\\0&#39;;\n\n\t&#x2F;&#x2F;big data.\n    int *numbers &#x3D; new int[lenOfN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t&#x2F;&#x2F;Calculate the numbers.\n\tint flag &#x3D; 0;\n    Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag);\n    delete  []numbers;\n    \n&#125;\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);\n\t&#x2F;&#x2F; char a[5] &#x3D; &#123;&quot;1239&quot;&#125;;\n\t&#x2F;&#x2F; char a[5] &#x3D; &#123;&quot;0&quot;&#125;;\n\tchar a[50] &#x3D; &#123;&quot;100&quot;&#125;;\n\tPrint1ToMaxDigits(a);\n\t&#x2F;&#x2F; int t1[5] &#x3D; &#123;1, 2&#125;;\n\t&#x2F;&#x2F; printf(&quot;%d&quot;, isIncreaseDigit(t1, a));\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>把自己写懵逼了，调试了好久，原来发现自己剪枝错了。</p>\n<p>由于判断条件在变化，而剪枝条件是不变的，所以不能在更变条件后剪枝</p>\n</blockquote>\n","site":{"data":{}},"abbrlink":"1RNDE8Z","excerpt":"","more":"<p>大数相关</p>\n<h2 id=\"面17：打印从1到最大的n位数\"><a href=\"#面17：打印从1到最大的n位数\" class=\"headerlink\" title=\"面17：打印从1到最大的n位数\"></a>面17：打印从1到最大的n位数</h2><h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>如题</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>明显的太简单了。坑还是在数据范围上，考虑使用大数加法模拟计算。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>也可以使用全排列的思路，思考除了开头为0的n个<code>0~9</code>数字的排列组合就是题目所要求的的数据。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>大数</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n)&#123;\n    for(int i &#x3D; 0; n[i] !&#x3D; &#39;\\0&#39;; i++)\n        if(numbers[i] !&#x3D; n[i] - &#39;0&#39;) return true;\n\treturn false;\n&#125;\n\nvoid PrintNumber(int *numbers, int MAXLEN)&#123;\n    int idx &#x3D; MAXLEN - 1;\n    while(idx &gt;&#x3D; 0 &amp;&amp; numbers[idx] &#x3D;&#x3D; 0) idx --;\n    for(int i &#x3D; idx; i &gt;&#x3D; 0; --i)\n        putchar(numbers[i] + &#39;0&#39;);\n    putchar(&#39;\\n&#39;);\n&#125;\n\nvoid Print1ToMaxDigits(char *n)&#123;\n    const int MAXLEN &#x3D; 1000;\n\tif(n &#x3D;&#x3D; nullptr || strlen(n) &lt;&#x3D; 0 || strlen(n) &gt;&#x3D; MAXLEN) return;\n    char test0[2] &#x3D; &quot;0&quot;;\n\tif(strcmp(test0, n) &#x3D;&#x3D; 0)&#123;\n        printf(&quot;0\\n&quot;);\n        return;\n    &#125;\n    \n\t&#x2F;&#x2F;reverse the input string\n\tchar *newN &#x3D; new char(MAXLEN);\n\tint lenN &#x3D; strlen(n);\n\tfor(int i &#x3D; 0; i &lt; lenN; i++)\n\t\tnewN[lenN - i - 1] &#x3D; n[i];\n    \n\t&#x2F;&#x2F;big data.\n    int *numbers &#x3D; new int[MAXLEN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t&#x2F;&#x2F;Calculate the numbers.\n    while(isIncreaseDigit(numbers, newN))&#123;\n        numbers[0]++;\n\t\tint idx &#x3D; 0;\n        while(numbers[idx] &#x3D;&#x3D; 10)&#123;\n            numbers[idx] &#x3D; 0;\n            ++idx;\n            numbers[idx]++;\n        \t\n        &#125;\n\t\tPrintNumber(numbers, MAXLEN);\n    &#125;\n    delete  []numbers;\n    \n&#125;\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);\n\tchar a[5] &#x3D; &#123;&quot;1239&quot;&#125;;\n\tPrint1ToMaxDigits(a);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>全排列组合</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nbool isIncreaseDigit(int *numbers, char* n)&#123;\n    for(int i &#x3D; 0; n[i] !&#x3D; &#39;\\0&#39;; i++)\n        if(numbers[i] !&#x3D; n[i] - &#39;0&#39;) return true;\n\treturn false;\n&#125;\n\nvoid PrintNumber(int *numbers, int MAXLEN)&#123;\n    int idx &#x3D; MAXLEN - 1;\n\t&#x2F;&#x2F;不输出前置零和全零\n    while(idx &gt;&#x3D; 0 &amp;&amp; numbers[idx] &#x3D;&#x3D; 0) idx --;\n\tif(idx &#x3D;&#x3D; -1) return;\n\tfor(int i &#x3D; idx; i &gt;&#x3D; 0; --i)\n        putchar(numbers[i] + &#39;0&#39;);\n    putchar(&#39;\\n&#39;);\n&#125;\n\nvoid Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &amp;flag)&#123;\n\tif(flag) return;\n\tif(pos &#x3D;&#x3D; -1) &#123;\n\t\t&#x2F;&#x2F;直接用flag剪枝\n\t\tif(!isIncreaseDigit(numbers, newN)) flag  &#x3D; 1;\n        PrintNumber(numbers, lenOfN);\n        return;\n    &#125;\n\n\tif(!isIncreaseDigit(numbers, newN)) return;\n    for(int i &#x3D; 0; i &lt;&#x3D; 9; i++)&#123;\n        numbers[pos] &#x3D; i;        \n        Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag);\t\t\n\t&#125;\n&#125;\n    \nvoid Print1ToMaxDigits(char *n)&#123;\n\tif(n &#x3D;&#x3D; nullptr || strlen(n) &lt;&#x3D; 0) return;\n    char test0[2] &#x3D; &quot;0&quot;;\n\tif(strcmp(test0, n) &#x3D;&#x3D; 0)&#123;\n        printf(&quot;0\\n&quot;);\n        return;\n    &#125;\n    \n\t&#x2F;&#x2F;reverse the input string\n\tint lenOfN &#x3D; strlen(n);\n\tchar *newN &#x3D; new char(lenOfN);\n\t\n\tfor(int i &#x3D; 0; i &lt; lenOfN; i++)\n\t\tnewN[lenOfN - i - 1] &#x3D; n[i];\n    newN[lenOfN] &#x3D; &#39;\\0&#39;;\n\n\t&#x2F;&#x2F;big data.\n    int *numbers &#x3D; new int[lenOfN];\n    memset(numbers, 0, sizeof(numbers));\n    \n\t&#x2F;&#x2F;Calculate the numbers.\n\tint flag &#x3D; 0;\n    Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag);\n    delete  []numbers;\n    \n&#125;\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);\n\t&#x2F;&#x2F; char a[5] &#x3D; &#123;&quot;1239&quot;&#125;;\n\t&#x2F;&#x2F; char a[5] &#x3D; &#123;&quot;0&quot;&#125;;\n\tchar a[50] &#x3D; &#123;&quot;100&quot;&#125;;\n\tPrint1ToMaxDigits(a);\n\t&#x2F;&#x2F; int t1[5] &#x3D; &#123;1, 2&#125;;\n\t&#x2F;&#x2F; printf(&quot;%d&quot;, isIncreaseDigit(t1, a));\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>把自己写懵逼了，调试了好久，原来发现自己剪枝错了。</p>\n<p>由于判断条件在变化，而剪枝条件是不变的，所以不能在更变条件后剪枝</p>\n</blockquote>"},{"title":"面试题-建模","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-11T07:07:27.000Z","_content":"\n收集抽象建模题目。\n\n<!-- more -->\n\n\n\n## 面60：n个骰子的点数\n\n### 题面：\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n \n\n## 思路：\n\n第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    void calProb(vector<int>&prob, int originN, int currentN, int addS){\n        if(currentN == 0){\n            prob[addS - originN]++;\n            return;\n        } \n        for(int i = 1; i <= maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    }\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        vector<int> prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb = pow(maxGV, n);\n        vector<double> res(n * maxGV - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[i] / allProb;\n        return res;\n    }\n};\n\n\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        int addLen = n * maxGV;\n        vector<int>prob[2];\n        for(int i = 0; i < 2; i++){\n            prob[i].resize(addLen);\n            for(int j = 0; j < addLen; j++)\n                prob[i][j] = 0;            \n        }\n\n        int calIdx = 0;\n        for(int i = 0; i < maxGV; i++)\n            prob[1 - calIdx][i] = 1;\n        \n        for(int i = 0; i < n - 1; i++){\n            for(int k = 0; k < addLen; k++){\n                prob[calIdx][k] = 0;\n                for(int j = max(0, k - maxGV); j < k; j++){\n                    prob[calIdx][k] += prob[1 - calIdx][j];\n                }\n            }\n                       \n            calIdx = 1 - calIdx;\n        }\n        double allProb = pow(maxGV, n);\n        vector<double> res(addLen - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[1 - calIdx][i + n -1 ] / allProb;\n        return res;\n    }\n};\n```\n\n## 面61：约瑟夫环\n\n这题老朋友了。\n\n### 题面：\n\n0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof)\n\n## 思路：\n\n数学+ 迭代。\n\n求出`n`个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。\n\n将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)\\%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。\n\n![fig1](http://static.come2rss.xyz/jianzhi_62_fig1.gif)\n\n而且有$f(0,m) = 0$，可以快速用迭代计算出来。\n\n\n\n### 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int lastRemaining(int n, int m) {\n        int res = 0;\n        for(int i = 1;i <= n; i++){\n            res = (res + m) % i;\n        }\n        return res;\n    }\n};\n```\n\n","source":"_posts/刷题/数学\n/面试题-建模.md","raw":"---\ntitle: 面试题-建模\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-11 15:07:27\ntags:\n---\n\n收集抽象建模题目。\n\n<!-- more -->\n\n\n\n## 面60：n个骰子的点数\n\n### 题面：\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n \n\n## 思路：\n\n第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    void calProb(vector<int>&prob, int originN, int currentN, int addS){\n        if(currentN == 0){\n            prob[addS - originN]++;\n            return;\n        } \n        for(int i = 1; i <= maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    }\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        vector<int> prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb = pow(maxGV, n);\n        vector<double> res(n * maxGV - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[i] / allProb;\n        return res;\n    }\n};\n\n\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        int addLen = n * maxGV;\n        vector<int>prob[2];\n        for(int i = 0; i < 2; i++){\n            prob[i].resize(addLen);\n            for(int j = 0; j < addLen; j++)\n                prob[i][j] = 0;            \n        }\n\n        int calIdx = 0;\n        for(int i = 0; i < maxGV; i++)\n            prob[1 - calIdx][i] = 1;\n        \n        for(int i = 0; i < n - 1; i++){\n            for(int k = 0; k < addLen; k++){\n                prob[calIdx][k] = 0;\n                for(int j = max(0, k - maxGV); j < k; j++){\n                    prob[calIdx][k] += prob[1 - calIdx][j];\n                }\n            }\n                       \n            calIdx = 1 - calIdx;\n        }\n        double allProb = pow(maxGV, n);\n        vector<double> res(addLen - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[1 - calIdx][i + n -1 ] / allProb;\n        return res;\n    }\n};\n```\n\n## 面61：约瑟夫环\n\n这题老朋友了。\n\n### 题面：\n\n0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof)\n\n## 思路：\n\n数学+ 迭代。\n\n求出`n`个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。\n\n将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)\\%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。\n\n![fig1](http://static.come2rss.xyz/jianzhi_62_fig1.gif)\n\n而且有$f(0,m) = 0$，可以快速用迭代计算出来。\n\n\n\n### 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int lastRemaining(int n, int m) {\n        int res = 0;\n        for(int i = 1;i <= n; i++){\n            res = (res + m) % i;\n        }\n        return res;\n    }\n};\n```\n\n","slug":"刷题-数学-面试题-建模","published":1,"updated":"2021-01-28T14:04:37.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5o003fl5uobxmba9zt","content":"<p>收集抽象建模题目。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"面60：n个骰子的点数\"><a href=\"#面60：n个骰子的点数\" class=\"headerlink\" title=\"面60：n个骰子的点数\"></a>面60：n个骰子的点数</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>\n<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS)&#123;\n        if(currentN &#x3D;&#x3D; 0)&#123;\n            prob[addS - originN]++;\n            return;\n        &#125; \n        for(int i &#x3D; 1; i &lt;&#x3D; maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    &#125;\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        vector&lt;int&gt; prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(n * maxGV - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[i] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        int addLen &#x3D; n * maxGV;\n        vector&lt;int&gt;prob[2];\n        for(int i &#x3D; 0; i &lt; 2; i++)&#123;\n            prob[i].resize(addLen);\n            for(int j &#x3D; 0; j &lt; addLen; j++)\n                prob[i][j] &#x3D; 0;            \n        &#125;\n\n        int calIdx &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; maxGV; i++)\n            prob[1 - calIdx][i] &#x3D; 1;\n        \n        for(int i &#x3D; 0; i &lt; n - 1; i++)&#123;\n            for(int k &#x3D; 0; k &lt; addLen; k++)&#123;\n                prob[calIdx][k] &#x3D; 0;\n                for(int j &#x3D; max(0, k - maxGV); j &lt; k; j++)&#123;\n                    prob[calIdx][k] +&#x3D; prob[1 - calIdx][j];\n                &#125;\n            &#125;\n                       \n            calIdx &#x3D; 1 - calIdx;\n        &#125;\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(addLen - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[1 - calIdx][i + n -1 ] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面61：约瑟夫环\"><a href=\"#面61：约瑟夫环\" class=\"headerlink\" title=\"面61：约瑟夫环\"></a>面61：约瑟夫环</h2><p>这题老朋友了。</p>\n<h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>\n<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>\n<p>来源：<a href=\"https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof\">力扣（LeetCode）</a></p>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>数学+ 迭代。</p>\n<p>求出<code>n</code>个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。</p>\n<p>将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。</p>\n<p><img src=\"http://static.come2rss.xyz/jianzhi_62_fig1.gif\" alt=\"fig1\"></p>\n<p>而且有$f(0,m) = 0$，可以快速用迭代计算出来。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int lastRemaining(int n, int m) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n            res &#x3D; (res + m) % i;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"RWTQJ2","excerpt":"<p>收集抽象建模题目。</p>","more":"<h2 id=\"面60：n个骰子的点数\"><a href=\"#面60：n个骰子的点数\" class=\"headerlink\" title=\"面60：n个骰子的点数\"></a>面60：n个骰子的点数</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>\n<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS)&#123;\n        if(currentN &#x3D;&#x3D; 0)&#123;\n            prob[addS - originN]++;\n            return;\n        &#125; \n        for(int i &#x3D; 1; i &lt;&#x3D; maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    &#125;\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        vector&lt;int&gt; prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(n * maxGV - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[i] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        int addLen &#x3D; n * maxGV;\n        vector&lt;int&gt;prob[2];\n        for(int i &#x3D; 0; i &lt; 2; i++)&#123;\n            prob[i].resize(addLen);\n            for(int j &#x3D; 0; j &lt; addLen; j++)\n                prob[i][j] &#x3D; 0;            \n        &#125;\n\n        int calIdx &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; maxGV; i++)\n            prob[1 - calIdx][i] &#x3D; 1;\n        \n        for(int i &#x3D; 0; i &lt; n - 1; i++)&#123;\n            for(int k &#x3D; 0; k &lt; addLen; k++)&#123;\n                prob[calIdx][k] &#x3D; 0;\n                for(int j &#x3D; max(0, k - maxGV); j &lt; k; j++)&#123;\n                    prob[calIdx][k] +&#x3D; prob[1 - calIdx][j];\n                &#125;\n            &#125;\n                       \n            calIdx &#x3D; 1 - calIdx;\n        &#125;\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(addLen - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[1 - calIdx][i + n -1 ] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面61：约瑟夫环\"><a href=\"#面61：约瑟夫环\" class=\"headerlink\" title=\"面61：约瑟夫环\"></a>面61：约瑟夫环</h2><p>这题老朋友了。</p>\n<h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>\n<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>\n<p>来源：<a href=\"https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof\">力扣（LeetCode）</a></p>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>数学+ 迭代。</p>\n<p>求出<code>n</code>个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。</p>\n<p>将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。</p>\n<p><img src=\"http://static.come2rss.xyz/jianzhi_62_fig1.gif\" alt=\"fig1\"></p>\n<p>而且有$f(0,m) = 0$，可以快速用迭代计算出来。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int lastRemaining(int n, int m) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n            res &#x3D; (res + m) % i;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题44：1出现的个数","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:22:13.000Z","_content":"\n\n\n\n\n广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理\n\n<!-- more -->\n\n### 题目：\n\n统计从1到N的所有数字的1的出现次数。\n\n### 思路：\n\n第一种：所有人都能想出直接暴力解的算法。\n\n第二种：参考其他人的解法。\n\n> 设N = abcde ,其中abcde分别为十进制中各位上的数字。\n> 如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。\n> ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~~199，1100~~1199,2100~~2199，，…，11100~~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。\n> ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~~199，1100~~1199,2100~~2199，，….，11100~~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~~12113,一共114个，等于低位数字（113）+1。\n> ③ 如果百位上数字大于1（2~~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~~199,1100~~1199，2100~~2199，…，11100~~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。\n> ——参考牛客网@藍裙子的百合魂\n\n### 代码：\n\n```\nint CounterOf1(int x){\n\tif(x <=  0) return 0;\n    int len = 0, tempX = x, judugNum = 1;\n    while(tempX){\n        tempX = tempX / 10;\n        len ++;\n    }\n    \n    int power = 10, counter = 0 ;\n    for(int i = 0; i < len; i++){\n        int liPower = power / 10;\n        int num = x % power / liPower;\n        if(num > judugNum ){\n            counter += (x / power + 1) * liPower;\n        }else if(num == judugNum ){\n            counter += (x / power) * liPower + x % liPower + 1;            \n        }else\n            counter += x / power * liPower;\n    \tpower *= 10;\n    }\n    return counter;\n}\n```\n\n测试可见 [牛客](https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6)\n\n","source":"_posts/刷题/数学\n/面试题44：1出现的个数.md","raw":"---\ntitle: 面试题44：1出现的个数\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:22:13\ntags:\n---\n\n\n\n\n\n广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理\n\n<!-- more -->\n\n### 题目：\n\n统计从1到N的所有数字的1的出现次数。\n\n### 思路：\n\n第一种：所有人都能想出直接暴力解的算法。\n\n第二种：参考其他人的解法。\n\n> 设N = abcde ,其中abcde分别为十进制中各位上的数字。\n> 如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。\n> ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~~199，1100~~1199,2100~~2199，，…，11100~~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。\n> ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~~199，1100~~1199,2100~~2199，，….，11100~~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~~12113,一共114个，等于低位数字（113）+1。\n> ③ 如果百位上数字大于1（2~~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~~199,1100~~1199，2100~~2199，…，11100~~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。\n> ——参考牛客网@藍裙子的百合魂\n\n### 代码：\n\n```\nint CounterOf1(int x){\n\tif(x <=  0) return 0;\n    int len = 0, tempX = x, judugNum = 1;\n    while(tempX){\n        tempX = tempX / 10;\n        len ++;\n    }\n    \n    int power = 10, counter = 0 ;\n    for(int i = 0; i < len; i++){\n        int liPower = power / 10;\n        int num = x % power / liPower;\n        if(num > judugNum ){\n            counter += (x / power + 1) * liPower;\n        }else if(num == judugNum ){\n            counter += (x / power) * liPower + x % liPower + 1;            \n        }else\n            counter += x / power * liPower;\n    \tpower *= 10;\n    }\n    return counter;\n}\n```\n\n测试可见 [牛客](https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6)\n\n","slug":"刷题-数学-面试题44：1出现的个数","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5p003gl5uofq9qcr1o","content":"<p>广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理</p>\n<span id=\"more\"></span>\n\n<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>统计从1到N的所有数字的1的出现次数。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种：所有人都能想出直接暴力解的算法。</p>\n<p>第二种：参考其他人的解法。</p>\n<blockquote>\n<p>设N = abcde ,其中abcde分别为十进制中各位上的数字。<br>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。<br>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100<del>199，1100</del>1199,2100<del>2199，，…，11100</del>11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。<br>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100<del>199，1100</del>1199,2100<del>2199，，….，11100</del>11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100<del>12113,一共114个，等于低位数字（113）+1。<br>③ 如果百位上数字大于1（2</del>9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100<del>199,1100</del>1199，2100<del>2199，…，11100</del>11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。<br>——参考牛客网@藍裙子的百合魂</p>\n</blockquote>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int CounterOf1(int x)&#123;\n\tif(x &lt;&#x3D;  0) return 0;\n    int len &#x3D; 0, tempX &#x3D; x, judugNum &#x3D; 1;\n    while(tempX)&#123;\n        tempX &#x3D; tempX &#x2F; 10;\n        len ++;\n    &#125;\n    \n    int power &#x3D; 10, counter &#x3D; 0 ;\n    for(int i &#x3D; 0; i &lt; len; i++)&#123;\n        int liPower &#x3D; power &#x2F; 10;\n        int num &#x3D; x % power &#x2F; liPower;\n        if(num &gt; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power + 1) * liPower;\n        &#125;else if(num &#x3D;&#x3D; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power) * liPower + x % liPower + 1;            \n        &#125;else\n            counter +&#x3D; x &#x2F; power * liPower;\n    \tpower *&#x3D; 10;\n    &#125;\n    return counter;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试可见 <a href=\"https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6\">牛客</a></p>\n","site":{"data":{}},"abbrlink":"1TG6JR8","excerpt":"<p>广受欢迎的剑指offer的神奇思路在网络上似乎并不多见，我个人也没看懂她的推理</p>","more":"<h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>统计从1到N的所有数字的1的出现次数。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种：所有人都能想出直接暴力解的算法。</p>\n<p>第二种：参考其他人的解法。</p>\n<blockquote>\n<p>设N = abcde ,其中abcde分别为十进制中各位上的数字。<br>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。<br>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100<del>199，1100</del>1199,2100<del>2199，，…，11100</del>11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。<br>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100<del>199，1100</del>1199,2100<del>2199，，….，11100</del>11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100<del>12113,一共114个，等于低位数字（113）+1。<br>③ 如果百位上数字大于1（2</del>9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100<del>199,1100</del>1199，2100<del>2199，…，11100</del>11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。<br>——参考牛客网@藍裙子的百合魂</p>\n</blockquote>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int CounterOf1(int x)&#123;\n\tif(x &lt;&#x3D;  0) return 0;\n    int len &#x3D; 0, tempX &#x3D; x, judugNum &#x3D; 1;\n    while(tempX)&#123;\n        tempX &#x3D; tempX &#x2F; 10;\n        len ++;\n    &#125;\n    \n    int power &#x3D; 10, counter &#x3D; 0 ;\n    for(int i &#x3D; 0; i &lt; len; i++)&#123;\n        int liPower &#x3D; power &#x2F; 10;\n        int num &#x3D; x % power &#x2F; liPower;\n        if(num &gt; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power + 1) * liPower;\n        &#125;else if(num &#x3D;&#x3D; judugNum )&#123;\n            counter +&#x3D; (x &#x2F; power) * liPower + x % liPower + 1;            \n        &#125;else\n            counter +&#x3D; x &#x2F; power * liPower;\n    \tpower *&#x3D; 10;\n    &#125;\n    return counter;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>测试可见 <a href=\"https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6\">牛客</a></p>"},{"title":"面试题49：丑数","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:22:01.000Z","_content":"\n\n<!-- more -->","source":"_posts/刷题/数学\n/面试题49：丑数.md","raw":"---\ntitle: 面试题49：丑数\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:22:01\ntags:\n---\n\n\n<!-- more -->","slug":"刷题-数学-面试题49：丑数","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5p003hl5uoc30e7kc2","content":"<span id=\"more\"></span>","site":{"data":{}},"abbrlink":"1RX02Z6","excerpt":"","more":""},{"title":"146. LRU Cache","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-27T03:09:29.000Z","_content":"\n\n\n\n\n\n## 思路：\n\nLRU实现中”删除最近最少使用的数据值“表达可能会让人产生误解，更准确的意思是”删除最长时间未使用的数据值“。\n\n硬件的实现可以用每次更新和添加元素`A`，累加除`A`之外的所有元素的计数值。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass LRUCache {\npublic:\n    // 软件实现LRU毕竟和硬件不同，需要考虑元素的放置和组成位置；\n    // hash + 双向链表的结构组成能够在O(1)的速度下获取元素位置\n    // 双向链表的支持保证了删除和在首位添加元素的速度也在O(1)\n    using pairii = pair<int,int>;\n    list<pairii> content; \n    unordered_map<int, list<pairii>::iterator> hash;\n    int capacity;\n    \n    LRUCache(int _capacity) : capacity(_capacity) {\n        //如果手写 list 添加 虚拟头尾节点更佳\n    }\n    \n    int get(int key) {\n        if(hash.find(key) == hash.end()){\n            return -1;\n        }\n        // 如果能够声明一个属于友元的 list 直接对指针进行操作 效率会更好\n        pairii node = *hash[key]; //慎用 删除后的iterator\n     \n        content.erase(hash[key]); \n        content.emplace_front(node);\n        hash[key] = content.begin();\n        return node.second;\n    }\n    \n    void put(int key, int value) {\n        pairii node{key, value};\n        if(hash.find(key) != hash.end()){ // 没有找到对应的value\n            content.erase(hash[key]);\n        }else if(content.size() == capacity){ // cache容量已满, 删除最长时间未使用的数据值\n            hash.erase(content.back().first);\n            content.pop_back(); //        \n        }\n        content.emplace_front(node);\n        hash[key] = content.begin();\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n","source":"_posts/刷题/模拟\n/146-LRU-Cache.md","raw":"---\ntitle: 146. LRU Cache\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-27 11:09:29\ntags:\ncategories:\n---\n\n\n\n\n\n\n## 思路：\n\nLRU实现中”删除最近最少使用的数据值“表达可能会让人产生误解，更准确的意思是”删除最长时间未使用的数据值“。\n\n硬件的实现可以用每次更新和添加元素`A`，累加除`A`之外的所有元素的计数值。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass LRUCache {\npublic:\n    // 软件实现LRU毕竟和硬件不同，需要考虑元素的放置和组成位置；\n    // hash + 双向链表的结构组成能够在O(1)的速度下获取元素位置\n    // 双向链表的支持保证了删除和在首位添加元素的速度也在O(1)\n    using pairii = pair<int,int>;\n    list<pairii> content; \n    unordered_map<int, list<pairii>::iterator> hash;\n    int capacity;\n    \n    LRUCache(int _capacity) : capacity(_capacity) {\n        //如果手写 list 添加 虚拟头尾节点更佳\n    }\n    \n    int get(int key) {\n        if(hash.find(key) == hash.end()){\n            return -1;\n        }\n        // 如果能够声明一个属于友元的 list 直接对指针进行操作 效率会更好\n        pairii node = *hash[key]; //慎用 删除后的iterator\n     \n        content.erase(hash[key]); \n        content.emplace_front(node);\n        hash[key] = content.begin();\n        return node.second;\n    }\n    \n    void put(int key, int value) {\n        pairii node{key, value};\n        if(hash.find(key) != hash.end()){ // 没有找到对应的value\n            content.erase(hash[key]);\n        }else if(content.size() == capacity){ // cache容量已满, 删除最长时间未使用的数据值\n            hash.erase(content.back().first);\n            content.pop_back(); //        \n        }\n        content.emplace_front(node);\n        hash[key] = content.begin();\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n","slug":"刷题-模拟-146-LRU-Cache","published":1,"updated":"2021-02-27T03:11:53.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5q003il5uobgfz1vze","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>LRU实现中”删除最近最少使用的数据值“表达可能会让人产生误解，更准确的意思是”删除最长时间未使用的数据值“。</p>\n<p>硬件的实现可以用每次更新和添加元素<code>A</code>，累加除<code>A</code>之外的所有元素的计数值。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class LRUCache &#123;\npublic:\n    &#x2F;&#x2F; 软件实现LRU毕竟和硬件不同，需要考虑元素的放置和组成位置；\n    &#x2F;&#x2F; hash + 双向链表的结构组成能够在O(1)的速度下获取元素位置\n    &#x2F;&#x2F; 双向链表的支持保证了删除和在首位添加元素的速度也在O(1)\n    using pairii &#x3D; pair&lt;int,int&gt;;\n    list&lt;pairii&gt; content; \n    unordered_map&lt;int, list&lt;pairii&gt;::iterator&gt; hash;\n    int capacity;\n    \n    LRUCache(int _capacity) : capacity(_capacity) &#123;\n        &#x2F;&#x2F;如果手写 list 添加 虚拟头尾节点更佳\n    &#125;\n    \n    int get(int key) &#123;\n        if(hash.find(key) &#x3D;&#x3D; hash.end())&#123;\n            return -1;\n        &#125;\n        &#x2F;&#x2F; 如果能够声明一个属于友元的 list 直接对指针进行操作 效率会更好\n        pairii node &#x3D; *hash[key]; &#x2F;&#x2F;慎用 删除后的iterator\n     \n        content.erase(hash[key]); \n        content.emplace_front(node);\n        hash[key] &#x3D; content.begin();\n        return node.second;\n    &#125;\n    \n    void put(int key, int value) &#123;\n        pairii node&#123;key, value&#125;;\n        if(hash.find(key) !&#x3D; hash.end())&#123; &#x2F;&#x2F; 没有找到对应的value\n            content.erase(hash[key]);\n        &#125;else if(content.size() &#x3D;&#x3D; capacity)&#123; &#x2F;&#x2F; cache容量已满, 删除最长时间未使用的数据值\n            hash.erase(content.back().first);\n            content.pop_back(); &#x2F;&#x2F;        \n        &#125;\n        content.emplace_front(node);\n        hash[key] &#x3D; content.begin();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj &#x3D; new LRUCache(capacity);\n * int param_1 &#x3D; obj-&gt;get(key);\n * obj-&gt;put(key,value);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1FM26S9","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>LRU实现中”删除最近最少使用的数据值“表达可能会让人产生误解，更准确的意思是”删除最长时间未使用的数据值“。</p>\n<p>硬件的实现可以用每次更新和添加元素<code>A</code>，累加除<code>A</code>之外的所有元素的计数值。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class LRUCache &#123;\npublic:\n    &#x2F;&#x2F; 软件实现LRU毕竟和硬件不同，需要考虑元素的放置和组成位置；\n    &#x2F;&#x2F; hash + 双向链表的结构组成能够在O(1)的速度下获取元素位置\n    &#x2F;&#x2F; 双向链表的支持保证了删除和在首位添加元素的速度也在O(1)\n    using pairii &#x3D; pair&lt;int,int&gt;;\n    list&lt;pairii&gt; content; \n    unordered_map&lt;int, list&lt;pairii&gt;::iterator&gt; hash;\n    int capacity;\n    \n    LRUCache(int _capacity) : capacity(_capacity) &#123;\n        &#x2F;&#x2F;如果手写 list 添加 虚拟头尾节点更佳\n    &#125;\n    \n    int get(int key) &#123;\n        if(hash.find(key) &#x3D;&#x3D; hash.end())&#123;\n            return -1;\n        &#125;\n        &#x2F;&#x2F; 如果能够声明一个属于友元的 list 直接对指针进行操作 效率会更好\n        pairii node &#x3D; *hash[key]; &#x2F;&#x2F;慎用 删除后的iterator\n     \n        content.erase(hash[key]); \n        content.emplace_front(node);\n        hash[key] &#x3D; content.begin();\n        return node.second;\n    &#125;\n    \n    void put(int key, int value) &#123;\n        pairii node&#123;key, value&#125;;\n        if(hash.find(key) !&#x3D; hash.end())&#123; &#x2F;&#x2F; 没有找到对应的value\n            content.erase(hash[key]);\n        &#125;else if(content.size() &#x3D;&#x3D; capacity)&#123; &#x2F;&#x2F; cache容量已满, 删除最长时间未使用的数据值\n            hash.erase(content.back().first);\n            content.pop_back(); &#x2F;&#x2F;        \n        &#125;\n        content.emplace_front(node);\n        hash[key] &#x3D; content.begin();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj &#x3D; new LRUCache(capacity);\n * int param_1 &#x3D; obj-&gt;get(key);\n * obj-&gt;put(key,value);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面5：合并数组","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:33:19.000Z","_content":"\n\n\n\n### 题目\n\n将一个字符串在不新建字符串的基础上将源字符串的空格替换为`%20`。输入字符串和总空间长度。\n\n\n\n### 思路\n\n明显就是遍历一次统计空格，计算出多余的字符数，并从后向前复制字符并替换字符。\n\n\n\n<!-- more -->\n\n### 样例\n\n```\n# #\n```\n\n### 代码\n\n```\nvoid replaceBlank(char str[], int length){\n    int len = 0, addLen = 0;\n    for(int i = 0; str[i] != '\\0'; i++){\n        if(str[i] == ' ') addlen + = 2;\n        len ++;\n    }\n    int endP1 = len - 1, endP2 = len + addLen - 1;\n    if(endP2 >= length) return;\n    for(; endP1 != endP2; endP1--, endP2-- )\n\t\tif(str[endP1] == ' '){\n            str[endP2] = '0';\n            str[endP2 - 1] = '2';\n\t\t   str[endP2 - 2] = '0'\n\t\t   endP2 -= 2;                            \n        }else str[endP2] = str[endP1];\n\t}\n    return;\n}\n```\n\n## 相关题目\n\n比如说将一个以排序的数组插入到另一个已排序的数组，并保持有序。同样从尾部插入更快。\n\n思维再发散一下就有归并排序中的两个数组的合并问题，不过此时是创建一个辅助数组 。","source":"_posts/刷题/模拟\n/面5：合并数组.md","raw":"---\ntitle: 面5：合并数组\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:33:19\n---\n\n\n\n\n### 题目\n\n将一个字符串在不新建字符串的基础上将源字符串的空格替换为`%20`。输入字符串和总空间长度。\n\n\n\n### 思路\n\n明显就是遍历一次统计空格，计算出多余的字符数，并从后向前复制字符并替换字符。\n\n\n\n<!-- more -->\n\n### 样例\n\n```\n# #\n```\n\n### 代码\n\n```\nvoid replaceBlank(char str[], int length){\n    int len = 0, addLen = 0;\n    for(int i = 0; str[i] != '\\0'; i++){\n        if(str[i] == ' ') addlen + = 2;\n        len ++;\n    }\n    int endP1 = len - 1, endP2 = len + addLen - 1;\n    if(endP2 >= length) return;\n    for(; endP1 != endP2; endP1--, endP2-- )\n\t\tif(str[endP1] == ' '){\n            str[endP2] = '0';\n            str[endP2 - 1] = '2';\n\t\t   str[endP2 - 2] = '0'\n\t\t   endP2 -= 2;                            \n        }else str[endP2] = str[endP1];\n\t}\n    return;\n}\n```\n\n## 相关题目\n\n比如说将一个以排序的数组插入到另一个已排序的数组，并保持有序。同样从尾部插入更快。\n\n思维再发散一下就有归并排序中的两个数组的合并问题，不过此时是创建一个辅助数组 。","slug":"刷题-模拟-面5：合并数组","published":1,"updated":"2021-02-14T13:13:57.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5q003jl5uo4v9wdkwf","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>将一个字符串在不新建字符串的基础上将源字符串的空格替换为<code>%20</code>。输入字符串和总空间长度。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>明显就是遍历一次统计空格，计算出多余的字符数，并从后向前复制字符并替换字符。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"># #<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void replaceBlank(char str[], int length)&#123;\n    int len &#x3D; 0, addLen &#x3D; 0;\n    for(int i &#x3D; 0; str[i] !&#x3D; &#39;\\0&#39;; i++)&#123;\n        if(str[i] &#x3D;&#x3D; &#39; &#39;) addlen + &#x3D; 2;\n        len ++;\n    &#125;\n    int endP1 &#x3D; len - 1, endP2 &#x3D; len + addLen - 1;\n    if(endP2 &gt;&#x3D; length) return;\n    for(; endP1 !&#x3D; endP2; endP1--, endP2-- )\n\t\tif(str[endP1] &#x3D;&#x3D; &#39; &#39;)&#123;\n            str[endP2] &#x3D; &#39;0&#39;;\n            str[endP2 - 1] &#x3D; &#39;2&#39;;\n\t\t   str[endP2 - 2] &#x3D; &#39;0&#39;\n\t\t   endP2 -&#x3D; 2;                            \n        &#125;else str[endP2] &#x3D; str[endP1];\n\t&#125;\n    return;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"相关题目\"><a href=\"#相关题目\" class=\"headerlink\" title=\"相关题目\"></a>相关题目</h2><p>比如说将一个以排序的数组插入到另一个已排序的数组，并保持有序。同样从尾部插入更快。</p>\n<p>思维再发散一下就有归并排序中的两个数组的合并问题，不过此时是创建一个辅助数组 。</p>\n","site":{"data":{}},"abbrlink":"2X3MV1R","excerpt":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>将一个字符串在不新建字符串的基础上将源字符串的空格替换为<code>%20</code>。输入字符串和总空间长度。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>明显就是遍历一次统计空格，计算出多余的字符数，并从后向前复制字符并替换字符。</p>","more":"<h3 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"># #<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void replaceBlank(char str[], int length)&#123;\n    int len &#x3D; 0, addLen &#x3D; 0;\n    for(int i &#x3D; 0; str[i] !&#x3D; &#39;\\0&#39;; i++)&#123;\n        if(str[i] &#x3D;&#x3D; &#39; &#39;) addlen + &#x3D; 2;\n        len ++;\n    &#125;\n    int endP1 &#x3D; len - 1, endP2 &#x3D; len + addLen - 1;\n    if(endP2 &gt;&#x3D; length) return;\n    for(; endP1 !&#x3D; endP2; endP1--, endP2-- )\n\t\tif(str[endP1] &#x3D;&#x3D; &#39; &#39;)&#123;\n            str[endP2] &#x3D; &#39;0&#39;;\n            str[endP2 - 1] &#x3D; &#39;2&#39;;\n\t\t   str[endP2 - 2] &#x3D; &#39;0&#39;\n\t\t   endP2 -&#x3D; 2;                            \n        &#125;else str[endP2] &#x3D; str[endP1];\n\t&#125;\n    return;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"相关题目\"><a href=\"#相关题目\" class=\"headerlink\" title=\"相关题目\"></a>相关题目</h2><p>比如说将一个以排序的数组插入到另一个已排序的数组，并保持有序。同样从尾部插入更快。</p>\n<p>思维再发散一下就有归并排序中的两个数组的合并问题，不过此时是创建一个辅助数组 。</p>"},{"title":"面试 模拟题","thumbnail":"http://static.come2rss.xyz/科罗拉多州大沙丘公园.jpg","toc":true,"top":10,"date":"2020-08-07T05:21:49.000Z","_content":"\n\n\n\n\n收集一些模拟题。\n\n<!-- more -->\n\n## 面29：打印矩阵\n\n### 题面：\n\n给出一个N*M的矩阵，按照从里到外的顺序顺时针打印矩阵。\n\n### 思路：\n\n（代码一）模拟题就是硬上。由于整个打印过程可以看成一圈圈的打印，所以按圈地打印。同时为了保持打印动作的一致行，都是打印一行或者一列差一个单元矩阵。\n\n不考虑上面的一致性，直接考虑填涂条件的话，也就复杂一点点。\n\n### 代码：\n\n一种可以优美的实现N*N的正方形矩阵填充的代码。\n\n```\n#include<string>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nvoid printNumberRect(int n, int m){\n\tvector<vector<int> > rect;\n    rect.resize(n);\n    for(int i = 0; i < rect.size(); i++) rect[i].resize(m);\n    \n    int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1;\n    int counter = 1;\n    while(xLeftUp <= xRightDown && yLeftUp <= yRightDown){\n        for(; y < yRightDown; y++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       \n        for(; x < xRightDown; x++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       \n        for(; y > yLeftUp; y--){            \n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       \n        for(; x > xLeftUp; x--){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    }\n    if(xLeftUp == xRightDown + 2 && yLeftUp == yRightDown + 2 ) rect[x - 1][y - 1] = counter;\n    for(int i = 0; i < rect.size(); i++){\n        for(int j = 0; j < rect[i].size(); j++)\n            printf(\"%d \", rect[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    //freopen(\"data.in\", \"r\", stdin);\n   printNumberRect(0, 0);\n   printNumberRect(2, 3);\n   printNumberRect(6, 3);\n   printNumberRect(3, 3);\n}\n```\n\n就直接填写。\n\n```\nvoid printNumberRect(int n, int m){\n\tvector<vector<int> > rect;\n    rect.resize(n);\n    for(int i = 0; i < rect.size(); i++) rect[i].resize(m);\n    \n    int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1;\n    int counter = 1;\n    while(xLeftUp <= xRightDown && yLeftUp <= yRightDown){\n        for(; y <= yRightDown; y++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        for(x++, y--; x <= xRightDown; x++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       //横着画可能会重叠\n        for(x--, y--; y >= yLeftUp && x > xLeftUp; y--){            \n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        //同上\n        for(y++, x--; x > xLeftUp && y < yRightDown; x--){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    }\n\n    for(int i = 0; i < rect.size(); i++){\n        for(int j = 0; j < rect[i].size(); j++)\n            printf(\"%d \", rect[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n```\n\n","source":"_posts/刷题/模拟\n/面试-模拟题.md","raw":"---\ntitle: 面试 模拟题\nthumbnail: 'http://static.come2rss.xyz/科罗拉多州大沙丘公园.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:21:49\n---\n\n\n\n\n\n收集一些模拟题。\n\n<!-- more -->\n\n## 面29：打印矩阵\n\n### 题面：\n\n给出一个N*M的矩阵，按照从里到外的顺序顺时针打印矩阵。\n\n### 思路：\n\n（代码一）模拟题就是硬上。由于整个打印过程可以看成一圈圈的打印，所以按圈地打印。同时为了保持打印动作的一致行，都是打印一行或者一列差一个单元矩阵。\n\n不考虑上面的一致性，直接考虑填涂条件的话，也就复杂一点点。\n\n### 代码：\n\n一种可以优美的实现N*N的正方形矩阵填充的代码。\n\n```\n#include<string>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nvoid printNumberRect(int n, int m){\n\tvector<vector<int> > rect;\n    rect.resize(n);\n    for(int i = 0; i < rect.size(); i++) rect[i].resize(m);\n    \n    int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1;\n    int counter = 1;\n    while(xLeftUp <= xRightDown && yLeftUp <= yRightDown){\n        for(; y < yRightDown; y++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       \n        for(; x < xRightDown; x++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       \n        for(; y > yLeftUp; y--){            \n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       \n        for(; x > xLeftUp; x--){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    }\n    if(xLeftUp == xRightDown + 2 && yLeftUp == yRightDown + 2 ) rect[x - 1][y - 1] = counter;\n    for(int i = 0; i < rect.size(); i++){\n        for(int j = 0; j < rect[i].size(); j++)\n            printf(\"%d \", rect[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    //freopen(\"data.in\", \"r\", stdin);\n   printNumberRect(0, 0);\n   printNumberRect(2, 3);\n   printNumberRect(6, 3);\n   printNumberRect(3, 3);\n}\n```\n\n就直接填写。\n\n```\nvoid printNumberRect(int n, int m){\n\tvector<vector<int> > rect;\n    rect.resize(n);\n    for(int i = 0; i < rect.size(); i++) rect[i].resize(m);\n    \n    int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1;\n    int counter = 1;\n    while(xLeftUp <= xRightDown && yLeftUp <= yRightDown){\n        for(; y <= yRightDown; y++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        for(x++, y--; x <= xRightDown; x++){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n       //横着画可能会重叠\n        for(x--, y--; y >= yLeftUp && x > xLeftUp; y--){            \n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        //同上\n        for(y++, x--; x > xLeftUp && y < yRightDown; x--){\n\t\t\trect[x][y] = counter;\n            counter++;\n        }\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    }\n\n    for(int i = 0; i < rect.size(); i++){\n        for(int j = 0; j < rect[i].size(); j++)\n            printf(\"%d \", rect[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n```\n\n","slug":"刷题-模拟-面试-模拟题","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5r003kl5uog6nua06l","content":"<p>收集一些模拟题。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"面29：打印矩阵\"><a href=\"#面29：打印矩阵\" class=\"headerlink\" title=\"面29：打印矩阵\"></a>面29：打印矩阵</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个N*M的矩阵，按照从里到外的顺序顺时针打印矩阵。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>（代码一）模拟题就是硬上。由于整个打印过程可以看成一圈圈的打印，所以按圈地打印。同时为了保持打印动作的一致行，都是打印一行或者一列差一个单元矩阵。</p>\n<p>不考虑上面的一致性，直接考虑填涂条件的话，也就复杂一点点。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>一种可以优美的实现N*N的正方形矩阵填充的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nvoid printNumberRect(int n, int m)&#123;\n\tvector&lt;vector&lt;int&gt; &gt; rect;\n    rect.resize(n);\n    for(int i &#x3D; 0; i &lt; rect.size(); i++) rect[i].resize(m);\n    \n    int x &#x3D; 0, y &#x3D; 0, xLeftUp &#x3D; 0, yLeftUp &#x3D; 0, xRightDown &#x3D; n - 1, yRightDown &#x3D; m - 1;\n    int counter &#x3D; 1;\n    while(xLeftUp &lt;&#x3D; xRightDown &amp;&amp; yLeftUp &lt;&#x3D; yRightDown)&#123;\n        for(; y &lt; yRightDown; y++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       \n        for(; x &lt; xRightDown; x++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       \n        for(; y &gt; yLeftUp; y--)&#123;            \n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       \n        for(; x &gt; xLeftUp; x--)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    &#125;\n    if(xLeftUp &#x3D;&#x3D; xRightDown + 2 &amp;&amp; yLeftUp &#x3D;&#x3D; yRightDown + 2 ) rect[x - 1][y - 1] &#x3D; counter;\n    for(int i &#x3D; 0; i &lt; rect.size(); i++)&#123;\n        for(int j &#x3D; 0; j &lt; rect[i].size(); j++)\n            printf(&quot;%d &quot;, rect[i][j]);\n        printf(&quot;\\n&quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;\n\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);\n   printNumberRect(0, 0);\n   printNumberRect(2, 3);\n   printNumberRect(6, 3);\n   printNumberRect(3, 3);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>就直接填写。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void printNumberRect(int n, int m)&#123;\n\tvector&lt;vector&lt;int&gt; &gt; rect;\n    rect.resize(n);\n    for(int i &#x3D; 0; i &lt; rect.size(); i++) rect[i].resize(m);\n    \n    int x &#x3D; 0, y &#x3D; 0, xLeftUp &#x3D; 0, yLeftUp &#x3D; 0, xRightDown &#x3D; n - 1, yRightDown &#x3D; m - 1;\n    int counter &#x3D; 1;\n    while(xLeftUp &lt;&#x3D; xRightDown &amp;&amp; yLeftUp &lt;&#x3D; yRightDown)&#123;\n        for(; y &lt;&#x3D; yRightDown; y++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        for(x++, y--; x &lt;&#x3D; xRightDown; x++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       &#x2F;&#x2F;横着画可能会重叠\n        for(x--, y--; y &gt;&#x3D; yLeftUp &amp;&amp; x &gt; xLeftUp; y--)&#123;            \n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        &#x2F;&#x2F;同上\n        for(y++, x--; x &gt; xLeftUp &amp;&amp; y &lt; yRightDown; x--)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    &#125;\n\n    for(int i &#x3D; 0; i &lt; rect.size(); i++)&#123;\n        for(int j &#x3D; 0; j &lt; rect[i].size(); j++)\n            printf(&quot;%d &quot;, rect[i][j]);\n        printf(&quot;\\n&quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3H8TJ22","excerpt":"<p>收集一些模拟题。</p>","more":"<h2 id=\"面29：打印矩阵\"><a href=\"#面29：打印矩阵\" class=\"headerlink\" title=\"面29：打印矩阵\"></a>面29：打印矩阵</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个N*M的矩阵，按照从里到外的顺序顺时针打印矩阵。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>（代码一）模拟题就是硬上。由于整个打印过程可以看成一圈圈的打印，所以按圈地打印。同时为了保持打印动作的一致行，都是打印一行或者一列差一个单元矩阵。</p>\n<p>不考虑上面的一致性，直接考虑填涂条件的话，也就复杂一点点。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>一种可以优美的实现N*N的正方形矩阵填充的代码。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;stack&gt;\n#include&lt;map&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nvoid printNumberRect(int n, int m)&#123;\n\tvector&lt;vector&lt;int&gt; &gt; rect;\n    rect.resize(n);\n    for(int i &#x3D; 0; i &lt; rect.size(); i++) rect[i].resize(m);\n    \n    int x &#x3D; 0, y &#x3D; 0, xLeftUp &#x3D; 0, yLeftUp &#x3D; 0, xRightDown &#x3D; n - 1, yRightDown &#x3D; m - 1;\n    int counter &#x3D; 1;\n    while(xLeftUp &lt;&#x3D; xRightDown &amp;&amp; yLeftUp &lt;&#x3D; yRightDown)&#123;\n        for(; y &lt; yRightDown; y++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       \n        for(; x &lt; xRightDown; x++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       \n        for(; y &gt; yLeftUp; y--)&#123;            \n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       \n        for(; x &gt; xLeftUp; x--)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    &#125;\n    if(xLeftUp &#x3D;&#x3D; xRightDown + 2 &amp;&amp; yLeftUp &#x3D;&#x3D; yRightDown + 2 ) rect[x - 1][y - 1] &#x3D; counter;\n    for(int i &#x3D; 0; i &lt; rect.size(); i++)&#123;\n        for(int j &#x3D; 0; j &lt; rect[i].size(); j++)\n            printf(&quot;%d &quot;, rect[i][j]);\n        printf(&quot;\\n&quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;\n\nint main()&#123;\n    &#x2F;&#x2F;freopen(&quot;data.in&quot;, &quot;r&quot;, stdin);\n   printNumberRect(0, 0);\n   printNumberRect(2, 3);\n   printNumberRect(6, 3);\n   printNumberRect(3, 3);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>就直接填写。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void printNumberRect(int n, int m)&#123;\n\tvector&lt;vector&lt;int&gt; &gt; rect;\n    rect.resize(n);\n    for(int i &#x3D; 0; i &lt; rect.size(); i++) rect[i].resize(m);\n    \n    int x &#x3D; 0, y &#x3D; 0, xLeftUp &#x3D; 0, yLeftUp &#x3D; 0, xRightDown &#x3D; n - 1, yRightDown &#x3D; m - 1;\n    int counter &#x3D; 1;\n    while(xLeftUp &lt;&#x3D; xRightDown &amp;&amp; yLeftUp &lt;&#x3D; yRightDown)&#123;\n        for(; y &lt;&#x3D; yRightDown; y++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        for(x++, y--; x &lt;&#x3D; xRightDown; x++)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n       &#x2F;&#x2F;横着画可能会重叠\n        for(x--, y--; y &gt;&#x3D; yLeftUp &amp;&amp; x &gt; xLeftUp; y--)&#123;            \n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        &#x2F;&#x2F;同上\n        for(y++, x--; x &gt; xLeftUp &amp;&amp; y &lt; yRightDown; x--)&#123;\n\t\t\trect[x][y] &#x3D; counter;\n            counter++;\n        &#125;\n        x++;\n        y++;\n        xLeftUp++;\n        yLeftUp++;\n        xRightDown--;\n        yRightDown--;\n    &#125;\n\n    for(int i &#x3D; 0; i &lt; rect.size(); i++)&#123;\n        for(int j &#x3D; 0; j &lt; rect[i].size(); j++)\n            printf(&quot;%d &quot;, rect[i][j]);\n        printf(&quot;\\n&quot;);\n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题-建模","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-11T07:07:27.000Z","_content":"\n收集抽象建模题目。\n\n<!-- more -->\n\n\n\n## 面60：n个骰子的点数\n\n### 题面：\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n \n\n## 思路：\n\n第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    void calProb(vector<int>&prob, int originN, int currentN, int addS){\n        if(currentN == 0){\n            prob[addS - originN]++;\n            return;\n        } \n        for(int i = 1; i <= maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    }\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        vector<int> prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb = pow(maxGV, n);\n        vector<double> res(n * maxGV - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[i] / allProb;\n        return res;\n    }\n};\n\n\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        int addLen = n * maxGV;\n        vector<int>prob[2];\n        for(int i = 0; i < 2; i++){\n            prob[i].resize(addLen);\n            for(int j = 0; j < addLen; j++)\n                prob[i][j] = 0;            \n        }\n\n        int calIdx = 0;\n        for(int i = 0; i < maxGV; i++)\n            prob[1 - calIdx][i] = 1;\n        \n        for(int i = 0; i < n - 1; i++){\n            for(int k = 0; k < addLen; k++){\n                prob[calIdx][k] = 0;\n                for(int j = max(0, k - maxGV); j < k; j++){\n                    prob[calIdx][k] += prob[1 - calIdx][j];\n                }\n            }\n                       \n            calIdx = 1 - calIdx;\n        }\n        double allProb = pow(maxGV, n);\n        vector<double> res(addLen - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[1 - calIdx][i + n -1 ] / allProb;\n        return res;\n    }\n};\n```\n\n## 面61：约瑟夫环\n\n这题老朋友了。\n\n### 题面：\n\n0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof)\n\n## 思路：\n\n数学+ 迭代。\n\n求出`n`个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。\n\n将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)\\%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。\n\n![fig1](http://static.come2rss.xyz/jianzhi_62_fig1.gif)\n\n而且有$f(0,m) = 0$，可以快速用迭代计算出来。\n\n\n\n### 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int lastRemaining(int n, int m) {\n        int res = 0;\n        for(int i = 1;i <= n; i++){\n            res = (res + m) % i;\n        }\n        return res;\n    }\n};\n```\n\n","source":"_posts/刷题/模拟\n/面试题-建模.md","raw":"---\ntitle: 面试题-建模\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-11 15:07:27\ntags:\n---\n\n收集抽象建模题目。\n\n<!-- more -->\n\n\n\n## 面60：n个骰子的点数\n\n### 题面：\n\n把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n\n \n\n## 思路：\n\n第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    void calProb(vector<int>&prob, int originN, int currentN, int addS){\n        if(currentN == 0){\n            prob[addS - originN]++;\n            return;\n        } \n        for(int i = 1; i <= maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    }\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        vector<int> prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb = pow(maxGV, n);\n        vector<double> res(n * maxGV - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[i] / allProb;\n        return res;\n    }\n};\n\n\nclass Solution {\npublic:\n    int maxGV = 6;\n\n    vector<double> twoSum(int n) {\n        // if(n < 1) return vector<int>();        \n        int addLen = n * maxGV;\n        vector<int>prob[2];\n        for(int i = 0; i < 2; i++){\n            prob[i].resize(addLen);\n            for(int j = 0; j < addLen; j++)\n                prob[i][j] = 0;            \n        }\n\n        int calIdx = 0;\n        for(int i = 0; i < maxGV; i++)\n            prob[1 - calIdx][i] = 1;\n        \n        for(int i = 0; i < n - 1; i++){\n            for(int k = 0; k < addLen; k++){\n                prob[calIdx][k] = 0;\n                for(int j = max(0, k - maxGV); j < k; j++){\n                    prob[calIdx][k] += prob[1 - calIdx][j];\n                }\n            }\n                       \n            calIdx = 1 - calIdx;\n        }\n        double allProb = pow(maxGV, n);\n        vector<double> res(addLen - n + 1);\n        for(int i = 0; i < res.size(); i++)\n            res[i] = prob[1 - calIdx][i + n -1 ] / allProb;\n        return res;\n    }\n};\n```\n\n## 面61：约瑟夫环\n\n这题老朋友了。\n\n### 题面：\n\n0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。\n\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n\n来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof)\n\n## 思路：\n\n数学+ 迭代。\n\n求出`n`个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。\n\n将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)\\%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。\n\n![fig1](http://static.come2rss.xyz/jianzhi_62_fig1.gif)\n\n而且有$f(0,m) = 0$，可以快速用迭代计算出来。\n\n\n\n### 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int lastRemaining(int n, int m) {\n        int res = 0;\n        for(int i = 1;i <= n; i++){\n            res = (res + m) % i;\n        }\n        return res;\n    }\n};\n```\n\n","slug":"刷题-模拟-面试题-建模","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5s003ll5uo6364e47c","content":"<p>收集抽象建模题目。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"面60：n个骰子的点数\"><a href=\"#面60：n个骰子的点数\" class=\"headerlink\" title=\"面60：n个骰子的点数\"></a>面60：n个骰子的点数</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>\n<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS)&#123;\n        if(currentN &#x3D;&#x3D; 0)&#123;\n            prob[addS - originN]++;\n            return;\n        &#125; \n        for(int i &#x3D; 1; i &lt;&#x3D; maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    &#125;\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        vector&lt;int&gt; prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(n * maxGV - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[i] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        int addLen &#x3D; n * maxGV;\n        vector&lt;int&gt;prob[2];\n        for(int i &#x3D; 0; i &lt; 2; i++)&#123;\n            prob[i].resize(addLen);\n            for(int j &#x3D; 0; j &lt; addLen; j++)\n                prob[i][j] &#x3D; 0;            \n        &#125;\n\n        int calIdx &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; maxGV; i++)\n            prob[1 - calIdx][i] &#x3D; 1;\n        \n        for(int i &#x3D; 0; i &lt; n - 1; i++)&#123;\n            for(int k &#x3D; 0; k &lt; addLen; k++)&#123;\n                prob[calIdx][k] &#x3D; 0;\n                for(int j &#x3D; max(0, k - maxGV); j &lt; k; j++)&#123;\n                    prob[calIdx][k] +&#x3D; prob[1 - calIdx][j];\n                &#125;\n            &#125;\n                       \n            calIdx &#x3D; 1 - calIdx;\n        &#125;\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(addLen - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[1 - calIdx][i + n -1 ] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面61：约瑟夫环\"><a href=\"#面61：约瑟夫环\" class=\"headerlink\" title=\"面61：约瑟夫环\"></a>面61：约瑟夫环</h2><p>这题老朋友了。</p>\n<h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>\n<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>\n<p>来源：<a href=\"https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof\">力扣（LeetCode）</a></p>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>数学+ 迭代。</p>\n<p>求出<code>n</code>个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。</p>\n<p>将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。</p>\n<p><img src=\"http://static.come2rss.xyz/jianzhi_62_fig1.gif\" alt=\"fig1\"></p>\n<p>而且有$f(0,m) = 0$，可以快速用迭代计算出来。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int lastRemaining(int n, int m) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n            res &#x3D; (res + m) % i;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"RWTQJ2","excerpt":"<p>收集抽象建模题目。</p>","more":"<h2 id=\"面60：n个骰子的点数\"><a href=\"#面60：n个骰子的点数\" class=\"headerlink\" title=\"面60：n个骰子的点数\"></a>面60：n个骰子的点数</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>\n<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>第一种可以用递归DFS的思路去求和N个骰子的点数之和。第二种可以用循环依次计算前K个骰子点数的可能出现次数。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS)&#123;\n        if(currentN &#x3D;&#x3D; 0)&#123;\n            prob[addS - originN]++;\n            return;\n        &#125; \n        for(int i &#x3D; 1; i &lt;&#x3D; maxGV; i++)\n            calProb(prob, originN, currentN - 1, addS + i);\n    &#125;\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        vector&lt;int&gt; prob(n * maxGV - n + 1, 0);\n        calProb(prob, n, n, 0);\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(n * maxGV - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[i] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;\n\n\nclass Solution &#123;\npublic:\n    int maxGV &#x3D; 6;\n\n    vector&lt;double&gt; twoSum(int n) &#123;\n        &#x2F;&#x2F; if(n &lt; 1) return vector&lt;int&gt;();        \n        int addLen &#x3D; n * maxGV;\n        vector&lt;int&gt;prob[2];\n        for(int i &#x3D; 0; i &lt; 2; i++)&#123;\n            prob[i].resize(addLen);\n            for(int j &#x3D; 0; j &lt; addLen; j++)\n                prob[i][j] &#x3D; 0;            \n        &#125;\n\n        int calIdx &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; maxGV; i++)\n            prob[1 - calIdx][i] &#x3D; 1;\n        \n        for(int i &#x3D; 0; i &lt; n - 1; i++)&#123;\n            for(int k &#x3D; 0; k &lt; addLen; k++)&#123;\n                prob[calIdx][k] &#x3D; 0;\n                for(int j &#x3D; max(0, k - maxGV); j &lt; k; j++)&#123;\n                    prob[calIdx][k] +&#x3D; prob[1 - calIdx][j];\n                &#125;\n            &#125;\n                       \n            calIdx &#x3D; 1 - calIdx;\n        &#125;\n        double allProb &#x3D; pow(maxGV, n);\n        vector&lt;double&gt; res(addLen - n + 1);\n        for(int i &#x3D; 0; i &lt; res.size(); i++)\n            res[i] &#x3D; prob[1 - calIdx][i + n -1 ] &#x2F; allProb;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面61：约瑟夫环\"><a href=\"#面61：约瑟夫环\" class=\"headerlink\" title=\"面61：约瑟夫环\"></a>面61：约瑟夫环</h2><p>这题老朋友了。</p>\n<h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>\n<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>\n<p>来源：<a href=\"https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof\">力扣（LeetCode）</a></p>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>数学+ 迭代。</p>\n<p>求出<code>n</code>个元素的最后留下的数字，可以看到这个题目仍有递归拆分成小问题的潜质。</p>\n<p>将原问题建模为$f(n,m)$ 。那么有$f(n-1,m)$代表了长度为$n-1$的最后留下的数字编号。重点来了，那么就有$f(n,m)=(f(n-1,m) + m)%n$，也就是说长度为$n$的留下的数字编号是数过$m$个数字后的长度为$n-1$的数组留下来的数字下标。</p>\n<p><img src=\"http://static.come2rss.xyz/jianzhi_62_fig1.gif\" alt=\"fig1\"></p>\n<p>而且有$f(0,m) = 0$，可以快速用迭代计算出来。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int lastRemaining(int n, int m) &#123;\n        int res &#x3D; 0;\n        for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n            res &#x3D; (res + m) % i;\n        &#125;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"435. Non-overlapping Intervals","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-12T01:19:14.000Z","_content":"\n还是蛮经典的题，想了想就出来了。\n\n<!-- more -->\n\n## 思路：\n\n求出最少舍弃的区间，换一个角度就是留下更多的区间。为了留下的区间最多，直观上来看最好是区间长度小，起点和终点都小的区间。\n\n通过仔细的思考，只有终点最小才能满足区间尽可能留下的条件。\n\n\n\n## 代码：\n\n```c++\n\n\nbool cmp(vector<int>& a, vector<int>& b){\n    if(a[1] == b[1])\n        return a[0] < b[0];\n    else return a[1] < b[1];\n\n}\nclass Solution {\npublic:\n\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        // bool (Solution::*cmpabc)(vertor<int>, vertor<int>);\n        // cmpabc = &Solution::cmpab;\n        int n = intervals.size();\n        // for(int i = 0; i < n; i++)\n        //     intervals[i].push_back(intervals[i][1] - intervals[i][0]);\n\n        sort(intervals.begin(), intervals.end(), cmp);\n\n        int add = 0, start = -0x7fffffff;\n        for(int i = 0; i < n; ++i){\n            if(start <= intervals[i][0]){\n                add++;\n                start = intervals[i][1];\n            }\n        }\n        return n - add;\n    }\n};\n```\n\n> `sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){return a[1] < b[1];});`最后的`sort`可以用匿名函数写写。\n","source":"_posts/刷题/贪心\n/435-Non-overlapping-Intervals.md","raw":"---\ntitle: 435. Non-overlapping Intervals\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-12 09:19:14\n---\n\n还是蛮经典的题，想了想就出来了。\n\n<!-- more -->\n\n## 思路：\n\n求出最少舍弃的区间，换一个角度就是留下更多的区间。为了留下的区间最多，直观上来看最好是区间长度小，起点和终点都小的区间。\n\n通过仔细的思考，只有终点最小才能满足区间尽可能留下的条件。\n\n\n\n## 代码：\n\n```c++\n\n\nbool cmp(vector<int>& a, vector<int>& b){\n    if(a[1] == b[1])\n        return a[0] < b[0];\n    else return a[1] < b[1];\n\n}\nclass Solution {\npublic:\n\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        // bool (Solution::*cmpabc)(vertor<int>, vertor<int>);\n        // cmpabc = &Solution::cmpab;\n        int n = intervals.size();\n        // for(int i = 0; i < n; i++)\n        //     intervals[i].push_back(intervals[i][1] - intervals[i][0]);\n\n        sort(intervals.begin(), intervals.end(), cmp);\n\n        int add = 0, start = -0x7fffffff;\n        for(int i = 0; i < n; ++i){\n            if(start <= intervals[i][0]){\n                add++;\n                start = intervals[i][1];\n            }\n        }\n        return n - add;\n    }\n};\n```\n\n> `sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b){return a[1] < b[1];});`最后的`sort`可以用匿名函数写写。\n","slug":"刷题-贪心-435-Non-overlapping-Intervals","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5t003ml5uo5k8cffyq","content":"<p>还是蛮经典的题，想了想就出来了。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>求出最少舍弃的区间，换一个角度就是留下更多的区间。为了留下的区间最多，直观上来看最好是区间长度小，起点和终点都小的区间。</p>\n<p>通过仔细的思考，只有终点最小才能满足区间尽可能留下的条件。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n\nbool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;\n    if(a[1] &#x3D;&#x3D; b[1])\n        return a[0] &lt; b[0];\n    else return a[1] &lt; b[1];\n\n&#125;\nclass Solution &#123;\npublic:\n\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        &#x2F;&#x2F; bool (Solution::*cmpabc)(vertor&lt;int&gt;, vertor&lt;int&gt;);\n        &#x2F;&#x2F; cmpabc &#x3D; &amp;Solution::cmpab;\n        int n &#x3D; intervals.size();\n        &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n; i++)\n        &#x2F;&#x2F;     intervals[i].push_back(intervals[i][1] - intervals[i][0]);\n\n        sort(intervals.begin(), intervals.end(), cmp);\n\n        int add &#x3D; 0, start &#x3D; -0x7fffffff;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(start &lt;&#x3D; intervals[i][0])&#123;\n                add++;\n                start &#x3D; intervals[i][1];\n            &#125;\n        &#125;\n        return n - add;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p><code>sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;return a[1] &lt; b[1];&#125;);</code>最后的<code>sort</code>可以用匿名函数写写。</p>\n</blockquote>\n","site":{"data":{}},"abbrlink":"3477ZQT","excerpt":"<p>还是蛮经典的题，想了想就出来了。</p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>求出最少舍弃的区间，换一个角度就是留下更多的区间。为了留下的区间最多，直观上来看最好是区间长度小，起点和终点都小的区间。</p>\n<p>通过仔细的思考，只有终点最小才能满足区间尽可能留下的条件。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n\nbool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;\n    if(a[1] &#x3D;&#x3D; b[1])\n        return a[0] &lt; b[0];\n    else return a[1] &lt; b[1];\n\n&#125;\nclass Solution &#123;\npublic:\n\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        &#x2F;&#x2F; bool (Solution::*cmpabc)(vertor&lt;int&gt;, vertor&lt;int&gt;);\n        &#x2F;&#x2F; cmpabc &#x3D; &amp;Solution::cmpab;\n        int n &#x3D; intervals.size();\n        &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; n; i++)\n        &#x2F;&#x2F;     intervals[i].push_back(intervals[i][1] - intervals[i][0]);\n\n        sort(intervals.begin(), intervals.end(), cmp);\n\n        int add &#x3D; 0, start &#x3D; -0x7fffffff;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(start &lt;&#x3D; intervals[i][0])&#123;\n                add++;\n                start &#x3D; intervals[i][1];\n            &#125;\n        &#125;\n        return n - add;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p><code>sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;return a[1] &lt; b[1];&#125;);</code>最后的<code>sort</code>可以用匿名函数写写。</p>\n</blockquote>"},{"title":"452. Minimum Number of Arrows to Burst Balloons","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-13T00:26:09.000Z","_content":"\n#### [452. Minimum Number of Arrows to Burst Balloons](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)\n\n类似于leetcode435贪心题\n\n<!-- more -->\n\n\n\n\n\n## 思路：\n\n用贪心的策略尽可能的射击气球末尾，可以用末尾排序，遍历增加箭数即可。\n\n## 代码：\n\n> 按气球开始排序，与原本思路上的思路等价\n\n```c++\nclass Solution {\npublic:\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(), points.end(), [](vector<int> a, vector<int> b)\n            {   \n                if(a[0] == b[0]) return a[1] < b[1];\n                else return a[0] < b[0];}\n            );\n        \n\n        int num = 0;\n        int end = -1;\n        for(int i = 0; i < points.size();){\n            num++;\n            end = points[i][1];\n            i++;\n            while(i < points.size() && end >= points[i][0]){             \n                end = min(end, points[i][1]);\n                i++;\n           \n            } \n\n        }\n        return num;\n    }\n};\n```\n\n\n\n","source":"_posts/刷题/贪心\n/452-Minimum-Number-of-Arrows-to-Burst-Balloons.md","raw":"---\ntitle: 452. Minimum Number of Arrows to Burst Balloons\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-13 08:26:09\n---\n\n#### [452. Minimum Number of Arrows to Burst Balloons](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)\n\n类似于leetcode435贪心题\n\n<!-- more -->\n\n\n\n\n\n## 思路：\n\n用贪心的策略尽可能的射击气球末尾，可以用末尾排序，遍历增加箭数即可。\n\n## 代码：\n\n> 按气球开始排序，与原本思路上的思路等价\n\n```c++\nclass Solution {\npublic:\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(), points.end(), [](vector<int> a, vector<int> b)\n            {   \n                if(a[0] == b[0]) return a[1] < b[1];\n                else return a[0] < b[0];}\n            );\n        \n\n        int num = 0;\n        int end = -1;\n        for(int i = 0; i < points.size();){\n            num++;\n            end = points[i][1];\n            i++;\n            while(i < points.size() && end >= points[i][0]){             \n                end = min(end, points[i][1]);\n                i++;\n           \n            } \n\n        }\n        return num;\n    }\n};\n```\n\n\n\n","slug":"刷题-贪心-452-Minimum-Number-of-Arrows-to-Burst-Balloons","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5t003nl5uoch911pm8","content":"<h4 id=\"452-Minimum-Number-of-Arrows-to-Burst-Balloons\"><a href=\"#452-Minimum-Number-of-Arrows-to-Burst-Balloons\" class=\"headerlink\" title=\"452. Minimum Number of Arrows to Burst Balloons\"></a><a href=\"https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\">452. Minimum Number of Arrows to Burst Balloons</a></h4><p>类似于leetcode435贪心题</p>\n<span id=\"more\"></span>\n\n\n\n\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用贪心的策略尽可能的射击气球末尾，可以用末尾排序，遍历增加箭数即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><blockquote>\n<p>按气球开始排序，与原本思路上的思路等价</p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        sort(points.begin(), points.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b)\n            &#123;   \n                if(a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];\n                else return a[0] &lt; b[0];&#125;\n            );\n        \n\n        int num &#x3D; 0;\n        int end &#x3D; -1;\n        for(int i &#x3D; 0; i &lt; points.size();)&#123;\n            num++;\n            end &#x3D; points[i][1];\n            i++;\n            while(i &lt; points.size() &amp;&amp; end &gt;&#x3D; points[i][0])&#123;             \n                end &#x3D; min(end, points[i][1]);\n                i++;\n           \n            &#125; \n\n        &#125;\n        return num;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","site":{"data":{}},"abbrlink":"1CM5F06","excerpt":"<h4 id=\"452-Minimum-Number-of-Arrows-to-Burst-Balloons\"><a href=\"#452-Minimum-Number-of-Arrows-to-Burst-Balloons\" class=\"headerlink\" title=\"452. Minimum Number of Arrows to Burst Balloons\"></a><a href=\"https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\">452. Minimum Number of Arrows to Burst Balloons</a></h4><p>类似于leetcode435贪心题</p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用贪心的策略尽可能的射击气球末尾，可以用末尾排序，遍历增加箭数即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><blockquote>\n<p>按气球开始排序，与原本思路上的思路等价</p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        sort(points.begin(), points.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b)\n            &#123;   \n                if(a[0] &#x3D;&#x3D; b[0]) return a[1] &lt; b[1];\n                else return a[0] &lt; b[0];&#125;\n            );\n        \n\n        int num &#x3D; 0;\n        int end &#x3D; -1;\n        for(int i &#x3D; 0; i &lt; points.size();)&#123;\n            num++;\n            end &#x3D; points[i][1];\n            i++;\n            while(i &lt; points.size() &amp;&amp; end &gt;&#x3D; points[i][0])&#123;             \n                end &#x3D; min(end, points[i][1]);\n                i++;\n           \n            &#125; \n\n        &#125;\n        return num;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"455. Assign Cookies","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-09T00:14:33.000Z","_content":"\n<!-- more -->\n\n#### [455. Assign Cookies](https://leetcode-cn.com/problems/assign-cookies/)\n\n贪心 + 二分\n\n<!--more-->\n\n## 思路：\n\n贪心\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n            sort(g.begin(), g.end(), less<int>());\n            sort(s.begin(), s.end(), less<int>());\n            vector<bool> vis(s.size(), 0);\n            int ans = 0;\n            for(int i = 0; i < g.size(); ++i){\n                int l = 0, r = s.size(), mid;\n                while(l < r){\n                    mid = (l + r) / 2;\n                    if(s[mid] >= g[i]) r = mid;\n                    else l = mid + 1;\n                    \n                }\n                mid = r;\n                while(mid < s.size() && vis[mid]) ++mid;\n                if(mid < s.size()){\n                    vis[mid] = 1;\n                    ++ans;\n\n                }\n                \n            }        \n            return ans;\n    }\n};\n```\n\n错误之处：\n\n+ sort的默认按升序拍戏，使用`greater`按降序排序\n+ 二分后mid为暂存值，lr才是最后目的地。","source":"_posts/刷题/贪心\n/455-Assign-Cookies.md","raw":"---\ntitle: 455. Assign Cookies\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-09 08:14:33\n---\n\n<!-- more -->\n\n#### [455. Assign Cookies](https://leetcode-cn.com/problems/assign-cookies/)\n\n贪心 + 二分\n\n<!--more-->\n\n## 思路：\n\n贪心\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n            sort(g.begin(), g.end(), less<int>());\n            sort(s.begin(), s.end(), less<int>());\n            vector<bool> vis(s.size(), 0);\n            int ans = 0;\n            for(int i = 0; i < g.size(); ++i){\n                int l = 0, r = s.size(), mid;\n                while(l < r){\n                    mid = (l + r) / 2;\n                    if(s[mid] >= g[i]) r = mid;\n                    else l = mid + 1;\n                    \n                }\n                mid = r;\n                while(mid < s.size() && vis[mid]) ++mid;\n                if(mid < s.size()){\n                    vis[mid] = 1;\n                    ++ans;\n\n                }\n                \n            }        \n            return ans;\n    }\n};\n```\n\n错误之处：\n\n+ sort的默认按升序拍戏，使用`greater`按降序排序\n+ 二分后mid为暂存值，lr才是最后目的地。","slug":"刷题-贪心-455-Assign-Cookies","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5v003ol5uoc2h35jei","content":"<span id=\"more\"></span>\n\n<h4 id=\"455-Assign-Cookies\"><a href=\"#455-Assign-Cookies\" class=\"headerlink\" title=\"455. Assign Cookies\"></a><a href=\"https://leetcode-cn.com/problems/assign-cookies/\">455. Assign Cookies</a></h4><p>贪心 + 二分</p>\n<!--more-->\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>贪心</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;\n            sort(g.begin(), g.end(), less&lt;int&gt;());\n            sort(s.begin(), s.end(), less&lt;int&gt;());\n            vector&lt;bool&gt; vis(s.size(), 0);\n            int ans &#x3D; 0;\n            for(int i &#x3D; 0; i &lt; g.size(); ++i)&#123;\n                int l &#x3D; 0, r &#x3D; s.size(), mid;\n                while(l &lt; r)&#123;\n                    mid &#x3D; (l + r) &#x2F; 2;\n                    if(s[mid] &gt;&#x3D; g[i]) r &#x3D; mid;\n                    else l &#x3D; mid + 1;\n                    \n                &#125;\n                mid &#x3D; r;\n                while(mid &lt; s.size() &amp;&amp; vis[mid]) ++mid;\n                if(mid &lt; s.size())&#123;\n                    vis[mid] &#x3D; 1;\n                    ++ans;\n\n                &#125;\n                \n            &#125;        \n            return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>错误之处：</p>\n<ul>\n<li>sort的默认按升序拍戏，使用<code>greater</code>按降序排序</li>\n<li>二分后mid为暂存值，lr才是最后目的地。</li>\n</ul>\n","site":{"data":{}},"abbrlink":"3SK0BSW","excerpt":"","more":"<h4 id=\"455-Assign-Cookies\"><a href=\"#455-Assign-Cookies\" class=\"headerlink\" title=\"455. Assign Cookies\"></a><a href=\"https://leetcode-cn.com/problems/assign-cookies/\">455. Assign Cookies</a></h4><p>贪心 + 二分</p>\n<!--more-->\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>贪心</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123;\n            sort(g.begin(), g.end(), less&lt;int&gt;());\n            sort(s.begin(), s.end(), less&lt;int&gt;());\n            vector&lt;bool&gt; vis(s.size(), 0);\n            int ans &#x3D; 0;\n            for(int i &#x3D; 0; i &lt; g.size(); ++i)&#123;\n                int l &#x3D; 0, r &#x3D; s.size(), mid;\n                while(l &lt; r)&#123;\n                    mid &#x3D; (l + r) &#x2F; 2;\n                    if(s[mid] &gt;&#x3D; g[i]) r &#x3D; mid;\n                    else l &#x3D; mid + 1;\n                    \n                &#125;\n                mid &#x3D; r;\n                while(mid &lt; s.size() &amp;&amp; vis[mid]) ++mid;\n                if(mid &lt; s.size())&#123;\n                    vis[mid] &#x3D; 1;\n                    ++ans;\n\n                &#125;\n                \n            &#125;        \n            return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>错误之处：</p>\n<ul>\n<li>sort的默认按升序拍戏，使用<code>greater</code>按降序排序</li>\n<li>二分后mid为暂存值，lr才是最后目的地。</li>\n</ul>"},{"title":"5674. Largest Merge Of Two Strings","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-07T05:46:28.000Z","_content":"\n\n\n\n\n周赛的题目3\n\n## 算法：\n\n明显是贪心，但我贪错了！\n\n一开始想着比较两个字符创的开头字符，选择字典序大的字符加入。如果两个字符相等就放着比较下一个，直到有不同的就可以全部加入。然后wa了4发。\n\n正确的思路是：比较剩下的字符串，选择字典序大的字符创的的首个字符加入即可。\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    string largestMerge(string word1, string word2) {\n        int i, j;\n        i = j = 0;\n        string res;\n        int n = word1.size(), m = word2.size();\n        while(i < n && j < m){\n            // 贪心算法：\n            // 直接比较 剩下子串， 选择字典的序大的子串的第一个字母加入\n            if(word1.substr(i) > word2.substr(j)) res += word1[i++];\n            else res += word2[j++];\n\n        }\n        if(i < n) res += word1.substr(i);\n        if(j < m) res += word2.substr(j);           \n        return res;\n    }\n};\n```\n\n","source":"_posts/刷题/贪心\n/5674-Largest-Merge-Of-Two-Strings.md","raw":"---\ntitle: 5674. Largest Merge Of Two Strings\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-07 13:46:28\ntags:\ncategories:\n---\n\n\n\n\n\n周赛的题目3\n\n## 算法：\n\n明显是贪心，但我贪错了！\n\n一开始想着比较两个字符创的开头字符，选择字典序大的字符加入。如果两个字符相等就放着比较下一个，直到有不同的就可以全部加入。然后wa了4发。\n\n正确的思路是：比较剩下的字符串，选择字典序大的字符创的的首个字符加入即可。\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    string largestMerge(string word1, string word2) {\n        int i, j;\n        i = j = 0;\n        string res;\n        int n = word1.size(), m = word2.size();\n        while(i < n && j < m){\n            // 贪心算法：\n            // 直接比较 剩下子串， 选择字典的序大的子串的第一个字母加入\n            if(word1.substr(i) > word2.substr(j)) res += word1[i++];\n            else res += word2[j++];\n\n        }\n        if(i < n) res += word1.substr(i);\n        if(j < m) res += word2.substr(j);           \n        return res;\n    }\n};\n```\n\n","slug":"刷题-贪心-5674-Largest-Merge-Of-Two-Strings","published":1,"updated":"2021-02-07T05:54:55.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5v003pl5uogkoldkz4","content":"<p>周赛的题目3</p>\n<h2 id=\"算法：\"><a href=\"#算法：\" class=\"headerlink\" title=\"算法：\"></a>算法：</h2><p>明显是贪心，但我贪错了！</p>\n<p>一开始想着比较两个字符创的开头字符，选择字典序大的字符加入。如果两个字符相等就放着比较下一个，直到有不同的就可以全部加入。然后wa了4发。</p>\n<p>正确的思路是：比较剩下的字符串，选择字典序大的字符创的的首个字符加入即可。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string largestMerge(string word1, string word2) &#123;\n        int i, j;\n        i &#x3D; j &#x3D; 0;\n        string res;\n        int n &#x3D; word1.size(), m &#x3D; word2.size();\n        while(i &lt; n &amp;&amp; j &lt; m)&#123;\n            &#x2F;&#x2F; 贪心算法：\n            &#x2F;&#x2F; 直接比较 剩下子串， 选择字典的序大的子串的第一个字母加入\n            if(word1.substr(i) &gt; word2.substr(j)) res +&#x3D; word1[i++];\n            else res +&#x3D; word2[j++];\n\n        &#125;\n        if(i &lt; n) res +&#x3D; word1.substr(i);\n        if(j &lt; m) res +&#x3D; word2.substr(j);           \n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1RW3Q8K","excerpt":"<p>周赛的题目3</p>\n<h2 id=\"算法：\"><a href=\"#算法：\" class=\"headerlink\" title=\"算法：\"></a>算法：</h2><p>明显是贪心，但我贪错了！</p>\n<p>一开始想着比较两个字符创的开头字符，选择字典序大的字符加入。如果两个字符相等就放着比较下一个，直到有不同的就可以全部加入。然后wa了4发。</p>\n<p>正确的思路是：比较剩下的字符串，选择字典序大的字符创的的首个字符加入即可。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string largestMerge(string word1, string word2) &#123;\n        int i, j;\n        i &#x3D; j &#x3D; 0;\n        string res;\n        int n &#x3D; word1.size(), m &#x3D; word2.size();\n        while(i &lt; n &amp;&amp; j &lt; m)&#123;\n            &#x2F;&#x2F; 贪心算法：\n            &#x2F;&#x2F; 直接比较 剩下子串， 选择字典的序大的子串的第一个字母加入\n            if(word1.substr(i) &gt; word2.substr(j)) res +&#x3D; word1[i++];\n            else res +&#x3D; word2[j++];\n\n        &#125;\n        if(i &lt; n) res +&#x3D; word1.substr(i);\n        if(j &lt; m) res +&#x3D; word2.substr(j);           \n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"665. Non-decreasing Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-16T05:47:28.000Z","_content":"\n<!-- more -->\n\n\n\n#### [665. Non-decreasing Array](https://leetcode-cn.com/problems/non-decreasing-array/)\n\n\n\n## 思路：\n\n对于任意一个$A[i]>A[i+1]$，$A[i]$和$A[i+1]$分别代表两个non-decreasing array，而合并两个的方法只有：`A[i] = A[i - 1]`和`A[i +1 ] = A[i + 2]`。\n\n接下来只需要讨论边界条件和合并次数即可。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    bool checkPossibility(vector<int>& nums) {\n        int ansnum = 0;\n        int n = nums.size();\n        for(int i = 0; i < n - 1; ++i){\n            if(nums[i] > nums[i + 1]){\n                if(i ==0 || nums[i - 1] <= nums[i + 1] || i == n - 2 || nums[i] <= nums[i + 2]){\n                    ansnum++;\n                    if(ansnum > 1) return false;\n                }   \n                else return false;\n                    \n            }\n        }\n        return true;;;;;;;;;;\n    }\n};\n```\n\n","source":"_posts/刷题/贪心\n/665-Non-decreasing-Array.md","raw":"---\ntitle: 665. Non-decreasing Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-16 13:47:28\n---\n\n<!-- more -->\n\n\n\n#### [665. Non-decreasing Array](https://leetcode-cn.com/problems/non-decreasing-array/)\n\n\n\n## 思路：\n\n对于任意一个$A[i]>A[i+1]$，$A[i]$和$A[i+1]$分别代表两个non-decreasing array，而合并两个的方法只有：`A[i] = A[i - 1]`和`A[i +1 ] = A[i + 2]`。\n\n接下来只需要讨论边界条件和合并次数即可。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    bool checkPossibility(vector<int>& nums) {\n        int ansnum = 0;\n        int n = nums.size();\n        for(int i = 0; i < n - 1; ++i){\n            if(nums[i] > nums[i + 1]){\n                if(i ==0 || nums[i - 1] <= nums[i + 1] || i == n - 2 || nums[i] <= nums[i + 2]){\n                    ansnum++;\n                    if(ansnum > 1) return false;\n                }   \n                else return false;\n                    \n            }\n        }\n        return true;;;;;;;;;;\n    }\n};\n```\n\n","slug":"刷题-贪心-665-Non-decreasing-Array","published":1,"updated":"2021-01-28T14:04:37.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5w003ql5uo70nh5gnt","content":"<span id=\"more\"></span>\n\n\n\n<h4 id=\"665-Non-decreasing-Array\"><a href=\"#665-Non-decreasing-Array\" class=\"headerlink\" title=\"665. Non-decreasing Array\"></a><a href=\"https://leetcode-cn.com/problems/non-decreasing-array/\">665. Non-decreasing Array</a></h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>对于任意一个$A[i]&gt;A[i+1]$，$A[i]$和$A[i+1]$分别代表两个non-decreasing array，而合并两个的方法只有：<code>A[i] = A[i - 1]</code>和<code>A[i +1 ] = A[i + 2]</code>。</p>\n<p>接下来只需要讨论边界条件和合并次数即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;\n        int ansnum &#x3D; 0;\n        int n &#x3D; nums.size();\n        for(int i &#x3D; 0; i &lt; n - 1; ++i)&#123;\n            if(nums[i] &gt; nums[i + 1])&#123;\n                if(i &#x3D;&#x3D;0 || nums[i - 1] &lt;&#x3D; nums[i + 1] || i &#x3D;&#x3D; n - 2 || nums[i] &lt;&#x3D; nums[i + 2])&#123;\n                    ansnum++;\n                    if(ansnum &gt; 1) return false;\n                &#125;   \n                else return false;\n                    \n            &#125;\n        &#125;\n        return true;;;;;;;;;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"20Y73WX","excerpt":"","more":"<h4 id=\"665-Non-decreasing-Array\"><a href=\"#665-Non-decreasing-Array\" class=\"headerlink\" title=\"665. Non-decreasing Array\"></a><a href=\"https://leetcode-cn.com/problems/non-decreasing-array/\">665. Non-decreasing Array</a></h4><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>对于任意一个$A[i]&gt;A[i+1]$，$A[i]$和$A[i+1]$分别代表两个non-decreasing array，而合并两个的方法只有：<code>A[i] = A[i - 1]</code>和<code>A[i +1 ] = A[i + 2]</code>。</p>\n<p>接下来只需要讨论边界条件和合并次数即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;\n        int ansnum &#x3D; 0;\n        int n &#x3D; nums.size();\n        for(int i &#x3D; 0; i &lt; n - 1; ++i)&#123;\n            if(nums[i] &gt; nums[i + 1])&#123;\n                if(i &#x3D;&#x3D;0 || nums[i - 1] &lt;&#x3D; nums[i + 1] || i &#x3D;&#x3D; n - 2 || nums[i] &lt;&#x3D; nums[i + 2])&#123;\n                    ansnum++;\n                    if(ansnum &gt; 1) return false;\n                &#125;   \n                else return false;\n                    \n            &#125;\n        &#125;\n        return true;;;;;;;;;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"763. Partition Labels","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-14T00:26:06.000Z","_content":"\n<!-- more -->\n\n## 思路：\n\n题目不错，贪心到最晚出现的字符就行了。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> partitionLabels(string S) {\n        int vis[26] = {0}, num[26] = {0};\n        vector<int> par;\n        int k = 0, n = S.size(), last = -1;\n        \n        for(int i = 0; i < n; ++i)\n            num[S[i] - 'a']++;\n\n        while(k < n){\n            memset(vis, 0, sizeof(vis));\n            for(k; k < n; ++k){                \n                int idx = S[k] - 'a';\n                vis[idx]++;\n                int flag = 0;\n                if(vis[idx] == num[idx] ){\n                    for(int j = 0; j < 26; ++j){                        \n                        if(vis[j] && vis[j] != num[j]){\n                            flag = 1;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        break;\n                    }\n                }\n            }\n            par.push_back(k - last);\n            last = k;\n            k++;\n        }\n        return par;\n    }\n};\n```\n\n\n\n\n\npy版：实现更优雅\n\n```python\n\nclass Solution(object):\n    def partitionLabels(self, S):\n        last = {c: i for i, c in enumerate(S)}\n        j = anchor = 0\n        ans = []\n        for i, c in enumerate(S):\n            j = max(j, last[c])\n            if i == j:\n                ans.append(i - anchor + 1)\n                anchor = i + 1\n            \n        return ans\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","source":"_posts/刷题/贪心\n/763-Partition-Labels.md","raw":"---\ntitle: 763. Partition Labels\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-14 08:26:06\n---\n\n<!-- more -->\n\n## 思路：\n\n题目不错，贪心到最晚出现的字符就行了。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> partitionLabels(string S) {\n        int vis[26] = {0}, num[26] = {0};\n        vector<int> par;\n        int k = 0, n = S.size(), last = -1;\n        \n        for(int i = 0; i < n; ++i)\n            num[S[i] - 'a']++;\n\n        while(k < n){\n            memset(vis, 0, sizeof(vis));\n            for(k; k < n; ++k){                \n                int idx = S[k] - 'a';\n                vis[idx]++;\n                int flag = 0;\n                if(vis[idx] == num[idx] ){\n                    for(int j = 0; j < 26; ++j){                        \n                        if(vis[j] && vis[j] != num[j]){\n                            flag = 1;\n                            break;\n                        }\n                    }\n                    if(!flag){\n                        break;\n                    }\n                }\n            }\n            par.push_back(k - last);\n            last = k;\n            k++;\n        }\n        return par;\n    }\n};\n```\n\n\n\n\n\npy版：实现更优雅\n\n```python\n\nclass Solution(object):\n    def partitionLabels(self, S):\n        last = {c: i for i, c in enumerate(S)}\n        j = anchor = 0\n        ans = []\n        for i, c in enumerate(S):\n            j = max(j, last[c])\n            if i == j:\n                ans.append(i - anchor + 1)\n                anchor = i + 1\n            \n        return ans\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n```\n\n","slug":"刷题-贪心-763-Partition-Labels","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5x003rl5uo5xmqcrx4","content":"<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>题目不错，贪心到最晚出现的字符就行了。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; partitionLabels(string S) &#123;\n        int vis[26] &#x3D; &#123;0&#125;, num[26] &#x3D; &#123;0&#125;;\n        vector&lt;int&gt; par;\n        int k &#x3D; 0, n &#x3D; S.size(), last &#x3D; -1;\n        \n        for(int i &#x3D; 0; i &lt; n; ++i)\n            num[S[i] - &#39;a&#39;]++;\n\n        while(k &lt; n)&#123;\n            memset(vis, 0, sizeof(vis));\n            for(k; k &lt; n; ++k)&#123;                \n                int idx &#x3D; S[k] - &#39;a&#39;;\n                vis[idx]++;\n                int flag &#x3D; 0;\n                if(vis[idx] &#x3D;&#x3D; num[idx] )&#123;\n                    for(int j &#x3D; 0; j &lt; 26; ++j)&#123;                        \n                        if(vis[j] &amp;&amp; vis[j] !&#x3D; num[j])&#123;\n                            flag &#x3D; 1;\n                            break;\n                        &#125;\n                    &#125;\n                    if(!flag)&#123;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n            par.push_back(k - last);\n            last &#x3D; k;\n            k++;\n        &#125;\n        return par;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>py版：实现更优雅</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">\nclass Solution(object):\n    def partitionLabels(self, S):\n        last &#x3D; &#123;c: i for i, c in enumerate(S)&#125;\n        j &#x3D; anchor &#x3D; 0\n        ans &#x3D; []\n        for i, c in enumerate(S):\n            j &#x3D; max(j, last[c])\n            if i &#x3D;&#x3D; j:\n                ans.append(i - anchor + 1)\n                anchor &#x3D; i + 1\n            \n        return ans\n\n作者：LeetCode\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;partition-labels&#x2F;solution&#x2F;hua-fen-zi-mu-qu-jian-by-leetcode&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1M1AKEB","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>题目不错，贪心到最晚出现的字符就行了。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; partitionLabels(string S) &#123;\n        int vis[26] &#x3D; &#123;0&#125;, num[26] &#x3D; &#123;0&#125;;\n        vector&lt;int&gt; par;\n        int k &#x3D; 0, n &#x3D; S.size(), last &#x3D; -1;\n        \n        for(int i &#x3D; 0; i &lt; n; ++i)\n            num[S[i] - &#39;a&#39;]++;\n\n        while(k &lt; n)&#123;\n            memset(vis, 0, sizeof(vis));\n            for(k; k &lt; n; ++k)&#123;                \n                int idx &#x3D; S[k] - &#39;a&#39;;\n                vis[idx]++;\n                int flag &#x3D; 0;\n                if(vis[idx] &#x3D;&#x3D; num[idx] )&#123;\n                    for(int j &#x3D; 0; j &lt; 26; ++j)&#123;                        \n                        if(vis[j] &amp;&amp; vis[j] !&#x3D; num[j])&#123;\n                            flag &#x3D; 1;\n                            break;\n                        &#125;\n                    &#125;\n                    if(!flag)&#123;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n            par.push_back(k - last);\n            last &#x3D; k;\n            k++;\n        &#125;\n        return par;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>py版：实现更优雅</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">\nclass Solution(object):\n    def partitionLabels(self, S):\n        last &#x3D; &#123;c: i for i, c in enumerate(S)&#125;\n        j &#x3D; anchor &#x3D; 0\n        ans &#x3D; []\n        for i, c in enumerate(S):\n            j &#x3D; max(j, last[c])\n            if i &#x3D;&#x3D; j:\n                ans.append(i - anchor + 1)\n                anchor &#x3D; i + 1\n            \n        return ans\n\n作者：LeetCode\n链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;partition-labels&#x2F;solution&#x2F;hua-fen-zi-mu-qu-jian-by-leetcode&#x2F;\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"870. Advantage Shuffle","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-05T12:38:14.000Z","_content":"\n\n\n\n# [870. Advantage Shuffle](https://leetcode-cn.com/problems/advantage-shuffle/)\n\n\n\n\n\n## 思路\n\n一看就是贪心\n\n从小到大逐个寻找B的牌`b`，找出一个刚刚好比`b`大的在A中的牌`a`。因为`a`刚刚比`b`大，所以最优。找出后，加入映射，最后重构数组即可。<!-- more -->\n\n## 代码\n\n下饭操作\n\n```c++\nclass Solution {\npublic:\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\n        int n = A.size();\n        vector<int> sortb(B);\n        sort(A.begin(), A.end());\n        vector<int> leftA;\n        sort(sortb.begin(), sortb.end());\n        // unordered_multimap<int, int> map;\n        multimap<int, int> map; // 可以用 unorder_map<int, deque<int>> 代替， 代码更简洁\n        int g = 0;\n        for(auto b : sortb){\n            while(g < n && A[g] <= b)\n                leftA.push_back(A[g++]);               \n            if(g < n)\n                map.insert({b, A[g++]});                \n        }\n        int k = 0;\n        for(int i = 0; i < n; ++i){\n            auto it = map.lower_bound(B[i]);\n            if(it != map.end()){\n                auto [b, a]= *it;\n                if(b == B[i]){\n                    A[i] = a;\n                    map.erase(it);\n                }\n            } \n            else A[i] = leftA[k++];\n        }\n        return A;\n    }\n};\n```\n\n\n\n","source":"_posts/刷题/贪心\n/870-Advantage-Shuffle.md","raw":"---\ntitle: 870. Advantage Shuffle\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-05 20:38:14\ntags:\ncategories:\n---\n\n\n\n\n# [870. Advantage Shuffle](https://leetcode-cn.com/problems/advantage-shuffle/)\n\n\n\n\n\n## 思路\n\n一看就是贪心\n\n从小到大逐个寻找B的牌`b`，找出一个刚刚好比`b`大的在A中的牌`a`。因为`a`刚刚比`b`大，所以最优。找出后，加入映射，最后重构数组即可。<!-- more -->\n\n## 代码\n\n下饭操作\n\n```c++\nclass Solution {\npublic:\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\n        int n = A.size();\n        vector<int> sortb(B);\n        sort(A.begin(), A.end());\n        vector<int> leftA;\n        sort(sortb.begin(), sortb.end());\n        // unordered_multimap<int, int> map;\n        multimap<int, int> map; // 可以用 unorder_map<int, deque<int>> 代替， 代码更简洁\n        int g = 0;\n        for(auto b : sortb){\n            while(g < n && A[g] <= b)\n                leftA.push_back(A[g++]);               \n            if(g < n)\n                map.insert({b, A[g++]});                \n        }\n        int k = 0;\n        for(int i = 0; i < n; ++i){\n            auto it = map.lower_bound(B[i]);\n            if(it != map.end()){\n                auto [b, a]= *it;\n                if(b == B[i]){\n                    A[i] = a;\n                    map.erase(it);\n                }\n            } \n            else A[i] = leftA[k++];\n        }\n        return A;\n    }\n};\n```\n\n\n\n","slug":"刷题-贪心-870-Advantage-Shuffle","published":1,"updated":"2021-02-05T12:39:48.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5x003sl5uo5or79vgz","content":"<h1 id=\"870-Advantage-Shuffle\"><a href=\"#870-Advantage-Shuffle\" class=\"headerlink\" title=\"870. Advantage Shuffle\"></a><a href=\"https://leetcode-cn.com/problems/advantage-shuffle/\">870. Advantage Shuffle</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一看就是贪心</p>\n<p>从小到大逐个寻找B的牌<code>b</code>，找出一个刚刚好比<code>b</code>大的在A中的牌<code>a</code>。因为<code>a</code>刚刚比<code>b</code>大，所以最优。找出后，加入映射，最后重构数组即可。<span id=\"more\"></span></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>下饭操作</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;\n        int n &#x3D; A.size();\n        vector&lt;int&gt; sortb(B);\n        sort(A.begin(), A.end());\n        vector&lt;int&gt; leftA;\n        sort(sortb.begin(), sortb.end());\n        &#x2F;&#x2F; unordered_multimap&lt;int, int&gt; map;\n        multimap&lt;int, int&gt; map; &#x2F;&#x2F; 可以用 unorder_map&lt;int, deque&lt;int&gt;&gt; 代替， 代码更简洁\n        int g &#x3D; 0;\n        for(auto b : sortb)&#123;\n            while(g &lt; n &amp;&amp; A[g] &lt;&#x3D; b)\n                leftA.push_back(A[g++]);               \n            if(g &lt; n)\n                map.insert(&#123;b, A[g++]&#125;);                \n        &#125;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            auto it &#x3D; map.lower_bound(B[i]);\n            if(it !&#x3D; map.end())&#123;\n                auto [b, a]&#x3D; *it;\n                if(b &#x3D;&#x3D; B[i])&#123;\n                    A[i] &#x3D; a;\n                    map.erase(it);\n                &#125;\n            &#125; \n            else A[i] &#x3D; leftA[k++];\n        &#125;\n        return A;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","site":{"data":{}},"abbrlink":"1PKVWCY","excerpt":"<h1 id=\"870-Advantage-Shuffle\"><a href=\"#870-Advantage-Shuffle\" class=\"headerlink\" title=\"870. Advantage Shuffle\"></a><a href=\"https://leetcode-cn.com/problems/advantage-shuffle/\">870. Advantage Shuffle</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一看就是贪心</p>\n<p>从小到大逐个寻找B的牌<code>b</code>，找出一个刚刚好比<code>b</code>大的在A中的牌<code>a</code>。因为<code>a</code>刚刚比<code>b</code>大，所以最优。找出后，加入映射，最后重构数组即可。","more":"</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>下饭操作</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;\n        int n &#x3D; A.size();\n        vector&lt;int&gt; sortb(B);\n        sort(A.begin(), A.end());\n        vector&lt;int&gt; leftA;\n        sort(sortb.begin(), sortb.end());\n        &#x2F;&#x2F; unordered_multimap&lt;int, int&gt; map;\n        multimap&lt;int, int&gt; map; &#x2F;&#x2F; 可以用 unorder_map&lt;int, deque&lt;int&gt;&gt; 代替， 代码更简洁\n        int g &#x3D; 0;\n        for(auto b : sortb)&#123;\n            while(g &lt; n &amp;&amp; A[g] &lt;&#x3D; b)\n                leftA.push_back(A[g++]);               \n            if(g &lt; n)\n                map.insert(&#123;b, A[g++]&#125;);                \n        &#125;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            auto it &#x3D; map.lower_bound(B[i]);\n            if(it !&#x3D; map.end())&#123;\n                auto [b, a]&#x3D; *it;\n                if(b &#x3D;&#x3D; B[i])&#123;\n                    A[i] &#x3D; a;\n                    map.erase(it);\n                &#125;\n            &#125; \n            else A[i] &#x3D; leftA[k++];\n        &#125;\n        return A;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题 DP 贪心","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:14:08.000Z","_content":"\n\n<!-- more -->\n\n收集贪心、DP面试题\n\n\n\n## 面14：剪绳子\n\n### 题面：\n\n将一串长为`K`的绳子剪成`m`（`m>=2`，各段长度取整数值）段，各段的长度大于`0`，求出最大的各段绳子长度之积。\n\n### 思路1：\n\n由乘法交换律可知绳子的乘积可以分解，提取出来。所以有`f(m+n)=f(n)*f(m)`，其中`f(n)`是长度`n`的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件`f(1) = 1, f(2) = 2, f(3) = 3`。同时在DP表示式为：\n\nf(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)\n\n\n所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。\n\n\n\n### 思路2：\n\n另一种就是贪心，对于长度`m`大于5的绳子尽可能的剪成长度为3的绳子，同时如果`m%3==1`，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:\n$$\nif \\ n \\geq 5\n\\\n3*(n-3) \\geq n\n\\\n2*(n-2) \\geq n\n\\\n3*(n -3 ) \\geq 2*(n-2)\n$$\n\n### 测试：\n\n```\n2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9\n```\n\n### 代码：\n\n**DP**\n\n```\nint maxProduct_DP(int length){\n    if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int* products = new int[length + 1];\n    //初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] = 0;\n    products[1] = 1;\n    products[2] = 2;\n    products[3] = 3;\n    for(int i = 4; i <= length; i++){\n        int mavV = 0;\n        for(int j = 1; j <= i / 2; j++){\n            maxV = max(maxV, products[i - j] * products[j]);\n        }\n        products[i] = maxv;\n    }\n    int res = products[length];\n    //防止内存泄漏\n    del[] products;\n    return res;\n}\n```\n\n**贪心**\n\n```\nint maxProduct_greedy(int length){\n if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int timesOf3 = length / 3;\n    if(legnth % 3 == 1) timesOf3 -= 1;\n    int timesOf2 = (length - timesOf3 * 3) / 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n}\n```\n\n## 面42：最大子数组和\n\n### 题面：\n\n如题\n\n### 思路：\n\nDP思想。数组之间的选择与历史无关，可以采取DP的方法。记`f(i)`为以`A[i]`为结尾的最大数组和。转移方程为：\n\nf(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0f(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0\n\n\n\n当然也可以直接从数据的角度理解，代码都是相同的。\n\n### 代码：\n\n```\nint MaxSumOfSubArray(int A[], int length){\n    int dp[] = new int(length);\n\tint maxSum = A[0];\n    dp[0] = A[0];   \n    for(int i = 1; i < length; i++){\n        dp[i] = max(A[i], A[i] + dp[i-1]);\n        maxSum = max(dp[i], maxSum);\n    }\n    delete[] dp;\n    return maxSum;\n    \n}\n```\n\n> 当然这里的dp数组也可以不要。\n\n## 面45：把数字排成最小的数字\n\n### 题目：\n\n给定一串数字，组合成的一个数字。求出组合后最小数字的\n\n### 思路：\n\n可以直接贪心+反证。按字典序排序数字即可。\n\n### 代码：\n\n就不写了，直接string排序输出即可。\n\n## 面46：数字翻译成字符串\n\n### 题目：\n\n把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。\n\n### 思路：\n\n第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。\n\n第二种用DP思想，考虑`dp[i]`为从`0`到`i`的字符串翻译方法。状态转移方程为：\n\ndp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else \n\n\n\n### 代码：\n\n```\nint GetTranslateCount(int A[], int length){\n    if(A == nullptr || length <= 0) return 0;\n    int dp[] = new int(length);\n    dp[0] = 1;\n    for(int i = 1; i < length; i++){\n\t\tint add = A[i - 1] * 10 + A[i];\n        if( add > 9 && add < 26){\n            if(i < 2) dp = dp[i - 1] + 1;\n            else dp[i] = dp[i - 1] + dp[i - 2];\n        } \n        else dp[i] = dp[i - 1];\n    }\n    delete[] dp;\n    return dp[length - 1];    \n}\n```\n\n## 面47：礼物的最大价值\n\n### 题目：\n\n从一在格子上装满礼物的`m*n`的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。\n\n### 思路：\n\n明显就是DP\n\n### 代码：\n\n不写了。\n\n## 面48：最长不含重复字符的子字符串\n\n### 题目：\n\n如题\n\n### 思路：\n\n暴力不可取。\n\n采用用DP思想，考虑`dp[i]`为以`S[i]`为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断`S[i]`的前一个相同字符是否在上一个`S[i-1]`为结尾的最长不重复字符串之内。记上一个字符与`S[i-1]`的长度`d`为`i - POS`。\n\n状态转移方程为：\n\ndp[i]={dp[i−1]+1,if d > dp[i - 1] d,else dp[i]={dp[i−1]+1,if d > dp[i - 1] d,else \n\n\n\n### 代码：\n\n```\nint MaxSubStr(String s){\n    int dp[] = new int(s.length());\n    int pos[26];\n    for(int i = 0; i < 26; i++) pos[[i] = -1;\n\t\n\tint maxL = 1;\n\tdp[0] = 1;\n\tfor(int i = 1; i < s.length(); i++){\n\t\tint d = i - pos[s[i] - 'a'];\n        if(dp[i - 1] < d){\n            dp[i] = dp[i - 1] + 1;\n        }else dp[i] = d;\n        maxL = max(maxL, dp[i]);\n        pos[s[i] - 'a'] = i;\n    }\n\tdelete[] dp;    \n   return maxL;            \n    \n}\n```","source":"_posts/刷题/贪心\n/面试题-DP-贪心.md","raw":"---\ntitle: 面试题 DP 贪心\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 14:14:08\ntags:\n---\n\n\n<!-- more -->\n\n收集贪心、DP面试题\n\n\n\n## 面14：剪绳子\n\n### 题面：\n\n将一串长为`K`的绳子剪成`m`（`m>=2`，各段长度取整数值）段，各段的长度大于`0`，求出最大的各段绳子长度之积。\n\n### 思路1：\n\n由乘法交换律可知绳子的乘积可以分解，提取出来。所以有`f(m+n)=f(n)*f(m)`，其中`f(n)`是长度`n`的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件`f(1) = 1, f(2) = 2, f(3) = 3`。同时在DP表示式为：\n\nf(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)\n\n\n所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。\n\n\n\n### 思路2：\n\n另一种就是贪心，对于长度`m`大于5的绳子尽可能的剪成长度为3的绳子，同时如果`m%3==1`，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:\n$$\nif \\ n \\geq 5\n\\\n3*(n-3) \\geq n\n\\\n2*(n-2) \\geq n\n\\\n3*(n -3 ) \\geq 2*(n-2)\n$$\n\n### 测试：\n\n```\n2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9\n```\n\n### 代码：\n\n**DP**\n\n```\nint maxProduct_DP(int length){\n    if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int* products = new int[length + 1];\n    //初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] = 0;\n    products[1] = 1;\n    products[2] = 2;\n    products[3] = 3;\n    for(int i = 4; i <= length; i++){\n        int mavV = 0;\n        for(int j = 1; j <= i / 2; j++){\n            maxV = max(maxV, products[i - j] * products[j]);\n        }\n        products[i] = maxv;\n    }\n    int res = products[length];\n    //防止内存泄漏\n    del[] products;\n    return res;\n}\n```\n\n**贪心**\n\n```\nint maxProduct_greedy(int length){\n if(length < 2) return 0;\n\tif(length == 2) return 1;\n    if(length == 3) return 2;\n    int timesOf3 = length / 3;\n    if(legnth % 3 == 1) timesOf3 -= 1;\n    int timesOf2 = (length - timesOf3 * 3) / 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n}\n```\n\n## 面42：最大子数组和\n\n### 题面：\n\n如题\n\n### 思路：\n\nDP思想。数组之间的选择与历史无关，可以采取DP的方法。记`f(i)`为以`A[i]`为结尾的最大数组和。转移方程为：\n\nf(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0f(i)={A[i],if f(i-1)<0 A[i]+f(i−1),if f(i-1)>0\n\n\n\n当然也可以直接从数据的角度理解，代码都是相同的。\n\n### 代码：\n\n```\nint MaxSumOfSubArray(int A[], int length){\n    int dp[] = new int(length);\n\tint maxSum = A[0];\n    dp[0] = A[0];   \n    for(int i = 1; i < length; i++){\n        dp[i] = max(A[i], A[i] + dp[i-1]);\n        maxSum = max(dp[i], maxSum);\n    }\n    delete[] dp;\n    return maxSum;\n    \n}\n```\n\n> 当然这里的dp数组也可以不要。\n\n## 面45：把数字排成最小的数字\n\n### 题目：\n\n给定一串数字，组合成的一个数字。求出组合后最小数字的\n\n### 思路：\n\n可以直接贪心+反证。按字典序排序数字即可。\n\n### 代码：\n\n就不写了，直接string排序输出即可。\n\n## 面46：数字翻译成字符串\n\n### 题目：\n\n把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。\n\n### 思路：\n\n第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。\n\n第二种用DP思想，考虑`dp[i]`为从`0`到`i`的字符串翻译方法。状态转移方程为：\n\ndp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10<=S[i-1] *10 + S[i] <26 dp[i−1]+dp[i−2],else \n\n\n\n### 代码：\n\n```\nint GetTranslateCount(int A[], int length){\n    if(A == nullptr || length <= 0) return 0;\n    int dp[] = new int(length);\n    dp[0] = 1;\n    for(int i = 1; i < length; i++){\n\t\tint add = A[i - 1] * 10 + A[i];\n        if( add > 9 && add < 26){\n            if(i < 2) dp = dp[i - 1] + 1;\n            else dp[i] = dp[i - 1] + dp[i - 2];\n        } \n        else dp[i] = dp[i - 1];\n    }\n    delete[] dp;\n    return dp[length - 1];    \n}\n```\n\n## 面47：礼物的最大价值\n\n### 题目：\n\n从一在格子上装满礼物的`m*n`的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。\n\n### 思路：\n\n明显就是DP\n\n### 代码：\n\n不写了。\n\n## 面48：最长不含重复字符的子字符串\n\n### 题目：\n\n如题\n\n### 思路：\n\n暴力不可取。\n\n采用用DP思想，考虑`dp[i]`为以`S[i]`为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断`S[i]`的前一个相同字符是否在上一个`S[i-1]`为结尾的最长不重复字符串之内。记上一个字符与`S[i-1]`的长度`d`为`i - POS`。\n\n状态转移方程为：\n\ndp[i]={dp[i−1]+1,if d > dp[i - 1] d,else dp[i]={dp[i−1]+1,if d > dp[i - 1] d,else \n\n\n\n### 代码：\n\n```\nint MaxSubStr(String s){\n    int dp[] = new int(s.length());\n    int pos[26];\n    for(int i = 0; i < 26; i++) pos[[i] = -1;\n\t\n\tint maxL = 1;\n\tdp[0] = 1;\n\tfor(int i = 1; i < s.length(); i++){\n\t\tint d = i - pos[s[i] - 'a'];\n        if(dp[i - 1] < d){\n            dp[i] = dp[i - 1] + 1;\n        }else dp[i] = d;\n        maxL = max(maxL, dp[i]);\n        pos[s[i] - 'a'] = i;\n    }\n\tdelete[] dp;    \n   return maxL;            \n    \n}\n```","slug":"刷题-贪心-面试题-DP-贪心","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j5y003tl5uo7xr5d1r4","content":"<span id=\"more\"></span>\n\n<p>收集贪心、DP面试题</p>\n<h2 id=\"面14：剪绳子\"><a href=\"#面14：剪绳子\" class=\"headerlink\" title=\"面14：剪绳子\"></a>面14：剪绳子</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>将一串长为<code>K</code>的绳子剪成<code>m</code>（<code>m&gt;=2</code>，各段长度取整数值）段，各段的长度大于<code>0</code>，求出最大的各段绳子长度之积。</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>由乘法交换律可知绳子的乘积可以分解，提取出来。所以有<code>f(m+n)=f(n)*f(m)</code>，其中<code>f(n)</code>是长度<code>n</code>的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件<code>f(1) = 1, f(2) = 2, f(3) = 3</code>。同时在DP表示式为：</p>\n<p>f(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)</p>\n<p>所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>另一种就是贪心，对于长度<code>m</code>大于5的绳子尽可能的剪成长度为3的绳子，同时如果<code>m%3==1</code>，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:<br>$$<br>if \\ n \\geq 5<br><br>3*(n-3) \\geq n<br><br>2*(n-2) \\geq n<br><br>3*(n -3 ) \\geq 2*(n-2)<br>$$</p>\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>DP</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_DP(int length)&#123;\n    if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int* products &#x3D; new int[length + 1];\n    &#x2F;&#x2F;初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] &#x3D; 0;\n    products[1] &#x3D; 1;\n    products[2] &#x3D; 2;\n    products[3] &#x3D; 3;\n    for(int i &#x3D; 4; i &lt;&#x3D; length; i++)&#123;\n        int mavV &#x3D; 0;\n        for(int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j++)&#123;\n            maxV &#x3D; max(maxV, products[i - j] * products[j]);\n        &#125;\n        products[i] &#x3D; maxv;\n    &#125;\n    int res &#x3D; products[length];\n    &#x2F;&#x2F;防止内存泄漏\n    del[] products;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>贪心</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_greedy(int length)&#123;\n if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int timesOf3 &#x3D; length &#x2F; 3;\n    if(legnth % 3 &#x3D;&#x3D; 1) timesOf3 -&#x3D; 1;\n    int timesOf2 &#x3D; (length - timesOf3 * 3) &#x2F; 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面42：最大子数组和\"><a href=\"#面42：最大子数组和\" class=\"headerlink\" title=\"面42：最大子数组和\"></a>面42：最大子数组和</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>DP思想。数组之间的选择与历史无关，可以采取DP的方法。记<code>f(i)</code>为以<code>A[i]</code>为结尾的最大数组和。转移方程为：</p>\n<p>f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0</p>\n<p>当然也可以直接从数据的角度理解，代码都是相同的。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSumOfSubArray(int A[], int length)&#123;\n    int dp[] &#x3D; new int(length);\n\tint maxSum &#x3D; A[0];\n    dp[0] &#x3D; A[0];   \n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n        dp[i] &#x3D; max(A[i], A[i] + dp[i-1]);\n        maxSum &#x3D; max(dp[i], maxSum);\n    &#125;\n    delete[] dp;\n    return maxSum;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>当然这里的dp数组也可以不要。</p>\n</blockquote>\n<h2 id=\"面45：把数字排成最小的数字\"><a href=\"#面45：把数字排成最小的数字\" class=\"headerlink\" title=\"面45：把数字排成最小的数字\"></a>面45：把数字排成最小的数字</h2><h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>给定一串数字，组合成的一个数字。求出组合后最小数字的</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以直接贪心+反证。按字典序排序数字即可。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>就不写了，直接string排序输出即可。</p>\n<h2 id=\"面46：数字翻译成字符串\"><a href=\"#面46：数字翻译成字符串\" class=\"headerlink\" title=\"面46：数字翻译成字符串\"></a>面46：数字翻译成字符串</h2><h3 id=\"题目：-1\"><a href=\"#题目：-1\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。</p>\n<p>第二种用DP思想，考虑<code>dp[i]</code>为从<code>0</code>到<code>i</code>的字符串翻译方法。状态转移方程为：</p>\n<p>dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else </p>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int GetTranslateCount(int A[], int length)&#123;\n    if(A &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0) return 0;\n    int dp[] &#x3D; new int(length);\n    dp[0] &#x3D; 1;\n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n\t\tint add &#x3D; A[i - 1] * 10 + A[i];\n        if( add &gt; 9 &amp;&amp; add &lt; 26)&#123;\n            if(i &lt; 2) dp &#x3D; dp[i - 1] + 1;\n            else dp[i] &#x3D; dp[i - 1] + dp[i - 2];\n        &#125; \n        else dp[i] &#x3D; dp[i - 1];\n    &#125;\n    delete[] dp;\n    return dp[length - 1];    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面47：礼物的最大价值\"><a href=\"#面47：礼物的最大价值\" class=\"headerlink\" title=\"面47：礼物的最大价值\"></a>面47：礼物的最大价值</h2><h3 id=\"题目：-2\"><a href=\"#题目：-2\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>从一在格子上装满礼物的<code>m*n</code>的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显就是DP</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>不写了。</p>\n<h2 id=\"面48：最长不含重复字符的子字符串\"><a href=\"#面48：最长不含重复字符的子字符串\" class=\"headerlink\" title=\"面48：最长不含重复字符的子字符串\"></a>面48：最长不含重复字符的子字符串</h2><h3 id=\"题目：-3\"><a href=\"#题目：-3\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>如题</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>暴力不可取。</p>\n<p>采用用DP思想，考虑<code>dp[i]</code>为以<code>S[i]</code>为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断<code>S[i]</code>的前一个相同字符是否在上一个<code>S[i-1]</code>为结尾的最长不重复字符串之内。记上一个字符与<code>S[i-1]</code>的长度<code>d</code>为<code>i - POS</code>。</p>\n<p>状态转移方程为：</p>\n<p>dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else </p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSubStr(String s)&#123;\n    int dp[] &#x3D; new int(s.length());\n    int pos[26];\n    for(int i &#x3D; 0; i &lt; 26; i++) pos[[i] &#x3D; -1;\n\t\n\tint maxL &#x3D; 1;\n\tdp[0] &#x3D; 1;\n\tfor(int i &#x3D; 1; i &lt; s.length(); i++)&#123;\n\t\tint d &#x3D; i - pos[s[i] - &#39;a&#39;];\n        if(dp[i - 1] &lt; d)&#123;\n            dp[i] &#x3D; dp[i - 1] + 1;\n        &#125;else dp[i] &#x3D; d;\n        maxL &#x3D; max(maxL, dp[i]);\n        pos[s[i] - &#39;a&#39;] &#x3D; i;\n    &#125;\n\tdelete[] dp;    \n   return maxL;            \n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"Q4ZBAM","excerpt":"","more":"<p>收集贪心、DP面试题</p>\n<h2 id=\"面14：剪绳子\"><a href=\"#面14：剪绳子\" class=\"headerlink\" title=\"面14：剪绳子\"></a>面14：剪绳子</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>将一串长为<code>K</code>的绳子剪成<code>m</code>（<code>m&gt;=2</code>，各段长度取整数值）段，各段的长度大于<code>0</code>，求出最大的各段绳子长度之积。</p>\n<h3 id=\"思路1：\"><a href=\"#思路1：\" class=\"headerlink\" title=\"思路1：\"></a>思路1：</h3><p>由乘法交换律可知绳子的乘积可以分解，提取出来。所以有<code>f(m+n)=f(n)*f(m)</code>，其中<code>f(n)</code>是长度<code>n</code>的绳子的最大乘积。分析具体问题可以了解到初始条件比较特殊，它对于小数字来说，分解还不如其本身大，所以定义边界条件<code>f(1) = 1, f(2) = 2, f(3) = 3</code>。同时在DP表示式为：</p>\n<p>f(n)=maxif(n−i)∗f(i)f(n)=maxif(n−i)∗f(i)</p>\n<p>所以时间复杂度为O(N2)O(N2)，空间复杂度为O(N)O(N)。</p>\n<h3 id=\"思路2：\"><a href=\"#思路2：\" class=\"headerlink\" title=\"思路2：\"></a>思路2：</h3><p>另一种就是贪心，对于长度<code>m</code>大于5的绳子尽可能的剪成长度为3的绳子，同时如果<code>m%3==1</code>，那么就少剪一段绳子，剪成两段长为2的绳子。证明如下:<br>$$<br>if \\ n \\geq 5<br><br>3*(n-3) \\geq n<br><br>2*(n-2) \\geq n<br><br>3*(n -3 ) \\geq 2*(n-2)<br>$$</p>\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">2\n2\n,\n3\n2\n,\n5\n6\n,\n6\n9<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p><strong>DP</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_DP(int length)&#123;\n    if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int* products &#x3D; new int[length + 1];\n    &#x2F;&#x2F;初试条件比较特殊，小于4的大于1的数的分段乘积不如其本身大\n    products[0] &#x3D; 0;\n    products[1] &#x3D; 1;\n    products[2] &#x3D; 2;\n    products[3] &#x3D; 3;\n    for(int i &#x3D; 4; i &lt;&#x3D; length; i++)&#123;\n        int mavV &#x3D; 0;\n        for(int j &#x3D; 1; j &lt;&#x3D; i &#x2F; 2; j++)&#123;\n            maxV &#x3D; max(maxV, products[i - j] * products[j]);\n        &#125;\n        products[i] &#x3D; maxv;\n    &#125;\n    int res &#x3D; products[length];\n    &#x2F;&#x2F;防止内存泄漏\n    del[] products;\n    return res;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>贪心</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int maxProduct_greedy(int length)&#123;\n if(length &lt; 2) return 0;\n\tif(length &#x3D;&#x3D; 2) return 1;\n    if(length &#x3D;&#x3D; 3) return 2;\n    int timesOf3 &#x3D; length &#x2F; 3;\n    if(legnth % 3 &#x3D;&#x3D; 1) timesOf3 -&#x3D; 1;\n    int timesOf2 &#x3D; (length - timesOf3 * 3) &#x2F; 2;\n    return (int)pow(3, timeOf3) * (int)pow(2, timesOf2);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面42：最大子数组和\"><a href=\"#面42：最大子数组和\" class=\"headerlink\" title=\"面42：最大子数组和\"></a>面42：最大子数组和</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>DP思想。数组之间的选择与历史无关，可以采取DP的方法。记<code>f(i)</code>为以<code>A[i]</code>为结尾的最大数组和。转移方程为：</p>\n<p>f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(i−1),if f(i-1)&gt;0</p>\n<p>当然也可以直接从数据的角度理解，代码都是相同的。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSumOfSubArray(int A[], int length)&#123;\n    int dp[] &#x3D; new int(length);\n\tint maxSum &#x3D; A[0];\n    dp[0] &#x3D; A[0];   \n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n        dp[i] &#x3D; max(A[i], A[i] + dp[i-1]);\n        maxSum &#x3D; max(dp[i], maxSum);\n    &#125;\n    delete[] dp;\n    return maxSum;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>当然这里的dp数组也可以不要。</p>\n</blockquote>\n<h2 id=\"面45：把数字排成最小的数字\"><a href=\"#面45：把数字排成最小的数字\" class=\"headerlink\" title=\"面45：把数字排成最小的数字\"></a>面45：把数字排成最小的数字</h2><h3 id=\"题目：\"><a href=\"#题目：\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>给定一串数字，组合成的一个数字。求出组合后最小数字的</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以直接贪心+反证。按字典序排序数字即可。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>就不写了，直接string排序输出即可。</p>\n<h2 id=\"面46：数字翻译成字符串\"><a href=\"#面46：数字翻译成字符串\" class=\"headerlink\" title=\"面46：数字翻译成字符串\"></a>面46：数字翻译成字符串</h2><h3 id=\"题目：-1\"><a href=\"#题目：-1\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>把一串数字翻译成数字对应的字母，并按原顺序组成字符串。由于数字分裂的不同，翻译方法有许多，求出翻译的方法的个数。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种就是直接递归分割字符串。显然有子问题重叠的现象，可以考虑使用DP。</p>\n<p>第二种用DP思想，考虑<code>dp[i]</code>为从<code>0</code>到<code>i</code>的字符串翻译方法。状态转移方程为：</p>\n<p>dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else dp[i]={dp[i−1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[i−1]+dp[i−2],else </p>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int GetTranslateCount(int A[], int length)&#123;\n    if(A &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0) return 0;\n    int dp[] &#x3D; new int(length);\n    dp[0] &#x3D; 1;\n    for(int i &#x3D; 1; i &lt; length; i++)&#123;\n\t\tint add &#x3D; A[i - 1] * 10 + A[i];\n        if( add &gt; 9 &amp;&amp; add &lt; 26)&#123;\n            if(i &lt; 2) dp &#x3D; dp[i - 1] + 1;\n            else dp[i] &#x3D; dp[i - 1] + dp[i - 2];\n        &#125; \n        else dp[i] &#x3D; dp[i - 1];\n    &#125;\n    delete[] dp;\n    return dp[length - 1];    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面47：礼物的最大价值\"><a href=\"#面47：礼物的最大价值\" class=\"headerlink\" title=\"面47：礼物的最大价值\"></a>面47：礼物的最大价值</h2><h3 id=\"题目：-2\"><a href=\"#题目：-2\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>从一在格子上装满礼物的<code>m*n</code>的矩形棋盘上，从左上角向下或者向右移动一格到右下角，求出路径上礼物价值的最大值。</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显就是DP</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><p>不写了。</p>\n<h2 id=\"面48：最长不含重复字符的子字符串\"><a href=\"#面48：最长不含重复字符的子字符串\" class=\"headerlink\" title=\"面48：最长不含重复字符的子字符串\"></a>面48：最长不含重复字符的子字符串</h2><h3 id=\"题目：-3\"><a href=\"#题目：-3\" class=\"headerlink\" title=\"题目：\"></a>题目：</h3><p>如题</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>暴力不可取。</p>\n<p>采用用DP思想，考虑<code>dp[i]</code>为以<code>S[i]</code>为结尾的最长不重复字符串。一个不含重复字符的字符串可以在由另一个不同的字符组成另一个不含重复字符的字符串。可以在dp过程中，记录下最新的字符的位置POS，判断<code>S[i]</code>的前一个相同字符是否在上一个<code>S[i-1]</code>为结尾的最长不重复字符串之内。记上一个字符与<code>S[i-1]</code>的长度<code>d</code>为<code>i - POS</code>。</p>\n<p>状态转移方程为：</p>\n<p>dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[i−1]+1,if d &gt; dp[i - 1] d,else </p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int MaxSubStr(String s)&#123;\n    int dp[] &#x3D; new int(s.length());\n    int pos[26];\n    for(int i &#x3D; 0; i &lt; 26; i++) pos[[i] &#x3D; -1;\n\t\n\tint maxL &#x3D; 1;\n\tdp[0] &#x3D; 1;\n\tfor(int i &#x3D; 1; i &lt; s.length(); i++)&#123;\n\t\tint d &#x3D; i - pos[s[i] - &#39;a&#39;];\n        if(dp[i - 1] &lt; d)&#123;\n            dp[i] &#x3D; dp[i - 1] + 1;\n        &#125;else dp[i] &#x3D; d;\n        maxL &#x3D; max(maxL, dp[i]);\n        pos[s[i] - &#39;a&#39;] &#x3D; i;\n    &#125;\n\tdelete[] dp;    \n   return maxL;            \n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"编程完整性","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:28:10.000Z","_content":"\n\n<!-- more -->\n\n## 编程完整性\n\n编程完整性是指代码对各种输入，条件的考虑，避免出现各种各样的程序漏洞，完成对编码的需求。可以从三个测试角度考虑，功能测试、边界测试和负面测试。功能测试就是指对代码本身需要完成的功能进行编码。边界测试就是对边界数据进行测试。负面测试就是对不符合要求的输入数据进行测试。\n\n\n\n## 3中错误处理方法\n\n错误处理方法就是为了把程序出现的错误转告给函数调用者。大概有三种方法，一是定义特定函数返回值为函数运行状态，但是增加了函数调用的不便，不能直接赋值给另一个函数的参数。二是定义一个全局变量，若函数调用中出现错误就改变全局变量，相比第一种方法方便很多，但是存在函数调用不检查全局变量的安全隐患。三是抛出异常，或者使用`try.....catch`语句定义不同状态的运行程序，可自定义异常类型，逻辑清晰，但是某些语言可能不支持。\n\n## 代码鲁邦性\n\n代码鲁棒性就是指代码对异常输入，运行错误的处理的能力。因为用户和环境的错误是可能不规范的，为了让程序正确运行，养成防御性编程习惯有利于提高代码质量。最简单最实用例子就是在函数入口检查参数。","source":"_posts/刷题/~其他code能力/代码规范\n/编程完整性.md","raw":"---\ntitle: 编程完整性\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:28:10\n---\n\n\n<!-- more -->\n\n## 编程完整性\n\n编程完整性是指代码对各种输入，条件的考虑，避免出现各种各样的程序漏洞，完成对编码的需求。可以从三个测试角度考虑，功能测试、边界测试和负面测试。功能测试就是指对代码本身需要完成的功能进行编码。边界测试就是对边界数据进行测试。负面测试就是对不符合要求的输入数据进行测试。\n\n\n\n## 3中错误处理方法\n\n错误处理方法就是为了把程序出现的错误转告给函数调用者。大概有三种方法，一是定义特定函数返回值为函数运行状态，但是增加了函数调用的不便，不能直接赋值给另一个函数的参数。二是定义一个全局变量，若函数调用中出现错误就改变全局变量，相比第一种方法方便很多，但是存在函数调用不检查全局变量的安全隐患。三是抛出异常，或者使用`try.....catch`语句定义不同状态的运行程序，可自定义异常类型，逻辑清晰，但是某些语言可能不支持。\n\n## 代码鲁邦性\n\n代码鲁棒性就是指代码对异常输入，运行错误的处理的能力。因为用户和环境的错误是可能不规范的，为了让程序正确运行，养成防御性编程习惯有利于提高代码质量。最简单最实用例子就是在函数入口检查参数。","slug":"刷题-其他code能力-代码规范-编程完整性","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j60003ul5uoeb1qcwjj","content":"<span id=\"more\"></span>\n\n<h2 id=\"编程完整性\"><a href=\"#编程完整性\" class=\"headerlink\" title=\"编程完整性\"></a>编程完整性</h2><p>编程完整性是指代码对各种输入，条件的考虑，避免出现各种各样的程序漏洞，完成对编码的需求。可以从三个测试角度考虑，功能测试、边界测试和负面测试。功能测试就是指对代码本身需要完成的功能进行编码。边界测试就是对边界数据进行测试。负面测试就是对不符合要求的输入数据进行测试。</p>\n<h2 id=\"3中错误处理方法\"><a href=\"#3中错误处理方法\" class=\"headerlink\" title=\"3中错误处理方法\"></a>3中错误处理方法</h2><p>错误处理方法就是为了把程序出现的错误转告给函数调用者。大概有三种方法，一是定义特定函数返回值为函数运行状态，但是增加了函数调用的不便，不能直接赋值给另一个函数的参数。二是定义一个全局变量，若函数调用中出现错误就改变全局变量，相比第一种方法方便很多，但是存在函数调用不检查全局变量的安全隐患。三是抛出异常，或者使用<code>try.....catch</code>语句定义不同状态的运行程序，可自定义异常类型，逻辑清晰，但是某些语言可能不支持。</p>\n<h2 id=\"代码鲁邦性\"><a href=\"#代码鲁邦性\" class=\"headerlink\" title=\"代码鲁邦性\"></a>代码鲁邦性</h2><p>代码鲁棒性就是指代码对异常输入，运行错误的处理的能力。因为用户和环境的错误是可能不规范的，为了让程序正确运行，养成防御性编程习惯有利于提高代码质量。最简单最实用例子就是在函数入口检查参数。</p>\n","site":{"data":{}},"abbrlink":"25819QE","excerpt":"","more":"<h2 id=\"编程完整性\"><a href=\"#编程完整性\" class=\"headerlink\" title=\"编程完整性\"></a>编程完整性</h2><p>编程完整性是指代码对各种输入，条件的考虑，避免出现各种各样的程序漏洞，完成对编码的需求。可以从三个测试角度考虑，功能测试、边界测试和负面测试。功能测试就是指对代码本身需要完成的功能进行编码。边界测试就是对边界数据进行测试。负面测试就是对不符合要求的输入数据进行测试。</p>\n<h2 id=\"3中错误处理方法\"><a href=\"#3中错误处理方法\" class=\"headerlink\" title=\"3中错误处理方法\"></a>3中错误处理方法</h2><p>错误处理方法就是为了把程序出现的错误转告给函数调用者。大概有三种方法，一是定义特定函数返回值为函数运行状态，但是增加了函数调用的不便，不能直接赋值给另一个函数的参数。二是定义一个全局变量，若函数调用中出现错误就改变全局变量，相比第一种方法方便很多，但是存在函数调用不检查全局变量的安全隐患。三是抛出异常，或者使用<code>try.....catch</code>语句定义不同状态的运行程序，可自定义异常类型，逻辑清晰，但是某些语言可能不支持。</p>\n<h2 id=\"代码鲁邦性\"><a href=\"#代码鲁邦性\" class=\"headerlink\" title=\"代码鲁邦性\"></a>代码鲁邦性</h2><p>代码鲁棒性就是指代码对异常输入，运行错误的处理的能力。因为用户和环境的错误是可能不规范的，为了让程序正确运行，养成防御性编程习惯有利于提高代码质量。最简单最实用例子就是在函数入口检查参数。</p>"},{"title":"面试素质","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:20:58.000Z","_content":"\n\n\n面试官希望面试者所展现的素质如下：\n\n\n\n  - 能够清晰表达项目的具体细节和大体流程，可以流畅的表述出对技术、做法的看法\n    - 要求逻辑清晰，详略得当，重点突出，观点明确\n  - 会主动与提问者沟通项目或者问题中不清楚的地方\n  - 对于外企而言流畅的英语交流是必须的\n- 学习能力\n- 知识迁移能力","source":"_posts/刷题/~其他code能力/沟通能力\n/面试素质.md","raw":"---\ntitle: 面试素质\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:20:58\ntags:\n---\n\n\n\n面试官希望面试者所展现的素质如下：\n\n\n\n  - 能够清晰表达项目的具体细节和大体流程，可以流畅的表述出对技术、做法的看法\n    - 要求逻辑清晰，详略得当，重点突出，观点明确\n  - 会主动与提问者沟通项目或者问题中不清楚的地方\n  - 对于外企而言流畅的英语交流是必须的\n- 学习能力\n- 知识迁移能力","slug":"刷题-其他code能力-沟通能力-面试素质","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j60003vl5uo2a7g0i0b","content":"<p>面试官希望面试者所展现的素质如下：</p>\n<ul>\n<li>能够清晰表达项目的具体细节和大体流程，可以流畅的表述出对技术、做法的看法<ul>\n<li>要求逻辑清晰，详略得当，重点突出，观点明确</li>\n</ul>\n</li>\n<li>会主动与提问者沟通项目或者问题中不清楚的地方</li>\n<li>对于外企而言流畅的英语交流是必须的</li>\n<li>学习能力</li>\n<li>知识迁移能力</li>\n</ul>\n","site":{"data":{}},"abbrlink":"18RJVM","excerpt":"","more":"<p>面试官希望面试者所展现的素质如下：</p>\n<ul>\n<li>能够清晰表达项目的具体细节和大体流程，可以流畅的表述出对技术、做法的看法<ul>\n<li>要求逻辑清晰，详略得当，重点突出，观点明确</li>\n</ul>\n</li>\n<li>会主动与提问者沟通项目或者问题中不清楚的地方</li>\n<li>对于外企而言流畅的英语交流是必须的</li>\n<li>学习能力</li>\n<li>知识迁移能力</li>\n</ul>\n"},{"title":"218. The Skyline Problem","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-26T03:16:58.000Z","_content":"\n<!-- more -->\n\n\n\n## [218. The Skyline Problem](https://leetcode-cn.com/problems/the-skyline-problem/)\n\n\n\n\n\n\n\n## 思路：\n\n扫描线算法：\n\n想像一根竖线，从左到右进行扫描，记录下当前竖线所有线段的高度（除去左端点），每遇到一个端点就挑选出最高点，并输出即可。这里可以观察到，此算法把一根直线拆分两个端点来看待，遇到右端点就记录维持该线段的高度，遇到左端点就删除该线段的高度。\n\n\n\n具体算法，直接看代码，其中左端点的Height取负值记录非常巧妙，既利用了set集合的升序性质，同时在遍历的时优先选择了新建筑，不至于产生“建筑间的空隙”。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        multiset<pair<int, int>> loc;\n        for(auto &e : buildings){\n            loc.insert({e[0], -e[2]});\n            loc.insert({e[1], e[2]});\n        }\n        vector<vector<int>> ans;\n        vector<int> last{0,0};\n        multiset<int> height{0}; //多个高度可能相同\n        cout << last[0] << endl;\n\n        for(auto &[pos, h] : loc){\n            if(h < 0) height.insert(-h);\n            else height.erase(height.find(h));\n\n            int maxh = *height.rbegin();\n            // cout << pos << ' ' << h << ' ' << maxh << endl;\n            if(maxh != last[1]){\n                last[0] = pos;\n                last[1] = maxh;\n                ans.emplace_back(last);                \n            }\n        }\n        return ans;\n\n    }\n};\n\n\n```","source":"_posts/刷题/其他/扫描线\n/218-The-Skyline-Problem.md","raw":"---\ntitle: 218. The Skyline Problem\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-26 11:16:58\n---\n\n<!-- more -->\n\n\n\n## [218. The Skyline Problem](https://leetcode-cn.com/problems/the-skyline-problem/)\n\n\n\n\n\n\n\n## 思路：\n\n扫描线算法：\n\n想像一根竖线，从左到右进行扫描，记录下当前竖线所有线段的高度（除去左端点），每遇到一个端点就挑选出最高点，并输出即可。这里可以观察到，此算法把一根直线拆分两个端点来看待，遇到右端点就记录维持该线段的高度，遇到左端点就删除该线段的高度。\n\n\n\n具体算法，直接看代码，其中左端点的Height取负值记录非常巧妙，既利用了set集合的升序性质，同时在遍历的时优先选择了新建筑，不至于产生“建筑间的空隙”。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        multiset<pair<int, int>> loc;\n        for(auto &e : buildings){\n            loc.insert({e[0], -e[2]});\n            loc.insert({e[1], e[2]});\n        }\n        vector<vector<int>> ans;\n        vector<int> last{0,0};\n        multiset<int> height{0}; //多个高度可能相同\n        cout << last[0] << endl;\n\n        for(auto &[pos, h] : loc){\n            if(h < 0) height.insert(-h);\n            else height.erase(height.find(h));\n\n            int maxh = *height.rbegin();\n            // cout << pos << ' ' << h << ' ' << maxh << endl;\n            if(maxh != last[1]){\n                last[0] = pos;\n                last[1] = maxh;\n                ans.emplace_back(last);                \n            }\n        }\n        return ans;\n\n    }\n};\n\n\n```","slug":"刷题-其他-扫描线-218-The-Skyline-Problem","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j61003wl5uoc1pqcgur","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"218-The-Skyline-Problem\"><a href=\"#218-The-Skyline-Problem\" class=\"headerlink\" title=\"218. The Skyline Problem\"></a><a href=\"https://leetcode-cn.com/problems/the-skyline-problem/\">218. The Skyline Problem</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>扫描线算法：</p>\n<p>想像一根竖线，从左到右进行扫描，记录下当前竖线所有线段的高度（除去左端点），每遇到一个端点就挑选出最高点，并输出即可。这里可以观察到，此算法把一根直线拆分两个端点来看待，遇到右端点就记录维持该线段的高度，遇到左端点就删除该线段的高度。</p>\n<p>具体算法，直接看代码，其中左端点的Height取负值记录非常巧妙，既利用了set集合的升序性质，同时在遍历的时优先选择了新建筑，不至于产生“建筑间的空隙”。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123;\n        multiset&lt;pair&lt;int, int&gt;&gt; loc;\n        for(auto &amp;e : buildings)&#123;\n            loc.insert(&#123;e[0], -e[2]&#125;);\n            loc.insert(&#123;e[1], e[2]&#125;);\n        &#125;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; last&#123;0,0&#125;;\n        multiset&lt;int&gt; height&#123;0&#125;; &#x2F;&#x2F;多个高度可能相同\n        cout &lt;&lt; last[0] &lt;&lt; endl;\n\n        for(auto &amp;[pos, h] : loc)&#123;\n            if(h &lt; 0) height.insert(-h);\n            else height.erase(height.find(h));\n\n            int maxh &#x3D; *height.rbegin();\n            &#x2F;&#x2F; cout &lt;&lt; pos &lt;&lt; &#39; &#39; &lt;&lt; h &lt;&lt; &#39; &#39; &lt;&lt; maxh &lt;&lt; endl;\n            if(maxh !&#x3D; last[1])&#123;\n                last[0] &#x3D; pos;\n                last[1] &#x3D; maxh;\n                ans.emplace_back(last);                \n            &#125;\n        &#125;\n        return ans;\n\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2R88RB9","excerpt":"","more":"<h2 id=\"218-The-Skyline-Problem\"><a href=\"#218-The-Skyline-Problem\" class=\"headerlink\" title=\"218. The Skyline Problem\"></a><a href=\"https://leetcode-cn.com/problems/the-skyline-problem/\">218. The Skyline Problem</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>扫描线算法：</p>\n<p>想像一根竖线，从左到右进行扫描，记录下当前竖线所有线段的高度（除去左端点），每遇到一个端点就挑选出最高点，并输出即可。这里可以观察到，此算法把一根直线拆分两个端点来看待，遇到右端点就记录维持该线段的高度，遇到左端点就删除该线段的高度。</p>\n<p>具体算法，直接看代码，其中左端点的Height取负值记录非常巧妙，既利用了set集合的升序性质，同时在遍历的时优先选择了新建筑，不至于产生“建筑间的空隙”。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123;\n        multiset&lt;pair&lt;int, int&gt;&gt; loc;\n        for(auto &amp;e : buildings)&#123;\n            loc.insert(&#123;e[0], -e[2]&#125;);\n            loc.insert(&#123;e[1], e[2]&#125;);\n        &#125;\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        vector&lt;int&gt; last&#123;0,0&#125;;\n        multiset&lt;int&gt; height&#123;0&#125;; &#x2F;&#x2F;多个高度可能相同\n        cout &lt;&lt; last[0] &lt;&lt; endl;\n\n        for(auto &amp;[pos, h] : loc)&#123;\n            if(h &lt; 0) height.insert(-h);\n            else height.erase(height.find(h));\n\n            int maxh &#x3D; *height.rbegin();\n            &#x2F;&#x2F; cout &lt;&lt; pos &lt;&lt; &#39; &#39; &lt;&lt; h &lt;&lt; &#39; &#39; &lt;&lt; maxh &lt;&lt; endl;\n            if(maxh !&#x3D; last[1])&#123;\n                last[0] &#x3D; pos;\n                last[1] &#x3D; maxh;\n                ans.emplace_back(last);                \n            &#125;\n        &#125;\n        return ans;\n\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"126. Word Ladder II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-29T02:59:06.000Z","_content":"\n\n\n\n## [126. Word Ladder II](https://leetcode-cn.com/problems/word-ladder-ii/)\n\n## 思路：\n\n> 这次的bugs很少，开心。\n>\n> 这题核心就是BFS（DFS）的基础上加上剪枝优化。或者TBFS\n>\n> \n\n\n\n建立搜索树BFS搜索结果即可。\n\n最好用邻接矩阵优化BFS搜索数量，同时显然的，你没法通过绕一个小弯找到最短路，这可以剪枝。\n\n\n\n<!-- more -->\n\n![img](D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg)\n\n\n\n第二种思路就是双头搜索。因为题目给出了起始地点和结束地点的字符串。在搜索的时候控制一下搜索空间，搜索深度就AC了。击败96%！。\n\n## 代码：\n\n```C++\n// 26th样例超时\nclass Solution {\npublic:\n    \n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        vector<vector<string>> ans;\n        int n = wordList.size(), flag = 0;\n        for(int i = 0; i < n; ++i){\n            if(wordList[i] == endWord) flag = 1;\n        }\n        if(!flag) return ans;\n        queue<SN*> que;\n        wordList.push_back(beginWord); // size++\n        que.push(new SN(n, -1, 0, nullptr));\n        int endlevel = -1;\n        while(que.size()){\n            SN *p = que.front(); \n            que.pop();\n            // cout << wordList[p.x] <<\"  \" << p.l << '#';\n            // if(p.plink != nullptr)\n            //     cout << p.x << (p.plink)->x << endl;\n            // cout << (p.plink == &p) << endl;  // bugs: p.plink == &p\n            //search the final points.\n            if(endlevel > 0 && p->l > endlevel) continue;\n            if(wordList[p->x] == endWord){\n                endlevel = p->l;\n                vector<string> tmp;\n                SN* np = p;\n                while(np  != nullptr){\n                    tmp.push_back(wordList[np->x]);\n                    np = np->plink;      \n                    // cout << np->x << \" \";              \n                }\n                // cout << endl;\n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            }\n            \n            \n            // emplace more points.\n            for(int j = 0; j < n; ++j){\n                if(islink(wordList[j], wordList[p->x])){                    \n                    SN* newp = new SN(j, p->x, p->l + 1, p); //bugs: 这里取的地址是变量p的地址，同时地址指向不变，但是p指向的内容会受暂存变量p赋值而变化。 这可是C++基础啊\n                    //解决方法： 给每个变量一个新的地址即可\n                    // cout << (&newp == &p) << endl;\n                    que.push(newp);\n                }\n            }\n        }\n\n        return ans;\n    }\n\n    bool islink(const string &a, const string  &b){\n        int len = a.size(), t = 0;\n        for(int i = 0; i < len; ++i){\n            if(a[i] != b[i]) t++;\n            if(t > 1) return false;\n        }\n        if(t == 0) return false;\n        return true;\n    }\n    class SN{\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){}\n    };\n};\n```\n\n\n\nAC\n\n```c++\n\n//图优化版本\n// 执行用时：\n// 644 ms\n// , 在所有 C++ 提交中击败了\n// 61.99%\n// 的用户\n// 内存消耗：\n// 19.1 MB\n// , 在所有 C++ 提交中击败了\n// 66.81%\n// 的用户\nclass Solution {\npublic:\n\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        \n        vector<vector<string>> ans;\n        \n        int n = wordList.size(), flag = 0;\n        for(int i = 0; i < n; ++i){\n            if(wordList[i] == endWord) flag = 1;\n        }\n        if(!flag) return ans;\n\n\n        //bulid the map.\n        wordList.push_back(beginWord); // size++\n        n++;\n        vector<vector<int>> edges;\n        edges.resize(n + 1);\n\n        for(int i = 0; i < n; ++i){\n            for(int j = i + 1; j < n; ++j){\n                if(islink(wordList[i], wordList[j])){\n                    edges[i].push_back(j);\n                    edges[j].push_back(i);\n                }\n            }\n        }\n        \n        vector<int>  cost(n, n + 1);\n        cost[n - 1] = 0;\n\n        //bfs\n        queue<SN*> que;        \n        que.push(new SN(n - 1, -1, 0, nullptr));\n        int endlevel = -1;\n        while(que.size()){\n            SN *p = que.front(); \n            que.pop();\n\n            if(endlevel > 0 && p->l > endlevel) continue;\n            if(wordList[p->x] == endWord){\n                endlevel = p->l;\n                vector<string> tmp;\n                SN* np = p;\n                while(np  != nullptr){\n                    tmp.push_back(wordList[np->x]);\n                    np = np->plink;                          \n                }                \n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            }\n                        \n            // emplace more points.\n            for(auto j : edges[p->x]){            \n                if(cost[j] > cost[p->x]){ // 没法绕一个圈子找到最短路\n                    cost[j] = cost[p->x] + 1;\n                    SN* newp = new SN(j, p->x, p->l + 1, p);\n                    que.push(newp);\n                }\n                \n            }\n        }\n\n        return ans;\n    }\n\n    bool islink(const string &a, const string  &b){\n        int len = a.size(), t = 0;\n        for(int i = 0; i < len; ++i){\n            if(a[i] != b[i]) t++;\n            if(t > 1) return false;\n        }\n        if(t == 0) return false;\n        return true;\n    }\n    class SN{\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){} //由于历史原因，px和l有点多余\n    };\n};\n```\n\n\n\n\n\n双向bfs思路学习；（未完成）\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        vector<vector<string>> path;\n        unordered_set<string> dict ,q1, q2; //dict：搜索空间 q1q2:双头搜索\n        unordered_map<string, vector<string>> next;\n        for(const auto &p : wordList){\n            dict.insert(p);\n        }\n        if(!dict.count(endWord))\n            return path;\n\n        dict.erase(beginWord);\n        dict.erase(endWord);\n\n        q1.insert(beginWord);\n        q2.insert(endWord);\n        bool reverse = false, found = false;\n        while(!q1.empty()){\n            unordered_set<string> q;\n            for(const auto &w : q1){\n                string cw = w;\n                for(size_t i = 0 ; i < cw.size(); ++i){\n                    char c = cw[i];\n                    for(int j = 0; j < 26; ++j){\n                        cw[i] = j + 'a';\n                        if(q2.count(cw)){\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            found = true;\n                        }\n                        if(dict.count(cw)){ //count 比 find好用\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            q.insert(cw);\n                        }\n                    }\n                    cw[i] = c;\n                }\n            }\n            // for(const auto &w :q)\n            //     cout << w << \" \";\n            // cout << endl;\n            //控制搜索层数            \n            if(found)  break;\n            for(const auto &w : q){\n                dict.erase(w);\n            }\n            //选择扩展范围小的开始搜索，降低搜索数量\n            if(q.size() < q2.size()){\n                q1 = q;\n            }else{\n                reverse = !reverse;\n                q1 = q2;\n                q2 = q;\n            }\n\n        }\n\n        vector<string> oneway = {beginWord};\n        buildPath(next, path, oneway, beginWord, endWord);\n        return path;\n        \n    }\n    \n    void buildPath(unordered_map<string, vector<string>>& next, vector<vector<string>>& path, \n                 vector<string> &oneway, string nword, string endWord){\n        if(nword == endWord){            \n            path.push_back(oneway);\n            return;        \n        }\n        for(const auto &w : next[nword]){\n            oneway.push_back(w);\n            buildPath(next, path, oneway, w, endWord);\n            oneway.pop_back();\n        }\n    }\n};\n\n```","source":"_posts/刷题/搜索/bfs\n/126-Word-Ladder-II.md","raw":"---\ntitle: 126. Word Ladder II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-29 10:59:06\n---\n\n\n\n\n## [126. Word Ladder II](https://leetcode-cn.com/problems/word-ladder-ii/)\n\n## 思路：\n\n> 这次的bugs很少，开心。\n>\n> 这题核心就是BFS（DFS）的基础上加上剪枝优化。或者TBFS\n>\n> \n\n\n\n建立搜索树BFS搜索结果即可。\n\n最好用邻接矩阵优化BFS搜索数量，同时显然的，你没法通过绕一个小弯找到最短路，这可以剪枝。\n\n\n\n<!-- more -->\n\n![img](D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg)\n\n\n\n第二种思路就是双头搜索。因为题目给出了起始地点和结束地点的字符串。在搜索的时候控制一下搜索空间，搜索深度就AC了。击败96%！。\n\n## 代码：\n\n```C++\n// 26th样例超时\nclass Solution {\npublic:\n    \n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        vector<vector<string>> ans;\n        int n = wordList.size(), flag = 0;\n        for(int i = 0; i < n; ++i){\n            if(wordList[i] == endWord) flag = 1;\n        }\n        if(!flag) return ans;\n        queue<SN*> que;\n        wordList.push_back(beginWord); // size++\n        que.push(new SN(n, -1, 0, nullptr));\n        int endlevel = -1;\n        while(que.size()){\n            SN *p = que.front(); \n            que.pop();\n            // cout << wordList[p.x] <<\"  \" << p.l << '#';\n            // if(p.plink != nullptr)\n            //     cout << p.x << (p.plink)->x << endl;\n            // cout << (p.plink == &p) << endl;  // bugs: p.plink == &p\n            //search the final points.\n            if(endlevel > 0 && p->l > endlevel) continue;\n            if(wordList[p->x] == endWord){\n                endlevel = p->l;\n                vector<string> tmp;\n                SN* np = p;\n                while(np  != nullptr){\n                    tmp.push_back(wordList[np->x]);\n                    np = np->plink;      \n                    // cout << np->x << \" \";              \n                }\n                // cout << endl;\n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            }\n            \n            \n            // emplace more points.\n            for(int j = 0; j < n; ++j){\n                if(islink(wordList[j], wordList[p->x])){                    \n                    SN* newp = new SN(j, p->x, p->l + 1, p); //bugs: 这里取的地址是变量p的地址，同时地址指向不变，但是p指向的内容会受暂存变量p赋值而变化。 这可是C++基础啊\n                    //解决方法： 给每个变量一个新的地址即可\n                    // cout << (&newp == &p) << endl;\n                    que.push(newp);\n                }\n            }\n        }\n\n        return ans;\n    }\n\n    bool islink(const string &a, const string  &b){\n        int len = a.size(), t = 0;\n        for(int i = 0; i < len; ++i){\n            if(a[i] != b[i]) t++;\n            if(t > 1) return false;\n        }\n        if(t == 0) return false;\n        return true;\n    }\n    class SN{\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){}\n    };\n};\n```\n\n\n\nAC\n\n```c++\n\n//图优化版本\n// 执行用时：\n// 644 ms\n// , 在所有 C++ 提交中击败了\n// 61.99%\n// 的用户\n// 内存消耗：\n// 19.1 MB\n// , 在所有 C++ 提交中击败了\n// 66.81%\n// 的用户\nclass Solution {\npublic:\n\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        \n        vector<vector<string>> ans;\n        \n        int n = wordList.size(), flag = 0;\n        for(int i = 0; i < n; ++i){\n            if(wordList[i] == endWord) flag = 1;\n        }\n        if(!flag) return ans;\n\n\n        //bulid the map.\n        wordList.push_back(beginWord); // size++\n        n++;\n        vector<vector<int>> edges;\n        edges.resize(n + 1);\n\n        for(int i = 0; i < n; ++i){\n            for(int j = i + 1; j < n; ++j){\n                if(islink(wordList[i], wordList[j])){\n                    edges[i].push_back(j);\n                    edges[j].push_back(i);\n                }\n            }\n        }\n        \n        vector<int>  cost(n, n + 1);\n        cost[n - 1] = 0;\n\n        //bfs\n        queue<SN*> que;        \n        que.push(new SN(n - 1, -1, 0, nullptr));\n        int endlevel = -1;\n        while(que.size()){\n            SN *p = que.front(); \n            que.pop();\n\n            if(endlevel > 0 && p->l > endlevel) continue;\n            if(wordList[p->x] == endWord){\n                endlevel = p->l;\n                vector<string> tmp;\n                SN* np = p;\n                while(np  != nullptr){\n                    tmp.push_back(wordList[np->x]);\n                    np = np->plink;                          \n                }                \n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            }\n                        \n            // emplace more points.\n            for(auto j : edges[p->x]){            \n                if(cost[j] > cost[p->x]){ // 没法绕一个圈子找到最短路\n                    cost[j] = cost[p->x] + 1;\n                    SN* newp = new SN(j, p->x, p->l + 1, p);\n                    que.push(newp);\n                }\n                \n            }\n        }\n\n        return ans;\n    }\n\n    bool islink(const string &a, const string  &b){\n        int len = a.size(), t = 0;\n        for(int i = 0; i < len; ++i){\n            if(a[i] != b[i]) t++;\n            if(t > 1) return false;\n        }\n        if(t == 0) return false;\n        return true;\n    }\n    class SN{\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){} //由于历史原因，px和l有点多余\n    };\n};\n```\n\n\n\n\n\n双向bfs思路学习；（未完成）\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        vector<vector<string>> path;\n        unordered_set<string> dict ,q1, q2; //dict：搜索空间 q1q2:双头搜索\n        unordered_map<string, vector<string>> next;\n        for(const auto &p : wordList){\n            dict.insert(p);\n        }\n        if(!dict.count(endWord))\n            return path;\n\n        dict.erase(beginWord);\n        dict.erase(endWord);\n\n        q1.insert(beginWord);\n        q2.insert(endWord);\n        bool reverse = false, found = false;\n        while(!q1.empty()){\n            unordered_set<string> q;\n            for(const auto &w : q1){\n                string cw = w;\n                for(size_t i = 0 ; i < cw.size(); ++i){\n                    char c = cw[i];\n                    for(int j = 0; j < 26; ++j){\n                        cw[i] = j + 'a';\n                        if(q2.count(cw)){\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            found = true;\n                        }\n                        if(dict.count(cw)){ //count 比 find好用\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            q.insert(cw);\n                        }\n                    }\n                    cw[i] = c;\n                }\n            }\n            // for(const auto &w :q)\n            //     cout << w << \" \";\n            // cout << endl;\n            //控制搜索层数            \n            if(found)  break;\n            for(const auto &w : q){\n                dict.erase(w);\n            }\n            //选择扩展范围小的开始搜索，降低搜索数量\n            if(q.size() < q2.size()){\n                q1 = q;\n            }else{\n                reverse = !reverse;\n                q1 = q2;\n                q2 = q;\n            }\n\n        }\n\n        vector<string> oneway = {beginWord};\n        buildPath(next, path, oneway, beginWord, endWord);\n        return path;\n        \n    }\n    \n    void buildPath(unordered_map<string, vector<string>>& next, vector<vector<string>>& path, \n                 vector<string> &oneway, string nword, string endWord){\n        if(nword == endWord){            \n            path.push_back(oneway);\n            return;        \n        }\n        for(const auto &w : next[nword]){\n            oneway.push_back(w);\n            buildPath(next, path, oneway, w, endWord);\n            oneway.pop_back();\n        }\n    }\n};\n\n```","slug":"刷题-搜索-bfs-126-Word-Ladder-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j62003xl5uo4yai1dc7","content":"<h2 id=\"126-Word-Ladder-II\"><a href=\"#126-Word-Ladder-II\" class=\"headerlink\" title=\"126. Word Ladder II\"></a><a href=\"https://leetcode-cn.com/problems/word-ladder-ii/\">126. Word Ladder II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><blockquote>\n<p>这次的bugs很少，开心。</p>\n<p>这题核心就是BFS（DFS）的基础上加上剪枝优化。或者TBFS</p>\n</blockquote>\n<p>建立搜索树BFS搜索结果即可。</p>\n<p>最好用邻接矩阵优化BFS搜索数量，同时显然的，你没法通过绕一个小弯找到最短路，这可以剪枝。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg\" alt=\"img\"></p>\n<p>第二种思路就是双头搜索。因为题目给出了起始地点和结束地点的字符串。在搜索的时候控制一下搜索空间，搜索深度就AC了。击败96%！。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F; 26th样例超时\nclass Solution &#123;\npublic:\n    \n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        int n &#x3D; wordList.size(), flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(wordList[i] &#x3D;&#x3D; endWord) flag &#x3D; 1;\n        &#125;\n        if(!flag) return ans;\n        queue&lt;SN*&gt; que;\n        wordList.push_back(beginWord); &#x2F;&#x2F; size++\n        que.push(new SN(n, -1, 0, nullptr));\n        int endlevel &#x3D; -1;\n        while(que.size())&#123;\n            SN *p &#x3D; que.front(); \n            que.pop();\n            &#x2F;&#x2F; cout &lt;&lt; wordList[p.x] &lt;&lt;&quot;  &quot; &lt;&lt; p.l &lt;&lt; &#39;#&#39;;\n            &#x2F;&#x2F; if(p.plink !&#x3D; nullptr)\n            &#x2F;&#x2F;     cout &lt;&lt; p.x &lt;&lt; (p.plink)-&gt;x &lt;&lt; endl;\n            &#x2F;&#x2F; cout &lt;&lt; (p.plink &#x3D;&#x3D; &amp;p) &lt;&lt; endl;  &#x2F;&#x2F; bugs: p.plink &#x3D;&#x3D; &amp;p\n            &#x2F;&#x2F;search the final points.\n            if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue;\n            if(wordList[p-&gt;x] &#x3D;&#x3D; endWord)&#123;\n                endlevel &#x3D; p-&gt;l;\n                vector&lt;string&gt; tmp;\n                SN* np &#x3D; p;\n                while(np  !&#x3D; nullptr)&#123;\n                    tmp.push_back(wordList[np-&gt;x]);\n                    np &#x3D; np-&gt;plink;      \n                    &#x2F;&#x2F; cout &lt;&lt; np-&gt;x &lt;&lt; &quot; &quot;;              \n                &#125;\n                &#x2F;&#x2F; cout &lt;&lt; endl;\n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            &#125;\n            \n            \n            &#x2F;&#x2F; emplace more points.\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(islink(wordList[j], wordList[p-&gt;x]))&#123;                    \n                    SN* newp &#x3D; new SN(j, p-&gt;x, p-&gt;l + 1, p); &#x2F;&#x2F;bugs: 这里取的地址是变量p的地址，同时地址指向不变，但是p指向的内容会受暂存变量p赋值而变化。 这可是C++基础啊\n                    &#x2F;&#x2F;解决方法： 给每个变量一个新的地址即可\n                    &#x2F;&#x2F; cout &lt;&lt; (&amp;newp &#x3D;&#x3D; &amp;p) &lt;&lt; endl;\n                    que.push(newp);\n                &#125;\n            &#125;\n        &#125;\n\n        return ans;\n    &#125;\n\n    bool islink(const string &amp;a, const string  &amp;b)&#123;\n        int len &#x3D; a.size(), t &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; len; ++i)&#123;\n            if(a[i] !&#x3D; b[i]) t++;\n            if(t &gt; 1) return false;\n        &#125;\n        if(t &#x3D;&#x3D; 0) return false;\n        return true;\n    &#125;\n    class SN&#123;\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink)&#123;&#125;\n    &#125;;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>AC</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;&#x2F;图优化版本\n&#x2F;&#x2F; 执行用时：\n&#x2F;&#x2F; 644 ms\n&#x2F;&#x2F; , 在所有 C++ 提交中击败了\n&#x2F;&#x2F; 61.99%\n&#x2F;&#x2F; 的用户\n&#x2F;&#x2F; 内存消耗：\n&#x2F;&#x2F; 19.1 MB\n&#x2F;&#x2F; , 在所有 C++ 提交中击败了\n&#x2F;&#x2F; 66.81%\n&#x2F;&#x2F; 的用户\nclass Solution &#123;\npublic:\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        \n        vector&lt;vector&lt;string&gt;&gt; ans;\n        \n        int n &#x3D; wordList.size(), flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(wordList[i] &#x3D;&#x3D; endWord) flag &#x3D; 1;\n        &#125;\n        if(!flag) return ans;\n\n\n        &#x2F;&#x2F;bulid the map.\n        wordList.push_back(beginWord); &#x2F;&#x2F; size++\n        n++;\n        vector&lt;vector&lt;int&gt;&gt; edges;\n        edges.resize(n + 1);\n\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; i + 1; j &lt; n; ++j)&#123;\n                if(islink(wordList[i], wordList[j]))&#123;\n                    edges[i].push_back(j);\n                    edges[j].push_back(i);\n                &#125;\n            &#125;\n        &#125;\n        \n        vector&lt;int&gt;  cost(n, n + 1);\n        cost[n - 1] &#x3D; 0;\n\n        &#x2F;&#x2F;bfs\n        queue&lt;SN*&gt; que;        \n        que.push(new SN(n - 1, -1, 0, nullptr));\n        int endlevel &#x3D; -1;\n        while(que.size())&#123;\n            SN *p &#x3D; que.front(); \n            que.pop();\n\n            if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue;\n            if(wordList[p-&gt;x] &#x3D;&#x3D; endWord)&#123;\n                endlevel &#x3D; p-&gt;l;\n                vector&lt;string&gt; tmp;\n                SN* np &#x3D; p;\n                while(np  !&#x3D; nullptr)&#123;\n                    tmp.push_back(wordList[np-&gt;x]);\n                    np &#x3D; np-&gt;plink;                          \n                &#125;                \n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            &#125;\n                        \n            &#x2F;&#x2F; emplace more points.\n            for(auto j : edges[p-&gt;x])&#123;            \n                if(cost[j] &gt; cost[p-&gt;x])&#123; &#x2F;&#x2F; 没法绕一个圈子找到最短路\n                    cost[j] &#x3D; cost[p-&gt;x] + 1;\n                    SN* newp &#x3D; new SN(j, p-&gt;x, p-&gt;l + 1, p);\n                    que.push(newp);\n                &#125;\n                \n            &#125;\n        &#125;\n\n        return ans;\n    &#125;\n\n    bool islink(const string &amp;a, const string  &amp;b)&#123;\n        int len &#x3D; a.size(), t &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; len; ++i)&#123;\n            if(a[i] !&#x3D; b[i]) t++;\n            if(t &gt; 1) return false;\n        &#125;\n        if(t &#x3D;&#x3D; 0) return false;\n        return true;\n    &#125;\n    class SN&#123;\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink)&#123;&#125; &#x2F;&#x2F;由于历史原因，px和l有点多余\n    &#125;;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>双向bfs思路学习；（未完成）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        vector&lt;vector&lt;string&gt;&gt; path;\n        unordered_set&lt;string&gt; dict ,q1, q2; &#x2F;&#x2F;dict：搜索空间 q1q2:双头搜索\n        unordered_map&lt;string, vector&lt;string&gt;&gt; next;\n        for(const auto &amp;p : wordList)&#123;\n            dict.insert(p);\n        &#125;\n        if(!dict.count(endWord))\n            return path;\n\n        dict.erase(beginWord);\n        dict.erase(endWord);\n\n        q1.insert(beginWord);\n        q2.insert(endWord);\n        bool reverse &#x3D; false, found &#x3D; false;\n        while(!q1.empty())&#123;\n            unordered_set&lt;string&gt; q;\n            for(const auto &amp;w : q1)&#123;\n                string cw &#x3D; w;\n                for(size_t i &#x3D; 0 ; i &lt; cw.size(); ++i)&#123;\n                    char c &#x3D; cw[i];\n                    for(int j &#x3D; 0; j &lt; 26; ++j)&#123;\n                        cw[i] &#x3D; j + &#39;a&#39;;\n                        if(q2.count(cw))&#123;\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            found &#x3D; true;\n                        &#125;\n                        if(dict.count(cw))&#123; &#x2F;&#x2F;count 比 find好用\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            q.insert(cw);\n                        &#125;\n                    &#125;\n                    cw[i] &#x3D; c;\n                &#125;\n            &#125;\n            &#x2F;&#x2F; for(const auto &amp;w :q)\n            &#x2F;&#x2F;     cout &lt;&lt; w &lt;&lt; &quot; &quot;;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n            &#x2F;&#x2F;控制搜索层数            \n            if(found)  break;\n            for(const auto &amp;w : q)&#123;\n                dict.erase(w);\n            &#125;\n            &#x2F;&#x2F;选择扩展范围小的开始搜索，降低搜索数量\n            if(q.size() &lt; q2.size())&#123;\n                q1 &#x3D; q;\n            &#125;else&#123;\n                reverse &#x3D; !reverse;\n                q1 &#x3D; q2;\n                q2 &#x3D; q;\n            &#125;\n\n        &#125;\n\n        vector&lt;string&gt; oneway &#x3D; &#123;beginWord&#125;;\n        buildPath(next, path, oneway, beginWord, endWord);\n        return path;\n        \n    &#125;\n    \n    void buildPath(unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; next, vector&lt;vector&lt;string&gt;&gt;&amp; path, \n                 vector&lt;string&gt; &amp;oneway, string nword, string endWord)&#123;\n        if(nword &#x3D;&#x3D; endWord)&#123;            \n            path.push_back(oneway);\n            return;        \n        &#125;\n        for(const auto &amp;w : next[nword])&#123;\n            oneway.push_back(w);\n            buildPath(next, path, oneway, w, endWord);\n            oneway.pop_back();\n        &#125;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"PTW7AC","excerpt":"<h2 id=\"126-Word-Ladder-II\"><a href=\"#126-Word-Ladder-II\" class=\"headerlink\" title=\"126. Word Ladder II\"></a><a href=\"https://leetcode-cn.com/problems/word-ladder-ii/\">126. Word Ladder II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><blockquote>\n<p>这次的bugs很少，开心。</p>\n<p>这题核心就是BFS（DFS）的基础上加上剪枝优化。或者TBFS</p>\n</blockquote>\n<p>建立搜索树BFS搜索结果即可。</p>\n<p>最好用邻接矩阵优化BFS搜索数量，同时显然的，你没法通过绕一个小弯找到最短路，这可以剪枝。</p>","more":"<p><img src=\"D:\\个人文件\\重要文件\\闲书与笔记\\MD暂存文件\\164a736e22a59a44e7e51e79e2f22f77d392fcd4dc621ea0083a91bd86855884.jpg\" alt=\"img\"></p>\n<p>第二种思路就是双头搜索。因为题目给出了起始地点和结束地点的字符串。在搜索的时候控制一下搜索空间，搜索深度就AC了。击败96%！。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F; 26th样例超时\nclass Solution &#123;\npublic:\n    \n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        vector&lt;vector&lt;string&gt;&gt; ans;\n        int n &#x3D; wordList.size(), flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(wordList[i] &#x3D;&#x3D; endWord) flag &#x3D; 1;\n        &#125;\n        if(!flag) return ans;\n        queue&lt;SN*&gt; que;\n        wordList.push_back(beginWord); &#x2F;&#x2F; size++\n        que.push(new SN(n, -1, 0, nullptr));\n        int endlevel &#x3D; -1;\n        while(que.size())&#123;\n            SN *p &#x3D; que.front(); \n            que.pop();\n            &#x2F;&#x2F; cout &lt;&lt; wordList[p.x] &lt;&lt;&quot;  &quot; &lt;&lt; p.l &lt;&lt; &#39;#&#39;;\n            &#x2F;&#x2F; if(p.plink !&#x3D; nullptr)\n            &#x2F;&#x2F;     cout &lt;&lt; p.x &lt;&lt; (p.plink)-&gt;x &lt;&lt; endl;\n            &#x2F;&#x2F; cout &lt;&lt; (p.plink &#x3D;&#x3D; &amp;p) &lt;&lt; endl;  &#x2F;&#x2F; bugs: p.plink &#x3D;&#x3D; &amp;p\n            &#x2F;&#x2F;search the final points.\n            if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue;\n            if(wordList[p-&gt;x] &#x3D;&#x3D; endWord)&#123;\n                endlevel &#x3D; p-&gt;l;\n                vector&lt;string&gt; tmp;\n                SN* np &#x3D; p;\n                while(np  !&#x3D; nullptr)&#123;\n                    tmp.push_back(wordList[np-&gt;x]);\n                    np &#x3D; np-&gt;plink;      \n                    &#x2F;&#x2F; cout &lt;&lt; np-&gt;x &lt;&lt; &quot; &quot;;              \n                &#125;\n                &#x2F;&#x2F; cout &lt;&lt; endl;\n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            &#125;\n            \n            \n            &#x2F;&#x2F; emplace more points.\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(islink(wordList[j], wordList[p-&gt;x]))&#123;                    \n                    SN* newp &#x3D; new SN(j, p-&gt;x, p-&gt;l + 1, p); &#x2F;&#x2F;bugs: 这里取的地址是变量p的地址，同时地址指向不变，但是p指向的内容会受暂存变量p赋值而变化。 这可是C++基础啊\n                    &#x2F;&#x2F;解决方法： 给每个变量一个新的地址即可\n                    &#x2F;&#x2F; cout &lt;&lt; (&amp;newp &#x3D;&#x3D; &amp;p) &lt;&lt; endl;\n                    que.push(newp);\n                &#125;\n            &#125;\n        &#125;\n\n        return ans;\n    &#125;\n\n    bool islink(const string &amp;a, const string  &amp;b)&#123;\n        int len &#x3D; a.size(), t &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; len; ++i)&#123;\n            if(a[i] !&#x3D; b[i]) t++;\n            if(t &gt; 1) return false;\n        &#125;\n        if(t &#x3D;&#x3D; 0) return false;\n        return true;\n    &#125;\n    class SN&#123;\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink)&#123;&#125;\n    &#125;;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>AC</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;&#x2F;图优化版本\n&#x2F;&#x2F; 执行用时：\n&#x2F;&#x2F; 644 ms\n&#x2F;&#x2F; , 在所有 C++ 提交中击败了\n&#x2F;&#x2F; 61.99%\n&#x2F;&#x2F; 的用户\n&#x2F;&#x2F; 内存消耗：\n&#x2F;&#x2F; 19.1 MB\n&#x2F;&#x2F; , 在所有 C++ 提交中击败了\n&#x2F;&#x2F; 66.81%\n&#x2F;&#x2F; 的用户\nclass Solution &#123;\npublic:\n\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        \n        vector&lt;vector&lt;string&gt;&gt; ans;\n        \n        int n &#x3D; wordList.size(), flag &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(wordList[i] &#x3D;&#x3D; endWord) flag &#x3D; 1;\n        &#125;\n        if(!flag) return ans;\n\n\n        &#x2F;&#x2F;bulid the map.\n        wordList.push_back(beginWord); &#x2F;&#x2F; size++\n        n++;\n        vector&lt;vector&lt;int&gt;&gt; edges;\n        edges.resize(n + 1);\n\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; i + 1; j &lt; n; ++j)&#123;\n                if(islink(wordList[i], wordList[j]))&#123;\n                    edges[i].push_back(j);\n                    edges[j].push_back(i);\n                &#125;\n            &#125;\n        &#125;\n        \n        vector&lt;int&gt;  cost(n, n + 1);\n        cost[n - 1] &#x3D; 0;\n\n        &#x2F;&#x2F;bfs\n        queue&lt;SN*&gt; que;        \n        que.push(new SN(n - 1, -1, 0, nullptr));\n        int endlevel &#x3D; -1;\n        while(que.size())&#123;\n            SN *p &#x3D; que.front(); \n            que.pop();\n\n            if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue;\n            if(wordList[p-&gt;x] &#x3D;&#x3D; endWord)&#123;\n                endlevel &#x3D; p-&gt;l;\n                vector&lt;string&gt; tmp;\n                SN* np &#x3D; p;\n                while(np  !&#x3D; nullptr)&#123;\n                    tmp.push_back(wordList[np-&gt;x]);\n                    np &#x3D; np-&gt;plink;                          \n                &#125;                \n                reverse(tmp.begin(), tmp.end());\n                ans.push_back(tmp);\n            &#125;\n                        \n            &#x2F;&#x2F; emplace more points.\n            for(auto j : edges[p-&gt;x])&#123;            \n                if(cost[j] &gt; cost[p-&gt;x])&#123; &#x2F;&#x2F; 没法绕一个圈子找到最短路\n                    cost[j] &#x3D; cost[p-&gt;x] + 1;\n                    SN* newp &#x3D; new SN(j, p-&gt;x, p-&gt;l + 1, p);\n                    que.push(newp);\n                &#125;\n                \n            &#125;\n        &#125;\n\n        return ans;\n    &#125;\n\n    bool islink(const string &amp;a, const string  &amp;b)&#123;\n        int len &#x3D; a.size(), t &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; len; ++i)&#123;\n            if(a[i] !&#x3D; b[i]) t++;\n            if(t &gt; 1) return false;\n        &#125;\n        if(t &#x3D;&#x3D; 0) return false;\n        return true;\n    &#125;\n    class SN&#123;\n    public:\n        int  x;\n        int px;\n        int l;\n        SN * plink;\n        SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink)&#123;&#125; &#x2F;&#x2F;由于历史原因，px和l有点多余\n    &#125;;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>双向bfs思路学习；（未完成）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123;\n        vector&lt;vector&lt;string&gt;&gt; path;\n        unordered_set&lt;string&gt; dict ,q1, q2; &#x2F;&#x2F;dict：搜索空间 q1q2:双头搜索\n        unordered_map&lt;string, vector&lt;string&gt;&gt; next;\n        for(const auto &amp;p : wordList)&#123;\n            dict.insert(p);\n        &#125;\n        if(!dict.count(endWord))\n            return path;\n\n        dict.erase(beginWord);\n        dict.erase(endWord);\n\n        q1.insert(beginWord);\n        q2.insert(endWord);\n        bool reverse &#x3D; false, found &#x3D; false;\n        while(!q1.empty())&#123;\n            unordered_set&lt;string&gt; q;\n            for(const auto &amp;w : q1)&#123;\n                string cw &#x3D; w;\n                for(size_t i &#x3D; 0 ; i &lt; cw.size(); ++i)&#123;\n                    char c &#x3D; cw[i];\n                    for(int j &#x3D; 0; j &lt; 26; ++j)&#123;\n                        cw[i] &#x3D; j + &#39;a&#39;;\n                        if(q2.count(cw))&#123;\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            found &#x3D; true;\n                        &#125;\n                        if(dict.count(cw))&#123; &#x2F;&#x2F;count 比 find好用\n                            reverse ? next[cw].push_back(w) : next[w].push_back(cw);\n                            q.insert(cw);\n                        &#125;\n                    &#125;\n                    cw[i] &#x3D; c;\n                &#125;\n            &#125;\n            &#x2F;&#x2F; for(const auto &amp;w :q)\n            &#x2F;&#x2F;     cout &lt;&lt; w &lt;&lt; &quot; &quot;;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n            &#x2F;&#x2F;控制搜索层数            \n            if(found)  break;\n            for(const auto &amp;w : q)&#123;\n                dict.erase(w);\n            &#125;\n            &#x2F;&#x2F;选择扩展范围小的开始搜索，降低搜索数量\n            if(q.size() &lt; q2.size())&#123;\n                q1 &#x3D; q;\n            &#125;else&#123;\n                reverse &#x3D; !reverse;\n                q1 &#x3D; q2;\n                q2 &#x3D; q;\n            &#125;\n\n        &#125;\n\n        vector&lt;string&gt; oneway &#x3D; &#123;beginWord&#125;;\n        buildPath(next, path, oneway, beginWord, endWord);\n        return path;\n        \n    &#125;\n    \n    void buildPath(unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; next, vector&lt;vector&lt;string&gt;&gt;&amp; path, \n                 vector&lt;string&gt; &amp;oneway, string nword, string endWord)&#123;\n        if(nword &#x3D;&#x3D; endWord)&#123;            \n            path.push_back(oneway);\n            return;        \n        &#125;\n        for(const auto &amp;w : next[nword])&#123;\n            oneway.push_back(w);\n            buildPath(next, path, oneway, w, endWord);\n            oneway.pop_back();\n        &#125;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"22. Generate Parentheses","thumbnail":"http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png","toc":true,"top":10,"date":"2021-04-25T23:41:25.000Z","_content":"\n\n\n\n\n\n\n## 思路：\n\n正确的迭代方式是，从左到右的遍历中，每一个正确序列都有左括号的数量大于等于右括号的数量。而每一处符号要么是左括号，要么是右括号，后者符号都有选择的生成即可。\n\n如何便可以递归生成所有符合题意的括号。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    vector<string> ans;\n    set<string> sset;\npublic:\n    vector<string> generateParenthesis(int n) { \n        generateParenthesisCore(0, 0, n, \"\");\n        for(string s : sset) ans.push_back(s);\n        return ans;\n    }\n    void generateParenthesisCore(int left, int right, int n, string str){\n        if(left == n){\n            ans.push_back(str + string((n - right), ')'));\n            return;\n        }\n\n        generateParenthesisCore(left + 1, right, n, str + \"(\");\n        if(left > right){\n            generateParenthesisCore(left, right + 1, n, str + \")\");\n        }\n        \n    }\n};\n```\n\n","source":"_posts/刷题/搜索/bfs\n/22-Generate-Parentheses.md","raw":"---\ntitle: 22. Generate Parentheses\nthumbnail: 'http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png'\ntoc: true\ntop: 10\ndate: 2021-04-26 07:41:25\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n## 思路：\n\n正确的迭代方式是，从左到右的遍历中，每一个正确序列都有左括号的数量大于等于右括号的数量。而每一处符号要么是左括号，要么是右括号，后者符号都有选择的生成即可。\n\n如何便可以递归生成所有符合题意的括号。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    vector<string> ans;\n    set<string> sset;\npublic:\n    vector<string> generateParenthesis(int n) { \n        generateParenthesisCore(0, 0, n, \"\");\n        for(string s : sset) ans.push_back(s);\n        return ans;\n    }\n    void generateParenthesisCore(int left, int right, int n, string str){\n        if(left == n){\n            ans.push_back(str + string((n - right), ')'));\n            return;\n        }\n\n        generateParenthesisCore(left + 1, right, n, str + \"(\");\n        if(left > right){\n            generateParenthesisCore(left, right + 1, n, str + \")\");\n        }\n        \n    }\n};\n```\n\n","slug":"刷题-搜索-bfs-22-Generate-Parentheses","published":1,"updated":"2021-04-26T00:38:09.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j62003yl5uohki44k94","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>正确的迭代方式是，从左到右的遍历中，每一个正确序列都有左括号的数量大于等于右括号的数量。而每一处符号要么是左括号，要么是右括号，后者符号都有选择的生成即可。</p>\n<p>如何便可以递归生成所有符合题意的括号。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;string&gt; ans;\n    set&lt;string&gt; sset;\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) &#123; \n        generateParenthesisCore(0, 0, n, &quot;&quot;);\n        for(string s : sset) ans.push_back(s);\n        return ans;\n    &#125;\n    void generateParenthesisCore(int left, int right, int n, string str)&#123;\n        if(left &#x3D;&#x3D; n)&#123;\n            ans.push_back(str + string((n - right), &#39;)&#39;));\n            return;\n        &#125;\n\n        generateParenthesisCore(left + 1, right, n, str + &quot;(&quot;);\n        if(left &gt; right)&#123;\n            generateParenthesisCore(left, right + 1, n, str + &quot;)&quot;);\n        &#125;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"5YTFJN","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>正确的迭代方式是，从左到右的遍历中，每一个正确序列都有左括号的数量大于等于右括号的数量。而每一处符号要么是左括号，要么是右括号，后者符号都有选择的生成即可。</p>\n<p>如何便可以递归生成所有符合题意的括号。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    vector&lt;string&gt; ans;\n    set&lt;string&gt; sset;\npublic:\n    vector&lt;string&gt; generateParenthesis(int n) &#123; \n        generateParenthesisCore(0, 0, n, &quot;&quot;);\n        for(string s : sset) ans.push_back(s);\n        return ans;\n    &#125;\n    void generateParenthesisCore(int left, int right, int n, string str)&#123;\n        if(left &#x3D;&#x3D; n)&#123;\n            ans.push_back(str + string((n - right), &#39;)&#39;));\n            return;\n        &#125;\n\n        generateParenthesisCore(left + 1, right, n, str + &quot;(&quot;);\n        if(left &gt; right)&#123;\n            generateParenthesisCore(left, right + 1, n, str + &quot;)&quot;);\n        &#125;\n        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"130. Surrounded Regions","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-01T00:23:07.000Z","_content":"\n\n\n\n\n## [130. Surrounded Regions](https://leetcode-cn.com/problems/surrounded-regions/)\n\n\n\n## 思路：\n\n如果用普通dfs搜索所有区域是速度有点慢的。\n\n但只是反过来思考，如果只所搜索所有不被包围的`O`并标记，同时翻转所有剩下的`X`，最后把所有的P翻转回来是不是会更快。\n\n> 不搞特例的话，一般都是后者快。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n\n    int n, m;\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n\n    void fill(vector<vector<char>>& board, vector<vector<bool>>& vis,vector<pair<int, int>> &path, \n                int &isea, int x , int y){\n        // cout << x << ' ' << y << endl;\n        vis[x][y] = 1;\n        path.push_back(make_pair(x, y));\n\n        for(int i = 0; i < 4; ++i){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || ny < 0 || nx >= n || ny >= m){\n                isea = 1;\n                continue;\n            }                \n            if(!vis[nx][ny] && board[nx][ny] == 'O'){\n                fill(board, vis, path, isea, nx, ny);\n            }                        \n        }\n    }\n\n    void solve(vector<vector<char>>& board) {\n        n = board.size();\n        if(n == 0) return;\n        m = board[0].size();\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\n        \n        for(int i = 0; i < n; ++i){\n            for(int j = 0;j < m; ++j){                \n                if(!vis[i][j] && board[i][j] == 'O'){\n                    vector<pair<int, int>> path;\n                    int isea = 0;\n                    fill(board, vis, path, isea, i, j);\n                    if(isea) continue; // bugs: forgets to clear path\n                    for(auto p : path){\n                        board[p.first][p.second] = 'X';                        \n                    }\n                    \n                }\n            }\n        }    \n    }\n};\n```\n\n\n\n\n\n16ms范例\n\n\n\n```C++\nclass Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        // 给出一个二维数组，找到被 x 包围的 o，然后将其转换为x\n        // dfs\n        if(board.empty())\n            return;\n        int m = board.size(), n = board[0].size();\n        if (m == 1 || n == 1)\n            return ;\n        // 反过来思考，只改变和边界直接相连的元素\n        // 首先检查第一行和最后一行的 O\n        for(int i = 0;i<m;i+=m-1)\n            for(int j = 0;j<n;j++)\n                if(board[i][j] == 'O')\n                    dfs(board,i,j,m,n);\n        // 再检查第一列和最后一列的 O\n        for(int j = 0;j<n;j+=n-1)\n            for(int i = 0;i<m;i++)\n                if(board[i][j] == 'O')\n                    dfs(board,i,j,m,n);\n        // 将 board 中的 O 改为 X\n        // 再将 board 中的 P 改为 O\n        for (auto &i:board)\n            replace(i.begin(),i.end(),'O','X');\n        for (auto &i:board)\n            replace(i.begin(),i.end(),'P','O');\n    }\n\n    void dfs(vector<vector<char>>&board,int i, int j,int m, int n)\n    {\n        if(i>=0 && i<m && j>=0 && j<n && board[i][j] == 'O')\n        {\n            board[i][j] = 'P';\n            dfs(board,i+1,j,m,n);\n            dfs(board,i,j+1,m,n);\n            dfs(board,i-1,j,m,n);\n            dfs(board,i,j-1,m,n);\n        }\n    }\n\n};\n```","source":"_posts/刷题/搜索/dfs\n/130-Surrounded-Regions.md","raw":"---\ntitle: 130. Surrounded Regions\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-01 08:23:07\n---\n\n\n\n\n\n## [130. Surrounded Regions](https://leetcode-cn.com/problems/surrounded-regions/)\n\n\n\n## 思路：\n\n如果用普通dfs搜索所有区域是速度有点慢的。\n\n但只是反过来思考，如果只所搜索所有不被包围的`O`并标记，同时翻转所有剩下的`X`，最后把所有的P翻转回来是不是会更快。\n\n> 不搞特例的话，一般都是后者快。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n\n    int n, m;\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n\n    void fill(vector<vector<char>>& board, vector<vector<bool>>& vis,vector<pair<int, int>> &path, \n                int &isea, int x , int y){\n        // cout << x << ' ' << y << endl;\n        vis[x][y] = 1;\n        path.push_back(make_pair(x, y));\n\n        for(int i = 0; i < 4; ++i){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < 0 || ny < 0 || nx >= n || ny >= m){\n                isea = 1;\n                continue;\n            }                \n            if(!vis[nx][ny] && board[nx][ny] == 'O'){\n                fill(board, vis, path, isea, nx, ny);\n            }                        \n        }\n    }\n\n    void solve(vector<vector<char>>& board) {\n        n = board.size();\n        if(n == 0) return;\n        m = board[0].size();\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\n        \n        for(int i = 0; i < n; ++i){\n            for(int j = 0;j < m; ++j){                \n                if(!vis[i][j] && board[i][j] == 'O'){\n                    vector<pair<int, int>> path;\n                    int isea = 0;\n                    fill(board, vis, path, isea, i, j);\n                    if(isea) continue; // bugs: forgets to clear path\n                    for(auto p : path){\n                        board[p.first][p.second] = 'X';                        \n                    }\n                    \n                }\n            }\n        }    \n    }\n};\n```\n\n\n\n\n\n16ms范例\n\n\n\n```C++\nclass Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        // 给出一个二维数组，找到被 x 包围的 o，然后将其转换为x\n        // dfs\n        if(board.empty())\n            return;\n        int m = board.size(), n = board[0].size();\n        if (m == 1 || n == 1)\n            return ;\n        // 反过来思考，只改变和边界直接相连的元素\n        // 首先检查第一行和最后一行的 O\n        for(int i = 0;i<m;i+=m-1)\n            for(int j = 0;j<n;j++)\n                if(board[i][j] == 'O')\n                    dfs(board,i,j,m,n);\n        // 再检查第一列和最后一列的 O\n        for(int j = 0;j<n;j+=n-1)\n            for(int i = 0;i<m;i++)\n                if(board[i][j] == 'O')\n                    dfs(board,i,j,m,n);\n        // 将 board 中的 O 改为 X\n        // 再将 board 中的 P 改为 O\n        for (auto &i:board)\n            replace(i.begin(),i.end(),'O','X');\n        for (auto &i:board)\n            replace(i.begin(),i.end(),'P','O');\n    }\n\n    void dfs(vector<vector<char>>&board,int i, int j,int m, int n)\n    {\n        if(i>=0 && i<m && j>=0 && j<n && board[i][j] == 'O')\n        {\n            board[i][j] = 'P';\n            dfs(board,i+1,j,m,n);\n            dfs(board,i,j+1,m,n);\n            dfs(board,i-1,j,m,n);\n            dfs(board,i,j-1,m,n);\n        }\n    }\n\n};\n```","slug":"刷题-搜索-dfs-130-Surrounded-Regions","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j63003zl5uoc5cg5hcj","content":"<h2 id=\"130-Surrounded-Regions\"><a href=\"#130-Surrounded-Regions\" class=\"headerlink\" title=\"130. Surrounded Regions\"></a><a href=\"https://leetcode-cn.com/problems/surrounded-regions/\">130. Surrounded Regions</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>如果用普通dfs搜索所有区域是速度有点慢的。</p>\n<p>但只是反过来思考，如果只所搜索所有不被包围的<code>O</code>并标记，同时翻转所有剩下的<code>X</code>，最后把所有的P翻转回来是不是会更快。</p>\n<blockquote>\n<p>不搞特例的话，一般都是后者快。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int n, m;\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n\n    void fill(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; vis,vector&lt;pair&lt;int, int&gt;&gt; &amp;path, \n                int &amp;isea, int x , int y)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n        vis[x][y] &#x3D; 1;\n        path.push_back(make_pair(x, y));\n\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            int nx &#x3D; x + dx[i];\n            int ny &#x3D; y + dy[i];\n            if(nx &lt; 0 || ny &lt; 0 || nx &gt;&#x3D; n || ny &gt;&#x3D; m)&#123;\n                isea &#x3D; 1;\n                continue;\n            &#125;                \n            if(!vis[nx][ny] &amp;&amp; board[nx][ny] &#x3D;&#x3D; &#39;O&#39;)&#123;\n                fill(board, vis, path, isea, nx, ny);\n            &#125;                        \n        &#125;\n    &#125;\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        n &#x3D; board.size();\n        if(n &#x3D;&#x3D; 0) return;\n        m &#x3D; board[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m, false));\n        \n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0;j &lt; m; ++j)&#123;                \n                if(!vis[i][j] &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;O&#39;)&#123;\n                    vector&lt;pair&lt;int, int&gt;&gt; path;\n                    int isea &#x3D; 0;\n                    fill(board, vis, path, isea, i, j);\n                    if(isea) continue; &#x2F;&#x2F; bugs: forgets to clear path\n                    for(auto p : path)&#123;\n                        board[p.first][p.second] &#x3D; &#39;X&#39;;                        \n                    &#125;\n                    \n                &#125;\n            &#125;\n        &#125;    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>16ms范例</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        &#x2F;&#x2F; 给出一个二维数组，找到被 x 包围的 o，然后将其转换为x\n        &#x2F;&#x2F; dfs\n        if(board.empty())\n            return;\n        int m &#x3D; board.size(), n &#x3D; board[0].size();\n        if (m &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 1)\n            return ;\n        &#x2F;&#x2F; 反过来思考，只改变和边界直接相连的元素\n        &#x2F;&#x2F; 首先检查第一行和最后一行的 O\n        for(int i &#x3D; 0;i&lt;m;i+&#x3D;m-1)\n            for(int j &#x3D; 0;j&lt;n;j++)\n                if(board[i][j] &#x3D;&#x3D; &#39;O&#39;)\n                    dfs(board,i,j,m,n);\n        &#x2F;&#x2F; 再检查第一列和最后一列的 O\n        for(int j &#x3D; 0;j&lt;n;j+&#x3D;n-1)\n            for(int i &#x3D; 0;i&lt;m;i++)\n                if(board[i][j] &#x3D;&#x3D; &#39;O&#39;)\n                    dfs(board,i,j,m,n);\n        &#x2F;&#x2F; 将 board 中的 O 改为 X\n        &#x2F;&#x2F; 再将 board 中的 P 改为 O\n        for (auto &amp;i:board)\n            replace(i.begin(),i.end(),&#39;O&#39;,&#39;X&#39;);\n        for (auto &amp;i:board)\n            replace(i.begin(),i.end(),&#39;P&#39;,&#39;O&#39;);\n    &#125;\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp;board,int i, int j,int m, int n)\n    &#123;\n        if(i&gt;&#x3D;0 &amp;&amp; i&lt;m &amp;&amp; j&gt;&#x3D;0 &amp;&amp; j&lt;n &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;O&#39;)\n        &#123;\n            board[i][j] &#x3D; &#39;P&#39;;\n            dfs(board,i+1,j,m,n);\n            dfs(board,i,j+1,m,n);\n            dfs(board,i-1,j,m,n);\n            dfs(board,i,j-1,m,n);\n        &#125;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1R2P2AQ","excerpt":"<h2 id=\"130-Surrounded-Regions\"><a href=\"#130-Surrounded-Regions\" class=\"headerlink\" title=\"130. Surrounded Regions\"></a><a href=\"https://leetcode-cn.com/problems/surrounded-regions/\">130. Surrounded Regions</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>如果用普通dfs搜索所有区域是速度有点慢的。</p>\n<p>但只是反过来思考，如果只所搜索所有不被包围的<code>O</code>并标记，同时翻转所有剩下的<code>X</code>，最后把所有的P翻转回来是不是会更快。</p>\n<blockquote>\n<p>不搞特例的话，一般都是后者快。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int n, m;\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n\n    void fill(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; vis,vector&lt;pair&lt;int, int&gt;&gt; &amp;path, \n                int &amp;isea, int x , int y)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n        vis[x][y] &#x3D; 1;\n        path.push_back(make_pair(x, y));\n\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            int nx &#x3D; x + dx[i];\n            int ny &#x3D; y + dy[i];\n            if(nx &lt; 0 || ny &lt; 0 || nx &gt;&#x3D; n || ny &gt;&#x3D; m)&#123;\n                isea &#x3D; 1;\n                continue;\n            &#125;                \n            if(!vis[nx][ny] &amp;&amp; board[nx][ny] &#x3D;&#x3D; &#39;O&#39;)&#123;\n                fill(board, vis, path, isea, nx, ny);\n            &#125;                        \n        &#125;\n    &#125;\n\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        n &#x3D; board.size();\n        if(n &#x3D;&#x3D; 0) return;\n        m &#x3D; board[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m, false));\n        \n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0;j &lt; m; ++j)&#123;                \n                if(!vis[i][j] &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;O&#39;)&#123;\n                    vector&lt;pair&lt;int, int&gt;&gt; path;\n                    int isea &#x3D; 0;\n                    fill(board, vis, path, isea, i, j);\n                    if(isea) continue; &#x2F;&#x2F; bugs: forgets to clear path\n                    for(auto p : path)&#123;\n                        board[p.first][p.second] &#x3D; &#39;X&#39;;                        \n                    &#125;\n                    \n                &#125;\n            &#125;\n        &#125;    \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>16ms范例</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        &#x2F;&#x2F; 给出一个二维数组，找到被 x 包围的 o，然后将其转换为x\n        &#x2F;&#x2F; dfs\n        if(board.empty())\n            return;\n        int m &#x3D; board.size(), n &#x3D; board[0].size();\n        if (m &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 1)\n            return ;\n        &#x2F;&#x2F; 反过来思考，只改变和边界直接相连的元素\n        &#x2F;&#x2F; 首先检查第一行和最后一行的 O\n        for(int i &#x3D; 0;i&lt;m;i+&#x3D;m-1)\n            for(int j &#x3D; 0;j&lt;n;j++)\n                if(board[i][j] &#x3D;&#x3D; &#39;O&#39;)\n                    dfs(board,i,j,m,n);\n        &#x2F;&#x2F; 再检查第一列和最后一列的 O\n        for(int j &#x3D; 0;j&lt;n;j+&#x3D;n-1)\n            for(int i &#x3D; 0;i&lt;m;i++)\n                if(board[i][j] &#x3D;&#x3D; &#39;O&#39;)\n                    dfs(board,i,j,m,n);\n        &#x2F;&#x2F; 将 board 中的 O 改为 X\n        &#x2F;&#x2F; 再将 board 中的 P 改为 O\n        for (auto &amp;i:board)\n            replace(i.begin(),i.end(),&#39;O&#39;,&#39;X&#39;);\n        for (auto &amp;i:board)\n            replace(i.begin(),i.end(),&#39;P&#39;,&#39;O&#39;);\n    &#125;\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp;board,int i, int j,int m, int n)\n    &#123;\n        if(i&gt;&#x3D;0 &amp;&amp; i&lt;m &amp;&amp; j&gt;&#x3D;0 &amp;&amp; j&lt;n &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;O&#39;)\n        &#123;\n            board[i][j] &#x3D; &#39;P&#39;;\n            dfs(board,i+1,j,m,n);\n            dfs(board,i,j+1,m,n);\n            dfs(board,i-1,j,m,n);\n            dfs(board,i,j-1,m,n);\n        &#125;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"417. Pacific Atlantic Water Flow","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-24T02:15:40.000Z","_content":"\n## [417. Pacific Atlantic Water Flow](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)\n\n## 思路：\n\n按着题目的意思顺着流向DFS有以下问题。做了正向的代码发现有个DFS依赖问题。\n\n网上大神给出了**[逆流](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/shen-du-sou-suo-dfs-by-jawhiow/)**DFS的思路。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    int m, n;\n    // 顺流dfs搜索得色5re'rs'ze'd [re'rong'ze'dui]\n    // 回流依赖问题： when height[x, y] == height[nx, ny] : \n    // type[x ,y] => type[dx, dy], type[dx ,dy] => type[x, y] , 同时DFS式的遍历方式保证了了每个\n    // 节点只被访问一次，所以存在类型相互依赖关系\n    // 即存在一个鸡生蛋，蛋生鸡的问题。\n    // 解决方法是：没想出来\n    int flow(vector<vector<int>> &matrix, vector<vector<int>> &type,  int x, int y){\n        // cout << x << y << endl;\n        if(x < 0 || y < 0 ) return -1;\n        else if( x >= m || y >= n) return -2;\n\n        if(type[x][y] != 0) return type[x][y];\n        type[x][y] = 4; // the visited point.\n        \n        int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1;\n        for(int i = 0; i < 4; ++i){\n            nx = x + dx[i];\n            ny = y + dy[i];            \n            if( (nx < 0 || ny < 0) || (nx >= m || ny >= n) ||  matrix[nx][ny] <= matrix[x][y]){ //bugs: nx, ny\n                \n                t = flow(matrix, type, nx, ny);                \n                if(t == -1 || t == 1 || t == 3) f1 = 1;\n                if(t == -2 || t == 2 || t == 3) f2 = 1;\n            }\n        }\n        if(f1 & f2) type[x][y] = 3;\n        else if(f1) type[x][y] = 1;\n        else if(f2) type[x][y] = 2;\n        // type[x][y] = f1 & f2; // bugs 1 & 1\n        return type[x][y];\n    }\n\n    int flow2(vector<vector<int>> &matrix, vector<vector<int>> &type,  int x, int y){\n        // cout << x << y << endl;\n        if(x < 0 || y < 0 ) return -1;\n        else if( x >= m || y >= n) return -2;\n\n        int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1;\n        for(int i = 0; i < 4; ++i){\n            nx = x + dx[i];\n            ny = y + dy[i];            \n            if( (nx < 0 || ny < 0) || (nx >= m || ny >= n) ||  matrix[nx][ny] <= matrix[x][y]){ //bugs: nx, ny\n                \n                t = flow(matrix, type, nx, ny);                \n                if(t == -1 || t == 1 || t == 3) f1 = 1;\n                if(t == -2 || t == 2 || t == 3) f2 = 1;\n            }\n        }\n        if(f1 & f2) type[x][y] = 3;\n        else if(f1) type[x][y] = 1;\n        else if(f2) type[x][y] = 2;\n        // type[x][y] = f1 & f2; // bugs 1 & 2 ： 1 | 2\n        return type[x][y];\n    }\n\n    // 题解：逆流写法\n    void reflow(vector<vector<int>> &matrix, vector<vector<int>> &type,  int x, int y, int wtype){\n        type[x][y] = type[x][y] | wtype;\n        int nx, ny;\n        for(int i = 0; i < 4; ++i){\n            nx = x + dx[i];\n            ny = y + dy[i];\n            if(nx >=0 && ny >= 0 && nx < m && ny < n)\n            if(matrix[x][y] <= matrix[nx][ny] && ((type[nx][ny] & wtype) == 0))\n                reflow(matrix, type, nx, ny, wtype);\n        }\n    }\n\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\n        m = matrix.size();\n        if(m == 0) return matrix; //return empty vector;\n        n = matrix[0].size();\n        vector< vector<int>> type(m, vector<int>(n, 0)), ans;   \n\n        for(int i = 0; i < m; ++i){\n            reflow(matrix, type, i, 0, 1);\n            reflow(matrix, type, i, n - 1, 2);\n        }\n        for(int i = 0; i < n; ++i){\n            reflow(matrix, type, 0, i, 1);\n            reflow(matrix, type, m - 1, i, 2);\n        }\n\n                     \n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){       \n                // cout << i << ' ' << j << ' ' << type[i][j] << endl;         \n                if(type[i][j] == 3){\n                    ans.emplace_back( vector<int>({i, j}));  // bugs initialize vector<int> a(n, i)  \n                }\n            }\n        }\n        return ans;\n\n    }\n};\n```","source":"_posts/刷题/搜索/dfs\n/417-Pacific-Atlantic-Water-Flow.md","raw":"---\ntitle: 417. Pacific Atlantic Water Flow\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-24 10:15:40\n---\n\n## [417. Pacific Atlantic Water Flow](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)\n\n## 思路：\n\n按着题目的意思顺着流向DFS有以下问题。做了正向的代码发现有个DFS依赖问题。\n\n网上大神给出了**[逆流](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/shen-du-sou-suo-dfs-by-jawhiow/)**DFS的思路。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, -1, 1};\n    int m, n;\n    // 顺流dfs搜索得色5re'rs'ze'd [re'rong'ze'dui]\n    // 回流依赖问题： when height[x, y] == height[nx, ny] : \n    // type[x ,y] => type[dx, dy], type[dx ,dy] => type[x, y] , 同时DFS式的遍历方式保证了了每个\n    // 节点只被访问一次，所以存在类型相互依赖关系\n    // 即存在一个鸡生蛋，蛋生鸡的问题。\n    // 解决方法是：没想出来\n    int flow(vector<vector<int>> &matrix, vector<vector<int>> &type,  int x, int y){\n        // cout << x << y << endl;\n        if(x < 0 || y < 0 ) return -1;\n        else if( x >= m || y >= n) return -2;\n\n        if(type[x][y] != 0) return type[x][y];\n        type[x][y] = 4; // the visited point.\n        \n        int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1;\n        for(int i = 0; i < 4; ++i){\n            nx = x + dx[i];\n            ny = y + dy[i];            \n            if( (nx < 0 || ny < 0) || (nx >= m || ny >= n) ||  matrix[nx][ny] <= matrix[x][y]){ //bugs: nx, ny\n                \n                t = flow(matrix, type, nx, ny);                \n                if(t == -1 || t == 1 || t == 3) f1 = 1;\n                if(t == -2 || t == 2 || t == 3) f2 = 1;\n            }\n        }\n        if(f1 & f2) type[x][y] = 3;\n        else if(f1) type[x][y] = 1;\n        else if(f2) type[x][y] = 2;\n        // type[x][y] = f1 & f2; // bugs 1 & 1\n        return type[x][y];\n    }\n\n    int flow2(vector<vector<int>> &matrix, vector<vector<int>> &type,  int x, int y){\n        // cout << x << y << endl;\n        if(x < 0 || y < 0 ) return -1;\n        else if( x >= m || y >= n) return -2;\n\n        int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1;\n        for(int i = 0; i < 4; ++i){\n            nx = x + dx[i];\n            ny = y + dy[i];            \n            if( (nx < 0 || ny < 0) || (nx >= m || ny >= n) ||  matrix[nx][ny] <= matrix[x][y]){ //bugs: nx, ny\n                \n                t = flow(matrix, type, nx, ny);                \n                if(t == -1 || t == 1 || t == 3) f1 = 1;\n                if(t == -2 || t == 2 || t == 3) f2 = 1;\n            }\n        }\n        if(f1 & f2) type[x][y] = 3;\n        else if(f1) type[x][y] = 1;\n        else if(f2) type[x][y] = 2;\n        // type[x][y] = f1 & f2; // bugs 1 & 2 ： 1 | 2\n        return type[x][y];\n    }\n\n    // 题解：逆流写法\n    void reflow(vector<vector<int>> &matrix, vector<vector<int>> &type,  int x, int y, int wtype){\n        type[x][y] = type[x][y] | wtype;\n        int nx, ny;\n        for(int i = 0; i < 4; ++i){\n            nx = x + dx[i];\n            ny = y + dy[i];\n            if(nx >=0 && ny >= 0 && nx < m && ny < n)\n            if(matrix[x][y] <= matrix[nx][ny] && ((type[nx][ny] & wtype) == 0))\n                reflow(matrix, type, nx, ny, wtype);\n        }\n    }\n\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\n        m = matrix.size();\n        if(m == 0) return matrix; //return empty vector;\n        n = matrix[0].size();\n        vector< vector<int>> type(m, vector<int>(n, 0)), ans;   \n\n        for(int i = 0; i < m; ++i){\n            reflow(matrix, type, i, 0, 1);\n            reflow(matrix, type, i, n - 1, 2);\n        }\n        for(int i = 0; i < n; ++i){\n            reflow(matrix, type, 0, i, 1);\n            reflow(matrix, type, m - 1, i, 2);\n        }\n\n                     \n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){       \n                // cout << i << ' ' << j << ' ' << type[i][j] << endl;         \n                if(type[i][j] == 3){\n                    ans.emplace_back( vector<int>({i, j}));  // bugs initialize vector<int> a(n, i)  \n                }\n            }\n        }\n        return ans;\n\n    }\n};\n```","slug":"刷题-搜索-dfs-417-Pacific-Atlantic-Water-Flow","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j640040l5uohow9agg9","content":"<h2 id=\"417-Pacific-Atlantic-Water-Flow\"><a href=\"#417-Pacific-Atlantic-Water-Flow\" class=\"headerlink\" title=\"417. Pacific Atlantic Water Flow\"></a><a href=\"https://leetcode-cn.com/problems/pacific-atlantic-water-flow/\">417. Pacific Atlantic Water Flow</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>按着题目的意思顺着流向DFS有以下问题。做了正向的代码发现有个DFS依赖问题。</p>\n<p>网上大神给出了**<a href=\"https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/shen-du-sou-suo-dfs-by-jawhiow/\">逆流</a>**DFS的思路。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    int m, n;\n    &#x2F;&#x2F; 顺流dfs搜索得色5re&#39;rs&#39;ze&#39;d [re&#39;rong&#39;ze&#39;dui]\n    &#x2F;&#x2F; 回流依赖问题： when height[x, y] &#x3D;&#x3D; height[nx, ny] : \n    &#x2F;&#x2F; type[x ,y] &#x3D;&gt; type[dx, dy], type[dx ,dy] &#x3D;&gt; type[x, y] , 同时DFS式的遍历方式保证了了每个\n    &#x2F;&#x2F; 节点只被访问一次，所以存在类型相互依赖关系\n    &#x2F;&#x2F; 即存在一个鸡生蛋，蛋生鸡的问题。\n    &#x2F;&#x2F; 解决方法是：没想出来\n    int flow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type,  int x, int y)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;\n        if(x &lt; 0 || y &lt; 0 ) return -1;\n        else if( x &gt;&#x3D; m || y &gt;&#x3D; n) return -2;\n\n        if(type[x][y] !&#x3D; 0) return type[x][y];\n        type[x][y] &#x3D; 4; &#x2F;&#x2F; the visited point.\n        \n        int nx, ny, f1 &#x3D; 0, f2 &#x3D; 0, t &#x3D; 0; &#x2F;&#x2F;bugs: initailization: flag &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            nx &#x3D; x + dx[i];\n            ny &#x3D; y + dy[i];            \n            if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;&#x3D; m || ny &gt;&#x3D; n) ||  matrix[nx][ny] &lt;&#x3D; matrix[x][y])&#123; &#x2F;&#x2F;bugs: nx, ny\n                \n                t &#x3D; flow(matrix, type, nx, ny);                \n                if(t &#x3D;&#x3D; -1 || t &#x3D;&#x3D; 1 || t &#x3D;&#x3D; 3) f1 &#x3D; 1;\n                if(t &#x3D;&#x3D; -2 || t &#x3D;&#x3D; 2 || t &#x3D;&#x3D; 3) f2 &#x3D; 1;\n            &#125;\n        &#125;\n        if(f1 &amp; f2) type[x][y] &#x3D; 3;\n        else if(f1) type[x][y] &#x3D; 1;\n        else if(f2) type[x][y] &#x3D; 2;\n        &#x2F;&#x2F; type[x][y] &#x3D; f1 &amp; f2; &#x2F;&#x2F; bugs 1 &amp; 1\n        return type[x][y];\n    &#125;\n\n    int flow2(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type,  int x, int y)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;\n        if(x &lt; 0 || y &lt; 0 ) return -1;\n        else if( x &gt;&#x3D; m || y &gt;&#x3D; n) return -2;\n\n        int nx, ny, f1 &#x3D; 0, f2 &#x3D; 0, t &#x3D; 0; &#x2F;&#x2F;bugs: initailization: flag &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            nx &#x3D; x + dx[i];\n            ny &#x3D; y + dy[i];            \n            if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;&#x3D; m || ny &gt;&#x3D; n) ||  matrix[nx][ny] &lt;&#x3D; matrix[x][y])&#123; &#x2F;&#x2F;bugs: nx, ny\n                \n                t &#x3D; flow(matrix, type, nx, ny);                \n                if(t &#x3D;&#x3D; -1 || t &#x3D;&#x3D; 1 || t &#x3D;&#x3D; 3) f1 &#x3D; 1;\n                if(t &#x3D;&#x3D; -2 || t &#x3D;&#x3D; 2 || t &#x3D;&#x3D; 3) f2 &#x3D; 1;\n            &#125;\n        &#125;\n        if(f1 &amp; f2) type[x][y] &#x3D; 3;\n        else if(f1) type[x][y] &#x3D; 1;\n        else if(f2) type[x][y] &#x3D; 2;\n        &#x2F;&#x2F; type[x][y] &#x3D; f1 &amp; f2; &#x2F;&#x2F; bugs 1 &amp; 2 ： 1 | 2\n        return type[x][y];\n    &#125;\n\n    &#x2F;&#x2F; 题解：逆流写法\n    void reflow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type,  int x, int y, int wtype)&#123;\n        type[x][y] &#x3D; type[x][y] | wtype;\n        int nx, ny;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            nx &#x3D; x + dx[i];\n            ny &#x3D; y + dy[i];\n            if(nx &gt;&#x3D;0 &amp;&amp; ny &gt;&#x3D; 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n)\n            if(matrix[x][y] &lt;&#x3D; matrix[nx][ny] &amp;&amp; ((type[nx][ny] &amp; wtype) &#x3D;&#x3D; 0))\n                reflow(matrix, type, nx, ny, wtype);\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        m &#x3D; matrix.size();\n        if(m &#x3D;&#x3D; 0) return matrix; &#x2F;&#x2F;return empty vector;\n        n &#x3D; matrix[0].size();\n        vector&lt; vector&lt;int&gt;&gt; type(m, vector&lt;int&gt;(n, 0)), ans;   \n\n        for(int i &#x3D; 0; i &lt; m; ++i)&#123;\n            reflow(matrix, type, i, 0, 1);\n            reflow(matrix, type, i, n - 1, 2);\n        &#125;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            reflow(matrix, type, 0, i, 1);\n            reflow(matrix, type, m - 1, i, 2);\n        &#125;\n\n                     \n        for(int i &#x3D; 0; i &lt; m; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;       \n                &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; type[i][j] &lt;&lt; endl;         \n                if(type[i][j] &#x3D;&#x3D; 3)&#123;\n                    ans.emplace_back( vector&lt;int&gt;(&#123;i, j&#125;));  &#x2F;&#x2F; bugs initialize vector&lt;int&gt; a(n, i)  \n                &#125;\n            &#125;\n        &#125;\n        return ans;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"H8HZG4","excerpt":"<h2 id=\"417-Pacific-Atlantic-Water-Flow\"><a href=\"#417-Pacific-Atlantic-Water-Flow\" class=\"headerlink\" title=\"417. Pacific Atlantic Water Flow\"></a><a href=\"https://leetcode-cn.com/problems/pacific-atlantic-water-flow/\">417. Pacific Atlantic Water Flow</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>按着题目的意思顺着流向DFS有以下问题。做了正向的代码发现有个DFS依赖问题。</p>\n<p>网上大神给出了**<a href=\"https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/shen-du-sou-suo-dfs-by-jawhiow/\">逆流</a>**DFS的思路。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    int m, n;\n    &#x2F;&#x2F; 顺流dfs搜索得色5re&#39;rs&#39;ze&#39;d [re&#39;rong&#39;ze&#39;dui]\n    &#x2F;&#x2F; 回流依赖问题： when height[x, y] &#x3D;&#x3D; height[nx, ny] : \n    &#x2F;&#x2F; type[x ,y] &#x3D;&gt; type[dx, dy], type[dx ,dy] &#x3D;&gt; type[x, y] , 同时DFS式的遍历方式保证了了每个\n    &#x2F;&#x2F; 节点只被访问一次，所以存在类型相互依赖关系\n    &#x2F;&#x2F; 即存在一个鸡生蛋，蛋生鸡的问题。\n    &#x2F;&#x2F; 解决方法是：没想出来\n    int flow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type,  int x, int y)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;\n        if(x &lt; 0 || y &lt; 0 ) return -1;\n        else if( x &gt;&#x3D; m || y &gt;&#x3D; n) return -2;\n\n        if(type[x][y] !&#x3D; 0) return type[x][y];\n        type[x][y] &#x3D; 4; &#x2F;&#x2F; the visited point.\n        \n        int nx, ny, f1 &#x3D; 0, f2 &#x3D; 0, t &#x3D; 0; &#x2F;&#x2F;bugs: initailization: flag &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            nx &#x3D; x + dx[i];\n            ny &#x3D; y + dy[i];            \n            if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;&#x3D; m || ny &gt;&#x3D; n) ||  matrix[nx][ny] &lt;&#x3D; matrix[x][y])&#123; &#x2F;&#x2F;bugs: nx, ny\n                \n                t &#x3D; flow(matrix, type, nx, ny);                \n                if(t &#x3D;&#x3D; -1 || t &#x3D;&#x3D; 1 || t &#x3D;&#x3D; 3) f1 &#x3D; 1;\n                if(t &#x3D;&#x3D; -2 || t &#x3D;&#x3D; 2 || t &#x3D;&#x3D; 3) f2 &#x3D; 1;\n            &#125;\n        &#125;\n        if(f1 &amp; f2) type[x][y] &#x3D; 3;\n        else if(f1) type[x][y] &#x3D; 1;\n        else if(f2) type[x][y] &#x3D; 2;\n        &#x2F;&#x2F; type[x][y] &#x3D; f1 &amp; f2; &#x2F;&#x2F; bugs 1 &amp; 1\n        return type[x][y];\n    &#125;\n\n    int flow2(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type,  int x, int y)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;\n        if(x &lt; 0 || y &lt; 0 ) return -1;\n        else if( x &gt;&#x3D; m || y &gt;&#x3D; n) return -2;\n\n        int nx, ny, f1 &#x3D; 0, f2 &#x3D; 0, t &#x3D; 0; &#x2F;&#x2F;bugs: initailization: flag &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            nx &#x3D; x + dx[i];\n            ny &#x3D; y + dy[i];            \n            if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;&#x3D; m || ny &gt;&#x3D; n) ||  matrix[nx][ny] &lt;&#x3D; matrix[x][y])&#123; &#x2F;&#x2F;bugs: nx, ny\n                \n                t &#x3D; flow(matrix, type, nx, ny);                \n                if(t &#x3D;&#x3D; -1 || t &#x3D;&#x3D; 1 || t &#x3D;&#x3D; 3) f1 &#x3D; 1;\n                if(t &#x3D;&#x3D; -2 || t &#x3D;&#x3D; 2 || t &#x3D;&#x3D; 3) f2 &#x3D; 1;\n            &#125;\n        &#125;\n        if(f1 &amp; f2) type[x][y] &#x3D; 3;\n        else if(f1) type[x][y] &#x3D; 1;\n        else if(f2) type[x][y] &#x3D; 2;\n        &#x2F;&#x2F; type[x][y] &#x3D; f1 &amp; f2; &#x2F;&#x2F; bugs 1 &amp; 2 ： 1 | 2\n        return type[x][y];\n    &#125;\n\n    &#x2F;&#x2F; 题解：逆流写法\n    void reflow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type,  int x, int y, int wtype)&#123;\n        type[x][y] &#x3D; type[x][y] | wtype;\n        int nx, ny;\n        for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n            nx &#x3D; x + dx[i];\n            ny &#x3D; y + dy[i];\n            if(nx &gt;&#x3D;0 &amp;&amp; ny &gt;&#x3D; 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n)\n            if(matrix[x][y] &lt;&#x3D; matrix[nx][ny] &amp;&amp; ((type[nx][ny] &amp; wtype) &#x3D;&#x3D; 0))\n                reflow(matrix, type, nx, ny, wtype);\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        m &#x3D; matrix.size();\n        if(m &#x3D;&#x3D; 0) return matrix; &#x2F;&#x2F;return empty vector;\n        n &#x3D; matrix[0].size();\n        vector&lt; vector&lt;int&gt;&gt; type(m, vector&lt;int&gt;(n, 0)), ans;   \n\n        for(int i &#x3D; 0; i &lt; m; ++i)&#123;\n            reflow(matrix, type, i, 0, 1);\n            reflow(matrix, type, i, n - 1, 2);\n        &#125;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            reflow(matrix, type, 0, i, 1);\n            reflow(matrix, type, m - 1, i, 2);\n        &#125;\n\n                     \n        for(int i &#x3D; 0; i &lt; m; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;       \n                &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; type[i][j] &lt;&lt; endl;         \n                if(type[i][j] &#x3D;&#x3D; 3)&#123;\n                    ans.emplace_back( vector&lt;int&gt;(&#123;i, j&#125;));  &#x2F;&#x2F; bugs initialize vector&lt;int&gt; a(n, i)  \n                &#125;\n            &#125;\n        &#125;\n        return ans;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"547. Friend Circles","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-22T01:45:38.000Z","_content":"\n\n\n\n## [547. Friend Circles](https://leetcode-cn.com/problems/friend-circles/)\n\n## 思路：\n\ndfs搜索人头就行。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int n;\n\n    void colorize(vector<vector<int>>& M, vector<int>& vis,int x){\n        vis[x] = 1;\n        for(int i = 0; i < n; ++i){            \n            if(!vis[i] && M[x][i]){                \n                colorize(M, vis, i); \n            }             \n        }\n    }\n    int findCircleNum(vector<vector<int>>& M) {\n        n = M.size();\n        vector<int> vis(n, 0);\n        int ct = 0;\n        for(int i = 0; i < n; ++i){\n            if(!vis[i]){\n                ct++;\n                colorize(M, vis, i);\n            }            \n        }\n        return ct;\n    }\n};\n```","source":"_posts/刷题/搜索/dfs\n/547-Friend-Circles.md","raw":"---\ntitle: 547. Friend Circles\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-22 09:45:38\n---\n\n\n\n\n## [547. Friend Circles](https://leetcode-cn.com/problems/friend-circles/)\n\n## 思路：\n\ndfs搜索人头就行。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int n;\n\n    void colorize(vector<vector<int>>& M, vector<int>& vis,int x){\n        vis[x] = 1;\n        for(int i = 0; i < n; ++i){            \n            if(!vis[i] && M[x][i]){                \n                colorize(M, vis, i); \n            }             \n        }\n    }\n    int findCircleNum(vector<vector<int>>& M) {\n        n = M.size();\n        vector<int> vis(n, 0);\n        int ct = 0;\n        for(int i = 0; i < n; ++i){\n            if(!vis[i]){\n                ct++;\n                colorize(M, vis, i);\n            }            \n        }\n        return ct;\n    }\n};\n```","slug":"刷题-搜索-dfs-547-Friend-Circles","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j640041l5uo0dxsc9kr","content":"<h2 id=\"547-Friend-Circles\"><a href=\"#547-Friend-Circles\" class=\"headerlink\" title=\"547. Friend Circles\"></a><a href=\"https://leetcode-cn.com/problems/friend-circles/\">547. Friend Circles</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dfs搜索人头就行。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int n;\n\n    void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; M, vector&lt;int&gt;&amp; vis,int x)&#123;\n        vis[x] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;            \n            if(!vis[i] &amp;&amp; M[x][i])&#123;                \n                colorize(M, vis, i); \n            &#125;             \n        &#125;\n    &#125;\n    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123;\n        n &#x3D; M.size();\n        vector&lt;int&gt; vis(n, 0);\n        int ct &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(!vis[i])&#123;\n                ct++;\n                colorize(M, vis, i);\n            &#125;            \n        &#125;\n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2QVZ5H3","excerpt":"<h2 id=\"547-Friend-Circles\"><a href=\"#547-Friend-Circles\" class=\"headerlink\" title=\"547. Friend Circles\"></a><a href=\"https://leetcode-cn.com/problems/friend-circles/\">547. Friend Circles</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dfs搜索人头就行。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int n;\n\n    void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; M, vector&lt;int&gt;&amp; vis,int x)&#123;\n        vis[x] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;            \n            if(!vis[i] &amp;&amp; M[x][i])&#123;                \n                colorize(M, vis, i); \n            &#125;             \n        &#125;\n    &#125;\n    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123;\n        n &#x3D; M.size();\n        vector&lt;int&gt; vis(n, 0);\n        int ct &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(!vis[i])&#123;\n                ct++;\n                colorize(M, vis, i);\n            &#125;            \n        &#125;\n        return ct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"547. Number of Provinces","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-07T03:05:57.000Z","_content":"\n\n\n\n\n## [547. Number of Provinces](https://leetcode-cn.com/problems/number-of-provinces/)\n\n## 思路：\n\n多次dfs判断连通团即可\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int res = 0, n = isConnected.size();\n        vector<int> vis(n);\n        for(int i = 0; i < n; ++i){\n            if(!vis[i]){\n                ++res;\n                dfs(vis, isConnected, i);\n            }\n        }\n        return res;\n    }\n     \n    void dfs(vector<int> &vis, vector<vector<int>> &g, int k){\n        if(vis[k]) return;\n        vis[k] = 1;\n        for(int i = 0; i < g.size(); ++i){\n            if(g[k][i]) dfs(vis, g, i);\n        }\n    }\n};\n```\n\n","source":"_posts/刷题/搜索/dfs\n/547-Number-of-Provinces.md","raw":"---\ntitle: 547. Number of Provinces\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-07 11:05:57\n---\n\n\n\n\n\n## [547. Number of Provinces](https://leetcode-cn.com/problems/number-of-provinces/)\n\n## 思路：\n\n多次dfs判断连通团即可\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int res = 0, n = isConnected.size();\n        vector<int> vis(n);\n        for(int i = 0; i < n; ++i){\n            if(!vis[i]){\n                ++res;\n                dfs(vis, isConnected, i);\n            }\n        }\n        return res;\n    }\n     \n    void dfs(vector<int> &vis, vector<vector<int>> &g, int k){\n        if(vis[k]) return;\n        vis[k] = 1;\n        for(int i = 0; i < g.size(); ++i){\n            if(g[k][i]) dfs(vis, g, i);\n        }\n    }\n};\n```\n\n","slug":"刷题-搜索-dfs-547-Number-of-Provinces","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j650042l5uo6mk0abqb","content":"<h2 id=\"547-Number-of-Provinces\"><a href=\"#547-Number-of-Provinces\" class=\"headerlink\" title=\"547. Number of Provinces\"></a><a href=\"https://leetcode-cn.com/problems/number-of-provinces/\">547. Number of Provinces</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>多次dfs判断连通团即可</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;\n        int res &#x3D; 0, n &#x3D; isConnected.size();\n        vector&lt;int&gt; vis(n);\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(!vis[i])&#123;\n                ++res;\n                dfs(vis, isConnected, i);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n     \n    void dfs(vector&lt;int&gt; &amp;vis, vector&lt;vector&lt;int&gt;&gt; &amp;g, int k)&#123;\n        if(vis[k]) return;\n        vis[k] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; g.size(); ++i)&#123;\n            if(g[k][i]) dfs(vis, g, i);\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1TD2SQD","excerpt":"<h2 id=\"547-Number-of-Provinces\"><a href=\"#547-Number-of-Provinces\" class=\"headerlink\" title=\"547. Number of Provinces\"></a><a href=\"https://leetcode-cn.com/problems/number-of-provinces/\">547. Number of Provinces</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>多次dfs判断连通团即可</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n\n    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;\n        int res &#x3D; 0, n &#x3D; isConnected.size();\n        vector&lt;int&gt; vis(n);\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(!vis[i])&#123;\n                ++res;\n                dfs(vis, isConnected, i);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n     \n    void dfs(vector&lt;int&gt; &amp;vis, vector&lt;vector&lt;int&gt;&gt; &amp;g, int k)&#123;\n        if(vis[k]) return;\n        vis[k] &#x3D; 1;\n        for(int i &#x3D; 0; i &lt; g.size(); ++i)&#123;\n            if(g[k][i]) dfs(vis, g, i);\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"695. Max Area of Island","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-19T02:58:40.000Z","_content":"\n\n\n\n\n\n## [695. Max Area of Island](https://leetcode-cn.com/problems/max-area-of-island/)\n\n、\n\n## 思路：\n\n深度优先搜索\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, 1, -1};\n    int n, m;\n    int maxAreaOfIsland(vector<vector<int>>& grid) {        \n        if(grid[0].size() == 0) return 0;\n        n = grid.size(), m = grid[0].size();\n        vector< vector<int>> vis(n, vector<int>(m, 0));\n\n        int maxA = 0;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){            \n                int tempA = 0;\n                if(grid[i][j] == 1 && vis[i][j] == 0){\n                    area(grid, i, j, vis, tempA);\n                    maxA = max(maxA, tempA);\n                }                    \n            }\n        }\n        return maxA;\n    }\n    \n    void area(vector<vector<int>>& grid, int x, int y, vector<vector<int>>& vis, int &ct){//bug\n        // cout << x << ' ' << y << endl;        \n        if( x < 0 || x >=n || y < 0 || y >= m || vis[x][y] == 1 || grid[x][y] == 0 ) return;//bug\n        vis[x][y] = 1; //bug        \n        ct += 1;        \n        for(int k = 0; k < 4; ++k)\n            area(grid, x + dx[k], y + dy[k], vis, ct);        \n    }\n};\n```","source":"_posts/刷题/搜索/dfs\n/695-Max-Area-of-Island.md","raw":"---\ntitle: 695. Max Area of Island\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-11-19 10:58:40\ntags:\n---\n\n\n\n\n\n\n## [695. Max Area of Island](https://leetcode-cn.com/problems/max-area-of-island/)\n\n、\n\n## 思路：\n\n深度优先搜索\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int dx[4] = {-1, 1, 0, 0};\n    int dy[4] = {0, 0, 1, -1};\n    int n, m;\n    int maxAreaOfIsland(vector<vector<int>>& grid) {        \n        if(grid[0].size() == 0) return 0;\n        n = grid.size(), m = grid[0].size();\n        vector< vector<int>> vis(n, vector<int>(m, 0));\n\n        int maxA = 0;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){            \n                int tempA = 0;\n                if(grid[i][j] == 1 && vis[i][j] == 0){\n                    area(grid, i, j, vis, tempA);\n                    maxA = max(maxA, tempA);\n                }                    \n            }\n        }\n        return maxA;\n    }\n    \n    void area(vector<vector<int>>& grid, int x, int y, vector<vector<int>>& vis, int &ct){//bug\n        // cout << x << ' ' << y << endl;        \n        if( x < 0 || x >=n || y < 0 || y >= m || vis[x][y] == 1 || grid[x][y] == 0 ) return;//bug\n        vis[x][y] = 1; //bug        \n        ct += 1;        \n        for(int k = 0; k < 4; ++k)\n            area(grid, x + dx[k], y + dy[k], vis, ct);        \n    }\n};\n```","slug":"刷题-搜索-dfs-695-Max-Area-of-Island","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j650043l5uo9ie8dx5a","content":"<h2 id=\"695-Max-Area-of-Island\"><a href=\"#695-Max-Area-of-Island\" class=\"headerlink\" title=\"695. Max Area of Island\"></a><a href=\"https://leetcode-cn.com/problems/max-area-of-island/\">695. Max Area of Island</a></h2><p>、</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>深度优先搜索</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, 1, -1&#125;;\n    int n, m;\n    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        \n        if(grid[0].size() &#x3D;&#x3D; 0) return 0;\n        n &#x3D; grid.size(), m &#x3D; grid[0].size();\n        vector&lt; vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0));\n\n        int maxA &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;            \n                int tempA &#x3D; 0;\n                if(grid[i][j] &#x3D;&#x3D; 1 &amp;&amp; vis[i][j] &#x3D;&#x3D; 0)&#123;\n                    area(grid, i, j, vis, tempA);\n                    maxA &#x3D; max(maxA, tempA);\n                &#125;                    \n            &#125;\n        &#125;\n        return maxA;\n    &#125;\n    \n    void area(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; vis, int &amp;ct)&#123;&#x2F;&#x2F;bug\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;        \n        if( x &lt; 0 || x &gt;&#x3D;n || y &lt; 0 || y &gt;&#x3D; m || vis[x][y] &#x3D;&#x3D; 1 || grid[x][y] &#x3D;&#x3D; 0 ) return;&#x2F;&#x2F;bug\n        vis[x][y] &#x3D; 1; &#x2F;&#x2F;bug        \n        ct +&#x3D; 1;        \n        for(int k &#x3D; 0; k &lt; 4; ++k)\n            area(grid, x + dx[k], y + dy[k], vis, ct);        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"39WWC8X","excerpt":"<h2 id=\"695-Max-Area-of-Island\"><a href=\"#695-Max-Area-of-Island\" class=\"headerlink\" title=\"695. Max Area of Island\"></a><a href=\"https://leetcode-cn.com/problems/max-area-of-island/\">695. Max Area of Island</a></h2><p>、</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>深度优先搜索</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int dx[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int dy[4] &#x3D; &#123;0, 0, 1, -1&#125;;\n    int n, m;\n    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        \n        if(grid[0].size() &#x3D;&#x3D; 0) return 0;\n        n &#x3D; grid.size(), m &#x3D; grid[0].size();\n        vector&lt; vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0));\n\n        int maxA &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; m; ++j)&#123;            \n                int tempA &#x3D; 0;\n                if(grid[i][j] &#x3D;&#x3D; 1 &amp;&amp; vis[i][j] &#x3D;&#x3D; 0)&#123;\n                    area(grid, i, j, vis, tempA);\n                    maxA &#x3D; max(maxA, tempA);\n                &#125;                    \n            &#125;\n        &#125;\n        return maxA;\n    &#125;\n    \n    void area(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; vis, int &amp;ct)&#123;&#x2F;&#x2F;bug\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;        \n        if( x &lt; 0 || x &gt;&#x3D;n || y &lt; 0 || y &gt;&#x3D; m || vis[x][y] &#x3D;&#x3D; 1 || grid[x][y] &#x3D;&#x3D; 0 ) return;&#x2F;&#x2F;bug\n        vis[x][y] &#x3D; 1; &#x2F;&#x2F;bug        \n        ct +&#x3D; 1;        \n        for(int k &#x3D; 0; k &lt; 4; ++k)\n            area(grid, x + dx[k], y + dy[k], vis, ct);        \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"154. Find Minimum in Rotated Sorted Array II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-01T00:40:48.000Z","_content":"\n\n\n\n\n## [154. Find Minimum in Rotated Sorted Array II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n## 思路：\n\n这题非常具有启发性质，hard~\n\n<!-- more -->\n\n虽然还是二分，但是题目条件更加复杂。\n\n话题可视化还是不错的分析方法，可惜我太懒了……\n\n注意题目的被旋转数组部分可能长度为零。\n\n借用答案的分析思路：\n\n由于数组“右边”的数字一定是未被旋转的，那么一定有\n$$\nnums[mid] < num[right] -> 右边有序\\\\\nnums[mid] > num[right] -> 左边有序\n$$\n\n\n如此便可以二分，其他情况下，可能存在\n$$\nnums[mid] == nums[l] == nums[r]\n$$\n无法进行二分，但可以发现，num[r]等于nums[mid]，所以r是可以缩减范围的。\n\n\n\n图形化描述见[官方题解](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui--16/)\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1, mid;\n        if(r < 0) return -1;//bug\n        //加个判断击败14%->98%,说明大多数人还是直接复制粘粘答案的\n        if(nums[l] < nums[r]) return nums[l];\n        while(l < r){\n            mid = l + (r - l) / 2;\n            if(nums[mid] < nums[r]) r = mid;\n            else if(nums[mid] > nums[r]) l = mid + 1;\n            else r--; \n        }\n        return nums[l];\n\n\n    }\n};\n\n```","source":"_posts/刷题/搜索/二分\n/154-Find-Minimum-in-Rotated-Sorted-Array-II.md","raw":"---\ntitle: 154. Find Minimum in Rotated Sorted Array II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-01 08:40:48\n---\n\n\n\n\n\n## [154. Find Minimum in Rotated Sorted Array II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)\n\n## 思路：\n\n这题非常具有启发性质，hard~\n\n<!-- more -->\n\n虽然还是二分，但是题目条件更加复杂。\n\n话题可视化还是不错的分析方法，可惜我太懒了……\n\n注意题目的被旋转数组部分可能长度为零。\n\n借用答案的分析思路：\n\n由于数组“右边”的数字一定是未被旋转的，那么一定有\n$$\nnums[mid] < num[right] -> 右边有序\\\\\nnums[mid] > num[right] -> 左边有序\n$$\n\n\n如此便可以二分，其他情况下，可能存在\n$$\nnums[mid] == nums[l] == nums[r]\n$$\n无法进行二分，但可以发现，num[r]等于nums[mid]，所以r是可以缩减范围的。\n\n\n\n图形化描述见[官方题解](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui--16/)\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1, mid;\n        if(r < 0) return -1;//bug\n        //加个判断击败14%->98%,说明大多数人还是直接复制粘粘答案的\n        if(nums[l] < nums[r]) return nums[l];\n        while(l < r){\n            mid = l + (r - l) / 2;\n            if(nums[mid] < nums[r]) r = mid;\n            else if(nums[mid] > nums[r]) l = mid + 1;\n            else r--; \n        }\n        return nums[l];\n\n\n    }\n};\n\n```","slug":"刷题-搜索-二分-154-Find-Minimum-in-Rotated-Sorted-Array-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j660044l5uo45ue3nwb","content":"<h2 id=\"154-Find-Minimum-in-Rotated-Sorted-Array-II\"><a href=\"#154-Find-Minimum-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"154. Find Minimum in Rotated Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/\">154. Find Minimum in Rotated Sorted Array II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题非常具有启发性质，hard~</p>\n<span id=\"more\"></span>\n\n<p>虽然还是二分，但是题目条件更加复杂。</p>\n<p>话题可视化还是不错的分析方法，可惜我太懒了……</p>\n<p>注意题目的被旋转数组部分可能长度为零。</p>\n<p>借用答案的分析思路：</p>\n<p>由于数组“右边”的数字一定是未被旋转的，那么一定有<br>$$<br>nums[mid] &lt; num[right] -&gt; 右边有序\\<br>nums[mid] &gt; num[right] -&gt; 左边有序<br>$$</p>\n<p>如此便可以二分，其他情况下，可能存在<br>$$<br>nums[mid] == nums[l] == nums[r]<br>$$<br>无法进行二分，但可以发现，num[r]等于nums[mid]，所以r是可以缩减范围的。</p>\n<p>图形化描述见<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui--16/\">官方题解</a></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1, mid;\n        if(r &lt; 0) return -1;&#x2F;&#x2F;bug\n        &#x2F;&#x2F;加个判断击败14%-&gt;98%,说明大多数人还是直接复制粘粘答案的\n        if(nums[l] &lt; nums[r]) return nums[l];\n        while(l &lt; r)&#123;\n            mid &#x3D; l + (r - l) &#x2F; 2;\n            if(nums[mid] &lt; nums[r]) r &#x3D; mid;\n            else if(nums[mid] &gt; nums[r]) l &#x3D; mid + 1;\n            else r--; \n        &#125;\n        return nums[l];\n\n\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"RND8QK","excerpt":"<h2 id=\"154-Find-Minimum-in-Rotated-Sorted-Array-II\"><a href=\"#154-Find-Minimum-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"154. Find Minimum in Rotated Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/\">154. Find Minimum in Rotated Sorted Array II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题非常具有启发性质，hard~</p>","more":"<p>虽然还是二分，但是题目条件更加复杂。</p>\n<p>话题可视化还是不错的分析方法，可惜我太懒了……</p>\n<p>注意题目的被旋转数组部分可能长度为零。</p>\n<p>借用答案的分析思路：</p>\n<p>由于数组“右边”的数字一定是未被旋转的，那么一定有<br>$$<br>nums[mid] &lt; num[right] -&gt; 右边有序\\<br>nums[mid] &gt; num[right] -&gt; 左边有序<br>$$</p>\n<p>如此便可以二分，其他情况下，可能存在<br>$$<br>nums[mid] == nums[l] == nums[r]<br>$$<br>无法进行二分，但可以发现，num[r]等于nums[mid]，所以r是可以缩减范围的。</p>\n<p>图形化描述见<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui--16/\">官方题解</a></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int findMin(vector&lt;int&gt;&amp; nums) &#123;\n        int l &#x3D; 0, r &#x3D; nums.size() - 1, mid;\n        if(r &lt; 0) return -1;&#x2F;&#x2F;bug\n        &#x2F;&#x2F;加个判断击败14%-&gt;98%,说明大多数人还是直接复制粘粘答案的\n        if(nums[l] &lt; nums[r]) return nums[l];\n        while(l &lt; r)&#123;\n            mid &#x3D; l + (r - l) &#x2F; 2;\n            if(nums[mid] &lt; nums[r]) r &#x3D; mid;\n            else if(nums[mid] &gt; nums[r]) l &#x3D; mid + 1;\n            else r--; \n        &#125;\n        return nums[l];\n\n\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"81. Search in Rotated Sorted Array II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-29T16:00:00.000Z","_content":"\n\n\n\n\n## [81. Search in Rotated Sorted Array II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n\n\n\n\n\n\n\n\n\n## 思路：\n\n这题好像是33题的follow up。\n\n增添了各个元素可能相等的条件。\n\n没做出来。\n\n\n\n如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 `nums[mid]==nums[l]`那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。\n\n跳出这层，能不能直接在二分搜索呢？\n\n\n\n<!-- more -->\n\n> 参考题解\n>\n> ![image-20201030095548987](http://static.come2rss.xyz/image-20201030095548987.png)\n\n\n\n\n\n```c++\n// 失败的二分\n// class Solution {\n// public:\n\n    \n//     bool search(vector<int>& nums, int target) {\n//         int n = nums.size();\n//         int l = 0, r = n, mid, start = l;\n//         while(l < r){\n//             mid = (l + r) / 2;\n//             if(nums[mid] < nums[start]) r = mid;\n//             else if(nums[mid] == nums[start]) start++;\n//             else l = mid + 1;\n//             // cout << l << endl;\n//         }    \n\n//         // cout << l << endl;\n//         vector<int>::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target);\n//         vector<int>::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target);\n//         if( iter1 != nums.end() && *iter1 == target || iter2 != nums.end() && *iter2 == target)\n//             return true;\n//         else return false;\n//     }\n// };\n\nclass Solution {\npublic:\n\n    \n    bool search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1, mid, start = l;\n        while(l <= r){\n            mid = ( r + l) / 2;\n            if(nums[mid] == target)\n                return true;\n            else if(nums[mid] > nums[l]){\n                if(nums[l] <= target && target < nums[mid])\n                    r = mid - 1;\n                else l = mid + 1;\n            }\n            else if(nums[mid] < nums[l]){\n                if(nums[mid] < target && target <= nums[r])\n                    l = mid + 1;\n                else r = mid - 1; \n            }\n            else if(nums[mid] == nums[l])\n                l++;\n        }\n        return false;\n    }\n};\n\n```","source":"_posts/刷题/搜索/二分\n/2020-10-30-81.-Search-in-Rotated-Sorted-Array-II.md","raw":"---\ntitle: 81. Search in Rotated Sorted Array II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-30 09:56:38\n---\n\n\n\n\n\n## [81. Search in Rotated Sorted Array II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n\n\n\n\n\n\n\n\n\n## 思路：\n\n这题好像是33题的follow up。\n\n增添了各个元素可能相等的条件。\n\n没做出来。\n\n\n\n如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 `nums[mid]==nums[l]`那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。\n\n跳出这层，能不能直接在二分搜索呢？\n\n\n\n<!-- more -->\n\n> 参考题解\n>\n> ![image-20201030095548987](http://static.come2rss.xyz/image-20201030095548987.png)\n\n\n\n\n\n```c++\n// 失败的二分\n// class Solution {\n// public:\n\n    \n//     bool search(vector<int>& nums, int target) {\n//         int n = nums.size();\n//         int l = 0, r = n, mid, start = l;\n//         while(l < r){\n//             mid = (l + r) / 2;\n//             if(nums[mid] < nums[start]) r = mid;\n//             else if(nums[mid] == nums[start]) start++;\n//             else l = mid + 1;\n//             // cout << l << endl;\n//         }    \n\n//         // cout << l << endl;\n//         vector<int>::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target);\n//         vector<int>::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target);\n//         if( iter1 != nums.end() && *iter1 == target || iter2 != nums.end() && *iter2 == target)\n//             return true;\n//         else return false;\n//     }\n// };\n\nclass Solution {\npublic:\n\n    \n    bool search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1, mid, start = l;\n        while(l <= r){\n            mid = ( r + l) / 2;\n            if(nums[mid] == target)\n                return true;\n            else if(nums[mid] > nums[l]){\n                if(nums[l] <= target && target < nums[mid])\n                    r = mid - 1;\n                else l = mid + 1;\n            }\n            else if(nums[mid] < nums[l]){\n                if(nums[mid] < target && target <= nums[r])\n                    l = mid + 1;\n                else r = mid - 1; \n            }\n            else if(nums[mid] == nums[l])\n                l++;\n        }\n        return false;\n    }\n};\n\n```","slug":"刷题-搜索-二分-2020-10-30-81-Search-in-Rotated-Sorted-Array-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j670045l5uodljf3q3j","content":"<h2 id=\"81-Search-in-Rotated-Sorted-Array-II\"><a href=\"#81-Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"81. Search in Rotated Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/\">81. Search in Rotated Sorted Array II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题好像是33题的follow up。</p>\n<p>增添了各个元素可能相等的条件。</p>\n<p>没做出来。</p>\n<p>如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 <code>nums[mid]==nums[l]</code>那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。</p>\n<p>跳出这层，能不能直接在二分搜索呢？</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>参考题解</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201030095548987.png\" alt=\"image-20201030095548987\"></p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 失败的二分\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n\n    \n&#x2F;&#x2F;     bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         int l &#x3D; 0, r &#x3D; n, mid, start &#x3D; l;\n&#x2F;&#x2F;         while(l &lt; r)&#123;\n&#x2F;&#x2F;             mid &#x3D; (l + r) &#x2F; 2;\n&#x2F;&#x2F;             if(nums[mid] &lt; nums[start]) r &#x3D; mid;\n&#x2F;&#x2F;             else if(nums[mid] &#x3D;&#x3D; nums[start]) start++;\n&#x2F;&#x2F;             else l &#x3D; mid + 1;\n&#x2F;&#x2F;             &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         &#125;    \n\n&#x2F;&#x2F;         &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter1 &#x3D; std::lower_bound(nums.begin(), nums.begin() + l, target);\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter2 &#x3D; std::lower_bound(nums.begin() + l, nums.end(), target);\n&#x2F;&#x2F;         if( iter1 !&#x3D; nums.end() &amp;&amp; *iter1 &#x3D;&#x3D; target || iter2 !&#x3D; nums.end() &amp;&amp; *iter2 &#x3D;&#x3D; target)\n&#x2F;&#x2F;             return true;\n&#x2F;&#x2F;         else return false;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\nclass Solution &#123;\npublic:\n\n    \n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int n &#x3D; nums.size();\n        int l &#x3D; 0, r &#x3D; n - 1, mid, start &#x3D; l;\n        while(l &lt;&#x3D; r)&#123;\n            mid &#x3D; ( r + l) &#x2F; 2;\n            if(nums[mid] &#x3D;&#x3D; target)\n                return true;\n            else if(nums[mid] &gt; nums[l])&#123;\n                if(nums[l] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid])\n                    r &#x3D; mid - 1;\n                else l &#x3D; mid + 1;\n            &#125;\n            else if(nums[mid] &lt; nums[l])&#123;\n                if(nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[r])\n                    l &#x3D; mid + 1;\n                else r &#x3D; mid - 1; \n            &#125;\n            else if(nums[mid] &#x3D;&#x3D; nums[l])\n                l++;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"9K261R","excerpt":"<h2 id=\"81-Search-in-Rotated-Sorted-Array-II\"><a href=\"#81-Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"81. Search in Rotated Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/\">81. Search in Rotated Sorted Array II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题好像是33题的follow up。</p>\n<p>增添了各个元素可能相等的条件。</p>\n<p>没做出来。</p>\n<p>如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 <code>nums[mid]==nums[l]</code>那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。</p>\n<p>跳出这层，能不能直接在二分搜索呢？</p>","more":"<blockquote>\n<p>参考题解</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201030095548987.png\" alt=\"image-20201030095548987\"></p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 失败的二分\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n\n    \n&#x2F;&#x2F;     bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         int l &#x3D; 0, r &#x3D; n, mid, start &#x3D; l;\n&#x2F;&#x2F;         while(l &lt; r)&#123;\n&#x2F;&#x2F;             mid &#x3D; (l + r) &#x2F; 2;\n&#x2F;&#x2F;             if(nums[mid] &lt; nums[start]) r &#x3D; mid;\n&#x2F;&#x2F;             else if(nums[mid] &#x3D;&#x3D; nums[start]) start++;\n&#x2F;&#x2F;             else l &#x3D; mid + 1;\n&#x2F;&#x2F;             &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         &#125;    \n\n&#x2F;&#x2F;         &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter1 &#x3D; std::lower_bound(nums.begin(), nums.begin() + l, target);\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter2 &#x3D; std::lower_bound(nums.begin() + l, nums.end(), target);\n&#x2F;&#x2F;         if( iter1 !&#x3D; nums.end() &amp;&amp; *iter1 &#x3D;&#x3D; target || iter2 !&#x3D; nums.end() &amp;&amp; *iter2 &#x3D;&#x3D; target)\n&#x2F;&#x2F;             return true;\n&#x2F;&#x2F;         else return false;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\nclass Solution &#123;\npublic:\n\n    \n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int n &#x3D; nums.size();\n        int l &#x3D; 0, r &#x3D; n - 1, mid, start &#x3D; l;\n        while(l &lt;&#x3D; r)&#123;\n            mid &#x3D; ( r + l) &#x2F; 2;\n            if(nums[mid] &#x3D;&#x3D; target)\n                return true;\n            else if(nums[mid] &gt; nums[l])&#123;\n                if(nums[l] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid])\n                    r &#x3D; mid - 1;\n                else l &#x3D; mid + 1;\n            &#125;\n            else if(nums[mid] &lt; nums[l])&#123;\n                if(nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[r])\n                    l &#x3D; mid + 1;\n                else r &#x3D; mid - 1; \n            &#125;\n            else if(nums[mid] &#x3D;&#x3D; nums[l])\n                l++;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"34. Find First and Last Position of Element in Sorted Array","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-28T00:39:37.000Z","_content":"\n#### [34. Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n<!-- more -->\n\n## 思路：\n\n二分\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    \n    int getFirst(vector<int> nums, int l, int r, int tar){\n        if(nums.size() == 0) return -1;\n        int mid ;\n        while(l < r){\n            mid = (r + l) / 2;\n            if(nums[mid] < tar) l = mid + 1;\n            else r = mid;\n        }\n    // 临界判断需要小心    \n        return l != nums.size() && nums[l] == tar ? l : -1;\n    }\n\n    int getLast(vector<int> nums, int l, int r, int tar){\n        if(nums.size() == 0) return -1;\n        int mid ;\n        while(l < r){\n            mid = (r + l) / 2;\n            if(nums[mid] <= tar) l = mid + 1;\n            else r = mid;\n        }\n        return l != 0 && nums[l - 1] == tar ? l - 1 : -1;\n    }\n    \n    vector<int> searchRange(vector<int>& nums, int target) {\n        int s = -1 , e = -1, l = 0, r = nums.size();\n        vector<int> res({getFirst(nums, 0, nums.size(), target) , getLast(nums, 0, nums.size(), target) });\n        return res;\n    }\n};\n```","source":"_posts/刷题/搜索/二分\n/34-Find-First-and-Last-Position-of-Element-in-Sorted-Array.md","raw":"---\ntitle: 34. Find First and Last Position of Element in Sorted Array\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-28 08:39:37\n---\n\n#### [34. Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n<!-- more -->\n\n## 思路：\n\n二分\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    \n    int getFirst(vector<int> nums, int l, int r, int tar){\n        if(nums.size() == 0) return -1;\n        int mid ;\n        while(l < r){\n            mid = (r + l) / 2;\n            if(nums[mid] < tar) l = mid + 1;\n            else r = mid;\n        }\n    // 临界判断需要小心    \n        return l != nums.size() && nums[l] == tar ? l : -1;\n    }\n\n    int getLast(vector<int> nums, int l, int r, int tar){\n        if(nums.size() == 0) return -1;\n        int mid ;\n        while(l < r){\n            mid = (r + l) / 2;\n            if(nums[mid] <= tar) l = mid + 1;\n            else r = mid;\n        }\n        return l != 0 && nums[l - 1] == tar ? l - 1 : -1;\n    }\n    \n    vector<int> searchRange(vector<int>& nums, int target) {\n        int s = -1 , e = -1, l = 0, r = nums.size();\n        vector<int> res({getFirst(nums, 0, nums.size(), target) , getLast(nums, 0, nums.size(), target) });\n        return res;\n    }\n};\n```","slug":"刷题-搜索-二分-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j670046l5uo1a72eno3","content":"<h4 id=\"34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"34. Find First and Last Position of Element in Sorted Array\"></a><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">34. Find First and Last Position of Element in Sorted Array</a></h4><span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二分</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    int getFirst(vector&lt;int&gt; nums, int l, int r, int tar)&#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int mid ;\n        while(l &lt; r)&#123;\n            mid &#x3D; (r + l) &#x2F; 2;\n            if(nums[mid] &lt; tar) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n    &#x2F;&#x2F; 临界判断需要小心    \n        return l !&#x3D; nums.size() &amp;&amp; nums[l] &#x3D;&#x3D; tar ? l : -1;\n    &#125;\n\n    int getLast(vector&lt;int&gt; nums, int l, int r, int tar)&#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int mid ;\n        while(l &lt; r)&#123;\n            mid &#x3D; (r + l) &#x2F; 2;\n            if(nums[mid] &lt;&#x3D; tar) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n        return l !&#x3D; 0 &amp;&amp; nums[l - 1] &#x3D;&#x3D; tar ? l - 1 : -1;\n    &#125;\n    \n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int s &#x3D; -1 , e &#x3D; -1, l &#x3D; 0, r &#x3D; nums.size();\n        vector&lt;int&gt; res(&#123;getFirst(nums, 0, nums.size(), target) , getLast(nums, 0, nums.size(), target) &#125;);\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2BTYZP4","excerpt":"<h4 id=\"34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"34. Find First and Last Position of Element in Sorted Array\"></a><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">34. Find First and Last Position of Element in Sorted Array</a></h4>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二分</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    int getFirst(vector&lt;int&gt; nums, int l, int r, int tar)&#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int mid ;\n        while(l &lt; r)&#123;\n            mid &#x3D; (r + l) &#x2F; 2;\n            if(nums[mid] &lt; tar) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n    &#x2F;&#x2F; 临界判断需要小心    \n        return l !&#x3D; nums.size() &amp;&amp; nums[l] &#x3D;&#x3D; tar ? l : -1;\n    &#125;\n\n    int getLast(vector&lt;int&gt; nums, int l, int r, int tar)&#123;\n        if(nums.size() &#x3D;&#x3D; 0) return -1;\n        int mid ;\n        while(l &lt; r)&#123;\n            mid &#x3D; (r + l) &#x2F; 2;\n            if(nums[mid] &lt;&#x3D; tar) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n        return l !&#x3D; 0 &amp;&amp; nums[l - 1] &#x3D;&#x3D; tar ? l - 1 : -1;\n    &#125;\n    \n    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int s &#x3D; -1 , e &#x3D; -1, l &#x3D; 0, r &#x3D; nums.size();\n        vector&lt;int&gt; res(&#123;getFirst(nums, 0, nums.size(), target) , getLast(nums, 0, nums.size(), target) &#125;);\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"4. Median of Two Sorted Arrays","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-12T02:09:16.000Z","_content":"\n\n\n\n\n\n\n\n# [4. Median of Two Sorted Arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)  - 第K大 + 二刷\n\n\n\n## 思路：\n\n将查找中位数扩大为更广义的解法：求解第$K$位的数字。每次在`A`,`B`两个数组中划分出两个`k/2`个元素，并排除划分出的最后一个数字比较小的数组，然后减去对应的排除的数组的数字个数，更新$K$值。直到$K==1$，或者其中一个数组为空。\n\n> 详细题解[如下](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int len1 = nums1.size(), len2 = nums2.size();\n        int alllen = len1 + len2;\n        if(alllen % 2 == 1){\n            return findKthNum(nums1, nums2, alllen / 2 + 1);\n        }else \n            return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2;\n    }\n    double findKthNum(vector<int>& nums1, vector<int>& nums2, int k){\n        int idx1 = 0, idx2 = 0;\n        int len1 = nums1.size(), len2 = nums2.size();\n        while(1){\n            if(idx1 == len1) return nums2[idx2 + k - 1];\n            if(idx2 == len2) return nums1[idx1 + k - 1];\n            if(k == 1) return min(nums1[idx1], nums2[idx2]);\n\n            int half = k / 2;\n            int newidx1 = min(idx1 + half, len1) - 1;\n            int newidx2 = min(idx2 + half, len2) - 1;\n            if(nums1[newidx1] >  nums2[newidx2]){\n                k -= newidx2 - idx2 + 1;\n                idx2 = newidx2 + 1;            \n            }else{\n                k -= newidx1 - idx1 + 1;\n                idx1 = newidx1 + 1;\n                \n            }\n            \n        }\n    }\n};\n```\n\n\n\n```c++\n\n// 思考一下follow up\n// 如果K组有序数据，要选出第K大数据你怎么计算呢？ 扩展一下就可以了！\n//以下是二刷，不是followup \nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int len1 = nums1.size(), len2 = nums2.size();\n        int alllen = len1 + len2;\n        if(alllen % 2 == 1){\n            return findKthNum(nums1, nums2, alllen / 2 + 1);\n        }else \n            return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2;\n    }\n    // k： 第K个数据（‘第’默认从1开始数起 ）\n    double findKthNum(vector<int>& nums1, vector<int>& nums2, int k){ \n        \n        int n = nums1.size(), m = nums2.size();\n        int idx1 = 0, idx2 = 0;\n        while(1){\n            if(idx1 == n) return nums2[idx2 + k - 1]; // 判断临界点\n            if(idx2 == m) return nums1[idx1 + k - 1];\n            if(k == 1) return min(nums1[idx1], nums2[idx2]);\n\n            // k >= 2\n            int newidx1 = min(k / 2 + idx1, n) - 1; // min 防止溢出\n            int newidx2 = min(k / 2 + idx2, m) - 1;  \n            if(nums1[newidx1] > nums2[newidx2]){// 结尾数字小的可以直接忽略前串\n                k -= newidx2 - idx2 + 1;  \n                idx2 = newidx2 + 1; // 多进一个数字\n            }else{\n                k -= newidx1 - idx1 + 1;\n                idx1 = newidx1 + 1;\n            }\n        }\n\n    }    \n};\n```\n\n","source":"_posts/刷题/搜索/二分\n/4-Median-of-Two-Sorted-Arrays.md","raw":"---\ntitle: 4. Median of Two Sorted Arrays\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-12 10:09:16\n---\n\n\n\n\n\n\n\n\n# [4. Median of Two Sorted Arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)  - 第K大 + 二刷\n\n\n\n## 思路：\n\n将查找中位数扩大为更广义的解法：求解第$K$位的数字。每次在`A`,`B`两个数组中划分出两个`k/2`个元素，并排除划分出的最后一个数字比较小的数组，然后减去对应的排除的数组的数字个数，更新$K$值。直到$K==1$，或者其中一个数组为空。\n\n> 详细题解[如下](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int len1 = nums1.size(), len2 = nums2.size();\n        int alllen = len1 + len2;\n        if(alllen % 2 == 1){\n            return findKthNum(nums1, nums2, alllen / 2 + 1);\n        }else \n            return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2;\n    }\n    double findKthNum(vector<int>& nums1, vector<int>& nums2, int k){\n        int idx1 = 0, idx2 = 0;\n        int len1 = nums1.size(), len2 = nums2.size();\n        while(1){\n            if(idx1 == len1) return nums2[idx2 + k - 1];\n            if(idx2 == len2) return nums1[idx1 + k - 1];\n            if(k == 1) return min(nums1[idx1], nums2[idx2]);\n\n            int half = k / 2;\n            int newidx1 = min(idx1 + half, len1) - 1;\n            int newidx2 = min(idx2 + half, len2) - 1;\n            if(nums1[newidx1] >  nums2[newidx2]){\n                k -= newidx2 - idx2 + 1;\n                idx2 = newidx2 + 1;            \n            }else{\n                k -= newidx1 - idx1 + 1;\n                idx1 = newidx1 + 1;\n                \n            }\n            \n        }\n    }\n};\n```\n\n\n\n```c++\n\n// 思考一下follow up\n// 如果K组有序数据，要选出第K大数据你怎么计算呢？ 扩展一下就可以了！\n//以下是二刷，不是followup \nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int len1 = nums1.size(), len2 = nums2.size();\n        int alllen = len1 + len2;\n        if(alllen % 2 == 1){\n            return findKthNum(nums1, nums2, alllen / 2 + 1);\n        }else \n            return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2;\n    }\n    // k： 第K个数据（‘第’默认从1开始数起 ）\n    double findKthNum(vector<int>& nums1, vector<int>& nums2, int k){ \n        \n        int n = nums1.size(), m = nums2.size();\n        int idx1 = 0, idx2 = 0;\n        while(1){\n            if(idx1 == n) return nums2[idx2 + k - 1]; // 判断临界点\n            if(idx2 == m) return nums1[idx1 + k - 1];\n            if(k == 1) return min(nums1[idx1], nums2[idx2]);\n\n            // k >= 2\n            int newidx1 = min(k / 2 + idx1, n) - 1; // min 防止溢出\n            int newidx2 = min(k / 2 + idx2, m) - 1;  \n            if(nums1[newidx1] > nums2[newidx2]){// 结尾数字小的可以直接忽略前串\n                k -= newidx2 - idx2 + 1;  \n                idx2 = newidx2 + 1; // 多进一个数字\n            }else{\n                k -= newidx1 - idx1 + 1;\n                idx1 = newidx1 + 1;\n            }\n        }\n\n    }    \n};\n```\n\n","slug":"刷题-搜索-二分-4-Median-of-Two-Sorted-Arrays","published":1,"updated":"2021-04-21T08:11:39.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j680047l5uocbeu3ut3","content":"<h1 id=\"4-Median-of-Two-Sorted-Arrays-第K大-二刷\"><a href=\"#4-Median-of-Two-Sorted-Arrays-第K大-二刷\" class=\"headerlink\" title=\"4. Median of Two Sorted Arrays  - 第K大 + 二刷\"></a><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\">4. Median of Two Sorted Arrays</a>  - 第K大 + 二刷</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>将查找中位数扩大为更广义的解法：求解第$K$位的数字。每次在<code>A</code>,<code>B</code>两个数组中划分出两个<code>k/2</code>个元素，并排除划分出的最后一个数字比较小的数组，然后减去对应的排除的数组的数字个数，更新$K$值。直到$K==1$，或者其中一个数组为空。</p>\n<blockquote>\n<p>详细题解<a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/\">如下</a></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        int len1 &#x3D; nums1.size(), len2 &#x3D; nums2.size();\n        int alllen &#x3D; len1 + len2;\n        if(alllen % 2 &#x3D;&#x3D; 1)&#123;\n            return findKthNum(nums1, nums2, alllen &#x2F; 2 + 1);\n        &#125;else \n            return (findKthNum(nums1, nums2, alllen &#x2F; 2 ) + findKthNum(nums1, nums2, alllen &#x2F; 2 + 1) ) &#x2F; 2;\n    &#125;\n    double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123;\n        int idx1 &#x3D; 0, idx2 &#x3D; 0;\n        int len1 &#x3D; nums1.size(), len2 &#x3D; nums2.size();\n        while(1)&#123;\n            if(idx1 &#x3D;&#x3D; len1) return nums2[idx2 + k - 1];\n            if(idx2 &#x3D;&#x3D; len2) return nums1[idx1 + k - 1];\n            if(k &#x3D;&#x3D; 1) return min(nums1[idx1], nums2[idx2]);\n\n            int half &#x3D; k &#x2F; 2;\n            int newidx1 &#x3D; min(idx1 + half, len1) - 1;\n            int newidx2 &#x3D; min(idx2 + half, len2) - 1;\n            if(nums1[newidx1] &gt;  nums2[newidx2])&#123;\n                k -&#x3D; newidx2 - idx2 + 1;\n                idx2 &#x3D; newidx2 + 1;            \n            &#125;else&#123;\n                k -&#x3D; newidx1 - idx1 + 1;\n                idx1 &#x3D; newidx1 + 1;\n                \n            &#125;\n            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;&#x2F; 思考一下follow up\n&#x2F;&#x2F; 如果K组有序数据，要选出第K大数据你怎么计算呢？ 扩展一下就可以了！\n&#x2F;&#x2F;以下是二刷，不是followup \nclass Solution &#123;\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        int len1 &#x3D; nums1.size(), len2 &#x3D; nums2.size();\n        int alllen &#x3D; len1 + len2;\n        if(alllen % 2 &#x3D;&#x3D; 1)&#123;\n            return findKthNum(nums1, nums2, alllen &#x2F; 2 + 1);\n        &#125;else \n            return (findKthNum(nums1, nums2, alllen &#x2F; 2 ) + findKthNum(nums1, nums2, alllen &#x2F; 2 + 1) ) &#x2F; 2;\n    &#125;\n    &#x2F;&#x2F; k： 第K个数据（‘第’默认从1开始数起 ）\n    double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123; \n        \n        int n &#x3D; nums1.size(), m &#x3D; nums2.size();\n        int idx1 &#x3D; 0, idx2 &#x3D; 0;\n        while(1)&#123;\n            if(idx1 &#x3D;&#x3D; n) return nums2[idx2 + k - 1]; &#x2F;&#x2F; 判断临界点\n            if(idx2 &#x3D;&#x3D; m) return nums1[idx1 + k - 1];\n            if(k &#x3D;&#x3D; 1) return min(nums1[idx1], nums2[idx2]);\n\n            &#x2F;&#x2F; k &gt;&#x3D; 2\n            int newidx1 &#x3D; min(k &#x2F; 2 + idx1, n) - 1; &#x2F;&#x2F; min 防止溢出\n            int newidx2 &#x3D; min(k &#x2F; 2 + idx2, m) - 1;  \n            if(nums1[newidx1] &gt; nums2[newidx2])&#123;&#x2F;&#x2F; 结尾数字小的可以直接忽略前串\n                k -&#x3D; newidx2 - idx2 + 1;  \n                idx2 &#x3D; newidx2 + 1; &#x2F;&#x2F; 多进一个数字\n            &#125;else&#123;\n                k -&#x3D; newidx1 - idx1 + 1;\n                idx1 &#x3D; newidx1 + 1;\n            &#125;\n        &#125;\n\n    &#125;    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1AWKM3V","excerpt":"<h1 id=\"4-Median-of-Two-Sorted-Arrays-第K大-二刷\"><a href=\"#4-Median-of-Two-Sorted-Arrays-第K大-二刷\" class=\"headerlink\" title=\"4. Median of Two Sorted Arrays  - 第K大 + 二刷\"></a><a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/\">4. Median of Two Sorted Arrays</a>  - 第K大 + 二刷</h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>将查找中位数扩大为更广义的解法：求解第$K$位的数字。每次在<code>A</code>,<code>B</code>两个数组中划分出两个<code>k/2</code>个元素，并排除划分出的最后一个数字比较小的数组，然后减去对应的排除的数组的数字个数，更新$K$值。直到$K==1$，或者其中一个数组为空。</p>\n<blockquote>\n<p>详细题解<a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/\">如下</a></p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        int len1 &#x3D; nums1.size(), len2 &#x3D; nums2.size();\n        int alllen &#x3D; len1 + len2;\n        if(alllen % 2 &#x3D;&#x3D; 1)&#123;\n            return findKthNum(nums1, nums2, alllen &#x2F; 2 + 1);\n        &#125;else \n            return (findKthNum(nums1, nums2, alllen &#x2F; 2 ) + findKthNum(nums1, nums2, alllen &#x2F; 2 + 1) ) &#x2F; 2;\n    &#125;\n    double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123;\n        int idx1 &#x3D; 0, idx2 &#x3D; 0;\n        int len1 &#x3D; nums1.size(), len2 &#x3D; nums2.size();\n        while(1)&#123;\n            if(idx1 &#x3D;&#x3D; len1) return nums2[idx2 + k - 1];\n            if(idx2 &#x3D;&#x3D; len2) return nums1[idx1 + k - 1];\n            if(k &#x3D;&#x3D; 1) return min(nums1[idx1], nums2[idx2]);\n\n            int half &#x3D; k &#x2F; 2;\n            int newidx1 &#x3D; min(idx1 + half, len1) - 1;\n            int newidx2 &#x3D; min(idx2 + half, len2) - 1;\n            if(nums1[newidx1] &gt;  nums2[newidx2])&#123;\n                k -&#x3D; newidx2 - idx2 + 1;\n                idx2 &#x3D; newidx2 + 1;            \n            &#125;else&#123;\n                k -&#x3D; newidx1 - idx1 + 1;\n                idx1 &#x3D; newidx1 + 1;\n                \n            &#125;\n            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;&#x2F; 思考一下follow up\n&#x2F;&#x2F; 如果K组有序数据，要选出第K大数据你怎么计算呢？ 扩展一下就可以了！\n&#x2F;&#x2F;以下是二刷，不是followup \nclass Solution &#123;\npublic:\n    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;\n        int len1 &#x3D; nums1.size(), len2 &#x3D; nums2.size();\n        int alllen &#x3D; len1 + len2;\n        if(alllen % 2 &#x3D;&#x3D; 1)&#123;\n            return findKthNum(nums1, nums2, alllen &#x2F; 2 + 1);\n        &#125;else \n            return (findKthNum(nums1, nums2, alllen &#x2F; 2 ) + findKthNum(nums1, nums2, alllen &#x2F; 2 + 1) ) &#x2F; 2;\n    &#125;\n    &#x2F;&#x2F; k： 第K个数据（‘第’默认从1开始数起 ）\n    double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123; \n        \n        int n &#x3D; nums1.size(), m &#x3D; nums2.size();\n        int idx1 &#x3D; 0, idx2 &#x3D; 0;\n        while(1)&#123;\n            if(idx1 &#x3D;&#x3D; n) return nums2[idx2 + k - 1]; &#x2F;&#x2F; 判断临界点\n            if(idx2 &#x3D;&#x3D; m) return nums1[idx1 + k - 1];\n            if(k &#x3D;&#x3D; 1) return min(nums1[idx1], nums2[idx2]);\n\n            &#x2F;&#x2F; k &gt;&#x3D; 2\n            int newidx1 &#x3D; min(k &#x2F; 2 + idx1, n) - 1; &#x2F;&#x2F; min 防止溢出\n            int newidx2 &#x3D; min(k &#x2F; 2 + idx2, m) - 1;  \n            if(nums1[newidx1] &gt; nums2[newidx2])&#123;&#x2F;&#x2F; 结尾数字小的可以直接忽略前串\n                k -&#x3D; newidx2 - idx2 + 1;  \n                idx2 &#x3D; newidx2 + 1; &#x2F;&#x2F; 多进一个数字\n            &#125;else&#123;\n                k -&#x3D; newidx1 - idx1 + 1;\n                idx1 &#x3D; newidx1 + 1;\n            &#125;\n        &#125;\n\n    &#125;    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"69. Sqrt(x)","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-27T00:14:13.000Z","_content":"\n\n\n这题还是蛮不错的，二分和牛顿迭代法的练习入门题。\n\n\n\n#### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/) 二分  - 牛顿迭代法\n\n##### <!-- more -->\n\n\n\n\n\n## 思路：\n\n二分x或者牛顿迭代计算都可。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long l = 0, r = x, mid;\n        while(l < r){\n            mid = (l + r) / 2;\n            if(mid * mid < x) l = mid + 1;\n            else r = mid;\n        }\n        if(l * l == x)\n            return l;\n        else \n            return l - 1;\n\n    }\n};\n\n\n\n```\n\n​\t\n\n牛顿迭代法\n\n```c++\n\n\n// 牛顿迭代法\nclass Solution {\npublic:\n    //写的时候瞎想的 挺好用\n    int mySqrt(int x) {\n        double ans = x, last = ans + 1;\n        double gap = 1e-3;\n        if(x == 0) return 0;\n        while(abs(ans - last) > gap){\n\n            last = ans;\n            ans = ans - (ans * ans - x) / (double)(2 * ans); \n        }\n        return int(ans);\n        \n\n    }\n};\n\n//上一个方法的公式简化版， 击败100%\n//而且考虑到了double运算速度慢，精度要求不高，可以使用long来代替，且保证不会遗漏答案。\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long res = x;\n        while(res * res > x){\n            res = (res +  x/ res ) /2;\n        }\n        return res;\n    }\n};\n\n```\n\n","source":"_posts/刷题/搜索/二分\n/69-Sqrt-x.md","raw":"---\ntitle: 69. Sqrt(x)\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-27 08:14:13\n---\n\n\n\n这题还是蛮不错的，二分和牛顿迭代法的练习入门题。\n\n\n\n#### [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/) 二分  - 牛顿迭代法\n\n##### <!-- more -->\n\n\n\n\n\n## 思路：\n\n二分x或者牛顿迭代计算都可。\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long l = 0, r = x, mid;\n        while(l < r){\n            mid = (l + r) / 2;\n            if(mid * mid < x) l = mid + 1;\n            else r = mid;\n        }\n        if(l * l == x)\n            return l;\n        else \n            return l - 1;\n\n    }\n};\n\n\n\n```\n\n​\t\n\n牛顿迭代法\n\n```c++\n\n\n// 牛顿迭代法\nclass Solution {\npublic:\n    //写的时候瞎想的 挺好用\n    int mySqrt(int x) {\n        double ans = x, last = ans + 1;\n        double gap = 1e-3;\n        if(x == 0) return 0;\n        while(abs(ans - last) > gap){\n\n            last = ans;\n            ans = ans - (ans * ans - x) / (double)(2 * ans); \n        }\n        return int(ans);\n        \n\n    }\n};\n\n//上一个方法的公式简化版， 击败100%\n//而且考虑到了double运算速度慢，精度要求不高，可以使用long来代替，且保证不会遗漏答案。\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long res = x;\n        while(res * res > x){\n            res = (res +  x/ res ) /2;\n        }\n        return res;\n    }\n};\n\n```\n\n","slug":"刷题-搜索-二分-69-Sqrt-x","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j690048l5uo5zhn6knt","content":"<p>这题还是蛮不错的，二分和牛顿迭代法的练习入门题。</p>\n<h4 id=\"69-Sqrt-x-二分-牛顿迭代法\"><a href=\"#69-Sqrt-x-二分-牛顿迭代法\" class=\"headerlink\" title=\"69. Sqrt(x) 二分  - 牛顿迭代法\"></a><a href=\"https://leetcode-cn.com/problems/sqrtx/\">69. Sqrt(x)</a> 二分  - 牛顿迭代法</h4><h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><span id=\"more\"></span></h5><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二分x或者牛顿迭代计算都可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int mySqrt(int x) &#123;\n        long l &#x3D; 0, r &#x3D; x, mid;\n        while(l &lt; r)&#123;\n            mid &#x3D; (l + r) &#x2F; 2;\n            if(mid * mid &lt; x) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n        if(l * l &#x3D;&#x3D; x)\n            return l;\n        else \n            return l - 1;\n\n    &#125;\n&#125;;\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​    </p>\n<p>牛顿迭代法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n\n&#x2F;&#x2F; 牛顿迭代法\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;写的时候瞎想的 挺好用\n    int mySqrt(int x) &#123;\n        double ans &#x3D; x, last &#x3D; ans + 1;\n        double gap &#x3D; 1e-3;\n        if(x &#x3D;&#x3D; 0) return 0;\n        while(abs(ans - last) &gt; gap)&#123;\n\n            last &#x3D; ans;\n            ans &#x3D; ans - (ans * ans - x) &#x2F; (double)(2 * ans); \n        &#125;\n        return int(ans);\n        \n\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;上一个方法的公式简化版， 击败100%\n&#x2F;&#x2F;而且考虑到了double运算速度慢，精度要求不高，可以使用long来代替，且保证不会遗漏答案。\nclass Solution &#123;\npublic:\n    int mySqrt(int x) &#123;\n        long res &#x3D; x;\n        while(res * res &gt; x)&#123;\n            res &#x3D; (res +  x&#x2F; res ) &#x2F;2;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2NFTXY6","excerpt":"<p>这题还是蛮不错的，二分和牛顿迭代法的练习入门题。</p>\n<h4 id=\"69-Sqrt-x-二分-牛顿迭代法\"><a href=\"#69-Sqrt-x-二分-牛顿迭代法\" class=\"headerlink\" title=\"69. Sqrt(x) 二分  - 牛顿迭代法\"></a><a href=\"https://leetcode-cn.com/problems/sqrtx/\">69. Sqrt(x)</a> 二分  - 牛顿迭代法</h4><h5 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a>","more":"</h5><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二分x或者牛顿迭代计算都可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int mySqrt(int x) &#123;\n        long l &#x3D; 0, r &#x3D; x, mid;\n        while(l &lt; r)&#123;\n            mid &#x3D; (l + r) &#x2F; 2;\n            if(mid * mid &lt; x) l &#x3D; mid + 1;\n            else r &#x3D; mid;\n        &#125;\n        if(l * l &#x3D;&#x3D; x)\n            return l;\n        else \n            return l - 1;\n\n    &#125;\n&#125;;\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>​    </p>\n<p>牛顿迭代法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n\n&#x2F;&#x2F; 牛顿迭代法\nclass Solution &#123;\npublic:\n    &#x2F;&#x2F;写的时候瞎想的 挺好用\n    int mySqrt(int x) &#123;\n        double ans &#x3D; x, last &#x3D; ans + 1;\n        double gap &#x3D; 1e-3;\n        if(x &#x3D;&#x3D; 0) return 0;\n        while(abs(ans - last) &gt; gap)&#123;\n\n            last &#x3D; ans;\n            ans &#x3D; ans - (ans * ans - x) &#x2F; (double)(2 * ans); \n        &#125;\n        return int(ans);\n        \n\n    &#125;\n&#125;;\n\n&#x2F;&#x2F;上一个方法的公式简化版， 击败100%\n&#x2F;&#x2F;而且考虑到了double运算速度慢，精度要求不高，可以使用long来代替，且保证不会遗漏答案。\nclass Solution &#123;\npublic:\n    int mySqrt(int x) &#123;\n        long res &#x3D; x;\n        while(res * res &gt; x)&#123;\n            res &#x3D; (res +  x&#x2F; res ) &#x2F;2;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"75. Sort Colors","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-17T00:21:54.000Z","_content":"\n\n\n\n#### [75. Sort Colors](https://leetcode-cn.com/problems/sort-colors/)\n\n彩虹题\n\n<!-- more -->\n\n## 思路：\n\n1. 直接桶排\n2. 有趣的三指针算法。\n\n## 代码：\n\n桶排\n\n```c++\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int count[3] = {0};\n        for(int i = 0; i < nums.size(); ++i){\n            count[nums[i]]++;\n        }\n        int k = 0;\n        for(int i = 0; i < 3; ++i){\n            \n            while(count[i] > 0){\n                nums[k++] = i;\n                count[i]--;\n            }\n        }        \n    }   \n};\n```\n\n三指针\n\n```c++\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int n = nums.size();\n        int p0 = 0, p1 = n - 1;\n        for(int i = 0; i <= p1; ++i){\n            while(nums[i] == 2 && p1 >= i){\n                swap(nums[i], nums[p1]);\n                p1--;\n            }\n            if(nums[i] == 0){\n                swap(nums[p0], nums[i]);\n                p0++;\n\n            }\n\n        }\n    }   \n};\n```","source":"_posts/刷题/搜索/二分\n/75-Sort-Colors.md","raw":"---\ntitle: 75. Sort Colors\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-17 08:21:54\n---\n\n\n\n\n#### [75. Sort Colors](https://leetcode-cn.com/problems/sort-colors/)\n\n彩虹题\n\n<!-- more -->\n\n## 思路：\n\n1. 直接桶排\n2. 有趣的三指针算法。\n\n## 代码：\n\n桶排\n\n```c++\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int count[3] = {0};\n        for(int i = 0; i < nums.size(); ++i){\n            count[nums[i]]++;\n        }\n        int k = 0;\n        for(int i = 0; i < 3; ++i){\n            \n            while(count[i] > 0){\n                nums[k++] = i;\n                count[i]--;\n            }\n        }        \n    }   \n};\n```\n\n三指针\n\n```c++\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int n = nums.size();\n        int p0 = 0, p1 = n - 1;\n        for(int i = 0; i <= p1; ++i){\n            while(nums[i] == 2 && p1 >= i){\n                swap(nums[i], nums[p1]);\n                p1--;\n            }\n            if(nums[i] == 0){\n                swap(nums[p0], nums[i]);\n                p0++;\n\n            }\n\n        }\n    }   \n};\n```","slug":"刷题-搜索-二分-75-Sort-Colors","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6b0049l5uo7c300nzn","content":"<h4 id=\"75-Sort-Colors\"><a href=\"#75-Sort-Colors\" class=\"headerlink\" title=\"75. Sort Colors\"></a><a href=\"https://leetcode-cn.com/problems/sort-colors/\">75. Sort Colors</a></h4><p>彩虹题</p>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>直接桶排</li>\n<li>有趣的三指针算法。</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>桶排</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        int count[3] &#x3D; &#123;0&#125;;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            count[nums[i]]++;\n        &#125;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; 3; ++i)&#123;\n            \n            while(count[i] &gt; 0)&#123;\n                nums[k++] &#x3D; i;\n                count[i]--;\n            &#125;\n        &#125;        \n    &#125;   \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>三指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int p0 &#x3D; 0, p1 &#x3D; n - 1;\n        for(int i &#x3D; 0; i &lt;&#x3D; p1; ++i)&#123;\n            while(nums[i] &#x3D;&#x3D; 2 &amp;&amp; p1 &gt;&#x3D; i)&#123;\n                swap(nums[i], nums[p1]);\n                p1--;\n            &#125;\n            if(nums[i] &#x3D;&#x3D; 0)&#123;\n                swap(nums[p0], nums[i]);\n                p0++;\n\n            &#125;\n\n        &#125;\n    &#125;   \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1S3QN9Z","excerpt":"<h4 id=\"75-Sort-Colors\"><a href=\"#75-Sort-Colors\" class=\"headerlink\" title=\"75. Sort Colors\"></a><a href=\"https://leetcode-cn.com/problems/sort-colors/\">75. Sort Colors</a></h4><p>彩虹题</p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>直接桶排</li>\n<li>有趣的三指针算法。</li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>桶排</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        int count[3] &#x3D; &#123;0&#125;;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            count[nums[i]]++;\n        &#125;\n        int k &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; 3; ++i)&#123;\n            \n            while(count[i] &gt; 0)&#123;\n                nums[k++] &#x3D; i;\n                count[i]--;\n            &#125;\n        &#125;        \n    &#125;   \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>三指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void sortColors(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        int p0 &#x3D; 0, p1 &#x3D; n - 1;\n        for(int i &#x3D; 0; i &lt;&#x3D; p1; ++i)&#123;\n            while(nums[i] &#x3D;&#x3D; 2 &amp;&amp; p1 &gt;&#x3D; i)&#123;\n                swap(nums[i], nums[p1]);\n                p1--;\n            &#125;\n            if(nums[i] &#x3D;&#x3D; 0)&#123;\n                swap(nums[p0], nums[i]);\n                p0++;\n\n            &#125;\n\n        &#125;\n    &#125;   \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"81. Search in Rotated Sorted Array II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-28T09:02:19.000Z","_content":"\n\n\n## [81. Search in Rotated Sorted Array II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n\n\n\n\n\n\n\n\n\n## 思路：\n\n这题好像是33题的follow up。\n\n增添了各个元素可能相等的条件。\n\n没做出来。\n\n\n\n如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 `nums[mid]==nums[l]`那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。\n\n跳出这层，能不能直接在二分搜索呢？\n\n\n\n<!-- more -->\n\n> 参考题解\n>\n> ![image-20201030095548987](http://static.come2rss.xyz/image-20201030095548987.png)\n\n\n\n\n\n```c++\n// 失败的二分\n// class Solution {\n// public:\n\n    \n//     bool search(vector<int>& nums, int target) {\n//         int n = nums.size();\n//         int l = 0, r = n, mid, start = l;\n//         while(l < r){\n//             mid = (l + r) / 2;\n//             if(nums[mid] < nums[start]) r = mid;\n//             else if(nums[mid] == nums[start]) start++;\n//             else l = mid + 1;\n//             // cout << l << endl;\n//         }    \n\n//         // cout << l << endl;\n//         vector<int>::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target);\n//         vector<int>::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target);\n//         if( iter1 != nums.end() && *iter1 == target || iter2 != nums.end() && *iter2 == target)\n//             return true;\n//         else return false;\n//     }\n// };\n\nclass Solution {\npublic:\n\n    \n    bool search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1, mid, start = l;\n        while(l <= r){\n            mid = ( r + l) / 2;\n            if(nums[mid] == target)\n                return true;\n            else if(nums[mid] > nums[l]){\n                if(nums[l] <= target && target < nums[mid])\n                    r = mid - 1;\n                else l = mid + 1;\n            }\n            else if(nums[mid] < nums[l]){\n                if(nums[mid] < target && target <= nums[r])\n                    l = mid + 1;\n                else r = mid - 1; \n            }\n            else if(nums[mid] == nums[l])\n                l++;\n        }\n        return false;\n    }\n};\n\n```","source":"_posts/刷题/搜索/二分\n/81-Search-in-Rotated-Sorted-Array-II.md","raw":"---\ntitle: 81. Search in Rotated Sorted Array II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-28 17:02:19\n---\n\n\n\n## [81. Search in Rotated Sorted Array II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)\n\n\n\n\n\n\n\n\n\n## 思路：\n\n这题好像是33题的follow up。\n\n增添了各个元素可能相等的条件。\n\n没做出来。\n\n\n\n如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 `nums[mid]==nums[l]`那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。\n\n跳出这层，能不能直接在二分搜索呢？\n\n\n\n<!-- more -->\n\n> 参考题解\n>\n> ![image-20201030095548987](http://static.come2rss.xyz/image-20201030095548987.png)\n\n\n\n\n\n```c++\n// 失败的二分\n// class Solution {\n// public:\n\n    \n//     bool search(vector<int>& nums, int target) {\n//         int n = nums.size();\n//         int l = 0, r = n, mid, start = l;\n//         while(l < r){\n//             mid = (l + r) / 2;\n//             if(nums[mid] < nums[start]) r = mid;\n//             else if(nums[mid] == nums[start]) start++;\n//             else l = mid + 1;\n//             // cout << l << endl;\n//         }    \n\n//         // cout << l << endl;\n//         vector<int>::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target);\n//         vector<int>::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target);\n//         if( iter1 != nums.end() && *iter1 == target || iter2 != nums.end() && *iter2 == target)\n//             return true;\n//         else return false;\n//     }\n// };\n\nclass Solution {\npublic:\n\n    \n    bool search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int l = 0, r = n - 1, mid, start = l;\n        while(l <= r){\n            mid = ( r + l) / 2;\n            if(nums[mid] == target)\n                return true;\n            else if(nums[mid] > nums[l]){\n                if(nums[l] <= target && target < nums[mid])\n                    r = mid - 1;\n                else l = mid + 1;\n            }\n            else if(nums[mid] < nums[l]){\n                if(nums[mid] < target && target <= nums[r])\n                    l = mid + 1;\n                else r = mid - 1; \n            }\n            else if(nums[mid] == nums[l])\n                l++;\n        }\n        return false;\n    }\n};\n\n```","slug":"刷题-搜索-二分-81-Search-in-Rotated-Sorted-Array-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6c004al5uob4wz6byb","content":"<h2 id=\"81-Search-in-Rotated-Sorted-Array-II\"><a href=\"#81-Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"81. Search in Rotated Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/\">81. Search in Rotated Sorted Array II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题好像是33题的follow up。</p>\n<p>增添了各个元素可能相等的条件。</p>\n<p>没做出来。</p>\n<p>如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 <code>nums[mid]==nums[l]</code>那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。</p>\n<p>跳出这层，能不能直接在二分搜索呢？</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>参考题解</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201030095548987.png\" alt=\"image-20201030095548987\"></p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 失败的二分\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n\n    \n&#x2F;&#x2F;     bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         int l &#x3D; 0, r &#x3D; n, mid, start &#x3D; l;\n&#x2F;&#x2F;         while(l &lt; r)&#123;\n&#x2F;&#x2F;             mid &#x3D; (l + r) &#x2F; 2;\n&#x2F;&#x2F;             if(nums[mid] &lt; nums[start]) r &#x3D; mid;\n&#x2F;&#x2F;             else if(nums[mid] &#x3D;&#x3D; nums[start]) start++;\n&#x2F;&#x2F;             else l &#x3D; mid + 1;\n&#x2F;&#x2F;             &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         &#125;    \n\n&#x2F;&#x2F;         &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter1 &#x3D; std::lower_bound(nums.begin(), nums.begin() + l, target);\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter2 &#x3D; std::lower_bound(nums.begin() + l, nums.end(), target);\n&#x2F;&#x2F;         if( iter1 !&#x3D; nums.end() &amp;&amp; *iter1 &#x3D;&#x3D; target || iter2 !&#x3D; nums.end() &amp;&amp; *iter2 &#x3D;&#x3D; target)\n&#x2F;&#x2F;             return true;\n&#x2F;&#x2F;         else return false;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\nclass Solution &#123;\npublic:\n\n    \n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int n &#x3D; nums.size();\n        int l &#x3D; 0, r &#x3D; n - 1, mid, start &#x3D; l;\n        while(l &lt;&#x3D; r)&#123;\n            mid &#x3D; ( r + l) &#x2F; 2;\n            if(nums[mid] &#x3D;&#x3D; target)\n                return true;\n            else if(nums[mid] &gt; nums[l])&#123;\n                if(nums[l] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid])\n                    r &#x3D; mid - 1;\n                else l &#x3D; mid + 1;\n            &#125;\n            else if(nums[mid] &lt; nums[l])&#123;\n                if(nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[r])\n                    l &#x3D; mid + 1;\n                else r &#x3D; mid - 1; \n            &#125;\n            else if(nums[mid] &#x3D;&#x3D; nums[l])\n                l++;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"9K261R","excerpt":"<h2 id=\"81-Search-in-Rotated-Sorted-Array-II\"><a href=\"#81-Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"81. Search in Rotated Sorted Array II\"></a><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/\">81. Search in Rotated Sorted Array II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题好像是33题的follow up。</p>\n<p>增添了各个元素可能相等的条件。</p>\n<p>没做出来。</p>\n<p>如果考虑在上一题的思路，先寻找找出二分点，在二分两端数字。如果遇到 <code>nums[mid]==nums[l]</code>那就需要遍历确定哪边是相等的，巴拉巴拉……，多了一堆条件设置和条件判断。</p>\n<p>跳出这层，能不能直接在二分搜索呢？</p>","more":"<blockquote>\n<p>参考题解</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201030095548987.png\" alt=\"image-20201030095548987\"></p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 失败的二分\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n\n    \n&#x2F;&#x2F;     bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n&#x2F;&#x2F;         int n &#x3D; nums.size();\n&#x2F;&#x2F;         int l &#x3D; 0, r &#x3D; n, mid, start &#x3D; l;\n&#x2F;&#x2F;         while(l &lt; r)&#123;\n&#x2F;&#x2F;             mid &#x3D; (l + r) &#x2F; 2;\n&#x2F;&#x2F;             if(nums[mid] &lt; nums[start]) r &#x3D; mid;\n&#x2F;&#x2F;             else if(nums[mid] &#x3D;&#x3D; nums[start]) start++;\n&#x2F;&#x2F;             else l &#x3D; mid + 1;\n&#x2F;&#x2F;             &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         &#125;    \n\n&#x2F;&#x2F;         &#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; endl;\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter1 &#x3D; std::lower_bound(nums.begin(), nums.begin() + l, target);\n&#x2F;&#x2F;         vector&lt;int&gt;::iterator iter2 &#x3D; std::lower_bound(nums.begin() + l, nums.end(), target);\n&#x2F;&#x2F;         if( iter1 !&#x3D; nums.end() &amp;&amp; *iter1 &#x3D;&#x3D; target || iter2 !&#x3D; nums.end() &amp;&amp; *iter2 &#x3D;&#x3D; target)\n&#x2F;&#x2F;             return true;\n&#x2F;&#x2F;         else return false;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\nclass Solution &#123;\npublic:\n\n    \n    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int n &#x3D; nums.size();\n        int l &#x3D; 0, r &#x3D; n - 1, mid, start &#x3D; l;\n        while(l &lt;&#x3D; r)&#123;\n            mid &#x3D; ( r + l) &#x2F; 2;\n            if(nums[mid] &#x3D;&#x3D; target)\n                return true;\n            else if(nums[mid] &gt; nums[l])&#123;\n                if(nums[l] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid])\n                    r &#x3D; mid - 1;\n                else l &#x3D; mid + 1;\n            &#125;\n            else if(nums[mid] &lt; nums[l])&#123;\n                if(nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[r])\n                    l &#x3D; mid + 1;\n                else r &#x3D; mid - 1; \n            &#125;\n            else if(nums[mid] &#x3D;&#x3D; nums[l])\n                l++;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题-二分","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:30:40.000Z","_content":"\n\n\n收集查找二分查找相关题目\n\n\n\n## 面11：旋转数组\n\n<!-- more -->\n\n### 题面：\n\n旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。\n\n### 思路：\n\n一种就是直接遍历。\n\n更快地可是使用二分法查找元素。依据二分法，记指针有`A`，`B`，`mid`；。若有数组`array[mid]>=array[A]`则有`mid`在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则`mid`在后一个移动过的区间，应该向前半部分二分。\n\n但是由于题面说数据可能不是递增的，所以可能出现`array[A]=array[mid]=array[B]`的情况，这时如果`mid`指向移动过的区间就会出现错误，比如`1,0,1,1,1`，`A=0,B=4,mid=2`。如何避免呢？只能是直接遍历。\n\n> 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了`array[mid]<=array[A]`且`array[mid]>array[B]`，这个假设一提出来就显得非常的荒谬了。\n\n### 样例：\n\n```\n4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1\n```\n\n### 代码:\n\n```\nint Min(int* numbers, int length){\n    if(numbers == null || length <= 0) \n        throw new std::exception(\"Invalid parameters\");\n    int start = 0, end = length - 1, mid;\n    while(start < end){\n        int mid = ((end - start) >> 1) + start;\n        if(numbers[start] == numbers[mid] == numbers[end] ){\n            int minNum = numbers[0];\n            for(int i = 1; i < length; i++)\n                if( numbers[i] < minNum) minNum = numbers[i];\n            return minNum;\n        }\n        \n        if(numbers[mid] >= numbers[start]) start = mid + 1;\n        else end = mid;\n    }\n    return numbers[end];    \n}\n```\n\n## 面53:(待完成)\n\n### 题面：\n\n旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。\n\n### 思路：\n\n一种就是直接遍历。\n\n更快地可是使用二分法查找元素。依据二分法，记指针有`A`，`B`，`mid`；。若有数组`array[mid]>=array[A]`则有`mid`在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则`mid`在后一个移动过的区间，应该向前半部分二分。\n\n但是由于题面说数据可能不是递增的，所以可能出现`array[A]=array[mid]=array[B]`的情况，这时如果`mid`指向移动过的区间就会出现错误，比如`1,0,1,1,1`，`A=0,B=4,mid=2`。如何避免呢？只能是直接遍历。\n\n> 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了`array[mid]<=array[A]`且`array[mid]>array[B]`，这个假设一提出来就显得非常的荒谬了。\n\n### 样例：\n\n```\n4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1\n```\n\n### 代码:","source":"_posts/刷题/搜索/二分\n/面试题-二分.md","raw":"---\ntitle: 面试题-二分\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:30:40\n---\n\n\n\n收集查找二分查找相关题目\n\n\n\n## 面11：旋转数组\n\n<!-- more -->\n\n### 题面：\n\n旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。\n\n### 思路：\n\n一种就是直接遍历。\n\n更快地可是使用二分法查找元素。依据二分法，记指针有`A`，`B`，`mid`；。若有数组`array[mid]>=array[A]`则有`mid`在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则`mid`在后一个移动过的区间，应该向前半部分二分。\n\n但是由于题面说数据可能不是递增的，所以可能出现`array[A]=array[mid]=array[B]`的情况，这时如果`mid`指向移动过的区间就会出现错误，比如`1,0,1,1,1`，`A=0,B=4,mid=2`。如何避免呢？只能是直接遍历。\n\n> 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了`array[mid]<=array[A]`且`array[mid]>array[B]`，这个假设一提出来就显得非常的荒谬了。\n\n### 样例：\n\n```\n4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1\n```\n\n### 代码:\n\n```\nint Min(int* numbers, int length){\n    if(numbers == null || length <= 0) \n        throw new std::exception(\"Invalid parameters\");\n    int start = 0, end = length - 1, mid;\n    while(start < end){\n        int mid = ((end - start) >> 1) + start;\n        if(numbers[start] == numbers[mid] == numbers[end] ){\n            int minNum = numbers[0];\n            for(int i = 1; i < length; i++)\n                if( numbers[i] < minNum) minNum = numbers[i];\n            return minNum;\n        }\n        \n        if(numbers[mid] >= numbers[start]) start = mid + 1;\n        else end = mid;\n    }\n    return numbers[end];    \n}\n```\n\n## 面53:(待完成)\n\n### 题面：\n\n旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。\n\n### 思路：\n\n一种就是直接遍历。\n\n更快地可是使用二分法查找元素。依据二分法，记指针有`A`，`B`，`mid`；。若有数组`array[mid]>=array[A]`则有`mid`在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则`mid`在后一个移动过的区间，应该向前半部分二分。\n\n但是由于题面说数据可能不是递增的，所以可能出现`array[A]=array[mid]=array[B]`的情况，这时如果`mid`指向移动过的区间就会出现错误，比如`1,0,1,1,1`，`A=0,B=4,mid=2`。如何避免呢？只能是直接遍历。\n\n> 如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了`array[mid]<=array[A]`且`array[mid]>array[B]`，这个假设一提出来就显得非常的荒谬了。\n\n### 样例：\n\n```\n4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1\n```\n\n### 代码:","slug":"刷题-搜索-二分-面试题-二分","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6d004bl5uoeyo00ive","content":"<p>收集查找二分查找相关题目</p>\n<h2 id=\"面11：旋转数组\"><a href=\"#面11：旋转数组\" class=\"headerlink\" title=\"面11：旋转数组\"></a>面11：旋转数组</h2><span id=\"more\"></span>\n\n<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>一种就是直接遍历。</p>\n<p>更快地可是使用二分法查找元素。依据二分法，记指针有<code>A</code>，<code>B</code>，<code>mid</code>；。若有数组<code>array[mid]&gt;=array[A]</code>则有<code>mid</code>在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则<code>mid</code>在后一个移动过的区间，应该向前半部分二分。</p>\n<p>但是由于题面说数据可能不是递增的，所以可能出现<code>array[A]=array[mid]=array[B]</code>的情况，这时如果<code>mid</code>指向移动过的区间就会出现错误，比如<code>1,0,1,1,1</code>，<code>A=0,B=4,mid=2</code>。如何避免呢？只能是直接遍历。</p>\n<blockquote>\n<p>如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了<code>array[mid]&lt;=array[A]</code>且<code>array[mid]&gt;array[B]</code>，这个假设一提出来就显得非常的荒谬了。</p>\n</blockquote>\n<h3 id=\"样例：\"><a href=\"#样例：\" class=\"headerlink\" title=\"样例：\"></a>样例：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码:\"></a>代码:</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int Min(int* numbers, int length)&#123;\n    if(numbers &#x3D;&#x3D; null || length &lt;&#x3D; 0) \n        throw new std::exception(&quot;Invalid parameters&quot;);\n    int start &#x3D; 0, end &#x3D; length - 1, mid;\n    while(start &lt; end)&#123;\n        int mid &#x3D; ((end - start) &gt;&gt; 1) + start;\n        if(numbers[start] &#x3D;&#x3D; numbers[mid] &#x3D;&#x3D; numbers[end] )&#123;\n            int minNum &#x3D; numbers[0];\n            for(int i &#x3D; 1; i &lt; length; i++)\n                if( numbers[i] &lt; minNum) minNum &#x3D; numbers[i];\n            return minNum;\n        &#125;\n        \n        if(numbers[mid] &gt;&#x3D; numbers[start]) start &#x3D; mid + 1;\n        else end &#x3D; mid;\n    &#125;\n    return numbers[end];    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面53-待完成\"><a href=\"#面53-待完成\" class=\"headerlink\" title=\"面53:(待完成)\"></a>面53:(待完成)</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>一种就是直接遍历。</p>\n<p>更快地可是使用二分法查找元素。依据二分法，记指针有<code>A</code>，<code>B</code>，<code>mid</code>；。若有数组<code>array[mid]&gt;=array[A]</code>则有<code>mid</code>在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则<code>mid</code>在后一个移动过的区间，应该向前半部分二分。</p>\n<p>但是由于题面说数据可能不是递增的，所以可能出现<code>array[A]=array[mid]=array[B]</code>的情况，这时如果<code>mid</code>指向移动过的区间就会出现错误，比如<code>1,0,1,1,1</code>，<code>A=0,B=4,mid=2</code>。如何避免呢？只能是直接遍历。</p>\n<blockquote>\n<p>如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了<code>array[mid]&lt;=array[A]</code>且<code>array[mid]&gt;array[B]</code>，这个假设一提出来就显得非常的荒谬了。</p>\n</blockquote>\n<h3 id=\"样例：-1\"><a href=\"#样例：-1\" class=\"headerlink\" title=\"样例：\"></a>样例：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码:\"></a>代码:</h3>","site":{"data":{}},"abbrlink":"G7JB5T","excerpt":"<p>收集查找二分查找相关题目</p>\n<h2 id=\"面11：旋转数组\"><a href=\"#面11：旋转数组\" class=\"headerlink\" title=\"面11：旋转数组\"></a>面11：旋转数组</h2>","more":"<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>一种就是直接遍历。</p>\n<p>更快地可是使用二分法查找元素。依据二分法，记指针有<code>A</code>，<code>B</code>，<code>mid</code>；。若有数组<code>array[mid]&gt;=array[A]</code>则有<code>mid</code>在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则<code>mid</code>在后一个移动过的区间，应该向前半部分二分。</p>\n<p>但是由于题面说数据可能不是递增的，所以可能出现<code>array[A]=array[mid]=array[B]</code>的情况，这时如果<code>mid</code>指向移动过的区间就会出现错误，比如<code>1,0,1,1,1</code>，<code>A=0,B=4,mid=2</code>。如何避免呢？只能是直接遍历。</p>\n<blockquote>\n<p>如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了<code>array[mid]&lt;=array[A]</code>且<code>array[mid]&gt;array[B]</code>，这个假设一提出来就显得非常的荒谬了。</p>\n</blockquote>\n<h3 id=\"样例：\"><a href=\"#样例：\" class=\"headerlink\" title=\"样例：\"></a>样例：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码:\"></a>代码:</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int Min(int* numbers, int length)&#123;\n    if(numbers &#x3D;&#x3D; null || length &lt;&#x3D; 0) \n        throw new std::exception(&quot;Invalid parameters&quot;);\n    int start &#x3D; 0, end &#x3D; length - 1, mid;\n    while(start &lt; end)&#123;\n        int mid &#x3D; ((end - start) &gt;&gt; 1) + start;\n        if(numbers[start] &#x3D;&#x3D; numbers[mid] &#x3D;&#x3D; numbers[end] )&#123;\n            int minNum &#x3D; numbers[0];\n            for(int i &#x3D; 1; i &lt; length; i++)\n                if( numbers[i] &lt; minNum) minNum &#x3D; numbers[i];\n            return minNum;\n        &#125;\n        \n        if(numbers[mid] &gt;&#x3D; numbers[start]) start &#x3D; mid + 1;\n        else end &#x3D; mid;\n    &#125;\n    return numbers[end];    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面53-待完成\"><a href=\"#面53-待完成\" class=\"headerlink\" title=\"面53:(待完成)\"></a>面53:(待完成)</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>旋转数组即把数组的前一部分放到数组的末尾。现有一不递减数组经过旋转后，请找出数组内元素最小的数。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>一种就是直接遍历。</p>\n<p>更快地可是使用二分法查找元素。依据二分法，记指针有<code>A</code>，<code>B</code>，<code>mid</code>；。若有数组<code>array[mid]&gt;=array[A]</code>则有<code>mid</code>在前一个没有移动的区间（就是指没有被选择的部分，对应的就是指被旋转的部分），应该向后半部分继续二分。否则<code>mid</code>在后一个移动过的区间，应该向前半部分二分。</p>\n<p>但是由于题面说数据可能不是递增的，所以可能出现<code>array[A]=array[mid]=array[B]</code>的情况，这时如果<code>mid</code>指向移动过的区间就会出现错误，比如<code>1,0,1,1,1</code>，<code>A=0,B=4,mid=2</code>。如何避免呢？只能是直接遍历。</p>\n<blockquote>\n<p>如何发现设计算法错误呢？两种思路一种是给测试样例，另一种是判断算法本身是否有漏洞。像这里的二分法就假设了<code>array[mid]&lt;=array[A]</code>且<code>array[mid]&gt;array[B]</code>，这个假设一提出来就显得非常的荒谬了。</p>\n</blockquote>\n<h3 id=\"样例：-1\"><a href=\"#样例：-1\" class=\"headerlink\" title=\"样例：\"></a>样例：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">4,5,6,7,1,2,3\n1,1,0,1,1,1,1\n1,1,1,1,0,1,1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码:\"></a>代码:</h3>"},{"title":"面试题53 - II. 0～n-1中缺失的数字","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:10:15.000Z","_content":"\n<!-- more -->\n\n\n\n好菜啊，二分都不会了写了出了三个bug，还好检查的快。 Leecode的无调试debug还是相当锻炼人的。\n\n简单思路：hash一下每个数据，找出空白值即可。\n\n二分思路：依据前半部分有`nums[i] == i`的性质，和后半部分`nums[i] ！= i`的不同可以二分数据，从而找出错位的第一个数据。但是错位的数据不一定是缺少的数据，如果`i==len(nums)`就可能有缺失数据n−1n−1的可能性。\n\n\n\n```\ncpp\nclass Solution {\npublic:\n//     int missingNumber(vector<int>& nums) {\n//         int len = nums.size();\n//         int *hs = new int[len + 1];\n//         //未初始化，或者说函数中new的数组初始状态非零\n//         memset(hs,0, sizeof(int) * (len + 1) );\n//         for(int i = 0;i < len ; ++i) hs[nums[i]] = 1;\n//         for(int i = 0;i < len + 1; ++i)\n//             if( hs[i] == 0) \n//                 return i; \n//         return 0;\n//     }\n// };\n\n    int missingNumber(vector<int>& nums) {\n        int right = nums.size() - 1, left = 0, mid = right;\n        //bug1 边界情况\n        if(nums[right] == right) return right + 1;\n        while(left < right){\n            mid = (left + right) / 2;\n         //bug2 二分错误\n            if( nums[mid] == mid )\n                left = mid + 1;\n            else if( nums[mid] != mid)\n                right = mid;\n        }\n        //bug3 mid值没被更新, 而 left 和 right 都可以\n        return left;\n  w\n    }\n};\n\n```","source":"_posts/刷题/搜索/二分\n/面试题53-II-0～n-1中缺失的数字.md","raw":"---\ntitle: 面试题53 - II. 0～n-1中缺失的数字\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 14:10:15\n---\n\n<!-- more -->\n\n\n\n好菜啊，二分都不会了写了出了三个bug，还好检查的快。 Leecode的无调试debug还是相当锻炼人的。\n\n简单思路：hash一下每个数据，找出空白值即可。\n\n二分思路：依据前半部分有`nums[i] == i`的性质，和后半部分`nums[i] ！= i`的不同可以二分数据，从而找出错位的第一个数据。但是错位的数据不一定是缺少的数据，如果`i==len(nums)`就可能有缺失数据n−1n−1的可能性。\n\n\n\n```\ncpp\nclass Solution {\npublic:\n//     int missingNumber(vector<int>& nums) {\n//         int len = nums.size();\n//         int *hs = new int[len + 1];\n//         //未初始化，或者说函数中new的数组初始状态非零\n//         memset(hs,0, sizeof(int) * (len + 1) );\n//         for(int i = 0;i < len ; ++i) hs[nums[i]] = 1;\n//         for(int i = 0;i < len + 1; ++i)\n//             if( hs[i] == 0) \n//                 return i; \n//         return 0;\n//     }\n// };\n\n    int missingNumber(vector<int>& nums) {\n        int right = nums.size() - 1, left = 0, mid = right;\n        //bug1 边界情况\n        if(nums[right] == right) return right + 1;\n        while(left < right){\n            mid = (left + right) / 2;\n         //bug2 二分错误\n            if( nums[mid] == mid )\n                left = mid + 1;\n            else if( nums[mid] != mid)\n                right = mid;\n        }\n        //bug3 mid值没被更新, 而 left 和 right 都可以\n        return left;\n  w\n    }\n};\n\n```","slug":"刷题-搜索-二分-面试题53-II-0～n-1中缺失的数字","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6e004cl5uoe20ibbpq","content":"<span id=\"more\"></span>\n\n\n\n<p>好菜啊，二分都不会了写了出了三个bug，还好检查的快。 Leecode的无调试debug还是相当锻炼人的。</p>\n<p>简单思路：hash一下每个数据，找出空白值即可。</p>\n<p>二分思路：依据前半部分有<code>nums[i] == i</code>的性质，和后半部分<code>nums[i] ！= i</code>的不同可以二分数据，从而找出错位的第一个数据。但是错位的数据不一定是缺少的数据，如果<code>i==len(nums)</code>就可能有缺失数据n−1n−1的可能性。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cpp\nclass Solution &#123;\npublic:\n&#x2F;&#x2F;     int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n&#x2F;&#x2F;         int len &#x3D; nums.size();\n&#x2F;&#x2F;         int *hs &#x3D; new int[len + 1];\n&#x2F;&#x2F;         &#x2F;&#x2F;未初始化，或者说函数中new的数组初始状态非零\n&#x2F;&#x2F;         memset(hs,0, sizeof(int) * (len + 1) );\n&#x2F;&#x2F;         for(int i &#x3D; 0;i &lt; len ; ++i) hs[nums[i]] &#x3D; 1;\n&#x2F;&#x2F;         for(int i &#x3D; 0;i &lt; len + 1; ++i)\n&#x2F;&#x2F;             if( hs[i] &#x3D;&#x3D; 0) \n&#x2F;&#x2F;                 return i; \n&#x2F;&#x2F;         return 0;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\n    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int right &#x3D; nums.size() - 1, left &#x3D; 0, mid &#x3D; right;\n        &#x2F;&#x2F;bug1 边界情况\n        if(nums[right] &#x3D;&#x3D; right) return right + 1;\n        while(left &lt; right)&#123;\n            mid &#x3D; (left + right) &#x2F; 2;\n         &#x2F;&#x2F;bug2 二分错误\n            if( nums[mid] &#x3D;&#x3D; mid )\n                left &#x3D; mid + 1;\n            else if( nums[mid] !&#x3D; mid)\n                right &#x3D; mid;\n        &#125;\n        &#x2F;&#x2F;bug3 mid值没被更新, 而 left 和 right 都可以\n        return left;\n  w\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"29224CA","excerpt":"","more":"<p>好菜啊，二分都不会了写了出了三个bug，还好检查的快。 Leecode的无调试debug还是相当锻炼人的。</p>\n<p>简单思路：hash一下每个数据，找出空白值即可。</p>\n<p>二分思路：依据前半部分有<code>nums[i] == i</code>的性质，和后半部分<code>nums[i] ！= i</code>的不同可以二分数据，从而找出错位的第一个数据。但是错位的数据不一定是缺少的数据，如果<code>i==len(nums)</code>就可能有缺失数据n−1n−1的可能性。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">cpp\nclass Solution &#123;\npublic:\n&#x2F;&#x2F;     int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n&#x2F;&#x2F;         int len &#x3D; nums.size();\n&#x2F;&#x2F;         int *hs &#x3D; new int[len + 1];\n&#x2F;&#x2F;         &#x2F;&#x2F;未初始化，或者说函数中new的数组初始状态非零\n&#x2F;&#x2F;         memset(hs,0, sizeof(int) * (len + 1) );\n&#x2F;&#x2F;         for(int i &#x3D; 0;i &lt; len ; ++i) hs[nums[i]] &#x3D; 1;\n&#x2F;&#x2F;         for(int i &#x3D; 0;i &lt; len + 1; ++i)\n&#x2F;&#x2F;             if( hs[i] &#x3D;&#x3D; 0) \n&#x2F;&#x2F;                 return i; \n&#x2F;&#x2F;         return 0;\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\n    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n        int right &#x3D; nums.size() - 1, left &#x3D; 0, mid &#x3D; right;\n        &#x2F;&#x2F;bug1 边界情况\n        if(nums[right] &#x3D;&#x3D; right) return right + 1;\n        while(left &lt; right)&#123;\n            mid &#x3D; (left + right) &#x2F; 2;\n         &#x2F;&#x2F;bug2 二分错误\n            if( nums[mid] &#x3D;&#x3D; mid )\n                left &#x3D; mid + 1;\n            else if( nums[mid] !&#x3D; mid)\n                right &#x3D; mid;\n        &#125;\n        &#x2F;&#x2F;bug3 mid值没被更新, 而 left 和 right 都可以\n        return left;\n  w\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"37. Sudoku Solver","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-05T02:00:30.000Z","_content":"\n\n\n\n\n\n## [37. Sudoku Solver](https://leetcode-cn.com/problems/sudoku-solver/)\n\n\n\n## 思路：\n\ndfs搜索，可以用位运算优化，懒得看了\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n\npublic:\n    vector<vector<int>> col, row, cell;\n    vector<pair<int, int>> blank;\n    // int dx[4] = {0, 0, -1, 1};\n    // int dy[4] = {-1, 1, 0, 0};\n    int n;\n    int flag  = 0;\n    int getC(int x, int y){\n        return (x / 3) * 3 + y / 3;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        n = board.size();\n        row = cell = col = vector<vector<int>>(n, vector<int>(n + 1, 0)); //bugs: num -> idx\n        // cout << row[0][0];\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                if(board[i][j] == '.') {\n                    blank.push_back(make_pair(i, j));\n                    continue;\n                }\n                int t = board[i][j] - '0';                \n                row[i][t] = 1;\n                col[j][t] = 1;\n                cell[getC(i, j)][t] = 1;\n                \n            }\n        }\n        dfs(board, 0);\n    }\n    \n    void dfs(vector<vector<char>> &board, int pos){\n        // cout << pos << ' ' << flag << \" \" << blank.size() << endl;\n        if(flag || pos == blank.size()){\n            flag = 1;\n            return;\n        }\n        int x = blank[pos].first;\n        int y = blank[pos].second;\n        // cout << x << ' ' << y << endl;\n        if(board[x][y] == '.'){\n            for(int i = 1; i <= 9; ++i){\n                if(!row[x][i] && !col[y][i] && !cell[getC(x, y)][i]){\n                    // cout << i << \"@\" << endl;\n                    row[x][i] = 1;\n                    col[y][i] = 1;\n                    cell[getC(x, y)][i] = 1;\n                    board[x][y] = i + '0';\n                    dfs(board, pos + 1);\n                    if(flag) return;\n                    row[x][i] = 0;\n                    col[y][i] = 0;\n                    cell[getC(x, y)][i] = 0;\n                    board[x][y] = '.';\n                }\n            }\n        }\n\n    }\n};\n```","source":"_posts/刷题/搜索/回溯\n/37-Sudoku-Solver.md","raw":"---\ntitle: 37. Sudoku Solver\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-05 10:00:30\n---\n\n\n\n\n\n\n## [37. Sudoku Solver](https://leetcode-cn.com/problems/sudoku-solver/)\n\n\n\n## 思路：\n\ndfs搜索，可以用位运算优化，懒得看了\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n\npublic:\n    vector<vector<int>> col, row, cell;\n    vector<pair<int, int>> blank;\n    // int dx[4] = {0, 0, -1, 1};\n    // int dy[4] = {-1, 1, 0, 0};\n    int n;\n    int flag  = 0;\n    int getC(int x, int y){\n        return (x / 3) * 3 + y / 3;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        n = board.size();\n        row = cell = col = vector<vector<int>>(n, vector<int>(n + 1, 0)); //bugs: num -> idx\n        // cout << row[0][0];\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                if(board[i][j] == '.') {\n                    blank.push_back(make_pair(i, j));\n                    continue;\n                }\n                int t = board[i][j] - '0';                \n                row[i][t] = 1;\n                col[j][t] = 1;\n                cell[getC(i, j)][t] = 1;\n                \n            }\n        }\n        dfs(board, 0);\n    }\n    \n    void dfs(vector<vector<char>> &board, int pos){\n        // cout << pos << ' ' << flag << \" \" << blank.size() << endl;\n        if(flag || pos == blank.size()){\n            flag = 1;\n            return;\n        }\n        int x = blank[pos].first;\n        int y = blank[pos].second;\n        // cout << x << ' ' << y << endl;\n        if(board[x][y] == '.'){\n            for(int i = 1; i <= 9; ++i){\n                if(!row[x][i] && !col[y][i] && !cell[getC(x, y)][i]){\n                    // cout << i << \"@\" << endl;\n                    row[x][i] = 1;\n                    col[y][i] = 1;\n                    cell[getC(x, y)][i] = 1;\n                    board[x][y] = i + '0';\n                    dfs(board, pos + 1);\n                    if(flag) return;\n                    row[x][i] = 0;\n                    col[y][i] = 0;\n                    cell[getC(x, y)][i] = 0;\n                    board[x][y] = '.';\n                }\n            }\n        }\n\n    }\n};\n```","slug":"刷题-搜索-回溯-37-Sudoku-Solver","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6f004dl5uo225r8e3o","content":"<h2 id=\"37-Sudoku-Solver\"><a href=\"#37-Sudoku-Solver\" class=\"headerlink\" title=\"37. Sudoku Solver\"></a><a href=\"https://leetcode-cn.com/problems/sudoku-solver/\">37. Sudoku Solver</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dfs搜索，可以用位运算优化，懒得看了</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n\npublic:\n    vector&lt;vector&lt;int&gt;&gt; col, row, cell;\n    vector&lt;pair&lt;int, int&gt;&gt; blank;\n    &#x2F;&#x2F; int dx[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    &#x2F;&#x2F; int dy[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int n;\n    int flag  &#x3D; 0;\n    int getC(int x, int y)&#123;\n        return (x &#x2F; 3) * 3 + y &#x2F; 3;\n    &#125;\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        n &#x3D; board.size();\n        row &#x3D; cell &#x3D; col &#x3D; vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0)); &#x2F;&#x2F;bugs: num -&gt; idx\n        &#x2F;&#x2F; cout &lt;&lt; row[0][0];\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    blank.push_back(make_pair(i, j));\n                    continue;\n                &#125;\n                int t &#x3D; board[i][j] - &#39;0&#39;;                \n                row[i][t] &#x3D; 1;\n                col[j][t] &#x3D; 1;\n                cell[getC(i, j)][t] &#x3D; 1;\n                \n            &#125;\n        &#125;\n        dfs(board, 0);\n    &#125;\n    \n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board, int pos)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; pos &lt;&lt; &#39; &#39; &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; blank.size() &lt;&lt; endl;\n        if(flag || pos &#x3D;&#x3D; blank.size())&#123;\n            flag &#x3D; 1;\n            return;\n        &#125;\n        int x &#x3D; blank[pos].first;\n        int y &#x3D; blank[pos].second;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n        if(board[x][y] &#x3D;&#x3D; &#39;.&#39;)&#123;\n            for(int i &#x3D; 1; i &lt;&#x3D; 9; ++i)&#123;\n                if(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[getC(x, y)][i])&#123;\n                    &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot;@&quot; &lt;&lt; endl;\n                    row[x][i] &#x3D; 1;\n                    col[y][i] &#x3D; 1;\n                    cell[getC(x, y)][i] &#x3D; 1;\n                    board[x][y] &#x3D; i + &#39;0&#39;;\n                    dfs(board, pos + 1);\n                    if(flag) return;\n                    row[x][i] &#x3D; 0;\n                    col[y][i] &#x3D; 0;\n                    cell[getC(x, y)][i] &#x3D; 0;\n                    board[x][y] &#x3D; &#39;.&#39;;\n                &#125;\n            &#125;\n        &#125;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"PB41BR","excerpt":"<h2 id=\"37-Sudoku-Solver\"><a href=\"#37-Sudoku-Solver\" class=\"headerlink\" title=\"37. Sudoku Solver\"></a><a href=\"https://leetcode-cn.com/problems/sudoku-solver/\">37. Sudoku Solver</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dfs搜索，可以用位运算优化，懒得看了</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n\npublic:\n    vector&lt;vector&lt;int&gt;&gt; col, row, cell;\n    vector&lt;pair&lt;int, int&gt;&gt; blank;\n    &#x2F;&#x2F; int dx[4] &#x3D; &#123;0, 0, -1, 1&#125;;\n    &#x2F;&#x2F; int dy[4] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    int n;\n    int flag  &#x3D; 0;\n    int getC(int x, int y)&#123;\n        return (x &#x2F; 3) * 3 + y &#x2F; 3;\n    &#125;\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        n &#x3D; board.size();\n        row &#x3D; cell &#x3D; col &#x3D; vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0)); &#x2F;&#x2F;bugs: num -&gt; idx\n        &#x2F;&#x2F; cout &lt;&lt; row[0][0];\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                if(board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    blank.push_back(make_pair(i, j));\n                    continue;\n                &#125;\n                int t &#x3D; board[i][j] - &#39;0&#39;;                \n                row[i][t] &#x3D; 1;\n                col[j][t] &#x3D; 1;\n                cell[getC(i, j)][t] &#x3D; 1;\n                \n            &#125;\n        &#125;\n        dfs(board, 0);\n    &#125;\n    \n    void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board, int pos)&#123;\n        &#x2F;&#x2F; cout &lt;&lt; pos &lt;&lt; &#39; &#39; &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; blank.size() &lt;&lt; endl;\n        if(flag || pos &#x3D;&#x3D; blank.size())&#123;\n            flag &#x3D; 1;\n            return;\n        &#125;\n        int x &#x3D; blank[pos].first;\n        int y &#x3D; blank[pos].second;\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; endl;\n        if(board[x][y] &#x3D;&#x3D; &#39;.&#39;)&#123;\n            for(int i &#x3D; 1; i &lt;&#x3D; 9; ++i)&#123;\n                if(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[getC(x, y)][i])&#123;\n                    &#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot;@&quot; &lt;&lt; endl;\n                    row[x][i] &#x3D; 1;\n                    col[y][i] &#x3D; 1;\n                    cell[getC(x, y)][i] &#x3D; 1;\n                    board[x][y] &#x3D; i + &#39;0&#39;;\n                    dfs(board, pos + 1);\n                    if(flag) return;\n                    row[x][i] &#x3D; 0;\n                    col[y][i] &#x3D; 0;\n                    cell[getC(x, y)][i] &#x3D; 0;\n                    board[x][y] &#x3D; &#39;.&#39;;\n                &#125;\n            &#125;\n        &#125;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"37.解数独","thumbnail":"http://static.come2rss.xyz/moxige.jpg","toc":true,"top":10,"date":"2020-09-17T04:57:20.000Z","_content":"\n## [37 解数独](https://leetcode-cn.com/problems/sudoku-solver/)  - 位运算 回溯\n\n\n\n编写一个程序，通过已填充的空格来解决数独问题。\n\n一个数独的解法需遵循如下规则：\n\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n空白格用 '.' 表示。\n\n\n\n<!--more-->\n\n## 思路：\n\n回溯。\n\n错误想法：模拟平时玩数独的方法，寻找可能性最小的格子并确定，这种方法反而实现复杂，难以查找BUG。\n\n> 简单方法反而最有效\n\n## 扩展：\n\n如何计算复杂度？\n\n\n\n## 代码：\n\n### 1A\n\n```c++\n\n//错误代码\nclass Solution {\npublic:\n    const static int len = 9;\n    void print(vector<vector<char>> &board){\n        static int sum = 1;\n        printf(\"-----------------\\n%d \\n\", sum++);\n        if(sum < 5)  return;\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < len; j++)\n                printf(\"%c \", board[i][j]);\n            printf(\"\\n\");\n        }\n    }\n    void solveSudokuCore(vector<vector<char>> &board, vector<char> poss[][len], int &flag){\n         int minPoss = 20;\n         int x = -1, y = -1;\n        \n\n         //print\n         print(board);\n\n         if(flag == 0) return;\n         for(int i = 0; i < len; i++)\n         for(int j = 0; j < len; j++){\n             int size = poss[i][j].size();\n             if(size == 1){\n                // do it.\n                 board[i][j] = poss[i][j][0];\n                 poss[i][j].clear();\n                 // remove the impossible number.\n                 for(int t = 0; t < len; t++){\n                     vector<char> &rowP = poss[i][t];\n                     vector<char> &colP = poss[t][j];\n                     rowP.erase(remove(rowP.begin(), rowP.end(), board[i][j]), rowP.end());\n                     colP.erase(remove(colP.begin(), colP.end(), board[i][j]), colP.end());\n                 }\n                \n               // int block = (i % 3) * 3 + j / 3;\n                int x = i / 3 * 3;\n                int y = j % 3 * 3;\n                for(int p = x; p < x + 3; p++)\n                for(int q = y; q < y + 3; q++)\n                {\n                     vector<char> &vecP = poss[p][q];\n                     vecP.erase(remove(vecP.begin(), vecP.end(), board[i][j]), vecP.end());\n                }\n\n                solveSudokuCore(board, poss, flag);\n                return;\n             \n             }\n             // This is a bad path.\n            else if( size == 0 && board[i][j] == '.'){\n                printf(\"[End point]:%d %d\\n\", i, j);\n                return;\n            }\n            \n            // Find the minimum possibly grid;\n             else if(minPoss > size && size > 1){\n                minPoss = size;\n                x = i;\n                y = j;\n\n            }        \n         }\n\n         //The no more possbility. End the Search.\n         if(minPoss == 20){\n               flag = 0;\n               return;\n         }\n             \n         // there are none grid that has only one possible result.\n         vector<char> ans = poss[x][y];\n         poss[x][y].clear();\n         for(int i = 0; i < ans.size(); i++){            \n            poss[x][y].push_back(ans[i]);\n            solveSudokuCore(board, poss, flag);\n            poss[x][y].clear();\n         }  \n            \n         \n\n    }\n\n\n    void solveSudoku(vector<vector<char>>& board) {\n     \n        vector<char> pos[len][len];\n        bool hasNum[len + 1] = {0};\n        for(int i=0; i < len; i++)\n        for(int j=0; j < len; j++){\n            if(board[i][j] == '.'){\n\n                memset(hasNum, 0,  sizeof(bool) * (len + 1));\n                for(int k = 0; k < len; k++){\n                    if(board[k][j] != '.')\n                        hasNum[board[k][j] -'0'] = 1;\n                    if(board[i][k] != '.')\n                        hasNum[board[i][k] -'0'] = 1;\n                }                \n                int x = i / 3 * 3;\n                int y = j / 3 * 3;\n                for(int p = x; p < x + 3; p++)\n                    for(int q = y; q < y + 3; q++)\n                    {\n                        if(board[p][q] != '.')\n                            hasNum[board[p][q] - '0'] = 1;\n                    }\n                for(int l = 1; l < len + 1; l++)\n                    if(hasNum[l] == 0)\n                        pos[i][j].push_back(l + '0');        \n                \n            }\n        }\n        int flag  = 1;\n        solveSudokuCore(board, pos, flag);                  \n    }\n};\n\n\n//1A\nclass Solution {\npublic:\n    const static int len = 9;\n    void print(vector<vector<char>> &board, int x, int y){\n        static int sum = 1;\n        printf(\"-----------------\\n%d  %d  %d;\\n\", sum++, x, y);\n        if(sum < 8)  return;\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < len; j++)\n                printf(\"%c \", board[i][j]);\n            printf(\"\\n\");\n        }\n    }\n   \n    void solveSudoku(vector<vector<char>>& board) {\n     \n        int rowNum[len][len] = {0};\n        int colNum[len][len] = {0};\n        int cubeNum[len][len] = {0};\n        memset(rowNum, 0, sizeof(int) * len * len);\n        memset(colNum, 0, sizeof(int) * len * len);\n        memset(cubeNum, 0, sizeof(int) * len * len);\n\n        for(int i=0; i < len; i++)\n        for(int j=0; j < len; j++){\n            if(board[i][j] != '.'){\n                rowNum[i][board[i][j] - '0' - 1] = 1;\n                colNum[j][board[i][j] - '0' - 1] = 1;            \n                \n                int cube = i / 3 * 3 + j / 3;\n                cubeNum[cube][board[i][j] - '0' - 1] = 1;\n            }\n        }\n        int flag = 0;\n        solveSudokuCore(board, rowNum, colNum, cubeNum, 0, 0, flag);\n\n    }\n    void changeXY(int x , int y, int &nx, int &ny){\n        y++;\n        if(y == 9){\n            y = 0;\n            x++;\n        }\n        nx = x;\n        ny = y;\n    }\n    \n    void solveSudokuCore(vector<vector<char>> &board, int rowNum[][len], int colNum[][len], int cubeNum[][len], int x, int y, int &flag){\n       \t\t\t\t\t//回溯剪枝\n//        if(x == 8)\n  //         print(board, x, y);\n        if(x == 9){\n            flag = 1;\n            return;\n        } \n\n        int nx, ny;\n        if(board[x][y] == '.'){\n            for(int i = 0; i < len; i++){\n                int cube = (x / 3 * 3 + y / 3);\n                if(!rowNum[x][i] && !colNum[y][i] && !cubeNum[cube][i]){\n                    board[x][y] = i + 1 + '0';\n\n                    rowNum[x][i] = 1;\n                    colNum[y][i] = 1;\n                    cubeNum[cube][i] = 1;\n\n                    \n                    changeXY(x, y, nx, ny);\n                    solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n                    \n\t\t\t\t\t//回溯剪枝\n                     if(flag) return;\n                    board[x][y] = '.';\n                    rowNum[x][i] = 0;\n                    colNum[y][i] = 0;\n                    cubeNum[cube][i] = 0;\n\n                   \n                }\n            }\n        }\n        else{\n\n            changeXY(x, y, nx, ny);\n            solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n        }\n\n    }\n};\n```\n\n\n\n\n\n\n\n### 位运算版本\n\n```c++\n\nclass Solution {\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector<pair<int, int>> spaces;\n\npublic:\n    void flip(int i, int j, int digit) {\n        line[i] ^= (1 << digit);\n        column[j] ^= (1 << digit);\n        block[i / 3][j / 3] ^= (1 << digit);\n    }\n\n    void dfs(vector<vector<char>>& board, int pos) {\n        if (pos == spaces.size()) {\n            valid = true;\n            return;\n        }\n\n        auto [i, j] = spaces[pos];\n        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;\n        for (; mask && !valid; mask &= (mask - 1)) {\n            int digitMask = mask & (-mask);\n            int digit = __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] = digit + '0' + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        }\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid = false;\n\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] == '.') {\n                    spaces.emplace_back(i, j);\n                }\n                else {\n                    int digit = board[i][j] - '0' - 1;\n                    flip(i, j, digit);\n                }\n            }\n        }\n\n        dfs(board, 0);\n    }\n};\n```\n\n> 位运算技巧：\n>\n> ​\t取出最低位的1，其他位为零：`x & (-x)`\n>\n> ​\t消除最低位的1：`x & (x - 1 )`\n>\n> ​     变换第pos位：`x ^ (1 << pos)`\n>\n> 得到最低位1的序数（低位零的个数）：`__builtin_ctz(unsigned_int x)`\n\n\n\n### 优化\n\n```c++\nclass Solution {\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector<pair<int, int>> spaces;\n\npublic:\n    void flip(int i, int j, int digit) {\n        line[i] ^= (1 << digit);\n        column[j] ^= (1 << digit);\n        block[i / 3][j / 3] ^= (1 << digit);\n    }\n\n    void dfs(vector<vector<char>>& board, int pos) {\n        if (pos == spaces.size()) {\n            valid = true;\n            return;\n        }\n\n        auto [i, j] = spaces[pos];\n        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;\n        for (; mask && !valid; mask &= (mask - 1)) {\n            int digitMask = mask & (-mask);\n            int digit = __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] = digit + '0' + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        }\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid = false;\n\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] != '.') {\n                    int digit = board[i][j] - '0' - 1;\n                    flip(i, j, digit);\n                }\n            }\n        }\n        int len = 9;\n        bool flag = true;\n        while(flag){\n            flag = false;\n            for(int i = 0; i < len; i++){\n                for(int j = 0; j < len; j++){\n                    if(board[i][j] != '.') continue;\n                    int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1FF;\n                    if( !(mask & (mask - 1))){\n                        int digitnum = __builtin_ctz(mask & (-mask)) ;\n                        flip(i, j, digitnum);\n                        board[i][j] = digitnum + '0' + 1;\n                        flag = true;\n                    }\n                }\n            }\n\n        }\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] == '.') {\n                    spaces.emplace_back(i, j);\n                }\n            }\n        }\n\n        dfs(board, 0);\n    }\n};\n\n\n```\n\n\n\n","source":"_posts/刷题/搜索/回溯\n/37.解数独.md","raw":"---\ntitle: 37.解数独\nthumbnail: 'http://static.come2rss.xyz/moxige.jpg'\ntoc: true\ntop: 10\ncategories:\ntags:\n\ndate: 2020-09-17 12:57:20\n---\n\n## [37 解数独](https://leetcode-cn.com/problems/sudoku-solver/)  - 位运算 回溯\n\n\n\n编写一个程序，通过已填充的空格来解决数独问题。\n\n一个数独的解法需遵循如下规则：\n\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n空白格用 '.' 表示。\n\n\n\n<!--more-->\n\n## 思路：\n\n回溯。\n\n错误想法：模拟平时玩数独的方法，寻找可能性最小的格子并确定，这种方法反而实现复杂，难以查找BUG。\n\n> 简单方法反而最有效\n\n## 扩展：\n\n如何计算复杂度？\n\n\n\n## 代码：\n\n### 1A\n\n```c++\n\n//错误代码\nclass Solution {\npublic:\n    const static int len = 9;\n    void print(vector<vector<char>> &board){\n        static int sum = 1;\n        printf(\"-----------------\\n%d \\n\", sum++);\n        if(sum < 5)  return;\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < len; j++)\n                printf(\"%c \", board[i][j]);\n            printf(\"\\n\");\n        }\n    }\n    void solveSudokuCore(vector<vector<char>> &board, vector<char> poss[][len], int &flag){\n         int minPoss = 20;\n         int x = -1, y = -1;\n        \n\n         //print\n         print(board);\n\n         if(flag == 0) return;\n         for(int i = 0; i < len; i++)\n         for(int j = 0; j < len; j++){\n             int size = poss[i][j].size();\n             if(size == 1){\n                // do it.\n                 board[i][j] = poss[i][j][0];\n                 poss[i][j].clear();\n                 // remove the impossible number.\n                 for(int t = 0; t < len; t++){\n                     vector<char> &rowP = poss[i][t];\n                     vector<char> &colP = poss[t][j];\n                     rowP.erase(remove(rowP.begin(), rowP.end(), board[i][j]), rowP.end());\n                     colP.erase(remove(colP.begin(), colP.end(), board[i][j]), colP.end());\n                 }\n                \n               // int block = (i % 3) * 3 + j / 3;\n                int x = i / 3 * 3;\n                int y = j % 3 * 3;\n                for(int p = x; p < x + 3; p++)\n                for(int q = y; q < y + 3; q++)\n                {\n                     vector<char> &vecP = poss[p][q];\n                     vecP.erase(remove(vecP.begin(), vecP.end(), board[i][j]), vecP.end());\n                }\n\n                solveSudokuCore(board, poss, flag);\n                return;\n             \n             }\n             // This is a bad path.\n            else if( size == 0 && board[i][j] == '.'){\n                printf(\"[End point]:%d %d\\n\", i, j);\n                return;\n            }\n            \n            // Find the minimum possibly grid;\n             else if(minPoss > size && size > 1){\n                minPoss = size;\n                x = i;\n                y = j;\n\n            }        \n         }\n\n         //The no more possbility. End the Search.\n         if(minPoss == 20){\n               flag = 0;\n               return;\n         }\n             \n         // there are none grid that has only one possible result.\n         vector<char> ans = poss[x][y];\n         poss[x][y].clear();\n         for(int i = 0; i < ans.size(); i++){            \n            poss[x][y].push_back(ans[i]);\n            solveSudokuCore(board, poss, flag);\n            poss[x][y].clear();\n         }  \n            \n         \n\n    }\n\n\n    void solveSudoku(vector<vector<char>>& board) {\n     \n        vector<char> pos[len][len];\n        bool hasNum[len + 1] = {0};\n        for(int i=0; i < len; i++)\n        for(int j=0; j < len; j++){\n            if(board[i][j] == '.'){\n\n                memset(hasNum, 0,  sizeof(bool) * (len + 1));\n                for(int k = 0; k < len; k++){\n                    if(board[k][j] != '.')\n                        hasNum[board[k][j] -'0'] = 1;\n                    if(board[i][k] != '.')\n                        hasNum[board[i][k] -'0'] = 1;\n                }                \n                int x = i / 3 * 3;\n                int y = j / 3 * 3;\n                for(int p = x; p < x + 3; p++)\n                    for(int q = y; q < y + 3; q++)\n                    {\n                        if(board[p][q] != '.')\n                            hasNum[board[p][q] - '0'] = 1;\n                    }\n                for(int l = 1; l < len + 1; l++)\n                    if(hasNum[l] == 0)\n                        pos[i][j].push_back(l + '0');        \n                \n            }\n        }\n        int flag  = 1;\n        solveSudokuCore(board, pos, flag);                  \n    }\n};\n\n\n//1A\nclass Solution {\npublic:\n    const static int len = 9;\n    void print(vector<vector<char>> &board, int x, int y){\n        static int sum = 1;\n        printf(\"-----------------\\n%d  %d  %d;\\n\", sum++, x, y);\n        if(sum < 8)  return;\n        for(int i = 0; i < len; i++){\n            for(int j = 0; j < len; j++)\n                printf(\"%c \", board[i][j]);\n            printf(\"\\n\");\n        }\n    }\n   \n    void solveSudoku(vector<vector<char>>& board) {\n     \n        int rowNum[len][len] = {0};\n        int colNum[len][len] = {0};\n        int cubeNum[len][len] = {0};\n        memset(rowNum, 0, sizeof(int) * len * len);\n        memset(colNum, 0, sizeof(int) * len * len);\n        memset(cubeNum, 0, sizeof(int) * len * len);\n\n        for(int i=0; i < len; i++)\n        for(int j=0; j < len; j++){\n            if(board[i][j] != '.'){\n                rowNum[i][board[i][j] - '0' - 1] = 1;\n                colNum[j][board[i][j] - '0' - 1] = 1;            \n                \n                int cube = i / 3 * 3 + j / 3;\n                cubeNum[cube][board[i][j] - '0' - 1] = 1;\n            }\n        }\n        int flag = 0;\n        solveSudokuCore(board, rowNum, colNum, cubeNum, 0, 0, flag);\n\n    }\n    void changeXY(int x , int y, int &nx, int &ny){\n        y++;\n        if(y == 9){\n            y = 0;\n            x++;\n        }\n        nx = x;\n        ny = y;\n    }\n    \n    void solveSudokuCore(vector<vector<char>> &board, int rowNum[][len], int colNum[][len], int cubeNum[][len], int x, int y, int &flag){\n       \t\t\t\t\t//回溯剪枝\n//        if(x == 8)\n  //         print(board, x, y);\n        if(x == 9){\n            flag = 1;\n            return;\n        } \n\n        int nx, ny;\n        if(board[x][y] == '.'){\n            for(int i = 0; i < len; i++){\n                int cube = (x / 3 * 3 + y / 3);\n                if(!rowNum[x][i] && !colNum[y][i] && !cubeNum[cube][i]){\n                    board[x][y] = i + 1 + '0';\n\n                    rowNum[x][i] = 1;\n                    colNum[y][i] = 1;\n                    cubeNum[cube][i] = 1;\n\n                    \n                    changeXY(x, y, nx, ny);\n                    solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n                    \n\t\t\t\t\t//回溯剪枝\n                     if(flag) return;\n                    board[x][y] = '.';\n                    rowNum[x][i] = 0;\n                    colNum[y][i] = 0;\n                    cubeNum[cube][i] = 0;\n\n                   \n                }\n            }\n        }\n        else{\n\n            changeXY(x, y, nx, ny);\n            solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n        }\n\n    }\n};\n```\n\n\n\n\n\n\n\n### 位运算版本\n\n```c++\n\nclass Solution {\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector<pair<int, int>> spaces;\n\npublic:\n    void flip(int i, int j, int digit) {\n        line[i] ^= (1 << digit);\n        column[j] ^= (1 << digit);\n        block[i / 3][j / 3] ^= (1 << digit);\n    }\n\n    void dfs(vector<vector<char>>& board, int pos) {\n        if (pos == spaces.size()) {\n            valid = true;\n            return;\n        }\n\n        auto [i, j] = spaces[pos];\n        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;\n        for (; mask && !valid; mask &= (mask - 1)) {\n            int digitMask = mask & (-mask);\n            int digit = __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] = digit + '0' + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        }\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid = false;\n\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] == '.') {\n                    spaces.emplace_back(i, j);\n                }\n                else {\n                    int digit = board[i][j] - '0' - 1;\n                    flip(i, j, digit);\n                }\n            }\n        }\n\n        dfs(board, 0);\n    }\n};\n```\n\n> 位运算技巧：\n>\n> ​\t取出最低位的1，其他位为零：`x & (-x)`\n>\n> ​\t消除最低位的1：`x & (x - 1 )`\n>\n> ​     变换第pos位：`x ^ (1 << pos)`\n>\n> 得到最低位1的序数（低位零的个数）：`__builtin_ctz(unsigned_int x)`\n\n\n\n### 优化\n\n```c++\nclass Solution {\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector<pair<int, int>> spaces;\n\npublic:\n    void flip(int i, int j, int digit) {\n        line[i] ^= (1 << digit);\n        column[j] ^= (1 << digit);\n        block[i / 3][j / 3] ^= (1 << digit);\n    }\n\n    void dfs(vector<vector<char>>& board, int pos) {\n        if (pos == spaces.size()) {\n            valid = true;\n            return;\n        }\n\n        auto [i, j] = spaces[pos];\n        int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;\n        for (; mask && !valid; mask &= (mask - 1)) {\n            int digitMask = mask & (-mask);\n            int digit = __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] = digit + '0' + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        }\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid = false;\n\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] != '.') {\n                    int digit = board[i][j] - '0' - 1;\n                    flip(i, j, digit);\n                }\n            }\n        }\n        int len = 9;\n        bool flag = true;\n        while(flag){\n            flag = false;\n            for(int i = 0; i < len; i++){\n                for(int j = 0; j < len; j++){\n                    if(board[i][j] != '.') continue;\n                    int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1FF;\n                    if( !(mask & (mask - 1))){\n                        int digitnum = __builtin_ctz(mask & (-mask)) ;\n                        flip(i, j, digitnum);\n                        board[i][j] = digitnum + '0' + 1;\n                        flag = true;\n                    }\n                }\n            }\n\n        }\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                if (board[i][j] == '.') {\n                    spaces.emplace_back(i, j);\n                }\n            }\n        }\n\n        dfs(board, 0);\n    }\n};\n\n\n```\n\n\n\n","slug":"刷题-搜索-回溯-37-解数独","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6h004el5uoarlta7ij","content":"<h2 id=\"37-解数独-位运算-回溯\"><a href=\"#37-解数独-位运算-回溯\" class=\"headerlink\" title=\"37 解数独  - 位运算 回溯\"></a><a href=\"https://leetcode-cn.com/problems/sudoku-solver/\">37 解数独</a>  - 位运算 回溯</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p>\n<p>一个数独的解法需遵循如下规则：</p>\n<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 ‘.’ 表示。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯。</p>\n<p>错误想法：模拟平时玩数独的方法，寻找可能性最小的格子并确定，这种方法反而实现复杂，难以查找BUG。</p>\n<blockquote>\n<p>简单方法反而最有效</p>\n</blockquote>\n<h2 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h2><p>如何计算复杂度？</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><h3 id=\"1A\"><a href=\"#1A\" class=\"headerlink\" title=\"1A\"></a>1A</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;&#x2F;错误代码\nclass Solution &#123;\npublic:\n    const static int len &#x3D; 9;\n    void print(vector&lt;vector&lt;char&gt;&gt; &amp;board)&#123;\n        static int sum &#x3D; 1;\n        printf(&quot;-----------------\\n%d \\n&quot;, sum++);\n        if(sum &lt; 5)  return;\n        for(int i &#x3D; 0; i &lt; len; i++)&#123;\n            for(int j &#x3D; 0; j &lt; len; j++)\n                printf(&quot;%c &quot;, board[i][j]);\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, vector&lt;char&gt; poss[][len], int &amp;flag)&#123;\n         int minPoss &#x3D; 20;\n         int x &#x3D; -1, y &#x3D; -1;\n        \n\n         &#x2F;&#x2F;print\n         print(board);\n\n         if(flag &#x3D;&#x3D; 0) return;\n         for(int i &#x3D; 0; i &lt; len; i++)\n         for(int j &#x3D; 0; j &lt; len; j++)&#123;\n             int size &#x3D; poss[i][j].size();\n             if(size &#x3D;&#x3D; 1)&#123;\n                &#x2F;&#x2F; do it.\n                 board[i][j] &#x3D; poss[i][j][0];\n                 poss[i][j].clear();\n                 &#x2F;&#x2F; remove the impossible number.\n                 for(int t &#x3D; 0; t &lt; len; t++)&#123;\n                     vector&lt;char&gt; &amp;rowP &#x3D; poss[i][t];\n                     vector&lt;char&gt; &amp;colP &#x3D; poss[t][j];\n                     rowP.erase(remove(rowP.begin(), rowP.end(), board[i][j]), rowP.end());\n                     colP.erase(remove(colP.begin(), colP.end(), board[i][j]), colP.end());\n                 &#125;\n                \n               &#x2F;&#x2F; int block &#x3D; (i % 3) * 3 + j &#x2F; 3;\n                int x &#x3D; i &#x2F; 3 * 3;\n                int y &#x3D; j % 3 * 3;\n                for(int p &#x3D; x; p &lt; x + 3; p++)\n                for(int q &#x3D; y; q &lt; y + 3; q++)\n                &#123;\n                     vector&lt;char&gt; &amp;vecP &#x3D; poss[p][q];\n                     vecP.erase(remove(vecP.begin(), vecP.end(), board[i][j]), vecP.end());\n                &#125;\n\n                solveSudokuCore(board, poss, flag);\n                return;\n             \n             &#125;\n             &#x2F;&#x2F; This is a bad path.\n            else if( size &#x3D;&#x3D; 0 &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;.&#39;)&#123;\n                printf(&quot;[End point]:%d %d\\n&quot;, i, j);\n                return;\n            &#125;\n            \n            &#x2F;&#x2F; Find the minimum possibly grid;\n             else if(minPoss &gt; size &amp;&amp; size &gt; 1)&#123;\n                minPoss &#x3D; size;\n                x &#x3D; i;\n                y &#x3D; j;\n\n            &#125;        \n         &#125;\n\n         &#x2F;&#x2F;The no more possbility. End the Search.\n         if(minPoss &#x3D;&#x3D; 20)&#123;\n               flag &#x3D; 0;\n               return;\n         &#125;\n             \n         &#x2F;&#x2F; there are none grid that has only one possible result.\n         vector&lt;char&gt; ans &#x3D; poss[x][y];\n         poss[x][y].clear();\n         for(int i &#x3D; 0; i &lt; ans.size(); i++)&#123;            \n            poss[x][y].push_back(ans[i]);\n            solveSudokuCore(board, poss, flag);\n            poss[x][y].clear();\n         &#125;  \n            \n         \n\n    &#125;\n\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n     \n        vector&lt;char&gt; pos[len][len];\n        bool hasNum[len + 1] &#x3D; &#123;0&#125;;\n        for(int i&#x3D;0; i &lt; len; i++)\n        for(int j&#x3D;0; j &lt; len; j++)&#123;\n            if(board[i][j] &#x3D;&#x3D; &#39;.&#39;)&#123;\n\n                memset(hasNum, 0,  sizeof(bool) * (len + 1));\n                for(int k &#x3D; 0; k &lt; len; k++)&#123;\n                    if(board[k][j] !&#x3D; &#39;.&#39;)\n                        hasNum[board[k][j] -&#39;0&#39;] &#x3D; 1;\n                    if(board[i][k] !&#x3D; &#39;.&#39;)\n                        hasNum[board[i][k] -&#39;0&#39;] &#x3D; 1;\n                &#125;                \n                int x &#x3D; i &#x2F; 3 * 3;\n                int y &#x3D; j &#x2F; 3 * 3;\n                for(int p &#x3D; x; p &lt; x + 3; p++)\n                    for(int q &#x3D; y; q &lt; y + 3; q++)\n                    &#123;\n                        if(board[p][q] !&#x3D; &#39;.&#39;)\n                            hasNum[board[p][q] - &#39;0&#39;] &#x3D; 1;\n                    &#125;\n                for(int l &#x3D; 1; l &lt; len + 1; l++)\n                    if(hasNum[l] &#x3D;&#x3D; 0)\n                        pos[i][j].push_back(l + &#39;0&#39;);        \n                \n            &#125;\n        &#125;\n        int flag  &#x3D; 1;\n        solveSudokuCore(board, pos, flag);                  \n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;1A\nclass Solution &#123;\npublic:\n    const static int len &#x3D; 9;\n    void print(vector&lt;vector&lt;char&gt;&gt; &amp;board, int x, int y)&#123;\n        static int sum &#x3D; 1;\n        printf(&quot;-----------------\\n%d  %d  %d;\\n&quot;, sum++, x, y);\n        if(sum &lt; 8)  return;\n        for(int i &#x3D; 0; i &lt; len; i++)&#123;\n            for(int j &#x3D; 0; j &lt; len; j++)\n                printf(&quot;%c &quot;, board[i][j]);\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n   \n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n     \n        int rowNum[len][len] &#x3D; &#123;0&#125;;\n        int colNum[len][len] &#x3D; &#123;0&#125;;\n        int cubeNum[len][len] &#x3D; &#123;0&#125;;\n        memset(rowNum, 0, sizeof(int) * len * len);\n        memset(colNum, 0, sizeof(int) * len * len);\n        memset(cubeNum, 0, sizeof(int) * len * len);\n\n        for(int i&#x3D;0; i &lt; len; i++)\n        for(int j&#x3D;0; j &lt; len; j++)&#123;\n            if(board[i][j] !&#x3D; &#39;.&#39;)&#123;\n                rowNum[i][board[i][j] - &#39;0&#39; - 1] &#x3D; 1;\n                colNum[j][board[i][j] - &#39;0&#39; - 1] &#x3D; 1;            \n                \n                int cube &#x3D; i &#x2F; 3 * 3 + j &#x2F; 3;\n                cubeNum[cube][board[i][j] - &#39;0&#39; - 1] &#x3D; 1;\n            &#125;\n        &#125;\n        int flag &#x3D; 0;\n        solveSudokuCore(board, rowNum, colNum, cubeNum, 0, 0, flag);\n\n    &#125;\n    void changeXY(int x , int y, int &amp;nx, int &amp;ny)&#123;\n        y++;\n        if(y &#x3D;&#x3D; 9)&#123;\n            y &#x3D; 0;\n            x++;\n        &#125;\n        nx &#x3D; x;\n        ny &#x3D; y;\n    &#125;\n    \n    void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, int rowNum[][len], int colNum[][len], int cubeNum[][len], int x, int y, int &amp;flag)&#123;\n       \t\t\t\t\t&#x2F;&#x2F;回溯剪枝\n&#x2F;&#x2F;        if(x &#x3D;&#x3D; 8)\n  &#x2F;&#x2F;         print(board, x, y);\n        if(x &#x3D;&#x3D; 9)&#123;\n            flag &#x3D; 1;\n            return;\n        &#125; \n\n        int nx, ny;\n        if(board[x][y] &#x3D;&#x3D; &#39;.&#39;)&#123;\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                int cube &#x3D; (x &#x2F; 3 * 3 + y &#x2F; 3);\n                if(!rowNum[x][i] &amp;&amp; !colNum[y][i] &amp;&amp; !cubeNum[cube][i])&#123;\n                    board[x][y] &#x3D; i + 1 + &#39;0&#39;;\n\n                    rowNum[x][i] &#x3D; 1;\n                    colNum[y][i] &#x3D; 1;\n                    cubeNum[cube][i] &#x3D; 1;\n\n                    \n                    changeXY(x, y, nx, ny);\n                    solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n                    \n\t\t\t\t\t&#x2F;&#x2F;回溯剪枝\n                     if(flag) return;\n                    board[x][y] &#x3D; &#39;.&#39;;\n                    rowNum[x][i] &#x3D; 0;\n                    colNum[y][i] &#x3D; 0;\n                    cubeNum[cube][i] &#x3D; 0;\n\n                   \n                &#125;\n            &#125;\n        &#125;\n        else&#123;\n\n            changeXY(x, y, nx, ny);\n            solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n        &#125;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n\n\n<h3 id=\"位运算版本\"><a href=\"#位运算版本\" class=\"headerlink\" title=\"位运算版本\"></a>位运算版本</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector&lt;pair&lt;int, int&gt;&gt; spaces;\n\npublic:\n    void flip(int i, int j, int digit) &#123;\n        line[i] ^&#x3D; (1 &lt;&lt; digit);\n        column[j] ^&#x3D; (1 &lt;&lt; digit);\n        block[i &#x2F; 3][j &#x2F; 3] ^&#x3D; (1 &lt;&lt; digit);\n    &#125;\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;\n        if (pos &#x3D;&#x3D; spaces.size()) &#123;\n            valid &#x3D; true;\n            return;\n        &#125;\n\n        auto [i, j] &#x3D; spaces[pos];\n        int mask &#x3D; ~(line[i] | column[j] | block[i &#x2F; 3][j &#x2F; 3]) &amp; 0x1ff;\n        for (; mask &amp;&amp; !valid; mask &amp;&#x3D; (mask - 1)) &#123;\n            int digitMask &#x3D; mask &amp; (-mask);\n            int digit &#x3D; __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] &#x3D; digit + &#39;0&#39; + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        &#125;\n    &#125;\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid &#x3D; false;\n\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    spaces.emplace_back(i, j);\n                &#125;\n                else &#123;\n                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;\n                    flip(i, j, digit);\n                &#125;\n            &#125;\n        &#125;\n\n        dfs(board, 0);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>位运算技巧：</p>\n<p>​    取出最低位的1，其他位为零：<code>x &amp; (-x)</code></p>\n<p>​    消除最低位的1：<code>x &amp; (x - 1 )</code></p>\n<p>​     变换第pos位：<code>x ^ (1 &lt;&lt; pos)</code></p>\n<p>得到最低位1的序数（低位零的个数）：<code>__builtin_ctz(unsigned_int x)</code></p>\n</blockquote>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector&lt;pair&lt;int, int&gt;&gt; spaces;\n\npublic:\n    void flip(int i, int j, int digit) &#123;\n        line[i] ^&#x3D; (1 &lt;&lt; digit);\n        column[j] ^&#x3D; (1 &lt;&lt; digit);\n        block[i &#x2F; 3][j &#x2F; 3] ^&#x3D; (1 &lt;&lt; digit);\n    &#125;\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;\n        if (pos &#x3D;&#x3D; spaces.size()) &#123;\n            valid &#x3D; true;\n            return;\n        &#125;\n\n        auto [i, j] &#x3D; spaces[pos];\n        int mask &#x3D; ~(line[i] | column[j] | block[i &#x2F; 3][j &#x2F; 3]) &amp; 0x1ff;\n        for (; mask &amp;&amp; !valid; mask &amp;&#x3D; (mask - 1)) &#123;\n            int digitMask &#x3D; mask &amp; (-mask);\n            int digit &#x3D; __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] &#x3D; digit + &#39;0&#39; + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        &#125;\n    &#125;\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid &#x3D; false;\n\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] !&#x3D; &#39;.&#39;) &#123;\n                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;\n                    flip(i, j, digit);\n                &#125;\n            &#125;\n        &#125;\n        int len &#x3D; 9;\n        bool flag &#x3D; true;\n        while(flag)&#123;\n            flag &#x3D; false;\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                for(int j &#x3D; 0; j &lt; len; j++)&#123;\n                    if(board[i][j] !&#x3D; &#39;.&#39;) continue;\n                    int mask &#x3D; ~(line[i] | column[j] | block[i &#x2F; 3][j &#x2F; 3]) &amp; 0x1FF;\n                    if( !(mask &amp; (mask - 1)))&#123;\n                        int digitnum &#x3D; __builtin_ctz(mask &amp; (-mask)) ;\n                        flip(i, j, digitnum);\n                        board[i][j] &#x3D; digitnum + &#39;0&#39; + 1;\n                        flag &#x3D; true;\n                    &#125;\n                &#125;\n            &#125;\n\n        &#125;\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    spaces.emplace_back(i, j);\n                &#125;\n            &#125;\n        &#125;\n\n        dfs(board, 0);\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","site":{"data":{}},"abbrlink":"1RB2FFH","excerpt":"<h2 id=\"37-解数独-位运算-回溯\"><a href=\"#37-解数独-位运算-回溯\" class=\"headerlink\" title=\"37 解数独  - 位运算 回溯\"></a><a href=\"https://leetcode-cn.com/problems/sudoku-solver/\">37 解数独</a>  - 位运算 回溯</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p>\n<p>一个数独的解法需遵循如下规则：</p>\n<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 ‘.’ 表示。</p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯。</p>\n<p>错误想法：模拟平时玩数独的方法，寻找可能性最小的格子并确定，这种方法反而实现复杂，难以查找BUG。</p>\n<blockquote>\n<p>简单方法反而最有效</p>\n</blockquote>\n<h2 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h2><p>如何计算复杂度？</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><h3 id=\"1A\"><a href=\"#1A\" class=\"headerlink\" title=\"1A\"></a>1A</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;&#x2F;错误代码\nclass Solution &#123;\npublic:\n    const static int len &#x3D; 9;\n    void print(vector&lt;vector&lt;char&gt;&gt; &amp;board)&#123;\n        static int sum &#x3D; 1;\n        printf(&quot;-----------------\\n%d \\n&quot;, sum++);\n        if(sum &lt; 5)  return;\n        for(int i &#x3D; 0; i &lt; len; i++)&#123;\n            for(int j &#x3D; 0; j &lt; len; j++)\n                printf(&quot;%c &quot;, board[i][j]);\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, vector&lt;char&gt; poss[][len], int &amp;flag)&#123;\n         int minPoss &#x3D; 20;\n         int x &#x3D; -1, y &#x3D; -1;\n        \n\n         &#x2F;&#x2F;print\n         print(board);\n\n         if(flag &#x3D;&#x3D; 0) return;\n         for(int i &#x3D; 0; i &lt; len; i++)\n         for(int j &#x3D; 0; j &lt; len; j++)&#123;\n             int size &#x3D; poss[i][j].size();\n             if(size &#x3D;&#x3D; 1)&#123;\n                &#x2F;&#x2F; do it.\n                 board[i][j] &#x3D; poss[i][j][0];\n                 poss[i][j].clear();\n                 &#x2F;&#x2F; remove the impossible number.\n                 for(int t &#x3D; 0; t &lt; len; t++)&#123;\n                     vector&lt;char&gt; &amp;rowP &#x3D; poss[i][t];\n                     vector&lt;char&gt; &amp;colP &#x3D; poss[t][j];\n                     rowP.erase(remove(rowP.begin(), rowP.end(), board[i][j]), rowP.end());\n                     colP.erase(remove(colP.begin(), colP.end(), board[i][j]), colP.end());\n                 &#125;\n                \n               &#x2F;&#x2F; int block &#x3D; (i % 3) * 3 + j &#x2F; 3;\n                int x &#x3D; i &#x2F; 3 * 3;\n                int y &#x3D; j % 3 * 3;\n                for(int p &#x3D; x; p &lt; x + 3; p++)\n                for(int q &#x3D; y; q &lt; y + 3; q++)\n                &#123;\n                     vector&lt;char&gt; &amp;vecP &#x3D; poss[p][q];\n                     vecP.erase(remove(vecP.begin(), vecP.end(), board[i][j]), vecP.end());\n                &#125;\n\n                solveSudokuCore(board, poss, flag);\n                return;\n             \n             &#125;\n             &#x2F;&#x2F; This is a bad path.\n            else if( size &#x3D;&#x3D; 0 &amp;&amp; board[i][j] &#x3D;&#x3D; &#39;.&#39;)&#123;\n                printf(&quot;[End point]:%d %d\\n&quot;, i, j);\n                return;\n            &#125;\n            \n            &#x2F;&#x2F; Find the minimum possibly grid;\n             else if(minPoss &gt; size &amp;&amp; size &gt; 1)&#123;\n                minPoss &#x3D; size;\n                x &#x3D; i;\n                y &#x3D; j;\n\n            &#125;        \n         &#125;\n\n         &#x2F;&#x2F;The no more possbility. End the Search.\n         if(minPoss &#x3D;&#x3D; 20)&#123;\n               flag &#x3D; 0;\n               return;\n         &#125;\n             \n         &#x2F;&#x2F; there are none grid that has only one possible result.\n         vector&lt;char&gt; ans &#x3D; poss[x][y];\n         poss[x][y].clear();\n         for(int i &#x3D; 0; i &lt; ans.size(); i++)&#123;            \n            poss[x][y].push_back(ans[i]);\n            solveSudokuCore(board, poss, flag);\n            poss[x][y].clear();\n         &#125;  \n            \n         \n\n    &#125;\n\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n     \n        vector&lt;char&gt; pos[len][len];\n        bool hasNum[len + 1] &#x3D; &#123;0&#125;;\n        for(int i&#x3D;0; i &lt; len; i++)\n        for(int j&#x3D;0; j &lt; len; j++)&#123;\n            if(board[i][j] &#x3D;&#x3D; &#39;.&#39;)&#123;\n\n                memset(hasNum, 0,  sizeof(bool) * (len + 1));\n                for(int k &#x3D; 0; k &lt; len; k++)&#123;\n                    if(board[k][j] !&#x3D; &#39;.&#39;)\n                        hasNum[board[k][j] -&#39;0&#39;] &#x3D; 1;\n                    if(board[i][k] !&#x3D; &#39;.&#39;)\n                        hasNum[board[i][k] -&#39;0&#39;] &#x3D; 1;\n                &#125;                \n                int x &#x3D; i &#x2F; 3 * 3;\n                int y &#x3D; j &#x2F; 3 * 3;\n                for(int p &#x3D; x; p &lt; x + 3; p++)\n                    for(int q &#x3D; y; q &lt; y + 3; q++)\n                    &#123;\n                        if(board[p][q] !&#x3D; &#39;.&#39;)\n                            hasNum[board[p][q] - &#39;0&#39;] &#x3D; 1;\n                    &#125;\n                for(int l &#x3D; 1; l &lt; len + 1; l++)\n                    if(hasNum[l] &#x3D;&#x3D; 0)\n                        pos[i][j].push_back(l + &#39;0&#39;);        \n                \n            &#125;\n        &#125;\n        int flag  &#x3D; 1;\n        solveSudokuCore(board, pos, flag);                  \n    &#125;\n&#125;;\n\n\n&#x2F;&#x2F;1A\nclass Solution &#123;\npublic:\n    const static int len &#x3D; 9;\n    void print(vector&lt;vector&lt;char&gt;&gt; &amp;board, int x, int y)&#123;\n        static int sum &#x3D; 1;\n        printf(&quot;-----------------\\n%d  %d  %d;\\n&quot;, sum++, x, y);\n        if(sum &lt; 8)  return;\n        for(int i &#x3D; 0; i &lt; len; i++)&#123;\n            for(int j &#x3D; 0; j &lt; len; j++)\n                printf(&quot;%c &quot;, board[i][j]);\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n   \n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n     \n        int rowNum[len][len] &#x3D; &#123;0&#125;;\n        int colNum[len][len] &#x3D; &#123;0&#125;;\n        int cubeNum[len][len] &#x3D; &#123;0&#125;;\n        memset(rowNum, 0, sizeof(int) * len * len);\n        memset(colNum, 0, sizeof(int) * len * len);\n        memset(cubeNum, 0, sizeof(int) * len * len);\n\n        for(int i&#x3D;0; i &lt; len; i++)\n        for(int j&#x3D;0; j &lt; len; j++)&#123;\n            if(board[i][j] !&#x3D; &#39;.&#39;)&#123;\n                rowNum[i][board[i][j] - &#39;0&#39; - 1] &#x3D; 1;\n                colNum[j][board[i][j] - &#39;0&#39; - 1] &#x3D; 1;            \n                \n                int cube &#x3D; i &#x2F; 3 * 3 + j &#x2F; 3;\n                cubeNum[cube][board[i][j] - &#39;0&#39; - 1] &#x3D; 1;\n            &#125;\n        &#125;\n        int flag &#x3D; 0;\n        solveSudokuCore(board, rowNum, colNum, cubeNum, 0, 0, flag);\n\n    &#125;\n    void changeXY(int x , int y, int &amp;nx, int &amp;ny)&#123;\n        y++;\n        if(y &#x3D;&#x3D; 9)&#123;\n            y &#x3D; 0;\n            x++;\n        &#125;\n        nx &#x3D; x;\n        ny &#x3D; y;\n    &#125;\n    \n    void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, int rowNum[][len], int colNum[][len], int cubeNum[][len], int x, int y, int &amp;flag)&#123;\n       \t\t\t\t\t&#x2F;&#x2F;回溯剪枝\n&#x2F;&#x2F;        if(x &#x3D;&#x3D; 8)\n  &#x2F;&#x2F;         print(board, x, y);\n        if(x &#x3D;&#x3D; 9)&#123;\n            flag &#x3D; 1;\n            return;\n        &#125; \n\n        int nx, ny;\n        if(board[x][y] &#x3D;&#x3D; &#39;.&#39;)&#123;\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                int cube &#x3D; (x &#x2F; 3 * 3 + y &#x2F; 3);\n                if(!rowNum[x][i] &amp;&amp; !colNum[y][i] &amp;&amp; !cubeNum[cube][i])&#123;\n                    board[x][y] &#x3D; i + 1 + &#39;0&#39;;\n\n                    rowNum[x][i] &#x3D; 1;\n                    colNum[y][i] &#x3D; 1;\n                    cubeNum[cube][i] &#x3D; 1;\n\n                    \n                    changeXY(x, y, nx, ny);\n                    solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n                    \n\t\t\t\t\t&#x2F;&#x2F;回溯剪枝\n                     if(flag) return;\n                    board[x][y] &#x3D; &#39;.&#39;;\n                    rowNum[x][i] &#x3D; 0;\n                    colNum[y][i] &#x3D; 0;\n                    cubeNum[cube][i] &#x3D; 0;\n\n                   \n                &#125;\n            &#125;\n        &#125;\n        else&#123;\n\n            changeXY(x, y, nx, ny);\n            solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag);\n        &#125;\n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n\n\n<h3 id=\"位运算版本\"><a href=\"#位运算版本\" class=\"headerlink\" title=\"位运算版本\"></a>位运算版本</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector&lt;pair&lt;int, int&gt;&gt; spaces;\n\npublic:\n    void flip(int i, int j, int digit) &#123;\n        line[i] ^&#x3D; (1 &lt;&lt; digit);\n        column[j] ^&#x3D; (1 &lt;&lt; digit);\n        block[i &#x2F; 3][j &#x2F; 3] ^&#x3D; (1 &lt;&lt; digit);\n    &#125;\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;\n        if (pos &#x3D;&#x3D; spaces.size()) &#123;\n            valid &#x3D; true;\n            return;\n        &#125;\n\n        auto [i, j] &#x3D; spaces[pos];\n        int mask &#x3D; ~(line[i] | column[j] | block[i &#x2F; 3][j &#x2F; 3]) &amp; 0x1ff;\n        for (; mask &amp;&amp; !valid; mask &amp;&#x3D; (mask - 1)) &#123;\n            int digitMask &#x3D; mask &amp; (-mask);\n            int digit &#x3D; __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] &#x3D; digit + &#39;0&#39; + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        &#125;\n    &#125;\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid &#x3D; false;\n\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    spaces.emplace_back(i, j);\n                &#125;\n                else &#123;\n                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;\n                    flip(i, j, digit);\n                &#125;\n            &#125;\n        &#125;\n\n        dfs(board, 0);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>位运算技巧：</p>\n<p>​    取出最低位的1，其他位为零：<code>x &amp; (-x)</code></p>\n<p>​    消除最低位的1：<code>x &amp; (x - 1 )</code></p>\n<p>​     变换第pos位：<code>x ^ (1 &lt;&lt; pos)</code></p>\n<p>得到最低位1的序数（低位零的个数）：<code>__builtin_ctz(unsigned_int x)</code></p>\n</blockquote>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\nprivate:\n    int line[9];\n    int column[9];\n    int block[3][3];\n    bool valid;\n    vector&lt;pair&lt;int, int&gt;&gt; spaces;\n\npublic:\n    void flip(int i, int j, int digit) &#123;\n        line[i] ^&#x3D; (1 &lt;&lt; digit);\n        column[j] ^&#x3D; (1 &lt;&lt; digit);\n        block[i &#x2F; 3][j &#x2F; 3] ^&#x3D; (1 &lt;&lt; digit);\n    &#125;\n\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;\n        if (pos &#x3D;&#x3D; spaces.size()) &#123;\n            valid &#x3D; true;\n            return;\n        &#125;\n\n        auto [i, j] &#x3D; spaces[pos];\n        int mask &#x3D; ~(line[i] | column[j] | block[i &#x2F; 3][j &#x2F; 3]) &amp; 0x1ff;\n        for (; mask &amp;&amp; !valid; mask &amp;&#x3D; (mask - 1)) &#123;\n            int digitMask &#x3D; mask &amp; (-mask);\n            int digit &#x3D; __builtin_ctz(digitMask);\n            flip(i, j, digit);\n            board[i][j] &#x3D; digit + &#39;0&#39; + 1;\n            dfs(board, pos + 1);\n            flip(i, j, digit);\n        &#125;\n    &#125;\n\n    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;\n        memset(line, 0, sizeof(line));\n        memset(column, 0, sizeof(column));\n        memset(block, 0, sizeof(block));\n        valid &#x3D; false;\n\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] !&#x3D; &#39;.&#39;) &#123;\n                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;\n                    flip(i, j, digit);\n                &#125;\n            &#125;\n        &#125;\n        int len &#x3D; 9;\n        bool flag &#x3D; true;\n        while(flag)&#123;\n            flag &#x3D; false;\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                for(int j &#x3D; 0; j &lt; len; j++)&#123;\n                    if(board[i][j] !&#x3D; &#39;.&#39;) continue;\n                    int mask &#x3D; ~(line[i] | column[j] | block[i &#x2F; 3][j &#x2F; 3]) &amp; 0x1FF;\n                    if( !(mask &amp; (mask - 1)))&#123;\n                        int digitnum &#x3D; __builtin_ctz(mask &amp; (-mask)) ;\n                        flip(i, j, digitnum);\n                        board[i][j] &#x3D; digitnum + &#39;0&#39; + 1;\n                        flag &#x3D; true;\n                    &#125;\n                &#125;\n            &#125;\n\n        &#125;\n        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;\n            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;\n                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;\n                    spaces.emplace_back(i, j);\n                &#125;\n            &#125;\n        &#125;\n\n        dfs(board, 0);\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"39. Combination Sum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-04T01:50:26.000Z","_content":"\n\n\n## [39. Combination Sum](https://leetcode-cn.com/problems/combination-sum/)\n\n> 在dfs搜索题中，形象化一个dfs搜索树是一个非常有趣的，形象的描述方法。比如下面这个没有剪枝的dfs搜索树。也可以比较一下，下面两种解法的dfs搜索树的不同之处。\n>\n> ![img](http://static.come2rss.xyz/1598091943-hZjibJ-file_1598091940241)\n\n<!-- more -->\n\n## 思路：\n\ndfs搜索剪枝代码。非常标准的一道搜索题。\n\n> 官方给出的时间复杂度分析\n>\n> ![image-20201204092517420](http://static.come2rss.xyz/image-20201204092517420.png)\n\n## 代码：\n\n\n\n66%\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>()); //sort优化顺序 33%->47%\n        vector<int> aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    }\n\n    void dfsCombinate(vector<int>& candidates, vector<int>& aim, int target, int pos){\n        if(pos == candidates.size()) return;\n        if(target <=0){\n            if(target == 0){\n                res.push_back(aim);\n            }\n            return;\n        }\n        aim.push_back(candidates[pos]);\n        dfsCombinate(candidates, aim, target - candidates[pos], pos);\n        aim.pop_back();\n        dfsCombinate(candidates, aim, target, pos + 1);\n    }\n};\n```\n\n\n\n99%\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>()); //sort优化顺序 33%->47%\n        vector<int> aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    }\n\n    void dfsCombinate(vector<int>& candidates, vector<int>& aim, int target, int pos){        \n        \n        if(target == 0){\n            res.push_back(aim);\n            return;\n        }                \n        for(int i = pos;i < candidates.size(); ++i){ //for循环代替递归寻找，减少函数调用，增加效率\n            if(candidates[i] > target) break;\n            if(i > pos && candidates[i] == candidates[i - 1]) continue; // 重复数字无需再判断\n            aim.push_back(candidates[i]);\n            dfsCombinate(candidates, aim, target - candidates[i],i);\n            aim.pop_back();\n        }            \n    }\n};\n```","source":"_posts/刷题/搜索/回溯\n/39-Combination-Sum.md","raw":"---\ntitle: 39. Combination Sum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-04 09:50:26\n---\n\n\n\n## [39. Combination Sum](https://leetcode-cn.com/problems/combination-sum/)\n\n> 在dfs搜索题中，形象化一个dfs搜索树是一个非常有趣的，形象的描述方法。比如下面这个没有剪枝的dfs搜索树。也可以比较一下，下面两种解法的dfs搜索树的不同之处。\n>\n> ![img](http://static.come2rss.xyz/1598091943-hZjibJ-file_1598091940241)\n\n<!-- more -->\n\n## 思路：\n\ndfs搜索剪枝代码。非常标准的一道搜索题。\n\n> 官方给出的时间复杂度分析\n>\n> ![image-20201204092517420](http://static.come2rss.xyz/image-20201204092517420.png)\n\n## 代码：\n\n\n\n66%\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>()); //sort优化顺序 33%->47%\n        vector<int> aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    }\n\n    void dfsCombinate(vector<int>& candidates, vector<int>& aim, int target, int pos){\n        if(pos == candidates.size()) return;\n        if(target <=0){\n            if(target == 0){\n                res.push_back(aim);\n            }\n            return;\n        }\n        aim.push_back(candidates[pos]);\n        dfsCombinate(candidates, aim, target - candidates[pos], pos);\n        aim.pop_back();\n        dfsCombinate(candidates, aim, target, pos + 1);\n    }\n};\n```\n\n\n\n99%\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>()); //sort优化顺序 33%->47%\n        vector<int> aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    }\n\n    void dfsCombinate(vector<int>& candidates, vector<int>& aim, int target, int pos){        \n        \n        if(target == 0){\n            res.push_back(aim);\n            return;\n        }                \n        for(int i = pos;i < candidates.size(); ++i){ //for循环代替递归寻找，减少函数调用，增加效率\n            if(candidates[i] > target) break;\n            if(i > pos && candidates[i] == candidates[i - 1]) continue; // 重复数字无需再判断\n            aim.push_back(candidates[i]);\n            dfsCombinate(candidates, aim, target - candidates[i],i);\n            aim.pop_back();\n        }            \n    }\n};\n```","slug":"刷题-搜索-回溯-39-Combination-Sum","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6h004fl5uoaaox4jwr","content":"<h2 id=\"39-Combination-Sum\"><a href=\"#39-Combination-Sum\" class=\"headerlink\" title=\"39. Combination Sum\"></a><a href=\"https://leetcode-cn.com/problems/combination-sum/\">39. Combination Sum</a></h2><blockquote>\n<p>在dfs搜索题中，形象化一个dfs搜索树是一个非常有趣的，形象的描述方法。比如下面这个没有剪枝的dfs搜索树。也可以比较一下，下面两种解法的dfs搜索树的不同之处。</p>\n<p><img src=\"http://static.come2rss.xyz/1598091943-hZjibJ-file_1598091940241\" alt=\"img\"></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dfs搜索剪枝代码。非常标准的一道搜索题。</p>\n<blockquote>\n<p>官方给出的时间复杂度分析</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201204092517420.png\" alt=\"image-20201204092517420\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>66%</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); &#x2F;&#x2F;sort优化顺序 33%-&gt;47%\n        vector&lt;int&gt; aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    &#125;\n\n    void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos)&#123;\n        if(pos &#x3D;&#x3D; candidates.size()) return;\n        if(target &lt;&#x3D;0)&#123;\n            if(target &#x3D;&#x3D; 0)&#123;\n                res.push_back(aim);\n            &#125;\n            return;\n        &#125;\n        aim.push_back(candidates[pos]);\n        dfsCombinate(candidates, aim, target - candidates[pos], pos);\n        aim.pop_back();\n        dfsCombinate(candidates, aim, target, pos + 1);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>99%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); &#x2F;&#x2F;sort优化顺序 33%-&gt;47%\n        vector&lt;int&gt; aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    &#125;\n\n    void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos)&#123;        \n        \n        if(target &#x3D;&#x3D; 0)&#123;\n            res.push_back(aim);\n            return;\n        &#125;                \n        for(int i &#x3D; pos;i &lt; candidates.size(); ++i)&#123; &#x2F;&#x2F;for循环代替递归寻找，减少函数调用，增加效率\n            if(candidates[i] &gt; target) break;\n            if(i &gt; pos &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1]) continue; &#x2F;&#x2F; 重复数字无需再判断\n            aim.push_back(candidates[i]);\n            dfsCombinate(candidates, aim, target - candidates[i],i);\n            aim.pop_back();\n        &#125;            \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3D0ETC7","excerpt":"<h2 id=\"39-Combination-Sum\"><a href=\"#39-Combination-Sum\" class=\"headerlink\" title=\"39. Combination Sum\"></a><a href=\"https://leetcode-cn.com/problems/combination-sum/\">39. Combination Sum</a></h2><blockquote>\n<p>在dfs搜索题中，形象化一个dfs搜索树是一个非常有趣的，形象的描述方法。比如下面这个没有剪枝的dfs搜索树。也可以比较一下，下面两种解法的dfs搜索树的不同之处。</p>\n<p><img src=\"http://static.come2rss.xyz/1598091943-hZjibJ-file_1598091940241\" alt=\"img\"></p>\n</blockquote>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>dfs搜索剪枝代码。非常标准的一道搜索题。</p>\n<blockquote>\n<p>官方给出的时间复杂度分析</p>\n<p><img src=\"http://static.come2rss.xyz/image-20201204092517420.png\" alt=\"image-20201204092517420\"></p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>66%</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); &#x2F;&#x2F;sort优化顺序 33%-&gt;47%\n        vector&lt;int&gt; aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    &#125;\n\n    void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos)&#123;\n        if(pos &#x3D;&#x3D; candidates.size()) return;\n        if(target &lt;&#x3D;0)&#123;\n            if(target &#x3D;&#x3D; 0)&#123;\n                res.push_back(aim);\n            &#125;\n            return;\n        &#125;\n        aim.push_back(candidates[pos]);\n        dfsCombinate(candidates, aim, target - candidates[pos], pos);\n        aim.pop_back();\n        dfsCombinate(candidates, aim, target, pos + 1);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>99%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); &#x2F;&#x2F;sort优化顺序 33%-&gt;47%\n        vector&lt;int&gt; aim;\n\n        dfsCombinate(candidates, aim, target, 0);\n        return res;\n    &#125;\n\n    void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos)&#123;        \n        \n        if(target &#x3D;&#x3D; 0)&#123;\n            res.push_back(aim);\n            return;\n        &#125;                \n        for(int i &#x3D; pos;i &lt; candidates.size(); ++i)&#123; &#x2F;&#x2F;for循环代替递归寻找，减少函数调用，增加效率\n            if(candidates[i] &gt; target) break;\n            if(i &gt; pos &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1]) continue; &#x2F;&#x2F; 重复数字无需再判断\n            aim.push_back(candidates[i]);\n            dfsCombinate(candidates, aim, target - candidates[i],i);\n            aim.pop_back();\n        &#125;            \n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"40. Combination Sum II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-04T01:50:35.000Z","_content":"\n\n\n\n## [40. Combination Sum II](https://leetcode-cn.com/problems/combination-sum-ii/)\n\n\n\n\n\n## 思路：\n\n1. 用map记录数字出现次数，转化为普通的dfs\n2. 避免在填充`idx`数字的时候，遍历到重复数字，即可。无需map记录数字。是一种成熟的避免重复数字的方法。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n40%\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> ct;\n    vector<int> arr;\n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>());\n        for(auto i : candidates){\n            ct[i]++;\n            if(ct[i] == 1) arr.push_back(i);    \n        }\n        vector<int> aim;\n        dfs(aim, 0, target);\n        return res;\n    }\n    void dfs(vector<int> &aim, int pos, int target){\n        if(target == 0){\n            res.push_back(aim);\n            return;\n        }\n        for(int i = pos; i < arr.size(); ++i){        \n            if(arr[i] > target) break;\n            if(ct[arr[i]] == 0) continue; //ct[arr[i]]必行存在\n            aim.push_back(arr[i]);\n            ct[arr[i]]--;\n            dfs(aim, i, target - arr[i]);\n            ct[arr[i]]++;\n            aim.pop_back();\n        }\n    }\n};\n```\n\n\n\n98%\n\n```c++\nclass Solution {\npublic:   \n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>());        \n        vector<int> aim;\n        dfs(candidates,aim, 0, target);\n        return res;\n    }\n    void dfs(vector<int>& candidates, vector<int> &aim, int pos, int target){\n        // for(auto i : aim){\n        //     cout << i << ' ' ;\n        // }\n        // cout << endl;\n        if(target == 0){\n            res.push_back(aim);\n            return;\n        }\n        for(int i = pos; i < candidates.size() && candidates[i] <= target; ++i){\n            //在一层的搜索中选择不重复的数字，同时巧妙的维持了可搜索上一层数字的状态\n            if(i > 0 && i > pos && candidates[i] == candidates[i - 1]) continue; \n            aim.push_back(candidates[i]);            \n            \n            dfs(candidates, aim, i + 1, target - candidates[i]);\n            aim.pop_back();\n        }\n    }\n};\n```","source":"_posts/刷题/搜索/回溯\n/40-Combination-Sum-II.md","raw":"---\ntitle: 40. Combination Sum II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-04 09:50:35\n---\n\n\n\n\n## [40. Combination Sum II](https://leetcode-cn.com/problems/combination-sum-ii/)\n\n\n\n\n\n## 思路：\n\n1. 用map记录数字出现次数，转化为普通的dfs\n2. 避免在填充`idx`数字的时候，遍历到重复数字，即可。无需map记录数字。是一种成熟的避免重复数字的方法。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n40%\n\n```c++\nclass Solution {\npublic:\n    unordered_map<int, int> ct;\n    vector<int> arr;\n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>());\n        for(auto i : candidates){\n            ct[i]++;\n            if(ct[i] == 1) arr.push_back(i);    \n        }\n        vector<int> aim;\n        dfs(aim, 0, target);\n        return res;\n    }\n    void dfs(vector<int> &aim, int pos, int target){\n        if(target == 0){\n            res.push_back(aim);\n            return;\n        }\n        for(int i = pos; i < arr.size(); ++i){        \n            if(arr[i] > target) break;\n            if(ct[arr[i]] == 0) continue; //ct[arr[i]]必行存在\n            aim.push_back(arr[i]);\n            ct[arr[i]]--;\n            dfs(aim, i, target - arr[i]);\n            ct[arr[i]]++;\n            aim.pop_back();\n        }\n    }\n};\n```\n\n\n\n98%\n\n```c++\nclass Solution {\npublic:   \n    vector<vector<int>> res;\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end(), less<int>());        \n        vector<int> aim;\n        dfs(candidates,aim, 0, target);\n        return res;\n    }\n    void dfs(vector<int>& candidates, vector<int> &aim, int pos, int target){\n        // for(auto i : aim){\n        //     cout << i << ' ' ;\n        // }\n        // cout << endl;\n        if(target == 0){\n            res.push_back(aim);\n            return;\n        }\n        for(int i = pos; i < candidates.size() && candidates[i] <= target; ++i){\n            //在一层的搜索中选择不重复的数字，同时巧妙的维持了可搜索上一层数字的状态\n            if(i > 0 && i > pos && candidates[i] == candidates[i - 1]) continue; \n            aim.push_back(candidates[i]);            \n            \n            dfs(candidates, aim, i + 1, target - candidates[i]);\n            aim.pop_back();\n        }\n    }\n};\n```","slug":"刷题-搜索-回溯-40-Combination-Sum-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6i004gl5uohmi444os","content":"<h2 id=\"40-Combination-Sum-II\"><a href=\"#40-Combination-Sum-II\" class=\"headerlink\" title=\"40. Combination Sum II\"></a><a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\">40. Combination Sum II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>用map记录数字出现次数，转化为普通的dfs</li>\n<li>避免在填充<code>idx</code>数字的时候，遍历到重复数字，即可。无需map记录数字。是一种成熟的避免重复数字的方法。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>40%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; ct;\n    vector&lt;int&gt; arr;\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;());\n        for(auto i : candidates)&#123;\n            ct[i]++;\n            if(ct[i] &#x3D;&#x3D; 1) arr.push_back(i);    \n        &#125;\n        vector&lt;int&gt; aim;\n        dfs(aim, 0, target);\n        return res;\n    &#125;\n    void dfs(vector&lt;int&gt; &amp;aim, int pos, int target)&#123;\n        if(target &#x3D;&#x3D; 0)&#123;\n            res.push_back(aim);\n            return;\n        &#125;\n        for(int i &#x3D; pos; i &lt; arr.size(); ++i)&#123;        \n            if(arr[i] &gt; target) break;\n            if(ct[arr[i]] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F;ct[arr[i]]必行存在\n            aim.push_back(arr[i]);\n            ct[arr[i]]--;\n            dfs(aim, i, target - arr[i]);\n            ct[arr[i]]++;\n            aim.pop_back();\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>98%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:   \n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;());        \n        vector&lt;int&gt; aim;\n        dfs(candidates,aim, 0, target);\n        return res;\n    &#125;\n    void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; &amp;aim, int pos, int target)&#123;\n        &#x2F;&#x2F; for(auto i : aim)&#123;\n        &#x2F;&#x2F;     cout &lt;&lt; i &lt;&lt; &#39; &#39; ;\n        &#x2F;&#x2F; &#125;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        if(target &#x3D;&#x3D; 0)&#123;\n            res.push_back(aim);\n            return;\n        &#125;\n        for(int i &#x3D; pos; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;&#x3D; target; ++i)&#123;\n            &#x2F;&#x2F;在一层的搜索中选择不重复的数字，同时巧妙的维持了可搜索上一层数字的状态\n            if(i &gt; 0 &amp;&amp; i &gt; pos &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1]) continue; \n            aim.push_back(candidates[i]);            \n            \n            dfs(candidates, aim, i + 1, target - candidates[i]);\n            aim.pop_back();\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3W6EVNG","excerpt":"<h2 id=\"40-Combination-Sum-II\"><a href=\"#40-Combination-Sum-II\" class=\"headerlink\" title=\"40. Combination Sum II\"></a><a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\">40. Combination Sum II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>用map记录数字出现次数，转化为普通的dfs</li>\n<li>避免在填充<code>idx</code>数字的时候，遍历到重复数字，即可。无需map记录数字。是一种成熟的避免重复数字的方法。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>40%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; ct;\n    vector&lt;int&gt; arr;\n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;());\n        for(auto i : candidates)&#123;\n            ct[i]++;\n            if(ct[i] &#x3D;&#x3D; 1) arr.push_back(i);    \n        &#125;\n        vector&lt;int&gt; aim;\n        dfs(aim, 0, target);\n        return res;\n    &#125;\n    void dfs(vector&lt;int&gt; &amp;aim, int pos, int target)&#123;\n        if(target &#x3D;&#x3D; 0)&#123;\n            res.push_back(aim);\n            return;\n        &#125;\n        for(int i &#x3D; pos; i &lt; arr.size(); ++i)&#123;        \n            if(arr[i] &gt; target) break;\n            if(ct[arr[i]] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F;ct[arr[i]]必行存在\n            aim.push_back(arr[i]);\n            ct[arr[i]]--;\n            dfs(aim, i, target - arr[i]);\n            ct[arr[i]]++;\n            aim.pop_back();\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>98%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:   \n    vector&lt;vector&lt;int&gt;&gt; res;\n    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;\n        sort(candidates.begin(), candidates.end(), less&lt;int&gt;());        \n        vector&lt;int&gt; aim;\n        dfs(candidates,aim, 0, target);\n        return res;\n    &#125;\n    void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; &amp;aim, int pos, int target)&#123;\n        &#x2F;&#x2F; for(auto i : aim)&#123;\n        &#x2F;&#x2F;     cout &lt;&lt; i &lt;&lt; &#39; &#39; ;\n        &#x2F;&#x2F; &#125;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        if(target &#x3D;&#x3D; 0)&#123;\n            res.push_back(aim);\n            return;\n        &#125;\n        for(int i &#x3D; pos; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;&#x3D; target; ++i)&#123;\n            &#x2F;&#x2F;在一层的搜索中选择不重复的数字，同时巧妙的维持了可搜索上一层数字的状态\n            if(i &gt; 0 &amp;&amp; i &gt; pos &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1]) continue; \n            aim.push_back(candidates[i]);            \n            \n            dfs(candidates, aim, i + 1, target - candidates[i]);\n            aim.pop_back();\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"46. Permutations","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-24T02:41:53.000Z","_content":"\n\n\n\n\n## [46. Permutations](https://leetcode-cn.com/problems/permutations/)2\n\n\n\n## 思路：\n\n回溯法确定全排列。复杂度$o(n*n!)$，（复制 * permute调用次数）。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    void permuteCore(vector<int>&nums, vector<vector<int>> &res, int pos){\n        int n = nums.size();\n        if(n - 1 < pos){\n            res.push_back(nums);\n            return;\n        } \n        for(int i = pos; i < n; ++i){\n            swap(nums[pos], nums[i]);\n            permuteCore(nums, res, pos + 1);\n            swap(nums[pos], nums[i]);\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> res;\n        permuteCore(nums, res, 0);\n        return res;\n    }\n};\n```","source":"_posts/刷题/搜索/回溯\n/46-Permutations.md","raw":"---\ntitle: 46. Permutations\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-24 10:41:53\n---\n\n\n\n\n\n## [46. Permutations](https://leetcode-cn.com/problems/permutations/)2\n\n\n\n## 思路：\n\n回溯法确定全排列。复杂度$o(n*n!)$，（复制 * permute调用次数）。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    void permuteCore(vector<int>&nums, vector<vector<int>> &res, int pos){\n        int n = nums.size();\n        if(n - 1 < pos){\n            res.push_back(nums);\n            return;\n        } \n        for(int i = pos; i < n; ++i){\n            swap(nums[pos], nums[i]);\n            permuteCore(nums, res, pos + 1);\n            swap(nums[pos], nums[i]);\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> res;\n        permuteCore(nums, res, 0);\n        return res;\n    }\n};\n```","slug":"刷题-搜索-回溯-46-Permutations","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6j004hl5uoamx3eqxf","content":"<h2 id=\"46-Permutations2\"><a href=\"#46-Permutations2\" class=\"headerlink\" title=\"46. Permutations2\"></a><a href=\"https://leetcode-cn.com/problems/permutations/\">46. Permutations</a>2</h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯法确定全排列。复杂度$o(n*n!)$，（复制 * permute调用次数）。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int pos)&#123;\n        int n &#x3D; nums.size();\n        if(n - 1 &lt; pos)&#123;\n            res.push_back(nums);\n            return;\n        &#125; \n        for(int i &#x3D; pos; i &lt; n; ++i)&#123;\n            swap(nums[pos], nums[i]);\n            permuteCore(nums, res, pos + 1);\n            swap(nums[pos], nums[i]);\n        &#125;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        permuteCore(nums, res, 0);\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3A9S8CR","excerpt":"<h2 id=\"46-Permutations2\"><a href=\"#46-Permutations2\" class=\"headerlink\" title=\"46. Permutations2\"></a><a href=\"https://leetcode-cn.com/problems/permutations/\">46. Permutations</a>2</h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯法确定全排列。复杂度$o(n*n!)$，（复制 * permute调用次数）。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int pos)&#123;\n        int n &#x3D; nums.size();\n        if(n - 1 &lt; pos)&#123;\n            res.push_back(nums);\n            return;\n        &#125; \n        for(int i &#x3D; pos; i &lt; n; ++i)&#123;\n            swap(nums[pos], nums[i]);\n            permuteCore(nums, res, pos + 1);\n            swap(nums[pos], nums[i]);\n        &#125;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        permuteCore(nums, res, 0);\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"47. Permutations II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-03T04:58:55.000Z","_content":"\n\n\n\n## [47. Permutations II](https://leetcode-cn.com/problems/permutations-ii/)2\n\n\n\n## 思路：\n\n保证`idx`位的元素不重复即可。\n\n1. 可以用set去重nums[idx]\n2. 用set去重res\n\n<!-- more -->\n\n## 代码：\n\n\n\n66%\n\n```c++\nclass Solution {\npublic:\n    \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> permute;\n        permuteUniqueCore(permute, nums, 0);\n        return permute;\n    }\n\n    void permuteUniqueCore(vector<vector<int>> &permute, vector<int>&nums, int pos){\n        if(nums.size() == 0 ) return;\n        if(pos == nums.size() - 1){\n            permute.push_back(nums);\n            return;\n        }\n        // set无脑去重，空间有点大\n        unordered_set<int> vis;\n        for(int i = pos; i < nums.size(); ++i){\n            if(pos != i && vis.count(nums[i])) continue;\n            vis.insert(nums[i]);\n            swap(nums[pos], nums[i]);\n            permuteUniqueCore(permute, nums, pos + 1);\n            swap(nums[pos], nums[i]);            \n        }\n    }\n};\n```\n\n\n\n88%\n\n```c++\nclass Solution {\npublic:\n    vector<int> temp;vector<vector<int>> res;\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<int> vis(nums.size());\n        permuteCore(nums, vis, 0);\n        return res;\n    }\n\n    \n    void permuteCore(vector<int>&nums, vector<int> &vis, int pos){\n        if(pos == nums.size()){\n            res.push_back(temp);\n            return;\n        }\n        for(int i = 0; i < nums.size(); i++){\n            if(vis[i] || (i > 0 && nums[i] == nums[i -1] && !vis[i - 1])) continue;\n            vis[i] = 1;\n            temp.push_back(nums[i]);\n            permuteCore(nums, vis, pos + 1);\n            temp.pop_back();\n            vis[i] = 0;            \n        }        \n    }\n};\n\n```","source":"_posts/刷题/搜索/回溯\n/47-Permutations-II.md","raw":"---\ntitle: 47. Permutations II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-03 12:58:55\n---\n\n\n\n\n## [47. Permutations II](https://leetcode-cn.com/problems/permutations-ii/)2\n\n\n\n## 思路：\n\n保证`idx`位的元素不重复即可。\n\n1. 可以用set去重nums[idx]\n2. 用set去重res\n\n<!-- more -->\n\n## 代码：\n\n\n\n66%\n\n```c++\nclass Solution {\npublic:\n    \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> permute;\n        permuteUniqueCore(permute, nums, 0);\n        return permute;\n    }\n\n    void permuteUniqueCore(vector<vector<int>> &permute, vector<int>&nums, int pos){\n        if(nums.size() == 0 ) return;\n        if(pos == nums.size() - 1){\n            permute.push_back(nums);\n            return;\n        }\n        // set无脑去重，空间有点大\n        unordered_set<int> vis;\n        for(int i = pos; i < nums.size(); ++i){\n            if(pos != i && vis.count(nums[i])) continue;\n            vis.insert(nums[i]);\n            swap(nums[pos], nums[i]);\n            permuteUniqueCore(permute, nums, pos + 1);\n            swap(nums[pos], nums[i]);            \n        }\n    }\n};\n```\n\n\n\n88%\n\n```c++\nclass Solution {\npublic:\n    vector<int> temp;vector<vector<int>> res;\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        vector<int> vis(nums.size());\n        permuteCore(nums, vis, 0);\n        return res;\n    }\n\n    \n    void permuteCore(vector<int>&nums, vector<int> &vis, int pos){\n        if(pos == nums.size()){\n            res.push_back(temp);\n            return;\n        }\n        for(int i = 0; i < nums.size(); i++){\n            if(vis[i] || (i > 0 && nums[i] == nums[i -1] && !vis[i - 1])) continue;\n            vis[i] = 1;\n            temp.push_back(nums[i]);\n            permuteCore(nums, vis, pos + 1);\n            temp.pop_back();\n            vis[i] = 0;            \n        }        \n    }\n};\n\n```","slug":"刷题-搜索-回溯-47-Permutations-II","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6j004il5uo118q1he0","content":"<h2 id=\"47-Permutations-II2\"><a href=\"#47-Permutations-II2\" class=\"headerlink\" title=\"47. Permutations II2\"></a><a href=\"https://leetcode-cn.com/problems/permutations-ii/\">47. Permutations II</a>2</h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>保证<code>idx</code>位的元素不重复即可。</p>\n<ol>\n<li>可以用set去重nums[idx]</li>\n<li>用set去重res</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>66%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; permute;\n        permuteUniqueCore(permute, nums, 0);\n        return permute;\n    &#125;\n\n    void permuteUniqueCore(vector&lt;vector&lt;int&gt;&gt; &amp;permute, vector&lt;int&gt;&amp;nums, int pos)&#123;\n        if(nums.size() &#x3D;&#x3D; 0 ) return;\n        if(pos &#x3D;&#x3D; nums.size() - 1)&#123;\n            permute.push_back(nums);\n            return;\n        &#125;\n        &#x2F;&#x2F; set无脑去重，空间有点大\n        unordered_set&lt;int&gt; vis;\n        for(int i &#x3D; pos; i &lt; nums.size(); ++i)&#123;\n            if(pos !&#x3D; i &amp;&amp; vis.count(nums[i])) continue;\n            vis.insert(nums[i]);\n            swap(nums[pos], nums[i]);\n            permuteUniqueCore(permute, nums, pos + 1);\n            swap(nums[pos], nums[i]);            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>88%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;\n\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(),nums.end());\n        vector&lt;int&gt; vis(nums.size());\n        permuteCore(nums, vis, 0);\n        return res;\n    &#125;\n\n    \n    void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;int&gt; &amp;vis, int pos)&#123;\n        if(pos &#x3D;&#x3D; nums.size())&#123;\n            res.push_back(temp);\n            return;\n        &#125;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n            if(vis[i] || (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i -1] &amp;&amp; !vis[i - 1])) continue;\n            vis[i] &#x3D; 1;\n            temp.push_back(nums[i]);\n            permuteCore(nums, vis, pos + 1);\n            temp.pop_back();\n            vis[i] &#x3D; 0;            \n        &#125;        \n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2XM17SG","excerpt":"<h2 id=\"47-Permutations-II2\"><a href=\"#47-Permutations-II2\" class=\"headerlink\" title=\"47. Permutations II2\"></a><a href=\"https://leetcode-cn.com/problems/permutations-ii/\">47. Permutations II</a>2</h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>保证<code>idx</code>位的元素不重复即可。</p>\n<ol>\n<li>可以用set去重nums[idx]</li>\n<li>用set去重res</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>66%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; permute;\n        permuteUniqueCore(permute, nums, 0);\n        return permute;\n    &#125;\n\n    void permuteUniqueCore(vector&lt;vector&lt;int&gt;&gt; &amp;permute, vector&lt;int&gt;&amp;nums, int pos)&#123;\n        if(nums.size() &#x3D;&#x3D; 0 ) return;\n        if(pos &#x3D;&#x3D; nums.size() - 1)&#123;\n            permute.push_back(nums);\n            return;\n        &#125;\n        &#x2F;&#x2F; set无脑去重，空间有点大\n        unordered_set&lt;int&gt; vis;\n        for(int i &#x3D; pos; i &lt; nums.size(); ++i)&#123;\n            if(pos !&#x3D; i &amp;&amp; vis.count(nums[i])) continue;\n            vis.insert(nums[i]);\n            swap(nums[pos], nums[i]);\n            permuteUniqueCore(permute, nums, pos + 1);\n            swap(nums[pos], nums[i]);            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>88%</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res;\n\n    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;\n        sort(nums.begin(),nums.end());\n        vector&lt;int&gt; vis(nums.size());\n        permuteCore(nums, vis, 0);\n        return res;\n    &#125;\n\n    \n    void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;int&gt; &amp;vis, int pos)&#123;\n        if(pos &#x3D;&#x3D; nums.size())&#123;\n            res.push_back(temp);\n            return;\n        &#125;\n        for(int i &#x3D; 0; i &lt; nums.size(); i++)&#123;\n            if(vis[i] || (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i -1] &amp;&amp; !vis[i - 1])) continue;\n            vis[i] &#x3D; 1;\n            temp.push_back(nums[i]);\n            permuteCore(nums, vis, pos + 1);\n            temp.pop_back();\n            vis[i] &#x3D; 0;            \n        &#125;        \n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"51. N-Queens","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-27T01:21:27.000Z","_content":"\n\n\n## [51. N-Queens](https://leetcode-cn.com/problems/n-queens/)\n\n## 思路:\n\n八皇后问题，经典问题。回溯解决。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    \n    void generate(vector<vector<string>> &outs, vector<int> &chess, vector<int> &hashorpos, int depth, int n){\n        if(n == depth){\n            \n            vector<string> res(n, string(n, '.'));\n            for(int i = 0; i < n; ++i){\n                res[i].replace(chess[i], 1, \"Q\"); \n                //  cout << chess[i] << ' ' ;\n            }\n            // cout << endl;\n            outs.emplace_back(res);\n            return;\n        }\n    \n        for(int i = 0; i < n; ++i){\n            int flag = 1;\n            if(!hashorpos[i]){\n                #这部分判断代码可以优化，但是很麻烦，可以用hasverpos代表一层中被禁止的位置,需要标记左右方向，很麻烦。考虑到n的数量直接遍历就行，可以当做一个不变量。\n                for(int j = 1; j <= depth ; ++j){\n                    if(chess[depth - j] == i - j || chess[depth - j] == i + j){\n                        flag = 0;\n                        break;\n                    }                                        \n                }\n                if(!flag) continue;\n\n                chess[depth] = i;\n                hashorpos[i] = 1;\n                \n                generate(outs, chess, hashorpos, depth + 1, n);\n                                \n                chess[depth] = -1;\n                hashorpos[i] = 0;\n                \n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> outs;\n        vector<int> chess(n, -1), hashorpos(n, 0);\n        generate(outs, chess, hashorpos, 0, n);\n        return outs;\n    }\n};\n```","source":"_posts/刷题/搜索/回溯\n/51-N-Queens.md","raw":"---\ntitle: 51. N-Queens\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-27 09:21:27\n---\n\n\n\n## [51. N-Queens](https://leetcode-cn.com/problems/n-queens/)\n\n## 思路:\n\n八皇后问题，经典问题。回溯解决。\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    \n    void generate(vector<vector<string>> &outs, vector<int> &chess, vector<int> &hashorpos, int depth, int n){\n        if(n == depth){\n            \n            vector<string> res(n, string(n, '.'));\n            for(int i = 0; i < n; ++i){\n                res[i].replace(chess[i], 1, \"Q\"); \n                //  cout << chess[i] << ' ' ;\n            }\n            // cout << endl;\n            outs.emplace_back(res);\n            return;\n        }\n    \n        for(int i = 0; i < n; ++i){\n            int flag = 1;\n            if(!hashorpos[i]){\n                #这部分判断代码可以优化，但是很麻烦，可以用hasverpos代表一层中被禁止的位置,需要标记左右方向，很麻烦。考虑到n的数量直接遍历就行，可以当做一个不变量。\n                for(int j = 1; j <= depth ; ++j){\n                    if(chess[depth - j] == i - j || chess[depth - j] == i + j){\n                        flag = 0;\n                        break;\n                    }                                        \n                }\n                if(!flag) continue;\n\n                chess[depth] = i;\n                hashorpos[i] = 1;\n                \n                generate(outs, chess, hashorpos, depth + 1, n);\n                                \n                chess[depth] = -1;\n                hashorpos[i] = 0;\n                \n            }\n        }\n    }\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> outs;\n        vector<int> chess(n, -1), hashorpos(n, 0);\n        generate(outs, chess, hashorpos, 0, n);\n        return outs;\n    }\n};\n```","slug":"刷题-搜索-回溯-51-N-Queens","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6k004jl5uo78e809mf","content":"<h2 id=\"51-N-Queens\"><a href=\"#51-N-Queens\" class=\"headerlink\" title=\"51. N-Queens\"></a><a href=\"https://leetcode-cn.com/problems/n-queens/\">51. N-Queens</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>八皇后问题，经典问题。回溯解决。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    void generate(vector&lt;vector&lt;string&gt;&gt; &amp;outs, vector&lt;int&gt; &amp;chess, vector&lt;int&gt; &amp;hashorpos, int depth, int n)&#123;\n        if(n &#x3D;&#x3D; depth)&#123;\n            \n            vector&lt;string&gt; res(n, string(n, &#39;.&#39;));\n            for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n                res[i].replace(chess[i], 1, &quot;Q&quot;); \n                &#x2F;&#x2F;  cout &lt;&lt; chess[i] &lt;&lt; &#39; &#39; ;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n            outs.emplace_back(res);\n            return;\n        &#125;\n    \n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            int flag &#x3D; 1;\n            if(!hashorpos[i])&#123;\n                #这部分判断代码可以优化，但是很麻烦，可以用hasverpos代表一层中被禁止的位置,需要标记左右方向，很麻烦。考虑到n的数量直接遍历就行，可以当做一个不变量。\n                for(int j &#x3D; 1; j &lt;&#x3D; depth ; ++j)&#123;\n                    if(chess[depth - j] &#x3D;&#x3D; i - j || chess[depth - j] &#x3D;&#x3D; i + j)&#123;\n                        flag &#x3D; 0;\n                        break;\n                    &#125;                                        \n                &#125;\n                if(!flag) continue;\n\n                chess[depth] &#x3D; i;\n                hashorpos[i] &#x3D; 1;\n                \n                generate(outs, chess, hashorpos, depth + 1, n);\n                                \n                chess[depth] &#x3D; -1;\n                hashorpos[i] &#x3D; 0;\n                \n            &#125;\n        &#125;\n    &#125;\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;\n        vector&lt;vector&lt;string&gt;&gt; outs;\n        vector&lt;int&gt; chess(n, -1), hashorpos(n, 0);\n        generate(outs, chess, hashorpos, 0, n);\n        return outs;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3CXBXJW","excerpt":"","more":"<h2 id=\"51-N-Queens\"><a href=\"#51-N-Queens\" class=\"headerlink\" title=\"51. N-Queens\"></a><a href=\"https://leetcode-cn.com/problems/n-queens/\">51. N-Queens</a></h2><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>八皇后问题，经典问题。回溯解决。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    void generate(vector&lt;vector&lt;string&gt;&gt; &amp;outs, vector&lt;int&gt; &amp;chess, vector&lt;int&gt; &amp;hashorpos, int depth, int n)&#123;\n        if(n &#x3D;&#x3D; depth)&#123;\n            \n            vector&lt;string&gt; res(n, string(n, &#39;.&#39;));\n            for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n                res[i].replace(chess[i], 1, &quot;Q&quot;); \n                &#x2F;&#x2F;  cout &lt;&lt; chess[i] &lt;&lt; &#39; &#39; ;\n            &#125;\n            &#x2F;&#x2F; cout &lt;&lt; endl;\n            outs.emplace_back(res);\n            return;\n        &#125;\n    \n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            int flag &#x3D; 1;\n            if(!hashorpos[i])&#123;\n                #这部分判断代码可以优化，但是很麻烦，可以用hasverpos代表一层中被禁止的位置,需要标记左右方向，很麻烦。考虑到n的数量直接遍历就行，可以当做一个不变量。\n                for(int j &#x3D; 1; j &lt;&#x3D; depth ; ++j)&#123;\n                    if(chess[depth - j] &#x3D;&#x3D; i - j || chess[depth - j] &#x3D;&#x3D; i + j)&#123;\n                        flag &#x3D; 0;\n                        break;\n                    &#125;                                        \n                &#125;\n                if(!flag) continue;\n\n                chess[depth] &#x3D; i;\n                hashorpos[i] &#x3D; 1;\n                \n                generate(outs, chess, hashorpos, depth + 1, n);\n                                \n                chess[depth] &#x3D; -1;\n                hashorpos[i] &#x3D; 0;\n                \n            &#125;\n        &#125;\n    &#125;\n    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;\n        vector&lt;vector&lt;string&gt;&gt; outs;\n        vector&lt;int&gt; chess(n, -1), hashorpos(n, 0);\n        generate(outs, chess, hashorpos, 0, n);\n        return outs;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"77. Combinations","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-25T06:02:41.000Z","_content":"\n\n\n\n\n## [77. Combinations](https://leetcode-cn.com/problems/combinations/)\n\n\n\n## 思路：\n\n回溯，获取搭配数组，\n\n<!-- more -->\n\n>  $s <= n - k  + 1$\n\n## 代码:\n\n```c++\n\nclass Solution {\npublic:\n    void getKnumber(vector<vector<int>>& ans, vector<int> &addt, int n, int k, int s){\n        if(addt.size() == k){\n            ans.push_back(addt);            \n            return;\n        }\n        if(s > n) return;\n        \n        for(int i = s; i <= n - k + addt.size() + 1; ++i){\n            addt.push_back(i);\n            getKnumber(ans, addt, n, k, i + 1);\n            addt.pop_back();\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> res;\n        vector<int> addt;\n        getKnumber(res, addt, n, k, 1);\n        return res;\n    }\n};\n```","source":"_posts/刷题/搜索/回溯\n/77-Combinations.md","raw":"---\ntitle: 77. Combinations\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-25 14:02:41\n---\n\n\n\n\n\n## [77. Combinations](https://leetcode-cn.com/problems/combinations/)\n\n\n\n## 思路：\n\n回溯，获取搭配数组，\n\n<!-- more -->\n\n>  $s <= n - k  + 1$\n\n## 代码:\n\n```c++\n\nclass Solution {\npublic:\n    void getKnumber(vector<vector<int>>& ans, vector<int> &addt, int n, int k, int s){\n        if(addt.size() == k){\n            ans.push_back(addt);            \n            return;\n        }\n        if(s > n) return;\n        \n        for(int i = s; i <= n - k + addt.size() + 1; ++i){\n            addt.push_back(i);\n            getKnumber(ans, addt, n, k, i + 1);\n            addt.pop_back();\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> res;\n        vector<int> addt;\n        getKnumber(res, addt, n, k, 1);\n        return res;\n    }\n};\n```","slug":"刷题-搜索-回溯-77-Combinations","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6l004kl5uo3j9v1jf2","content":"<h2 id=\"77-Combinations\"><a href=\"#77-Combinations\" class=\"headerlink\" title=\"77. Combinations\"></a><a href=\"https://leetcode-cn.com/problems/combinations/\">77. Combinations</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯，获取搭配数组，</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p> $s &lt;= n - k  + 1$</p>\n</blockquote>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码:\"></a>代码:</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    void getKnumber(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt; &amp;addt, int n, int k, int s)&#123;\n        if(addt.size() &#x3D;&#x3D; k)&#123;\n            ans.push_back(addt);            \n            return;\n        &#125;\n        if(s &gt; n) return;\n        \n        for(int i &#x3D; s; i &lt;&#x3D; n - k + addt.size() + 1; ++i)&#123;\n            addt.push_back(i);\n            getKnumber(ans, addt, n, k, i + 1);\n            addt.pop_back();\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;int&gt; addt;\n        getKnumber(res, addt, n, k, 1);\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"Y20PTT","excerpt":"<h2 id=\"77-Combinations\"><a href=\"#77-Combinations\" class=\"headerlink\" title=\"77. Combinations\"></a><a href=\"https://leetcode-cn.com/problems/combinations/\">77. Combinations</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>回溯，获取搭配数组，</p>","more":"<blockquote>\n<p> $s &lt;= n - k  + 1$</p>\n</blockquote>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码:\"></a>代码:</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    void getKnumber(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt; &amp;addt, int n, int k, int s)&#123;\n        if(addt.size() &#x3D;&#x3D; k)&#123;\n            ans.push_back(addt);            \n            return;\n        &#125;\n        if(s &gt; n) return;\n        \n        for(int i &#x3D; s; i &lt;&#x3D; n - k + addt.size() + 1; ++i)&#123;\n            addt.push_back(i);\n            getKnumber(ans, addt, n, k, i + 1);\n            addt.pop_back();\n        &#125;\n    &#125;\n\n    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;\n        vector&lt;vector&lt;int&gt;&gt; res;\n        vector&lt;int&gt; addt;\n        getKnumber(res, addt, n, k, 1);\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题-回溯DFs","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:29:35.000Z","_content":"\n<!-- more -->\n\n收集回溯相关题目\n\n\n\n## 面13\n\n> 面12和13很相似，不重复写了。\n\n### 题面：\n\n在一个字符矩阵中寻找一条路径，路径上的字符从头到尾排列起来是给定的字符串`s`。判断有无这么一条路径。\n\n### 思路：\n\nDFS或者说和回朔直接暴力搜。\n\n### 代码：\n\n```\nbool hasPathCore(char *matrix, int rows, int cols, int row, int col, char *str, int strIdx, int &isFound){\n    if(strIdx < 0){\n        isFound = 1;\n        return true;\n    }\n    if(isFound) return true;\n    \n    visited[row * cols + col] = 1;\n    int dX[] = {0, 0, -1, 1}, dY[] = {-1, 1, 0, 0};\n    for(int i = 0; i < 4; ++i){\n\t\tint nX = dX[i] + row, nY = dY[i] + col, p = row * cols + col;\n        if( nX >= 0 && nY >= 0 && nX < rows && nY < cols && !visited[p] && str[strIdx] ==  matrix[p])\n            hashPathCore(matrix, rows, cols, row, col, str, strIdx - 1);        \n    }\n}\n\nbool hasPath(char *matrix, int rows, int cols, char *str, int length){\n\tif(str == nullptr || matrix == nullptr)\n        throw new std::exception(\"Invalid parameters.\");\n    int visited = new int[rows * cols], isFound = 0;\n    memset(visited, 0, sizeof(visited));\n    for(int i = 0; i < rows; ++i)\n        for(int j = 0; j < cols; ++j)\n            if( hasPathCore(matrix, rows, cols, i, j, str, length - 1, isFound)){//倒着搜    \n            \tdel[] visited;            \n                return true;    \n            }\n}\n```","source":"_posts/刷题/搜索/回溯\n/面试题-回溯DFs.md","raw":"---\ntitle: 面试题-回溯DFs\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:29:35\ntags:\n---\n\n<!-- more -->\n\n收集回溯相关题目\n\n\n\n## 面13\n\n> 面12和13很相似，不重复写了。\n\n### 题面：\n\n在一个字符矩阵中寻找一条路径，路径上的字符从头到尾排列起来是给定的字符串`s`。判断有无这么一条路径。\n\n### 思路：\n\nDFS或者说和回朔直接暴力搜。\n\n### 代码：\n\n```\nbool hasPathCore(char *matrix, int rows, int cols, int row, int col, char *str, int strIdx, int &isFound){\n    if(strIdx < 0){\n        isFound = 1;\n        return true;\n    }\n    if(isFound) return true;\n    \n    visited[row * cols + col] = 1;\n    int dX[] = {0, 0, -1, 1}, dY[] = {-1, 1, 0, 0};\n    for(int i = 0; i < 4; ++i){\n\t\tint nX = dX[i] + row, nY = dY[i] + col, p = row * cols + col;\n        if( nX >= 0 && nY >= 0 && nX < rows && nY < cols && !visited[p] && str[strIdx] ==  matrix[p])\n            hashPathCore(matrix, rows, cols, row, col, str, strIdx - 1);        \n    }\n}\n\nbool hasPath(char *matrix, int rows, int cols, char *str, int length){\n\tif(str == nullptr || matrix == nullptr)\n        throw new std::exception(\"Invalid parameters.\");\n    int visited = new int[rows * cols], isFound = 0;\n    memset(visited, 0, sizeof(visited));\n    for(int i = 0; i < rows; ++i)\n        for(int j = 0; j < cols; ++j)\n            if( hasPathCore(matrix, rows, cols, i, j, str, length - 1, isFound)){//倒着搜    \n            \tdel[] visited;            \n                return true;    \n            }\n}\n```","slug":"刷题-搜索-回溯-面试题-回溯DFs","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6l004ll5uoeu6m90p4","content":"<span id=\"more\"></span>\n\n<p>收集回溯相关题目</p>\n<h2 id=\"面13\"><a href=\"#面13\" class=\"headerlink\" title=\"面13\"></a>面13</h2><blockquote>\n<p>面12和13很相似，不重复写了。</p>\n</blockquote>\n<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>在一个字符矩阵中寻找一条路径，路径上的字符从头到尾排列起来是给定的字符串<code>s</code>。判断有无这么一条路径。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>DFS或者说和回朔直接暴力搜。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool hasPathCore(char *matrix, int rows, int cols, int row, int col, char *str, int strIdx, int &amp;isFound)&#123;\n    if(strIdx &lt; 0)&#123;\n        isFound &#x3D; 1;\n        return true;\n    &#125;\n    if(isFound) return true;\n    \n    visited[row * cols + col] &#x3D; 1;\n    int dX[] &#x3D; &#123;0, 0, -1, 1&#125;, dY[] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n\t\tint nX &#x3D; dX[i] + row, nY &#x3D; dY[i] + col, p &#x3D; row * cols + col;\n        if( nX &gt;&#x3D; 0 &amp;&amp; nY &gt;&#x3D; 0 &amp;&amp; nX &lt; rows &amp;&amp; nY &lt; cols &amp;&amp; !visited[p] &amp;&amp; str[strIdx] &#x3D;&#x3D;  matrix[p])\n            hashPathCore(matrix, rows, cols, row, col, str, strIdx - 1);        \n    &#125;\n&#125;\n\nbool hasPath(char *matrix, int rows, int cols, char *str, int length)&#123;\n\tif(str &#x3D;&#x3D; nullptr || matrix &#x3D;&#x3D; nullptr)\n        throw new std::exception(&quot;Invalid parameters.&quot;);\n    int visited &#x3D; new int[rows * cols], isFound &#x3D; 0;\n    memset(visited, 0, sizeof(visited));\n    for(int i &#x3D; 0; i &lt; rows; ++i)\n        for(int j &#x3D; 0; j &lt; cols; ++j)\n            if( hasPathCore(matrix, rows, cols, i, j, str, length - 1, isFound))&#123;&#x2F;&#x2F;倒着搜    \n            \tdel[] visited;            \n                return true;    \n            &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1PQAVTB","excerpt":"","more":"<p>收集回溯相关题目</p>\n<h2 id=\"面13\"><a href=\"#面13\" class=\"headerlink\" title=\"面13\"></a>面13</h2><blockquote>\n<p>面12和13很相似，不重复写了。</p>\n</blockquote>\n<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>在一个字符矩阵中寻找一条路径，路径上的字符从头到尾排列起来是给定的字符串<code>s</code>。判断有无这么一条路径。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>DFS或者说和回朔直接暴力搜。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool hasPathCore(char *matrix, int rows, int cols, int row, int col, char *str, int strIdx, int &amp;isFound)&#123;\n    if(strIdx &lt; 0)&#123;\n        isFound &#x3D; 1;\n        return true;\n    &#125;\n    if(isFound) return true;\n    \n    visited[row * cols + col] &#x3D; 1;\n    int dX[] &#x3D; &#123;0, 0, -1, 1&#125;, dY[] &#x3D; &#123;-1, 1, 0, 0&#125;;\n    for(int i &#x3D; 0; i &lt; 4; ++i)&#123;\n\t\tint nX &#x3D; dX[i] + row, nY &#x3D; dY[i] + col, p &#x3D; row * cols + col;\n        if( nX &gt;&#x3D; 0 &amp;&amp; nY &gt;&#x3D; 0 &amp;&amp; nX &lt; rows &amp;&amp; nY &lt; cols &amp;&amp; !visited[p] &amp;&amp; str[strIdx] &#x3D;&#x3D;  matrix[p])\n            hashPathCore(matrix, rows, cols, row, col, str, strIdx - 1);        \n    &#125;\n&#125;\n\nbool hasPath(char *matrix, int rows, int cols, char *str, int length)&#123;\n\tif(str &#x3D;&#x3D; nullptr || matrix &#x3D;&#x3D; nullptr)\n        throw new std::exception(&quot;Invalid parameters.&quot;);\n    int visited &#x3D; new int[rows * cols], isFound &#x3D; 0;\n    memset(visited, 0, sizeof(visited));\n    for(int i &#x3D; 0; i &lt; rows; ++i)\n        for(int j &#x3D; 0; j &lt; cols; ++j)\n            if( hasPathCore(matrix, rows, cols, i, j, str, length - 1, isFound))&#123;&#x2F;&#x2F;倒着搜    \n            \tdel[] visited;            \n                return true;    \n            &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1340. Jump Game V","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-05T03:04:43.000Z","_content":"这个题目还是蛮入门的……\n## 思路：\n\n这题如果采用DP的思想去做，很难。第一，如果设$dp[t][i]$为第i个数字为终点,最多移动t步的情况下最大经过的数字个数，那么DP转移方程就涉及到搜索上一层合理数字，复杂度大增（离线可计算，但是还是不快）。\n\n> 后面给的第二种算法就是该版本。\n\n第二，如果$dp[t][i]$为第i个数字为起点,最多走t步的最大经过的数字个数，虽然由于顺着题目的意思，相比上一种方法减少了搜索上一层的合理数字，但还是不够快。可以从DP版本1中看出来，许多状态转移的计算都是无谓的。时间复杂度为$O(N^2D)$，即使有一点点剪枝也没法AC。\n\n第三，通过记忆化搜索的方法，可以大幅减少重复计算。  \n\n\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    // f[i]:从i开始最多可以visit的数字\n    vector<int> f;\n\n    void dfs(vector<int> &arr, int id, int d, int n){\n        if(f[id] != -1) return;\n        f[id] = 1;        \n        for(int i = id + 1; i < id + d + 1 && i < n && arr[id] > arr[i]; i++){\n            dfs(arr, i, d, n);\n            f[id] = max(f[id], f[i] + 1);\n        }\n            \n        for(int i = id - 1; i > id - d - 1 && i >= 0 && arr[id] > arr[i]; i--){\n            dfs(arr, i, d, n);        \n            f[id] = max(f[id], f[i] + 1);\n        }            \n    }\n    int maxJumps(vector<int>& arr, int d) {\n        int len = arr.size();\n        f.resize(len, -1);\n        \n        for(int i = 0;i < len; i++){\n            dfs(arr, i, d ,len);        \n        }\n        return *max_element(f.begin(), f.end());\n    }\n};\n```\n\nDP版本1：\n\n```c++\n\nclass Solution {\npublic:\n    int maxJumps(vector<int>& arr, int d) {\n        int len = arr.size();\n        vector<int> dp[2];\n        dp[0].resize(len, 1);\n        dp[1].resize(len, 0);\n        int maxstep = 0, flag = 1;\n        int newl = 0, oldl = 1;\n        while(flag){\n            flag = 0;    \n            swap(newl, oldl);\n\n            for(int i = 0; i < len; i++){\n                for(int j = i + 1; j < d + i + 1 && j < len && arr[j] < arr[i]; ++j){\n                    int newv = dp[oldl][j] + 1;\n                    if(newv > dp[newl][i]){\n                        dp[newl][i] = newv;\n                        flag = 1;\n                    }                    \n                }\n                for(int j = i - 1; j > i - d - 1 && j >= 0 && arr[j] < arr[i]; --j){\n                    int newv = dp[oldl][j] + 1;\n                    if(newv > dp[newl][i]){\n                        dp[newl][i] = newv;\n                        flag = 1;\n                    }                    \n                }                \n            }\n        }\n        int v = -1;\n        // for(int i = 0; i < len; ++i)\n        //     v = max(v, dp[newl][i]);\n        for(int i = 0; i < len; ++i)\n            v = max(v, dp[oldl][i]);\n        \n        return v;\n    }\n};\n```\n\n\n\nDP版本2：\n\n```c++\n\nclass Solution {\npublic:\n    int maxJumps(vector<int>& arr, int d) {\n        int len = arr.size();\n        vector<vector<int> > dp(2, vector<int>(len, 0));\n        vector<vector<int> > bigger(len,vector<int>(0,0));\n        vector<int> ischanged(len, 1);\n        for(int i = 0;i < len; i++){\n            int low = max(0, i - d);\n            int high = min(len - 1, i + d);\n            for(int j = i - 1; j >= low; j--)\n                if(arr[i] > arr[j]) bigger[j].push_back(i);\n                else break;\n            \n            for(int j = i + 1; j <= high; j++)\n                if(arr[i] > arr[j]) bigger[j].push_back(i);\n                else break;                 \n        }\n\n\n        int maxstep = 0, flag = 1;\n        int newl = 0, oldl = 1;\n        while(flag){\n            flag = 0;    \n            swap(newl, oldl);\n\n            for(int i = 0; i < len; i++){\n                if(ischanged[i] == 0) continue;\n                ischanged[i] = 0;\n                for(int j = 0; j < bigger[i].size(); j++){\n                    int newv = dp[oldl][bigger[i][j]] + 1;\n                    if(newv > dp[newl][i]){\n                        dp[newl][i] = newv;\n                        flag = 1;\n                        ischanged[i] = 1;\n                    }\n                    // dp[newl][i] = max(dp[newl][i], dp[oldl][bigger[i][j]] + 1);                    \n                }\n                maxstep = max(dp[newl][i], maxstep);\n            }\n        }\n\n        return maxstep + 1;\n    }\n};\n```\n\n","source":"_posts/刷题/搜索/记忆化搜索\n/1340-Jump-Game-V.md","raw":"---\ntitle: 1340. Jump Game V\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-05 11:04:43\n---\n这个题目还是蛮入门的……\n## 思路：\n\n这题如果采用DP的思想去做，很难。第一，如果设$dp[t][i]$为第i个数字为终点,最多移动t步的情况下最大经过的数字个数，那么DP转移方程就涉及到搜索上一层合理数字，复杂度大增（离线可计算，但是还是不快）。\n\n> 后面给的第二种算法就是该版本。\n\n第二，如果$dp[t][i]$为第i个数字为起点,最多走t步的最大经过的数字个数，虽然由于顺着题目的意思，相比上一种方法减少了搜索上一层的合理数字，但还是不够快。可以从DP版本1中看出来，许多状态转移的计算都是无谓的。时间复杂度为$O(N^2D)$，即使有一点点剪枝也没法AC。\n\n第三，通过记忆化搜索的方法，可以大幅减少重复计算。  \n\n\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    // f[i]:从i开始最多可以visit的数字\n    vector<int> f;\n\n    void dfs(vector<int> &arr, int id, int d, int n){\n        if(f[id] != -1) return;\n        f[id] = 1;        \n        for(int i = id + 1; i < id + d + 1 && i < n && arr[id] > arr[i]; i++){\n            dfs(arr, i, d, n);\n            f[id] = max(f[id], f[i] + 1);\n        }\n            \n        for(int i = id - 1; i > id - d - 1 && i >= 0 && arr[id] > arr[i]; i--){\n            dfs(arr, i, d, n);        \n            f[id] = max(f[id], f[i] + 1);\n        }            \n    }\n    int maxJumps(vector<int>& arr, int d) {\n        int len = arr.size();\n        f.resize(len, -1);\n        \n        for(int i = 0;i < len; i++){\n            dfs(arr, i, d ,len);        \n        }\n        return *max_element(f.begin(), f.end());\n    }\n};\n```\n\nDP版本1：\n\n```c++\n\nclass Solution {\npublic:\n    int maxJumps(vector<int>& arr, int d) {\n        int len = arr.size();\n        vector<int> dp[2];\n        dp[0].resize(len, 1);\n        dp[1].resize(len, 0);\n        int maxstep = 0, flag = 1;\n        int newl = 0, oldl = 1;\n        while(flag){\n            flag = 0;    \n            swap(newl, oldl);\n\n            for(int i = 0; i < len; i++){\n                for(int j = i + 1; j < d + i + 1 && j < len && arr[j] < arr[i]; ++j){\n                    int newv = dp[oldl][j] + 1;\n                    if(newv > dp[newl][i]){\n                        dp[newl][i] = newv;\n                        flag = 1;\n                    }                    \n                }\n                for(int j = i - 1; j > i - d - 1 && j >= 0 && arr[j] < arr[i]; --j){\n                    int newv = dp[oldl][j] + 1;\n                    if(newv > dp[newl][i]){\n                        dp[newl][i] = newv;\n                        flag = 1;\n                    }                    \n                }                \n            }\n        }\n        int v = -1;\n        // for(int i = 0; i < len; ++i)\n        //     v = max(v, dp[newl][i]);\n        for(int i = 0; i < len; ++i)\n            v = max(v, dp[oldl][i]);\n        \n        return v;\n    }\n};\n```\n\n\n\nDP版本2：\n\n```c++\n\nclass Solution {\npublic:\n    int maxJumps(vector<int>& arr, int d) {\n        int len = arr.size();\n        vector<vector<int> > dp(2, vector<int>(len, 0));\n        vector<vector<int> > bigger(len,vector<int>(0,0));\n        vector<int> ischanged(len, 1);\n        for(int i = 0;i < len; i++){\n            int low = max(0, i - d);\n            int high = min(len - 1, i + d);\n            for(int j = i - 1; j >= low; j--)\n                if(arr[i] > arr[j]) bigger[j].push_back(i);\n                else break;\n            \n            for(int j = i + 1; j <= high; j++)\n                if(arr[i] > arr[j]) bigger[j].push_back(i);\n                else break;                 \n        }\n\n\n        int maxstep = 0, flag = 1;\n        int newl = 0, oldl = 1;\n        while(flag){\n            flag = 0;    \n            swap(newl, oldl);\n\n            for(int i = 0; i < len; i++){\n                if(ischanged[i] == 0) continue;\n                ischanged[i] = 0;\n                for(int j = 0; j < bigger[i].size(); j++){\n                    int newv = dp[oldl][bigger[i][j]] + 1;\n                    if(newv > dp[newl][i]){\n                        dp[newl][i] = newv;\n                        flag = 1;\n                        ischanged[i] = 1;\n                    }\n                    // dp[newl][i] = max(dp[newl][i], dp[oldl][bigger[i][j]] + 1);                    \n                }\n                maxstep = max(dp[newl][i], maxstep);\n            }\n        }\n\n        return maxstep + 1;\n    }\n};\n```\n\n","slug":"刷题-搜索-记忆化搜索-1340-Jump-Game-V","published":1,"updated":"2021-01-28T14:04:37.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6m004ml5uo4nodb4wk","content":"<p>这个题目还是蛮入门的……</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题如果采用DP的思想去做，很难。第一，如果设$dp[t][i]$为第i个数字为终点,最多移动t步的情况下最大经过的数字个数，那么DP转移方程就涉及到搜索上一层合理数字，复杂度大增（离线可计算，但是还是不快）。</p>\n<blockquote>\n<p>后面给的第二种算法就是该版本。</p>\n</blockquote>\n<p>第二，如果$dp[t][i]$为第i个数字为起点,最多走t步的最大经过的数字个数，虽然由于顺着题目的意思，相比上一种方法减少了搜索上一层的合理数字，但还是不够快。可以从DP版本1中看出来，许多状态转移的计算都是无谓的。时间复杂度为$O(N^2D)$，即使有一点点剪枝也没法AC。</p>\n<p>第三，通过记忆化搜索的方法，可以大幅减少重复计算。  </p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; f[i]:从i开始最多可以visit的数字\n    vector&lt;int&gt; f;\n\n    void dfs(vector&lt;int&gt; &amp;arr, int id, int d, int n)&#123;\n        if(f[id] !&#x3D; -1) return;\n        f[id] &#x3D; 1;        \n        for(int i &#x3D; id + 1; i &lt; id + d + 1 &amp;&amp; i &lt; n &amp;&amp; arr[id] &gt; arr[i]; i++)&#123;\n            dfs(arr, i, d, n);\n            f[id] &#x3D; max(f[id], f[i] + 1);\n        &#125;\n            \n        for(int i &#x3D; id - 1; i &gt; id - d - 1 &amp;&amp; i &gt;&#x3D; 0 &amp;&amp; arr[id] &gt; arr[i]; i--)&#123;\n            dfs(arr, i, d, n);        \n            f[id] &#x3D; max(f[id], f[i] + 1);\n        &#125;            \n    &#125;\n    int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123;\n        int len &#x3D; arr.size();\n        f.resize(len, -1);\n        \n        for(int i &#x3D; 0;i &lt; len; i++)&#123;\n            dfs(arr, i, d ,len);        \n        &#125;\n        return *max_element(f.begin(), f.end());\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>DP版本1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123;\n        int len &#x3D; arr.size();\n        vector&lt;int&gt; dp[2];\n        dp[0].resize(len, 1);\n        dp[1].resize(len, 0);\n        int maxstep &#x3D; 0, flag &#x3D; 1;\n        int newl &#x3D; 0, oldl &#x3D; 1;\n        while(flag)&#123;\n            flag &#x3D; 0;    \n            swap(newl, oldl);\n\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                for(int j &#x3D; i + 1; j &lt; d + i + 1 &amp;&amp; j &lt; len &amp;&amp; arr[j] &lt; arr[i]; ++j)&#123;\n                    int newv &#x3D; dp[oldl][j] + 1;\n                    if(newv &gt; dp[newl][i])&#123;\n                        dp[newl][i] &#x3D; newv;\n                        flag &#x3D; 1;\n                    &#125;                    \n                &#125;\n                for(int j &#x3D; i - 1; j &gt; i - d - 1 &amp;&amp; j &gt;&#x3D; 0 &amp;&amp; arr[j] &lt; arr[i]; --j)&#123;\n                    int newv &#x3D; dp[oldl][j] + 1;\n                    if(newv &gt; dp[newl][i])&#123;\n                        dp[newl][i] &#x3D; newv;\n                        flag &#x3D; 1;\n                    &#125;                    \n                &#125;                \n            &#125;\n        &#125;\n        int v &#x3D; -1;\n        &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; len; ++i)\n        &#x2F;&#x2F;     v &#x3D; max(v, dp[newl][i]);\n        for(int i &#x3D; 0; i &lt; len; ++i)\n            v &#x3D; max(v, dp[oldl][i]);\n        \n        return v;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>DP版本2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123;\n        int len &#x3D; arr.size();\n        vector&lt;vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(len, 0));\n        vector&lt;vector&lt;int&gt; &gt; bigger(len,vector&lt;int&gt;(0,0));\n        vector&lt;int&gt; ischanged(len, 1);\n        for(int i &#x3D; 0;i &lt; len; i++)&#123;\n            int low &#x3D; max(0, i - d);\n            int high &#x3D; min(len - 1, i + d);\n            for(int j &#x3D; i - 1; j &gt;&#x3D; low; j--)\n                if(arr[i] &gt; arr[j]) bigger[j].push_back(i);\n                else break;\n            \n            for(int j &#x3D; i + 1; j &lt;&#x3D; high; j++)\n                if(arr[i] &gt; arr[j]) bigger[j].push_back(i);\n                else break;                 \n        &#125;\n\n\n        int maxstep &#x3D; 0, flag &#x3D; 1;\n        int newl &#x3D; 0, oldl &#x3D; 1;\n        while(flag)&#123;\n            flag &#x3D; 0;    \n            swap(newl, oldl);\n\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                if(ischanged[i] &#x3D;&#x3D; 0) continue;\n                ischanged[i] &#x3D; 0;\n                for(int j &#x3D; 0; j &lt; bigger[i].size(); j++)&#123;\n                    int newv &#x3D; dp[oldl][bigger[i][j]] + 1;\n                    if(newv &gt; dp[newl][i])&#123;\n                        dp[newl][i] &#x3D; newv;\n                        flag &#x3D; 1;\n                        ischanged[i] &#x3D; 1;\n                    &#125;\n                    &#x2F;&#x2F; dp[newl][i] &#x3D; max(dp[newl][i], dp[oldl][bigger[i][j]] + 1);                    \n                &#125;\n                maxstep &#x3D; max(dp[newl][i], maxstep);\n            &#125;\n        &#125;\n\n        return maxstep + 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3FNMBY4","excerpt":"<p>这个题目还是蛮入门的……</p>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题如果采用DP的思想去做，很难。第一，如果设$dp[t][i]$为第i个数字为终点,最多移动t步的情况下最大经过的数字个数，那么DP转移方程就涉及到搜索上一层合理数字，复杂度大增（离线可计算，但是还是不快）。</p>\n<blockquote>\n<p>后面给的第二种算法就是该版本。</p>\n</blockquote>\n<p>第二，如果$dp[t][i]$为第i个数字为起点,最多走t步的最大经过的数字个数，虽然由于顺着题目的意思，相比上一种方法减少了搜索上一层的合理数字，但还是不够快。可以从DP版本1中看出来，许多状态转移的计算都是无谓的。时间复杂度为$O(N^2D)$，即使有一点点剪枝也没法AC。</p>\n<p>第三，通过记忆化搜索的方法，可以大幅减少重复计算。  </p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    &#x2F;&#x2F; f[i]:从i开始最多可以visit的数字\n    vector&lt;int&gt; f;\n\n    void dfs(vector&lt;int&gt; &amp;arr, int id, int d, int n)&#123;\n        if(f[id] !&#x3D; -1) return;\n        f[id] &#x3D; 1;        \n        for(int i &#x3D; id + 1; i &lt; id + d + 1 &amp;&amp; i &lt; n &amp;&amp; arr[id] &gt; arr[i]; i++)&#123;\n            dfs(arr, i, d, n);\n            f[id] &#x3D; max(f[id], f[i] + 1);\n        &#125;\n            \n        for(int i &#x3D; id - 1; i &gt; id - d - 1 &amp;&amp; i &gt;&#x3D; 0 &amp;&amp; arr[id] &gt; arr[i]; i--)&#123;\n            dfs(arr, i, d, n);        \n            f[id] &#x3D; max(f[id], f[i] + 1);\n        &#125;            \n    &#125;\n    int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123;\n        int len &#x3D; arr.size();\n        f.resize(len, -1);\n        \n        for(int i &#x3D; 0;i &lt; len; i++)&#123;\n            dfs(arr, i, d ,len);        \n        &#125;\n        return *max_element(f.begin(), f.end());\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>DP版本1：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123;\n        int len &#x3D; arr.size();\n        vector&lt;int&gt; dp[2];\n        dp[0].resize(len, 1);\n        dp[1].resize(len, 0);\n        int maxstep &#x3D; 0, flag &#x3D; 1;\n        int newl &#x3D; 0, oldl &#x3D; 1;\n        while(flag)&#123;\n            flag &#x3D; 0;    \n            swap(newl, oldl);\n\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                for(int j &#x3D; i + 1; j &lt; d + i + 1 &amp;&amp; j &lt; len &amp;&amp; arr[j] &lt; arr[i]; ++j)&#123;\n                    int newv &#x3D; dp[oldl][j] + 1;\n                    if(newv &gt; dp[newl][i])&#123;\n                        dp[newl][i] &#x3D; newv;\n                        flag &#x3D; 1;\n                    &#125;                    \n                &#125;\n                for(int j &#x3D; i - 1; j &gt; i - d - 1 &amp;&amp; j &gt;&#x3D; 0 &amp;&amp; arr[j] &lt; arr[i]; --j)&#123;\n                    int newv &#x3D; dp[oldl][j] + 1;\n                    if(newv &gt; dp[newl][i])&#123;\n                        dp[newl][i] &#x3D; newv;\n                        flag &#x3D; 1;\n                    &#125;                    \n                &#125;                \n            &#125;\n        &#125;\n        int v &#x3D; -1;\n        &#x2F;&#x2F; for(int i &#x3D; 0; i &lt; len; ++i)\n        &#x2F;&#x2F;     v &#x3D; max(v, dp[newl][i]);\n        for(int i &#x3D; 0; i &lt; len; ++i)\n            v &#x3D; max(v, dp[oldl][i]);\n        \n        return v;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>DP版本2：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123;\n        int len &#x3D; arr.size();\n        vector&lt;vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(len, 0));\n        vector&lt;vector&lt;int&gt; &gt; bigger(len,vector&lt;int&gt;(0,0));\n        vector&lt;int&gt; ischanged(len, 1);\n        for(int i &#x3D; 0;i &lt; len; i++)&#123;\n            int low &#x3D; max(0, i - d);\n            int high &#x3D; min(len - 1, i + d);\n            for(int j &#x3D; i - 1; j &gt;&#x3D; low; j--)\n                if(arr[i] &gt; arr[j]) bigger[j].push_back(i);\n                else break;\n            \n            for(int j &#x3D; i + 1; j &lt;&#x3D; high; j++)\n                if(arr[i] &gt; arr[j]) bigger[j].push_back(i);\n                else break;                 \n        &#125;\n\n\n        int maxstep &#x3D; 0, flag &#x3D; 1;\n        int newl &#x3D; 0, oldl &#x3D; 1;\n        while(flag)&#123;\n            flag &#x3D; 0;    \n            swap(newl, oldl);\n\n            for(int i &#x3D; 0; i &lt; len; i++)&#123;\n                if(ischanged[i] &#x3D;&#x3D; 0) continue;\n                ischanged[i] &#x3D; 0;\n                for(int j &#x3D; 0; j &lt; bigger[i].size(); j++)&#123;\n                    int newv &#x3D; dp[oldl][bigger[i][j]] + 1;\n                    if(newv &gt; dp[newl][i])&#123;\n                        dp[newl][i] &#x3D; newv;\n                        flag &#x3D; 1;\n                        ischanged[i] &#x3D; 1;\n                    &#125;\n                    &#x2F;&#x2F; dp[newl][i] &#x3D; max(dp[newl][i], dp[oldl][bigger[i][j]] + 1);                    \n                &#125;\n                maxstep &#x3D; max(dp[newl][i], maxstep);\n            &#125;\n        &#125;\n\n        return maxstep + 1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"135. Candy","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-10T00:02:10.000Z","_content":"\n这题还行吧，一般一般。\n\n<!-- more -->\n\n#### [135. Candy](https://leetcode-cn.com/problems/candy/)\n\n### 思路：\n\n简单思路：记忆化搜索candy[i]。\n\n更有技巧性：从左到右遍历更新candy[i],再从右到左遍历更新candy.\n\n更大的脑洞：按峰值和谷值计算机总值。\n\n![image.png](http://static.come2rss.xyz/df2bada8d7abe1d0550ebee880b5bf7b00cb38d553f008a9eb25491ddc356533-image.png)\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> candys;\n    int len;\n    int getcandys(int pos, vector<int>& ratings){\n        if(candys[pos] == -1){\n            if(pos == 0 && ratings[pos] > ratings[pos + 1])\n                candys[pos] = getcandys(pos + 1, ratings) + 1;\n            else if(pos == len - 1 &&  ratings[pos] > ratings[pos - 1])\n                candys[pos] = getcandys(pos - 1, ratings) + 1;\n            else if(pos < len - 1 && pos > 0 && ratings[pos] > min(ratings[pos -1], ratings[pos + 1])){\n                if(ratings[pos] > ratings[pos - 1])\n                    candys[pos] = getcandys(pos - 1, ratings) + 1;\n                if(ratings[pos] >  ratings[pos + 1])\n                    candys[pos] =  max(getcandys(pos + 1, ratings) + 1, candys[pos]);\n            }\n             \n            else candys[pos] = 1;\n        }\n        cout << pos << candys[pos] << endl;\n        return candys[pos];\n\n    }\n    int candy(vector<int>& ratings) {\n        len = ratings.size();\n        candys.resize(len, -1);\n        int res = 0;\n        if(len > 1)\n        for(int i = 0;i < len; i++){\n            res += getcandys(i, ratings);\n        }\n        else return 1;\n        return res;\n    }\n};\n```\n\n","source":"_posts/刷题/搜索/记忆化搜索\n/135-Candy.md","raw":"---\ntitle: 135. Candy\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-10 08:02:10\n---\n\n这题还行吧，一般一般。\n\n<!-- more -->\n\n#### [135. Candy](https://leetcode-cn.com/problems/candy/)\n\n### 思路：\n\n简单思路：记忆化搜索candy[i]。\n\n更有技巧性：从左到右遍历更新candy[i],再从右到左遍历更新candy.\n\n更大的脑洞：按峰值和谷值计算机总值。\n\n![image.png](http://static.come2rss.xyz/df2bada8d7abe1d0550ebee880b5bf7b00cb38d553f008a9eb25491ddc356533-image.png)\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> candys;\n    int len;\n    int getcandys(int pos, vector<int>& ratings){\n        if(candys[pos] == -1){\n            if(pos == 0 && ratings[pos] > ratings[pos + 1])\n                candys[pos] = getcandys(pos + 1, ratings) + 1;\n            else if(pos == len - 1 &&  ratings[pos] > ratings[pos - 1])\n                candys[pos] = getcandys(pos - 1, ratings) + 1;\n            else if(pos < len - 1 && pos > 0 && ratings[pos] > min(ratings[pos -1], ratings[pos + 1])){\n                if(ratings[pos] > ratings[pos - 1])\n                    candys[pos] = getcandys(pos - 1, ratings) + 1;\n                if(ratings[pos] >  ratings[pos + 1])\n                    candys[pos] =  max(getcandys(pos + 1, ratings) + 1, candys[pos]);\n            }\n             \n            else candys[pos] = 1;\n        }\n        cout << pos << candys[pos] << endl;\n        return candys[pos];\n\n    }\n    int candy(vector<int>& ratings) {\n        len = ratings.size();\n        candys.resize(len, -1);\n        int res = 0;\n        if(len > 1)\n        for(int i = 0;i < len; i++){\n            res += getcandys(i, ratings);\n        }\n        else return 1;\n        return res;\n    }\n};\n```\n\n","slug":"刷题-搜索-记忆化搜索-135-Candy","published":1,"updated":"2021-01-28T14:04:37.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6n004nl5uo8xt2d4n3","content":"<p>这题还行吧，一般一般。</p>\n<span id=\"more\"></span>\n\n<h4 id=\"135-Candy\"><a href=\"#135-Candy\" class=\"headerlink\" title=\"135. Candy\"></a><a href=\"https://leetcode-cn.com/problems/candy/\">135. Candy</a></h4><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>简单思路：记忆化搜索candy[i]。</p>\n<p>更有技巧性：从左到右遍历更新candy[i],再从右到左遍历更新candy.</p>\n<p>更大的脑洞：按峰值和谷值计算机总值。</p>\n<p><img src=\"http://static.come2rss.xyz/df2bada8d7abe1d0550ebee880b5bf7b00cb38d553f008a9eb25491ddc356533-image.png\" alt=\"image.png\"></p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; candys;\n    int len;\n    int getcandys(int pos, vector&lt;int&gt;&amp; ratings)&#123;\n        if(candys[pos] &#x3D;&#x3D; -1)&#123;\n            if(pos &#x3D;&#x3D; 0 &amp;&amp; ratings[pos] &gt; ratings[pos + 1])\n                candys[pos] &#x3D; getcandys(pos + 1, ratings) + 1;\n            else if(pos &#x3D;&#x3D; len - 1 &amp;&amp;  ratings[pos] &gt; ratings[pos - 1])\n                candys[pos] &#x3D; getcandys(pos - 1, ratings) + 1;\n            else if(pos &lt; len - 1 &amp;&amp; pos &gt; 0 &amp;&amp; ratings[pos] &gt; min(ratings[pos -1], ratings[pos + 1]))&#123;\n                if(ratings[pos] &gt; ratings[pos - 1])\n                    candys[pos] &#x3D; getcandys(pos - 1, ratings) + 1;\n                if(ratings[pos] &gt;  ratings[pos + 1])\n                    candys[pos] &#x3D;  max(getcandys(pos + 1, ratings) + 1, candys[pos]);\n            &#125;\n             \n            else candys[pos] &#x3D; 1;\n        &#125;\n        cout &lt;&lt; pos &lt;&lt; candys[pos] &lt;&lt; endl;\n        return candys[pos];\n\n    &#125;\n    int candy(vector&lt;int&gt;&amp; ratings) &#123;\n        len &#x3D; ratings.size();\n        candys.resize(len, -1);\n        int res &#x3D; 0;\n        if(len &gt; 1)\n        for(int i &#x3D; 0;i &lt; len; i++)&#123;\n            res +&#x3D; getcandys(i, ratings);\n        &#125;\n        else return 1;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"38CRN37","excerpt":"<p>这题还行吧，一般一般。</p>","more":"<h4 id=\"135-Candy\"><a href=\"#135-Candy\" class=\"headerlink\" title=\"135. Candy\"></a><a href=\"https://leetcode-cn.com/problems/candy/\">135. Candy</a></h4><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>简单思路：记忆化搜索candy[i]。</p>\n<p>更有技巧性：从左到右遍历更新candy[i],再从右到左遍历更新candy.</p>\n<p>更大的脑洞：按峰值和谷值计算机总值。</p>\n<p><img src=\"http://static.come2rss.xyz/df2bada8d7abe1d0550ebee880b5bf7b00cb38d553f008a9eb25491ddc356533-image.png\" alt=\"image.png\"></p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; candys;\n    int len;\n    int getcandys(int pos, vector&lt;int&gt;&amp; ratings)&#123;\n        if(candys[pos] &#x3D;&#x3D; -1)&#123;\n            if(pos &#x3D;&#x3D; 0 &amp;&amp; ratings[pos] &gt; ratings[pos + 1])\n                candys[pos] &#x3D; getcandys(pos + 1, ratings) + 1;\n            else if(pos &#x3D;&#x3D; len - 1 &amp;&amp;  ratings[pos] &gt; ratings[pos - 1])\n                candys[pos] &#x3D; getcandys(pos - 1, ratings) + 1;\n            else if(pos &lt; len - 1 &amp;&amp; pos &gt; 0 &amp;&amp; ratings[pos] &gt; min(ratings[pos -1], ratings[pos + 1]))&#123;\n                if(ratings[pos] &gt; ratings[pos - 1])\n                    candys[pos] &#x3D; getcandys(pos - 1, ratings) + 1;\n                if(ratings[pos] &gt;  ratings[pos + 1])\n                    candys[pos] &#x3D;  max(getcandys(pos + 1, ratings) + 1, candys[pos]);\n            &#125;\n             \n            else candys[pos] &#x3D; 1;\n        &#125;\n        cout &lt;&lt; pos &lt;&lt; candys[pos] &lt;&lt; endl;\n        return candys[pos];\n\n    &#125;\n    int candy(vector&lt;int&gt;&amp; ratings) &#123;\n        len &#x3D; ratings.size();\n        candys.resize(len, -1);\n        int res &#x3D; 0;\n        if(len &gt; 1)\n        for(int i &#x3D; 0;i &lt; len; i++)&#123;\n            res +&#x3D; getcandys(i, ratings);\n        &#125;\n        else return 1;\n        return res;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1. Two Sum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-25T07:44:50.000Z","_content":"\n\n\n\n## [1. Two Sum](https://leetcode-cn.com/problems/two-sum/)\n\n## 思路：\n\n\n\nhash即可\n\n练习一下 STL。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_set<int> sset;\n        map<int, int> ridx;\n        for(int i = 0; i < nums.size(); ++i){\n            int k = nums[i];\n            if(sset.count(target - k)){\n                return {ridx[target - k], i};\n            }\n\n            sset.insert(k);\n            ridx[k] = i;\n        }\n        return {0 , 0};\n    }\n};\n```\n\n直接用map更好\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {        \n        map<int, int> ridx;\n        for(int i = 0; i < nums.size(); ++i){\n            int k = nums[i];\n            if(ridx.count(target - k)){\n                return {ridx[target - k], i};\n            }\n            ridx[k] = i;\n        }\n        return {0 , 0};\n    }\n};\n```","source":"_posts/刷题/数据结构/set\n/1-Two-Sum.md","raw":"---\ntitle: 1. Two Sum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-25 15:44:50\n---\n\n\n\n\n## [1. Two Sum](https://leetcode-cn.com/problems/two-sum/)\n\n## 思路：\n\n\n\nhash即可\n\n练习一下 STL。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_set<int> sset;\n        map<int, int> ridx;\n        for(int i = 0; i < nums.size(); ++i){\n            int k = nums[i];\n            if(sset.count(target - k)){\n                return {ridx[target - k], i};\n            }\n\n            sset.insert(k);\n            ridx[k] = i;\n        }\n        return {0 , 0};\n    }\n};\n```\n\n直接用map更好\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {        \n        map<int, int> ridx;\n        for(int i = 0; i < nums.size(); ++i){\n            int k = nums[i];\n            if(ridx.count(target - k)){\n                return {ridx[target - k], i};\n            }\n            ridx[k] = i;\n        }\n        return {0 , 0};\n    }\n};\n```","slug":"刷题-数据结构-set-1-Two-Sum","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6n004ol5uob7px2byc","content":"<h2 id=\"1-Two-Sum\"><a href=\"#1-Two-Sum\" class=\"headerlink\" title=\"1. Two Sum\"></a><a href=\"https://leetcode-cn.com/problems/two-sum/\">1. Two Sum</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>hash即可</p>\n<p>练习一下 STL。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        unordered_set&lt;int&gt; sset;\n        map&lt;int, int&gt; ridx;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            int k &#x3D; nums[i];\n            if(sset.count(target - k))&#123;\n                return &#123;ridx[target - k], i&#125;;\n            &#125;\n\n            sset.insert(k);\n            ridx[k] &#x3D; i;\n        &#125;\n        return &#123;0 , 0&#125;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>直接用map更好</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        \n        map&lt;int, int&gt; ridx;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            int k &#x3D; nums[i];\n            if(ridx.count(target - k))&#123;\n                return &#123;ridx[target - k], i&#125;;\n            &#125;\n            ridx[k] &#x3D; i;\n        &#125;\n        return &#123;0 , 0&#125;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2HA41EQ","excerpt":"<h2 id=\"1-Two-Sum\"><a href=\"#1-Two-Sum\" class=\"headerlink\" title=\"1. Two Sum\"></a><a href=\"https://leetcode-cn.com/problems/two-sum/\">1. Two Sum</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>hash即可</p>\n<p>练习一下 STL。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        unordered_set&lt;int&gt; sset;\n        map&lt;int, int&gt; ridx;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            int k &#x3D; nums[i];\n            if(sset.count(target - k))&#123;\n                return &#123;ridx[target - k], i&#125;;\n            &#125;\n\n            sset.insert(k);\n            ridx[k] &#x3D; i;\n        &#125;\n        return &#123;0 , 0&#125;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>直接用map更好</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;        \n        map&lt;int, int&gt; ridx;\n        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;\n            int k &#x3D; nums[i];\n            if(ridx.count(target - k))&#123;\n                return &#123;ridx[target - k], i&#125;;\n            &#125;\n            ridx[k] &#x3D; i;\n        &#125;\n        return &#123;0 , 0&#125;;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"128. Longest Consecutive Sequence","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-25T07:44:42.000Z","_content":"\n\n\n\n\n\n\n## [128. Longest Consecutive Sequence](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n## 思路：\n\n\n\n1. sort排序\n2. 用set去重，在序列的第一个数字上搜索连续数字长度值！\n\n<!-- more -->\n\n\n\n\n\n## 代码：\n\n\n\nsort\n\n```c++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n        int mlen = 1, len = 1;\n        \n        for(int i = 1; i < nums.size(); ++i){\n            if(nums[i] == nums[i - 1] + 1){\n                len++;\n            }else if(nums[i] != nums[i - 1]) len = 1;\n            mlen = max(mlen, len);\n        }\n        return mlen;\n    }\n};\n```\n\nset优化\n\n```c++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n\n        int mlen = 1;\n        unordered_set<int> sset;\n        for(auto &v : nums) sset.insert(v);\n        for(auto &v : sset){\n            if(sset.count(v - 1)) continue; // 只有连续序列的第一个数才能计算后续长度\n            int len = 1;\n            while(sset.count(len + v)){\n                len++;\n            }\n            mlen = max(mlen, len);\n            // cout << v << ' ' << len; // unordered_set 遍历的数字不是有序的            \n        }\n        return mlen;\n    }\n};\n```","source":"_posts/刷题/数据结构/set\n/128-Longest-Consecutive-Sequence.md","raw":"---\ntitle: 128. Longest Consecutive Sequence\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-25 15:44:42\n---\n\n\n\n\n\n\n\n## [128. Longest Consecutive Sequence](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n## 思路：\n\n\n\n1. sort排序\n2. 用set去重，在序列的第一个数字上搜索连续数字长度值！\n\n<!-- more -->\n\n\n\n\n\n## 代码：\n\n\n\nsort\n\n```c++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n\n        sort(nums.begin(), nums.end());\n        int mlen = 1, len = 1;\n        \n        for(int i = 1; i < nums.size(); ++i){\n            if(nums[i] == nums[i - 1] + 1){\n                len++;\n            }else if(nums[i] != nums[i - 1]) len = 1;\n            mlen = max(mlen, len);\n        }\n        return mlen;\n    }\n};\n```\n\nset优化\n\n```c++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        if(nums.size() == 0) return 0;\n\n        int mlen = 1;\n        unordered_set<int> sset;\n        for(auto &v : nums) sset.insert(v);\n        for(auto &v : sset){\n            if(sset.count(v - 1)) continue; // 只有连续序列的第一个数才能计算后续长度\n            int len = 1;\n            while(sset.count(len + v)){\n                len++;\n            }\n            mlen = max(mlen, len);\n            // cout << v << ' ' << len; // unordered_set 遍历的数字不是有序的            \n        }\n        return mlen;\n    }\n};\n```","slug":"刷题-数据结构-set-128-Longest-Consecutive-Sequence","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6u004pl5uo5m77aebi","content":"<h2 id=\"128-Longest-Consecutive-Sequence\"><a href=\"#128-Longest-Consecutive-Sequence\" class=\"headerlink\" title=\"128. Longest Consecutive Sequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/\">128. Longest Consecutive Sequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>sort排序</li>\n<li>用set去重，在序列的第一个数字上搜索连续数字长度值！</li>\n</ol>\n<span id=\"more\"></span>\n\n\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>sort</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n\n        sort(nums.begin(), nums.end());\n        int mlen &#x3D; 1, len &#x3D; 1;\n        \n        for(int i &#x3D; 1; i &lt; nums.size(); ++i)&#123;\n            if(nums[i] &#x3D;&#x3D; nums[i - 1] + 1)&#123;\n                len++;\n            &#125;else if(nums[i] !&#x3D; nums[i - 1]) len &#x3D; 1;\n            mlen &#x3D; max(mlen, len);\n        &#125;\n        return mlen;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>set优化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n\n        int mlen &#x3D; 1;\n        unordered_set&lt;int&gt; sset;\n        for(auto &amp;v : nums) sset.insert(v);\n        for(auto &amp;v : sset)&#123;\n            if(sset.count(v - 1)) continue; &#x2F;&#x2F; 只有连续序列的第一个数才能计算后续长度\n            int len &#x3D; 1;\n            while(sset.count(len + v))&#123;\n                len++;\n            &#125;\n            mlen &#x3D; max(mlen, len);\n            &#x2F;&#x2F; cout &lt;&lt; v &lt;&lt; &#39; &#39; &lt;&lt; len; &#x2F;&#x2F; unordered_set 遍历的数字不是有序的            \n        &#125;\n        return mlen;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2RZ68JN","excerpt":"<h2 id=\"128-Longest-Consecutive-Sequence\"><a href=\"#128-Longest-Consecutive-Sequence\" class=\"headerlink\" title=\"128. Longest Consecutive Sequence\"></a><a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/\">128. Longest Consecutive Sequence</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>sort排序</li>\n<li>用set去重，在序列的第一个数字上搜索连续数字长度值！</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>sort</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n\n        sort(nums.begin(), nums.end());\n        int mlen &#x3D; 1, len &#x3D; 1;\n        \n        for(int i &#x3D; 1; i &lt; nums.size(); ++i)&#123;\n            if(nums[i] &#x3D;&#x3D; nums[i - 1] + 1)&#123;\n                len++;\n            &#125;else if(nums[i] !&#x3D; nums[i - 1]) len &#x3D; 1;\n            mlen &#x3D; max(mlen, len);\n        &#125;\n        return mlen;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>set优化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;\n        if(nums.size() &#x3D;&#x3D; 0) return 0;\n\n        int mlen &#x3D; 1;\n        unordered_set&lt;int&gt; sset;\n        for(auto &amp;v : nums) sset.insert(v);\n        for(auto &amp;v : sset)&#123;\n            if(sset.count(v - 1)) continue; &#x2F;&#x2F; 只有连续序列的第一个数才能计算后续长度\n            int len &#x3D; 1;\n            while(sset.count(len + v))&#123;\n                len++;\n            &#125;\n            mlen &#x3D; max(mlen, len);\n            &#x2F;&#x2F; cout &lt;&lt; v &lt;&lt; &#39; &#39; &lt;&lt; len; &#x2F;&#x2F; unordered_set 遍历的数字不是有序的            \n        &#125;\n        return mlen;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"23. Merge k Sorted Lists","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-24T13:10:48.000Z","_content":"\n\n\n\n\n## [23. Merge k Sorted Lists](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n## 思路：\n\n\n\n优先队列排node就行。<!-- more -->\n\n## 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\n    class Node{\n        \n    public:\n        ListNode *p;\n        Node(ListNode *_p): p(_p){}\n        friend bool operator < (Node p1, Node p2){\n            return p1.p->val > p2.p->val;\n        }\n        // friend bool operator < (string s1, string s2){\n        //     return s1.name < s2.name;\n        // }\n    \n    };\n    priority_queue<Node> pq;\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        for(auto &p : lists) \n            if(p) pq.push(Node(p));\n        ListNode *root , *p, *oldp;\n        p =  nullptr;\n        oldp = root = new ListNode();\n        while(pq.size()){\n            p = pq.top().p;\n            pq.pop();\n            if(p->next) pq.push(Node(p->next));\n            oldp->next = p;\n            oldp = p;\n            \n        }\n        return root->next;\n    }\n};\n```","source":"_posts/刷题/数据结构/优先队列\n/23-Merge-k-Sorted-Lists.md","raw":"---\ntitle: 23. Merge k Sorted Lists\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-24 21:10:48\n---\n\n\n\n\n\n## [23. Merge k Sorted Lists](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n## 思路：\n\n\n\n优先队列排node就行。<!-- more -->\n\n## 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\n    class Node{\n        \n    public:\n        ListNode *p;\n        Node(ListNode *_p): p(_p){}\n        friend bool operator < (Node p1, Node p2){\n            return p1.p->val > p2.p->val;\n        }\n        // friend bool operator < (string s1, string s2){\n        //     return s1.name < s2.name;\n        // }\n    \n    };\n    priority_queue<Node> pq;\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        for(auto &p : lists) \n            if(p) pq.push(Node(p));\n        ListNode *root , *p, *oldp;\n        p =  nullptr;\n        oldp = root = new ListNode();\n        while(pq.size()){\n            p = pq.top().p;\n            pq.pop();\n            if(p->next) pq.push(Node(p->next));\n            oldp->next = p;\n            oldp = p;\n            \n        }\n        return root->next;\n    }\n};\n```","slug":"刷题-数据结构-优先队列-23-Merge-k-Sorted-Lists","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6v004ql5uo1nj34f6c","content":"<h2 id=\"23-Merge-k-Sorted-Lists\"><a href=\"#23-Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"23. Merge k Sorted Lists\"></a><a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\">23. Merge k Sorted Lists</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>优先队列排node就行。<span id=\"more\"></span></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    class Node&#123;\n        \n    public:\n        ListNode *p;\n        Node(ListNode *_p): p(_p)&#123;&#125;\n        friend bool operator &lt; (Node p1, Node p2)&#123;\n            return p1.p-&gt;val &gt; p2.p-&gt;val;\n        &#125;\n        &#x2F;&#x2F; friend bool operator &lt; (string s1, string s2)&#123;\n        &#x2F;&#x2F;     return s1.name &lt; s2.name;\n        &#x2F;&#x2F; &#125;\n    \n    &#125;;\n    priority_queue&lt;Node&gt; pq;\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        for(auto &amp;p : lists) \n            if(p) pq.push(Node(p));\n        ListNode *root , *p, *oldp;\n        p &#x3D;  nullptr;\n        oldp &#x3D; root &#x3D; new ListNode();\n        while(pq.size())&#123;\n            p &#x3D; pq.top().p;\n            pq.pop();\n            if(p-&gt;next) pq.push(Node(p-&gt;next));\n            oldp-&gt;next &#x3D; p;\n            oldp &#x3D; p;\n            \n        &#125;\n        return root-&gt;next;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"28578JA","excerpt":"<h2 id=\"23-Merge-k-Sorted-Lists\"><a href=\"#23-Merge-k-Sorted-Lists\" class=\"headerlink\" title=\"23. Merge k Sorted Lists\"></a><a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\">23. Merge k Sorted Lists</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>优先队列排node就行。","more":"</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    class Node&#123;\n        \n    public:\n        ListNode *p;\n        Node(ListNode *_p): p(_p)&#123;&#125;\n        friend bool operator &lt; (Node p1, Node p2)&#123;\n            return p1.p-&gt;val &gt; p2.p-&gt;val;\n        &#125;\n        &#x2F;&#x2F; friend bool operator &lt; (string s1, string s2)&#123;\n        &#x2F;&#x2F;     return s1.name &lt; s2.name;\n        &#x2F;&#x2F; &#125;\n    \n    &#125;;\n    priority_queue&lt;Node&gt; pq;\npublic:\n    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;\n        for(auto &amp;p : lists) \n            if(p) pq.push(Node(p));\n        ListNode *root , *p, *oldp;\n        p &#x3D;  nullptr;\n        oldp &#x3D; root &#x3D; new ListNode();\n        while(pq.size())&#123;\n            p &#x3D; pq.top().p;\n            pq.pop();\n            if(p-&gt;next) pq.push(Node(p-&gt;next));\n            oldp-&gt;next &#x3D; p;\n            oldp &#x3D; p;\n            \n        &#125;\n        return root-&gt;next;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"149. Max Points on a Line","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-27T15:23:34.000Z","_content":"\n\n\n\n\n\n\n## [149. Max Points on a Line](https://leetcode-cn.com/problems/max-points-on-a-line/)\n\n\n\n## 思路：\n\n\n\n思路差不多，但是走歪了。害~\n\n> 整体思路是两层嵌套的for循环。两点可以确定一条直线，那么选择固定一个点，求其他点与固定点的斜率，如果斜率相同，那么斜率相同的点在同一条直线上。\n> 同时要考虑，斜率可能为无穷大，也有可能两个点为同一个点。键值应该为斜率。\n>\n> 通过dup记录这一次内层循环中与p1相同的点。\n> 通过one_round_res统计每一次内层for循环的结果。\n> 将斜率无穷大定义为FLT_MAX。\n>\n> 键值key为斜率，其数据类型选择为long double即可通过\n> `vector<vector<int>> points = { {0,0},{94911150,94911151},{94911151,94911152} };`\n> 来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/max-points-on-a-line/solution/cha-xi-biao-jie-fa-bu-xu-yao-jiang-xie-l-ayf2/)\n><!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        if(points.size() == 0 ) return 0;\n        int maxct = 1;        \n        for(int i = 0; i < points.size(); ++i){\n            // 记录经过一个点所有直线，即使斜率为无穷大\n            // 因为只有一个点，无需记录直线公式中的x = c 和 x = k * y + b 中的 c, b\n            unordered_map<long double, int> record; \n            int ct = 1;\n            int depu = 0;\n            for(int j = i + 1; j < points.size(); ++j){                \n                auto p1 = points[i];\n                auto p2 = points[j];\n                if(p1 == p2){  // 重合点\n                    ++depu;\n                    continue;\n                }\n                if(p1[0] > p2[0]) swap(p1, p2);\n                if(p2[0] == p1[0]){                    \n                    ct = max(ct, ++record[DBL_MAX] + 1);                                     \n                }else{\n                    long double k = (long double)(p2[1] - p1[1]) / (p2[0] - p1[0]);\n                    // double b = p2[1] - k * p2[0];                                     \n                    ct = max(ct, ++record[k] + 1);\n                }                                \n            }            \n            maxct = max(maxct, ct + depu);\n        }        \n        return maxct;\n    }\n};\n```","source":"_posts/刷题/数据结构/哈希/149-Max-Points-on-a-Line.md","raw":"---\ntitle: 149. Max Points on a Line\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-27 23:23:34\n---\n\n\n\n\n\n\n\n## [149. Max Points on a Line](https://leetcode-cn.com/problems/max-points-on-a-line/)\n\n\n\n## 思路：\n\n\n\n思路差不多，但是走歪了。害~\n\n> 整体思路是两层嵌套的for循环。两点可以确定一条直线，那么选择固定一个点，求其他点与固定点的斜率，如果斜率相同，那么斜率相同的点在同一条直线上。\n> 同时要考虑，斜率可能为无穷大，也有可能两个点为同一个点。键值应该为斜率。\n>\n> 通过dup记录这一次内层循环中与p1相同的点。\n> 通过one_round_res统计每一次内层for循环的结果。\n> 将斜率无穷大定义为FLT_MAX。\n>\n> 键值key为斜率，其数据类型选择为long double即可通过\n> `vector<vector<int>> points = { {0,0},{94911150,94911151},{94911151,94911152} };`\n> 来源：[力扣（LeetCode）](https://leetcode-cn.com/problems/max-points-on-a-line/solution/cha-xi-biao-jie-fa-bu-xu-yao-jiang-xie-l-ayf2/)\n><!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        if(points.size() == 0 ) return 0;\n        int maxct = 1;        \n        for(int i = 0; i < points.size(); ++i){\n            // 记录经过一个点所有直线，即使斜率为无穷大\n            // 因为只有一个点，无需记录直线公式中的x = c 和 x = k * y + b 中的 c, b\n            unordered_map<long double, int> record; \n            int ct = 1;\n            int depu = 0;\n            for(int j = i + 1; j < points.size(); ++j){                \n                auto p1 = points[i];\n                auto p2 = points[j];\n                if(p1 == p2){  // 重合点\n                    ++depu;\n                    continue;\n                }\n                if(p1[0] > p2[0]) swap(p1, p2);\n                if(p2[0] == p1[0]){                    \n                    ct = max(ct, ++record[DBL_MAX] + 1);                                     \n                }else{\n                    long double k = (long double)(p2[1] - p1[1]) / (p2[0] - p1[0]);\n                    // double b = p2[1] - k * p2[0];                                     \n                    ct = max(ct, ++record[k] + 1);\n                }                                \n            }            \n            maxct = max(maxct, ct + depu);\n        }        \n        return maxct;\n    }\n};\n```","slug":"刷题/数据结构/哈希/149-Max-Points-on-a-Line","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6w004rl5uo9qom0e1u","content":"<h2 id=\"149-Max-Points-on-a-Line\"><a href=\"#149-Max-Points-on-a-Line\" class=\"headerlink\" title=\"149. Max Points on a Line\"></a><a href=\"https://leetcode-cn.com/problems/max-points-on-a-line/\">149. Max Points on a Line</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>思路差不多，但是走歪了。害~</p>\n<blockquote>\n<p>整体思路是两层嵌套的for循环。两点可以确定一条直线，那么选择固定一个点，求其他点与固定点的斜率，如果斜率相同，那么斜率相同的点在同一条直线上。<br>同时要考虑，斜率可能为无穷大，也有可能两个点为同一个点。键值应该为斜率。</p>\n<p>通过dup记录这一次内层循环中与p1相同的点。<br>通过one_round_res统计每一次内层for循环的结果。<br>将斜率无穷大定义为FLT_MAX。</p>\n<p>键值key为斜率，其数据类型选择为long double即可通过<br><code>vector&lt;vector&lt;int&gt;&gt; points = &#123; &#123;0,0&#125;,&#123;94911150,94911151&#125;,&#123;94911151,94911152&#125; &#125;;</code><br>来源：<a href=\"https://leetcode-cn.com/problems/max-points-on-a-line/solution/cha-xi-biao-jie-fa-bu-xu-yao-jiang-xie-l-ayf2/\">力扣（LeetCode）</a></p>\n<span id=\"more\"></span>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        if(points.size() &#x3D;&#x3D; 0 ) return 0;\n        int maxct &#x3D; 1;        \n        for(int i &#x3D; 0; i &lt; points.size(); ++i)&#123;\n            &#x2F;&#x2F; 记录经过一个点所有直线，即使斜率为无穷大\n            &#x2F;&#x2F; 因为只有一个点，无需记录直线公式中的x &#x3D; c 和 x &#x3D; k * y + b 中的 c, b\n            unordered_map&lt;long double, int&gt; record; \n            int ct &#x3D; 1;\n            int depu &#x3D; 0;\n            for(int j &#x3D; i + 1; j &lt; points.size(); ++j)&#123;                \n                auto p1 &#x3D; points[i];\n                auto p2 &#x3D; points[j];\n                if(p1 &#x3D;&#x3D; p2)&#123;  &#x2F;&#x2F; 重合点\n                    ++depu;\n                    continue;\n                &#125;\n                if(p1[0] &gt; p2[0]) swap(p1, p2);\n                if(p2[0] &#x3D;&#x3D; p1[0])&#123;                    \n                    ct &#x3D; max(ct, ++record[DBL_MAX] + 1);                                     \n                &#125;else&#123;\n                    long double k &#x3D; (long double)(p2[1] - p1[1]) &#x2F; (p2[0] - p1[0]);\n                    &#x2F;&#x2F; double b &#x3D; p2[1] - k * p2[0];                                     \n                    ct &#x3D; max(ct, ++record[k] + 1);\n                &#125;                                \n            &#125;            \n            maxct &#x3D; max(maxct, ct + depu);\n        &#125;        \n        return maxct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"9RW8WC","excerpt":"<h2 id=\"149-Max-Points-on-a-Line\"><a href=\"#149-Max-Points-on-a-Line\" class=\"headerlink\" title=\"149. Max Points on a Line\"></a><a href=\"https://leetcode-cn.com/problems/max-points-on-a-line/\">149. Max Points on a Line</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>思路差不多，但是走歪了。害~</p>\n<blockquote>\n<p>整体思路是两层嵌套的for循环。两点可以确定一条直线，那么选择固定一个点，求其他点与固定点的斜率，如果斜率相同，那么斜率相同的点在同一条直线上。<br>同时要考虑，斜率可能为无穷大，也有可能两个点为同一个点。键值应该为斜率。</p>\n<p>通过dup记录这一次内层循环中与p1相同的点。<br>通过one_round_res统计每一次内层for循环的结果。<br>将斜率无穷大定义为FLT_MAX。</p>\n<p>键值key为斜率，其数据类型选择为long double即可通过<br><code>vector&lt;vector&lt;int&gt;&gt; points = &#123; &#123;0,0&#125;,&#123;94911150,94911151&#125;,&#123;94911151,94911152&#125; &#125;;</code><br>来源：<a href=\"https://leetcode-cn.com/problems/max-points-on-a-line/solution/cha-xi-biao-jie-fa-bu-xu-yao-jiang-xie-l-ayf2/\">力扣（LeetCode）</a></p>","more":"</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;\n        if(points.size() &#x3D;&#x3D; 0 ) return 0;\n        int maxct &#x3D; 1;        \n        for(int i &#x3D; 0; i &lt; points.size(); ++i)&#123;\n            &#x2F;&#x2F; 记录经过一个点所有直线，即使斜率为无穷大\n            &#x2F;&#x2F; 因为只有一个点，无需记录直线公式中的x &#x3D; c 和 x &#x3D; k * y + b 中的 c, b\n            unordered_map&lt;long double, int&gt; record; \n            int ct &#x3D; 1;\n            int depu &#x3D; 0;\n            for(int j &#x3D; i + 1; j &lt; points.size(); ++j)&#123;                \n                auto p1 &#x3D; points[i];\n                auto p2 &#x3D; points[j];\n                if(p1 &#x3D;&#x3D; p2)&#123;  &#x2F;&#x2F; 重合点\n                    ++depu;\n                    continue;\n                &#125;\n                if(p1[0] &gt; p2[0]) swap(p1, p2);\n                if(p2[0] &#x3D;&#x3D; p1[0])&#123;                    \n                    ct &#x3D; max(ct, ++record[DBL_MAX] + 1);                                     \n                &#125;else&#123;\n                    long double k &#x3D; (long double)(p2[1] - p1[1]) &#x2F; (p2[0] - p1[0]);\n                    &#x2F;&#x2F; double b &#x3D; p2[1] - k * p2[0];                                     \n                    ct &#x3D; max(ct, ++record[k] + 1);\n                &#125;                                \n            &#125;            \n            maxct &#x3D; max(maxct, ct + depu);\n        &#125;        \n        return maxct;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"210. Course Schedule II (Medium)","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-27T01:19:16.000Z","_content":"\n\n\n\n# [210. Course Schedule II](https://leetcode-cn.com/problems/course-schedule-ii/)\n\n\n\n\n\n## 思路：\n\n1. dfs + 判环 + 回溯 \n2. 入度\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> map;\n    stack<int> track;\n    vector<int> vis;\n    int flag = 0;\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        map.resize(numCourses);\n        vis.resize(numCourses);\n        for(auto e : prerequisites){\n            int u = e[0], v = e[1];\n            map[v].emplace_back(u);\n        }\n        for(int i = 0; i < numCourses; ++i)\n            if(!vis[i]) dfs(i);\n        vector<int> ans;\n        while(!track.empty()){\n            ans.emplace_back(track.top());\n            track.pop();\n        }\n        if(flag) return {};\n        else return ans;\n    }\n\n    void dfs(int u){\n        vis[u] = -1;\n        for(auto v : map[u]){\n            if(!vis[v]){\n                dfs(v);\n            }else if(vis[v] == -1){ // 如果第一次遍历到一个环，那么这个环一定会被全部遍历到\n                flag = 1;\n            }\n        }\n        vis[u] = 1;\n        track.push(u);\n    }\n};\n\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> map;\n    vector<int> indegrees;\n    queue<int> que;\n    int flag = 0;\n\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        map.resize(numCourses);\n        indegrees.resize(numCourses);\n        for(auto e : prerequisites){\n            int u = e[0], v = e[1];\n            map[v].emplace_back(u);\n            ++indegrees[u];\n        }\n        for(int i = 0; i < numCourses; ++i)\n            if(!indegrees[i]) que.push(i);\n        vector<int> ans;\n        \n        while(!que.empty()){\n           int t = que.front(); \n           ans.push_back(t);\n           que.pop();\n           for(auto v : map[t]){\n                --indegrees[v];\n                if(indegrees[v] == 0)\n                    que.push(v);\n           }\n        }\n        if(ans.size() != numCourses) return {};\n        else return ans;\n    }\n\n};\n```","source":"_posts/刷题/数据结构/图\n/210-Course-Schedule-II-Medium.md","raw":"---\ntitle: 210. Course Schedule II (Medium)\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-27 09:19:16\ntags:\ncategories:\n---\n\n\n\n\n# [210. Course Schedule II](https://leetcode-cn.com/problems/course-schedule-ii/)\n\n\n\n\n\n## 思路：\n\n1. dfs + 判环 + 回溯 \n2. 入度\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> map;\n    stack<int> track;\n    vector<int> vis;\n    int flag = 0;\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        map.resize(numCourses);\n        vis.resize(numCourses);\n        for(auto e : prerequisites){\n            int u = e[0], v = e[1];\n            map[v].emplace_back(u);\n        }\n        for(int i = 0; i < numCourses; ++i)\n            if(!vis[i]) dfs(i);\n        vector<int> ans;\n        while(!track.empty()){\n            ans.emplace_back(track.top());\n            track.pop();\n        }\n        if(flag) return {};\n        else return ans;\n    }\n\n    void dfs(int u){\n        vis[u] = -1;\n        for(auto v : map[u]){\n            if(!vis[v]){\n                dfs(v);\n            }else if(vis[v] == -1){ // 如果第一次遍历到一个环，那么这个环一定会被全部遍历到\n                flag = 1;\n            }\n        }\n        vis[u] = 1;\n        track.push(u);\n    }\n};\n\n```\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> map;\n    vector<int> indegrees;\n    queue<int> que;\n    int flag = 0;\n\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        map.resize(numCourses);\n        indegrees.resize(numCourses);\n        for(auto e : prerequisites){\n            int u = e[0], v = e[1];\n            map[v].emplace_back(u);\n            ++indegrees[u];\n        }\n        for(int i = 0; i < numCourses; ++i)\n            if(!indegrees[i]) que.push(i);\n        vector<int> ans;\n        \n        while(!que.empty()){\n           int t = que.front(); \n           ans.push_back(t);\n           que.pop();\n           for(auto v : map[t]){\n                --indegrees[v];\n                if(indegrees[v] == 0)\n                    que.push(v);\n           }\n        }\n        if(ans.size() != numCourses) return {};\n        else return ans;\n    }\n\n};\n```","slug":"刷题-数据结构-图-210-Course-Schedule-II-Medium","published":1,"updated":"2021-02-27T01:19:29.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6w004sl5uo5xgefm39","content":"<h1 id=\"210-Course-Schedule-II\"><a href=\"#210-Course-Schedule-II\" class=\"headerlink\" title=\"210. Course Schedule II\"></a><a href=\"https://leetcode-cn.com/problems/course-schedule-ii/\">210. Course Schedule II</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dfs + 判环 + 回溯 </li>\n<li>入度</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; map;\n    stack&lt;int&gt; track;\n    vector&lt;int&gt; vis;\n    int flag &#x3D; 0;\n    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;\n        map.resize(numCourses);\n        vis.resize(numCourses);\n        for(auto e : prerequisites)&#123;\n            int u &#x3D; e[0], v &#x3D; e[1];\n            map[v].emplace_back(u);\n        &#125;\n        for(int i &#x3D; 0; i &lt; numCourses; ++i)\n            if(!vis[i]) dfs(i);\n        vector&lt;int&gt; ans;\n        while(!track.empty())&#123;\n            ans.emplace_back(track.top());\n            track.pop();\n        &#125;\n        if(flag) return &#123;&#125;;\n        else return ans;\n    &#125;\n\n    void dfs(int u)&#123;\n        vis[u] &#x3D; -1;\n        for(auto v : map[u])&#123;\n            if(!vis[v])&#123;\n                dfs(v);\n            &#125;else if(vis[v] &#x3D;&#x3D; -1)&#123; &#x2F;&#x2F; 如果第一次遍历到一个环，那么这个环一定会被全部遍历到\n                flag &#x3D; 1;\n            &#125;\n        &#125;\n        vis[u] &#x3D; 1;\n        track.push(u);\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; map;\n    vector&lt;int&gt; indegrees;\n    queue&lt;int&gt; que;\n    int flag &#x3D; 0;\n\n    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;\n        map.resize(numCourses);\n        indegrees.resize(numCourses);\n        for(auto e : prerequisites)&#123;\n            int u &#x3D; e[0], v &#x3D; e[1];\n            map[v].emplace_back(u);\n            ++indegrees[u];\n        &#125;\n        for(int i &#x3D; 0; i &lt; numCourses; ++i)\n            if(!indegrees[i]) que.push(i);\n        vector&lt;int&gt; ans;\n        \n        while(!que.empty())&#123;\n           int t &#x3D; que.front(); \n           ans.push_back(t);\n           que.pop();\n           for(auto v : map[t])&#123;\n                --indegrees[v];\n                if(indegrees[v] &#x3D;&#x3D; 0)\n                    que.push(v);\n           &#125;\n        &#125;\n        if(ans.size() !&#x3D; numCourses) return &#123;&#125;;\n        else return ans;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"2JZV5X0","excerpt":"<h1 id=\"210-Course-Schedule-II\"><a href=\"#210-Course-Schedule-II\" class=\"headerlink\" title=\"210. Course Schedule II\"></a><a href=\"https://leetcode-cn.com/problems/course-schedule-ii/\">210. Course Schedule II</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>dfs + 判环 + 回溯 </li>\n<li>入度</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; map;\n    stack&lt;int&gt; track;\n    vector&lt;int&gt; vis;\n    int flag &#x3D; 0;\n    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;\n        map.resize(numCourses);\n        vis.resize(numCourses);\n        for(auto e : prerequisites)&#123;\n            int u &#x3D; e[0], v &#x3D; e[1];\n            map[v].emplace_back(u);\n        &#125;\n        for(int i &#x3D; 0; i &lt; numCourses; ++i)\n            if(!vis[i]) dfs(i);\n        vector&lt;int&gt; ans;\n        while(!track.empty())&#123;\n            ans.emplace_back(track.top());\n            track.pop();\n        &#125;\n        if(flag) return &#123;&#125;;\n        else return ans;\n    &#125;\n\n    void dfs(int u)&#123;\n        vis[u] &#x3D; -1;\n        for(auto v : map[u])&#123;\n            if(!vis[v])&#123;\n                dfs(v);\n            &#125;else if(vis[v] &#x3D;&#x3D; -1)&#123; &#x2F;&#x2F; 如果第一次遍历到一个环，那么这个环一定会被全部遍历到\n                flag &#x3D; 1;\n            &#125;\n        &#125;\n        vis[u] &#x3D; 1;\n        track.push(u);\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; map;\n    vector&lt;int&gt; indegrees;\n    queue&lt;int&gt; que;\n    int flag &#x3D; 0;\n\n    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;\n        map.resize(numCourses);\n        indegrees.resize(numCourses);\n        for(auto e : prerequisites)&#123;\n            int u &#x3D; e[0], v &#x3D; e[1];\n            map[v].emplace_back(u);\n            ++indegrees[u];\n        &#125;\n        for(int i &#x3D; 0; i &lt; numCourses; ++i)\n            if(!indegrees[i]) que.push(i);\n        vector&lt;int&gt; ans;\n        \n        while(!que.empty())&#123;\n           int t &#x3D; que.front(); \n           ans.push_back(t);\n           que.pop();\n           for(auto v : map[t])&#123;\n                --indegrees[v];\n                if(indegrees[v] &#x3D;&#x3D; 0)\n                    que.push(v);\n           &#125;\n        &#125;\n        if(ans.size() !&#x3D; numCourses) return &#123;&#125;;\n        else return ans;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"332. Reconstruct Itinerary","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-28T06:43:49.000Z","_content":"\n\n\n\n## [332. Reconstruct Itinerary](https://leetcode-cn.com/problems/reconstruct-itinerary/)\n\n图论补充知识：\n\n通过图中所有边恰好一次且行遍所有顶点的通路称为**欧拉通路**。\n\n通过图中所有边恰好一次且行遍所有顶点的回路称为**欧拉回路**。\n\n<!-- more -->\n\n具有欧拉回路的无向图称为**欧拉图**。\n\n具有欧拉通路但不具有欧拉回路的无向图称为**半欧拉图**。\n\n因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。\n\n\n\n如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：\n\n对于**无向图** G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。\n\n对于**无向图** G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2个奇度顶点。\n\n对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。\n\n对于**有向图** G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且\n\n+ 恰有一个顶点的出度与入度差为 1；\n+ 恰有一个顶点的入度与出度差为 1；\n+ 所有其他顶点的入度和出度相同。\n\n## 思路：\n\n首先，以站点为点，tickets为单向边，可建有向图。\n\n题目保证了欧拉图的存在，我们需要在图上寻找一条字母序最小的欧拉通路。我们可以使用Hierholzer 算法求出该通路，其中优先遍历字母序最小的站点即可。\n\n#### Hierholzer 算法\n\n算法流程如下：\n\n1. 从某点开始出发，遍历该图\n2. 每次移动后，删除刚刚经过的边（DFS）\n3. 当遍历该节点结束后，也就是没有其他路径可走，把节点记录下来。\n\n因为每次记录的节点都是当时遍历时最后退出的节点，所以必定比之前压入的节点在欧拉图前，同时由于删边的性质和起点是欧拉通路的起点，保证了路径的有效性。所以一定能搜到。\n\n> 一开始把票当成点，相同的点当成边，把简单的欧拉问题变成了复杂的旅行商问题，我干！\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    map<string, priority_queue<string, vector<string>, greater<string>>> vec;\n\n    vector<string> path;\n\n    void dfs(string curr){\n        while(vec.count(curr) && vec[curr].size()){\n            string tmp = vec[curr].top();\n            vec[curr].pop();\n            dfs(tmp);\n        }\n        path.emplace_back(curr);\n    }\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        for(auto &item : tickets){\n            vec[item[0]].push(item[1]);\n        }\n        dfs(\"JFK\");\n        reverse(path.begin(), path.end());\n        return path;\n    }\n};\n```","source":"_posts/刷题/数据结构/图\n/332-Reconstruct-Itinerary.md","raw":"---\ntitle: 332. Reconstruct Itinerary\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-28 14:43:49\n---\n\n\n\n\n## [332. Reconstruct Itinerary](https://leetcode-cn.com/problems/reconstruct-itinerary/)\n\n图论补充知识：\n\n通过图中所有边恰好一次且行遍所有顶点的通路称为**欧拉通路**。\n\n通过图中所有边恰好一次且行遍所有顶点的回路称为**欧拉回路**。\n\n<!-- more -->\n\n具有欧拉回路的无向图称为**欧拉图**。\n\n具有欧拉通路但不具有欧拉回路的无向图称为**半欧拉图**。\n\n因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。\n\n\n\n如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：\n\n对于**无向图** G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。\n\n对于**无向图** G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2个奇度顶点。\n\n对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。\n\n对于**有向图** G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且\n\n+ 恰有一个顶点的出度与入度差为 1；\n+ 恰有一个顶点的入度与出度差为 1；\n+ 所有其他顶点的入度和出度相同。\n\n## 思路：\n\n首先，以站点为点，tickets为单向边，可建有向图。\n\n题目保证了欧拉图的存在，我们需要在图上寻找一条字母序最小的欧拉通路。我们可以使用Hierholzer 算法求出该通路，其中优先遍历字母序最小的站点即可。\n\n#### Hierholzer 算法\n\n算法流程如下：\n\n1. 从某点开始出发，遍历该图\n2. 每次移动后，删除刚刚经过的边（DFS）\n3. 当遍历该节点结束后，也就是没有其他路径可走，把节点记录下来。\n\n因为每次记录的节点都是当时遍历时最后退出的节点，所以必定比之前压入的节点在欧拉图前，同时由于删边的性质和起点是欧拉通路的起点，保证了路径的有效性。所以一定能搜到。\n\n> 一开始把票当成点，相同的点当成边，把简单的欧拉问题变成了复杂的旅行商问题，我干！\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    map<string, priority_queue<string, vector<string>, greater<string>>> vec;\n\n    vector<string> path;\n\n    void dfs(string curr){\n        while(vec.count(curr) && vec[curr].size()){\n            string tmp = vec[curr].top();\n            vec[curr].pop();\n            dfs(tmp);\n        }\n        path.emplace_back(curr);\n    }\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        for(auto &item : tickets){\n            vec[item[0]].push(item[1]);\n        }\n        dfs(\"JFK\");\n        reverse(path.begin(), path.end());\n        return path;\n    }\n};\n```","slug":"刷题-数据结构-图-332-Reconstruct-Itinerary","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6x004tl5uoao31b2ss","content":"<h2 id=\"332-Reconstruct-Itinerary\"><a href=\"#332-Reconstruct-Itinerary\" class=\"headerlink\" title=\"332. Reconstruct Itinerary\"></a><a href=\"https://leetcode-cn.com/problems/reconstruct-itinerary/\">332. Reconstruct Itinerary</a></h2><p>图论补充知识：</p>\n<p>通过图中所有边恰好一次且行遍所有顶点的通路称为<strong>欧拉通路</strong>。</p>\n<p>通过图中所有边恰好一次且行遍所有顶点的回路称为<strong>欧拉回路</strong>。</p>\n<span id=\"more\"></span>\n\n<p>具有欧拉回路的无向图称为<strong>欧拉图</strong>。</p>\n<p>具有欧拉通路但不具有欧拉回路的无向图称为<strong>半欧拉图</strong>。</p>\n<p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。</p>\n<p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p>\n<p>对于<strong>无向图</strong> G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</p>\n<p>对于<strong>无向图</strong> G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2个奇度顶点。</p>\n<p>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</p>\n<p>对于<strong>有向图</strong> G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且</p>\n<ul>\n<li>恰有一个顶点的出度与入度差为 1；</li>\n<li>恰有一个顶点的入度与出度差为 1；</li>\n<li>所有其他顶点的入度和出度相同。</li>\n</ul>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>首先，以站点为点，tickets为单向边，可建有向图。</p>\n<p>题目保证了欧拉图的存在，我们需要在图上寻找一条字母序最小的欧拉通路。我们可以使用Hierholzer 算法求出该通路，其中优先遍历字母序最小的站点即可。</p>\n<h4 id=\"Hierholzer-算法\"><a href=\"#Hierholzer-算法\" class=\"headerlink\" title=\"Hierholzer 算法\"></a>Hierholzer 算法</h4><p>算法流程如下：</p>\n<ol>\n<li>从某点开始出发，遍历该图</li>\n<li>每次移动后，删除刚刚经过的边（DFS）</li>\n<li>当遍历该节点结束后，也就是没有其他路径可走，把节点记录下来。</li>\n</ol>\n<p>因为每次记录的节点都是当时遍历时最后退出的节点，所以必定比之前压入的节点在欧拉图前，同时由于删边的性质和起点是欧拉通路的起点，保证了路径的有效性。所以一定能搜到。</p>\n<blockquote>\n<p>一开始把票当成点，相同的点当成边，把简单的欧拉问题变成了复杂的旅行商问题，我干！</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;&gt; vec;\n\n    vector&lt;string&gt; path;\n\n    void dfs(string curr)&#123;\n        while(vec.count(curr) &amp;&amp; vec[curr].size())&#123;\n            string tmp &#x3D; vec[curr].top();\n            vec[curr].pop();\n            dfs(tmp);\n        &#125;\n        path.emplace_back(curr);\n    &#125;\n    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;\n        for(auto &amp;item : tickets)&#123;\n            vec[item[0]].push(item[1]);\n        &#125;\n        dfs(&quot;JFK&quot;);\n        reverse(path.begin(), path.end());\n        return path;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"YP65G3","excerpt":"<h2 id=\"332-Reconstruct-Itinerary\"><a href=\"#332-Reconstruct-Itinerary\" class=\"headerlink\" title=\"332. Reconstruct Itinerary\"></a><a href=\"https://leetcode-cn.com/problems/reconstruct-itinerary/\">332. Reconstruct Itinerary</a></h2><p>图论补充知识：</p>\n<p>通过图中所有边恰好一次且行遍所有顶点的通路称为<strong>欧拉通路</strong>。</p>\n<p>通过图中所有边恰好一次且行遍所有顶点的回路称为<strong>欧拉回路</strong>。</p>","more":"<p>具有欧拉回路的无向图称为<strong>欧拉图</strong>。</p>\n<p>具有欧拉通路但不具有欧拉回路的无向图称为<strong>半欧拉图</strong>。</p>\n<p>因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。</p>\n<p>如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：</p>\n<p>对于<strong>无向图</strong> G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。</p>\n<p>对于<strong>无向图</strong> G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2个奇度顶点。</p>\n<p>对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。</p>\n<p>对于<strong>有向图</strong> G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且</p>\n<ul>\n<li>恰有一个顶点的出度与入度差为 1；</li>\n<li>恰有一个顶点的入度与出度差为 1；</li>\n<li>所有其他顶点的入度和出度相同。</li>\n</ul>\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>首先，以站点为点，tickets为单向边，可建有向图。</p>\n<p>题目保证了欧拉图的存在，我们需要在图上寻找一条字母序最小的欧拉通路。我们可以使用Hierholzer 算法求出该通路，其中优先遍历字母序最小的站点即可。</p>\n<h4 id=\"Hierholzer-算法\"><a href=\"#Hierholzer-算法\" class=\"headerlink\" title=\"Hierholzer 算法\"></a>Hierholzer 算法</h4><p>算法流程如下：</p>\n<ol>\n<li>从某点开始出发，遍历该图</li>\n<li>每次移动后，删除刚刚经过的边（DFS）</li>\n<li>当遍历该节点结束后，也就是没有其他路径可走，把节点记录下来。</li>\n</ol>\n<p>因为每次记录的节点都是当时遍历时最后退出的节点，所以必定比之前压入的节点在欧拉图前，同时由于删边的性质和起点是欧拉通路的起点，保证了路径的有效性。所以一定能搜到。</p>\n<blockquote>\n<p>一开始把票当成点，相同的点当成边，把简单的欧拉问题变成了复杂的旅行商问题，我干！</p>\n</blockquote>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;&gt; vec;\n\n    vector&lt;string&gt; path;\n\n    void dfs(string curr)&#123;\n        while(vec.count(curr) &amp;&amp; vec[curr].size())&#123;\n            string tmp &#x3D; vec[curr].top();\n            vec[curr].pop();\n            dfs(tmp);\n        &#125;\n        path.emplace_back(curr);\n    &#125;\n    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;\n        for(auto &amp;item : tickets)&#123;\n            vec[item[0]].push(item[1]);\n        &#125;\n        dfs(&quot;JFK&quot;);\n        reverse(path.begin(), path.end());\n        return path;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"785. Is Graph Bipartite?","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-24T04:17:57.000Z","_content":"\n\n\n\n\n\n\n\n# [785. Is Graph Bipartite?](https://leetcode-cn.com/problems/is-graph-bipartite/)\n\n\n\n## 思路：\n\n二分图染色问题，实际是就是判断任意一条边的形式是否有矛盾。\n\n$O(E +N )$\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int flag = 0;\n    vector<int> color;\n\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        color.resize(n, 0);\n        for(int i = 0;i < n; ++i){\n            if(color[i] == 0) colorize(graph, i, 1);\n            if(flag) return false;\n        }\n        return true;\n    }\n\n    void colorize(vector<vector<int>>& graph, int u, int ctype){\n        if(color[u]){\n            if(color[u] * ctype == -1) flag = 1;\n            return;\n        }\n        color[u] = ctype;\n        for(auto v : graph[u]) colorize(graph, v, -ctype);\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/图\n/785-Is-Graph-Bipartite.md","raw":"---\ntitle: 785. Is Graph Bipartite?\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-24 12:17:57\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n\n# [785. Is Graph Bipartite?](https://leetcode-cn.com/problems/is-graph-bipartite/)\n\n\n\n## 思路：\n\n二分图染色问题，实际是就是判断任意一条边的形式是否有矛盾。\n\n$O(E +N )$\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int flag = 0;\n    vector<int> color;\n\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        color.resize(n, 0);\n        for(int i = 0;i < n; ++i){\n            if(color[i] == 0) colorize(graph, i, 1);\n            if(flag) return false;\n        }\n        return true;\n    }\n\n    void colorize(vector<vector<int>>& graph, int u, int ctype){\n        if(color[u]){\n            if(color[u] * ctype == -1) flag = 1;\n            return;\n        }\n        color[u] = ctype;\n        for(auto v : graph[u]) colorize(graph, v, -ctype);\n    }\n};\n```\n\n","slug":"刷题-数据结构-图-785-Is-Graph-Bipartite","published":1,"updated":"2021-02-24T04:19:28.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6y004ul5uo96kvbn3e","content":"<h1 id=\"785-Is-Graph-Bipartite\"><a href=\"#785-Is-Graph-Bipartite\" class=\"headerlink\" title=\"785. Is Graph Bipartite?\"></a><a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\">785. Is Graph Bipartite?</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二分图染色问题，实际是就是判断任意一条边的形式是否有矛盾。</p>\n<p>$O(E +N )$</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int flag &#x3D; 0;\n    vector&lt;int&gt; color;\n\n    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int n &#x3D; graph.size();\n        color.resize(n, 0);\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(color[i] &#x3D;&#x3D; 0) colorize(graph, i, 1);\n            if(flag) return false;\n        &#125;\n        return true;\n    &#125;\n\n    void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u, int ctype)&#123;\n        if(color[u])&#123;\n            if(color[u] * ctype &#x3D;&#x3D; -1) flag &#x3D; 1;\n            return;\n        &#125;\n        color[u] &#x3D; ctype;\n        for(auto v : graph[u]) colorize(graph, v, -ctype);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3F7678J","excerpt":"<h1 id=\"785-Is-Graph-Bipartite\"><a href=\"#785-Is-Graph-Bipartite\" class=\"headerlink\" title=\"785. Is Graph Bipartite?\"></a><a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\">785. Is Graph Bipartite?</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>二分图染色问题，实际是就是判断任意一条边的形式是否有矛盾。</p>\n<p>$O(E +N )$</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int flag &#x3D; 0;\n    vector&lt;int&gt; color;\n\n    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int n &#x3D; graph.size();\n        color.resize(n, 0);\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(color[i] &#x3D;&#x3D; 0) colorize(graph, i, 1);\n            if(flag) return false;\n        &#125;\n        return true;\n    &#125;\n\n    void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u, int ctype)&#123;\n        if(color[u])&#123;\n            if(color[u] * ctype &#x3D;&#x3D; -1) flag &#x3D; 1;\n            return;\n        &#125;\n        color[u] &#x3D; ctype;\n        for(auto v : graph[u]) colorize(graph, v, -ctype);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"847. 访问所有节点的最短路径","thumbnail":"http://static.come2rss.xyz/low-poly-ice-cream.png","toc":true,"top":10,"date":"2021-05-08T09:02:09.000Z","_content":"\n\n\n\n\n# [847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)\n\n\n\n\n\n\n\n## 思路：\n\n旅行商问题~真难！\n\n\n\n### DFS搜索\n\ndfs搜索回溯貌似可行，但是没有明确的停止条件\n\n### BFS搜索\n\nbfs搜索状态`state(cover, head)`可行。其中`cover`用位状态表示搜索过的节点的集合，`head`表示当前遍历的头结点。搜索的更新的`new cover = cover | 1 << newhead`。\n\n<!-- more -->\n\n代码巧妙在于直接存储节点，而非路径，压缩了搜索范围。\n\n实践发现如此简单的思路还是会超时！\n\n考虑用`dist[cover][head]`记录最短路状态，减少搜索范围。\n\n\n\n### DAG化DP计算\n\n在上述思路的前提下，`dist[cover][head]`在更新之后总有`newcover>=cover`。把`dist`当成一个图，而这个图保证了DAG的性质成立，那我们可以用DP方法计算最短路。在正向遍历`cover`到`1<<N`，遍历时尝试用不同的边进行更新。\n\n注意，更新计算可能会更新到相同`cover`集，即重复遍历了节点，那么需要再次尝试更新！\n\n\n\n### 复杂度说明\n\n一共有$2^N*N$种状态，而每种状态的更新最多N次计算。所以复杂度是`O(2^N*N^2)`\n\n\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\n    \n    queue<pair<int, int>>  que; // queue of statue and head.\n\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int times = 0;;\n        int n = graph.size(),  visall = (1 << n) - 1;\n        vector<vector<int>> dist(1<<n, vector<int>(n, n * n));\n        for(int i = 0; i < n; ++i){\n            que.push({1 << i, i});\n            dist[1 << i][i] = 0;\n        }\n        while(que.size()){\n            auto [cover, head] = que.front();\n            que.pop();\n            int d = dist[cover][head];\n            if(cover == visall) return d;\n            \n            for(auto v : graph[head]){\n                int newcover = cover | 1 << v;\n                if(d + 1 < dist[newcover][v]){\n                    que.push({newcover, v});\n                    dist[newcover][v] = d + 1;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\n```\n\n\n\n\n\n```c++\n\nclass Solution {\n    vector<int> trace;\n    vector<int> newtrace;\n    map<pair<int, int>, int> linker;\n    set<int> intarce;\n    int n;\n\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        n = graph.size();\n        for(int i = 0; i < n; ++i){\n            //  cout << i << \":\"  << endl;\n            dfs(graph, i);\n           \n        }\n            \n        \n        return trace.size() - 1;\n    }\n\n    inline pair<int, int> minpair(int a, int b){\n        if(a > b ) return {b, a};\n        return {a, b};\n    }\n    void dfs(vector<vector<int>>& graph, int u){\n        \n        newtrace.push_back(u);\n        intarce.insert(u);\n        // for(auto c : newtrace) cout << c << ' ' ;\n        // cout << endl;\n        if(intarce.size() == n){\n            if(trace.size() == 0 || trace.size() > newtrace.size()){\n                trace = newtrace;\n            }            \n        }else{\n            for(auto v : graph[u]){\n                if(++linker[minpair(u, v)] <= 4){                    \n                    dfs(graph, v);\n                }\n                --linker[minpair(u, v)];\n            }\n\n        }\n        \n        newtrace.erase(newtrace.end() - 1);\n        intarce.erase(u);\n    }\n};\n```\n\n\n\n\n\nDAG\n\n```c++\nclass Solution {\n    \n    queue<pair<int, int>>  que; // queue of statue and head.\n    \npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int times = 0;;\n        int n = graph.size(),  visall = (1 << n) - 1;\n        const int maxlen = n * n;\n        vector<vector<int>> dist(1<<n, vector<int>(n, maxlen));\n        for(int i = 0; i < n; ++i){\n            dist[1 << i][i] = 0;\n        }\n        for(int cover = 1; cover <= visall; ++cover){        \n            bool repeat = true;\n            while(repeat){\n                repeat = false;            \n                for(int u = 0; u < n; ++u){\n                    if(dist[cover][u] == maxlen) continue; // jump over the states no exist.\n                    int d = dist[cover][u];\n                    for(auto v : graph[u]){\n                        int newcover = cover | (1 << v);\n                        if(d + 1 < dist[newcover][v]){           \n                            dist[newcover][v] = d + 1;\n                            if(newcover == cover) repeat = true; // if visited node set is the same as last set, just update again.\n                    }\n                }\n                }\n            }\n            \n        }\n        int minans = maxlen;\n        for(auto c : dist[visall]) minans = min(minans, c);\n        return minans;\n    }\n\n};\n```\n\n","source":"_posts/刷题/数据结构/图\n/847-访问所有节点的最短路径.md","raw":"---\ntitle: 847. 访问所有节点的最短路径\nthumbnail: 'http://static.come2rss.xyz/low-poly-ice-cream.png'\ntoc: true\ntop: 10\ndate: 2021-05-08 17:02:09\ntags:\ncategories:\n---\n\n\n\n\n\n# [847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)\n\n\n\n\n\n\n\n## 思路：\n\n旅行商问题~真难！\n\n\n\n### DFS搜索\n\ndfs搜索回溯貌似可行，但是没有明确的停止条件\n\n### BFS搜索\n\nbfs搜索状态`state(cover, head)`可行。其中`cover`用位状态表示搜索过的节点的集合，`head`表示当前遍历的头结点。搜索的更新的`new cover = cover | 1 << newhead`。\n\n<!-- more -->\n\n代码巧妙在于直接存储节点，而非路径，压缩了搜索范围。\n\n实践发现如此简单的思路还是会超时！\n\n考虑用`dist[cover][head]`记录最短路状态，减少搜索范围。\n\n\n\n### DAG化DP计算\n\n在上述思路的前提下，`dist[cover][head]`在更新之后总有`newcover>=cover`。把`dist`当成一个图，而这个图保证了DAG的性质成立，那我们可以用DP方法计算最短路。在正向遍历`cover`到`1<<N`，遍历时尝试用不同的边进行更新。\n\n注意，更新计算可能会更新到相同`cover`集，即重复遍历了节点，那么需要再次尝试更新！\n\n\n\n### 复杂度说明\n\n一共有$2^N*N$种状态，而每种状态的更新最多N次计算。所以复杂度是`O(2^N*N^2)`\n\n\n\n## 代码：\n\n\n\n```c++\n\nclass Solution {\n    \n    queue<pair<int, int>>  que; // queue of statue and head.\n\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int times = 0;;\n        int n = graph.size(),  visall = (1 << n) - 1;\n        vector<vector<int>> dist(1<<n, vector<int>(n, n * n));\n        for(int i = 0; i < n; ++i){\n            que.push({1 << i, i});\n            dist[1 << i][i] = 0;\n        }\n        while(que.size()){\n            auto [cover, head] = que.front();\n            que.pop();\n            int d = dist[cover][head];\n            if(cover == visall) return d;\n            \n            for(auto v : graph[head]){\n                int newcover = cover | 1 << v;\n                if(d + 1 < dist[newcover][v]){\n                    que.push({newcover, v});\n                    dist[newcover][v] = d + 1;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\n```\n\n\n\n\n\n```c++\n\nclass Solution {\n    vector<int> trace;\n    vector<int> newtrace;\n    map<pair<int, int>, int> linker;\n    set<int> intarce;\n    int n;\n\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        n = graph.size();\n        for(int i = 0; i < n; ++i){\n            //  cout << i << \":\"  << endl;\n            dfs(graph, i);\n           \n        }\n            \n        \n        return trace.size() - 1;\n    }\n\n    inline pair<int, int> minpair(int a, int b){\n        if(a > b ) return {b, a};\n        return {a, b};\n    }\n    void dfs(vector<vector<int>>& graph, int u){\n        \n        newtrace.push_back(u);\n        intarce.insert(u);\n        // for(auto c : newtrace) cout << c << ' ' ;\n        // cout << endl;\n        if(intarce.size() == n){\n            if(trace.size() == 0 || trace.size() > newtrace.size()){\n                trace = newtrace;\n            }            \n        }else{\n            for(auto v : graph[u]){\n                if(++linker[minpair(u, v)] <= 4){                    \n                    dfs(graph, v);\n                }\n                --linker[minpair(u, v)];\n            }\n\n        }\n        \n        newtrace.erase(newtrace.end() - 1);\n        intarce.erase(u);\n    }\n};\n```\n\n\n\n\n\nDAG\n\n```c++\nclass Solution {\n    \n    queue<pair<int, int>>  que; // queue of statue and head.\n    \npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int times = 0;;\n        int n = graph.size(),  visall = (1 << n) - 1;\n        const int maxlen = n * n;\n        vector<vector<int>> dist(1<<n, vector<int>(n, maxlen));\n        for(int i = 0; i < n; ++i){\n            dist[1 << i][i] = 0;\n        }\n        for(int cover = 1; cover <= visall; ++cover){        \n            bool repeat = true;\n            while(repeat){\n                repeat = false;            \n                for(int u = 0; u < n; ++u){\n                    if(dist[cover][u] == maxlen) continue; // jump over the states no exist.\n                    int d = dist[cover][u];\n                    for(auto v : graph[u]){\n                        int newcover = cover | (1 << v);\n                        if(d + 1 < dist[newcover][v]){           \n                            dist[newcover][v] = d + 1;\n                            if(newcover == cover) repeat = true; // if visited node set is the same as last set, just update again.\n                    }\n                }\n                }\n            }\n            \n        }\n        int minans = maxlen;\n        for(auto c : dist[visall]) minans = min(minans, c);\n        return minans;\n    }\n\n};\n```\n\n","slug":"刷题-数据结构-图-847-访问所有节点的最短路径","published":1,"updated":"2021-05-08T09:04:58.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6y004vl5uoc2g86i2x","content":"<h1 id=\"847-访问所有节点的最短路径\"><a href=\"#847-访问所有节点的最短路径\" class=\"headerlink\" title=\"847. 访问所有节点的最短路径\"></a><a href=\"https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/\">847. 访问所有节点的最短路径</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>旅行商问题~真难！</p>\n<h3 id=\"DFS搜索\"><a href=\"#DFS搜索\" class=\"headerlink\" title=\"DFS搜索\"></a>DFS搜索</h3><p>dfs搜索回溯貌似可行，但是没有明确的停止条件</p>\n<h3 id=\"BFS搜索\"><a href=\"#BFS搜索\" class=\"headerlink\" title=\"BFS搜索\"></a>BFS搜索</h3><p>bfs搜索状态<code>state(cover, head)</code>可行。其中<code>cover</code>用位状态表示搜索过的节点的集合，<code>head</code>表示当前遍历的头结点。搜索的更新的<code>new cover = cover | 1 &lt;&lt; newhead</code>。</p>\n<span id=\"more\"></span>\n\n<p>代码巧妙在于直接存储节点，而非路径，压缩了搜索范围。</p>\n<p>实践发现如此简单的思路还是会超时！</p>\n<p>考虑用<code>dist[cover][head]</code>记录最短路状态，减少搜索范围。</p>\n<h3 id=\"DAG化DP计算\"><a href=\"#DAG化DP计算\" class=\"headerlink\" title=\"DAG化DP计算\"></a>DAG化DP计算</h3><p>在上述思路的前提下，<code>dist[cover][head]</code>在更新之后总有<code>newcover&gt;=cover</code>。把<code>dist</code>当成一个图，而这个图保证了DAG的性质成立，那我们可以用DP方法计算最短路。在正向遍历<code>cover</code>到<code>1&lt;&lt;N</code>，遍历时尝试用不同的边进行更新。</p>\n<p>注意，更新计算可能会更新到相同<code>cover</code>集，即重复遍历了节点，那么需要再次尝试更新！</p>\n<h3 id=\"复杂度说明\"><a href=\"#复杂度说明\" class=\"headerlink\" title=\"复杂度说明\"></a>复杂度说明</h3><p>一共有$2^N*N$种状态，而每种状态的更新最多N次计算。所以复杂度是<code>O(2^N*N^2)</code></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    \n    queue&lt;pair&lt;int, int&gt;&gt;  que; &#x2F;&#x2F; queue of statue and head.\n\npublic:\n    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int times &#x3D; 0;;\n        int n &#x3D; graph.size(),  visall &#x3D; (1 &lt;&lt; n) - 1;\n        vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, n * n));\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            que.push(&#123;1 &lt;&lt; i, i&#125;);\n            dist[1 &lt;&lt; i][i] &#x3D; 0;\n        &#125;\n        while(que.size())&#123;\n            auto [cover, head] &#x3D; que.front();\n            que.pop();\n            int d &#x3D; dist[cover][head];\n            if(cover &#x3D;&#x3D; visall) return d;\n            \n            for(auto v : graph[head])&#123;\n                int newcover &#x3D; cover | 1 &lt;&lt; v;\n                if(d + 1 &lt; dist[newcover][v])&#123;\n                    que.push(&#123;newcover, v&#125;);\n                    dist[newcover][v] &#x3D; d + 1;\n                &#125;\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    vector&lt;int&gt; trace;\n    vector&lt;int&gt; newtrace;\n    map&lt;pair&lt;int, int&gt;, int&gt; linker;\n    set&lt;int&gt; intarce;\n    int n;\n\npublic:\n    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        n &#x3D; graph.size();\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            &#x2F;&#x2F;  cout &lt;&lt; i &lt;&lt; &quot;:&quot;  &lt;&lt; endl;\n            dfs(graph, i);\n           \n        &#125;\n            \n        \n        return trace.size() - 1;\n    &#125;\n\n    inline pair&lt;int, int&gt; minpair(int a, int b)&#123;\n        if(a &gt; b ) return &#123;b, a&#125;;\n        return &#123;a, b&#125;;\n    &#125;\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u)&#123;\n        \n        newtrace.push_back(u);\n        intarce.insert(u);\n        &#x2F;&#x2F; for(auto c : newtrace) cout &lt;&lt; c &lt;&lt; &#39; &#39; ;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        if(intarce.size() &#x3D;&#x3D; n)&#123;\n            if(trace.size() &#x3D;&#x3D; 0 || trace.size() &gt; newtrace.size())&#123;\n                trace &#x3D; newtrace;\n            &#125;            \n        &#125;else&#123;\n            for(auto v : graph[u])&#123;\n                if(++linker[minpair(u, v)] &lt;&#x3D; 4)&#123;                    \n                    dfs(graph, v);\n                &#125;\n                --linker[minpair(u, v)];\n            &#125;\n\n        &#125;\n        \n        newtrace.erase(newtrace.end() - 1);\n        intarce.erase(u);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>DAG</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    \n    queue&lt;pair&lt;int, int&gt;&gt;  que; &#x2F;&#x2F; queue of statue and head.\n    \npublic:\n    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int times &#x3D; 0;;\n        int n &#x3D; graph.size(),  visall &#x3D; (1 &lt;&lt; n) - 1;\n        const int maxlen &#x3D; n * n;\n        vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, maxlen));\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            dist[1 &lt;&lt; i][i] &#x3D; 0;\n        &#125;\n        for(int cover &#x3D; 1; cover &lt;&#x3D; visall; ++cover)&#123;        \n            bool repeat &#x3D; true;\n            while(repeat)&#123;\n                repeat &#x3D; false;            \n                for(int u &#x3D; 0; u &lt; n; ++u)&#123;\n                    if(dist[cover][u] &#x3D;&#x3D; maxlen) continue; &#x2F;&#x2F; jump over the states no exist.\n                    int d &#x3D; dist[cover][u];\n                    for(auto v : graph[u])&#123;\n                        int newcover &#x3D; cover | (1 &lt;&lt; v);\n                        if(d + 1 &lt; dist[newcover][v])&#123;           \n                            dist[newcover][v] &#x3D; d + 1;\n                            if(newcover &#x3D;&#x3D; cover) repeat &#x3D; true; &#x2F;&#x2F; if visited node set is the same as last set, just update again.\n                    &#125;\n                &#125;\n                &#125;\n            &#125;\n            \n        &#125;\n        int minans &#x3D; maxlen;\n        for(auto c : dist[visall]) minans &#x3D; min(minans, c);\n        return minans;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1DZ53YD","excerpt":"<h1 id=\"847-访问所有节点的最短路径\"><a href=\"#847-访问所有节点的最短路径\" class=\"headerlink\" title=\"847. 访问所有节点的最短路径\"></a><a href=\"https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/\">847. 访问所有节点的最短路径</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>旅行商问题~真难！</p>\n<h3 id=\"DFS搜索\"><a href=\"#DFS搜索\" class=\"headerlink\" title=\"DFS搜索\"></a>DFS搜索</h3><p>dfs搜索回溯貌似可行，但是没有明确的停止条件</p>\n<h3 id=\"BFS搜索\"><a href=\"#BFS搜索\" class=\"headerlink\" title=\"BFS搜索\"></a>BFS搜索</h3><p>bfs搜索状态<code>state(cover, head)</code>可行。其中<code>cover</code>用位状态表示搜索过的节点的集合，<code>head</code>表示当前遍历的头结点。搜索的更新的<code>new cover = cover | 1 &lt;&lt; newhead</code>。</p>","more":"<p>代码巧妙在于直接存储节点，而非路径，压缩了搜索范围。</p>\n<p>实践发现如此简单的思路还是会超时！</p>\n<p>考虑用<code>dist[cover][head]</code>记录最短路状态，减少搜索范围。</p>\n<h3 id=\"DAG化DP计算\"><a href=\"#DAG化DP计算\" class=\"headerlink\" title=\"DAG化DP计算\"></a>DAG化DP计算</h3><p>在上述思路的前提下，<code>dist[cover][head]</code>在更新之后总有<code>newcover&gt;=cover</code>。把<code>dist</code>当成一个图，而这个图保证了DAG的性质成立，那我们可以用DP方法计算最短路。在正向遍历<code>cover</code>到<code>1&lt;&lt;N</code>，遍历时尝试用不同的边进行更新。</p>\n<p>注意，更新计算可能会更新到相同<code>cover</code>集，即重复遍历了节点，那么需要再次尝试更新！</p>\n<h3 id=\"复杂度说明\"><a href=\"#复杂度说明\" class=\"headerlink\" title=\"复杂度说明\"></a>复杂度说明</h3><p>一共有$2^N*N$种状态，而每种状态的更新最多N次计算。所以复杂度是<code>O(2^N*N^2)</code></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    \n    queue&lt;pair&lt;int, int&gt;&gt;  que; &#x2F;&#x2F; queue of statue and head.\n\npublic:\n    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int times &#x3D; 0;;\n        int n &#x3D; graph.size(),  visall &#x3D; (1 &lt;&lt; n) - 1;\n        vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, n * n));\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            que.push(&#123;1 &lt;&lt; i, i&#125;);\n            dist[1 &lt;&lt; i][i] &#x3D; 0;\n        &#125;\n        while(que.size())&#123;\n            auto [cover, head] &#x3D; que.front();\n            que.pop();\n            int d &#x3D; dist[cover][head];\n            if(cover &#x3D;&#x3D; visall) return d;\n            \n            for(auto v : graph[head])&#123;\n                int newcover &#x3D; cover | 1 &lt;&lt; v;\n                if(d + 1 &lt; dist[newcover][v])&#123;\n                    que.push(&#123;newcover, v&#125;);\n                    dist[newcover][v] &#x3D; d + 1;\n                &#125;\n            &#125;\n        &#125;\n        return 0;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\n    vector&lt;int&gt; trace;\n    vector&lt;int&gt; newtrace;\n    map&lt;pair&lt;int, int&gt;, int&gt; linker;\n    set&lt;int&gt; intarce;\n    int n;\n\npublic:\n    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        n &#x3D; graph.size();\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            &#x2F;&#x2F;  cout &lt;&lt; i &lt;&lt; &quot;:&quot;  &lt;&lt; endl;\n            dfs(graph, i);\n           \n        &#125;\n            \n        \n        return trace.size() - 1;\n    &#125;\n\n    inline pair&lt;int, int&gt; minpair(int a, int b)&#123;\n        if(a &gt; b ) return &#123;b, a&#125;;\n        return &#123;a, b&#125;;\n    &#125;\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u)&#123;\n        \n        newtrace.push_back(u);\n        intarce.insert(u);\n        &#x2F;&#x2F; for(auto c : newtrace) cout &lt;&lt; c &lt;&lt; &#39; &#39; ;\n        &#x2F;&#x2F; cout &lt;&lt; endl;\n        if(intarce.size() &#x3D;&#x3D; n)&#123;\n            if(trace.size() &#x3D;&#x3D; 0 || trace.size() &gt; newtrace.size())&#123;\n                trace &#x3D; newtrace;\n            &#125;            \n        &#125;else&#123;\n            for(auto v : graph[u])&#123;\n                if(++linker[minpair(u, v)] &lt;&#x3D; 4)&#123;                    \n                    dfs(graph, v);\n                &#125;\n                --linker[minpair(u, v)];\n            &#125;\n\n        &#125;\n        \n        newtrace.erase(newtrace.end() - 1);\n        intarce.erase(u);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>DAG</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    \n    queue&lt;pair&lt;int, int&gt;&gt;  que; &#x2F;&#x2F; queue of statue and head.\n    \npublic:\n    int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int times &#x3D; 0;;\n        int n &#x3D; graph.size(),  visall &#x3D; (1 &lt;&lt; n) - 1;\n        const int maxlen &#x3D; n * n;\n        vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, maxlen));\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            dist[1 &lt;&lt; i][i] &#x3D; 0;\n        &#125;\n        for(int cover &#x3D; 1; cover &lt;&#x3D; visall; ++cover)&#123;        \n            bool repeat &#x3D; true;\n            while(repeat)&#123;\n                repeat &#x3D; false;            \n                for(int u &#x3D; 0; u &lt; n; ++u)&#123;\n                    if(dist[cover][u] &#x3D;&#x3D; maxlen) continue; &#x2F;&#x2F; jump over the states no exist.\n                    int d &#x3D; dist[cover][u];\n                    for(auto v : graph[u])&#123;\n                        int newcover &#x3D; cover | (1 &lt;&lt; v);\n                        if(d + 1 &lt; dist[newcover][v])&#123;           \n                            dist[newcover][v] &#x3D; d + 1;\n                            if(newcover &#x3D;&#x3D; cover) repeat &#x3D; true; &#x2F;&#x2F; if visited node set is the same as last set, just update again.\n                    &#125;\n                &#125;\n                &#125;\n            &#125;\n            \n        &#125;\n        int minans &#x3D; maxlen;\n        for(auto c : dist[visall]) minans &#x3D; min(minans, c);\n        return minans;\n    &#125;\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"882. Reachable Nodes In Subdivided Graph","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-02T09:19:28.000Z","_content":"\n\n\n\n\n\n\n## 思路：\n\n`subdivision nodes`可以化为路径的长度，将此问题转化为可以用dijstra求解的问题。\n\n每次遍历到最新最短的节点都可以进行求出此点相连的边的可以累加`subdivistion nodes`的个数，但是需要控制重复累加比较麻烦。最后采用记录下每条边可到达的点，最后统一累计即可。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<vector<pair<int, int>>> road;\n    vector<int> vis, dis;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    map<pair<int, int>, int> used; // 其实dijsktra算法对于是可以做到每subdivision nodes只更新一次的，但是不好计算;\n    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {\n        road.resize(n);\n        vis.resize(n);\n        dis.resize(n, INT_MAX);\n        for(auto e : edges){            \n            road[e[0]].emplace_back(e[1], e[2] + 1);\n            road[e[1]].emplace_back(e[0], e[2] + 1); // node, subdivision nodes + 1 = distantce\n        }        \n        pq.push({0, 0}); // distance, node;\n        dis[0] = 0;\n        int sumnode = 0;\n        while(pq.size()){\n            auto  [_, u] = pq.top(); pq.pop();\n            // cout << u << endl;\n            if(vis[u]) continue;\n            if(dis[u] > maxMoves) break;\n            vis[u] = 1;\n            ++sumnode;\n            for(auto [v, len] : road[u]){\n                if(dis[v] > dis[u] + len){\n                    dis[v] = dis[u] + len;\n                    pq.push({dis[v], v});\n                }\n                used[{u, v}] = min(dis[u] + len, maxMoves) - dis[u];\n            } \n        }\n        for(auto edges : edges){\n            int u = edges[0], v = edges[1], len = edges[2];\n            sumnode += min(used[{u, v}] + used[{v, u}], len);\n        }\n        return sumnode;\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/图\n/882-Reachable-Nodes-In-Subdivided-Graph.md","raw":"---\ntitle: 882. Reachable Nodes In Subdivided Graph\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-02 17:19:28\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n## 思路：\n\n`subdivision nodes`可以化为路径的长度，将此问题转化为可以用dijstra求解的问题。\n\n每次遍历到最新最短的节点都可以进行求出此点相连的边的可以累加`subdivistion nodes`的个数，但是需要控制重复累加比较麻烦。最后采用记录下每条边可到达的点，最后统一累计即可。\n\n\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<vector<pair<int, int>>> road;\n    vector<int> vis, dis;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    map<pair<int, int>, int> used; // 其实dijsktra算法对于是可以做到每subdivision nodes只更新一次的，但是不好计算;\n    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {\n        road.resize(n);\n        vis.resize(n);\n        dis.resize(n, INT_MAX);\n        for(auto e : edges){            \n            road[e[0]].emplace_back(e[1], e[2] + 1);\n            road[e[1]].emplace_back(e[0], e[2] + 1); // node, subdivision nodes + 1 = distantce\n        }        \n        pq.push({0, 0}); // distance, node;\n        dis[0] = 0;\n        int sumnode = 0;\n        while(pq.size()){\n            auto  [_, u] = pq.top(); pq.pop();\n            // cout << u << endl;\n            if(vis[u]) continue;\n            if(dis[u] > maxMoves) break;\n            vis[u] = 1;\n            ++sumnode;\n            for(auto [v, len] : road[u]){\n                if(dis[v] > dis[u] + len){\n                    dis[v] = dis[u] + len;\n                    pq.push({dis[v], v});\n                }\n                used[{u, v}] = min(dis[u] + len, maxMoves) - dis[u];\n            } \n        }\n        for(auto edges : edges){\n            int u = edges[0], v = edges[1], len = edges[2];\n            sumnode += min(used[{u, v}] + used[{v, u}], len);\n        }\n        return sumnode;\n    }\n};\n```\n\n","slug":"刷题-数据结构-图-882-Reachable-Nodes-In-Subdivided-Graph","published":1,"updated":"2021-03-02T09:23:12.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6z004wl5uocmvt7xxb","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>subdivision nodes</code>可以化为路径的长度，将此问题转化为可以用dijstra求解的问题。</p>\n<p>每次遍历到最新最短的节点都可以进行求出此点相连的边的可以累加<code>subdivistion nodes</code>的个数，但是需要控制重复累加比较麻烦。最后采用记录下每条边可到达的点，最后统一累计即可。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; road;\n    vector&lt;int&gt; vis, dis;\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n    map&lt;pair&lt;int, int&gt;, int&gt; used; &#x2F;&#x2F; 其实dijsktra算法对于是可以做到每subdivision nodes只更新一次的，但是不好计算;\n    int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) &#123;\n        road.resize(n);\n        vis.resize(n);\n        dis.resize(n, INT_MAX);\n        for(auto e : edges)&#123;            \n            road[e[0]].emplace_back(e[1], e[2] + 1);\n            road[e[1]].emplace_back(e[0], e[2] + 1); &#x2F;&#x2F; node, subdivision nodes + 1 &#x3D; distantce\n        &#125;        \n        pq.push(&#123;0, 0&#125;); &#x2F;&#x2F; distance, node;\n        dis[0] &#x3D; 0;\n        int sumnode &#x3D; 0;\n        while(pq.size())&#123;\n            auto  [_, u] &#x3D; pq.top(); pq.pop();\n            &#x2F;&#x2F; cout &lt;&lt; u &lt;&lt; endl;\n            if(vis[u]) continue;\n            if(dis[u] &gt; maxMoves) break;\n            vis[u] &#x3D; 1;\n            ++sumnode;\n            for(auto [v, len] : road[u])&#123;\n                if(dis[v] &gt; dis[u] + len)&#123;\n                    dis[v] &#x3D; dis[u] + len;\n                    pq.push(&#123;dis[v], v&#125;);\n                &#125;\n                used[&#123;u, v&#125;] &#x3D; min(dis[u] + len, maxMoves) - dis[u];\n            &#125; \n        &#125;\n        for(auto edges : edges)&#123;\n            int u &#x3D; edges[0], v &#x3D; edges[1], len &#x3D; edges[2];\n            sumnode +&#x3D; min(used[&#123;u, v&#125;] + used[&#123;v, u&#125;], len);\n        &#125;\n        return sumnode;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"H3K9TE","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p><code>subdivision nodes</code>可以化为路径的长度，将此问题转化为可以用dijstra求解的问题。</p>\n<p>每次遍历到最新最短的节点都可以进行求出此点相连的边的可以累加<code>subdivistion nodes</code>的个数，但是需要控制重复累加比较麻烦。最后采用记录下每条边可到达的点，最后统一累计即可。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; road;\n    vector&lt;int&gt; vis, dis;\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n    map&lt;pair&lt;int, int&gt;, int&gt; used; &#x2F;&#x2F; 其实dijsktra算法对于是可以做到每subdivision nodes只更新一次的，但是不好计算;\n    int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) &#123;\n        road.resize(n);\n        vis.resize(n);\n        dis.resize(n, INT_MAX);\n        for(auto e : edges)&#123;            \n            road[e[0]].emplace_back(e[1], e[2] + 1);\n            road[e[1]].emplace_back(e[0], e[2] + 1); &#x2F;&#x2F; node, subdivision nodes + 1 &#x3D; distantce\n        &#125;        \n        pq.push(&#123;0, 0&#125;); &#x2F;&#x2F; distance, node;\n        dis[0] &#x3D; 0;\n        int sumnode &#x3D; 0;\n        while(pq.size())&#123;\n            auto  [_, u] &#x3D; pq.top(); pq.pop();\n            &#x2F;&#x2F; cout &lt;&lt; u &lt;&lt; endl;\n            if(vis[u]) continue;\n            if(dis[u] &gt; maxMoves) break;\n            vis[u] &#x3D; 1;\n            ++sumnode;\n            for(auto [v, len] : road[u])&#123;\n                if(dis[v] &gt; dis[u] + len)&#123;\n                    dis[v] &#x3D; dis[u] + len;\n                    pq.push(&#123;dis[v], v&#125;);\n                &#125;\n                used[&#123;u, v&#125;] &#x3D; min(dis[u] + len, maxMoves) - dis[u];\n            &#125; \n        &#125;\n        for(auto edges : edges)&#123;\n            int u &#x3D; edges[0], v &#x3D; edges[1], len &#x3D; edges[2];\n            sumnode +&#x3D; min(used[&#123;u, v&#125;] + used[&#123;v, u&#125;], len);\n        &#125;\n        return sumnode;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"二分图匹配","thumbnail":"http://static.come2rss.xyz/mirage.png","toc":true,"top":10,"date":"2021-05-09T05:03:11.000Z","_content":"\n\n\n# 二分图匹配\n\n二分图匹配是个经典问题——两组节点在图上尽可能的匹配。\n\n匈牙利算法以不断寻找增光路的方式，寻找更多的匹配;\n\n思想如下：\n\n1. 从未匹配的点`c`开始寻找链接的点`v`，如果`v`也是未匹配，则匹配成功。如果该点已经匹配了`u`，则递归尝试让`u`匹配其他节点。\n2. 如果`v`匹配失败，那就找找`c`的其他点。\n\n\n\n> [题解参考](https://leetcode-cn.com/circle/article/SCLpQf/)\n\n<!-- more -->\n\n## 模板写法\n\n\n\n```c++\nconst int N=605;\nconst int n=105;\nvector<int> g[N];\nint from[N], tot=0;\nbool use[N];\n\nbool match(int x){\n    for(int i=0; i<g[x].size(); ++i)\n    if(!use[g[x][i]]){\n        use[g[x][i]]=true;\n        if(from[g[x][i]]==-1 || match(from[g[x][i]])){\n            from[g[x][i]]=x;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary(){\n    tot=0;\n    memset(from, -1, sizeof from);\n    for(int i=1; i<=n; ++i){\n        memset(use, 0x00, sizeof use);\n        if(from[i] != -1 && match(i)) ++tot;\n    }\n    return tot;\n}\n\n\n```\n\n\n\n## 二分图染色问题 \n\n\n\n#### [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)\n\n### 思路：\n\n\n\n炫酷的`lambda`写法~\n\n\n\n\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    int flag = 0;\n    vector<int> color;\n\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        int colors[n];\n        memset(colors, -1, sizeof colors);\n\n        function<bool(int, int)> dfs = [&](int node, int color) -> bool {\n            colors[node] = color;\n            for(auto c : graph[node]){\n                if(colors[c] == -1 && !dfs(c, 1 - color)) return false;\n                if(colors[c] == color) return false;\n            }\n            return true;\n        };\n        for(int i = 0; i < n; ++i)\n            if(colors[i] == -1 && !dfs(i, 1)) return false;\n        return true;\n    }\n\n\n};\n```\n\n\n\n\n\n\n\n\n\n## [棋盘覆盖](https://ac.nowcoder.com/acm/problem/51272)\n\n\n\n### 思路：\n\n棋盘就是个抽象的图。\n\n二分图思路做下来就行。\n\n### 代码：\n\n\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int N = 105;\nusing PII = pair<int,int>;\nint n, m;\nbool maze[N][N];\nPII match[N][N]; // 直接存储匹配量，比较方便~\nbool vis[N][N];\n\nint dx[] = {-1, 0, 0, 1}; //1 与 4 对应\nint dy[] = {0, 1, -1, 0}; // 2与3 对应\n\nbool find(int x, int y){\n    // vis[x][y] = 1;\n    for(int i = 0 ;i < 4; ++i){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if(nx && nx <= n && ny && ny <= n && !maze[nx][ny] && !vis[nx][ny]){ // 访问有效的，不在该次扩展中访问过的节点\n            vis[nx][ny] = 1; // 该节点已经访问\n            auto t1 = match[nx][ny].first;\n            auto t2 = match[nx][ny].second;\n            if(t1 == -1 || find(t1, t2)){ // 如果该节点未匹配或者该节点的匹配被更新了\n                match[x][y] = {nx, ny};\n                match[nx][ny] = {x, y};\n                return true;\n            }\n        }\n\n    }\n    return false;\n}\n\nint main(){\n    int a, b;\n    scanf(\"%d%d\", &n, &m);\n    while(m--){\n        scanf(\"%d%d\", &a, &b);\n        maze[a][b] = 1;        \n    }\n    memset(match, -1, sizeof match);\n    int cnt = 0;\n    for(int i = 1; i <= n; ++i){\n        for(int j = 1; j <= n; ++j){\n//            if((i+j)&0x01 && !maze[i][j]){  // 为什么不排除已匹配成功的节点\n            if(match[i][j].first != -1 && !maze[i][j]){  // 为什么不排除已匹配成功的节点\n                memset(vis, 0x00, sizeof vis);\n                if(find(i, j)) cnt++;\n            }\n        }\n    }\n    printf(\"%d\", cnt);\n\n    return 0;\n}   \n```\n\n","source":"_posts/刷题/数据结构/图\n/二分图匹配.md","raw":"---\ntitle: 二分图匹配\nthumbnail: 'http://static.come2rss.xyz/mirage.png'\ntoc: true\ntop: 10\ndate: 2021-05-09 13:03:11\ntags:\ncategories:\n---\n\n\n\n# 二分图匹配\n\n二分图匹配是个经典问题——两组节点在图上尽可能的匹配。\n\n匈牙利算法以不断寻找增光路的方式，寻找更多的匹配;\n\n思想如下：\n\n1. 从未匹配的点`c`开始寻找链接的点`v`，如果`v`也是未匹配，则匹配成功。如果该点已经匹配了`u`，则递归尝试让`u`匹配其他节点。\n2. 如果`v`匹配失败，那就找找`c`的其他点。\n\n\n\n> [题解参考](https://leetcode-cn.com/circle/article/SCLpQf/)\n\n<!-- more -->\n\n## 模板写法\n\n\n\n```c++\nconst int N=605;\nconst int n=105;\nvector<int> g[N];\nint from[N], tot=0;\nbool use[N];\n\nbool match(int x){\n    for(int i=0; i<g[x].size(); ++i)\n    if(!use[g[x][i]]){\n        use[g[x][i]]=true;\n        if(from[g[x][i]]==-1 || match(from[g[x][i]])){\n            from[g[x][i]]=x;\n            return true;\n        }\n    }\n    return false;\n}\n\nint hungary(){\n    tot=0;\n    memset(from, -1, sizeof from);\n    for(int i=1; i<=n; ++i){\n        memset(use, 0x00, sizeof use);\n        if(from[i] != -1 && match(i)) ++tot;\n    }\n    return tot;\n}\n\n\n```\n\n\n\n## 二分图染色问题 \n\n\n\n#### [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)\n\n### 思路：\n\n\n\n炫酷的`lambda`写法~\n\n\n\n\n\n### 代码：\n\n```c++\nclass Solution {\npublic:\n    int flag = 0;\n    vector<int> color;\n\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        int colors[n];\n        memset(colors, -1, sizeof colors);\n\n        function<bool(int, int)> dfs = [&](int node, int color) -> bool {\n            colors[node] = color;\n            for(auto c : graph[node]){\n                if(colors[c] == -1 && !dfs(c, 1 - color)) return false;\n                if(colors[c] == color) return false;\n            }\n            return true;\n        };\n        for(int i = 0; i < n; ++i)\n            if(colors[i] == -1 && !dfs(i, 1)) return false;\n        return true;\n    }\n\n\n};\n```\n\n\n\n\n\n\n\n\n\n## [棋盘覆盖](https://ac.nowcoder.com/acm/problem/51272)\n\n\n\n### 思路：\n\n棋盘就是个抽象的图。\n\n二分图思路做下来就行。\n\n### 代码：\n\n\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int N = 105;\nusing PII = pair<int,int>;\nint n, m;\nbool maze[N][N];\nPII match[N][N]; // 直接存储匹配量，比较方便~\nbool vis[N][N];\n\nint dx[] = {-1, 0, 0, 1}; //1 与 4 对应\nint dy[] = {0, 1, -1, 0}; // 2与3 对应\n\nbool find(int x, int y){\n    // vis[x][y] = 1;\n    for(int i = 0 ;i < 4; ++i){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if(nx && nx <= n && ny && ny <= n && !maze[nx][ny] && !vis[nx][ny]){ // 访问有效的，不在该次扩展中访问过的节点\n            vis[nx][ny] = 1; // 该节点已经访问\n            auto t1 = match[nx][ny].first;\n            auto t2 = match[nx][ny].second;\n            if(t1 == -1 || find(t1, t2)){ // 如果该节点未匹配或者该节点的匹配被更新了\n                match[x][y] = {nx, ny};\n                match[nx][ny] = {x, y};\n                return true;\n            }\n        }\n\n    }\n    return false;\n}\n\nint main(){\n    int a, b;\n    scanf(\"%d%d\", &n, &m);\n    while(m--){\n        scanf(\"%d%d\", &a, &b);\n        maze[a][b] = 1;        \n    }\n    memset(match, -1, sizeof match);\n    int cnt = 0;\n    for(int i = 1; i <= n; ++i){\n        for(int j = 1; j <= n; ++j){\n//            if((i+j)&0x01 && !maze[i][j]){  // 为什么不排除已匹配成功的节点\n            if(match[i][j].first != -1 && !maze[i][j]){  // 为什么不排除已匹配成功的节点\n                memset(vis, 0x00, sizeof vis);\n                if(find(i, j)) cnt++;\n            }\n        }\n    }\n    printf(\"%d\", cnt);\n\n    return 0;\n}   \n```\n\n","slug":"刷题-数据结构-图-二分图匹配","published":1,"updated":"2021-05-09T06:03:00.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j6z004xl5uo0iob9tbu","content":"<h1 id=\"二分图匹配\"><a href=\"#二分图匹配\" class=\"headerlink\" title=\"二分图匹配\"></a>二分图匹配</h1><p>二分图匹配是个经典问题——两组节点在图上尽可能的匹配。</p>\n<p>匈牙利算法以不断寻找增光路的方式，寻找更多的匹配;</p>\n<p>思想如下：</p>\n<ol>\n<li>从未匹配的点<code>c</code>开始寻找链接的点<code>v</code>，如果<code>v</code>也是未匹配，则匹配成功。如果该点已经匹配了<code>u</code>，则递归尝试让<code>u</code>匹配其他节点。</li>\n<li>如果<code>v</code>匹配失败，那就找找<code>c</code>的其他点。</li>\n</ol>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/circle/article/SCLpQf/\">题解参考</a></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"模板写法\"><a href=\"#模板写法\" class=\"headerlink\" title=\"模板写法\"></a>模板写法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int N&#x3D;605;\nconst int n&#x3D;105;\nvector&lt;int&gt; g[N];\nint from[N], tot&#x3D;0;\nbool use[N];\n\nbool match(int x)&#123;\n    for(int i&#x3D;0; i&lt;g[x].size(); ++i)\n    if(!use[g[x][i]])&#123;\n        use[g[x][i]]&#x3D;true;\n        if(from[g[x][i]]&#x3D;&#x3D;-1 || match(from[g[x][i]]))&#123;\n            from[g[x][i]]&#x3D;x;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint hungary()&#123;\n    tot&#x3D;0;\n    memset(from, -1, sizeof from);\n    for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123;\n        memset(use, 0x00, sizeof use);\n        if(from[i] !&#x3D; -1 &amp;&amp; match(i)) ++tot;\n    &#125;\n    return tot;\n&#125;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"二分图染色问题\"><a href=\"#二分图染色问题\" class=\"headerlink\" title=\"二分图染色问题\"></a>二分图染色问题</h2><h4 id=\"785-判断二分图\"><a href=\"#785-判断二分图\" class=\"headerlink\" title=\"785. 判断二分图\"></a><a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\">785. 判断二分图</a></h4><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>炫酷的<code>lambda</code>写法~</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int flag &#x3D; 0;\n    vector&lt;int&gt; color;\n\n    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int n &#x3D; graph.size();\n        int colors[n];\n        memset(colors, -1, sizeof colors);\n\n        function&lt;bool(int, int)&gt; dfs &#x3D; [&amp;](int node, int color) -&gt; bool &#123;\n            colors[node] &#x3D; color;\n            for(auto c : graph[node])&#123;\n                if(colors[c] &#x3D;&#x3D; -1 &amp;&amp; !dfs(c, 1 - color)) return false;\n                if(colors[c] &#x3D;&#x3D; color) return false;\n            &#125;\n            return true;\n        &#125;;\n        for(int i &#x3D; 0; i &lt; n; ++i)\n            if(colors[i] &#x3D;&#x3D; -1 &amp;&amp; !dfs(i, 1)) return false;\n        return true;\n    &#125;\n\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n\n\n\n\n<h2 id=\"棋盘覆盖\"><a href=\"#棋盘覆盖\" class=\"headerlink\" title=\"棋盘覆盖\"></a><a href=\"https://ac.nowcoder.com/acm/problem/51272\">棋盘覆盖</a></h2><h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>棋盘就是个抽象的图。</p>\n<p>二分图思路做下来就行。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nconst int N &#x3D; 105;\nusing PII &#x3D; pair&lt;int,int&gt;;\nint n, m;\nbool maze[N][N];\nPII match[N][N]; &#x2F;&#x2F; 直接存储匹配量，比较方便~\nbool vis[N][N];\n\nint dx[] &#x3D; &#123;-1, 0, 0, 1&#125;; &#x2F;&#x2F;1 与 4 对应\nint dy[] &#x3D; &#123;0, 1, -1, 0&#125;; &#x2F;&#x2F; 2与3 对应\n\nbool find(int x, int y)&#123;\n    &#x2F;&#x2F; vis[x][y] &#x3D; 1;\n    for(int i &#x3D; 0 ;i &lt; 4; ++i)&#123;\n        int nx &#x3D; x + dx[i];\n        int ny &#x3D; y + dy[i];\n        \n        if(nx &amp;&amp; nx &lt;&#x3D; n &amp;&amp; ny &amp;&amp; ny &lt;&#x3D; n &amp;&amp; !maze[nx][ny] &amp;&amp; !vis[nx][ny])&#123; &#x2F;&#x2F; 访问有效的，不在该次扩展中访问过的节点\n            vis[nx][ny] &#x3D; 1; &#x2F;&#x2F; 该节点已经访问\n            auto t1 &#x3D; match[nx][ny].first;\n            auto t2 &#x3D; match[nx][ny].second;\n            if(t1 &#x3D;&#x3D; -1 || find(t1, t2))&#123; &#x2F;&#x2F; 如果该节点未匹配或者该节点的匹配被更新了\n                match[x][y] &#x3D; &#123;nx, ny&#125;;\n                match[nx][ny] &#x3D; &#123;x, y&#125;;\n                return true;\n            &#125;\n        &#125;\n\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    int a, b;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    while(m--)&#123;\n        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);\n        maze[a][b] &#x3D; 1;        \n    &#125;\n    memset(match, -1, sizeof match);\n    int cnt &#x3D; 0;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n        for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123;\n&#x2F;&#x2F;            if((i+j)&amp;0x01 &amp;&amp; !maze[i][j])&#123;  &#x2F;&#x2F; 为什么不排除已匹配成功的节点\n            if(match[i][j].first !&#x3D; -1 &amp;&amp; !maze[i][j])&#123;  &#x2F;&#x2F; 为什么不排除已匹配成功的节点\n                memset(vis, 0x00, sizeof vis);\n                if(find(i, j)) cnt++;\n            &#125;\n        &#125;\n    &#125;\n    printf(&quot;%d&quot;, cnt);\n\n    return 0;\n&#125;   <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"T724B9","excerpt":"<h1 id=\"二分图匹配\"><a href=\"#二分图匹配\" class=\"headerlink\" title=\"二分图匹配\"></a>二分图匹配</h1><p>二分图匹配是个经典问题——两组节点在图上尽可能的匹配。</p>\n<p>匈牙利算法以不断寻找增光路的方式，寻找更多的匹配;</p>\n<p>思想如下：</p>\n<ol>\n<li>从未匹配的点<code>c</code>开始寻找链接的点<code>v</code>，如果<code>v</code>也是未匹配，则匹配成功。如果该点已经匹配了<code>u</code>，则递归尝试让<code>u</code>匹配其他节点。</li>\n<li>如果<code>v</code>匹配失败，那就找找<code>c</code>的其他点。</li>\n</ol>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/circle/article/SCLpQf/\">题解参考</a></p>\n</blockquote>","more":"<h2 id=\"模板写法\"><a href=\"#模板写法\" class=\"headerlink\" title=\"模板写法\"></a>模板写法</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int N&#x3D;605;\nconst int n&#x3D;105;\nvector&lt;int&gt; g[N];\nint from[N], tot&#x3D;0;\nbool use[N];\n\nbool match(int x)&#123;\n    for(int i&#x3D;0; i&lt;g[x].size(); ++i)\n    if(!use[g[x][i]])&#123;\n        use[g[x][i]]&#x3D;true;\n        if(from[g[x][i]]&#x3D;&#x3D;-1 || match(from[g[x][i]]))&#123;\n            from[g[x][i]]&#x3D;x;\n            return true;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint hungary()&#123;\n    tot&#x3D;0;\n    memset(from, -1, sizeof from);\n    for(int i&#x3D;1; i&lt;&#x3D;n; ++i)&#123;\n        memset(use, 0x00, sizeof use);\n        if(from[i] !&#x3D; -1 &amp;&amp; match(i)) ++tot;\n    &#125;\n    return tot;\n&#125;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"二分图染色问题\"><a href=\"#二分图染色问题\" class=\"headerlink\" title=\"二分图染色问题\"></a>二分图染色问题</h2><h4 id=\"785-判断二分图\"><a href=\"#785-判断二分图\" class=\"headerlink\" title=\"785. 判断二分图\"></a><a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\">785. 判断二分图</a></h4><h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>炫酷的<code>lambda</code>写法~</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int flag &#x3D; 0;\n    vector&lt;int&gt; color;\n\n    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;\n        int n &#x3D; graph.size();\n        int colors[n];\n        memset(colors, -1, sizeof colors);\n\n        function&lt;bool(int, int)&gt; dfs &#x3D; [&amp;](int node, int color) -&gt; bool &#123;\n            colors[node] &#x3D; color;\n            for(auto c : graph[node])&#123;\n                if(colors[c] &#x3D;&#x3D; -1 &amp;&amp; !dfs(c, 1 - color)) return false;\n                if(colors[c] &#x3D;&#x3D; color) return false;\n            &#125;\n            return true;\n        &#125;;\n        for(int i &#x3D; 0; i &lt; n; ++i)\n            if(colors[i] &#x3D;&#x3D; -1 &amp;&amp; !dfs(i, 1)) return false;\n        return true;\n    &#125;\n\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n\n\n\n\n<h2 id=\"棋盘覆盖\"><a href=\"#棋盘覆盖\" class=\"headerlink\" title=\"棋盘覆盖\"></a><a href=\"https://ac.nowcoder.com/acm/problem/51272\">棋盘覆盖</a></h2><h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>棋盘就是个抽象的图。</p>\n<p>二分图思路做下来就行。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nconst int N &#x3D; 105;\nusing PII &#x3D; pair&lt;int,int&gt;;\nint n, m;\nbool maze[N][N];\nPII match[N][N]; &#x2F;&#x2F; 直接存储匹配量，比较方便~\nbool vis[N][N];\n\nint dx[] &#x3D; &#123;-1, 0, 0, 1&#125;; &#x2F;&#x2F;1 与 4 对应\nint dy[] &#x3D; &#123;0, 1, -1, 0&#125;; &#x2F;&#x2F; 2与3 对应\n\nbool find(int x, int y)&#123;\n    &#x2F;&#x2F; vis[x][y] &#x3D; 1;\n    for(int i &#x3D; 0 ;i &lt; 4; ++i)&#123;\n        int nx &#x3D; x + dx[i];\n        int ny &#x3D; y + dy[i];\n        \n        if(nx &amp;&amp; nx &lt;&#x3D; n &amp;&amp; ny &amp;&amp; ny &lt;&#x3D; n &amp;&amp; !maze[nx][ny] &amp;&amp; !vis[nx][ny])&#123; &#x2F;&#x2F; 访问有效的，不在该次扩展中访问过的节点\n            vis[nx][ny] &#x3D; 1; &#x2F;&#x2F; 该节点已经访问\n            auto t1 &#x3D; match[nx][ny].first;\n            auto t2 &#x3D; match[nx][ny].second;\n            if(t1 &#x3D;&#x3D; -1 || find(t1, t2))&#123; &#x2F;&#x2F; 如果该节点未匹配或者该节点的匹配被更新了\n                match[x][y] &#x3D; &#123;nx, ny&#125;;\n                match[nx][ny] &#x3D; &#123;x, y&#125;;\n                return true;\n            &#125;\n        &#125;\n\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    int a, b;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    while(m--)&#123;\n        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);\n        maze[a][b] &#x3D; 1;        \n    &#125;\n    memset(match, -1, sizeof match);\n    int cnt &#x3D; 0;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)&#123;\n        for(int j &#x3D; 1; j &lt;&#x3D; n; ++j)&#123;\n&#x2F;&#x2F;            if((i+j)&amp;0x01 &amp;&amp; !maze[i][j])&#123;  &#x2F;&#x2F; 为什么不排除已匹配成功的节点\n            if(match[i][j].first !&#x3D; -1 &amp;&amp; !maze[i][j])&#123;  &#x2F;&#x2F; 为什么不排除已匹配成功的节点\n                memset(vis, 0x00, sizeof vis);\n                if(find(i, j)) cnt++;\n            &#125;\n        &#125;\n    &#125;\n    printf(&quot;%d&quot;, cnt);\n\n    return 0;\n&#125;   <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"割点算法","thumbnail":"http://static.come2rss.xyz/mirage.png","toc":true,"top":10,"date":"2021-05-09T03:34:08.000Z","_content":"\n\n\n\n\n## 割点算法Tarjan\n\n割点算法 引入了建立在DFS生成树的遍历节点的时间戳概念，如果一个节点`u`的子节点`v`可以找到一条不经过`u`以外的路径到达`u`的祖先，那么显然有一条通路可以回到`u`的祖先。反之，如果存在`v`找不到这么一条路径回到`u`的祖先，那么显然`u`是一个割点，他分割了`v`所在的子树和其他子树（如果`u`不是根的话，包括祖先所在子树）。\n\n\n\n![image-20210509113600747](http://static.come2rss.xyz/image-20210509113600747.png)\n\n那么一个割点有多少子树呢？\n首先，一个割点的对应的`v`是独立在各个子树的吗？是的，如果存在`v1`和`v2`都找到路径，且在一个子树中，那么必然有`v1`可以通过`v2`找到`u`，那么在DFS搜索的时候，必定会一次遍历`v1`和`v2`。所以每个割点对应的子树只会搜索到一个`v`。\n扩展一下， 那么经过去掉割点的图最多有几个连通块？\n\n<!-- more -->\n\n[POJ 2117 Electricity](http://poj.org/problem?id=2117)\n\n> [参考解答](https://leetcode-cn.com/circle/article/FH8cqr/#poj-3177/newcoder-10774/acw-395-%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84)\n```c++\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int N = 10005;\nconst int M = 30005;\nint tot;\nint to[M], nxt[M], head[M]; // graph 链式前向星存储方式\nint dfn[N];\nint low[N];\nint ts;\nint n, m;\nint bp, cnt;\nint root;\nvoid add(int u, int v){ // connstruct graph;\n    ++tot;\n    to[tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\nvoid tarjan(int u){\n    // cout << u << ' '; \n    int subtree = 0;\n    dfn[u] = low[u] = ++ts;\n    for(int i = head[u]; i; i = nxt[i]){\n        int v = to[i];\n        \n        if(dfn[v]) low[u] = min(low[u], dfn[v]);\n        else{\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n            if(low[v] >= dfn[u]) ++subtree;; // 节点u是割点，且割点对应的子节点v是在一个被分割子树中\n        }\n    }\n    if( u != root) ++subtree;\n    bp = max(bp, subtree);\n}\nint main(){\n    while(scanf(\"%d%d\", &n, &m), n || m){\n        ts = tot = bp = cnt = 0;\n        memset(head, 0x00, sizeof head); // to 和 edge 不需要重置\n        memset(dfn, 0x00, sizeof dfn);\n        memset(low, 0x00, sizeof low);\n        int a ,b;\n        while(m--){\n            scanf(\"%d%d\", &a, &b);\n            add(a, b);\n            add(b, a);            \n        }\n        \n        for(root = 0; root < n; ++root){\n            if(!dfn[root]){\n                tarjan(root);\n                cnt++;\n            }\n        }\n        printf(\"%d\\n\", cnt + bp - 1);\n    }\n    return 0;\n}   \n\n\n\n```\n\n\n## 补充知识点\n- [前向星](https://baike.baidu.com/item/%E5%89%8D%E5%90%91%E6%98%9F?fr=aladdin)\n- [链式前向星](https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F)\n\n前向星不过是把边按出发点排序并顺序存储下来， 通过记录首部位置来遍历；\n链式前向星更进一步，通过在头部位置记录边的地点，同时以静态方式存储边，在静态边中存储下下条边的地址。\n\n\n\n最后还有常用的对拍程序：\n\n```shell\n#!/bin/sh\ng++ $1 -o ./a.out \n./a.out < input  > myoutput\ndiff myoutput output -s -u\n```\n\n","source":"_posts/刷题/数据结构/图\n/割点算法.md","raw":"---\ntitle: 割点算法\nthumbnail: 'http://static.come2rss.xyz/mirage.png'\ntoc: true\ntop: 10\ndate: 2021-05-09 11:34:08\ntags:\ncategories:\n---\n\n\n\n\n\n## 割点算法Tarjan\n\n割点算法 引入了建立在DFS生成树的遍历节点的时间戳概念，如果一个节点`u`的子节点`v`可以找到一条不经过`u`以外的路径到达`u`的祖先，那么显然有一条通路可以回到`u`的祖先。反之，如果存在`v`找不到这么一条路径回到`u`的祖先，那么显然`u`是一个割点，他分割了`v`所在的子树和其他子树（如果`u`不是根的话，包括祖先所在子树）。\n\n\n\n![image-20210509113600747](http://static.come2rss.xyz/image-20210509113600747.png)\n\n那么一个割点有多少子树呢？\n首先，一个割点的对应的`v`是独立在各个子树的吗？是的，如果存在`v1`和`v2`都找到路径，且在一个子树中，那么必然有`v1`可以通过`v2`找到`u`，那么在DFS搜索的时候，必定会一次遍历`v1`和`v2`。所以每个割点对应的子树只会搜索到一个`v`。\n扩展一下， 那么经过去掉割点的图最多有几个连通块？\n\n<!-- more -->\n\n[POJ 2117 Electricity](http://poj.org/problem?id=2117)\n\n> [参考解答](https://leetcode-cn.com/circle/article/FH8cqr/#poj-3177/newcoder-10774/acw-395-%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84)\n```c++\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\nconst int N = 10005;\nconst int M = 30005;\nint tot;\nint to[M], nxt[M], head[M]; // graph 链式前向星存储方式\nint dfn[N];\nint low[N];\nint ts;\nint n, m;\nint bp, cnt;\nint root;\nvoid add(int u, int v){ // connstruct graph;\n    ++tot;\n    to[tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\nvoid tarjan(int u){\n    // cout << u << ' '; \n    int subtree = 0;\n    dfn[u] = low[u] = ++ts;\n    for(int i = head[u]; i; i = nxt[i]){\n        int v = to[i];\n        \n        if(dfn[v]) low[u] = min(low[u], dfn[v]);\n        else{\n            tarjan(v);\n            low[u] = min(low[u], low[v]);\n            if(low[v] >= dfn[u]) ++subtree;; // 节点u是割点，且割点对应的子节点v是在一个被分割子树中\n        }\n    }\n    if( u != root) ++subtree;\n    bp = max(bp, subtree);\n}\nint main(){\n    while(scanf(\"%d%d\", &n, &m), n || m){\n        ts = tot = bp = cnt = 0;\n        memset(head, 0x00, sizeof head); // to 和 edge 不需要重置\n        memset(dfn, 0x00, sizeof dfn);\n        memset(low, 0x00, sizeof low);\n        int a ,b;\n        while(m--){\n            scanf(\"%d%d\", &a, &b);\n            add(a, b);\n            add(b, a);            \n        }\n        \n        for(root = 0; root < n; ++root){\n            if(!dfn[root]){\n                tarjan(root);\n                cnt++;\n            }\n        }\n        printf(\"%d\\n\", cnt + bp - 1);\n    }\n    return 0;\n}   \n\n\n\n```\n\n\n## 补充知识点\n- [前向星](https://baike.baidu.com/item/%E5%89%8D%E5%90%91%E6%98%9F?fr=aladdin)\n- [链式前向星](https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F)\n\n前向星不过是把边按出发点排序并顺序存储下来， 通过记录首部位置来遍历；\n链式前向星更进一步，通过在头部位置记录边的地点，同时以静态方式存储边，在静态边中存储下下条边的地址。\n\n\n\n最后还有常用的对拍程序：\n\n```shell\n#!/bin/sh\ng++ $1 -o ./a.out \n./a.out < input  > myoutput\ndiff myoutput output -s -u\n```\n\n","slug":"刷题-数据结构-图-割点算法","published":1,"updated":"2021-05-09T03:37:46.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j70004yl5uod8wp4j51","content":"<h2 id=\"割点算法Tarjan\"><a href=\"#割点算法Tarjan\" class=\"headerlink\" title=\"割点算法Tarjan\"></a>割点算法Tarjan</h2><p>割点算法 引入了建立在DFS生成树的遍历节点的时间戳概念，如果一个节点<code>u</code>的子节点<code>v</code>可以找到一条不经过<code>u</code>以外的路径到达<code>u</code>的祖先，那么显然有一条通路可以回到<code>u</code>的祖先。反之，如果存在<code>v</code>找不到这么一条路径回到<code>u</code>的祖先，那么显然<code>u</code>是一个割点，他分割了<code>v</code>所在的子树和其他子树（如果<code>u</code>不是根的话，包括祖先所在子树）。</p>\n<p><img src=\"http://static.come2rss.xyz/image-20210509113600747.png\" alt=\"image-20210509113600747\"></p>\n<p>那么一个割点有多少子树呢？<br>首先，一个割点的对应的<code>v</code>是独立在各个子树的吗？是的，如果存在<code>v1</code>和<code>v2</code>都找到路径，且在一个子树中，那么必然有<code>v1</code>可以通过<code>v2</code>找到<code>u</code>，那么在DFS搜索的时候，必定会一次遍历<code>v1</code>和<code>v2</code>。所以每个割点对应的子树只会搜索到一个<code>v</code>。<br>扩展一下， 那么经过去掉割点的图最多有几个连通块？</p>\n<span id=\"more\"></span>\n\n<p><a href=\"http://poj.org/problem?id=2117\">POJ 2117 Electricity</a></p>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/circle/article/FH8cqr/#poj-3177/newcoder-10774/acw-395-%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84\">参考解答</a></p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int N &#x3D; 10005;\nconst int M &#x3D; 30005;\nint tot;\nint to[M], nxt[M], head[M]; &#x2F;&#x2F; graph 链式前向星存储方式\nint dfn[N];\nint low[N];\nint ts;\nint n, m;\nint bp, cnt;\nint root;\nvoid add(int u, int v)&#123; &#x2F;&#x2F; connstruct graph;\n    ++tot;\n    to[tot] &#x3D; v;\n    nxt[tot] &#x3D; head[u];\n    head[u] &#x3D; tot;\n&#125;\nvoid tarjan(int u)&#123;\n    &#x2F;&#x2F; cout &lt;&lt; u &lt;&lt; &#39; &#39;; \n    int subtree &#x3D; 0;\n    dfn[u] &#x3D; low[u] &#x3D; ++ts;\n    for(int i &#x3D; head[u]; i; i &#x3D; nxt[i])&#123;\n        int v &#x3D; to[i];\n        \n        if(dfn[v]) low[u] &#x3D; min(low[u], dfn[v]);\n        else&#123;\n            tarjan(v);\n            low[u] &#x3D; min(low[u], low[v]);\n            if(low[v] &gt;&#x3D; dfn[u]) ++subtree;; &#x2F;&#x2F; 节点u是割点，且割点对应的子节点v是在一个被分割子树中\n        &#125;\n    &#125;\n    if( u !&#x3D; root) ++subtree;\n    bp &#x3D; max(bp, subtree);\n&#125;\nint main()&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)&#123;\n        ts &#x3D; tot &#x3D; bp &#x3D; cnt &#x3D; 0;\n        memset(head, 0x00, sizeof head); &#x2F;&#x2F; to 和 edge 不需要重置\n        memset(dfn, 0x00, sizeof dfn);\n        memset(low, 0x00, sizeof low);\n        int a ,b;\n        while(m--)&#123;\n            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);\n            add(a, b);\n            add(b, a);            \n        &#125;\n        \n        for(root &#x3D; 0; root &lt; n; ++root)&#123;\n            if(!dfn[root])&#123;\n                tarjan(root);\n                cnt++;\n            &#125;\n        &#125;\n        printf(&quot;%d\\n&quot;, cnt + bp - 1);\n    &#125;\n    return 0;\n&#125;   \n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h2 id=\"补充知识点\"><a href=\"#补充知识点\" class=\"headerlink\" title=\"补充知识点\"></a>补充知识点</h2><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%89%8D%E5%90%91%E6%98%9F?fr=aladdin\">前向星</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F\">链式前向星</a></li>\n</ul>\n<p>前向星不过是把边按出发点排序并顺序存储下来， 通过记录首部位置来遍历；<br>链式前向星更进一步，通过在头部位置记录边的地点，同时以静态方式存储边，在静态边中存储下下条边的地址。</p>\n<p>最后还有常用的对拍程序：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">#!&#x2F;bin&#x2F;sh\ng++ $1 -o .&#x2F;a.out \n.&#x2F;a.out &lt; input  &gt; myoutput\ndiff myoutput output -s -u<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"38WPRRD","excerpt":"<h2 id=\"割点算法Tarjan\"><a href=\"#割点算法Tarjan\" class=\"headerlink\" title=\"割点算法Tarjan\"></a>割点算法Tarjan</h2><p>割点算法 引入了建立在DFS生成树的遍历节点的时间戳概念，如果一个节点<code>u</code>的子节点<code>v</code>可以找到一条不经过<code>u</code>以外的路径到达<code>u</code>的祖先，那么显然有一条通路可以回到<code>u</code>的祖先。反之，如果存在<code>v</code>找不到这么一条路径回到<code>u</code>的祖先，那么显然<code>u</code>是一个割点，他分割了<code>v</code>所在的子树和其他子树（如果<code>u</code>不是根的话，包括祖先所在子树）。</p>\n<p><img src=\"http://static.come2rss.xyz/image-20210509113600747.png\" alt=\"image-20210509113600747\"></p>\n<p>那么一个割点有多少子树呢？<br>首先，一个割点的对应的<code>v</code>是独立在各个子树的吗？是的，如果存在<code>v1</code>和<code>v2</code>都找到路径，且在一个子树中，那么必然有<code>v1</code>可以通过<code>v2</code>找到<code>u</code>，那么在DFS搜索的时候，必定会一次遍历<code>v1</code>和<code>v2</code>。所以每个割点对应的子树只会搜索到一个<code>v</code>。<br>扩展一下， 那么经过去掉割点的图最多有几个连通块？</p>","more":"<p><a href=\"http://poj.org/problem?id=2117\">POJ 2117 Electricity</a></p>\n<blockquote>\n<p><a href=\"https://leetcode-cn.com/circle/article/FH8cqr/#poj-3177/newcoder-10774/acw-395-%E5%86%97%E4%BD%99%E8%B7%AF%E5%BE%84\">参考解答</a></p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;cstring&gt;\nusing namespace std;\nconst int N &#x3D; 10005;\nconst int M &#x3D; 30005;\nint tot;\nint to[M], nxt[M], head[M]; &#x2F;&#x2F; graph 链式前向星存储方式\nint dfn[N];\nint low[N];\nint ts;\nint n, m;\nint bp, cnt;\nint root;\nvoid add(int u, int v)&#123; &#x2F;&#x2F; connstruct graph;\n    ++tot;\n    to[tot] &#x3D; v;\n    nxt[tot] &#x3D; head[u];\n    head[u] &#x3D; tot;\n&#125;\nvoid tarjan(int u)&#123;\n    &#x2F;&#x2F; cout &lt;&lt; u &lt;&lt; &#39; &#39;; \n    int subtree &#x3D; 0;\n    dfn[u] &#x3D; low[u] &#x3D; ++ts;\n    for(int i &#x3D; head[u]; i; i &#x3D; nxt[i])&#123;\n        int v &#x3D; to[i];\n        \n        if(dfn[v]) low[u] &#x3D; min(low[u], dfn[v]);\n        else&#123;\n            tarjan(v);\n            low[u] &#x3D; min(low[u], low[v]);\n            if(low[v] &gt;&#x3D; dfn[u]) ++subtree;; &#x2F;&#x2F; 节点u是割点，且割点对应的子节点v是在一个被分割子树中\n        &#125;\n    &#125;\n    if( u !&#x3D; root) ++subtree;\n    bp &#x3D; max(bp, subtree);\n&#125;\nint main()&#123;\n    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)&#123;\n        ts &#x3D; tot &#x3D; bp &#x3D; cnt &#x3D; 0;\n        memset(head, 0x00, sizeof head); &#x2F;&#x2F; to 和 edge 不需要重置\n        memset(dfn, 0x00, sizeof dfn);\n        memset(low, 0x00, sizeof low);\n        int a ,b;\n        while(m--)&#123;\n            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);\n            add(a, b);\n            add(b, a);            \n        &#125;\n        \n        for(root &#x3D; 0; root &lt; n; ++root)&#123;\n            if(!dfn[root])&#123;\n                tarjan(root);\n                cnt++;\n            &#125;\n        &#125;\n        printf(&quot;%d\\n&quot;, cnt + bp - 1);\n    &#125;\n    return 0;\n&#125;   \n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h2 id=\"补充知识点\"><a href=\"#补充知识点\" class=\"headerlink\" title=\"补充知识点\"></a>补充知识点</h2><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%89%8D%E5%90%91%E6%98%9F?fr=aladdin\">前向星</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F\">链式前向星</a></li>\n</ul>\n<p>前向星不过是把边按出发点排序并顺序存储下来， 通过记录首部位置来遍历；<br>链式前向星更进一步，通过在头部位置记录边的地点，同时以静态方式存储边，在静态边中存储下下条边的地址。</p>\n<p>最后还有常用的对拍程序：</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">#!&#x2F;bin&#x2F;sh\ng++ $1 -o .&#x2F;a.out \n.&#x2F;a.out &lt; input  &gt; myoutput\ndiff myoutput output -s -u<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"347. Top K Frequent Elements","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-11-15T01:32:09.000Z","_content":"\n\n<!-- more -->\n\n## 思路:\n\nmap记录出现初次，\n\n堆维护前K大\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        map<int, int> counter;\n        map<int, int>::iterator iter;\n        priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int,int> > >  pq;\n        for(auto i : nums)\n            counter[i]++;\n        \n        iter = counter.begin();\n        pair<int, int> tp;\n        int s1, s2, e1, e2;\n        // cout << counter.size() << endl;\n        while(iter != counter.end()){\n            s1 = iter->first;\n            s2 = iter->second;\n            if(pq.size() == k){\n                tp = pq.top();\n                e2 = tp.first;\n                e1 = tp.second;\n                if(e2 < s2){\n                    pq.pop();\n                    pq.push(make_pair(s2, s1));\n                }\n            }else pq.push(make_pair(s2, s1));            \n            iter++;\n        }\n\n        vector<int> ans;        \n        while(pq.size() > 0){                                    \n            ans.push_back(pq.top().second);            \n            pq.pop();\n        }\n        return ans;\n    }\n};\n```","source":"_posts/刷题/数据结构/堆\n/347-Top-K-Frequent-Elements.md","raw":"---\ntitle: 347. Top K Frequent Elements\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-11-15 09:32:09\n---\n\n\n<!-- more -->\n\n## 思路:\n\nmap记录出现初次，\n\n堆维护前K大\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        map<int, int> counter;\n        map<int, int>::iterator iter;\n        priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int,int> > >  pq;\n        for(auto i : nums)\n            counter[i]++;\n        \n        iter = counter.begin();\n        pair<int, int> tp;\n        int s1, s2, e1, e2;\n        // cout << counter.size() << endl;\n        while(iter != counter.end()){\n            s1 = iter->first;\n            s2 = iter->second;\n            if(pq.size() == k){\n                tp = pq.top();\n                e2 = tp.first;\n                e1 = tp.second;\n                if(e2 < s2){\n                    pq.pop();\n                    pq.push(make_pair(s2, s1));\n                }\n            }else pq.push(make_pair(s2, s1));            \n            iter++;\n        }\n\n        vector<int> ans;        \n        while(pq.size() > 0){                                    \n            ans.push_back(pq.top().second);            \n            pq.pop();\n        }\n        return ans;\n    }\n};\n```","slug":"刷题-数据结构-堆-347-Top-K-Frequent-Elements","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j70004zl5uog80b2iqb","content":"<span id=\"more\"></span>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>map记录出现初次，</p>\n<p>堆维护前K大</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        sort(nums.begin(), nums.end());\n        map&lt;int, int&gt; counter;\n        map&lt;int, int&gt;::iterator iter;\n        priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int,int&gt; &gt; &gt;  pq;\n        for(auto i : nums)\n            counter[i]++;\n        \n        iter &#x3D; counter.begin();\n        pair&lt;int, int&gt; tp;\n        int s1, s2, e1, e2;\n        &#x2F;&#x2F; cout &lt;&lt; counter.size() &lt;&lt; endl;\n        while(iter !&#x3D; counter.end())&#123;\n            s1 &#x3D; iter-&gt;first;\n            s2 &#x3D; iter-&gt;second;\n            if(pq.size() &#x3D;&#x3D; k)&#123;\n                tp &#x3D; pq.top();\n                e2 &#x3D; tp.first;\n                e1 &#x3D; tp.second;\n                if(e2 &lt; s2)&#123;\n                    pq.pop();\n                    pq.push(make_pair(s2, s1));\n                &#125;\n            &#125;else pq.push(make_pair(s2, s1));            \n            iter++;\n        &#125;\n\n        vector&lt;int&gt; ans;        \n        while(pq.size() &gt; 0)&#123;                                    \n            ans.push_back(pq.top().second);            \n            pq.pop();\n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3F73822","excerpt":"","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>map记录出现初次，</p>\n<p>堆维护前K大</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;\n        sort(nums.begin(), nums.end());\n        map&lt;int, int&gt; counter;\n        map&lt;int, int&gt;::iterator iter;\n        priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int,int&gt; &gt; &gt;  pq;\n        for(auto i : nums)\n            counter[i]++;\n        \n        iter &#x3D; counter.begin();\n        pair&lt;int, int&gt; tp;\n        int s1, s2, e1, e2;\n        &#x2F;&#x2F; cout &lt;&lt; counter.size() &lt;&lt; endl;\n        while(iter !&#x3D; counter.end())&#123;\n            s1 &#x3D; iter-&gt;first;\n            s2 &#x3D; iter-&gt;second;\n            if(pq.size() &#x3D;&#x3D; k)&#123;\n                tp &#x3D; pq.top();\n                e2 &#x3D; tp.first;\n                e1 &#x3D; tp.second;\n                if(e2 &lt; s2)&#123;\n                    pq.pop();\n                    pq.push(make_pair(s2, s1));\n                &#125;\n            &#125;else pq.push(make_pair(s2, s1));            \n            iter++;\n        &#125;\n\n        vector&lt;int&gt; ans;        \n        while(pq.size() &gt; 0)&#123;                                    \n            ans.push_back(pq.top().second);            \n            pq.pop();\n        &#125;\n        return ans;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"380. Insert Delete GetRandom O(1)","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-03T04:26:20.000Z","_content":"\n\n\n\n\n\n\n\n## 思路：\n\n要求插入，删除，随机获取元素用$O(1)$\n\n不要求数据有序，也不要要求数据按原序。\n\n`hash + 动态数组`即可。\n\n> 删除的时候，交换待删除元素到动态数组末就行了。\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\n\nclass RandomizedSet {\n    vector<int> arr;\n    unordered_map<int, int> idx;\npublic:\n    /** Initialize your data structure here. */\n    RandomizedSet() {\n\n    }\n    \n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    bool insert(int val) {\n        if(idx.count(val)){\n            return false;\n        }\n        arr.push_back(val);\n        idx[val] = arr.size() - 1;\n        return true;\n    }\n    \n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    bool remove(int val) {\n        if(!idx.count(val)) return false;\n        int pos = idx[val];\n        idx[arr[arr.size() - 1]] = pos;\n        swap(arr[pos], arr[arr.size() - 1]);\n        arr.pop_back();\n        idx.erase(val);\n        return true;\n    }\n    \n    /** Get a random element from the set. */\n    int getRandom() {\n        return arr[random() % arr.size()];\n    }\n};\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet* obj = new RandomizedSet();\n * bool param_1 = obj->insert(val);\n * bool param_2 = obj->remove(val);\n * int param_3 = obj->getRandom();\n */\n```\n\n","source":"_posts/刷题/数据结构/复杂数据结构/380-Insert-Delete-GetRandom-O-1.md","raw":"---\ntitle: 380. Insert Delete GetRandom O(1)\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-03 12:26:20\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n\n## 思路：\n\n要求插入，删除，随机获取元素用$O(1)$\n\n不要求数据有序，也不要要求数据按原序。\n\n`hash + 动态数组`即可。\n\n> 删除的时候，交换待删除元素到动态数组末就行了。\n\n<!-- more -->\n\n\n\n## 代码：\n\n\n\n```c++\n\nclass RandomizedSet {\n    vector<int> arr;\n    unordered_map<int, int> idx;\npublic:\n    /** Initialize your data structure here. */\n    RandomizedSet() {\n\n    }\n    \n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n    bool insert(int val) {\n        if(idx.count(val)){\n            return false;\n        }\n        arr.push_back(val);\n        idx[val] = arr.size() - 1;\n        return true;\n    }\n    \n    /** Removes a value from the set. Returns true if the set contained the specified element. */\n    bool remove(int val) {\n        if(!idx.count(val)) return false;\n        int pos = idx[val];\n        idx[arr[arr.size() - 1]] = pos;\n        swap(arr[pos], arr[arr.size() - 1]);\n        arr.pop_back();\n        idx.erase(val);\n        return true;\n    }\n    \n    /** Get a random element from the set. */\n    int getRandom() {\n        return arr[random() % arr.size()];\n    }\n};\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet* obj = new RandomizedSet();\n * bool param_1 = obj->insert(val);\n * bool param_2 = obj->remove(val);\n * int param_3 = obj->getRandom();\n */\n```\n\n","slug":"刷题/数据结构/复杂数据结构/380-Insert-Delete-GetRandom-O-1","published":1,"updated":"2021-03-03T04:33:14.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j710050l5uoeuy3a910","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>要求插入，删除，随机获取元素用$O(1)$</p>\n<p>不要求数据有序，也不要要求数据按原序。</p>\n<p><code>hash + 动态数组</code>即可。</p>\n<blockquote>\n<p>删除的时候，交换待删除元素到动态数组末就行了。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass RandomizedSet &#123;\n    vector&lt;int&gt; arr;\n    unordered_map&lt;int, int&gt; idx;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    RandomizedSet() &#123;\n\n    &#125;\n    \n    &#x2F;** Inserts a value to the set. Returns true if the set did not already contain the specified element. *&#x2F;\n    bool insert(int val) &#123;\n        if(idx.count(val))&#123;\n            return false;\n        &#125;\n        arr.push_back(val);\n        idx[val] &#x3D; arr.size() - 1;\n        return true;\n    &#125;\n    \n    &#x2F;** Removes a value from the set. Returns true if the set contained the specified element. *&#x2F;\n    bool remove(int val) &#123;\n        if(!idx.count(val)) return false;\n        int pos &#x3D; idx[val];\n        idx[arr[arr.size() - 1]] &#x3D; pos;\n        swap(arr[pos], arr[arr.size() - 1]);\n        arr.pop_back();\n        idx.erase(val);\n        return true;\n    &#125;\n    \n    &#x2F;** Get a random element from the set. *&#x2F;\n    int getRandom() &#123;\n        return arr[random() % arr.size()];\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet* obj &#x3D; new RandomizedSet();\n * bool param_1 &#x3D; obj-&gt;insert(val);\n * bool param_2 &#x3D; obj-&gt;remove(val);\n * int param_3 &#x3D; obj-&gt;getRandom();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"26MN0FY","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>要求插入，删除，随机获取元素用$O(1)$</p>\n<p>不要求数据有序，也不要要求数据按原序。</p>\n<p><code>hash + 动态数组</code>即可。</p>\n<blockquote>\n<p>删除的时候，交换待删除元素到动态数组末就行了。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass RandomizedSet &#123;\n    vector&lt;int&gt; arr;\n    unordered_map&lt;int, int&gt; idx;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    RandomizedSet() &#123;\n\n    &#125;\n    \n    &#x2F;** Inserts a value to the set. Returns true if the set did not already contain the specified element. *&#x2F;\n    bool insert(int val) &#123;\n        if(idx.count(val))&#123;\n            return false;\n        &#125;\n        arr.push_back(val);\n        idx[val] &#x3D; arr.size() - 1;\n        return true;\n    &#125;\n    \n    &#x2F;** Removes a value from the set. Returns true if the set contained the specified element. *&#x2F;\n    bool remove(int val) &#123;\n        if(!idx.count(val)) return false;\n        int pos &#x3D; idx[val];\n        idx[arr[arr.size() - 1]] &#x3D; pos;\n        swap(arr[pos], arr[arr.size() - 1]);\n        arr.pop_back();\n        idx.erase(val);\n        return true;\n    &#125;\n    \n    &#x2F;** Get a random element from the set. *&#x2F;\n    int getRandom() &#123;\n        return arr[random() % arr.size()];\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet* obj &#x3D; new RandomizedSet();\n * bool param_1 &#x3D; obj-&gt;insert(val);\n * bool param_2 &#x3D; obj-&gt;remove(val);\n * int param_3 &#x3D; obj-&gt;getRandom();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"706. Design HashMap","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-15T03:13:45.000Z","_content":"\n\n\n## 思路思路：\n\n `hash table` 配置 STL强大的API包装完成了。\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass MyHashMap {\n    vector<list<pair<int, int>>> data;\n    static const int base = 1931;\n    static int hash(int key){\n        return key % base;   \n    }\n    auto findit(int key, int pos){\n        auto iskey = [key](pair<int, int> item){return item.first == key;};\n        return find_if(data[pos].begin(), data[pos].end(), iskey);\n    }\n\npublic:\n    /** Initialize your data structure here. */\n    MyHashMap() {\n        data.resize(1931);\n        // erase不会检查尾指针\n        // int key = 0,  pos  = 0;\n        // auto it = findit(key, pos);\n        // cout << \"start\" << key << endl;\n        // data[pos].erase(it);\n    }\n    \n    /** value will always be non-negative. */\n    void put(int key, int value) {\n        int pos = hash(key);\n        auto it = findit(key, pos);\n        if(it == data[pos].end())\n            data[pos].insert(it, {key, value});\n        else \n            it->second = value;\n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    int get(int key) {\n        int pos = hash(key);\n        auto it = findit(key, pos);\n        // cout << \"find\" << key << endl;\n        return it == data[pos].end() ? -1 : (*it).second;\n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    void remove(int key) {\n        int pos = hash(key);\n        auto it = findit(key, pos);\n        // cout << \"remove\" << key << endl;\n        if(it != data[pos].end()) data[pos].erase(it);\n    }\n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj->put(key,value);\n * int param_2 = obj->get(key);\n * obj->remove(key);\n */\n```\n\n","source":"_posts/刷题/数据结构/复杂数据结构/706-Design-HashMap.md","raw":"---\ntitle: 706. Design HashMap\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-15 11:13:45\ntags:\ncategories:\n---\n\n\n\n## 思路思路：\n\n `hash table` 配置 STL强大的API包装完成了。\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass MyHashMap {\n    vector<list<pair<int, int>>> data;\n    static const int base = 1931;\n    static int hash(int key){\n        return key % base;   \n    }\n    auto findit(int key, int pos){\n        auto iskey = [key](pair<int, int> item){return item.first == key;};\n        return find_if(data[pos].begin(), data[pos].end(), iskey);\n    }\n\npublic:\n    /** Initialize your data structure here. */\n    MyHashMap() {\n        data.resize(1931);\n        // erase不会检查尾指针\n        // int key = 0,  pos  = 0;\n        // auto it = findit(key, pos);\n        // cout << \"start\" << key << endl;\n        // data[pos].erase(it);\n    }\n    \n    /** value will always be non-negative. */\n    void put(int key, int value) {\n        int pos = hash(key);\n        auto it = findit(key, pos);\n        if(it == data[pos].end())\n            data[pos].insert(it, {key, value});\n        else \n            it->second = value;\n    }\n    \n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    int get(int key) {\n        int pos = hash(key);\n        auto it = findit(key, pos);\n        // cout << \"find\" << key << endl;\n        return it == data[pos].end() ? -1 : (*it).second;\n    }\n    \n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    void remove(int key) {\n        int pos = hash(key);\n        auto it = findit(key, pos);\n        // cout << \"remove\" << key << endl;\n        if(it != data[pos].end()) data[pos].erase(it);\n    }\n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj->put(key,value);\n * int param_2 = obj->get(key);\n * obj->remove(key);\n */\n```\n\n","slug":"刷题/数据结构/复杂数据结构/706-Design-HashMap","published":1,"updated":"2021-03-15T03:14:57.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j720051l5uo291wdgc3","content":"<h2 id=\"思路思路：\"><a href=\"#思路思路：\" class=\"headerlink\" title=\"思路思路：\"></a>思路思路：</h2><p> <code>hash table</code> 配置 STL强大的API包装完成了。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyHashMap &#123;\n    vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; data;\n    static const int base &#x3D; 1931;\n    static int hash(int key)&#123;\n        return key % base;   \n    &#125;\n    auto findit(int key, int pos)&#123;\n        auto iskey &#x3D; [key](pair&lt;int, int&gt; item)&#123;return item.first &#x3D;&#x3D; key;&#125;;\n        return find_if(data[pos].begin(), data[pos].end(), iskey);\n    &#125;\n\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    MyHashMap() &#123;\n        data.resize(1931);\n        &#x2F;&#x2F; erase不会检查尾指针\n        &#x2F;&#x2F; int key &#x3D; 0,  pos  &#x3D; 0;\n        &#x2F;&#x2F; auto it &#x3D; findit(key, pos);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;start&quot; &lt;&lt; key &lt;&lt; endl;\n        &#x2F;&#x2F; data[pos].erase(it);\n    &#125;\n    \n    &#x2F;** value will always be non-negative. *&#x2F;\n    void put(int key, int value) &#123;\n        int pos &#x3D; hash(key);\n        auto it &#x3D; findit(key, pos);\n        if(it &#x3D;&#x3D; data[pos].end())\n            data[pos].insert(it, &#123;key, value&#125;);\n        else \n            it-&gt;second &#x3D; value;\n    &#125;\n    \n    &#x2F;** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key *&#x2F;\n    int get(int key) &#123;\n        int pos &#x3D; hash(key);\n        auto it &#x3D; findit(key, pos);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;find&quot; &lt;&lt; key &lt;&lt; endl;\n        return it &#x3D;&#x3D; data[pos].end() ? -1 : (*it).second;\n    &#125;\n    \n    &#x2F;** Removes the mapping of the specified value key if this map contains a mapping for the key *&#x2F;\n    void remove(int key) &#123;\n        int pos &#x3D; hash(key);\n        auto it &#x3D; findit(key, pos);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;remove&quot; &lt;&lt; key &lt;&lt; endl;\n        if(it !&#x3D; data[pos].end()) data[pos].erase(it);\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj &#x3D; new MyHashMap();\n * obj-&gt;put(key,value);\n * int param_2 &#x3D; obj-&gt;get(key);\n * obj-&gt;remove(key);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"XCW7QS","excerpt":"<h2 id=\"思路思路：\"><a href=\"#思路思路：\" class=\"headerlink\" title=\"思路思路：\"></a>思路思路：</h2><p> <code>hash table</code> 配置 STL强大的API包装完成了。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyHashMap &#123;\n    vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; data;\n    static const int base &#x3D; 1931;\n    static int hash(int key)&#123;\n        return key % base;   \n    &#125;\n    auto findit(int key, int pos)&#123;\n        auto iskey &#x3D; [key](pair&lt;int, int&gt; item)&#123;return item.first &#x3D;&#x3D; key;&#125;;\n        return find_if(data[pos].begin(), data[pos].end(), iskey);\n    &#125;\n\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    MyHashMap() &#123;\n        data.resize(1931);\n        &#x2F;&#x2F; erase不会检查尾指针\n        &#x2F;&#x2F; int key &#x3D; 0,  pos  &#x3D; 0;\n        &#x2F;&#x2F; auto it &#x3D; findit(key, pos);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;start&quot; &lt;&lt; key &lt;&lt; endl;\n        &#x2F;&#x2F; data[pos].erase(it);\n    &#125;\n    \n    &#x2F;** value will always be non-negative. *&#x2F;\n    void put(int key, int value) &#123;\n        int pos &#x3D; hash(key);\n        auto it &#x3D; findit(key, pos);\n        if(it &#x3D;&#x3D; data[pos].end())\n            data[pos].insert(it, &#123;key, value&#125;);\n        else \n            it-&gt;second &#x3D; value;\n    &#125;\n    \n    &#x2F;** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key *&#x2F;\n    int get(int key) &#123;\n        int pos &#x3D; hash(key);\n        auto it &#x3D; findit(key, pos);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;find&quot; &lt;&lt; key &lt;&lt; endl;\n        return it &#x3D;&#x3D; data[pos].end() ? -1 : (*it).second;\n    &#125;\n    \n    &#x2F;** Removes the mapping of the specified value key if this map contains a mapping for the key *&#x2F;\n    void remove(int key) &#123;\n        int pos &#x3D; hash(key);\n        auto it &#x3D; findit(key, pos);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;remove&quot; &lt;&lt; key &lt;&lt; endl;\n        if(it !&#x3D; data[pos].end()) data[pos].erase(it);\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj &#x3D; new MyHashMap();\n * obj-&gt;put(key,value);\n * int param_2 &#x3D; obj-&gt;get(key);\n * obj-&gt;remove(key);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"155. Min Stack","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-23T10:22:02.000Z","_content":"\n\n\n\n## [155. Min Stack](https://leetcode-cn.com/problems/min-stack/)\n\n\n\n## 思路：\n\n用另一个栈保存另一个栈的各个元素插入，删除后的最小值。\n\n他利用这么一个现象：后插入的大元素不会影响这个栈的最小值，反之小元素会改变。那么只要把此时小元素插入到最小栈即可，同理删除元素的时候也按值删除。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n\n```c++\nclass MinStack {\n    stack<int> s1, mins;\npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n        if(mins.empty() || mins.top() >= x){\n            mins.push(x);\n        }\n    }\n    \n    void pop() {\n        if(s1.size()){\n            int f = s1.top();\n            s1.pop();\n            if(mins.size() && f == mins.top()){\n                mins.pop();\n            }\n        }\n    }\n    \n    int top() {\n        return s1.top();\n    }\n    \n    int getMin() {\n        return mins.top();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(x);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */\n```\n\n","source":"_posts/刷题/数据结构/栈和队列/155-Min-Stack.md","raw":"---\ntitle: 155. Min Stack\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-23 18:22:02\n---\n\n\n\n\n## [155. Min Stack](https://leetcode-cn.com/problems/min-stack/)\n\n\n\n## 思路：\n\n用另一个栈保存另一个栈的各个元素插入，删除后的最小值。\n\n他利用这么一个现象：后插入的大元素不会影响这个栈的最小值，反之小元素会改变。那么只要把此时小元素插入到最小栈即可，同理删除元素的时候也按值删除。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n\n```c++\nclass MinStack {\n    stack<int> s1, mins;\npublic:\n    /** initialize your data structure here. */\n    MinStack() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n        if(mins.empty() || mins.top() >= x){\n            mins.push(x);\n        }\n    }\n    \n    void pop() {\n        if(s1.size()){\n            int f = s1.top();\n            s1.pop();\n            if(mins.size() && f == mins.top()){\n                mins.pop();\n            }\n        }\n    }\n    \n    int top() {\n        return s1.top();\n    }\n    \n    int getMin() {\n        return mins.top();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(x);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */\n```\n\n","slug":"刷题/数据结构/栈和队列/155-Min-Stack","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j720052l5uoddap23nr","content":"<h2 id=\"155-Min-Stack\"><a href=\"#155-Min-Stack\" class=\"headerlink\" title=\"155. Min Stack\"></a><a href=\"https://leetcode-cn.com/problems/min-stack/\">155. Min Stack</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用另一个栈保存另一个栈的各个元素插入，删除后的最小值。</p>\n<p>他利用这么一个现象：后插入的大元素不会影响这个栈的最小值，反之小元素会改变。那么只要把此时小元素插入到最小栈即可，同理删除元素的时候也按值删除。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MinStack &#123;\n    stack&lt;int&gt; s1, mins;\npublic:\n    &#x2F;** initialize your data structure here. *&#x2F;\n    MinStack() &#123;\n\n    &#125;\n    \n    void push(int x) &#123;\n        s1.push(x);\n        if(mins.empty() || mins.top() &gt;&#x3D; x)&#123;\n            mins.push(x);\n        &#125;\n    &#125;\n    \n    void pop() &#123;\n        if(s1.size())&#123;\n            int f &#x3D; s1.top();\n            s1.pop();\n            if(mins.size() &amp;&amp; f &#x3D;&#x3D; mins.top())&#123;\n                mins.pop();\n            &#125;\n        &#125;\n    &#125;\n    \n    int top() &#123;\n        return s1.top();\n    &#125;\n    \n    int getMin() &#123;\n        return mins.top();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj &#x3D; new MinStack();\n * obj-&gt;push(x);\n * obj-&gt;pop();\n * int param_3 &#x3D; obj-&gt;top();\n * int param_4 &#x3D; obj-&gt;getMin();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"281XAGH","excerpt":"<h2 id=\"155-Min-Stack\"><a href=\"#155-Min-Stack\" class=\"headerlink\" title=\"155. Min Stack\"></a><a href=\"https://leetcode-cn.com/problems/min-stack/\">155. Min Stack</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用另一个栈保存另一个栈的各个元素插入，删除后的最小值。</p>\n<p>他利用这么一个现象：后插入的大元素不会影响这个栈的最小值，反之小元素会改变。那么只要把此时小元素插入到最小栈即可，同理删除元素的时候也按值删除。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MinStack &#123;\n    stack&lt;int&gt; s1, mins;\npublic:\n    &#x2F;** initialize your data structure here. *&#x2F;\n    MinStack() &#123;\n\n    &#125;\n    \n    void push(int x) &#123;\n        s1.push(x);\n        if(mins.empty() || mins.top() &gt;&#x3D; x)&#123;\n            mins.push(x);\n        &#125;\n    &#125;\n    \n    void pop() &#123;\n        if(s1.size())&#123;\n            int f &#x3D; s1.top();\n            s1.pop();\n            if(mins.size() &amp;&amp; f &#x3D;&#x3D; mins.top())&#123;\n                mins.pop();\n            &#125;\n        &#125;\n    &#125;\n    \n    int top() &#123;\n        return s1.top();\n    &#125;\n    \n    int getMin() &#123;\n        return mins.top();\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj &#x3D; new MinStack();\n * obj-&gt;push(x);\n * obj-&gt;pop();\n * int param_3 &#x3D; obj-&gt;top();\n * int param_4 &#x3D; obj-&gt;getMin();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"20. Valid Parentheses","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-23T10:22:12.000Z","_content":"\n\n\n\n\n## [20. Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/)\n\n## 思路：\n\n用栈判断即可。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    stack<char> sta;\npublic:\n    bool isValid(string s) {\n        for(auto c : s){\n            if(c == '(' || c == '[' || c == '{'){\n                sta.push(c);\n                continue;\n            }\n            \n            if(sta.size()){\n                char topc = sta.top();\n                switch(topc){\n                    case '(' : \n                        if(c == ')') sta.pop();\n                        else return false;\n                        break;\n                    \n                    case '[' : \n                        if(c == ']') sta.pop();\n                        else return false;\n                        break;\n                    \n                    case '{' : \n                        if(c == '}') sta.pop();\n                        else return false;\n                        break;\n                }\n\n            }else return false;\n        }\n\n        if(sta.empty()) return true;\n        else return false;\n    }\n};\n```\n\n\n\nmap简洁写法\n\n```c++\nclass Solution {\n    stack<char> sta;\npublic:\n    bool isValid(string s) {\n        \n        map<char, char> pairs = {\n            {'[',']'},\n            {'(', ')'},\n            {'{', '}'}\n        };\n        for(auto c : s){\n            if(pairs.count(c)){\n                sta.push(c);\n            }\n            else{\n                if(sta.empty() || pairs[sta.top()] != c) return false;\n                sta.pop();\n            }\n        }\n        return sta.empty();\n    }\n};\n```","source":"_posts/刷题/数据结构/栈和队列/20-Valid-Parentheses.md","raw":"---\ntitle: 20. Valid Parentheses\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-23 18:22:12\n---\n\n\n\n\n\n## [20. Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/)\n\n## 思路：\n\n用栈判断即可。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\n    stack<char> sta;\npublic:\n    bool isValid(string s) {\n        for(auto c : s){\n            if(c == '(' || c == '[' || c == '{'){\n                sta.push(c);\n                continue;\n            }\n            \n            if(sta.size()){\n                char topc = sta.top();\n                switch(topc){\n                    case '(' : \n                        if(c == ')') sta.pop();\n                        else return false;\n                        break;\n                    \n                    case '[' : \n                        if(c == ']') sta.pop();\n                        else return false;\n                        break;\n                    \n                    case '{' : \n                        if(c == '}') sta.pop();\n                        else return false;\n                        break;\n                }\n\n            }else return false;\n        }\n\n        if(sta.empty()) return true;\n        else return false;\n    }\n};\n```\n\n\n\nmap简洁写法\n\n```c++\nclass Solution {\n    stack<char> sta;\npublic:\n    bool isValid(string s) {\n        \n        map<char, char> pairs = {\n            {'[',']'},\n            {'(', ')'},\n            {'{', '}'}\n        };\n        for(auto c : s){\n            if(pairs.count(c)){\n                sta.push(c);\n            }\n            else{\n                if(sta.empty() || pairs[sta.top()] != c) return false;\n                sta.pop();\n            }\n        }\n        return sta.empty();\n    }\n};\n```","slug":"刷题/数据结构/栈和队列/20-Valid-Parentheses","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j730053l5uo1qdr5ren","content":"<h2 id=\"20-Valid-Parentheses\"><a href=\"#20-Valid-Parentheses\" class=\"headerlink\" title=\"20. Valid Parentheses\"></a><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">20. Valid Parentheses</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用栈判断即可。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    stack&lt;char&gt; sta;\npublic:\n    bool isValid(string s) &#123;\n        for(auto c : s)&#123;\n            if(c &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;&#123;&#39;)&#123;\n                sta.push(c);\n                continue;\n            &#125;\n            \n            if(sta.size())&#123;\n                char topc &#x3D; sta.top();\n                switch(topc)&#123;\n                    case &#39;(&#39; : \n                        if(c &#x3D;&#x3D; &#39;)&#39;) sta.pop();\n                        else return false;\n                        break;\n                    \n                    case &#39;[&#39; : \n                        if(c &#x3D;&#x3D; &#39;]&#39;) sta.pop();\n                        else return false;\n                        break;\n                    \n                    case &#39;&#123;&#39; : \n                        if(c &#x3D;&#x3D; &#39;&#125;&#39;) sta.pop();\n                        else return false;\n                        break;\n                &#125;\n\n            &#125;else return false;\n        &#125;\n\n        if(sta.empty()) return true;\n        else return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>map简洁写法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    stack&lt;char&gt; sta;\npublic:\n    bool isValid(string s) &#123;\n        \n        map&lt;char, char&gt; pairs &#x3D; &#123;\n            &#123;&#39;[&#39;,&#39;]&#39;&#125;,\n            &#123;&#39;(&#39;, &#39;)&#39;&#125;,\n            &#123;&#39;&#123;&#39;, &#39;&#125;&#39;&#125;\n        &#125;;\n        for(auto c : s)&#123;\n            if(pairs.count(c))&#123;\n                sta.push(c);\n            &#125;\n            else&#123;\n                if(sta.empty() || pairs[sta.top()] !&#x3D; c) return false;\n                sta.pop();\n            &#125;\n        &#125;\n        return sta.empty();\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"262SBEE","excerpt":"<h2 id=\"20-Valid-Parentheses\"><a href=\"#20-Valid-Parentheses\" class=\"headerlink\" title=\"20. Valid Parentheses\"></a><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">20. Valid Parentheses</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>用栈判断即可。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    stack&lt;char&gt; sta;\npublic:\n    bool isValid(string s) &#123;\n        for(auto c : s)&#123;\n            if(c &#x3D;&#x3D; &#39;(&#39; || c &#x3D;&#x3D; &#39;[&#39; || c &#x3D;&#x3D; &#39;&#123;&#39;)&#123;\n                sta.push(c);\n                continue;\n            &#125;\n            \n            if(sta.size())&#123;\n                char topc &#x3D; sta.top();\n                switch(topc)&#123;\n                    case &#39;(&#39; : \n                        if(c &#x3D;&#x3D; &#39;)&#39;) sta.pop();\n                        else return false;\n                        break;\n                    \n                    case &#39;[&#39; : \n                        if(c &#x3D;&#x3D; &#39;]&#39;) sta.pop();\n                        else return false;\n                        break;\n                    \n                    case &#39;&#123;&#39; : \n                        if(c &#x3D;&#x3D; &#39;&#125;&#39;) sta.pop();\n                        else return false;\n                        break;\n                &#125;\n\n            &#125;else return false;\n        &#125;\n\n        if(sta.empty()) return true;\n        else return false;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>map简洁写法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    stack&lt;char&gt; sta;\npublic:\n    bool isValid(string s) &#123;\n        \n        map&lt;char, char&gt; pairs &#x3D; &#123;\n            &#123;&#39;[&#39;,&#39;]&#39;&#125;,\n            &#123;&#39;(&#39;, &#39;)&#39;&#125;,\n            &#123;&#39;&#123;&#39;, &#39;&#125;&#39;&#125;\n        &#125;;\n        for(auto c : s)&#123;\n            if(pairs.count(c))&#123;\n                sta.push(c);\n            &#125;\n            else&#123;\n                if(sta.empty() || pairs[sta.top()] !&#x3D; c) return false;\n                sta.pop();\n            &#125;\n        &#125;\n        return sta.empty();\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"225. Implement Stack using Queues","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-30T07:12:26.000Z","_content":"\n\n\n\n\n## [225. Implement Stack using Queues](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n\n\n\n\n## 思路：\t\n\n\n\n其实我想到了，但是这个效率真的差。<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass MyStack {\n    queue<int> q1, q2;\npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        q2.push(x);\n        while(q1.size()){\n            q2.push(q1.front());\n            q1.pop();\n        }\n        swap(q1 ,q2);\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int temp = q1.front();\n        q1.pop();\n        return temp;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        return q1.front();\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q1.size() == 0;\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */\n```","source":"_posts/刷题/数据结构/栈和队列/225-Implement-Stack-using-Queues.md","raw":"---\ntitle: 225. Implement Stack using Queues\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-01-30 15:12:26\ntags:\ncategories:\n---\n\n\n\n\n\n## [225. Implement Stack using Queues](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n\n\n\n\n## 思路：\t\n\n\n\n其实我想到了，但是这个效率真的差。<!-- more -->\n\n\n\n## 代码：\n\n```c++\nclass MyStack {\n    queue<int> q1, q2;\npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n    \n    /** Push element x onto stack. */\n    void push(int x) {\n        q2.push(x);\n        while(q1.size()){\n            q2.push(q1.front());\n            q1.pop();\n        }\n        swap(q1 ,q2);\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int temp = q1.front();\n        q1.pop();\n        return temp;\n    }\n    \n    /** Get the top element. */\n    int top() {\n        return q1.front();\n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return q1.size() == 0;\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */\n```","slug":"刷题/数据结构/栈和队列/225-Implement-Stack-using-Queues","published":1,"updated":"2021-01-30T07:13:08.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j730054l5uo492danje","content":"<h2 id=\"225-Implement-Stack-using-Queues\"><a href=\"#225-Implement-Stack-using-Queues\" class=\"headerlink\" title=\"225. Implement Stack using Queues\"></a><a href=\"https://leetcode-cn.com/problems/implement-stack-using-queues/\">225. Implement Stack using Queues</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>其实我想到了，但是这个效率真的差。<span id=\"more\"></span></p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyStack &#123;\n    queue&lt;int&gt; q1, q2;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    MyStack() &#123;\n\n    &#125;\n    \n    &#x2F;** Push element x onto stack. *&#x2F;\n    void push(int x) &#123;\n        q2.push(x);\n        while(q1.size())&#123;\n            q2.push(q1.front());\n            q1.pop();\n        &#125;\n        swap(q1 ,q2);\n    &#125;\n    \n    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;\n    int pop() &#123;\n        int temp &#x3D; q1.front();\n        q1.pop();\n        return temp;\n    &#125;\n    \n    &#x2F;** Get the top element. *&#x2F;\n    int top() &#123;\n        return q1.front();\n    &#125;\n    \n    &#x2F;** Returns whether the stack is empty. *&#x2F;\n    bool empty() &#123;\n        return q1.size() &#x3D;&#x3D; 0;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj &#x3D; new MyStack();\n * obj-&gt;push(x);\n * int param_2 &#x3D; obj-&gt;pop();\n * int param_3 &#x3D; obj-&gt;top();\n * bool param_4 &#x3D; obj-&gt;empty();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"6VH5X5","excerpt":"<h2 id=\"225-Implement-Stack-using-Queues\"><a href=\"#225-Implement-Stack-using-Queues\" class=\"headerlink\" title=\"225. Implement Stack using Queues\"></a><a href=\"https://leetcode-cn.com/problems/implement-stack-using-queues/\">225. Implement Stack using Queues</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>其实我想到了，但是这个效率真的差。","more":"</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyStack &#123;\n    queue&lt;int&gt; q1, q2;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    MyStack() &#123;\n\n    &#125;\n    \n    &#x2F;** Push element x onto stack. *&#x2F;\n    void push(int x) &#123;\n        q2.push(x);\n        while(q1.size())&#123;\n            q2.push(q1.front());\n            q1.pop();\n        &#125;\n        swap(q1 ,q2);\n    &#125;\n    \n    &#x2F;** Removes the element on top of the stack and returns that element. *&#x2F;\n    int pop() &#123;\n        int temp &#x3D; q1.front();\n        q1.pop();\n        return temp;\n    &#125;\n    \n    &#x2F;** Get the top element. *&#x2F;\n    int top() &#123;\n        return q1.front();\n    &#125;\n    \n    &#x2F;** Returns whether the stack is empty. *&#x2F;\n    bool empty() &#123;\n        return q1.size() &#x3D;&#x3D; 0;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj &#x3D; new MyStack();\n * obj-&gt;push(x);\n * int param_2 &#x3D; obj-&gt;pop();\n * int param_3 &#x3D; obj-&gt;top();\n * bool param_4 &#x3D; obj-&gt;empty();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"232. Implement Queue using Stacks","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-23T10:22:22.000Z","_content":"\n\n\n\n\n## [232. Implement Queue using Stacks](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n\n\n## 思路：\n\n两个队列一个入队元素，一个出队元素。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass MyQueue {\n    stack<int> s1, s2;\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        s1.push(x);\n        // cout << x << endl;\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(s2.size() == 0){\n            while(s1.size()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        if(s2.size() == 0) return -1;\n\n        int t = s2.top();\n        s2.pop();\n        return t;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(s2.size() == 0){\n            while(s1.size()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return s1.size() == 0 && s2.size() == 0;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","source":"_posts/刷题/数据结构/栈和队列/232-Implement-Queue-using-Stacks.md","raw":"---\ntitle: 232. Implement Queue using Stacks\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-23 18:22:22\n---\n\n\n\n\n\n## [232. Implement Queue using Stacks](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n\n\n## 思路：\n\n两个队列一个入队元素，一个出队元素。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n```c++\nclass MyQueue {\n    stack<int> s1, s2;\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        \n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        s1.push(x);\n        // cout << x << endl;\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if(s2.size() == 0){\n            while(s1.size()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        if(s2.size() == 0) return -1;\n\n        int t = s2.top();\n        s2.pop();\n        return t;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if(s2.size() == 0){\n            while(s1.size()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return s1.size() == 0 && s2.size() == 0;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","slug":"刷题/数据结构/栈和队列/232-Implement-Queue-using-Stacks","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j740055l5uo7m7s3cpj","content":"<h2 id=\"232-Implement-Queue-using-Stacks\"><a href=\"#232-Implement-Queue-using-Stacks\" class=\"headerlink\" title=\"232. Implement Queue using Stacks\"></a><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">232. Implement Queue using Stacks</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>两个队列一个入队元素，一个出队元素。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyQueue &#123;\n    stack&lt;int&gt; s1, s2;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    MyQueue() &#123;\n        \n    &#125;\n    \n    &#x2F;** Push element x to the back of queue. *&#x2F;\n    void push(int x) &#123;\n        s1.push(x);\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; endl;\n    &#125;\n    \n    &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;\n    int pop() &#123;\n        if(s2.size() &#x3D;&#x3D; 0)&#123;\n            while(s1.size())&#123;\n                s2.push(s1.top());\n                s1.pop();\n            &#125;\n        &#125;\n        if(s2.size() &#x3D;&#x3D; 0) return -1;\n\n        int t &#x3D; s2.top();\n        s2.pop();\n        return t;\n    &#125;\n    \n    &#x2F;** Get the front element. *&#x2F;\n    int peek() &#123;\n        if(s2.size() &#x3D;&#x3D; 0)&#123;\n            while(s1.size())&#123;\n                s2.push(s1.top());\n                s1.pop();\n            &#125;\n        &#125;\n        return s2.top();\n    &#125;\n    \n    &#x2F;** Returns whether the queue is empty. *&#x2F;\n    bool empty() &#123;\n        return s1.size() &#x3D;&#x3D; 0 &amp;&amp; s2.size() &#x3D;&#x3D; 0;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj &#x3D; new MyQueue();\n * obj-&gt;push(x);\n * int param_2 &#x3D; obj-&gt;pop();\n * int param_3 &#x3D; obj-&gt;peek();\n * bool param_4 &#x3D; obj-&gt;empty();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1B7E5Z2","excerpt":"<h2 id=\"232-Implement-Queue-using-Stacks\"><a href=\"#232-Implement-Queue-using-Stacks\" class=\"headerlink\" title=\"232. Implement Queue using Stacks\"></a><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">232. Implement Queue using Stacks</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>两个队列一个入队元素，一个出队元素。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MyQueue &#123;\n    stack&lt;int&gt; s1, s2;\npublic:\n    &#x2F;** Initialize your data structure here. *&#x2F;\n    MyQueue() &#123;\n        \n    &#125;\n    \n    &#x2F;** Push element x to the back of queue. *&#x2F;\n    void push(int x) &#123;\n        s1.push(x);\n        &#x2F;&#x2F; cout &lt;&lt; x &lt;&lt; endl;\n    &#125;\n    \n    &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;\n    int pop() &#123;\n        if(s2.size() &#x3D;&#x3D; 0)&#123;\n            while(s1.size())&#123;\n                s2.push(s1.top());\n                s1.pop();\n            &#125;\n        &#125;\n        if(s2.size() &#x3D;&#x3D; 0) return -1;\n\n        int t &#x3D; s2.top();\n        s2.pop();\n        return t;\n    &#125;\n    \n    &#x2F;** Get the front element. *&#x2F;\n    int peek() &#123;\n        if(s2.size() &#x3D;&#x3D; 0)&#123;\n            while(s1.size())&#123;\n                s2.push(s1.top());\n                s1.pop();\n            &#125;\n        &#125;\n        return s2.top();\n    &#125;\n    \n    &#x2F;** Returns whether the queue is empty. *&#x2F;\n    bool empty() &#123;\n        return s1.size() &#x3D;&#x3D; 0 &amp;&amp; s2.size() &#x3D;&#x3D; 0;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj &#x3D; new MyQueue();\n * obj-&gt;push(x);\n * int param_2 &#x3D; obj-&gt;pop();\n * int param_3 &#x3D; obj-&gt;peek();\n * bool param_4 &#x3D; obj-&gt;empty();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"239. Sliding Window Maximum","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-25T07:45:02.000Z","_content":"\n\n\n\n\n\n\n## [239. Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n## 思路：\n\n\n\n想了三种方法：\n\n1. 朴素地确认最大值是否在窗口内\n2. 使用优先队列维护窗口中的最值，但是需要注意最值是否还在窗口内\n3. 使用单调双头队列维护窗口内的单调队列\n\n> 方法3的单调队列其实和单调栈的性质如出一辙，只不过换了个队列的性质。\n\n\n\n<!-- more -->\n\n## 代码：\n\ntle\n\n```c++\nclass Solution {\npublic:\n    \n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(k > n) return vector<int>();\n        vector<int> ans(n - k + 1);\n        auto p = max_element(nums.begin(), nums.begin() + k);\n        ans[0] = *p;\n        for(int i = 1; i < n - k + 1; ++i){\n            if(nums[i - 1] == *p){\n                p = max_element(nums.begin() + i, nums.begin() + i + k);\n            }\n            if(*(nums.begin() + i + k - 1) > *p)\n                p = nums.begin() + i + k - 1;\n            ans[i] = *p;\n        }\n        return ans;\n\n    }\n    \n};\n```\n\n\n\n\n\n优先队列 \n\n$o(nlogn)$\n\n\n\n```c++\nclass Solution {\npublic:\n    \n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(k > n) return vector<int>();\n        vector<int> ans(n - k + 1);\n       \n        priority_queue<pair<int, int>> pq;\n        for(int i = 0; i < k; ++i) pq.push({nums[i], i});\n        ans[0] = pq.top().first;\n        for(int i = 1; i < n - k + 1; ++i){\n            pq.push({nums[i + k - 1], i + k - 1});\n            auto [val, idx] = pq.top();\n            while(idx < i){\n                pq.pop();\n                val = pq.top().first;\n                idx = pq.top().second;\n            }\n            ans[i] = val;\n        }\n        return ans;\n    }\n    \n};\n```\n\n\n\n双头单调队列！\n\n```c++\nclass Solution {\npublic:\n    \n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(k > n) return vector<int>();\n        vector<int> ans(n - k + 1);\n       \n        deque<int> que; // 单调递减的队列\n        for(int i = 0; i < n; ++i){\n            if(i >= k && nums[i - k] == que.front()){ // 特定元素删除pop\n                que.pop_front();\n            }\n            \n            int t = nums[i];\n            while(que.size() && que.back() < t){ // 很像单调栈的维护过程\n                que.pop_back();\n            }\n            que.push_back(t);\n\n            if(i >= k - 1) ans[i - k + 1] = que.front();  // 记录\n        }\n        \n        return ans;\n    }\n    \n};\n```","source":"_posts/刷题/数据结构/栈和队列/239-Sliding-Window-Maximum.md","raw":"---\ntitle: 239. Sliding Window Maximum\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-25 15:45:02\n---\n\n\n\n\n\n\n\n## [239. Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n## 思路：\n\n\n\n想了三种方法：\n\n1. 朴素地确认最大值是否在窗口内\n2. 使用优先队列维护窗口中的最值，但是需要注意最值是否还在窗口内\n3. 使用单调双头队列维护窗口内的单调队列\n\n> 方法3的单调队列其实和单调栈的性质如出一辙，只不过换了个队列的性质。\n\n\n\n<!-- more -->\n\n## 代码：\n\ntle\n\n```c++\nclass Solution {\npublic:\n    \n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(k > n) return vector<int>();\n        vector<int> ans(n - k + 1);\n        auto p = max_element(nums.begin(), nums.begin() + k);\n        ans[0] = *p;\n        for(int i = 1; i < n - k + 1; ++i){\n            if(nums[i - 1] == *p){\n                p = max_element(nums.begin() + i, nums.begin() + i + k);\n            }\n            if(*(nums.begin() + i + k - 1) > *p)\n                p = nums.begin() + i + k - 1;\n            ans[i] = *p;\n        }\n        return ans;\n\n    }\n    \n};\n```\n\n\n\n\n\n优先队列 \n\n$o(nlogn)$\n\n\n\n```c++\nclass Solution {\npublic:\n    \n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(k > n) return vector<int>();\n        vector<int> ans(n - k + 1);\n       \n        priority_queue<pair<int, int>> pq;\n        for(int i = 0; i < k; ++i) pq.push({nums[i], i});\n        ans[0] = pq.top().first;\n        for(int i = 1; i < n - k + 1; ++i){\n            pq.push({nums[i + k - 1], i + k - 1});\n            auto [val, idx] = pq.top();\n            while(idx < i){\n                pq.pop();\n                val = pq.top().first;\n                idx = pq.top().second;\n            }\n            ans[i] = val;\n        }\n        return ans;\n    }\n    \n};\n```\n\n\n\n双头单调队列！\n\n```c++\nclass Solution {\npublic:\n    \n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        if(k > n) return vector<int>();\n        vector<int> ans(n - k + 1);\n       \n        deque<int> que; // 单调递减的队列\n        for(int i = 0; i < n; ++i){\n            if(i >= k && nums[i - k] == que.front()){ // 特定元素删除pop\n                que.pop_front();\n            }\n            \n            int t = nums[i];\n            while(que.size() && que.back() < t){ // 很像单调栈的维护过程\n                que.pop_back();\n            }\n            que.push_back(t);\n\n            if(i >= k - 1) ans[i - k + 1] = que.front();  // 记录\n        }\n        \n        return ans;\n    }\n    \n};\n```","slug":"刷题/数据结构/栈和队列/239-Sliding-Window-Maximum","published":1,"updated":"2021-04-21T08:17:42.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j750056l5uo89mpapmt","content":"<h2 id=\"239-Sliding-Window-Maximum\"><a href=\"#239-Sliding-Window-Maximum\" class=\"headerlink\" title=\"239. Sliding Window Maximum\"></a><a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\">239. Sliding Window Maximum</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>想了三种方法：</p>\n<ol>\n<li>朴素地确认最大值是否在窗口内</li>\n<li>使用优先队列维护窗口中的最值，但是需要注意最值是否还在窗口内</li>\n<li>使用单调双头队列维护窗口内的单调队列</li>\n</ol>\n<blockquote>\n<p>方法3的单调队列其实和单调栈的性质如出一辙，只不过换了个队列的性质。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>tle</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(k &gt; n) return vector&lt;int&gt;();\n        vector&lt;int&gt; ans(n - k + 1);\n        auto p &#x3D; max_element(nums.begin(), nums.begin() + k);\n        ans[0] &#x3D; *p;\n        for(int i &#x3D; 1; i &lt; n - k + 1; ++i)&#123;\n            if(nums[i - 1] &#x3D;&#x3D; *p)&#123;\n                p &#x3D; max_element(nums.begin() + i, nums.begin() + i + k);\n            &#125;\n            if(*(nums.begin() + i + k - 1) &gt; *p)\n                p &#x3D; nums.begin() + i + k - 1;\n            ans[i] &#x3D; *p;\n        &#125;\n        return ans;\n\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>优先队列 </p>\n<p>$o(nlogn)$</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(k &gt; n) return vector&lt;int&gt;();\n        vector&lt;int&gt; ans(n - k + 1);\n       \n        priority_queue&lt;pair&lt;int, int&gt;&gt; pq;\n        for(int i &#x3D; 0; i &lt; k; ++i) pq.push(&#123;nums[i], i&#125;);\n        ans[0] &#x3D; pq.top().first;\n        for(int i &#x3D; 1; i &lt; n - k + 1; ++i)&#123;\n            pq.push(&#123;nums[i + k - 1], i + k - 1&#125;);\n            auto [val, idx] &#x3D; pq.top();\n            while(idx &lt; i)&#123;\n                pq.pop();\n                val &#x3D; pq.top().first;\n                idx &#x3D; pq.top().second;\n            &#125;\n            ans[i] &#x3D; val;\n        &#125;\n        return ans;\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>双头单调队列！</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(k &gt; n) return vector&lt;int&gt;();\n        vector&lt;int&gt; ans(n - k + 1);\n       \n        deque&lt;int&gt; que; &#x2F;&#x2F; 单调递减的队列\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(i &gt;&#x3D; k &amp;&amp; nums[i - k] &#x3D;&#x3D; que.front())&#123; &#x2F;&#x2F; 特定元素删除pop\n                que.pop_front();\n            &#125;\n            \n            int t &#x3D; nums[i];\n            while(que.size() &amp;&amp; que.back() &lt; t)&#123; &#x2F;&#x2F; 很像单调栈的维护过程\n                que.pop_back();\n            &#125;\n            que.push_back(t);\n\n            if(i &gt;&#x3D; k - 1) ans[i - k + 1] &#x3D; que.front();  &#x2F;&#x2F; 记录\n        &#125;\n        \n        return ans;\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"3C787DG","excerpt":"<h2 id=\"239-Sliding-Window-Maximum\"><a href=\"#239-Sliding-Window-Maximum\" class=\"headerlink\" title=\"239. Sliding Window Maximum\"></a><a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\">239. Sliding Window Maximum</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>想了三种方法：</p>\n<ol>\n<li>朴素地确认最大值是否在窗口内</li>\n<li>使用优先队列维护窗口中的最值，但是需要注意最值是否还在窗口内</li>\n<li>使用单调双头队列维护窗口内的单调队列</li>\n</ol>\n<blockquote>\n<p>方法3的单调队列其实和单调栈的性质如出一辙，只不过换了个队列的性质。</p>\n</blockquote>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>tle</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(k &gt; n) return vector&lt;int&gt;();\n        vector&lt;int&gt; ans(n - k + 1);\n        auto p &#x3D; max_element(nums.begin(), nums.begin() + k);\n        ans[0] &#x3D; *p;\n        for(int i &#x3D; 1; i &lt; n - k + 1; ++i)&#123;\n            if(nums[i - 1] &#x3D;&#x3D; *p)&#123;\n                p &#x3D; max_element(nums.begin() + i, nums.begin() + i + k);\n            &#125;\n            if(*(nums.begin() + i + k - 1) &gt; *p)\n                p &#x3D; nums.begin() + i + k - 1;\n            ans[i] &#x3D; *p;\n        &#125;\n        return ans;\n\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>优先队列 </p>\n<p>$o(nlogn)$</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(k &gt; n) return vector&lt;int&gt;();\n        vector&lt;int&gt; ans(n - k + 1);\n       \n        priority_queue&lt;pair&lt;int, int&gt;&gt; pq;\n        for(int i &#x3D; 0; i &lt; k; ++i) pq.push(&#123;nums[i], i&#125;);\n        ans[0] &#x3D; pq.top().first;\n        for(int i &#x3D; 1; i &lt; n - k + 1; ++i)&#123;\n            pq.push(&#123;nums[i + k - 1], i + k - 1&#125;);\n            auto [val, idx] &#x3D; pq.top();\n            while(idx &lt; i)&#123;\n                pq.pop();\n                val &#x3D; pq.top().first;\n                idx &#x3D; pq.top().second;\n            &#125;\n            ans[i] &#x3D; val;\n        &#125;\n        return ans;\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>双头单调队列！</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    \n    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n &#x3D; nums.size();\n        if(k &gt; n) return vector&lt;int&gt;();\n        vector&lt;int&gt; ans(n - k + 1);\n       \n        deque&lt;int&gt; que; &#x2F;&#x2F; 单调递减的队列\n        for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n            if(i &gt;&#x3D; k &amp;&amp; nums[i - k] &#x3D;&#x3D; que.front())&#123; &#x2F;&#x2F; 特定元素删除pop\n                que.pop_front();\n            &#125;\n            \n            int t &#x3D; nums[i];\n            while(que.size() &amp;&amp; que.back() &lt; t)&#123; &#x2F;&#x2F; 很像单调栈的维护过程\n                que.pop_back();\n            &#125;\n            que.push_back(t);\n\n            if(i &gt;&#x3D; k - 1) ans[i - k + 1] &#x3D; que.front();  &#x2F;&#x2F; 记录\n        &#125;\n        \n        return ans;\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"32. Longest Valid Parentheses","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-04-25T08:25:41.000Z","_content":"\n\n<!-- more -->\n\n\n\n## 思路： \n\n栈验证匹配括号很简单，但是用如何获取多个匹配成功的括号组合长度就很麻烦！\n\n难的是想到，连续的有效括号`()())()()`只需要记录一个最先未匹配的位置。具体做法是，在栈中存储一个最后没有匹配到的右括号下标。\n\n\n\n\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int maxlen = 0; \n        stack<int> st;\n        \n        st.push(-1); // 压入一个最后未匹配的)。\n        for(int i = 0; i < s.size(); ++i){\n            if(s[i] == ')'){\n                st.pop();\n                if(!st.empty()){ // 刚刚的）匹配成功，可以计算最长匹配\n                    maxlen = max(maxlen, i - st.top()); \n                }else st.push(i); // 说明该)没有匹配到，是新的最后的最右括号\n            }else st.push(i);\n        }\n        return maxlen;\n    }\n};\n\n```\n\n","source":"_posts/刷题/数据结构/栈和队列/32-Longest-Valid-Parentheses.md","raw":"---\ntitle: 32. Longest Valid Parentheses\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-04-25 16:25:41\ntags:\ncategories:\n---\n\n\n<!-- more -->\n\n\n\n## 思路： \n\n栈验证匹配括号很简单，但是用如何获取多个匹配成功的括号组合长度就很麻烦！\n\n难的是想到，连续的有效括号`()())()()`只需要记录一个最先未匹配的位置。具体做法是，在栈中存储一个最后没有匹配到的右括号下标。\n\n\n\n\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int maxlen = 0; \n        stack<int> st;\n        \n        st.push(-1); // 压入一个最后未匹配的)。\n        for(int i = 0; i < s.size(); ++i){\n            if(s[i] == ')'){\n                st.pop();\n                if(!st.empty()){ // 刚刚的）匹配成功，可以计算最长匹配\n                    maxlen = max(maxlen, i - st.top()); \n                }else st.push(i); // 说明该)没有匹配到，是新的最后的最右括号\n            }else st.push(i);\n        }\n        return maxlen;\n    }\n};\n\n```\n\n","slug":"刷题/数据结构/栈和队列/32-Longest-Valid-Parentheses","published":1,"updated":"2021-04-25T08:32:09.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j750057l5uo2op20tss","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>栈验证匹配括号很简单，但是用如何获取多个匹配成功的括号组合长度就很麻烦！</p>\n<p>难的是想到，连续的有效括号<code>()())()()</code>只需要记录一个最先未匹配的位置。具体做法是，在栈中存储一个最后没有匹配到的右括号下标。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestValidParentheses(string s) &#123;\n        int maxlen &#x3D; 0; \n        stack&lt;int&gt; st;\n        \n        st.push(-1); &#x2F;&#x2F; 压入一个最后未匹配的)。\n        for(int i &#x3D; 0; i &lt; s.size(); ++i)&#123;\n            if(s[i] &#x3D;&#x3D; &#39;)&#39;)&#123;\n                st.pop();\n                if(!st.empty())&#123; &#x2F;&#x2F; 刚刚的）匹配成功，可以计算最长匹配\n                    maxlen &#x3D; max(maxlen, i - st.top()); \n                &#125;else st.push(i); &#x2F;&#x2F; 说明该)没有匹配到，是新的最后的最右括号\n            &#125;else st.push(i);\n        &#125;\n        return maxlen;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2JGSB4H","excerpt":"","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>栈验证匹配括号很简单，但是用如何获取多个匹配成功的括号组合长度就很麻烦！</p>\n<p>难的是想到，连续的有效括号<code>()())()()</code>只需要记录一个最先未匹配的位置。具体做法是，在栈中存储一个最后没有匹配到的右括号下标。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestValidParentheses(string s) &#123;\n        int maxlen &#x3D; 0; \n        stack&lt;int&gt; st;\n        \n        st.push(-1); &#x2F;&#x2F; 压入一个最后未匹配的)。\n        for(int i &#x3D; 0; i &lt; s.size(); ++i)&#123;\n            if(s[i] &#x3D;&#x3D; &#39;)&#39;)&#123;\n                st.pop();\n                if(!st.empty())&#123; &#x2F;&#x2F; 刚刚的）匹配成功，可以计算最长匹配\n                    maxlen &#x3D; max(maxlen, i - st.top()); \n                &#125;else st.push(i); &#x2F;&#x2F; 说明该)没有匹配到，是新的最后的最右括号\n            &#125;else st.push(i);\n        &#125;\n        return maxlen;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"503. Next Greater Element II","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-30T07:11:34.000Z","_content":"\n\n\n\n\n## [503. Next Greater Element II](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n\n\n\n\n## 思路：\n\n\n\n单调栈！比较更大值的神。\n\n遍历数组维护单调栈，在排除栈中更小的元素时，就已经为他们找到了更大值。为了保证数组是环形查找的，可以插入两次数组元素。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> bigger(n, -1);\n        stack<pair<int, int>> sta;\n        for(int i = 0; i < 2; ++i){\n            for(int j = 0; j < n; ++j){\n                while(sta.size() && sta.top().second <nums[j]){\n                    auto [pos, num] = sta.top();\n                    sta.pop();\n                    if(bigger[pos] == -1 )bigger[pos] = nums[j];\n                }\n                sta.push({j, nums[j]});\n            }\n        }\n        return bigger;\n    }\n};\n```","source":"_posts/刷题/数据结构/栈和队列/503-Next-Greater-Element-II.md","raw":"---\ntitle: 503. Next Greater Element II\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-01-30 15:11:34\ntags:\ncategories:\n---\n\n\n\n\n\n## [503. Next Greater Element II](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n\n\n\n\n## 思路：\n\n\n\n单调栈！比较更大值的神。\n\n遍历数组维护单调栈，在排除栈中更小的元素时，就已经为他们找到了更大值。为了保证数组是环形查找的，可以插入两次数组元素。\n\n<!-- more -->\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> bigger(n, -1);\n        stack<pair<int, int>> sta;\n        for(int i = 0; i < 2; ++i){\n            for(int j = 0; j < n; ++j){\n                while(sta.size() && sta.top().second <nums[j]){\n                    auto [pos, num] = sta.top();\n                    sta.pop();\n                    if(bigger[pos] == -1 )bigger[pos] = nums[j];\n                }\n                sta.push({j, nums[j]});\n            }\n        }\n        return bigger;\n    }\n};\n```","slug":"刷题/数据结构/栈和队列/503-Next-Greater-Element-II","published":1,"updated":"2021-01-30T07:13:28.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j760058l5uo4a212yw9","content":"<h2 id=\"503-Next-Greater-Element-II\"><a href=\"#503-Next-Greater-Element-II\" class=\"headerlink\" title=\"503. Next Greater Element II\"></a><a href=\"https://leetcode-cn.com/problems/next-greater-element-ii/\">503. Next Greater Element II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>单调栈！比较更大值的神。</p>\n<p>遍历数组维护单调栈，在排除栈中更小的元素时，就已经为他们找到了更大值。为了保证数组是环形查找的，可以插入两次数组元素。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; bigger(n, -1);\n        stack&lt;pair&lt;int, int&gt;&gt; sta;\n        for(int i &#x3D; 0; i &lt; 2; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                while(sta.size() &amp;&amp; sta.top().second &lt;nums[j])&#123;\n                    auto [pos, num] &#x3D; sta.top();\n                    sta.pop();\n                    if(bigger[pos] &#x3D;&#x3D; -1 )bigger[pos] &#x3D; nums[j];\n                &#125;\n                sta.push(&#123;j, nums[j]&#125;);\n            &#125;\n        &#125;\n        return bigger;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"EDGPJT","excerpt":"<h2 id=\"503-Next-Greater-Element-II\"><a href=\"#503-Next-Greater-Element-II\" class=\"headerlink\" title=\"503. Next Greater Element II\"></a><a href=\"https://leetcode-cn.com/problems/next-greater-element-ii/\">503. Next Greater Element II</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>单调栈！比较更大值的神。</p>\n<p>遍历数组维护单调栈，在排除栈中更小的元素时，就已经为他们找到了更大值。为了保证数组是环形查找的，可以插入两次数组元素。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        vector&lt;int&gt; bigger(n, -1);\n        stack&lt;pair&lt;int, int&gt;&gt; sta;\n        for(int i &#x3D; 0; i &lt; 2; ++i)&#123;\n            for(int j &#x3D; 0; j &lt; n; ++j)&#123;\n                while(sta.size() &amp;&amp; sta.top().second &lt;nums[j])&#123;\n                    auto [pos, num] &#x3D; sta.top();\n                    sta.pop();\n                    if(bigger[pos] &#x3D;&#x3D; -1 )bigger[pos] &#x3D; nums[j];\n                &#125;\n                sta.push(&#123;j, nums[j]&#125;);\n            &#125;\n        &#125;\n        return bigger;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"98. Validate Binary Search Tree","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-04-22T07:56:21.000Z","_content":"\n# [98. Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n\n\n## 思路：\n\n不要把二叉树的性质搞错了，是任一个节点的值大于其**所有**左节点的值，小于等于**所有**右节点的值，而非左节点。\n\n如此直接验证所有节点的是否大于左子树的最大值，小于右子树的最小值即可。\n\n<!-- more -->\n\n## 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// class Solution {\n// public:\n//     bool isValidBST(TreeNode* root) {\n//         if(!root) return true;\n//         bool flag = (root->right ? (root->val < root->right->val) : true) \n//                     && (root->left ? (root->val > root->left->val) : true);\n        \n//         return flag && isValidBST(root->right) && isValidBST(root->left);\n//     }\n// };\n\nclass Solution {\npublic:\n    inline TreeNode* minNode(TreeNode* root){\n        while(root->left) root = root->left;\n        return root;\n    }\n\n    inline TreeNode* maxNode(TreeNode* root){\n        while(root->right) root = root->right;\n        return root;\n    }\n    \n    bool isValidBST(TreeNode* root) {\n        if(!root) return true;\n        bool flag = (root->right ? (root->val < minNode(root->right)->val) : true) \n                    && (root->left ? (root->val > maxNode(root->left)->val) : true);\n        \n        return flag && isValidBST(root->right) && isValidBST(root->left);\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/栈和队列/98-Validate-Binary-Search-Tree.md","raw":"---\ntitle: 98. Validate Binary Search Tree\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-04-22 15:56:21\ntags:\ncategories:\n---\n\n# [98. Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n\n\n## 思路：\n\n不要把二叉树的性质搞错了，是任一个节点的值大于其**所有**左节点的值，小于等于**所有**右节点的值，而非左节点。\n\n如此直接验证所有节点的是否大于左子树的最大值，小于右子树的最小值即可。\n\n<!-- more -->\n\n## 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n// class Solution {\n// public:\n//     bool isValidBST(TreeNode* root) {\n//         if(!root) return true;\n//         bool flag = (root->right ? (root->val < root->right->val) : true) \n//                     && (root->left ? (root->val > root->left->val) : true);\n        \n//         return flag && isValidBST(root->right) && isValidBST(root->left);\n//     }\n// };\n\nclass Solution {\npublic:\n    inline TreeNode* minNode(TreeNode* root){\n        while(root->left) root = root->left;\n        return root;\n    }\n\n    inline TreeNode* maxNode(TreeNode* root){\n        while(root->right) root = root->right;\n        return root;\n    }\n    \n    bool isValidBST(TreeNode* root) {\n        if(!root) return true;\n        bool flag = (root->right ? (root->val < minNode(root->right)->val) : true) \n                    && (root->left ? (root->val > maxNode(root->left)->val) : true);\n        \n        return flag && isValidBST(root->right) && isValidBST(root->left);\n    }\n};\n```\n\n","slug":"刷题/数据结构/栈和队列/98-Validate-Binary-Search-Tree","published":1,"updated":"2021-04-22T08:03:03.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j770059l5uo3rood1mo","content":"<h1 id=\"98-Validate-Binary-Search-Tree\"><a href=\"#98-Validate-Binary-Search-Tree\" class=\"headerlink\" title=\"98. Validate Binary Search Tree\"></a><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">98. Validate Binary Search Tree</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>不要把二叉树的性质搞错了，是任一个节点的值大于其<strong>所有</strong>左节点的值，小于等于<strong>所有</strong>右节点的值，而非左节点。</p>\n<p>如此直接验证所有节点的是否大于左子树的最大值，小于右子树的最小值即可。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n&#x2F;&#x2F;     bool isValidBST(TreeNode* root) &#123;\n&#x2F;&#x2F;         if(!root) return true;\n&#x2F;&#x2F;         bool flag &#x3D; (root-&gt;right ? (root-&gt;val &lt; root-&gt;right-&gt;val) : true) \n&#x2F;&#x2F;                     &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; root-&gt;left-&gt;val) : true);\n        \n&#x2F;&#x2F;         return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left);\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\nclass Solution &#123;\npublic:\n    inline TreeNode* minNode(TreeNode* root)&#123;\n        while(root-&gt;left) root &#x3D; root-&gt;left;\n        return root;\n    &#125;\n\n    inline TreeNode* maxNode(TreeNode* root)&#123;\n        while(root-&gt;right) root &#x3D; root-&gt;right;\n        return root;\n    &#125;\n    \n    bool isValidBST(TreeNode* root) &#123;\n        if(!root) return true;\n        bool flag &#x3D; (root-&gt;right ? (root-&gt;val &lt; minNode(root-&gt;right)-&gt;val) : true) \n                    &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; maxNode(root-&gt;left)-&gt;val) : true);\n        \n        return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"32YW3D0","excerpt":"<h1 id=\"98-Validate-Binary-Search-Tree\"><a href=\"#98-Validate-Binary-Search-Tree\" class=\"headerlink\" title=\"98. Validate Binary Search Tree\"></a><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">98. Validate Binary Search Tree</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>不要把二叉树的性质搞错了，是任一个节点的值大于其<strong>所有</strong>左节点的值，小于等于<strong>所有</strong>右节点的值，而非左节点。</p>\n<p>如此直接验证所有节点的是否大于左子树的最大值，小于右子树的最小值即可。</p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\n&#x2F;&#x2F; class Solution &#123;\n&#x2F;&#x2F; public:\n&#x2F;&#x2F;     bool isValidBST(TreeNode* root) &#123;\n&#x2F;&#x2F;         if(!root) return true;\n&#x2F;&#x2F;         bool flag &#x3D; (root-&gt;right ? (root-&gt;val &lt; root-&gt;right-&gt;val) : true) \n&#x2F;&#x2F;                     &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; root-&gt;left-&gt;val) : true);\n        \n&#x2F;&#x2F;         return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left);\n&#x2F;&#x2F;     &#125;\n&#x2F;&#x2F; &#125;;\n\nclass Solution &#123;\npublic:\n    inline TreeNode* minNode(TreeNode* root)&#123;\n        while(root-&gt;left) root &#x3D; root-&gt;left;\n        return root;\n    &#125;\n\n    inline TreeNode* maxNode(TreeNode* root)&#123;\n        while(root-&gt;right) root &#x3D; root-&gt;right;\n        return root;\n    &#125;\n    \n    bool isValidBST(TreeNode* root) &#123;\n        if(!root) return true;\n        bool flag &#x3D; (root-&gt;right ? (root-&gt;val &lt; minNode(root-&gt;right)-&gt;val) : true) \n                    &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; maxNode(root-&gt;left)-&gt;val) : true);\n        \n        return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题-栈和队列","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:32:06.000Z","_content":"\n\n\n收集了栈和队列相关题目。\n\n\n\n## 面试9：两个栈实现队列\n\n<!-- more -->\n\n\n\n### 题面：\n\n如题\n\n### 思路：\n\n栈是FILO结构，将两个栈的结合起来就可以达到FIFO的效果。\n\n### 代码：\n\n```\ntemplate <typename T> class CQueue\n{\n    public:\n    \tCQueue(void);\n    \t~CQueue(void);\n    void appendTail(const T& node){\n        stack2.push(node);\n    }\n   \tT deleteHead(){\n        if(stack1.empty()){\n            while(!stack2.empty()){\n                stack1.push(stack2.top());\n                stack2.pop();\n            }\n        }\n        //弹空栈应抛出异常\n        if(stack1.empty()) \n            throw new exception(\"queue is empty.\");\n\n        T topValue = stack1.top();\n        stack1.pop();\n        return topValue;        \n    }\n    private:\n    \tstack<T> stack1, stack2;\n}\n```\n\n## 面试题9相关题：两个队列实现栈\n\n```\n//思考了一下只能用一个队列循序存储数据，在插入操作时直接插入。删除时把一个队列的除了最后一个其他数据顺序放到临时存储队列，最后删除最后一个数据。\n```\n\n## 包含min函数的栈\n\n### 题面：\n\n给定栈的数据结构，要求实现对栈的操作min，push，pop，并且复杂度为O(1)O(1)。\n\n### 思路：\n\n这题的难度不在于思维，而在于一种思想。为了保持栈FILO的特性，必须有一个栈负责存储原数据。但是如何实现min？一开始的想法是维护一个递增的栈，但是明显的复杂度高，且不易维护。简单如我没有想到可以直接维护一个**每一个元素都代表着当前被压入栈时的栈的最小值**的**状态栈**。也就是说在数据压入栈的时候求出之前记录的最小值和被压入元素的最小值，然后压入状态栈。pop的时候也很简单，直接两个栈都pop就ok。\n\n可以这么做的理由，是栈的min值是与将来无关的，仅与过去有关，换句话说就是状态值仅与当前栈的内容有关。\n\n好优雅。\n\n```\nclass StackMin{\n    private:\n    \tstack<int> s, sMin;\n    public:\n    void push(int x){\n        if(sMin.size() > 0)\n            sMin.push(min(x, sMin.top()));\n        else sMin.push(x);\n        s.push(x);\n    }\n    void pop(){\n        if(sMin.size() == 0) return;\n        sMin.pop();\n        s.pop();\n    }\n    int min(){\n        if(sMin.size() > 0) \n\t        return sMin.top();\n        else \n            throw new exception();\n    }\n}\n```\n\n> 错误：没有检查栈的元素数量。\n\n## 面31：合法的栈的弹出序列\n\n### 题面：\n\n给出一个按增序的数字序列`1，2，3，4……`压入栈的序列， 同时给出一个对应数字的弹出序列，判断弹出序列是否是压入序列的弹出序列。\n\n### 思路：\n\n不考虑数据的错误输入的话。一个简单而自然的思路就是模拟，建立一个辅助栈。对于弹出序列的当前数据，如果比栈顶数据大或者栈没有数据，则压入数据，直到栈顶和当前弹出序列的值一样大。如果等于栈顶数据，弹出栈顶。如果比栈顶数据小，则序列错误。如果正常运行结束则序列正确。\n\n> 不太容易讲清楚，最好举个例子。\n>\n> 想了一丢丢，终于讲清楚了。重点在于判断模拟过程的条件需要缕清。\n\n### 样例：\n\n```\ntrue:\n1,2,3\n1,2,3\n\n1,2,3\n3,2,1\n\n1,2,3\n3,1,2\n\n1,2,3,4,5,6\n3,4,2,5,1,6\n\n1,2,3,4,5,6\n3,4,2,6,1,5\n```\n\n### 代码：\n\n```\nbool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop){\n    stack<int> s;\n    int pushMax = 0;\n    if(lenPush != lenPop) return false;\n    for(int i = 0; i < lenPush; i++){\n        if(s.empty() || aPush[i] > s.top()){\n            int k = pushMax + 1;\n            while(k <= aPush[i]){\n                s.push(k);\n                k++;\n            }\n            pushMax = k - 1;\n        }\n        if(s.top() == aPush[i]){\n            s.pop();                       \n        }else{\n            return false;\n        }\n        \n    }\n    return true;\n}\n```\n\n\n\n## 面59 题二：队列的最大值\n\n### 题面：\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。\n\n若队列为空，pop_front 和 max_value 需要返回 -1\n\n\n### 思路：\n\n第一种肯定会想到把一个队列拆成两个栈来做；第二种比较巧妙，通过分析滑动窗口内元素最大值的变化，可以写出类似的如下代码。\n具体思路，是用双头队列维护队列最大值。\n### 代码：\n```c++\nclass MaxQueue {\npublic:\n    deque<int> value;\n    deque<int> maxValue;\n\n    MaxQueue() {\n        value.clear();\n        maxValue.clear();\n    }\n    \n    int max_value() {\n        if(value.size() > 0){\n            return maxValue.front();\n        }\n        else \n           // throw new exception;\n           return -1;\n    }\n    \n    void push_back(int number) {\n        value.push_back(number);\n        \n        while(maxValue.size() > 0 && maxValue.back() < number){\n            maxValue.pop_back();\n        }        \n        maxValue.push_back(number);     \n    }\n    \n    int pop_front() {\n        if(value.size() > 0){\n            int popValue = value.front();\n            if(maxValue.front() == popValue){\n                maxValue.pop_front();\n            }\n            value.pop_front();\n            return popValue;\n        }else\n          //  throw new exception;\n          return -1;\n    }\n};\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue* obj = new MaxQueue();\n * int param_1 = obj->max_value();\n * obj->push_back(value);\n * int param_3 = obj->pop_front();\n */\n ```\n","source":"_posts/刷题/数据结构/栈和队列/面试题-栈和队列.md","raw":"---\ntitle: 面试题-栈和队列\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ncategories:\ndate: 2020-08-07 13:32:06\ntags:\n---\n\n\n\n收集了栈和队列相关题目。\n\n\n\n## 面试9：两个栈实现队列\n\n<!-- more -->\n\n\n\n### 题面：\n\n如题\n\n### 思路：\n\n栈是FILO结构，将两个栈的结合起来就可以达到FIFO的效果。\n\n### 代码：\n\n```\ntemplate <typename T> class CQueue\n{\n    public:\n    \tCQueue(void);\n    \t~CQueue(void);\n    void appendTail(const T& node){\n        stack2.push(node);\n    }\n   \tT deleteHead(){\n        if(stack1.empty()){\n            while(!stack2.empty()){\n                stack1.push(stack2.top());\n                stack2.pop();\n            }\n        }\n        //弹空栈应抛出异常\n        if(stack1.empty()) \n            throw new exception(\"queue is empty.\");\n\n        T topValue = stack1.top();\n        stack1.pop();\n        return topValue;        \n    }\n    private:\n    \tstack<T> stack1, stack2;\n}\n```\n\n## 面试题9相关题：两个队列实现栈\n\n```\n//思考了一下只能用一个队列循序存储数据，在插入操作时直接插入。删除时把一个队列的除了最后一个其他数据顺序放到临时存储队列，最后删除最后一个数据。\n```\n\n## 包含min函数的栈\n\n### 题面：\n\n给定栈的数据结构，要求实现对栈的操作min，push，pop，并且复杂度为O(1)O(1)。\n\n### 思路：\n\n这题的难度不在于思维，而在于一种思想。为了保持栈FILO的特性，必须有一个栈负责存储原数据。但是如何实现min？一开始的想法是维护一个递增的栈，但是明显的复杂度高，且不易维护。简单如我没有想到可以直接维护一个**每一个元素都代表着当前被压入栈时的栈的最小值**的**状态栈**。也就是说在数据压入栈的时候求出之前记录的最小值和被压入元素的最小值，然后压入状态栈。pop的时候也很简单，直接两个栈都pop就ok。\n\n可以这么做的理由，是栈的min值是与将来无关的，仅与过去有关，换句话说就是状态值仅与当前栈的内容有关。\n\n好优雅。\n\n```\nclass StackMin{\n    private:\n    \tstack<int> s, sMin;\n    public:\n    void push(int x){\n        if(sMin.size() > 0)\n            sMin.push(min(x, sMin.top()));\n        else sMin.push(x);\n        s.push(x);\n    }\n    void pop(){\n        if(sMin.size() == 0) return;\n        sMin.pop();\n        s.pop();\n    }\n    int min(){\n        if(sMin.size() > 0) \n\t        return sMin.top();\n        else \n            throw new exception();\n    }\n}\n```\n\n> 错误：没有检查栈的元素数量。\n\n## 面31：合法的栈的弹出序列\n\n### 题面：\n\n给出一个按增序的数字序列`1，2，3，4……`压入栈的序列， 同时给出一个对应数字的弹出序列，判断弹出序列是否是压入序列的弹出序列。\n\n### 思路：\n\n不考虑数据的错误输入的话。一个简单而自然的思路就是模拟，建立一个辅助栈。对于弹出序列的当前数据，如果比栈顶数据大或者栈没有数据，则压入数据，直到栈顶和当前弹出序列的值一样大。如果等于栈顶数据，弹出栈顶。如果比栈顶数据小，则序列错误。如果正常运行结束则序列正确。\n\n> 不太容易讲清楚，最好举个例子。\n>\n> 想了一丢丢，终于讲清楚了。重点在于判断模拟过程的条件需要缕清。\n\n### 样例：\n\n```\ntrue:\n1,2,3\n1,2,3\n\n1,2,3\n3,2,1\n\n1,2,3\n3,1,2\n\n1,2,3,4,5,6\n3,4,2,5,1,6\n\n1,2,3,4,5,6\n3,4,2,6,1,5\n```\n\n### 代码：\n\n```\nbool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop){\n    stack<int> s;\n    int pushMax = 0;\n    if(lenPush != lenPop) return false;\n    for(int i = 0; i < lenPush; i++){\n        if(s.empty() || aPush[i] > s.top()){\n            int k = pushMax + 1;\n            while(k <= aPush[i]){\n                s.push(k);\n                k++;\n            }\n            pushMax = k - 1;\n        }\n        if(s.top() == aPush[i]){\n            s.pop();                       \n        }else{\n            return false;\n        }\n        \n    }\n    return true;\n}\n```\n\n\n\n## 面59 题二：队列的最大值\n\n### 题面：\n\n请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。\n\n若队列为空，pop_front 和 max_value 需要返回 -1\n\n\n### 思路：\n\n第一种肯定会想到把一个队列拆成两个栈来做；第二种比较巧妙，通过分析滑动窗口内元素最大值的变化，可以写出类似的如下代码。\n具体思路，是用双头队列维护队列最大值。\n### 代码：\n```c++\nclass MaxQueue {\npublic:\n    deque<int> value;\n    deque<int> maxValue;\n\n    MaxQueue() {\n        value.clear();\n        maxValue.clear();\n    }\n    \n    int max_value() {\n        if(value.size() > 0){\n            return maxValue.front();\n        }\n        else \n           // throw new exception;\n           return -1;\n    }\n    \n    void push_back(int number) {\n        value.push_back(number);\n        \n        while(maxValue.size() > 0 && maxValue.back() < number){\n            maxValue.pop_back();\n        }        \n        maxValue.push_back(number);     \n    }\n    \n    int pop_front() {\n        if(value.size() > 0){\n            int popValue = value.front();\n            if(maxValue.front() == popValue){\n                maxValue.pop_front();\n            }\n            value.pop_front();\n            return popValue;\n        }else\n          //  throw new exception;\n          return -1;\n    }\n};\n\n/**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue* obj = new MaxQueue();\n * int param_1 = obj->max_value();\n * obj->push_back(value);\n * int param_3 = obj->pop_front();\n */\n ```\n","slug":"刷题/数据结构/栈和队列/面试题-栈和队列","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j77005al5uo5aahchgt","content":"<p>收集了栈和队列相关题目。</p>\n<h2 id=\"面试9：两个栈实现队列\"><a href=\"#面试9：两个栈实现队列\" class=\"headerlink\" title=\"面试9：两个栈实现队列\"></a>面试9：两个栈实现队列</h2><span id=\"more\"></span>\n\n\n\n<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>栈是FILO结构，将两个栈的结合起来就可以达到FIFO的效果。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">template &lt;typename T&gt; class CQueue\n&#123;\n    public:\n    \tCQueue(void);\n    \t~CQueue(void);\n    void appendTail(const T&amp; node)&#123;\n        stack2.push(node);\n    &#125;\n   \tT deleteHead()&#123;\n        if(stack1.empty())&#123;\n            while(!stack2.empty())&#123;\n                stack1.push(stack2.top());\n                stack2.pop();\n            &#125;\n        &#125;\n        &#x2F;&#x2F;弹空栈应抛出异常\n        if(stack1.empty()) \n            throw new exception(&quot;queue is empty.&quot;);\n\n        T topValue &#x3D; stack1.top();\n        stack1.pop();\n        return topValue;        \n    &#125;\n    private:\n    \tstack&lt;T&gt; stack1, stack2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面试题9相关题：两个队列实现栈\"><a href=\"#面试题9相关题：两个队列实现栈\" class=\"headerlink\" title=\"面试题9相关题：两个队列实现栈\"></a>面试题9相关题：两个队列实现栈</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;思考了一下只能用一个队列循序存储数据，在插入操作时直接插入。删除时把一个队列的除了最后一个其他数据顺序放到临时存储队列，最后删除最后一个数据。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"包含min函数的栈\"><a href=\"#包含min函数的栈\" class=\"headerlink\" title=\"包含min函数的栈\"></a>包含min函数的栈</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给定栈的数据结构，要求实现对栈的操作min，push，pop，并且复杂度为O(1)O(1)。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>这题的难度不在于思维，而在于一种思想。为了保持栈FILO的特性，必须有一个栈负责存储原数据。但是如何实现min？一开始的想法是维护一个递增的栈，但是明显的复杂度高，且不易维护。简单如我没有想到可以直接维护一个<strong>每一个元素都代表着当前被压入栈时的栈的最小值</strong>的<strong>状态栈</strong>。也就是说在数据压入栈的时候求出之前记录的最小值和被压入元素的最小值，然后压入状态栈。pop的时候也很简单，直接两个栈都pop就ok。</p>\n<p>可以这么做的理由，是栈的min值是与将来无关的，仅与过去有关，换句话说就是状态值仅与当前栈的内容有关。</p>\n<p>好优雅。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class StackMin&#123;\n    private:\n    \tstack&lt;int&gt; s, sMin;\n    public:\n    void push(int x)&#123;\n        if(sMin.size() &gt; 0)\n            sMin.push(min(x, sMin.top()));\n        else sMin.push(x);\n        s.push(x);\n    &#125;\n    void pop()&#123;\n        if(sMin.size() &#x3D;&#x3D; 0) return;\n        sMin.pop();\n        s.pop();\n    &#125;\n    int min()&#123;\n        if(sMin.size() &gt; 0) \n\t        return sMin.top();\n        else \n            throw new exception();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>错误：没有检查栈的元素数量。</p>\n</blockquote>\n<h2 id=\"面31：合法的栈的弹出序列\"><a href=\"#面31：合法的栈的弹出序列\" class=\"headerlink\" title=\"面31：合法的栈的弹出序列\"></a>面31：合法的栈的弹出序列</h2><h3 id=\"题面：-2\"><a href=\"#题面：-2\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个按增序的数字序列<code>1，2，3，4……</code>压入栈的序列， 同时给出一个对应数字的弹出序列，判断弹出序列是否是压入序列的弹出序列。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>不考虑数据的错误输入的话。一个简单而自然的思路就是模拟，建立一个辅助栈。对于弹出序列的当前数据，如果比栈顶数据大或者栈没有数据，则压入数据，直到栈顶和当前弹出序列的值一样大。如果等于栈顶数据，弹出栈顶。如果比栈顶数据小，则序列错误。如果正常运行结束则序列正确。</p>\n<blockquote>\n<p>不太容易讲清楚，最好举个例子。</p>\n<p>想了一丢丢，终于讲清楚了。重点在于判断模拟过程的条件需要缕清。</p>\n</blockquote>\n<h3 id=\"样例：\"><a href=\"#样例：\" class=\"headerlink\" title=\"样例：\"></a>样例：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">true:\n1,2,3\n1,2,3\n\n1,2,3\n3,2,1\n\n1,2,3\n3,1,2\n\n1,2,3,4,5,6\n3,4,2,5,1,6\n\n1,2,3,4,5,6\n3,4,2,6,1,5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop)&#123;\n    stack&lt;int&gt; s;\n    int pushMax &#x3D; 0;\n    if(lenPush !&#x3D; lenPop) return false;\n    for(int i &#x3D; 0; i &lt; lenPush; i++)&#123;\n        if(s.empty() || aPush[i] &gt; s.top())&#123;\n            int k &#x3D; pushMax + 1;\n            while(k &lt;&#x3D; aPush[i])&#123;\n                s.push(k);\n                k++;\n            &#125;\n            pushMax &#x3D; k - 1;\n        &#125;\n        if(s.top() &#x3D;&#x3D; aPush[i])&#123;\n            s.pop();                       \n        &#125;else&#123;\n            return false;\n        &#125;\n        \n    &#125;\n    return true;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"面59-题二：队列的最大值\"><a href=\"#面59-题二：队列的最大值\" class=\"headerlink\" title=\"面59 题二：队列的最大值\"></a>面59 题二：队列的最大值</h2><h3 id=\"题面：-3\"><a href=\"#题面：-3\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>\n<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种肯定会想到把一个队列拆成两个栈来做；第二种比较巧妙，通过分析滑动窗口内元素最大值的变化，可以写出类似的如下代码。<br>具体思路，是用双头队列维护队列最大值。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MaxQueue &#123;\npublic:\n    deque&lt;int&gt; value;\n    deque&lt;int&gt; maxValue;\n\n    MaxQueue() &#123;\n        value.clear();\n        maxValue.clear();\n    &#125;\n    \n    int max_value() &#123;\n        if(value.size() &gt; 0)&#123;\n            return maxValue.front();\n        &#125;\n        else \n           &#x2F;&#x2F; throw new exception;\n           return -1;\n    &#125;\n    \n    void push_back(int number) &#123;\n        value.push_back(number);\n        \n        while(maxValue.size() &gt; 0 &amp;&amp; maxValue.back() &lt; number)&#123;\n            maxValue.pop_back();\n        &#125;        \n        maxValue.push_back(number);     \n    &#125;\n    \n    int pop_front() &#123;\n        if(value.size() &gt; 0)&#123;\n            int popValue &#x3D; value.front();\n            if(maxValue.front() &#x3D;&#x3D; popValue)&#123;\n                maxValue.pop_front();\n            &#125;\n            value.pop_front();\n            return popValue;\n        &#125;else\n          &#x2F;&#x2F;  throw new exception;\n          return -1;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue* obj &#x3D; new MaxQueue();\n * int param_1 &#x3D; obj-&gt;max_value();\n * obj-&gt;push_back(value);\n * int param_3 &#x3D; obj-&gt;pop_front();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"abbrlink":"33NSYY2","excerpt":"<p>收集了栈和队列相关题目。</p>\n<h2 id=\"面试9：两个栈实现队列\"><a href=\"#面试9：两个栈实现队列\" class=\"headerlink\" title=\"面试9：两个栈实现队列\"></a>面试9：两个栈实现队列</h2>","more":"<h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>栈是FILO结构，将两个栈的结合起来就可以达到FIFO的效果。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">template &lt;typename T&gt; class CQueue\n&#123;\n    public:\n    \tCQueue(void);\n    \t~CQueue(void);\n    void appendTail(const T&amp; node)&#123;\n        stack2.push(node);\n    &#125;\n   \tT deleteHead()&#123;\n        if(stack1.empty())&#123;\n            while(!stack2.empty())&#123;\n                stack1.push(stack2.top());\n                stack2.pop();\n            &#125;\n        &#125;\n        &#x2F;&#x2F;弹空栈应抛出异常\n        if(stack1.empty()) \n            throw new exception(&quot;queue is empty.&quot;);\n\n        T topValue &#x3D; stack1.top();\n        stack1.pop();\n        return topValue;        \n    &#125;\n    private:\n    \tstack&lt;T&gt; stack1, stack2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面试题9相关题：两个队列实现栈\"><a href=\"#面试题9相关题：两个队列实现栈\" class=\"headerlink\" title=\"面试题9相关题：两个队列实现栈\"></a>面试题9相关题：两个队列实现栈</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;思考了一下只能用一个队列循序存储数据，在插入操作时直接插入。删除时把一个队列的除了最后一个其他数据顺序放到临时存储队列，最后删除最后一个数据。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"包含min函数的栈\"><a href=\"#包含min函数的栈\" class=\"headerlink\" title=\"包含min函数的栈\"></a>包含min函数的栈</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给定栈的数据结构，要求实现对栈的操作min，push，pop，并且复杂度为O(1)O(1)。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>这题的难度不在于思维，而在于一种思想。为了保持栈FILO的特性，必须有一个栈负责存储原数据。但是如何实现min？一开始的想法是维护一个递增的栈，但是明显的复杂度高，且不易维护。简单如我没有想到可以直接维护一个<strong>每一个元素都代表着当前被压入栈时的栈的最小值</strong>的<strong>状态栈</strong>。也就是说在数据压入栈的时候求出之前记录的最小值和被压入元素的最小值，然后压入状态栈。pop的时候也很简单，直接两个栈都pop就ok。</p>\n<p>可以这么做的理由，是栈的min值是与将来无关的，仅与过去有关，换句话说就是状态值仅与当前栈的内容有关。</p>\n<p>好优雅。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class StackMin&#123;\n    private:\n    \tstack&lt;int&gt; s, sMin;\n    public:\n    void push(int x)&#123;\n        if(sMin.size() &gt; 0)\n            sMin.push(min(x, sMin.top()));\n        else sMin.push(x);\n        s.push(x);\n    &#125;\n    void pop()&#123;\n        if(sMin.size() &#x3D;&#x3D; 0) return;\n        sMin.pop();\n        s.pop();\n    &#125;\n    int min()&#123;\n        if(sMin.size() &gt; 0) \n\t        return sMin.top();\n        else \n            throw new exception();\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>错误：没有检查栈的元素数量。</p>\n</blockquote>\n<h2 id=\"面31：合法的栈的弹出序列\"><a href=\"#面31：合法的栈的弹出序列\" class=\"headerlink\" title=\"面31：合法的栈的弹出序列\"></a>面31：合法的栈的弹出序列</h2><h3 id=\"题面：-2\"><a href=\"#题面：-2\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个按增序的数字序列<code>1，2，3，4……</code>压入栈的序列， 同时给出一个对应数字的弹出序列，判断弹出序列是否是压入序列的弹出序列。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>不考虑数据的错误输入的话。一个简单而自然的思路就是模拟，建立一个辅助栈。对于弹出序列的当前数据，如果比栈顶数据大或者栈没有数据，则压入数据，直到栈顶和当前弹出序列的值一样大。如果等于栈顶数据，弹出栈顶。如果比栈顶数据小，则序列错误。如果正常运行结束则序列正确。</p>\n<blockquote>\n<p>不太容易讲清楚，最好举个例子。</p>\n<p>想了一丢丢，终于讲清楚了。重点在于判断模拟过程的条件需要缕清。</p>\n</blockquote>\n<h3 id=\"样例：\"><a href=\"#样例：\" class=\"headerlink\" title=\"样例：\"></a>样例：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">true:\n1,2,3\n1,2,3\n\n1,2,3\n3,2,1\n\n1,2,3\n3,1,2\n\n1,2,3,4,5,6\n3,4,2,5,1,6\n\n1,2,3,4,5,6\n3,4,2,6,1,5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop)&#123;\n    stack&lt;int&gt; s;\n    int pushMax &#x3D; 0;\n    if(lenPush !&#x3D; lenPop) return false;\n    for(int i &#x3D; 0; i &lt; lenPush; i++)&#123;\n        if(s.empty() || aPush[i] &gt; s.top())&#123;\n            int k &#x3D; pushMax + 1;\n            while(k &lt;&#x3D; aPush[i])&#123;\n                s.push(k);\n                k++;\n            &#125;\n            pushMax &#x3D; k - 1;\n        &#125;\n        if(s.top() &#x3D;&#x3D; aPush[i])&#123;\n            s.pop();                       \n        &#125;else&#123;\n            return false;\n        &#125;\n        \n    &#125;\n    return true;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"面59-题二：队列的最大值\"><a href=\"#面59-题二：队列的最大值\" class=\"headerlink\" title=\"面59 题二：队列的最大值\"></a>面59 题二：队列的最大值</h2><h3 id=\"题面：-3\"><a href=\"#题面：-3\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>\n<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>第一种肯定会想到把一个队列拆成两个栈来做；第二种比较巧妙，通过分析滑动窗口内元素最大值的变化，可以写出类似的如下代码。<br>具体思路，是用双头队列维护队列最大值。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class MaxQueue &#123;\npublic:\n    deque&lt;int&gt; value;\n    deque&lt;int&gt; maxValue;\n\n    MaxQueue() &#123;\n        value.clear();\n        maxValue.clear();\n    &#125;\n    \n    int max_value() &#123;\n        if(value.size() &gt; 0)&#123;\n            return maxValue.front();\n        &#125;\n        else \n           &#x2F;&#x2F; throw new exception;\n           return -1;\n    &#125;\n    \n    void push_back(int number) &#123;\n        value.push_back(number);\n        \n        while(maxValue.size() &gt; 0 &amp;&amp; maxValue.back() &lt; number)&#123;\n            maxValue.pop_back();\n        &#125;        \n        maxValue.push_back(number);     \n    &#125;\n    \n    int pop_front() &#123;\n        if(value.size() &gt; 0)&#123;\n            int popValue &#x3D; value.front();\n            if(maxValue.front() &#x3D;&#x3D; popValue)&#123;\n                maxValue.pop_front();\n            &#125;\n            value.pop_front();\n            return popValue;\n        &#125;else\n          &#x2F;&#x2F;  throw new exception;\n          return -1;\n    &#125;\n&#125;;\n\n&#x2F;**\n * Your MaxQueue object will be instantiated and called as such:\n * MaxQueue* obj &#x3D; new MaxQueue();\n * int param_1 &#x3D; obj-&gt;max_value();\n * obj-&gt;push_back(value);\n * int param_3 &#x3D; obj-&gt;pop_front();\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"106. Construct Binary Tree from Inorder and Postorder Traversal","toc":true,"top":10,"date":"2020-09-25T00:24:07.000Z","_content":"\nhello world \n\n## [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n![img](http://static.come2rss.xyz/西班牙韦斯卡.jpg)\n\n<!-- more -->\n\n## 思路：\n\n递归的将中序遍历的序列分开，并建立中间节点的值\n\n## 代码：\n\n递归。\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n\n    TreeNode* buildTreeCore(vector<int>& inorder, vector<int>& postorder, int ins, int inend, int posts, int poste){\n        if(ins >= inend || posts >= poste) return NULL;\n\n        TreeNode *node = new TreeNode(postorder[poste - 1]);\n        int pos = ins;\n        while(inorder[pos] != postorder[poste - 1]){\n            pos++;\n        }\n        node->left = buildTreeCore(inorder, postorder, ins, pos, posts, posts + pos - ins);\n        node->right = buildTreeCore(inorder, postorder, pos + 1, inend, posts + pos - ins, poste - 1);\n        return node;\n\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n       return buildTreeCore(inorder, postorder, 0, inorder.size(), 0, postorder.size());\n    }\n};\n\n\n\n```\n\n","source":"_posts/刷题/数据结构/树/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.md","raw":"---\ntitle: 106. Construct Binary Tree from Inorder and Postorder Traversal\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-09-25 08:24:07\n---\n\nhello world \n\n## [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n![img](http://static.come2rss.xyz/西班牙韦斯卡.jpg)\n\n<!-- more -->\n\n## 思路：\n\n递归的将中序遍历的序列分开，并建立中间节点的值\n\n## 代码：\n\n递归。\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n\n    TreeNode* buildTreeCore(vector<int>& inorder, vector<int>& postorder, int ins, int inend, int posts, int poste){\n        if(ins >= inend || posts >= poste) return NULL;\n\n        TreeNode *node = new TreeNode(postorder[poste - 1]);\n        int pos = ins;\n        while(inorder[pos] != postorder[poste - 1]){\n            pos++;\n        }\n        node->left = buildTreeCore(inorder, postorder, ins, pos, posts, posts + pos - ins);\n        node->right = buildTreeCore(inorder, postorder, pos + 1, inend, posts + pos - ins, poste - 1);\n        return node;\n\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n       return buildTreeCore(inorder, postorder, 0, inorder.size(), 0, postorder.size());\n    }\n};\n\n\n\n```\n\n","slug":"刷题/数据结构/树/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j78005bl5uo5e00cnyo","content":"<p>hello world </p>\n<h2 id=\"106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\"><a href=\"#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\" class=\"headerlink\" title=\"106. Construct Binary Tree from Inorder and Postorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p><img src=\"http://static.come2rss.xyz/%E8%A5%BF%E7%8F%AD%E7%89%99%E9%9F%A6%E6%96%AF%E5%8D%A1.jpg\" alt=\"img\"></p>\n<span id=\"more\"></span>\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>递归的将中序遍历的序列分开，并建立中间节点的值</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>递归。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n\n    TreeNode* buildTreeCore(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int ins, int inend, int posts, int poste)&#123;\n        if(ins &gt;&#x3D; inend || posts &gt;&#x3D; poste) return NULL;\n\n        TreeNode *node &#x3D; new TreeNode(postorder[poste - 1]);\n        int pos &#x3D; ins;\n        while(inorder[pos] !&#x3D; postorder[poste - 1])&#123;\n            pos++;\n        &#125;\n        node-&gt;left &#x3D; buildTreeCore(inorder, postorder, ins, pos, posts, posts + pos - ins);\n        node-&gt;right &#x3D; buildTreeCore(inorder, postorder, pos + 1, inend, posts + pos - ins, poste - 1);\n        return node;\n\n    &#125;\n    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n       return buildTreeCore(inorder, postorder, 0, inorder.size(), 0, postorder.size());\n    &#125;\n&#125;;\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1QR2E38","excerpt":"<p>hello world </p>\n<h2 id=\"106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\"><a href=\"#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal\" class=\"headerlink\" title=\"106. Construct Binary Tree from Inorder and Postorder Traversal\"></a><a href=\"https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p><img src=\"http://static.come2rss.xyz/%E8%A5%BF%E7%8F%AD%E7%89%99%E9%9F%A6%E6%96%AF%E5%8D%A1.jpg\" alt=\"img\"></p>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>递归的将中序遍历的序列分开，并建立中间节点的值</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>递归。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n\n    TreeNode* buildTreeCore(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int ins, int inend, int posts, int poste)&#123;\n        if(ins &gt;&#x3D; inend || posts &gt;&#x3D; poste) return NULL;\n\n        TreeNode *node &#x3D; new TreeNode(postorder[poste - 1]);\n        int pos &#x3D; ins;\n        while(inorder[pos] !&#x3D; postorder[poste - 1])&#123;\n            pos++;\n        &#125;\n        node-&gt;left &#x3D; buildTreeCore(inorder, postorder, ins, pos, posts, posts + pos - ins);\n        node-&gt;right &#x3D; buildTreeCore(inorder, postorder, pos + 1, inend, posts + pos - ins, poste - 1);\n        return node;\n\n    &#125;\n    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;\n       return buildTreeCore(inorder, postorder, 0, inorder.size(), 0, postorder.size());\n    &#125;\n&#125;;\n\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"109. Convert Sorted List to Binary Search Tree","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-04T00:54:37.000Z","_content":"\n\n\n\n## 思路：\n\n链表实际上给出的是二叉树前序的结果，因为AVL树任意左右子树高度不超过1，我们可以选择链表中点，并将链表的长度尽可能一样长的两部分划分到左右子树，所以高度性质可以维持住。\n\n在中序遍历链表，控制子树长度，即可构建符合题意的AVL树。\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        int len = sizeOfList(head);\n        return sortedListToBSTCore(head, 0, len - 1);\n    }\n    \n    int sizeOfList(ListNode* head){\n        ListNode *p = head;\n        int len = 0;\n        while(p){\n            p = p->next;\n            ++len;\n        }\n        return len;\n    }\n    TreeNode* sortedListToBSTCore(ListNode* &head, int lhs, int rhs) {\n        if(lhs > rhs) return nullptr;\n        int mid = (lhs + rhs + 1) / 2;\n        TreeNode* lchild = sortedListToBSTCore(head, lhs, mid - 1);\n        TreeNode* root = new TreeNode(head->val);\n        head = head->next;\n        TreeNode* rchild = sortedListToBSTCore(head, mid + 1, rhs);\n        root->left = lchild;\n        root->right = rchild;\n        return root;\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/树/109-Convert-Sorted-List-to-Binary-Search-Tree.md","raw":"---\ntitle: 109. Convert Sorted List to Binary Search Tree\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-04 08:54:37\ntags:\ncategories:\n---\n\n\n\n\n## 思路：\n\n链表实际上给出的是二叉树前序的结果，因为AVL树任意左右子树高度不超过1，我们可以选择链表中点，并将链表的长度尽可能一样长的两部分划分到左右子树，所以高度性质可以维持住。\n\n在中序遍历链表，控制子树长度，即可构建符合题意的AVL树。\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        int len = sizeOfList(head);\n        return sortedListToBSTCore(head, 0, len - 1);\n    }\n    \n    int sizeOfList(ListNode* head){\n        ListNode *p = head;\n        int len = 0;\n        while(p){\n            p = p->next;\n            ++len;\n        }\n        return len;\n    }\n    TreeNode* sortedListToBSTCore(ListNode* &head, int lhs, int rhs) {\n        if(lhs > rhs) return nullptr;\n        int mid = (lhs + rhs + 1) / 2;\n        TreeNode* lchild = sortedListToBSTCore(head, lhs, mid - 1);\n        TreeNode* root = new TreeNode(head->val);\n        head = head->next;\n        TreeNode* rchild = sortedListToBSTCore(head, mid + 1, rhs);\n        root->left = lchild;\n        root->right = rchild;\n        return root;\n    }\n};\n```\n\n","slug":"刷题/数据结构/树/109-Convert-Sorted-List-to-Binary-Search-Tree","published":1,"updated":"2021-03-04T00:57:56.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7a005cl5uofsfi5aqk","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>链表实际上给出的是二叉树前序的结果，因为AVL树任意左右子树高度不超过1，我们可以选择链表中点，并将链表的长度尽可能一样长的两部分划分到左右子树，所以高度性质可以维持住。</p>\n<p>在中序遍历链表，控制子树长度，即可构建符合题意的AVL树。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* sortedListToBST(ListNode* head) &#123;\n        int len &#x3D; sizeOfList(head);\n        return sortedListToBSTCore(head, 0, len - 1);\n    &#125;\n    \n    int sizeOfList(ListNode* head)&#123;\n        ListNode *p &#x3D; head;\n        int len &#x3D; 0;\n        while(p)&#123;\n            p &#x3D; p-&gt;next;\n            ++len;\n        &#125;\n        return len;\n    &#125;\n    TreeNode* sortedListToBSTCore(ListNode* &amp;head, int lhs, int rhs) &#123;\n        if(lhs &gt; rhs) return nullptr;\n        int mid &#x3D; (lhs + rhs + 1) &#x2F; 2;\n        TreeNode* lchild &#x3D; sortedListToBSTCore(head, lhs, mid - 1);\n        TreeNode* root &#x3D; new TreeNode(head-&gt;val);\n        head &#x3D; head-&gt;next;\n        TreeNode* rchild &#x3D; sortedListToBSTCore(head, mid + 1, rhs);\n        root-&gt;left &#x3D; lchild;\n        root-&gt;right &#x3D; rchild;\n        return root;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"AV6MQE","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>链表实际上给出的是二叉树前序的结果，因为AVL树任意左右子树高度不超过1，我们可以选择链表中点，并将链表的长度尽可能一样长的两部分划分到左右子树，所以高度性质可以维持住。</p>\n<p>在中序遍历链表，控制子树长度，即可构建符合题意的AVL树。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* sortedListToBST(ListNode* head) &#123;\n        int len &#x3D; sizeOfList(head);\n        return sortedListToBSTCore(head, 0, len - 1);\n    &#125;\n    \n    int sizeOfList(ListNode* head)&#123;\n        ListNode *p &#x3D; head;\n        int len &#x3D; 0;\n        while(p)&#123;\n            p &#x3D; p-&gt;next;\n            ++len;\n        &#125;\n        return len;\n    &#125;\n    TreeNode* sortedListToBSTCore(ListNode* &amp;head, int lhs, int rhs) &#123;\n        if(lhs &gt; rhs) return nullptr;\n        int mid &#x3D; (lhs + rhs + 1) &#x2F; 2;\n        TreeNode* lchild &#x3D; sortedListToBSTCore(head, lhs, mid - 1);\n        TreeNode* root &#x3D; new TreeNode(head-&gt;val);\n        head &#x3D; head-&gt;next;\n        TreeNode* rchild &#x3D; sortedListToBSTCore(head, mid + 1, rhs);\n        root-&gt;left &#x3D; lchild;\n        root-&gt;right &#x3D; rchild;\n        return root;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"1609. Even Odd Tree","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-10-18T05:22:57.000Z","_content":"\n\n<!-- more -->\n\n## 思路:\n\n层序遍历。记录边界即可。\n\n\n\n## 代码：\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    bool isEvenOddTree(TreeNode* root) {\n        if(root == nullptr ) return false;\n        queue<TreeNode *> que;\n        vector<int> a;\n        int level = 0, num = 1, nextn = 0;;\n        que.push(root);\n        while(!que.empty()){\n            TreeNode *t = que.front();\n            que.pop();\n            a.push_back(t->val);\n            num--;\n            if(t->left){\n                que.push(t->left);\n                nextn++;\n            }\n            if(t->right){\n                que.push(t->right);\n                nextn++;            \n            }            \n            if(num == 0){\n                num = nextn;\n                nextn = 0;\n                int flag = 1;\n                if(a.size() < 1) continue;\n\n                if(level & 1){\n                    for(int i = 1; i < a.size(); i++){\n                        if(a[i] >= a[i - 1] || a[i]%2 == 1 )\n                            flag = 0;\n                    }\n                    if(a[0]%2 == 1) flag = 0;\n                }\n                else{\n                    for(int i = 1; i < a.size(); i++){\n                        if(a[i] <= a[i - 1] || a[i]%2 == 0)\n                            flag = 0;\n                    }                \n                    if(a[0]%2 == 0) flag = 0;\n\n                }\n           \n                a.clear();\n                level ++;\n                if(!flag) return false;\n            }   \n        }\n        return true;\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/树/1609-Even-Odd-Tree.md","raw":"---\ntitle: 1609. Even Odd Tree\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-10-18 13:22:57\n---\n\n\n<!-- more -->\n\n## 思路:\n\n层序遍历。记录边界即可。\n\n\n\n## 代码：\n\n```c++\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    bool isEvenOddTree(TreeNode* root) {\n        if(root == nullptr ) return false;\n        queue<TreeNode *> que;\n        vector<int> a;\n        int level = 0, num = 1, nextn = 0;;\n        que.push(root);\n        while(!que.empty()){\n            TreeNode *t = que.front();\n            que.pop();\n            a.push_back(t->val);\n            num--;\n            if(t->left){\n                que.push(t->left);\n                nextn++;\n            }\n            if(t->right){\n                que.push(t->right);\n                nextn++;            \n            }            \n            if(num == 0){\n                num = nextn;\n                nextn = 0;\n                int flag = 1;\n                if(a.size() < 1) continue;\n\n                if(level & 1){\n                    for(int i = 1; i < a.size(); i++){\n                        if(a[i] >= a[i - 1] || a[i]%2 == 1 )\n                            flag = 0;\n                    }\n                    if(a[0]%2 == 1) flag = 0;\n                }\n                else{\n                    for(int i = 1; i < a.size(); i++){\n                        if(a[i] <= a[i - 1] || a[i]%2 == 0)\n                            flag = 0;\n                    }                \n                    if(a[0]%2 == 0) flag = 0;\n\n                }\n           \n                a.clear();\n                level ++;\n                if(!flag) return false;\n            }   \n        }\n        return true;\n    }\n};\n```\n\n","slug":"刷题/数据结构/树/1609-Even-Odd-Tree","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7a005dl5uob7hy3fc3","content":"<span id=\"more\"></span>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>层序遍历。记录边界即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    \n    bool isEvenOddTree(TreeNode* root) &#123;\n        if(root &#x3D;&#x3D; nullptr ) return false;\n        queue&lt;TreeNode *&gt; que;\n        vector&lt;int&gt; a;\n        int level &#x3D; 0, num &#x3D; 1, nextn &#x3D; 0;;\n        que.push(root);\n        while(!que.empty())&#123;\n            TreeNode *t &#x3D; que.front();\n            que.pop();\n            a.push_back(t-&gt;val);\n            num--;\n            if(t-&gt;left)&#123;\n                que.push(t-&gt;left);\n                nextn++;\n            &#125;\n            if(t-&gt;right)&#123;\n                que.push(t-&gt;right);\n                nextn++;            \n            &#125;            \n            if(num &#x3D;&#x3D; 0)&#123;\n                num &#x3D; nextn;\n                nextn &#x3D; 0;\n                int flag &#x3D; 1;\n                if(a.size() &lt; 1) continue;\n\n                if(level &amp; 1)&#123;\n                    for(int i &#x3D; 1; i &lt; a.size(); i++)&#123;\n                        if(a[i] &gt;&#x3D; a[i - 1] || a[i]%2 &#x3D;&#x3D; 1 )\n                            flag &#x3D; 0;\n                    &#125;\n                    if(a[0]%2 &#x3D;&#x3D; 1) flag &#x3D; 0;\n                &#125;\n                else&#123;\n                    for(int i &#x3D; 1; i &lt; a.size(); i++)&#123;\n                        if(a[i] &lt;&#x3D; a[i - 1] || a[i]%2 &#x3D;&#x3D; 0)\n                            flag &#x3D; 0;\n                    &#125;                \n                    if(a[0]%2 &#x3D;&#x3D; 0) flag &#x3D; 0;\n\n                &#125;\n           \n                a.clear();\n                level ++;\n                if(!flag) return false;\n            &#125;   \n        &#125;\n        return true;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"ADF75T","excerpt":"","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路:\"></a>思路:</h2><p>层序遍历。记录边界即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    \n    bool isEvenOddTree(TreeNode* root) &#123;\n        if(root &#x3D;&#x3D; nullptr ) return false;\n        queue&lt;TreeNode *&gt; que;\n        vector&lt;int&gt; a;\n        int level &#x3D; 0, num &#x3D; 1, nextn &#x3D; 0;;\n        que.push(root);\n        while(!que.empty())&#123;\n            TreeNode *t &#x3D; que.front();\n            que.pop();\n            a.push_back(t-&gt;val);\n            num--;\n            if(t-&gt;left)&#123;\n                que.push(t-&gt;left);\n                nextn++;\n            &#125;\n            if(t-&gt;right)&#123;\n                que.push(t-&gt;right);\n                nextn++;            \n            &#125;            \n            if(num &#x3D;&#x3D; 0)&#123;\n                num &#x3D; nextn;\n                nextn &#x3D; 0;\n                int flag &#x3D; 1;\n                if(a.size() &lt; 1) continue;\n\n                if(level &amp; 1)&#123;\n                    for(int i &#x3D; 1; i &lt; a.size(); i++)&#123;\n                        if(a[i] &gt;&#x3D; a[i - 1] || a[i]%2 &#x3D;&#x3D; 1 )\n                            flag &#x3D; 0;\n                    &#125;\n                    if(a[0]%2 &#x3D;&#x3D; 1) flag &#x3D; 0;\n                &#125;\n                else&#123;\n                    for(int i &#x3D; 1; i &lt; a.size(); i++)&#123;\n                        if(a[i] &lt;&#x3D; a[i - 1] || a[i]%2 &#x3D;&#x3D; 0)\n                            flag &#x3D; 0;\n                    &#125;                \n                    if(a[0]%2 &#x3D;&#x3D; 0) flag &#x3D; 0;\n\n                &#125;\n           \n                a.clear();\n                level ++;\n                if(!flag) return false;\n            &#125;   \n        &#125;\n        return true;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"235. Lowest Common Ancestor of a Binary Search Tree","thumbnail":"http://static.come2rss.xyz/温哥华东部的弗雷泽河.jpg","toc":true,"top":10,"date":"2020-09-27T03:37:57.000Z","_content":"\n## [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n<!-- more -->\n\n\n\n## 思路：\n\n搜索树的LCA比较简单，利于二分性质即可。\n\n## 代码：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root->val < min(p->val, q->val)){\n            return lowestCommonAncestor(root->right, p, q);\n        }else if(root->val > max(p->val, q->val) ){\n            return  lowestCommonAncestor(root->left, p, q);\n        }else{\n            return root;\n        }\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/树/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree.md","raw":"---\ntitle: 235. Lowest Common Ancestor of a Binary Search Tree\nthumbnail: 'http://static.come2rss.xyz/温哥华东部的弗雷泽河.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-09-27 11:37:57\n---\n\n## [235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n<!-- more -->\n\n\n\n## 思路：\n\n搜索树的LCA比较简单，利于二分性质即可。\n\n## 代码：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root->val < min(p->val, q->val)){\n            return lowestCommonAncestor(root->right, p, q);\n        }else if(root->val > max(p->val, q->val) ){\n            return  lowestCommonAncestor(root->left, p, q);\n        }else{\n            return root;\n        }\n    }\n};\n```\n\n","slug":"刷题/数据结构/树/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7b005el5uo2ztv8w0z","content":"<h2 id=\"235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree\"><a href=\"#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree\" class=\"headerlink\" title=\"235. Lowest Common Ancestor of a Binary Search Tree\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\">235. Lowest Common Ancestor of a Binary Search Tree</a></h2><span id=\"more\"></span>\n\n\n\n<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>搜索树的LCA比较简单，利于二分性质即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        if(root-&gt;val &lt; min(p-&gt;val, q-&gt;val))&#123;\n            return lowestCommonAncestor(root-&gt;right, p, q);\n        &#125;else if(root-&gt;val &gt; max(p-&gt;val, q-&gt;val) )&#123;\n            return  lowestCommonAncestor(root-&gt;left, p, q);\n        &#125;else&#123;\n            return root;\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1Q04C57","excerpt":"<h2 id=\"235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree\"><a href=\"#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree\" class=\"headerlink\" title=\"235. Lowest Common Ancestor of a Binary Search Tree\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\">235. Lowest Common Ancestor of a Binary Search Tree</a></h2>","more":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>搜索树的LCA比较简单，利于二分性质即可。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\n\nclass Solution &#123;\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        if(root-&gt;val &lt; min(p-&gt;val, q-&gt;val))&#123;\n            return lowestCommonAncestor(root-&gt;right, p, q);\n        &#125;else if(root-&gt;val &gt; max(p-&gt;val, q-&gt;val) )&#123;\n            return  lowestCommonAncestor(root-&gt;left, p, q);\n        &#125;else&#123;\n            return root;\n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"236. Lowest Common Ancestor of a Binary Tree","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-04T01:26:57.000Z","_content":"\n\n\n\n\n## 思路：\n\n1. 递归搜索，判断左右子树已经当前节点是否有`p`和`q`。\n2. 记录下父节点，转化为两条链表的公共子节点。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode *target;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        dfs(root, p, q);\n        return target;\n    }\n\n    int dfs(TreeNode* root, TreeNode* p, TreeNode* q){\n        if(!root) return 0;\n        int leftRes = dfs(root->left, p, q);\n        int rightRes = dfs(root->right, p, q);\n        int midRes = 0;\n        if(root == p) midRes = 1;\n        else if(root == q) midRes = 2;\n\n\n        if(!target && \n        (root == p && root == q || leftRes + rightRes + midRes == 3)) target = root;\n        \n        return leftRes + rightRes + midRes;\n    }\n};\n```\n\n\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode *target;\n    unordered_map<TreeNode*, TreeNode*> fa;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        dfs(root, nullptr);\n        TreeNode* p1 = p, *p2 = q;\n        while(p1 != p2){\n            p1 = fa[p1] ? fa[p1] : q;\n            p2 = fa[p2] ? fa[p2] : p;\n        }        \n        return p1;\n    }\n\n    void dfs(TreeNode* root, TreeNode* father){\n        if(!root) return;\n        fa[root] = father;\n        dfs(root->left, root);\n        dfs(root->right, root);\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/树/236-Lowest-Common-Ancestor-of-a-Binary-Tree.md","raw":"---\ntitle: 236. Lowest Common Ancestor of a Binary Tree\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-04 09:26:57\ntags:\ncategories:\n---\n\n\n\n\n\n## 思路：\n\n1. 递归搜索，判断左右子树已经当前节点是否有`p`和`q`。\n2. 记录下父节点，转化为两条链表的公共子节点。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode *target;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        dfs(root, p, q);\n        return target;\n    }\n\n    int dfs(TreeNode* root, TreeNode* p, TreeNode* q){\n        if(!root) return 0;\n        int leftRes = dfs(root->left, p, q);\n        int rightRes = dfs(root->right, p, q);\n        int midRes = 0;\n        if(root == p) midRes = 1;\n        else if(root == q) midRes = 2;\n\n\n        if(!target && \n        (root == p && root == q || leftRes + rightRes + midRes == 3)) target = root;\n        \n        return leftRes + rightRes + midRes;\n    }\n};\n```\n\n\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode *target;\n    unordered_map<TreeNode*, TreeNode*> fa;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        dfs(root, nullptr);\n        TreeNode* p1 = p, *p2 = q;\n        while(p1 != p2){\n            p1 = fa[p1] ? fa[p1] : q;\n            p2 = fa[p2] ? fa[p2] : p;\n        }        \n        return p1;\n    }\n\n    void dfs(TreeNode* root, TreeNode* father){\n        if(!root) return;\n        fa[root] = father;\n        dfs(root->left, root);\n        dfs(root->right, root);\n    }\n};\n```\n\n","slug":"刷题/数据结构/树/236-Lowest-Common-Ancestor-of-a-Binary-Tree","published":1,"updated":"2021-04-01T08:29:33.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7d005fl5uo4cwef6ps","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>递归搜索，判断左右子树已经当前节点是否有<code>p</code>和<code>q</code>。</li>\n<li>记录下父节点，转化为两条链表的公共子节点。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode *target;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        dfs(root, p, q);\n        return target;\n    &#125;\n\n    int dfs(TreeNode* root, TreeNode* p, TreeNode* q)&#123;\n        if(!root) return 0;\n        int leftRes &#x3D; dfs(root-&gt;left, p, q);\n        int rightRes &#x3D; dfs(root-&gt;right, p, q);\n        int midRes &#x3D; 0;\n        if(root &#x3D;&#x3D; p) midRes &#x3D; 1;\n        else if(root &#x3D;&#x3D; q) midRes &#x3D; 2;\n\n\n        if(!target &amp;&amp; \n        (root &#x3D;&#x3D; p &amp;&amp; root &#x3D;&#x3D; q || leftRes + rightRes + midRes &#x3D;&#x3D; 3)) target &#x3D; root;\n        \n        return leftRes + rightRes + midRes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode *target;\n    unordered_map&lt;TreeNode*, TreeNode*&gt; fa;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        dfs(root, nullptr);\n        TreeNode* p1 &#x3D; p, *p2 &#x3D; q;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; fa[p1] ? fa[p1] : q;\n            p2 &#x3D; fa[p2] ? fa[p2] : p;\n        &#125;        \n        return p1;\n    &#125;\n\n    void dfs(TreeNode* root, TreeNode* father)&#123;\n        if(!root) return;\n        fa[root] &#x3D; father;\n        dfs(root-&gt;left, root);\n        dfs(root-&gt;right, root);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3D14RGH","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>递归搜索，判断左右子树已经当前节点是否有<code>p</code>和<code>q</code>。</li>\n<li>记录下父节点，转化为两条链表的公共子节点。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode *target;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        dfs(root, p, q);\n        return target;\n    &#125;\n\n    int dfs(TreeNode* root, TreeNode* p, TreeNode* q)&#123;\n        if(!root) return 0;\n        int leftRes &#x3D; dfs(root-&gt;left, p, q);\n        int rightRes &#x3D; dfs(root-&gt;right, p, q);\n        int midRes &#x3D; 0;\n        if(root &#x3D;&#x3D; p) midRes &#x3D; 1;\n        else if(root &#x3D;&#x3D; q) midRes &#x3D; 2;\n\n\n        if(!target &amp;&amp; \n        (root &#x3D;&#x3D; p &amp;&amp; root &#x3D;&#x3D; q || leftRes + rightRes + midRes &#x3D;&#x3D; 3)) target &#x3D; root;\n        \n        return leftRes + rightRes + midRes;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode *target;\n    unordered_map&lt;TreeNode*, TreeNode*&gt; fa;\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;\n        dfs(root, nullptr);\n        TreeNode* p1 &#x3D; p, *p2 &#x3D; q;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; fa[p1] ? fa[p1] : q;\n            p2 &#x3D; fa[p2] ? fa[p2] : p;\n        &#125;        \n        return p1;\n    &#125;\n\n    void dfs(TreeNode* root, TreeNode* father)&#123;\n        if(!root) return;\n        fa[root] &#x3D; father;\n        dfs(root-&gt;left, root);\n        dfs(root-&gt;right, root);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"297. Serialize and Deserialize Binary Tree","thumbnail":"http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png","toc":true,"top":10,"date":"2021-04-26T00:27:55.000Z","_content":"\n# [297. Serialize and Deserialize Binary Tree](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n\n\n## 思路：\n\n对于二叉树序列化，leetcode已经给出了很好的示范。思考一下，完整前缀遍历（包括空节点信息）能否构建二叉树？可以，从根到子节点前缀遍历的同时构建二叉树。同理后缀也可以。\n\n<!-- more -->\n\n\n\n这里我采用层序遍历的方式，构建序列化和解序列化。\n\n下面的代码有一个小技巧，把`迭代器`的设计思想融入到代码里：把遍历的功能独立出来，只提供接口，以便快速判断有无剩余节点，该节点是否有效。\n\n\n\n\n\n## 代码：\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\n    string ser;\n    int pos; // decoded pos.\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n    \n        queue<TreeNode*> que;\n        que.push(root);\n\n        while(que.size()){\n            TreeNode* pnode = que.front();\n            que.pop();\n            if(pnode){\n                ser += to_string(pnode->val) + \",\";\n                que.push(pnode->left);\n                que.push(pnode->right);\n            }\n            else ser += \"null,\";\n        }\n        if(ser != \"\") ser.erase(ser.size() - 1);\n       // cout << ser << endl;\n        return ser;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        ser = data;\n        TreeNode *root = nullptr, *p = root;\n        pos = 0;\n\n        queue<TreeNode*> que;\n        if(_isvalue()){\n            root = new TreeNode(_next());\n            que.push(root);\n\n        }\n        else return nullptr;\n\n        while(que.size()){\n            p = que.front(); // 为该节点构造左右节点\n            que.pop();\n          //  cout << p->val << ' ';\n            if(!_hasnext()) break;\n            if(_isvalue()){\n                p->left = new TreeNode(_next());\n                que.push(p->left);\n            }else _next(); // 该节点的左子树为空\n            if(_isvalue()){\n                p->right = new TreeNode(_next());\n                que.push(p->right);\n            }else _next(); // 该节点的右子树为空\n        } \n        //cout << endl;\n        return root;\n\n    }\n\n    bool _isvalue(){        \n        if(!_hasnext()) return false;\n        if(isdigit(ser[pos]) || ser[pos] == '-') return true;\n        return false;\n    }\n\n    inline bool _hasnext(){\n        return !(pos >= ser.size());\n    }\n    int _next(){\n        bool isnum = _isvalue();\n        int t = pos;\n        while(t < ser.size() && ser[t] != ',') ++t;\n        int pre = pos;\n        pos = t + 1; // 把pos移到下一个空节点null或者数字开头处\n        if(isnum) return stoi(ser.substr(pre, t - pre)); \n        else return -1;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n```\n\n","source":"_posts/刷题/数据结构/树/297-Serialize-and-Deserialize-Binary-Tree.md","raw":"---\ntitle: 297. Serialize and Deserialize Binary Tree\nthumbnail: 'http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png'\ntoc: true\ntop: 10\ndate: 2021-04-26 08:27:55\ntags:\ncategories:\n---\n\n# [297. Serialize and Deserialize Binary Tree](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n\n\n## 思路：\n\n对于二叉树序列化，leetcode已经给出了很好的示范。思考一下，完整前缀遍历（包括空节点信息）能否构建二叉树？可以，从根到子节点前缀遍历的同时构建二叉树。同理后缀也可以。\n\n<!-- more -->\n\n\n\n这里我采用层序遍历的方式，构建序列化和解序列化。\n\n下面的代码有一个小技巧，把`迭代器`的设计思想融入到代码里：把遍历的功能独立出来，只提供接口，以便快速判断有无剩余节点，该节点是否有效。\n\n\n\n\n\n## 代码：\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\n    string ser;\n    int pos; // decoded pos.\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n    \n        queue<TreeNode*> que;\n        que.push(root);\n\n        while(que.size()){\n            TreeNode* pnode = que.front();\n            que.pop();\n            if(pnode){\n                ser += to_string(pnode->val) + \",\";\n                que.push(pnode->left);\n                que.push(pnode->right);\n            }\n            else ser += \"null,\";\n        }\n        if(ser != \"\") ser.erase(ser.size() - 1);\n       // cout << ser << endl;\n        return ser;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        ser = data;\n        TreeNode *root = nullptr, *p = root;\n        pos = 0;\n\n        queue<TreeNode*> que;\n        if(_isvalue()){\n            root = new TreeNode(_next());\n            que.push(root);\n\n        }\n        else return nullptr;\n\n        while(que.size()){\n            p = que.front(); // 为该节点构造左右节点\n            que.pop();\n          //  cout << p->val << ' ';\n            if(!_hasnext()) break;\n            if(_isvalue()){\n                p->left = new TreeNode(_next());\n                que.push(p->left);\n            }else _next(); // 该节点的左子树为空\n            if(_isvalue()){\n                p->right = new TreeNode(_next());\n                que.push(p->right);\n            }else _next(); // 该节点的右子树为空\n        } \n        //cout << endl;\n        return root;\n\n    }\n\n    bool _isvalue(){        \n        if(!_hasnext()) return false;\n        if(isdigit(ser[pos]) || ser[pos] == '-') return true;\n        return false;\n    }\n\n    inline bool _hasnext(){\n        return !(pos >= ser.size());\n    }\n    int _next(){\n        bool isnum = _isvalue();\n        int t = pos;\n        while(t < ser.size() && ser[t] != ',') ++t;\n        int pre = pos;\n        pos = t + 1; // 把pos移到下一个空节点null或者数字开头处\n        if(isnum) return stoi(ser.substr(pre, t - pre)); \n        else return -1;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n```\n\n","slug":"刷题/数据结构/树/297-Serialize-and-Deserialize-Binary-Tree","published":1,"updated":"2021-04-26T00:34:59.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7d005gl5uoe4wv2x73","content":"<h1 id=\"297-Serialize-and-Deserialize-Binary-Tree\"><a href=\"#297-Serialize-and-Deserialize-Binary-Tree\" class=\"headerlink\" title=\"297. Serialize and Deserialize Binary Tree\"></a><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">297. Serialize and Deserialize Binary Tree</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>对于二叉树序列化，leetcode已经给出了很好的示范。思考一下，完整前缀遍历（包括空节点信息）能否构建二叉树？可以，从根到子节点前缀遍历的同时构建二叉树。同理后缀也可以。</p>\n<span id=\"more\"></span>\n\n\n\n<p>这里我采用层序遍历的方式，构建序列化和解序列化。</p>\n<p>下面的代码有一个小技巧，把<code>迭代器</code>的设计思想融入到代码里：把遍历的功能独立出来，只提供接口，以便快速判断有无剩余节点，该节点是否有效。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Codec &#123;\n    string ser;\n    int pos; &#x2F;&#x2F; decoded pos.\npublic:\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n    \n        queue&lt;TreeNode*&gt; que;\n        que.push(root);\n\n        while(que.size())&#123;\n            TreeNode* pnode &#x3D; que.front();\n            que.pop();\n            if(pnode)&#123;\n                ser +&#x3D; to_string(pnode-&gt;val) + &quot;,&quot;;\n                que.push(pnode-&gt;left);\n                que.push(pnode-&gt;right);\n            &#125;\n            else ser +&#x3D; &quot;null,&quot;;\n        &#125;\n        if(ser !&#x3D; &quot;&quot;) ser.erase(ser.size() - 1);\n       &#x2F;&#x2F; cout &lt;&lt; ser &lt;&lt; endl;\n        return ser;\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) &#123;\n        ser &#x3D; data;\n        TreeNode *root &#x3D; nullptr, *p &#x3D; root;\n        pos &#x3D; 0;\n\n        queue&lt;TreeNode*&gt; que;\n        if(_isvalue())&#123;\n            root &#x3D; new TreeNode(_next());\n            que.push(root);\n\n        &#125;\n        else return nullptr;\n\n        while(que.size())&#123;\n            p &#x3D; que.front(); &#x2F;&#x2F; 为该节点构造左右节点\n            que.pop();\n          &#x2F;&#x2F;  cout &lt;&lt; p-&gt;val &lt;&lt; &#39; &#39;;\n            if(!_hasnext()) break;\n            if(_isvalue())&#123;\n                p-&gt;left &#x3D; new TreeNode(_next());\n                que.push(p-&gt;left);\n            &#125;else _next(); &#x2F;&#x2F; 该节点的左子树为空\n            if(_isvalue())&#123;\n                p-&gt;right &#x3D; new TreeNode(_next());\n                que.push(p-&gt;right);\n            &#125;else _next(); &#x2F;&#x2F; 该节点的右子树为空\n        &#125; \n        &#x2F;&#x2F;cout &lt;&lt; endl;\n        return root;\n\n    &#125;\n\n    bool _isvalue()&#123;        \n        if(!_hasnext()) return false;\n        if(isdigit(ser[pos]) || ser[pos] &#x3D;&#x3D; &#39;-&#39;) return true;\n        return false;\n    &#125;\n\n    inline bool _hasnext()&#123;\n        return !(pos &gt;&#x3D; ser.size());\n    &#125;\n    int _next()&#123;\n        bool isnum &#x3D; _isvalue();\n        int t &#x3D; pos;\n        while(t &lt; ser.size() &amp;&amp; ser[t] !&#x3D; &#39;,&#39;) ++t;\n        int pre &#x3D; pos;\n        pos &#x3D; t + 1; &#x2F;&#x2F; 把pos移到下一个空节点null或者数字开头处\n        if(isnum) return stoi(ser.substr(pre, t - pre)); \n        else return -1;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; Your Codec object will be instantiated and called as such:\n&#x2F;&#x2F; Codec ser, deser;\n&#x2F;&#x2F; TreeNode* ans &#x3D; deser.deserialize(ser.serialize(root));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"37QR22N","excerpt":"<h1 id=\"297-Serialize-and-Deserialize-Binary-Tree\"><a href=\"#297-Serialize-and-Deserialize-Binary-Tree\" class=\"headerlink\" title=\"297. Serialize and Deserialize Binary Tree\"></a><a href=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">297. Serialize and Deserialize Binary Tree</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>对于二叉树序列化，leetcode已经给出了很好的示范。思考一下，完整前缀遍历（包括空节点信息）能否构建二叉树？可以，从根到子节点前缀遍历的同时构建二叉树。同理后缀也可以。</p>","more":"<p>这里我采用层序遍历的方式，构建序列化和解序列化。</p>\n<p>下面的代码有一个小技巧，把<code>迭代器</code>的设计思想融入到代码里：把遍历的功能独立出来，只提供接口，以便快速判断有无剩余节点，该节点是否有效。</p>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Codec &#123;\n    string ser;\n    int pos; &#x2F;&#x2F; decoded pos.\npublic:\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    string serialize(TreeNode* root) &#123;\n    \n        queue&lt;TreeNode*&gt; que;\n        que.push(root);\n\n        while(que.size())&#123;\n            TreeNode* pnode &#x3D; que.front();\n            que.pop();\n            if(pnode)&#123;\n                ser +&#x3D; to_string(pnode-&gt;val) + &quot;,&quot;;\n                que.push(pnode-&gt;left);\n                que.push(pnode-&gt;right);\n            &#125;\n            else ser +&#x3D; &quot;null,&quot;;\n        &#125;\n        if(ser !&#x3D; &quot;&quot;) ser.erase(ser.size() - 1);\n       &#x2F;&#x2F; cout &lt;&lt; ser &lt;&lt; endl;\n        return ser;\n    &#125;\n\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) &#123;\n        ser &#x3D; data;\n        TreeNode *root &#x3D; nullptr, *p &#x3D; root;\n        pos &#x3D; 0;\n\n        queue&lt;TreeNode*&gt; que;\n        if(_isvalue())&#123;\n            root &#x3D; new TreeNode(_next());\n            que.push(root);\n\n        &#125;\n        else return nullptr;\n\n        while(que.size())&#123;\n            p &#x3D; que.front(); &#x2F;&#x2F; 为该节点构造左右节点\n            que.pop();\n          &#x2F;&#x2F;  cout &lt;&lt; p-&gt;val &lt;&lt; &#39; &#39;;\n            if(!_hasnext()) break;\n            if(_isvalue())&#123;\n                p-&gt;left &#x3D; new TreeNode(_next());\n                que.push(p-&gt;left);\n            &#125;else _next(); &#x2F;&#x2F; 该节点的左子树为空\n            if(_isvalue())&#123;\n                p-&gt;right &#x3D; new TreeNode(_next());\n                que.push(p-&gt;right);\n            &#125;else _next(); &#x2F;&#x2F; 该节点的右子树为空\n        &#125; \n        &#x2F;&#x2F;cout &lt;&lt; endl;\n        return root;\n\n    &#125;\n\n    bool _isvalue()&#123;        \n        if(!_hasnext()) return false;\n        if(isdigit(ser[pos]) || ser[pos] &#x3D;&#x3D; &#39;-&#39;) return true;\n        return false;\n    &#125;\n\n    inline bool _hasnext()&#123;\n        return !(pos &gt;&#x3D; ser.size());\n    &#125;\n    int _next()&#123;\n        bool isnum &#x3D; _isvalue();\n        int t &#x3D; pos;\n        while(t &lt; ser.size() &amp;&amp; ser[t] !&#x3D; &#39;,&#39;) ++t;\n        int pre &#x3D; pos;\n        pos &#x3D; t + 1; &#x2F;&#x2F; 把pos移到下一个空节点null或者数字开头处\n        if(isnum) return stoi(ser.substr(pre, t - pre)); \n        else return -1;\n    &#125;\n&#125;;\n\n&#x2F;&#x2F; Your Codec object will be instantiated and called as such:\n&#x2F;&#x2F; Codec ser, deser;\n&#x2F;&#x2F; TreeNode* ans &#x3D; deser.deserialize(ser.serialize(root));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"307. Range Sum Query - Mutable","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-02-05T12:38:24.000Z","_content":"\n\n\n# [307. Range Sum Query - Mutable](https://leetcode-cn.com/problems/range-sum-query-mutable/)\n\n\n\n\n\n## 思路\n\n线段树 + lazy操作\n\n<!-- more -->\n\n## 代码\n\n\n\n\n\n\n\n线段树累加操作（代码应该正确，顺手写一写）\n\n\n\n```c++\nclass NumArray {\npublic:\n    int n = 0, m = 0;\n    vector<int> d, b, a;\n    void build(int l, int r, int no){\n        int m = (l + r) / 2;\n        if(l == r){\n            d[no] = a[l];\n            return;\n        }\n        else {\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] = d[no * 2] + d[no * 2 + 1];\n        }\n    }\n    \n    void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated\n        if(s <= l && r <= t){\n            d[no] += (r - l + 1) * c;\n            b[no] += c;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if(b[no] && l != r){\n            d[no * 2] += (mid - l + 1) * b[no];\n            d[no * 2 + 1] += (r - mid) * b[no];\n            b[no * 2] += b[no];\n            b[no * 2 + 1] += b[no];\n            b[no] = 0;\n        }\n\n        if(s < mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t > mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] = d[no * 2] + d[no * 2 + 1];\n    }\n\n    int query_big(int l, int r, int s, int t, int no){  // [s, t] is queried.\n        if(s <= l && r <= t){\n            return d[no];\n        }\n        int mid = (l + r) / 2;\n        if(b[no] && l != r){\n            d[no * 2] += (mid - l + 1) * b[no];\n            d[no * 2 + 1] += (r - mid) * b[no];\n            b[no * 2] += b[no];\n            b[no * 2 + 1] += b[no];\n            b[no] = 0;\n        }\n        int sum = 0;\n        if(s < mid + 1) sum += query_big(l, mid, s, t, no * 2);\n        if(t > mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    }\n    NumArray(vector<int>& nums) {\n        m = nums.size();\n        n = m * 2 + 10;\n        d.resize(n);\n        b.resize(n);\n        a = nums;\n        build(0, m - 1, 1);\n    }\n    \n    void update(int index, int val) {\n        update_big(0, m, index, index, val, 1);\n    }\n    \n    int sumRange(int left, int right) {\n        return query_big(0, m, left, right, 1);\n        // return 0;\n    }\n\n    \n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(index,val);\n * int param_2 = obj->sumRange(left,right);\n */\n```\n\n\n\n\n\n线段树更新为定值（AC ） 17% \n\n\n\n````c++\nclass NumArray {\npublic:\n    int n = 0, m = 0;\n    vector<int> d, b, a, isb;\n    void build(int l, int r, int no){\n        int m = (l + r) / 2;\n        if(l == r){\n            d[no] = a[l];\n            return;\n        }\n        else {\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] = d[no * 2] + d[no * 2 + 1];\n        }\n    }\n    \n    void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated\n        if(s <= l && r <= t){\n            d[no] = (r - l + 1) * c;\n            b[no] = c;\n            isb[no] = 1;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if(l < r && isb[no]){\n            d[no * 2] = (mid - l + 1) * b[no];\n            d[no * 2 + 1] = (r - mid) * b[no];\n            b[no * 2] = b[no];\n            b[no * 2 + 1] = b[no];\n            isb[no * 2] = isb[no * 2] = 1;\n            b[no] = isb[no] = 0;\n        }\n\n        if(s < mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t > mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] = d[no * 2] + d[no * 2 + 1];\n    }\n\n    int query_big(int l, int r, int s, int t, int no){  // [s, t] is queried.\n        if(s <= l && r <= t){\n            return d[no];\n        }\n        int mid = (l + r) / 2;\n        if(l < r && b[no]){\n            d[no * 2] = (mid - l + 1) * b[no];\n            d[no * 2 + 1] = (r - mid) * b[no];\n            b[no * 2] = b[no];\n            b[no * 2 + 1] = b[no];\n            isb[no * 2] = isb[no * 2] = 1;\n            b[no] = isb[no] = 0;\n        }\n        int sum = 0;\n        if(s < mid + 1) sum += query_big(l, mid, s, t, no * 2);\n        if(t > mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    }\n    NumArray(vector<int>& nums) {\n        m = nums.size();\n        n = m * 4 + 10; // n * 2 开太小了\n        d.resize(n);\n        b.resize(n);\n        isb.resize(n);\n        a = nums;\n        build(0, m - 1, 1);\n    }\n    \n    void update(int index, int val) {\n        update_big(0, m - 1, index, index, val, 1);\n    }\n    \n    int sumRange(int left, int right) {\n        return query_big(0, m - 1, left, right, 1);\n        // return 0;\n    }\n\n    \n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(index,val);\n * int param_2 = obj->sumRange(left,right);\n */\n````\n\n","source":"_posts/刷题/数据结构/树/307-Range-Sum-Query-Mutable.md","raw":"---\ntitle: 307. Range Sum Query - Mutable\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-02-05 20:38:24\ntags:\ncategories:\n---\n\n\n\n# [307. Range Sum Query - Mutable](https://leetcode-cn.com/problems/range-sum-query-mutable/)\n\n\n\n\n\n## 思路\n\n线段树 + lazy操作\n\n<!-- more -->\n\n## 代码\n\n\n\n\n\n\n\n线段树累加操作（代码应该正确，顺手写一写）\n\n\n\n```c++\nclass NumArray {\npublic:\n    int n = 0, m = 0;\n    vector<int> d, b, a;\n    void build(int l, int r, int no){\n        int m = (l + r) / 2;\n        if(l == r){\n            d[no] = a[l];\n            return;\n        }\n        else {\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] = d[no * 2] + d[no * 2 + 1];\n        }\n    }\n    \n    void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated\n        if(s <= l && r <= t){\n            d[no] += (r - l + 1) * c;\n            b[no] += c;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if(b[no] && l != r){\n            d[no * 2] += (mid - l + 1) * b[no];\n            d[no * 2 + 1] += (r - mid) * b[no];\n            b[no * 2] += b[no];\n            b[no * 2 + 1] += b[no];\n            b[no] = 0;\n        }\n\n        if(s < mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t > mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] = d[no * 2] + d[no * 2 + 1];\n    }\n\n    int query_big(int l, int r, int s, int t, int no){  // [s, t] is queried.\n        if(s <= l && r <= t){\n            return d[no];\n        }\n        int mid = (l + r) / 2;\n        if(b[no] && l != r){\n            d[no * 2] += (mid - l + 1) * b[no];\n            d[no * 2 + 1] += (r - mid) * b[no];\n            b[no * 2] += b[no];\n            b[no * 2 + 1] += b[no];\n            b[no] = 0;\n        }\n        int sum = 0;\n        if(s < mid + 1) sum += query_big(l, mid, s, t, no * 2);\n        if(t > mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    }\n    NumArray(vector<int>& nums) {\n        m = nums.size();\n        n = m * 2 + 10;\n        d.resize(n);\n        b.resize(n);\n        a = nums;\n        build(0, m - 1, 1);\n    }\n    \n    void update(int index, int val) {\n        update_big(0, m, index, index, val, 1);\n    }\n    \n    int sumRange(int left, int right) {\n        return query_big(0, m, left, right, 1);\n        // return 0;\n    }\n\n    \n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(index,val);\n * int param_2 = obj->sumRange(left,right);\n */\n```\n\n\n\n\n\n线段树更新为定值（AC ） 17% \n\n\n\n````c++\nclass NumArray {\npublic:\n    int n = 0, m = 0;\n    vector<int> d, b, a, isb;\n    void build(int l, int r, int no){\n        int m = (l + r) / 2;\n        if(l == r){\n            d[no] = a[l];\n            return;\n        }\n        else {\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] = d[no * 2] + d[no * 2 + 1];\n        }\n    }\n    \n    void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated\n        if(s <= l && r <= t){\n            d[no] = (r - l + 1) * c;\n            b[no] = c;\n            isb[no] = 1;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if(l < r && isb[no]){\n            d[no * 2] = (mid - l + 1) * b[no];\n            d[no * 2 + 1] = (r - mid) * b[no];\n            b[no * 2] = b[no];\n            b[no * 2 + 1] = b[no];\n            isb[no * 2] = isb[no * 2] = 1;\n            b[no] = isb[no] = 0;\n        }\n\n        if(s < mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t > mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] = d[no * 2] + d[no * 2 + 1];\n    }\n\n    int query_big(int l, int r, int s, int t, int no){  // [s, t] is queried.\n        if(s <= l && r <= t){\n            return d[no];\n        }\n        int mid = (l + r) / 2;\n        if(l < r && b[no]){\n            d[no * 2] = (mid - l + 1) * b[no];\n            d[no * 2 + 1] = (r - mid) * b[no];\n            b[no * 2] = b[no];\n            b[no * 2 + 1] = b[no];\n            isb[no * 2] = isb[no * 2] = 1;\n            b[no] = isb[no] = 0;\n        }\n        int sum = 0;\n        if(s < mid + 1) sum += query_big(l, mid, s, t, no * 2);\n        if(t > mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    }\n    NumArray(vector<int>& nums) {\n        m = nums.size();\n        n = m * 4 + 10; // n * 2 开太小了\n        d.resize(n);\n        b.resize(n);\n        isb.resize(n);\n        a = nums;\n        build(0, m - 1, 1);\n    }\n    \n    void update(int index, int val) {\n        update_big(0, m - 1, index, index, val, 1);\n    }\n    \n    int sumRange(int left, int right) {\n        return query_big(0, m - 1, left, right, 1);\n        // return 0;\n    }\n\n    \n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(index,val);\n * int param_2 = obj->sumRange(left,right);\n */\n````\n\n","slug":"刷题/数据结构/树/307-Range-Sum-Query-Mutable","published":1,"updated":"2021-02-05T12:39:56.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7e005hl5uofa23241f","content":"<h1 id=\"307-Range-Sum-Query-Mutable\"><a href=\"#307-Range-Sum-Query-Mutable\" class=\"headerlink\" title=\"307. Range Sum Query - Mutable\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-mutable/\">307. Range Sum Query - Mutable</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>线段树 + lazy操作</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>线段树累加操作（代码应该正确，顺手写一写）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class NumArray &#123;\npublic:\n    int n &#x3D; 0, m &#x3D; 0;\n    vector&lt;int&gt; d, b, a;\n    void build(int l, int r, int no)&#123;\n        int m &#x3D; (l + r) &#x2F; 2;\n        if(l &#x3D;&#x3D; r)&#123;\n            d[no] &#x3D; a[l];\n            return;\n        &#125;\n        else &#123;\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n        &#125;\n    &#125;\n    \n    void update_big(int l, int r, int s, int t, int c, int no)&#123; &#x2F;&#x2F; [s, t] is updated\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            d[no] +&#x3D; (r - l + 1) * c;\n            b[no] +&#x3D; c;\n            return;\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(b[no] &amp;&amp; l !&#x3D; r)&#123;\n            d[no * 2] +&#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] +&#x3D; (r - mid) * b[no];\n            b[no * 2] +&#x3D; b[no];\n            b[no * 2 + 1] +&#x3D; b[no];\n            b[no] &#x3D; 0;\n        &#125;\n\n        if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n    &#125;\n\n    int query_big(int l, int r, int s, int t, int no)&#123;  &#x2F;&#x2F; [s, t] is queried.\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            return d[no];\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(b[no] &amp;&amp; l !&#x3D; r)&#123;\n            d[no * 2] +&#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] +&#x3D; (r - mid) * b[no];\n            b[no * 2] +&#x3D; b[no];\n            b[no * 2 + 1] +&#x3D; b[no];\n            b[no] &#x3D; 0;\n        &#125;\n        int sum &#x3D; 0;\n        if(s &lt; mid + 1) sum +&#x3D; query_big(l, mid, s, t, no * 2);\n        if(t &gt; mid) sum +&#x3D; query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    &#125;\n    NumArray(vector&lt;int&gt;&amp; nums) &#123;\n        m &#x3D; nums.size();\n        n &#x3D; m * 2 + 10;\n        d.resize(n);\n        b.resize(n);\n        a &#x3D; nums;\n        build(0, m - 1, 1);\n    &#125;\n    \n    void update(int index, int val) &#123;\n        update_big(0, m, index, index, val, 1);\n    &#125;\n    \n    int sumRange(int left, int right) &#123;\n        return query_big(0, m, left, right, 1);\n        &#x2F;&#x2F; return 0;\n    &#125;\n\n    \n&#125;;\n\n&#x2F;**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj &#x3D; new NumArray(nums);\n * obj-&gt;update(index,val);\n * int param_2 &#x3D; obj-&gt;sumRange(left,right);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>线段树更新为定值（AC ） 17% </p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class NumArray &#123;\npublic:\n    int n &#x3D; 0, m &#x3D; 0;\n    vector&lt;int&gt; d, b, a, isb;\n    void build(int l, int r, int no)&#123;\n        int m &#x3D; (l + r) &#x2F; 2;\n        if(l &#x3D;&#x3D; r)&#123;\n            d[no] &#x3D; a[l];\n            return;\n        &#125;\n        else &#123;\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n        &#125;\n    &#125;\n    \n    void update_big(int l, int r, int s, int t, int c, int no)&#123; &#x2F;&#x2F; [s, t] is updated\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            d[no] &#x3D; (r - l + 1) * c;\n            b[no] &#x3D; c;\n            isb[no] &#x3D; 1;\n            return;\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(l &lt; r &amp;&amp; isb[no])&#123;\n            d[no * 2] &#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] &#x3D; (r - mid) * b[no];\n            b[no * 2] &#x3D; b[no];\n            b[no * 2 + 1] &#x3D; b[no];\n            isb[no * 2] &#x3D; isb[no * 2] &#x3D; 1;\n            b[no] &#x3D; isb[no] &#x3D; 0;\n        &#125;\n\n        if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n    &#125;\n\n    int query_big(int l, int r, int s, int t, int no)&#123;  &#x2F;&#x2F; [s, t] is queried.\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            return d[no];\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(l &lt; r &amp;&amp; b[no])&#123;\n            d[no * 2] &#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] &#x3D; (r - mid) * b[no];\n            b[no * 2] &#x3D; b[no];\n            b[no * 2 + 1] &#x3D; b[no];\n            isb[no * 2] &#x3D; isb[no * 2] &#x3D; 1;\n            b[no] &#x3D; isb[no] &#x3D; 0;\n        &#125;\n        int sum &#x3D; 0;\n        if(s &lt; mid + 1) sum +&#x3D; query_big(l, mid, s, t, no * 2);\n        if(t &gt; mid) sum +&#x3D; query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    &#125;\n    NumArray(vector&lt;int&gt;&amp; nums) &#123;\n        m &#x3D; nums.size();\n        n &#x3D; m * 4 + 10; &#x2F;&#x2F; n * 2 开太小了\n        d.resize(n);\n        b.resize(n);\n        isb.resize(n);\n        a &#x3D; nums;\n        build(0, m - 1, 1);\n    &#125;\n    \n    void update(int index, int val) &#123;\n        update_big(0, m - 1, index, index, val, 1);\n    &#125;\n    \n    int sumRange(int left, int right) &#123;\n        return query_big(0, m - 1, left, right, 1);\n        &#x2F;&#x2F; return 0;\n    &#125;\n\n    \n&#125;;\n\n&#x2F;**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj &#x3D; new NumArray(nums);\n * obj-&gt;update(index,val);\n * int param_2 &#x3D; obj-&gt;sumRange(left,right);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3C4VTG0","excerpt":"<h1 id=\"307-Range-Sum-Query-Mutable\"><a href=\"#307-Range-Sum-Query-Mutable\" class=\"headerlink\" title=\"307. Range Sum Query - Mutable\"></a><a href=\"https://leetcode-cn.com/problems/range-sum-query-mutable/\">307. Range Sum Query - Mutable</a></h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>线段树 + lazy操作</p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>线段树累加操作（代码应该正确，顺手写一写）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class NumArray &#123;\npublic:\n    int n &#x3D; 0, m &#x3D; 0;\n    vector&lt;int&gt; d, b, a;\n    void build(int l, int r, int no)&#123;\n        int m &#x3D; (l + r) &#x2F; 2;\n        if(l &#x3D;&#x3D; r)&#123;\n            d[no] &#x3D; a[l];\n            return;\n        &#125;\n        else &#123;\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n        &#125;\n    &#125;\n    \n    void update_big(int l, int r, int s, int t, int c, int no)&#123; &#x2F;&#x2F; [s, t] is updated\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            d[no] +&#x3D; (r - l + 1) * c;\n            b[no] +&#x3D; c;\n            return;\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(b[no] &amp;&amp; l !&#x3D; r)&#123;\n            d[no * 2] +&#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] +&#x3D; (r - mid) * b[no];\n            b[no * 2] +&#x3D; b[no];\n            b[no * 2 + 1] +&#x3D; b[no];\n            b[no] &#x3D; 0;\n        &#125;\n\n        if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n    &#125;\n\n    int query_big(int l, int r, int s, int t, int no)&#123;  &#x2F;&#x2F; [s, t] is queried.\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            return d[no];\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(b[no] &amp;&amp; l !&#x3D; r)&#123;\n            d[no * 2] +&#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] +&#x3D; (r - mid) * b[no];\n            b[no * 2] +&#x3D; b[no];\n            b[no * 2 + 1] +&#x3D; b[no];\n            b[no] &#x3D; 0;\n        &#125;\n        int sum &#x3D; 0;\n        if(s &lt; mid + 1) sum +&#x3D; query_big(l, mid, s, t, no * 2);\n        if(t &gt; mid) sum +&#x3D; query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    &#125;\n    NumArray(vector&lt;int&gt;&amp; nums) &#123;\n        m &#x3D; nums.size();\n        n &#x3D; m * 2 + 10;\n        d.resize(n);\n        b.resize(n);\n        a &#x3D; nums;\n        build(0, m - 1, 1);\n    &#125;\n    \n    void update(int index, int val) &#123;\n        update_big(0, m, index, index, val, 1);\n    &#125;\n    \n    int sumRange(int left, int right) &#123;\n        return query_big(0, m, left, right, 1);\n        &#x2F;&#x2F; return 0;\n    &#125;\n\n    \n&#125;;\n\n&#x2F;**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj &#x3D; new NumArray(nums);\n * obj-&gt;update(index,val);\n * int param_2 &#x3D; obj-&gt;sumRange(left,right);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<p>线段树更新为定值（AC ） 17% </p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class NumArray &#123;\npublic:\n    int n &#x3D; 0, m &#x3D; 0;\n    vector&lt;int&gt; d, b, a, isb;\n    void build(int l, int r, int no)&#123;\n        int m &#x3D; (l + r) &#x2F; 2;\n        if(l &#x3D;&#x3D; r)&#123;\n            d[no] &#x3D; a[l];\n            return;\n        &#125;\n        else &#123;\n            build(l, m, no * 2), build(m + 1, r, no * 2 + 1);\n            d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n        &#125;\n    &#125;\n    \n    void update_big(int l, int r, int s, int t, int c, int no)&#123; &#x2F;&#x2F; [s, t] is updated\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            d[no] &#x3D; (r - l + 1) * c;\n            b[no] &#x3D; c;\n            isb[no] &#x3D; 1;\n            return;\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(l &lt; r &amp;&amp; isb[no])&#123;\n            d[no * 2] &#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] &#x3D; (r - mid) * b[no];\n            b[no * 2] &#x3D; b[no];\n            b[no * 2 + 1] &#x3D; b[no];\n            isb[no * 2] &#x3D; isb[no * 2] &#x3D; 1;\n            b[no] &#x3D; isb[no] &#x3D; 0;\n        &#125;\n\n        if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2);\n        if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1);\n        d[no] &#x3D; d[no * 2] + d[no * 2 + 1];\n    &#125;\n\n    int query_big(int l, int r, int s, int t, int no)&#123;  &#x2F;&#x2F; [s, t] is queried.\n        if(s &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; t)&#123;\n            return d[no];\n        &#125;\n        int mid &#x3D; (l + r) &#x2F; 2;\n        if(l &lt; r &amp;&amp; b[no])&#123;\n            d[no * 2] &#x3D; (mid - l + 1) * b[no];\n            d[no * 2 + 1] &#x3D; (r - mid) * b[no];\n            b[no * 2] &#x3D; b[no];\n            b[no * 2 + 1] &#x3D; b[no];\n            isb[no * 2] &#x3D; isb[no * 2] &#x3D; 1;\n            b[no] &#x3D; isb[no] &#x3D; 0;\n        &#125;\n        int sum &#x3D; 0;\n        if(s &lt; mid + 1) sum +&#x3D; query_big(l, mid, s, t, no * 2);\n        if(t &gt; mid) sum +&#x3D; query_big(mid + 1, r, s, t, no * 2 + 1);\n        return sum;\n    &#125;\n    NumArray(vector&lt;int&gt;&amp; nums) &#123;\n        m &#x3D; nums.size();\n        n &#x3D; m * 4 + 10; &#x2F;&#x2F; n * 2 开太小了\n        d.resize(n);\n        b.resize(n);\n        isb.resize(n);\n        a &#x3D; nums;\n        build(0, m - 1, 1);\n    &#125;\n    \n    void update(int index, int val) &#123;\n        update_big(0, m - 1, index, index, val, 1);\n    &#125;\n    \n    int sumRange(int left, int right) &#123;\n        return query_big(0, m - 1, left, right, 1);\n        &#x2F;&#x2F; return 0;\n    &#125;\n\n    \n&#125;;\n\n&#x2F;**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj &#x3D; new NumArray(nums);\n * obj-&gt;update(index,val);\n * int param_2 &#x3D; obj-&gt;sumRange(left,right);\n *&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"310. Minimum Height Trees","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-12-06T01:51:10.000Z","_content":"\n\n\n\n\n## [310. Minimum Height Trees](https://leetcode-cn.com/problems/minimum-height-trees/)\n\n## 思路：\n\n1. （超时）bfs\n2. 拓扑排序变形。从图的边缘点逆向追溯到中心点，可以直接获取到目标点。又有题目性质猜得，没有孤立点（除非n=1），没有环。那么目标点至多只有两个。\n\n<!-- more -->s\n\n\n\n\n\n```c++\nclass Solution {\npublic:    \n    vector<vector<int>> map;\n\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n       map.resize(n);\n       for(int i = 0; i < edges.size(); ++i){\n           int x = edges[i][0];\n           int y = edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n       }\n       int minl = n - 1;\n       vector<int> root;\n       for(int i = 0; i < n; ++i){\n           vector<bool> vis(n, false);\n           int len = dfs(i, vis, 0);\n        \n           if(len < minl){\n               root.clear();\n               minl = len;\n           }\n           if(len == minl){\n               root.push_back(i);\n           }\n       }\n        return root;\n    }\n\n    int dfs(int v, vector<bool>&vis, int len){\n        vis[v] = 1;\n        int maxlen = len;\n        for(auto u : map[v]){        \n            if(!vis[u]){\n            // cout << v << ' ' << u << ' ' << len << endl;\n                maxlen = max(maxlen, dfs(u, vis, len + 1)); // bugs: maxv = max(maxv, dfs(maxv + 1));\n            }\n        }\n        return maxlen;\n    }\n};\n```\n\n\n\n拓扑AC\n\n```c++\nclass Solution {\npublic:    \n    vector<vector<int>> map;\n    vector<int> degree;\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n       map.resize(n);\n       degree.resize(n);\n       for(int i = 0; i < edges.size(); ++i){\n           int x = edges[i][0];\n           int y = edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       }\n       queue<int> que;\n       int m = 0;\n        for(int i = 0;i < n; ++i){\n            if(degree[i] == 1){\n                que.push(i);\n            }\n            if(degree[i] > 0) ++m;\n        }\n        vector<int> root;\n        while(que.size()){\n            m -= que.size();\n            if(m == 0) break;\n            // cout << m << endl;\n            while(que.size()){                \n                int u = que.front();                \n                que.pop();\n                for(auto v : map[u]){\n                    degree[v]--;\n                    degree[u]--;\n                    if(degree[v] == 0) root.push_back(v);\n                }\n            }\n\n            for(int i = 0; i < n; ++i){\n                if(degree[i] == 1){\n                    que.push(i);\n                }\n            }\n        }\n        if(root.size() == 0)\n        while(que.size()){\n            root.push_back(que.front());\n            que.pop();\n        }\n        if(n == 1) root.push_back(0);\n        return root;\n    }\n};\n\n```\n\n利用性质优化一下\n\n```c++\nclass Solution {\npublic:    \n    vector<vector<int>> map;\n    vector<int> degree;\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n       map.resize(n);\n       degree.resize(n);\n       for(int i = 0; i < edges.size(); ++i){\n           int x = edges[i][0];\n           int y = edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       }\n       queue<int> que;\n       int m = n;\n        for(int i = 0;i < n; ++i){\n            if(degree[i] == 1){\n                que.push(i);\n            }            \n        }\n        vector<int> root;\n        while(m > 2){            \n            m -= que.size();\n            int size = que.size();\n            for(int i = 0; i < size; ++i){                \n                int u = que.front();                \n                que.pop();\n                for(auto v : map[u]){\n                    degree[v]--;\n                    if(degree[v] == 1){\n                       que.push(v);\n                    }\n                }\n            }\n        }\n\n        if(root.size() == 0)\n        while(que.size()){\n            root.push_back(que.front());\n            que.pop();\n        }\n        if(n == 1) root.push_back(0);\n        return root;\n    }\n};\n```","source":"_posts/刷题/数据结构/树/310-Minimum-Height-Trees.md","raw":"---\ntitle: 310. Minimum Height Trees\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-12-06 09:51:10\n---\n\n\n\n\n\n## [310. Minimum Height Trees](https://leetcode-cn.com/problems/minimum-height-trees/)\n\n## 思路：\n\n1. （超时）bfs\n2. 拓扑排序变形。从图的边缘点逆向追溯到中心点，可以直接获取到目标点。又有题目性质猜得，没有孤立点（除非n=1），没有环。那么目标点至多只有两个。\n\n<!-- more -->s\n\n\n\n\n\n```c++\nclass Solution {\npublic:    \n    vector<vector<int>> map;\n\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n       map.resize(n);\n       for(int i = 0; i < edges.size(); ++i){\n           int x = edges[i][0];\n           int y = edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n       }\n       int minl = n - 1;\n       vector<int> root;\n       for(int i = 0; i < n; ++i){\n           vector<bool> vis(n, false);\n           int len = dfs(i, vis, 0);\n        \n           if(len < minl){\n               root.clear();\n               minl = len;\n           }\n           if(len == minl){\n               root.push_back(i);\n           }\n       }\n        return root;\n    }\n\n    int dfs(int v, vector<bool>&vis, int len){\n        vis[v] = 1;\n        int maxlen = len;\n        for(auto u : map[v]){        \n            if(!vis[u]){\n            // cout << v << ' ' << u << ' ' << len << endl;\n                maxlen = max(maxlen, dfs(u, vis, len + 1)); // bugs: maxv = max(maxv, dfs(maxv + 1));\n            }\n        }\n        return maxlen;\n    }\n};\n```\n\n\n\n拓扑AC\n\n```c++\nclass Solution {\npublic:    \n    vector<vector<int>> map;\n    vector<int> degree;\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n       map.resize(n);\n       degree.resize(n);\n       for(int i = 0; i < edges.size(); ++i){\n           int x = edges[i][0];\n           int y = edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       }\n       queue<int> que;\n       int m = 0;\n        for(int i = 0;i < n; ++i){\n            if(degree[i] == 1){\n                que.push(i);\n            }\n            if(degree[i] > 0) ++m;\n        }\n        vector<int> root;\n        while(que.size()){\n            m -= que.size();\n            if(m == 0) break;\n            // cout << m << endl;\n            while(que.size()){                \n                int u = que.front();                \n                que.pop();\n                for(auto v : map[u]){\n                    degree[v]--;\n                    degree[u]--;\n                    if(degree[v] == 0) root.push_back(v);\n                }\n            }\n\n            for(int i = 0; i < n; ++i){\n                if(degree[i] == 1){\n                    que.push(i);\n                }\n            }\n        }\n        if(root.size() == 0)\n        while(que.size()){\n            root.push_back(que.front());\n            que.pop();\n        }\n        if(n == 1) root.push_back(0);\n        return root;\n    }\n};\n\n```\n\n利用性质优化一下\n\n```c++\nclass Solution {\npublic:    \n    vector<vector<int>> map;\n    vector<int> degree;\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n       map.resize(n);\n       degree.resize(n);\n       for(int i = 0; i < edges.size(); ++i){\n           int x = edges[i][0];\n           int y = edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       }\n       queue<int> que;\n       int m = n;\n        for(int i = 0;i < n; ++i){\n            if(degree[i] == 1){\n                que.push(i);\n            }            \n        }\n        vector<int> root;\n        while(m > 2){            \n            m -= que.size();\n            int size = que.size();\n            for(int i = 0; i < size; ++i){                \n                int u = que.front();                \n                que.pop();\n                for(auto v : map[u]){\n                    degree[v]--;\n                    if(degree[v] == 1){\n                       que.push(v);\n                    }\n                }\n            }\n        }\n\n        if(root.size() == 0)\n        while(que.size()){\n            root.push_back(que.front());\n            que.pop();\n        }\n        if(n == 1) root.push_back(0);\n        return root;\n    }\n};\n```","slug":"刷题/数据结构/树/310-Minimum-Height-Trees","published":1,"updated":"2021-01-28T14:04:37.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7f005il5uohway9p5v","content":"<h2 id=\"310-Minimum-Height-Trees\"><a href=\"#310-Minimum-Height-Trees\" class=\"headerlink\" title=\"310. Minimum Height Trees\"></a><a href=\"https://leetcode-cn.com/problems/minimum-height-trees/\">310. Minimum Height Trees</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>（超时）bfs</li>\n<li>拓扑排序变形。从图的边缘点逆向追溯到中心点，可以直接获取到目标点。又有题目性质猜得，没有孤立点（除非n=1），没有环。那么目标点至多只有两个。</li>\n</ol>\n<span id=\"more\"></span>s\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:    \n    vector&lt;vector&lt;int&gt;&gt; map;\n\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n       map.resize(n);\n       for(int i &#x3D; 0; i &lt; edges.size(); ++i)&#123;\n           int x &#x3D; edges[i][0];\n           int y &#x3D; edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n       &#125;\n       int minl &#x3D; n - 1;\n       vector&lt;int&gt; root;\n       for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n           vector&lt;bool&gt; vis(n, false);\n           int len &#x3D; dfs(i, vis, 0);\n        \n           if(len &lt; minl)&#123;\n               root.clear();\n               minl &#x3D; len;\n           &#125;\n           if(len &#x3D;&#x3D; minl)&#123;\n               root.push_back(i);\n           &#125;\n       &#125;\n        return root;\n    &#125;\n\n    int dfs(int v, vector&lt;bool&gt;&amp;vis, int len)&#123;\n        vis[v] &#x3D; 1;\n        int maxlen &#x3D; len;\n        for(auto u : map[v])&#123;        \n            if(!vis[u])&#123;\n            &#x2F;&#x2F; cout &lt;&lt; v &lt;&lt; &#39; &#39; &lt;&lt; u &lt;&lt; &#39; &#39; &lt;&lt; len &lt;&lt; endl;\n                maxlen &#x3D; max(maxlen, dfs(u, vis, len + 1)); &#x2F;&#x2F; bugs: maxv &#x3D; max(maxv, dfs(maxv + 1));\n            &#125;\n        &#125;\n        return maxlen;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>拓扑AC</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:    \n    vector&lt;vector&lt;int&gt;&gt; map;\n    vector&lt;int&gt; degree;\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n       map.resize(n);\n       degree.resize(n);\n       for(int i &#x3D; 0; i &lt; edges.size(); ++i)&#123;\n           int x &#x3D; edges[i][0];\n           int y &#x3D; edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       &#125;\n       queue&lt;int&gt; que;\n       int m &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(degree[i] &#x3D;&#x3D; 1)&#123;\n                que.push(i);\n            &#125;\n            if(degree[i] &gt; 0) ++m;\n        &#125;\n        vector&lt;int&gt; root;\n        while(que.size())&#123;\n            m -&#x3D; que.size();\n            if(m &#x3D;&#x3D; 0) break;\n            &#x2F;&#x2F; cout &lt;&lt; m &lt;&lt; endl;\n            while(que.size())&#123;                \n                int u &#x3D; que.front();                \n                que.pop();\n                for(auto v : map[u])&#123;\n                    degree[v]--;\n                    degree[u]--;\n                    if(degree[v] &#x3D;&#x3D; 0) root.push_back(v);\n                &#125;\n            &#125;\n\n            for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n                if(degree[i] &#x3D;&#x3D; 1)&#123;\n                    que.push(i);\n                &#125;\n            &#125;\n        &#125;\n        if(root.size() &#x3D;&#x3D; 0)\n        while(que.size())&#123;\n            root.push_back(que.front());\n            que.pop();\n        &#125;\n        if(n &#x3D;&#x3D; 1) root.push_back(0);\n        return root;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>利用性质优化一下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:    \n    vector&lt;vector&lt;int&gt;&gt; map;\n    vector&lt;int&gt; degree;\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n       map.resize(n);\n       degree.resize(n);\n       for(int i &#x3D; 0; i &lt; edges.size(); ++i)&#123;\n           int x &#x3D; edges[i][0];\n           int y &#x3D; edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       &#125;\n       queue&lt;int&gt; que;\n       int m &#x3D; n;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(degree[i] &#x3D;&#x3D; 1)&#123;\n                que.push(i);\n            &#125;            \n        &#125;\n        vector&lt;int&gt; root;\n        while(m &gt; 2)&#123;            \n            m -&#x3D; que.size();\n            int size &#x3D; que.size();\n            for(int i &#x3D; 0; i &lt; size; ++i)&#123;                \n                int u &#x3D; que.front();                \n                que.pop();\n                for(auto v : map[u])&#123;\n                    degree[v]--;\n                    if(degree[v] &#x3D;&#x3D; 1)&#123;\n                       que.push(v);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n\n        if(root.size() &#x3D;&#x3D; 0)\n        while(que.size())&#123;\n            root.push_back(que.front());\n            que.pop();\n        &#125;\n        if(n &#x3D;&#x3D; 1) root.push_back(0);\n        return root;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"WGT1KZ","excerpt":"<h2 id=\"310-Minimum-Height-Trees\"><a href=\"#310-Minimum-Height-Trees\" class=\"headerlink\" title=\"310. Minimum Height Trees\"></a><a href=\"https://leetcode-cn.com/problems/minimum-height-trees/\">310. Minimum Height Trees</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>（超时）bfs</li>\n<li>拓扑排序变形。从图的边缘点逆向追溯到中心点，可以直接获取到目标点。又有题目性质猜得，没有孤立点（除非n=1），没有环。那么目标点至多只有两个。</li>\n</ol>","more":"s\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:    \n    vector&lt;vector&lt;int&gt;&gt; map;\n\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n       map.resize(n);\n       for(int i &#x3D; 0; i &lt; edges.size(); ++i)&#123;\n           int x &#x3D; edges[i][0];\n           int y &#x3D; edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n       &#125;\n       int minl &#x3D; n - 1;\n       vector&lt;int&gt; root;\n       for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n           vector&lt;bool&gt; vis(n, false);\n           int len &#x3D; dfs(i, vis, 0);\n        \n           if(len &lt; minl)&#123;\n               root.clear();\n               minl &#x3D; len;\n           &#125;\n           if(len &#x3D;&#x3D; minl)&#123;\n               root.push_back(i);\n           &#125;\n       &#125;\n        return root;\n    &#125;\n\n    int dfs(int v, vector&lt;bool&gt;&amp;vis, int len)&#123;\n        vis[v] &#x3D; 1;\n        int maxlen &#x3D; len;\n        for(auto u : map[v])&#123;        \n            if(!vis[u])&#123;\n            &#x2F;&#x2F; cout &lt;&lt; v &lt;&lt; &#39; &#39; &lt;&lt; u &lt;&lt; &#39; &#39; &lt;&lt; len &lt;&lt; endl;\n                maxlen &#x3D; max(maxlen, dfs(u, vis, len + 1)); &#x2F;&#x2F; bugs: maxv &#x3D; max(maxv, dfs(maxv + 1));\n            &#125;\n        &#125;\n        return maxlen;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>拓扑AC</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:    \n    vector&lt;vector&lt;int&gt;&gt; map;\n    vector&lt;int&gt; degree;\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n       map.resize(n);\n       degree.resize(n);\n       for(int i &#x3D; 0; i &lt; edges.size(); ++i)&#123;\n           int x &#x3D; edges[i][0];\n           int y &#x3D; edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       &#125;\n       queue&lt;int&gt; que;\n       int m &#x3D; 0;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(degree[i] &#x3D;&#x3D; 1)&#123;\n                que.push(i);\n            &#125;\n            if(degree[i] &gt; 0) ++m;\n        &#125;\n        vector&lt;int&gt; root;\n        while(que.size())&#123;\n            m -&#x3D; que.size();\n            if(m &#x3D;&#x3D; 0) break;\n            &#x2F;&#x2F; cout &lt;&lt; m &lt;&lt; endl;\n            while(que.size())&#123;                \n                int u &#x3D; que.front();                \n                que.pop();\n                for(auto v : map[u])&#123;\n                    degree[v]--;\n                    degree[u]--;\n                    if(degree[v] &#x3D;&#x3D; 0) root.push_back(v);\n                &#125;\n            &#125;\n\n            for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n                if(degree[i] &#x3D;&#x3D; 1)&#123;\n                    que.push(i);\n                &#125;\n            &#125;\n        &#125;\n        if(root.size() &#x3D;&#x3D; 0)\n        while(que.size())&#123;\n            root.push_back(que.front());\n            que.pop();\n        &#125;\n        if(n &#x3D;&#x3D; 1) root.push_back(0);\n        return root;\n    &#125;\n&#125;;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>利用性质优化一下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:    \n    vector&lt;vector&lt;int&gt;&gt; map;\n    vector&lt;int&gt; degree;\n    vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;\n       map.resize(n);\n       degree.resize(n);\n       for(int i &#x3D; 0; i &lt; edges.size(); ++i)&#123;\n           int x &#x3D; edges[i][0];\n           int y &#x3D; edges[i][1];\n            map[x].emplace_back(y);\n            map[y].emplace_back(x);\n            degree[x]++;\n            degree[y]++;\n       &#125;\n       queue&lt;int&gt; que;\n       int m &#x3D; n;\n        for(int i &#x3D; 0;i &lt; n; ++i)&#123;\n            if(degree[i] &#x3D;&#x3D; 1)&#123;\n                que.push(i);\n            &#125;            \n        &#125;\n        vector&lt;int&gt; root;\n        while(m &gt; 2)&#123;            \n            m -&#x3D; que.size();\n            int size &#x3D; que.size();\n            for(int i &#x3D; 0; i &lt; size; ++i)&#123;                \n                int u &#x3D; que.front();                \n                que.pop();\n                for(auto v : map[u])&#123;\n                    degree[v]--;\n                    if(degree[v] &#x3D;&#x3D; 1)&#123;\n                       que.push(v);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n\n        if(root.size() &#x3D;&#x3D; 0)\n        while(que.size())&#123;\n            root.push_back(que.front());\n            que.pop();\n        &#125;\n        if(n &#x3D;&#x3D; 1) root.push_back(0);\n        return root;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"331. Verify Preorder Serialization of a Binary Tree","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-12T06:54:28.000Z","_content":"\n\n\n# [331. Verify Preorder Serialization of a Binary Tree](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)\n\n\n\n\n## 思路：\n\n\n\n1. 按照字符串提供的数据按前序遍历伪建树，如果用完了所有字符就建树成功。\n2. 前序遍历允许我们的用栈记录当前节点以及之前节点应该生长的分支数，比如碰到一个数字，上一个节点的减一分支数，插入一个当点节点的分支数2。遍历过程中，栈为空或者遍历后，字符数还有剩余，显然建树失败。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n````c++\nclass Solution {\npublic:\n    bool isValidSerialization(string preorder) {\n        int pos = 0;\n        // if(preorder)\n        return isValidSerializationCore(preorder, pos) && pos == preorder.size() - 1; //完成条件：可以构建出一棵树，并且每个字符都使用到\n    }\n\n\n    bool isValidSerializationCore(string &preorder, int &pos) {\n        cout << pos << endl;\n        if(preorder.size() <=  pos) return false;\n        \n        if(preorder[pos] == '#')\n            return true;\n        while(isdigit(preorder[++pos])); \n        --pos;  //跳到数字的最后一个char的pos\n\n        if(isValidSerializationCore(preorder, pos += 2) && isValidSerializationCore(preorder, pos += 2)) return true;\n        return false;\n    }\n\n\n};\n````\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    bool isValidSerialization(string preorder) {\n        int pos = 0;\n        stack<int> post;\n        post.push(1);\n        while(pos < preorder.size()){\n            cout << pos <<  ' ' << post.size() << endl;\n            if(post.size() == 0) return false;\n            if(preorder[pos] == ',') ++pos;\n            else if(preorder[pos] == '#'){ \n                ++pos;               \n                if(--post.top() == 0){                    \n                    post.pop();\n                }\n            }else if(isdigit(preorder[pos])){                \n                if(--post.top() == 0){                    \n                    post.pop();\n                }\n                post.push(2);                \n                while(isdigit(preorder[++pos]));\n            }\n        }\n        return post.size() == 0;\n    }\n\n\n\n};\n```\n\n","source":"_posts/刷题/数据结构/树/331-Verify-Preorder-Serialization-of-a-Binary-Tree.md","raw":"---\ntitle: 331. Verify Preorder Serialization of a Binary Tree\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-12 14:54:28\ntags:\ncategories:\n---\n\n\n\n# [331. Verify Preorder Serialization of a Binary Tree](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)\n\n\n\n\n## 思路：\n\n\n\n1. 按照字符串提供的数据按前序遍历伪建树，如果用完了所有字符就建树成功。\n2. 前序遍历允许我们的用栈记录当前节点以及之前节点应该生长的分支数，比如碰到一个数字，上一个节点的减一分支数，插入一个当点节点的分支数2。遍历过程中，栈为空或者遍历后，字符数还有剩余，显然建树失败。\n\n<!-- more -->\n\n## 代码：\n\n\n\n\n\n\n````c++\nclass Solution {\npublic:\n    bool isValidSerialization(string preorder) {\n        int pos = 0;\n        // if(preorder)\n        return isValidSerializationCore(preorder, pos) && pos == preorder.size() - 1; //完成条件：可以构建出一棵树，并且每个字符都使用到\n    }\n\n\n    bool isValidSerializationCore(string &preorder, int &pos) {\n        cout << pos << endl;\n        if(preorder.size() <=  pos) return false;\n        \n        if(preorder[pos] == '#')\n            return true;\n        while(isdigit(preorder[++pos])); \n        --pos;  //跳到数字的最后一个char的pos\n\n        if(isValidSerializationCore(preorder, pos += 2) && isValidSerializationCore(preorder, pos += 2)) return true;\n        return false;\n    }\n\n\n};\n````\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    bool isValidSerialization(string preorder) {\n        int pos = 0;\n        stack<int> post;\n        post.push(1);\n        while(pos < preorder.size()){\n            cout << pos <<  ' ' << post.size() << endl;\n            if(post.size() == 0) return false;\n            if(preorder[pos] == ',') ++pos;\n            else if(preorder[pos] == '#'){ \n                ++pos;               \n                if(--post.top() == 0){                    \n                    post.pop();\n                }\n            }else if(isdigit(preorder[pos])){                \n                if(--post.top() == 0){                    \n                    post.pop();\n                }\n                post.push(2);                \n                while(isdigit(preorder[++pos]));\n            }\n        }\n        return post.size() == 0;\n    }\n\n\n\n};\n```\n\n","slug":"刷题/数据结构/树/331-Verify-Preorder-Serialization-of-a-Binary-Tree","published":1,"updated":"2021-03-12T07:40:09.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7g005jl5uofcgadjjr","content":"<h1 id=\"331-Verify-Preorder-Serialization-of-a-Binary-Tree\"><a href=\"#331-Verify-Preorder-Serialization-of-a-Binary-Tree\" class=\"headerlink\" title=\"331. Verify Preorder Serialization of a Binary Tree\"></a><a href=\"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/\">331. Verify Preorder Serialization of a Binary Tree</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>按照字符串提供的数据按前序遍历伪建树，如果用完了所有字符就建树成功。</li>\n<li>前序遍历允许我们的用栈记录当前节点以及之前节点应该生长的分支数，比如碰到一个数字，上一个节点的减一分支数，插入一个当点节点的分支数2。遍历过程中，栈为空或者遍历后，字符数还有剩余，显然建树失败。</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isValidSerialization(string preorder) &#123;\n        int pos &#x3D; 0;\n        &#x2F;&#x2F; if(preorder)\n        return isValidSerializationCore(preorder, pos) &amp;&amp; pos &#x3D;&#x3D; preorder.size() - 1; &#x2F;&#x2F;完成条件：可以构建出一棵树，并且每个字符都使用到\n    &#125;\n\n\n    bool isValidSerializationCore(string &amp;preorder, int &amp;pos) &#123;\n        cout &lt;&lt; pos &lt;&lt; endl;\n        if(preorder.size() &lt;&#x3D;  pos) return false;\n        \n        if(preorder[pos] &#x3D;&#x3D; &#39;#&#39;)\n            return true;\n        while(isdigit(preorder[++pos])); \n        --pos;  &#x2F;&#x2F;跳到数字的最后一个char的pos\n\n        if(isValidSerializationCore(preorder, pos +&#x3D; 2) &amp;&amp; isValidSerializationCore(preorder, pos +&#x3D; 2)) return true;\n        return false;\n    &#125;\n\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isValidSerialization(string preorder) &#123;\n        int pos &#x3D; 0;\n        stack&lt;int&gt; post;\n        post.push(1);\n        while(pos &lt; preorder.size())&#123;\n            cout &lt;&lt; pos &lt;&lt;  &#39; &#39; &lt;&lt; post.size() &lt;&lt; endl;\n            if(post.size() &#x3D;&#x3D; 0) return false;\n            if(preorder[pos] &#x3D;&#x3D; &#39;,&#39;) ++pos;\n            else if(preorder[pos] &#x3D;&#x3D; &#39;#&#39;)&#123; \n                ++pos;               \n                if(--post.top() &#x3D;&#x3D; 0)&#123;                    \n                    post.pop();\n                &#125;\n            &#125;else if(isdigit(preorder[pos]))&#123;                \n                if(--post.top() &#x3D;&#x3D; 0)&#123;                    \n                    post.pop();\n                &#125;\n                post.push(2);                \n                while(isdigit(preorder[++pos]));\n            &#125;\n        &#125;\n        return post.size() &#x3D;&#x3D; 0;\n    &#125;\n\n\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3CBKMVF","excerpt":"<h1 id=\"331-Verify-Preorder-Serialization-of-a-Binary-Tree\"><a href=\"#331-Verify-Preorder-Serialization-of-a-Binary-Tree\" class=\"headerlink\" title=\"331. Verify Preorder Serialization of a Binary Tree\"></a><a href=\"https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/\">331. Verify Preorder Serialization of a Binary Tree</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>按照字符串提供的数据按前序遍历伪建树，如果用完了所有字符就建树成功。</li>\n<li>前序遍历允许我们的用栈记录当前节点以及之前节点应该生长的分支数，比如碰到一个数字，上一个节点的减一分支数，插入一个当点节点的分支数2。遍历过程中，栈为空或者遍历后，字符数还有剩余，显然建树失败。</li>\n</ol>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isValidSerialization(string preorder) &#123;\n        int pos &#x3D; 0;\n        &#x2F;&#x2F; if(preorder)\n        return isValidSerializationCore(preorder, pos) &amp;&amp; pos &#x3D;&#x3D; preorder.size() - 1; &#x2F;&#x2F;完成条件：可以构建出一棵树，并且每个字符都使用到\n    &#125;\n\n\n    bool isValidSerializationCore(string &amp;preorder, int &amp;pos) &#123;\n        cout &lt;&lt; pos &lt;&lt; endl;\n        if(preorder.size() &lt;&#x3D;  pos) return false;\n        \n        if(preorder[pos] &#x3D;&#x3D; &#39;#&#39;)\n            return true;\n        while(isdigit(preorder[++pos])); \n        --pos;  &#x2F;&#x2F;跳到数字的最后一个char的pos\n\n        if(isValidSerializationCore(preorder, pos +&#x3D; 2) &amp;&amp; isValidSerializationCore(preorder, pos +&#x3D; 2)) return true;\n        return false;\n    &#125;\n\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isValidSerialization(string preorder) &#123;\n        int pos &#x3D; 0;\n        stack&lt;int&gt; post;\n        post.push(1);\n        while(pos &lt; preorder.size())&#123;\n            cout &lt;&lt; pos &lt;&lt;  &#39; &#39; &lt;&lt; post.size() &lt;&lt; endl;\n            if(post.size() &#x3D;&#x3D; 0) return false;\n            if(preorder[pos] &#x3D;&#x3D; &#39;,&#39;) ++pos;\n            else if(preorder[pos] &#x3D;&#x3D; &#39;#&#39;)&#123; \n                ++pos;               \n                if(--post.top() &#x3D;&#x3D; 0)&#123;                    \n                    post.pop();\n                &#125;\n            &#125;else if(isdigit(preorder[pos]))&#123;                \n                if(--post.top() &#x3D;&#x3D; 0)&#123;                    \n                    post.pop();\n                &#125;\n                post.push(2);                \n                while(isdigit(preorder[++pos]));\n            &#125;\n        &#125;\n        return post.size() &#x3D;&#x3D; 0;\n    &#125;\n\n\n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"450. Delete Node in a BST","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-03T06:28:21.000Z","_content":"\n\n\n\n\n## 思路：\n\n删除一个只有一个子节点，或者没有子节点的节点，比较简单。\n\n删除有两个子节点的节点`A`，需要把找一个比`A`大的最小子节点`B`来替换该`A`。那么同时也需要递归的删除节点`B`。\n\n\n\n<!-- more -->\n\n## 代码：\n\n如果二叉树结构是父子儿子结构代码会更简单。\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void print(TreeNode* root){\n        if(!root) return;\n        print(root->left);\n        cout << root->val << \" \" ; \n        print(root->right);\n    }\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if(!root) return nullptr;\n        // print(root); cout << root->val << endl; \n        if(key > root->val){\n            root->right = deleteNode(root->right, key);\n            return root;\n        }\n        if(key < root->val){\n            root->left = deleteNode(root->left, key);            \n            return root;\n        }\n        //delete the note without right child.\n        if(!root->right){\n            TreeNode *temp = root->left;\n            delete root;\n            return temp;        \n        }\n        //delete the node with right child.\n        TreeNode* rightMinP = getMinNode(root->right);\n        TreeNode* newp = new TreeNode(rightMinP->val);\n        // recursively delete the minimum node.\n        root->right = deleteNode(root->right, rightMinP->val); //Because of updating left child link //bugs\n        // cout << \"@\" << root->val << endl;        \n        // print(root);\n        // cout << \"$\" << newp->val << endl;\n        newp->left = root->left;\n        newp->right = root->right;\n        delete root;\n        return newp;    \n    }\n\n    TreeNode * getMinNode(TreeNode* root){\n        if(!root) return nullptr;\n        TreeNode* p = root;\n        while(p->left){\n            p = p->left;\n        }\n        return p;\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/树/450-Delete-Node-in-a-BST.md","raw":"---\ntitle: 450. Delete Node in a BST\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-03 14:28:21\ntags:\ncategories:\n---\n\n\n\n\n\n## 思路：\n\n删除一个只有一个子节点，或者没有子节点的节点，比较简单。\n\n删除有两个子节点的节点`A`，需要把找一个比`A`大的最小子节点`B`来替换该`A`。那么同时也需要递归的删除节点`B`。\n\n\n\n<!-- more -->\n\n## 代码：\n\n如果二叉树结构是父子儿子结构代码会更简单。\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void print(TreeNode* root){\n        if(!root) return;\n        print(root->left);\n        cout << root->val << \" \" ; \n        print(root->right);\n    }\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if(!root) return nullptr;\n        // print(root); cout << root->val << endl; \n        if(key > root->val){\n            root->right = deleteNode(root->right, key);\n            return root;\n        }\n        if(key < root->val){\n            root->left = deleteNode(root->left, key);            \n            return root;\n        }\n        //delete the note without right child.\n        if(!root->right){\n            TreeNode *temp = root->left;\n            delete root;\n            return temp;        \n        }\n        //delete the node with right child.\n        TreeNode* rightMinP = getMinNode(root->right);\n        TreeNode* newp = new TreeNode(rightMinP->val);\n        // recursively delete the minimum node.\n        root->right = deleteNode(root->right, rightMinP->val); //Because of updating left child link //bugs\n        // cout << \"@\" << root->val << endl;        \n        // print(root);\n        // cout << \"$\" << newp->val << endl;\n        newp->left = root->left;\n        newp->right = root->right;\n        delete root;\n        return newp;    \n    }\n\n    TreeNode * getMinNode(TreeNode* root){\n        if(!root) return nullptr;\n        TreeNode* p = root;\n        while(p->left){\n            p = p->left;\n        }\n        return p;\n    }\n};\n```\n\n","slug":"刷题/数据结构/树/450-Delete-Node-in-a-BST","published":1,"updated":"2021-03-03T06:31:13.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7h005kl5uo0z1uaohi","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>删除一个只有一个子节点，或者没有子节点的节点，比较简单。</p>\n<p>删除有两个子节点的节点<code>A</code>，需要把找一个比<code>A</code>大的最小子节点<code>B</code>来替换该<code>A</code>。那么同时也需要递归的删除节点<code>B</code>。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>如果二叉树结构是父子儿子结构代码会更简单。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    void print(TreeNode* root)&#123;\n        if(!root) return;\n        print(root-&gt;left);\n        cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot; ; \n        print(root-&gt;right);\n    &#125;\n    TreeNode* deleteNode(TreeNode* root, int key) &#123;\n        if(!root) return nullptr;\n        &#x2F;&#x2F; print(root); cout &lt;&lt; root-&gt;val &lt;&lt; endl; \n        if(key &gt; root-&gt;val)&#123;\n            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);\n            return root;\n        &#125;\n        if(key &lt; root-&gt;val)&#123;\n            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);            \n            return root;\n        &#125;\n        &#x2F;&#x2F;delete the note without right child.\n        if(!root-&gt;right)&#123;\n            TreeNode *temp &#x3D; root-&gt;left;\n            delete root;\n            return temp;        \n        &#125;\n        &#x2F;&#x2F;delete the node with right child.\n        TreeNode* rightMinP &#x3D; getMinNode(root-&gt;right);\n        TreeNode* newp &#x3D; new TreeNode(rightMinP-&gt;val);\n        &#x2F;&#x2F; recursively delete the minimum node.\n        root-&gt;right &#x3D; deleteNode(root-&gt;right, rightMinP-&gt;val); &#x2F;&#x2F;Because of updating left child link &#x2F;&#x2F;bugs\n        &#x2F;&#x2F; cout &lt;&lt; &quot;@&quot; &lt;&lt; root-&gt;val &lt;&lt; endl;        \n        &#x2F;&#x2F; print(root);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;$&quot; &lt;&lt; newp-&gt;val &lt;&lt; endl;\n        newp-&gt;left &#x3D; root-&gt;left;\n        newp-&gt;right &#x3D; root-&gt;right;\n        delete root;\n        return newp;    \n    &#125;\n\n    TreeNode * getMinNode(TreeNode* root)&#123;\n        if(!root) return nullptr;\n        TreeNode* p &#x3D; root;\n        while(p-&gt;left)&#123;\n            p &#x3D; p-&gt;left;\n        &#125;\n        return p;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1RBEG6F","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>删除一个只有一个子节点，或者没有子节点的节点，比较简单。</p>\n<p>删除有两个子节点的节点<code>A</code>，需要把找一个比<code>A</code>大的最小子节点<code>B</code>来替换该<code>A</code>。那么同时也需要递归的删除节点<code>B</code>。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><p>如果二叉树结构是父子儿子结构代码会更简单。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    void print(TreeNode* root)&#123;\n        if(!root) return;\n        print(root-&gt;left);\n        cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot; ; \n        print(root-&gt;right);\n    &#125;\n    TreeNode* deleteNode(TreeNode* root, int key) &#123;\n        if(!root) return nullptr;\n        &#x2F;&#x2F; print(root); cout &lt;&lt; root-&gt;val &lt;&lt; endl; \n        if(key &gt; root-&gt;val)&#123;\n            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);\n            return root;\n        &#125;\n        if(key &lt; root-&gt;val)&#123;\n            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);            \n            return root;\n        &#125;\n        &#x2F;&#x2F;delete the note without right child.\n        if(!root-&gt;right)&#123;\n            TreeNode *temp &#x3D; root-&gt;left;\n            delete root;\n            return temp;        \n        &#125;\n        &#x2F;&#x2F;delete the node with right child.\n        TreeNode* rightMinP &#x3D; getMinNode(root-&gt;right);\n        TreeNode* newp &#x3D; new TreeNode(rightMinP-&gt;val);\n        &#x2F;&#x2F; recursively delete the minimum node.\n        root-&gt;right &#x3D; deleteNode(root-&gt;right, rightMinP-&gt;val); &#x2F;&#x2F;Because of updating left child link &#x2F;&#x2F;bugs\n        &#x2F;&#x2F; cout &lt;&lt; &quot;@&quot; &lt;&lt; root-&gt;val &lt;&lt; endl;        \n        &#x2F;&#x2F; print(root);\n        &#x2F;&#x2F; cout &lt;&lt; &quot;$&quot; &lt;&lt; newp-&gt;val &lt;&lt; endl;\n        newp-&gt;left &#x3D; root-&gt;left;\n        newp-&gt;right &#x3D; root-&gt;right;\n        delete root;\n        return newp;    \n    &#125;\n\n    TreeNode * getMinNode(TreeNode* root)&#123;\n        if(!root) return nullptr;\n        TreeNode* p &#x3D; root;\n        while(p-&gt;left)&#123;\n            p &#x3D; p-&gt;left;\n        &#125;\n        return p;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"653. Two Sum IV - Input is a BST","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-03T07:58:11.000Z","_content":"\n\n\n\n\n\n\n\n\n## 思路：\n\n\n\n利用BST性质， 前序遍历数据的同时，搜索对应的`k - val`。\n\n当然可以搜索一遍，同时`hash`遍历的数据，转化为一般的两数之和。\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        int flag = 0;\n        findSum(root, root, k, flag);\n        return flag;\n    }\n    void findSum(TreeNode* root, TreeNode* head, int k, int &flag){\n        if(!root) return;\n        findSum(root->left, head, k, flag);\n        if(root->val > (k + 1) / 2) return; //剪枝\n        TreeNode* p = findT(head, k - root->val);\n        if(p != nullptr && p != root){\n            flag = 1;\n            return;\n        }\n        findSum(root->right, head, k, flag);\n\n    }\n    TreeNode* findT(TreeNode* root, int T){\n        if(!root) return nullptr;\n        if(root->val == T) return root;\n        if(root->val < T) return findT(root->right, T);\n        else return findT(root->left, T);\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/树/653-Two-Sum-IV-Input-is-a-BST.md","raw":"---\ntitle: 653. Two Sum IV - Input is a BST\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-03 15:58:11\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n\n\n## 思路：\n\n\n\n利用BST性质， 前序遍历数据的同时，搜索对应的`k - val`。\n\n当然可以搜索一遍，同时`hash`遍历的数据，转化为一般的两数之和。\n\n\n\n<!-- more -->\n\n\n\n## 代码：\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        int flag = 0;\n        findSum(root, root, k, flag);\n        return flag;\n    }\n    void findSum(TreeNode* root, TreeNode* head, int k, int &flag){\n        if(!root) return;\n        findSum(root->left, head, k, flag);\n        if(root->val > (k + 1) / 2) return; //剪枝\n        TreeNode* p = findT(head, k - root->val);\n        if(p != nullptr && p != root){\n            flag = 1;\n            return;\n        }\n        findSum(root->right, head, k, flag);\n\n    }\n    TreeNode* findT(TreeNode* root, int T){\n        if(!root) return nullptr;\n        if(root->val == T) return root;\n        if(root->val < T) return findT(root->right, T);\n        else return findT(root->left, T);\n    }\n};\n```\n\n","slug":"刷题/数据结构/树/653-Two-Sum-IV-Input-is-a-BST","published":1,"updated":"2021-03-03T08:01:13.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7i005ll5uo3uam15en","content":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用BST性质， 前序遍历数据的同时，搜索对应的<code>k - val</code>。</p>\n<p>当然可以搜索一遍，同时<code>hash</code>遍历的数据，转化为一般的两数之和。</p>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool findTarget(TreeNode* root, int k) &#123;\n        int flag &#x3D; 0;\n        findSum(root, root, k, flag);\n        return flag;\n    &#125;\n    void findSum(TreeNode* root, TreeNode* head, int k, int &amp;flag)&#123;\n        if(!root) return;\n        findSum(root-&gt;left, head, k, flag);\n        if(root-&gt;val &gt; (k + 1) &#x2F; 2) return; &#x2F;&#x2F;剪枝\n        TreeNode* p &#x3D; findT(head, k - root-&gt;val);\n        if(p !&#x3D; nullptr &amp;&amp; p !&#x3D; root)&#123;\n            flag &#x3D; 1;\n            return;\n        &#125;\n        findSum(root-&gt;right, head, k, flag);\n\n    &#125;\n    TreeNode* findT(TreeNode* root, int T)&#123;\n        if(!root) return nullptr;\n        if(root-&gt;val &#x3D;&#x3D; T) return root;\n        if(root-&gt;val &lt; T) return findT(root-&gt;right, T);\n        else return findT(root-&gt;left, T);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3SDKCDB","excerpt":"<h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>利用BST性质， 前序遍历数据的同时，搜索对应的<code>k - val</code>。</p>\n<p>当然可以搜索一遍，同时<code>hash</code>遍历的数据，转化为一般的两数之和。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool findTarget(TreeNode* root, int k) &#123;\n        int flag &#x3D; 0;\n        findSum(root, root, k, flag);\n        return flag;\n    &#125;\n    void findSum(TreeNode* root, TreeNode* head, int k, int &amp;flag)&#123;\n        if(!root) return;\n        findSum(root-&gt;left, head, k, flag);\n        if(root-&gt;val &gt; (k + 1) &#x2F; 2) return; &#x2F;&#x2F;剪枝\n        TreeNode* p &#x3D; findT(head, k - root-&gt;val);\n        if(p !&#x3D; nullptr &amp;&amp; p !&#x3D; root)&#123;\n            flag &#x3D; 1;\n            return;\n        &#125;\n        findSum(root-&gt;right, head, k, flag);\n\n    &#125;\n    TreeNode* findT(TreeNode* root, int T)&#123;\n        if(!root) return nullptr;\n        if(root-&gt;val &#x3D;&#x3D; T) return root;\n        if(root-&gt;val &lt; T) return findT(root-&gt;right, T);\n        else return findT(root-&gt;left, T);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"654. 最大二叉树","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T06:09:42.000Z","_content":"\n<!-- more -->\n\n\n\n一个基础的递归建树就可以解决。\n\n以递归的思想处理每一个新数组，先找出最大值所在并以此值一分数组为2个数组，同时递归建树即可。\n\nNote：注意边界错误，如right到底没有没值\n\n\n\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        return constructBT(nums, 0, nums.size() - 1);\n        \n    }\n    TreeNode* constructBT(vector<int>& nums, int left, int right){\n        if(left > right)\n            return NULL;\n        \n        int index = left, nmax = nums[left];\n        for(int i = left + 1; i <= right; i++){\n            if(nmax < nums[i]){\n                nmax = nums[i];\n                index = i;\n            }\n        }\n        TreeNode* root = new TreeNode(nmax);\n        root->left = constructBT(nums, left, index - 1);\n        root->right  = constructBT(nums, index + 1, right);\n        return root;\n    }\n    \n    \n\n};\n```\n\n","source":"_posts/刷题/数据结构/树/654-最大二叉树.md","raw":"---\ntitle: 654. 最大二叉树\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 14:09:42\n---\n\n<!-- more -->\n\n\n\n一个基础的递归建树就可以解决。\n\n以递归的思想处理每一个新数组，先找出最大值所在并以此值一分数组为2个数组，同时递归建树即可。\n\nNote：注意边界错误，如right到底没有没值\n\n\n\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        return constructBT(nums, 0, nums.size() - 1);\n        \n    }\n    TreeNode* constructBT(vector<int>& nums, int left, int right){\n        if(left > right)\n            return NULL;\n        \n        int index = left, nmax = nums[left];\n        for(int i = left + 1; i <= right; i++){\n            if(nmax < nums[i]){\n                nmax = nums[i];\n                index = i;\n            }\n        }\n        TreeNode* root = new TreeNode(nmax);\n        root->left = constructBT(nums, left, index - 1);\n        root->right  = constructBT(nums, index + 1, right);\n        return root;\n    }\n    \n    \n\n};\n```\n\n","slug":"刷题/数据结构/树/654-最大二叉树","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7i005ml5uo4ddl1zhe","content":"<span id=\"more\"></span>\n\n\n\n<p>一个基础的递归建树就可以解决。</p>\n<p>以递归的思想处理每一个新数组，先找出最大值所在并以此值一分数组为2个数组，同时递归建树即可。</p>\n<p>Note：注意边界错误，如right到底没有没值</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;\n        return constructBT(nums, 0, nums.size() - 1);\n        \n    &#125;\n    TreeNode* constructBT(vector&lt;int&gt;&amp; nums, int left, int right)&#123;\n        if(left &gt; right)\n            return NULL;\n        \n        int index &#x3D; left, nmax &#x3D; nums[left];\n        for(int i &#x3D; left + 1; i &lt;&#x3D; right; i++)&#123;\n            if(nmax &lt; nums[i])&#123;\n                nmax &#x3D; nums[i];\n                index &#x3D; i;\n            &#125;\n        &#125;\n        TreeNode* root &#x3D; new TreeNode(nmax);\n        root-&gt;left &#x3D; constructBT(nums, left, index - 1);\n        root-&gt;right  &#x3D; constructBT(nums, index + 1, right);\n        return root;\n    &#125;\n    \n    \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"3QJMT4D","excerpt":"","more":"<p>一个基础的递归建树就可以解决。</p>\n<p>以递归的思想处理每一个新数组，先找出最大值所在并以此值一分数组为2个数组，同时递归建树即可。</p>\n<p>Note：注意边界错误，如right到底没有没值</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;\n        return constructBT(nums, 0, nums.size() - 1);\n        \n    &#125;\n    TreeNode* constructBT(vector&lt;int&gt;&amp; nums, int left, int right)&#123;\n        if(left &gt; right)\n            return NULL;\n        \n        int index &#x3D; left, nmax &#x3D; nums[left];\n        for(int i &#x3D; left + 1; i &lt;&#x3D; right; i++)&#123;\n            if(nmax &lt; nums[i])&#123;\n                nmax &#x3D; nums[i];\n                index &#x3D; i;\n            &#125;\n        &#125;\n        TreeNode* root &#x3D; new TreeNode(nmax);\n        root-&gt;left &#x3D; constructBT(nums, left, index - 1);\n        root-&gt;right  &#x3D; constructBT(nums, index + 1, right);\n        return root;\n    &#125;\n    \n    \n\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"897. Increasing Order Search Tree","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-04T01:09:22.000Z","_content":"\n## 思路\n\n前序遍历 + 建树\n\n<!-- more -->\n\n\n\n\n\n## 代码：\n\n\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* head;\n    TreeNode* increasingBST(TreeNode* root) {\n        TreeNode* p =  nullptr;\n        increasingBSTCore(root, p);\n        return head;\n    }\n\n    TreeNode* increasingBSTCore(TreeNode* root, TreeNode* &pre) {\n        if(!root) return nullptr;\n        increasingBSTCore(root->left, pre);\n        root->left = nullptr;\n        if(pre) pre->right = root;\n        else head = root; // The list of head;\n        pre = root;\n        increasingBSTCore(root->right, pre);\n        return root;\n    }\n};\n```\n\n\n\n","source":"_posts/刷题/数据结构/树/897-Increasing-Order-Search-Tree.md","raw":"---\ntitle: 897. Increasing Order Search Tree\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-04 09:09:22\ntags:\ncategories:\n---\n\n## 思路\n\n前序遍历 + 建树\n\n<!-- more -->\n\n\n\n\n\n## 代码：\n\n\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* head;\n    TreeNode* increasingBST(TreeNode* root) {\n        TreeNode* p =  nullptr;\n        increasingBSTCore(root, p);\n        return head;\n    }\n\n    TreeNode* increasingBSTCore(TreeNode* root, TreeNode* &pre) {\n        if(!root) return nullptr;\n        increasingBSTCore(root->left, pre);\n        root->left = nullptr;\n        if(pre) pre->right = root;\n        else head = root; // The list of head;\n        pre = root;\n        increasingBSTCore(root->right, pre);\n        return root;\n    }\n};\n```\n\n\n\n","slug":"刷题/数据结构/树/897-Increasing-Order-Search-Tree","published":1,"updated":"2021-03-04T01:10:47.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7j005nl5uofutmb63v","content":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>前序遍历 + 建树</p>\n<span id=\"more\"></span>\n\n\n\n\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* head;\n    TreeNode* increasingBST(TreeNode* root) &#123;\n        TreeNode* p &#x3D;  nullptr;\n        increasingBSTCore(root, p);\n        return head;\n    &#125;\n\n    TreeNode* increasingBSTCore(TreeNode* root, TreeNode* &amp;pre) &#123;\n        if(!root) return nullptr;\n        increasingBSTCore(root-&gt;left, pre);\n        root-&gt;left &#x3D; nullptr;\n        if(pre) pre-&gt;right &#x3D; root;\n        else head &#x3D; root; &#x2F;&#x2F; The list of head;\n        pre &#x3D; root;\n        increasingBSTCore(root-&gt;right, pre);\n        return root;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","site":{"data":{}},"abbrlink":"1C0VMHH","excerpt":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>前序遍历 + 建树</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    TreeNode* head;\n    TreeNode* increasingBST(TreeNode* root) &#123;\n        TreeNode* p &#x3D;  nullptr;\n        increasingBSTCore(root, p);\n        return head;\n    &#125;\n\n    TreeNode* increasingBSTCore(TreeNode* root, TreeNode* &amp;pre) &#123;\n        if(!root) return nullptr;\n        increasingBSTCore(root-&gt;left, pre);\n        root-&gt;left &#x3D; nullptr;\n        if(pre) pre-&gt;right &#x3D; root;\n        else head &#x3D; root; &#x2F;&#x2F; The list of head;\n        pre &#x3D; root;\n        increasingBSTCore(root-&gt;right, pre);\n        return root;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"PAT 1043 二叉树重建","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:17:52.000Z","_content":"\n<!-- more -->\n\n\n\n## 搜索二叉树的前序列推出整个二叉树或者推出后序列\n\n思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点；\n\n难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界；\n\n\n\n**PAT 1043**\n\n```\n其实有点意思\n柳神的代码比我的构思好多了\nvector<int>pre,post;\nbool isMirror;\nvoid checkPre(int root,int tail)//【root，tail】\n{\n    if(root>tail) return;//! 空节点退出\n    int i=root+1,j=tail;\n    if(!isMirror)\n    {\n        //!while退出之时 就是到了另一个子树序列的开头与结尾\n        while(i<=tail&&pre[root]>pre[i]) i++;\n        while(j>root&&pre[root]<=pre[j]) j--;//!若该序列是二叉搜索树则必有i==j+1\n    }\n    else\n    {\n        while(i<=tail&&pre[root]<=pre[i]) i++;\n        while(j>root&&pre[root]>pre[j]) j--;\n    }\n    if(i-j!=1) return;//!由于树可能不存在 需要处理异常情况\n    checkPre(root+1,j);\n    checkPre(i,tail);\n    post.push_back(pre[root]);//!前序遍历压入当前根节点；\n}\nint main()\n{\n    int n, flag = 1;\n    scanf(\"%d\",&n);\n    pre.resize(n+1);\n    for(int i=0; i<n; i++) scanf(\"%d\",&pre[i]);\n    checkPre(0,n-1);\n    if(post.size()!=n)//! 不为二、        printf(\"YES\\n\");\n        for(int i=0; i<n; i++)\n        {\n            printf(\"%d\",post[i]);\n            printf(\"%c\",i!=n-1?' ':'\\n');\n        }\n    }\n    else printf(\"NO\\n\");\n\n}\n```","source":"_posts/刷题/数据结构/树/PAT-1043-二叉树重建.md","raw":"---\ntitle: PAT 1043 二叉树重建\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:17:52\n---\n\n<!-- more -->\n\n\n\n## 搜索二叉树的前序列推出整个二叉树或者推出后序列\n\n思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点；\n\n难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界；\n\n\n\n**PAT 1043**\n\n```\n其实有点意思\n柳神的代码比我的构思好多了\nvector<int>pre,post;\nbool isMirror;\nvoid checkPre(int root,int tail)//【root，tail】\n{\n    if(root>tail) return;//! 空节点退出\n    int i=root+1,j=tail;\n    if(!isMirror)\n    {\n        //!while退出之时 就是到了另一个子树序列的开头与结尾\n        while(i<=tail&&pre[root]>pre[i]) i++;\n        while(j>root&&pre[root]<=pre[j]) j--;//!若该序列是二叉搜索树则必有i==j+1\n    }\n    else\n    {\n        while(i<=tail&&pre[root]<=pre[i]) i++;\n        while(j>root&&pre[root]>pre[j]) j--;\n    }\n    if(i-j!=1) return;//!由于树可能不存在 需要处理异常情况\n    checkPre(root+1,j);\n    checkPre(i,tail);\n    post.push_back(pre[root]);//!前序遍历压入当前根节点；\n}\nint main()\n{\n    int n, flag = 1;\n    scanf(\"%d\",&n);\n    pre.resize(n+1);\n    for(int i=0; i<n; i++) scanf(\"%d\",&pre[i]);\n    checkPre(0,n-1);\n    if(post.size()!=n)//! 不为二、        printf(\"YES\\n\");\n        for(int i=0; i<n; i++)\n        {\n            printf(\"%d\",post[i]);\n            printf(\"%c\",i!=n-1?' ':'\\n');\n        }\n    }\n    else printf(\"NO\\n\");\n\n}\n```","slug":"刷题/数据结构/树/PAT-1043-二叉树重建","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7j005ol5uoa2970boa","content":"<span id=\"more\"></span>\n\n\n\n<h2 id=\"搜索二叉树的前序列推出整个二叉树或者推出后序列\"><a href=\"#搜索二叉树的前序列推出整个二叉树或者推出后序列\" class=\"headerlink\" title=\"搜索二叉树的前序列推出整个二叉树或者推出后序列\"></a>搜索二叉树的前序列推出整个二叉树或者推出后序列</h2><p>思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点；</p>\n<p>难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界；</p>\n<p><strong>PAT 1043</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">其实有点意思\n柳神的代码比我的构思好多了\nvector&lt;int&gt;pre,post;\nbool isMirror;\nvoid checkPre(int root,int tail)&#x2F;&#x2F;【root，tail】\n&#123;\n    if(root&gt;tail) return;&#x2F;&#x2F;! 空节点退出\n    int i&#x3D;root+1,j&#x3D;tail;\n    if(!isMirror)\n    &#123;\n        &#x2F;&#x2F;!while退出之时 就是到了另一个子树序列的开头与结尾\n        while(i&lt;&#x3D;tail&amp;&amp;pre[root]&gt;pre[i]) i++;\n        while(j&gt;root&amp;&amp;pre[root]&lt;&#x3D;pre[j]) j--;&#x2F;&#x2F;!若该序列是二叉搜索树则必有i&#x3D;&#x3D;j+1\n    &#125;\n    else\n    &#123;\n        while(i&lt;&#x3D;tail&amp;&amp;pre[root]&lt;&#x3D;pre[i]) i++;\n        while(j&gt;root&amp;&amp;pre[root]&gt;pre[j]) j--;\n    &#125;\n    if(i-j!&#x3D;1) return;&#x2F;&#x2F;!由于树可能不存在 需要处理异常情况\n    checkPre(root+1,j);\n    checkPre(i,tail);\n    post.push_back(pre[root]);&#x2F;&#x2F;!前序遍历压入当前根节点；\n&#125;\nint main()\n&#123;\n    int n, flag &#x3D; 1;\n    scanf(&quot;%d&quot;,&amp;n);\n    pre.resize(n+1);\n    for(int i&#x3D;0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;pre[i]);\n    checkPre(0,n-1);\n    if(post.size()!&#x3D;n)&#x2F;&#x2F;! 不为二、        printf(&quot;YES\\n&quot;);\n        for(int i&#x3D;0; i&lt;n; i++)\n        &#123;\n            printf(&quot;%d&quot;,post[i]);\n            printf(&quot;%c&quot;,i!&#x3D;n-1?&#39; &#39;:&#39;\\n&#39;);\n        &#125;\n    &#125;\n    else printf(&quot;NO\\n&quot;);\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"7YNTD5","excerpt":"","more":"<h2 id=\"搜索二叉树的前序列推出整个二叉树或者推出后序列\"><a href=\"#搜索二叉树的前序列推出整个二叉树或者推出后序列\" class=\"headerlink\" title=\"搜索二叉树的前序列推出整个二叉树或者推出后序列\"></a>搜索二叉树的前序列推出整个二叉树或者推出后序列</h2><p>思想：利用二叉树的子树的性质，分隔开两个子树，递归的遍历根节点；</p>\n<p>难点：利用双针思想保持并判断两个区间的内容，同时确定无子树的错误和递归边界；</p>\n<p><strong>PAT 1043</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">其实有点意思\n柳神的代码比我的构思好多了\nvector&lt;int&gt;pre,post;\nbool isMirror;\nvoid checkPre(int root,int tail)&#x2F;&#x2F;【root，tail】\n&#123;\n    if(root&gt;tail) return;&#x2F;&#x2F;! 空节点退出\n    int i&#x3D;root+1,j&#x3D;tail;\n    if(!isMirror)\n    &#123;\n        &#x2F;&#x2F;!while退出之时 就是到了另一个子树序列的开头与结尾\n        while(i&lt;&#x3D;tail&amp;&amp;pre[root]&gt;pre[i]) i++;\n        while(j&gt;root&amp;&amp;pre[root]&lt;&#x3D;pre[j]) j--;&#x2F;&#x2F;!若该序列是二叉搜索树则必有i&#x3D;&#x3D;j+1\n    &#125;\n    else\n    &#123;\n        while(i&lt;&#x3D;tail&amp;&amp;pre[root]&lt;&#x3D;pre[i]) i++;\n        while(j&gt;root&amp;&amp;pre[root]&gt;pre[j]) j--;\n    &#125;\n    if(i-j!&#x3D;1) return;&#x2F;&#x2F;!由于树可能不存在 需要处理异常情况\n    checkPre(root+1,j);\n    checkPre(i,tail);\n    post.push_back(pre[root]);&#x2F;&#x2F;!前序遍历压入当前根节点；\n&#125;\nint main()\n&#123;\n    int n, flag &#x3D; 1;\n    scanf(&quot;%d&quot;,&amp;n);\n    pre.resize(n+1);\n    for(int i&#x3D;0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;pre[i]);\n    checkPre(0,n-1);\n    if(post.size()!&#x3D;n)&#x2F;&#x2F;! 不为二、        printf(&quot;YES\\n&quot;);\n        for(int i&#x3D;0; i&lt;n; i++)\n        &#123;\n            printf(&quot;%d&quot;,post[i]);\n            printf(&quot;%c&quot;,i!&#x3D;n-1?&#39; &#39;:&#39;\\n&#39;);\n        &#125;\n    &#125;\n    else printf(&quot;NO\\n&quot;);\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"PAT风格二叉树总结","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:17:11.000Z","_content":"\n<!-- more -->\n\n\n\n总结一下PAT出现的所有树的套路\n\n\n\n## 前序中序转后序\n\n```\nint post[40], n, pos = 0;\nvector<int> pre, in;\nstack<int>s;\nvoid dfs(int l1, int h1, int l2, int h2){\n    if(l1 > h1) return;\n    int k = l2;\n    for(;in[k]!=pre[l1];k++);\n    dfs(l1 + 1, l1 + k - l2, l2 , k - 1);\n    dfs(l1 + k - l2 + 1, h1, k + 1, h2);\n    post[pos++] = pre[l1];\n}\nint main(){\n    int t;\n    cin >> n;\n    for(int i =0 ;i < 2 * n; i++){\n        string a;\n        cin >> a;\n        if(a[1] == 'u'){\n            cin >> t;\n            s.push(t);\n            pre.push_back(t);\n        }else{\n            in.push_back(s.top());\n            s.pop();\n        }\n    }\n    dfs(0, n - 1, 0, n - 1);\n    for(int i = 0;i < n; i++){\n        if(i == n - 1) cout << post[i];\n        else cout << post[i] << ' ' ;\n    }\n}\n```\n\n## BST + CMT 转层序\n\n```\nint cbst[2000], n, pos = 1, in[2000];\nint dfs(int u){\n    if(u > n ) return 0;\n    dfs(u * 2);\n    cbst[u] = in[pos++];\n    dfs(u * 2 + 1);\n}\nint main(){\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> in[i];\n    }\n    sort(in + 1, in + n + 1);\n    dfs(1);\n    for(int i = 1;i <= n; i++){\n        if(i == n ) printf(\"%d\", cbst[i]);\n        else printf(\"%d \", cbst[i]);\n    }\n}\n```\n\n## 前序中序转后序\n\n```\nvector<int> in, post, pre;\nint n, flag  = 1;\nvoid dfs(int l1, int h1, int l2, int h2){\n    if(l1 >= h1){\n        if(l1 == h1) in.push_back(pre[l1]); // l1 > h1时 才能压入 否则是错误的\n        return;\n    }\n    int k = l1 + 1;\n    while(k <= h1 && pre[k] != post[h2 - 1]) k++;\n    if(k == l1 + 1)\n        flag = 0;\n    dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2  );\n    in.push_back(pre[l1]);\n    dfs(k, h1, l2 + k - l1 - 1, h2 - 1 );\n}\nint main(){\n    cin >> n;\n    post.resize(n);\n    pre.resize(n);\n    for(int i = 0; i < n; i++) cin >> pre[i];\n    for(int i = 0; i < n; i++) cin >> post[i];\n    dfs(0, n - 1, 0 , n - 1);\n    if(flag) cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n    for(int i = 0; i < n; i++)\n        if(i == n - 1) printf(\"%d\\n\", in[i]);\n        else printf(\"%d \", in[i]);\n}\n```\n\n## 层序中序转前序后序\n\n这个问题也非常的巧妙，本来是一个层次遍历划分出一个父节点，但是下一步左右子树划分却成了问题，这个算法有一次刷新了我的世界观。使用中序遍历的思想，在层次遍历中查询每一个节点的归属父节点的左子树还是右子树\n\n```\nconst ll mod = 1000000007;\nint tree[40][2], val[40], n;\nint  in[40];\nvector<int> pre, post, lay;\n\nint build(vector<int> lay, int l, int r){\n    if(l > r) return 0;\n    int k = 1;\n    while(lay[0] != in[k]) k++;\n    vector<int> llay, rlay;\n    for(int i = 1;i < lay.size(); i++){\n        int isl = 0;\n        for(int j = l; j< k; j++)\n        if(lay[i] == in[j]){\n            isl = 1;\n            break;\n        }\n        if(isl) llay.push_back(lay[i]);\n        else rlay.push_back(lay[i]);\n    }\n    pre.push_back(in[k]);\n    tree[k][0] =  build(llay, l, k - 1);\n    tree[k][1] =  build(rlay, k + 1, r);\n    post.push_back(in[k]);\n    return k;\n}\nint main(){\n    cin >> n;\n    lay.resize(n);\n    int root = 0;\n    for(int i = 0;i < n; i++) cin >> lay[i];\n    for(int i = 0;i < n; i++) cin >> in[i + 1];\n    root = build(lay, 1, n);\n    for(int i = 0;i < n;i++)\n        if(i == n - 1) printf(\"%d\\n\", pre[i]);\n        else printf(\"%d \", pre[i]);\n    for(int i = 0;i < n;i++)\n        if(i == n - 1) printf(\"%d\\n\", post[i]);\n        else printf(\"%d \", post[i]);\n}\n```\n\n## 判断完全二叉树\n\n```\nint tree[200][2], n, ingree[200], root, lastnood, flag = 1;\nint bfs(int u){\n    int tn = 1;\n    queue<int> que;\n    que.push(u);\n    while(que.size()){\n        int v = que.front(); que.pop();\n        lastnood = v;\n        if(tree[v][0] == -1){\n            if(tn != n)\n                flag = 0;\n        }else{\n            que.push(tree[v][0]);\n            tn++;\n        }\n        if(tree[v][1] == -1){\n            if(tn != n)\n                flag = 0;\n        }else{\n            que.push(tree[v][1]);\n            tn++;\n        }\n    }\n}\n\nint main(){\n    fill(tree[0], tree[0] + 200 * 2 , - 1 );\n    cin >> n;\n    for(int i = 0;i < n; i++) {\n        string a, b;\n        cin >> a >> b;\n        if(a != \"-\"){\n            int v = atoi(a.c_str());\n            tree[i][0] = v;\n            ingree[v] ++;\n        }\n        if(b != \"-\") {\n            int v = atoi(b.c_str());\n            tree[i][1] = v;\n            ingree[v] ++;\n        }\n    }\n    for(int i = 0; i < n ;i++) if(ingree[i] == 0) root = i;\n    bfs(root);\n    if(flag) cout << \"YES \" << lastnood;\n    else cout << \"NO \" << root;\n\n}\n```\n\n## 静态链表建树\n\n```\nint tree[2000][3], lay[2000], n, depest, ct = 0;\nint insert(int u, int val, int dep){\n    depest = max(depest,dep);\n//    cout << u << endl;\n    if(u == 0){\n        lay[dep] ++;\n        tree[++ct][2] = val;\n        return ct;\n    }else if(val <= tree[u][2]){\n        tree[u][0] = insert(tree[u][0], val, dep + 1);\n    }else if(val > tree[u][2]){\n        tree[u][1] = insert(tree[u][1], val, dep + 1);\n    }\n    return u;\n }\n int main()\n {\n     int root = 0, tmp;\n     cin >> n;\n     for(int i = 0;i < n;i++){\n        cin >> tmp;\n        root = insert(root, tmp, 1);\n     }\n     cout << lay[depest ] << \" + \" <<  lay[depest - 1] << \" = \" <<  lay[depest] + lay[depest - 1] << endl;\n }\n```\n\n## 判断树\n\n晴神的一道题1016\n\n```\nint tree[100][3], val[40], n,  ingree[20];\nint navln, layer[23], isct = 1, switime;\nstack<int> s;\n//avl\nint ctavl(int root){\n    if(root == 0) return 0;\n    int h1 = ctavl(tree[root][0]);\n    int h2 =  ctavl(tree[root][1]);\n    if( abs(h1 - h2) > 1) navln ++;\n    return max(h1, h2) + 1;\n}\n//层序遍历同时存储 逆层序遍历的顺序以便调整堆！\nvoid isctree(int root){\n    int nt = 1;\n    queue<int> que, lay;\n    que.push(root);\n    lay.push(1);\n    while(que.size()){\n        int u = que.front(); que.pop();\n        int ll = lay.front(); lay.pop();\n        s.push(u);\n        layer[ll] ++;\n//        cout << u << endl;\n        if( tree[u][0] ){\n            que.push(tree[u][0]);\n            lay.push(ll + 1);\n            nt ++;\n        }else if(nt != n) isct = 0;\n        if( tree[u][1] ){\n            que.push(tree[u][1]);\n            lay.push(ll + 1);\n            nt ++;\n        }else if(nt != n) isct = 0;\n    }\n}\n// 向下调整 大顶堆\nvoid downAdjust(int root){\n    for(int p = tree[root][0];p !=0; p = tree[root][0]){\n        int pp = tree[root][1];\n        if(val[pp] > val[p]) p = pp;\n        if(val[p] < val[root]) break;\n        swap( val[root], val[p]);\n        switime ++;\n        root = p;\n    }\n}\nint main(){\n    string s1, s2;\n    cin >> n;\n    for(int i = 0;i < n; i++){\n        cin >> val[i];\n    }\n    for(int i = 1;i <= n; i++){\n        cin >>  s1 >> s2;\n        if(s1 != \"-\"){\n            tree[i][0] = atoi(s1.c_str());\n            ingree[atoi(s1.c_str())]++;\n        }\n        if(s2 != \"-\"){\n            tree[i][1] = atoi(s2.c_str());\n            ingree[atoi(s2.c_str())]++;\n        }\n    }\n    int rt = -1;\n    for(int i = 0;i < n; i++)\n        if( ingree[i] == 0) rt = i;\n//    cout << rt ;\n    ctavl(rt);\n    if(navln != 0) cout << \"NOT AVL TREE!!!\\n\" <<  navln << endl;\n    else{\n        isctree(rt);\n        int p = 1, noden = 1;\n        while(noden == layer[p]){\n            noden *= 2;\n            p++;\n        }\n        if(!isct) cout << \"NOT COMPLETE TREE!!!\\n\" << p - 1 << endl;\n        else{\n            while(s.size()){\n                int u = s.top(); s.pop();\n                downAdjust(u);\n            }\n            cout << \"OHHHHH HEAP!!!\\n\" << switime << endl;\n        }\n    }\n}\n```","source":"_posts/刷题/数据结构/树/PAT风格二叉树总结.md","raw":"---\ntitle: PAT风格二叉树总结\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:17:11\n---\n\n<!-- more -->\n\n\n\n总结一下PAT出现的所有树的套路\n\n\n\n## 前序中序转后序\n\n```\nint post[40], n, pos = 0;\nvector<int> pre, in;\nstack<int>s;\nvoid dfs(int l1, int h1, int l2, int h2){\n    if(l1 > h1) return;\n    int k = l2;\n    for(;in[k]!=pre[l1];k++);\n    dfs(l1 + 1, l1 + k - l2, l2 , k - 1);\n    dfs(l1 + k - l2 + 1, h1, k + 1, h2);\n    post[pos++] = pre[l1];\n}\nint main(){\n    int t;\n    cin >> n;\n    for(int i =0 ;i < 2 * n; i++){\n        string a;\n        cin >> a;\n        if(a[1] == 'u'){\n            cin >> t;\n            s.push(t);\n            pre.push_back(t);\n        }else{\n            in.push_back(s.top());\n            s.pop();\n        }\n    }\n    dfs(0, n - 1, 0, n - 1);\n    for(int i = 0;i < n; i++){\n        if(i == n - 1) cout << post[i];\n        else cout << post[i] << ' ' ;\n    }\n}\n```\n\n## BST + CMT 转层序\n\n```\nint cbst[2000], n, pos = 1, in[2000];\nint dfs(int u){\n    if(u > n ) return 0;\n    dfs(u * 2);\n    cbst[u] = in[pos++];\n    dfs(u * 2 + 1);\n}\nint main(){\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> in[i];\n    }\n    sort(in + 1, in + n + 1);\n    dfs(1);\n    for(int i = 1;i <= n; i++){\n        if(i == n ) printf(\"%d\", cbst[i]);\n        else printf(\"%d \", cbst[i]);\n    }\n}\n```\n\n## 前序中序转后序\n\n```\nvector<int> in, post, pre;\nint n, flag  = 1;\nvoid dfs(int l1, int h1, int l2, int h2){\n    if(l1 >= h1){\n        if(l1 == h1) in.push_back(pre[l1]); // l1 > h1时 才能压入 否则是错误的\n        return;\n    }\n    int k = l1 + 1;\n    while(k <= h1 && pre[k] != post[h2 - 1]) k++;\n    if(k == l1 + 1)\n        flag = 0;\n    dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2  );\n    in.push_back(pre[l1]);\n    dfs(k, h1, l2 + k - l1 - 1, h2 - 1 );\n}\nint main(){\n    cin >> n;\n    post.resize(n);\n    pre.resize(n);\n    for(int i = 0; i < n; i++) cin >> pre[i];\n    for(int i = 0; i < n; i++) cin >> post[i];\n    dfs(0, n - 1, 0 , n - 1);\n    if(flag) cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n    for(int i = 0; i < n; i++)\n        if(i == n - 1) printf(\"%d\\n\", in[i]);\n        else printf(\"%d \", in[i]);\n}\n```\n\n## 层序中序转前序后序\n\n这个问题也非常的巧妙，本来是一个层次遍历划分出一个父节点，但是下一步左右子树划分却成了问题，这个算法有一次刷新了我的世界观。使用中序遍历的思想，在层次遍历中查询每一个节点的归属父节点的左子树还是右子树\n\n```\nconst ll mod = 1000000007;\nint tree[40][2], val[40], n;\nint  in[40];\nvector<int> pre, post, lay;\n\nint build(vector<int> lay, int l, int r){\n    if(l > r) return 0;\n    int k = 1;\n    while(lay[0] != in[k]) k++;\n    vector<int> llay, rlay;\n    for(int i = 1;i < lay.size(); i++){\n        int isl = 0;\n        for(int j = l; j< k; j++)\n        if(lay[i] == in[j]){\n            isl = 1;\n            break;\n        }\n        if(isl) llay.push_back(lay[i]);\n        else rlay.push_back(lay[i]);\n    }\n    pre.push_back(in[k]);\n    tree[k][0] =  build(llay, l, k - 1);\n    tree[k][1] =  build(rlay, k + 1, r);\n    post.push_back(in[k]);\n    return k;\n}\nint main(){\n    cin >> n;\n    lay.resize(n);\n    int root = 0;\n    for(int i = 0;i < n; i++) cin >> lay[i];\n    for(int i = 0;i < n; i++) cin >> in[i + 1];\n    root = build(lay, 1, n);\n    for(int i = 0;i < n;i++)\n        if(i == n - 1) printf(\"%d\\n\", pre[i]);\n        else printf(\"%d \", pre[i]);\n    for(int i = 0;i < n;i++)\n        if(i == n - 1) printf(\"%d\\n\", post[i]);\n        else printf(\"%d \", post[i]);\n}\n```\n\n## 判断完全二叉树\n\n```\nint tree[200][2], n, ingree[200], root, lastnood, flag = 1;\nint bfs(int u){\n    int tn = 1;\n    queue<int> que;\n    que.push(u);\n    while(que.size()){\n        int v = que.front(); que.pop();\n        lastnood = v;\n        if(tree[v][0] == -1){\n            if(tn != n)\n                flag = 0;\n        }else{\n            que.push(tree[v][0]);\n            tn++;\n        }\n        if(tree[v][1] == -1){\n            if(tn != n)\n                flag = 0;\n        }else{\n            que.push(tree[v][1]);\n            tn++;\n        }\n    }\n}\n\nint main(){\n    fill(tree[0], tree[0] + 200 * 2 , - 1 );\n    cin >> n;\n    for(int i = 0;i < n; i++) {\n        string a, b;\n        cin >> a >> b;\n        if(a != \"-\"){\n            int v = atoi(a.c_str());\n            tree[i][0] = v;\n            ingree[v] ++;\n        }\n        if(b != \"-\") {\n            int v = atoi(b.c_str());\n            tree[i][1] = v;\n            ingree[v] ++;\n        }\n    }\n    for(int i = 0; i < n ;i++) if(ingree[i] == 0) root = i;\n    bfs(root);\n    if(flag) cout << \"YES \" << lastnood;\n    else cout << \"NO \" << root;\n\n}\n```\n\n## 静态链表建树\n\n```\nint tree[2000][3], lay[2000], n, depest, ct = 0;\nint insert(int u, int val, int dep){\n    depest = max(depest,dep);\n//    cout << u << endl;\n    if(u == 0){\n        lay[dep] ++;\n        tree[++ct][2] = val;\n        return ct;\n    }else if(val <= tree[u][2]){\n        tree[u][0] = insert(tree[u][0], val, dep + 1);\n    }else if(val > tree[u][2]){\n        tree[u][1] = insert(tree[u][1], val, dep + 1);\n    }\n    return u;\n }\n int main()\n {\n     int root = 0, tmp;\n     cin >> n;\n     for(int i = 0;i < n;i++){\n        cin >> tmp;\n        root = insert(root, tmp, 1);\n     }\n     cout << lay[depest ] << \" + \" <<  lay[depest - 1] << \" = \" <<  lay[depest] + lay[depest - 1] << endl;\n }\n```\n\n## 判断树\n\n晴神的一道题1016\n\n```\nint tree[100][3], val[40], n,  ingree[20];\nint navln, layer[23], isct = 1, switime;\nstack<int> s;\n//avl\nint ctavl(int root){\n    if(root == 0) return 0;\n    int h1 = ctavl(tree[root][0]);\n    int h2 =  ctavl(tree[root][1]);\n    if( abs(h1 - h2) > 1) navln ++;\n    return max(h1, h2) + 1;\n}\n//层序遍历同时存储 逆层序遍历的顺序以便调整堆！\nvoid isctree(int root){\n    int nt = 1;\n    queue<int> que, lay;\n    que.push(root);\n    lay.push(1);\n    while(que.size()){\n        int u = que.front(); que.pop();\n        int ll = lay.front(); lay.pop();\n        s.push(u);\n        layer[ll] ++;\n//        cout << u << endl;\n        if( tree[u][0] ){\n            que.push(tree[u][0]);\n            lay.push(ll + 1);\n            nt ++;\n        }else if(nt != n) isct = 0;\n        if( tree[u][1] ){\n            que.push(tree[u][1]);\n            lay.push(ll + 1);\n            nt ++;\n        }else if(nt != n) isct = 0;\n    }\n}\n// 向下调整 大顶堆\nvoid downAdjust(int root){\n    for(int p = tree[root][0];p !=0; p = tree[root][0]){\n        int pp = tree[root][1];\n        if(val[pp] > val[p]) p = pp;\n        if(val[p] < val[root]) break;\n        swap( val[root], val[p]);\n        switime ++;\n        root = p;\n    }\n}\nint main(){\n    string s1, s2;\n    cin >> n;\n    for(int i = 0;i < n; i++){\n        cin >> val[i];\n    }\n    for(int i = 1;i <= n; i++){\n        cin >>  s1 >> s2;\n        if(s1 != \"-\"){\n            tree[i][0] = atoi(s1.c_str());\n            ingree[atoi(s1.c_str())]++;\n        }\n        if(s2 != \"-\"){\n            tree[i][1] = atoi(s2.c_str());\n            ingree[atoi(s2.c_str())]++;\n        }\n    }\n    int rt = -1;\n    for(int i = 0;i < n; i++)\n        if( ingree[i] == 0) rt = i;\n//    cout << rt ;\n    ctavl(rt);\n    if(navln != 0) cout << \"NOT AVL TREE!!!\\n\" <<  navln << endl;\n    else{\n        isctree(rt);\n        int p = 1, noden = 1;\n        while(noden == layer[p]){\n            noden *= 2;\n            p++;\n        }\n        if(!isct) cout << \"NOT COMPLETE TREE!!!\\n\" << p - 1 << endl;\n        else{\n            while(s.size()){\n                int u = s.top(); s.pop();\n                downAdjust(u);\n            }\n            cout << \"OHHHHH HEAP!!!\\n\" << switime << endl;\n        }\n    }\n}\n```","slug":"刷题/数据结构/树/PAT风格二叉树总结","published":1,"updated":"2021-01-28T14:04:37.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7k005pl5uodopl89nq","content":"<span id=\"more\"></span>\n\n\n\n<p>总结一下PAT出现的所有树的套路</p>\n<h2 id=\"前序中序转后序\"><a href=\"#前序中序转后序\" class=\"headerlink\" title=\"前序中序转后序\"></a>前序中序转后序</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int post[40], n, pos &#x3D; 0;\nvector&lt;int&gt; pre, in;\nstack&lt;int&gt;s;\nvoid dfs(int l1, int h1, int l2, int h2)&#123;\n    if(l1 &gt; h1) return;\n    int k &#x3D; l2;\n    for(;in[k]!&#x3D;pre[l1];k++);\n    dfs(l1 + 1, l1 + k - l2, l2 , k - 1);\n    dfs(l1 + k - l2 + 1, h1, k + 1, h2);\n    post[pos++] &#x3D; pre[l1];\n&#125;\nint main()&#123;\n    int t;\n    cin &gt;&gt; n;\n    for(int i &#x3D;0 ;i &lt; 2 * n; i++)&#123;\n        string a;\n        cin &gt;&gt; a;\n        if(a[1] &#x3D;&#x3D; &#39;u&#39;)&#123;\n            cin &gt;&gt; t;\n            s.push(t);\n            pre.push_back(t);\n        &#125;else&#123;\n            in.push_back(s.top());\n            s.pop();\n        &#125;\n    &#125;\n    dfs(0, n - 1, 0, n - 1);\n    for(int i &#x3D; 0;i &lt; n; i++)&#123;\n        if(i &#x3D;&#x3D; n - 1) cout &lt;&lt; post[i];\n        else cout &lt;&lt; post[i] &lt;&lt; &#39; &#39; ;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"BST-CMT-转层序\"><a href=\"#BST-CMT-转层序\" class=\"headerlink\" title=\"BST + CMT 转层序\"></a>BST + CMT 转层序</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int cbst[2000], n, pos &#x3D; 1, in[2000];\nint dfs(int u)&#123;\n    if(u &gt; n ) return 0;\n    dfs(u * 2);\n    cbst[u] &#x3D; in[pos++];\n    dfs(u * 2 + 1);\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n        cin &gt;&gt; in[i];\n    &#125;\n    sort(in + 1, in + n + 1);\n    dfs(1);\n    for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n        if(i &#x3D;&#x3D; n ) printf(&quot;%d&quot;, cbst[i]);\n        else printf(&quot;%d &quot;, cbst[i]);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"前序中序转后序-1\"><a href=\"#前序中序转后序-1\" class=\"headerlink\" title=\"前序中序转后序\"></a>前序中序转后序</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">vector&lt;int&gt; in, post, pre;\nint n, flag  &#x3D; 1;\nvoid dfs(int l1, int h1, int l2, int h2)&#123;\n    if(l1 &gt;&#x3D; h1)&#123;\n        if(l1 &#x3D;&#x3D; h1) in.push_back(pre[l1]); &#x2F;&#x2F; l1 &gt; h1时 才能压入 否则是错误的\n        return;\n    &#125;\n    int k &#x3D; l1 + 1;\n    while(k &lt;&#x3D; h1 &amp;&amp; pre[k] !&#x3D; post[h2 - 1]) k++;\n    if(k &#x3D;&#x3D; l1 + 1)\n        flag &#x3D; 0;\n    dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2  );\n    in.push_back(pre[l1]);\n    dfs(k, h1, l2 + k - l1 - 1, h2 - 1 );\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    post.resize(n);\n    pre.resize(n);\n    for(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; pre[i];\n    for(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; post[i];\n    dfs(0, n - 1, 0 , n - 1);\n    if(flag) cout &lt;&lt; &quot;Yes\\n&quot;;\n    else cout &lt;&lt; &quot;No\\n&quot;;\n    for(int i &#x3D; 0; i &lt; n; i++)\n        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\\n&quot;, in[i]);\n        else printf(&quot;%d &quot;, in[i]);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"层序中序转前序后序\"><a href=\"#层序中序转前序后序\" class=\"headerlink\" title=\"层序中序转前序后序\"></a>层序中序转前序后序</h2><p>这个问题也非常的巧妙，本来是一个层次遍历划分出一个父节点，但是下一步左右子树划分却成了问题，这个算法有一次刷新了我的世界观。使用中序遍历的思想，在层次遍历中查询每一个节点的归属父节点的左子树还是右子树</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const ll mod &#x3D; 1000000007;\nint tree[40][2], val[40], n;\nint  in[40];\nvector&lt;int&gt; pre, post, lay;\n\nint build(vector&lt;int&gt; lay, int l, int r)&#123;\n    if(l &gt; r) return 0;\n    int k &#x3D; 1;\n    while(lay[0] !&#x3D; in[k]) k++;\n    vector&lt;int&gt; llay, rlay;\n    for(int i &#x3D; 1;i &lt; lay.size(); i++)&#123;\n        int isl &#x3D; 0;\n        for(int j &#x3D; l; j&lt; k; j++)\n        if(lay[i] &#x3D;&#x3D; in[j])&#123;\n            isl &#x3D; 1;\n            break;\n        &#125;\n        if(isl) llay.push_back(lay[i]);\n        else rlay.push_back(lay[i]);\n    &#125;\n    pre.push_back(in[k]);\n    tree[k][0] &#x3D;  build(llay, l, k - 1);\n    tree[k][1] &#x3D;  build(rlay, k + 1, r);\n    post.push_back(in[k]);\n    return k;\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    lay.resize(n);\n    int root &#x3D; 0;\n    for(int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; lay[i];\n    for(int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; in[i + 1];\n    root &#x3D; build(lay, 1, n);\n    for(int i &#x3D; 0;i &lt; n;i++)\n        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\\n&quot;, pre[i]);\n        else printf(&quot;%d &quot;, pre[i]);\n    for(int i &#x3D; 0;i &lt; n;i++)\n        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\\n&quot;, post[i]);\n        else printf(&quot;%d &quot;, post[i]);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"判断完全二叉树\"><a href=\"#判断完全二叉树\" class=\"headerlink\" title=\"判断完全二叉树\"></a>判断完全二叉树</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int tree[200][2], n, ingree[200], root, lastnood, flag &#x3D; 1;\nint bfs(int u)&#123;\n    int tn &#x3D; 1;\n    queue&lt;int&gt; que;\n    que.push(u);\n    while(que.size())&#123;\n        int v &#x3D; que.front(); que.pop();\n        lastnood &#x3D; v;\n        if(tree[v][0] &#x3D;&#x3D; -1)&#123;\n            if(tn !&#x3D; n)\n                flag &#x3D; 0;\n        &#125;else&#123;\n            que.push(tree[v][0]);\n            tn++;\n        &#125;\n        if(tree[v][1] &#x3D;&#x3D; -1)&#123;\n            if(tn !&#x3D; n)\n                flag &#x3D; 0;\n        &#125;else&#123;\n            que.push(tree[v][1]);\n            tn++;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    fill(tree[0], tree[0] + 200 * 2 , - 1 );\n    cin &gt;&gt; n;\n    for(int i &#x3D; 0;i &lt; n; i++) &#123;\n        string a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        if(a !&#x3D; &quot;-&quot;)&#123;\n            int v &#x3D; atoi(a.c_str());\n            tree[i][0] &#x3D; v;\n            ingree[v] ++;\n        &#125;\n        if(b !&#x3D; &quot;-&quot;) &#123;\n            int v &#x3D; atoi(b.c_str());\n            tree[i][1] &#x3D; v;\n            ingree[v] ++;\n        &#125;\n    &#125;\n    for(int i &#x3D; 0; i &lt; n ;i++) if(ingree[i] &#x3D;&#x3D; 0) root &#x3D; i;\n    bfs(root);\n    if(flag) cout &lt;&lt; &quot;YES &quot; &lt;&lt; lastnood;\n    else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"静态链表建树\"><a href=\"#静态链表建树\" class=\"headerlink\" title=\"静态链表建树\"></a>静态链表建树</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int tree[2000][3], lay[2000], n, depest, ct &#x3D; 0;\nint insert(int u, int val, int dep)&#123;\n    depest &#x3D; max(depest,dep);\n&#x2F;&#x2F;    cout &lt;&lt; u &lt;&lt; endl;\n    if(u &#x3D;&#x3D; 0)&#123;\n        lay[dep] ++;\n        tree[++ct][2] &#x3D; val;\n        return ct;\n    &#125;else if(val &lt;&#x3D; tree[u][2])&#123;\n        tree[u][0] &#x3D; insert(tree[u][0], val, dep + 1);\n    &#125;else if(val &gt; tree[u][2])&#123;\n        tree[u][1] &#x3D; insert(tree[u][1], val, dep + 1);\n    &#125;\n    return u;\n &#125;\n int main()\n &#123;\n     int root &#x3D; 0, tmp;\n     cin &gt;&gt; n;\n     for(int i &#x3D; 0;i &lt; n;i++)&#123;\n        cin &gt;&gt; tmp;\n        root &#x3D; insert(root, tmp, 1);\n     &#125;\n     cout &lt;&lt; lay[depest ] &lt;&lt; &quot; + &quot; &lt;&lt;  lay[depest - 1] &lt;&lt; &quot; &#x3D; &quot; &lt;&lt;  lay[depest] + lay[depest - 1] &lt;&lt; endl;\n &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"判断树\"><a href=\"#判断树\" class=\"headerlink\" title=\"判断树\"></a>判断树</h2><p>晴神的一道题1016</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int tree[100][3], val[40], n,  ingree[20];\nint navln, layer[23], isct &#x3D; 1, switime;\nstack&lt;int&gt; s;\n&#x2F;&#x2F;avl\nint ctavl(int root)&#123;\n    if(root &#x3D;&#x3D; 0) return 0;\n    int h1 &#x3D; ctavl(tree[root][0]);\n    int h2 &#x3D;  ctavl(tree[root][1]);\n    if( abs(h1 - h2) &gt; 1) navln ++;\n    return max(h1, h2) + 1;\n&#125;\n&#x2F;&#x2F;层序遍历同时存储 逆层序遍历的顺序以便调整堆！\nvoid isctree(int root)&#123;\n    int nt &#x3D; 1;\n    queue&lt;int&gt; que, lay;\n    que.push(root);\n    lay.push(1);\n    while(que.size())&#123;\n        int u &#x3D; que.front(); que.pop();\n        int ll &#x3D; lay.front(); lay.pop();\n        s.push(u);\n        layer[ll] ++;\n&#x2F;&#x2F;        cout &lt;&lt; u &lt;&lt; endl;\n        if( tree[u][0] )&#123;\n            que.push(tree[u][0]);\n            lay.push(ll + 1);\n            nt ++;\n        &#125;else if(nt !&#x3D; n) isct &#x3D; 0;\n        if( tree[u][1] )&#123;\n            que.push(tree[u][1]);\n            lay.push(ll + 1);\n            nt ++;\n        &#125;else if(nt !&#x3D; n) isct &#x3D; 0;\n    &#125;\n&#125;\n&#x2F;&#x2F; 向下调整 大顶堆\nvoid downAdjust(int root)&#123;\n    for(int p &#x3D; tree[root][0];p !&#x3D;0; p &#x3D; tree[root][0])&#123;\n        int pp &#x3D; tree[root][1];\n        if(val[pp] &gt; val[p]) p &#x3D; pp;\n        if(val[p] &lt; val[root]) break;\n        swap( val[root], val[p]);\n        switime ++;\n        root &#x3D; p;\n    &#125;\n&#125;\nint main()&#123;\n    string s1, s2;\n    cin &gt;&gt; n;\n    for(int i &#x3D; 0;i &lt; n; i++)&#123;\n        cin &gt;&gt; val[i];\n    &#125;\n    for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n        cin &gt;&gt;  s1 &gt;&gt; s2;\n        if(s1 !&#x3D; &quot;-&quot;)&#123;\n            tree[i][0] &#x3D; atoi(s1.c_str());\n            ingree[atoi(s1.c_str())]++;\n        &#125;\n        if(s2 !&#x3D; &quot;-&quot;)&#123;\n            tree[i][1] &#x3D; atoi(s2.c_str());\n            ingree[atoi(s2.c_str())]++;\n        &#125;\n    &#125;\n    int rt &#x3D; -1;\n    for(int i &#x3D; 0;i &lt; n; i++)\n        if( ingree[i] &#x3D;&#x3D; 0) rt &#x3D; i;\n&#x2F;&#x2F;    cout &lt;&lt; rt ;\n    ctavl(rt);\n    if(navln !&#x3D; 0) cout &lt;&lt; &quot;NOT AVL TREE!!!\\n&quot; &lt;&lt;  navln &lt;&lt; endl;\n    else&#123;\n        isctree(rt);\n        int p &#x3D; 1, noden &#x3D; 1;\n        while(noden &#x3D;&#x3D; layer[p])&#123;\n            noden *&#x3D; 2;\n            p++;\n        &#125;\n        if(!isct) cout &lt;&lt; &quot;NOT COMPLETE TREE!!!\\n&quot; &lt;&lt; p - 1 &lt;&lt; endl;\n        else&#123;\n            while(s.size())&#123;\n                int u &#x3D; s.top(); s.pop();\n                downAdjust(u);\n            &#125;\n            cout &lt;&lt; &quot;OHHHHH HEAP!!!\\n&quot; &lt;&lt; switime &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"1EV01H","excerpt":"","more":"<p>总结一下PAT出现的所有树的套路</p>\n<h2 id=\"前序中序转后序\"><a href=\"#前序中序转后序\" class=\"headerlink\" title=\"前序中序转后序\"></a>前序中序转后序</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int post[40], n, pos &#x3D; 0;\nvector&lt;int&gt; pre, in;\nstack&lt;int&gt;s;\nvoid dfs(int l1, int h1, int l2, int h2)&#123;\n    if(l1 &gt; h1) return;\n    int k &#x3D; l2;\n    for(;in[k]!&#x3D;pre[l1];k++);\n    dfs(l1 + 1, l1 + k - l2, l2 , k - 1);\n    dfs(l1 + k - l2 + 1, h1, k + 1, h2);\n    post[pos++] &#x3D; pre[l1];\n&#125;\nint main()&#123;\n    int t;\n    cin &gt;&gt; n;\n    for(int i &#x3D;0 ;i &lt; 2 * n; i++)&#123;\n        string a;\n        cin &gt;&gt; a;\n        if(a[1] &#x3D;&#x3D; &#39;u&#39;)&#123;\n            cin &gt;&gt; t;\n            s.push(t);\n            pre.push_back(t);\n        &#125;else&#123;\n            in.push_back(s.top());\n            s.pop();\n        &#125;\n    &#125;\n    dfs(0, n - 1, 0, n - 1);\n    for(int i &#x3D; 0;i &lt; n; i++)&#123;\n        if(i &#x3D;&#x3D; n - 1) cout &lt;&lt; post[i];\n        else cout &lt;&lt; post[i] &lt;&lt; &#39; &#39; ;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"BST-CMT-转层序\"><a href=\"#BST-CMT-转层序\" class=\"headerlink\" title=\"BST + CMT 转层序\"></a>BST + CMT 转层序</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int cbst[2000], n, pos &#x3D; 1, in[2000];\nint dfs(int u)&#123;\n    if(u &gt; n ) return 0;\n    dfs(u * 2);\n    cbst[u] &#x3D; in[pos++];\n    dfs(u * 2 + 1);\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;\n        cin &gt;&gt; in[i];\n    &#125;\n    sort(in + 1, in + n + 1);\n    dfs(1);\n    for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n        if(i &#x3D;&#x3D; n ) printf(&quot;%d&quot;, cbst[i]);\n        else printf(&quot;%d &quot;, cbst[i]);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"前序中序转后序-1\"><a href=\"#前序中序转后序-1\" class=\"headerlink\" title=\"前序中序转后序\"></a>前序中序转后序</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">vector&lt;int&gt; in, post, pre;\nint n, flag  &#x3D; 1;\nvoid dfs(int l1, int h1, int l2, int h2)&#123;\n    if(l1 &gt;&#x3D; h1)&#123;\n        if(l1 &#x3D;&#x3D; h1) in.push_back(pre[l1]); &#x2F;&#x2F; l1 &gt; h1时 才能压入 否则是错误的\n        return;\n    &#125;\n    int k &#x3D; l1 + 1;\n    while(k &lt;&#x3D; h1 &amp;&amp; pre[k] !&#x3D; post[h2 - 1]) k++;\n    if(k &#x3D;&#x3D; l1 + 1)\n        flag &#x3D; 0;\n    dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2  );\n    in.push_back(pre[l1]);\n    dfs(k, h1, l2 + k - l1 - 1, h2 - 1 );\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    post.resize(n);\n    pre.resize(n);\n    for(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; pre[i];\n    for(int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; post[i];\n    dfs(0, n - 1, 0 , n - 1);\n    if(flag) cout &lt;&lt; &quot;Yes\\n&quot;;\n    else cout &lt;&lt; &quot;No\\n&quot;;\n    for(int i &#x3D; 0; i &lt; n; i++)\n        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\\n&quot;, in[i]);\n        else printf(&quot;%d &quot;, in[i]);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"层序中序转前序后序\"><a href=\"#层序中序转前序后序\" class=\"headerlink\" title=\"层序中序转前序后序\"></a>层序中序转前序后序</h2><p>这个问题也非常的巧妙，本来是一个层次遍历划分出一个父节点，但是下一步左右子树划分却成了问题，这个算法有一次刷新了我的世界观。使用中序遍历的思想，在层次遍历中查询每一个节点的归属父节点的左子树还是右子树</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const ll mod &#x3D; 1000000007;\nint tree[40][2], val[40], n;\nint  in[40];\nvector&lt;int&gt; pre, post, lay;\n\nint build(vector&lt;int&gt; lay, int l, int r)&#123;\n    if(l &gt; r) return 0;\n    int k &#x3D; 1;\n    while(lay[0] !&#x3D; in[k]) k++;\n    vector&lt;int&gt; llay, rlay;\n    for(int i &#x3D; 1;i &lt; lay.size(); i++)&#123;\n        int isl &#x3D; 0;\n        for(int j &#x3D; l; j&lt; k; j++)\n        if(lay[i] &#x3D;&#x3D; in[j])&#123;\n            isl &#x3D; 1;\n            break;\n        &#125;\n        if(isl) llay.push_back(lay[i]);\n        else rlay.push_back(lay[i]);\n    &#125;\n    pre.push_back(in[k]);\n    tree[k][0] &#x3D;  build(llay, l, k - 1);\n    tree[k][1] &#x3D;  build(rlay, k + 1, r);\n    post.push_back(in[k]);\n    return k;\n&#125;\nint main()&#123;\n    cin &gt;&gt; n;\n    lay.resize(n);\n    int root &#x3D; 0;\n    for(int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; lay[i];\n    for(int i &#x3D; 0;i &lt; n; i++) cin &gt;&gt; in[i + 1];\n    root &#x3D; build(lay, 1, n);\n    for(int i &#x3D; 0;i &lt; n;i++)\n        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\\n&quot;, pre[i]);\n        else printf(&quot;%d &quot;, pre[i]);\n    for(int i &#x3D; 0;i &lt; n;i++)\n        if(i &#x3D;&#x3D; n - 1) printf(&quot;%d\\n&quot;, post[i]);\n        else printf(&quot;%d &quot;, post[i]);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"判断完全二叉树\"><a href=\"#判断完全二叉树\" class=\"headerlink\" title=\"判断完全二叉树\"></a>判断完全二叉树</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int tree[200][2], n, ingree[200], root, lastnood, flag &#x3D; 1;\nint bfs(int u)&#123;\n    int tn &#x3D; 1;\n    queue&lt;int&gt; que;\n    que.push(u);\n    while(que.size())&#123;\n        int v &#x3D; que.front(); que.pop();\n        lastnood &#x3D; v;\n        if(tree[v][0] &#x3D;&#x3D; -1)&#123;\n            if(tn !&#x3D; n)\n                flag &#x3D; 0;\n        &#125;else&#123;\n            que.push(tree[v][0]);\n            tn++;\n        &#125;\n        if(tree[v][1] &#x3D;&#x3D; -1)&#123;\n            if(tn !&#x3D; n)\n                flag &#x3D; 0;\n        &#125;else&#123;\n            que.push(tree[v][1]);\n            tn++;\n        &#125;\n    &#125;\n&#125;\n\nint main()&#123;\n    fill(tree[0], tree[0] + 200 * 2 , - 1 );\n    cin &gt;&gt; n;\n    for(int i &#x3D; 0;i &lt; n; i++) &#123;\n        string a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        if(a !&#x3D; &quot;-&quot;)&#123;\n            int v &#x3D; atoi(a.c_str());\n            tree[i][0] &#x3D; v;\n            ingree[v] ++;\n        &#125;\n        if(b !&#x3D; &quot;-&quot;) &#123;\n            int v &#x3D; atoi(b.c_str());\n            tree[i][1] &#x3D; v;\n            ingree[v] ++;\n        &#125;\n    &#125;\n    for(int i &#x3D; 0; i &lt; n ;i++) if(ingree[i] &#x3D;&#x3D; 0) root &#x3D; i;\n    bfs(root);\n    if(flag) cout &lt;&lt; &quot;YES &quot; &lt;&lt; lastnood;\n    else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root;\n\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"静态链表建树\"><a href=\"#静态链表建树\" class=\"headerlink\" title=\"静态链表建树\"></a>静态链表建树</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">int tree[2000][3], lay[2000], n, depest, ct &#x3D; 0;\nint insert(int u, int val, int dep)&#123;\n    depest &#x3D; max(depest,dep);\n&#x2F;&#x2F;    cout &lt;&lt; u &lt;&lt; endl;\n    if(u &#x3D;&#x3D; 0)&#123;\n        lay[dep] ++;\n        tree[++ct][2] &#x3D; val;\n        return ct;\n    &#125;else if(val &lt;&#x3D; tree[u][2])&#123;\n        tree[u][0] &#x3D; insert(tree[u][0], val, dep + 1);\n    &#125;else if(val &gt; tree[u][2])&#123;\n        tree[u][1] &#x3D; insert(tree[u][1], val, dep + 1);\n    &#125;\n    return u;\n &#125;\n int main()\n &#123;\n     int root &#x3D; 0, tmp;\n     cin &gt;&gt; n;\n     for(int i &#x3D; 0;i &lt; n;i++)&#123;\n        cin &gt;&gt; tmp;\n        root &#x3D; insert(root, tmp, 1);\n     &#125;\n     cout &lt;&lt; lay[depest ] &lt;&lt; &quot; + &quot; &lt;&lt;  lay[depest - 1] &lt;&lt; &quot; &#x3D; &quot; &lt;&lt;  lay[depest] + lay[depest - 1] &lt;&lt; endl;\n &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"判断树\"><a href=\"#判断树\" class=\"headerlink\" title=\"判断树\"></a>判断树</h2><p>晴神的一道题1016</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">int tree[100][3], val[40], n,  ingree[20];\nint navln, layer[23], isct &#x3D; 1, switime;\nstack&lt;int&gt; s;\n&#x2F;&#x2F;avl\nint ctavl(int root)&#123;\n    if(root &#x3D;&#x3D; 0) return 0;\n    int h1 &#x3D; ctavl(tree[root][0]);\n    int h2 &#x3D;  ctavl(tree[root][1]);\n    if( abs(h1 - h2) &gt; 1) navln ++;\n    return max(h1, h2) + 1;\n&#125;\n&#x2F;&#x2F;层序遍历同时存储 逆层序遍历的顺序以便调整堆！\nvoid isctree(int root)&#123;\n    int nt &#x3D; 1;\n    queue&lt;int&gt; que, lay;\n    que.push(root);\n    lay.push(1);\n    while(que.size())&#123;\n        int u &#x3D; que.front(); que.pop();\n        int ll &#x3D; lay.front(); lay.pop();\n        s.push(u);\n        layer[ll] ++;\n&#x2F;&#x2F;        cout &lt;&lt; u &lt;&lt; endl;\n        if( tree[u][0] )&#123;\n            que.push(tree[u][0]);\n            lay.push(ll + 1);\n            nt ++;\n        &#125;else if(nt !&#x3D; n) isct &#x3D; 0;\n        if( tree[u][1] )&#123;\n            que.push(tree[u][1]);\n            lay.push(ll + 1);\n            nt ++;\n        &#125;else if(nt !&#x3D; n) isct &#x3D; 0;\n    &#125;\n&#125;\n&#x2F;&#x2F; 向下调整 大顶堆\nvoid downAdjust(int root)&#123;\n    for(int p &#x3D; tree[root][0];p !&#x3D;0; p &#x3D; tree[root][0])&#123;\n        int pp &#x3D; tree[root][1];\n        if(val[pp] &gt; val[p]) p &#x3D; pp;\n        if(val[p] &lt; val[root]) break;\n        swap( val[root], val[p]);\n        switime ++;\n        root &#x3D; p;\n    &#125;\n&#125;\nint main()&#123;\n    string s1, s2;\n    cin &gt;&gt; n;\n    for(int i &#x3D; 0;i &lt; n; i++)&#123;\n        cin &gt;&gt; val[i];\n    &#125;\n    for(int i &#x3D; 1;i &lt;&#x3D; n; i++)&#123;\n        cin &gt;&gt;  s1 &gt;&gt; s2;\n        if(s1 !&#x3D; &quot;-&quot;)&#123;\n            tree[i][0] &#x3D; atoi(s1.c_str());\n            ingree[atoi(s1.c_str())]++;\n        &#125;\n        if(s2 !&#x3D; &quot;-&quot;)&#123;\n            tree[i][1] &#x3D; atoi(s2.c_str());\n            ingree[atoi(s2.c_str())]++;\n        &#125;\n    &#125;\n    int rt &#x3D; -1;\n    for(int i &#x3D; 0;i &lt; n; i++)\n        if( ingree[i] &#x3D;&#x3D; 0) rt &#x3D; i;\n&#x2F;&#x2F;    cout &lt;&lt; rt ;\n    ctavl(rt);\n    if(navln !&#x3D; 0) cout &lt;&lt; &quot;NOT AVL TREE!!!\\n&quot; &lt;&lt;  navln &lt;&lt; endl;\n    else&#123;\n        isctree(rt);\n        int p &#x3D; 1, noden &#x3D; 1;\n        while(noden &#x3D;&#x3D; layer[p])&#123;\n            noden *&#x3D; 2;\n            p++;\n        &#125;\n        if(!isct) cout &lt;&lt; &quot;NOT COMPLETE TREE!!!\\n&quot; &lt;&lt; p - 1 &lt;&lt; endl;\n        else&#123;\n            while(s.size())&#123;\n                int u &#x3D; s.top(); s.pop();\n                downAdjust(u);\n            &#125;\n            cout &lt;&lt; &quot;OHHHHH HEAP!!!\\n&quot; &lt;&lt; switime &lt;&lt; endl;\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题 04.09. BST Sequences LCCI","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-04-01T08:08:51.000Z","_content":"\n\n\n\n\n\n\n\n# [面试题 04.09. BST Sequences LCCI](https://leetcode-cn.com/problems/bst-sequences-lcci/)\n\n\n\n懵树下你和我，快乐刷刷题\n\n## 思路\n\n二叉树的构建，是从根节点开始的，每构建的一个节点，就添加了一个可能两个新扩展节点，我们可以在其中任意选择一个节点新构建，如此递归下去，完成整棵树的构建。\n\n那么，我们需要模拟整棵树的构建遍历过程，用`deque`存储每次构建时可以选择的节点，递归构造。如果`deque`为空，说明建构完成，把记录构建顺序的`path`加入答案即可。建构完成后回溯进行下一个节点的构建。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n    vector<vector<int>> ansSet;\n    vector<int> path;\n    deque<TreeNode*> que;\n\npublic:\n    vector<vector<int>> BSTSequences(TreeNode* root){        \n        if(root) que.push_back(root);\n        BSTSequencesCore();\n        return ansSet;\n    }\n\n    void BSTSequencesCore() {\n        if(que.size() == 0){\n            ansSet.push_back(path);\n            return;\n        }\n        for(int i = 0, size = que.size(); i < size; ++i){\n            auto node = que.front(); \n            que.pop_front();\n            path.push_back(node->val);\n            if(node->left) que.push_back(node->left);\n            if(node->right) que.push_back(node->right);\n\n            // 选择有效节点，进入递归\n            BSTSequencesCore();\n            \n            // 回溯状态\n            path.pop_back();\n            if(node->left) que.pop_back();\n            if(node->right) que.pop_back();\n            que.push_back(node); // 回溯状态要逆序‘’\n            \n        }\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/树/面试题-04-09-BST-Sequences-LCCI.md","raw":"---\ntitle: 面试题 04.09. BST Sequences LCCI\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-04-01 16:08:51\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n\n# [面试题 04.09. BST Sequences LCCI](https://leetcode-cn.com/problems/bst-sequences-lcci/)\n\n\n\n懵树下你和我，快乐刷刷题\n\n## 思路\n\n二叉树的构建，是从根节点开始的，每构建的一个节点，就添加了一个可能两个新扩展节点，我们可以在其中任意选择一个节点新构建，如此递归下去，完成整棵树的构建。\n\n那么，我们需要模拟整棵树的构建遍历过程，用`deque`存储每次构建时可以选择的节点，递归构造。如果`deque`为空，说明建构完成，把记录构建顺序的`path`加入答案即可。建构完成后回溯进行下一个节点的构建。\n\n<!-- more -->\n\n## 代码：\n\n\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n    vector<vector<int>> ansSet;\n    vector<int> path;\n    deque<TreeNode*> que;\n\npublic:\n    vector<vector<int>> BSTSequences(TreeNode* root){        \n        if(root) que.push_back(root);\n        BSTSequencesCore();\n        return ansSet;\n    }\n\n    void BSTSequencesCore() {\n        if(que.size() == 0){\n            ansSet.push_back(path);\n            return;\n        }\n        for(int i = 0, size = que.size(); i < size; ++i){\n            auto node = que.front(); \n            que.pop_front();\n            path.push_back(node->val);\n            if(node->left) que.push_back(node->left);\n            if(node->right) que.push_back(node->right);\n\n            // 选择有效节点，进入递归\n            BSTSequencesCore();\n            \n            // 回溯状态\n            path.pop_back();\n            if(node->left) que.pop_back();\n            if(node->right) que.pop_back();\n            que.push_back(node); // 回溯状态要逆序‘’\n            \n        }\n    }\n};\n```\n\n","slug":"刷题/数据结构/树/面试题-04-09-BST-Sequences-LCCI","published":1,"updated":"2021-04-01T08:28:54.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7l005ql5uo7nnseqdm","content":"<h1 id=\"面试题-04-09-BST-Sequences-LCCI\"><a href=\"#面试题-04-09-BST-Sequences-LCCI\" class=\"headerlink\" title=\"面试题 04.09. BST Sequences LCCI\"></a><a href=\"https://leetcode-cn.com/problems/bst-sequences-lcci/\">面试题 04.09. BST Sequences LCCI</a></h1><p>懵树下你和我，快乐刷刷题</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二叉树的构建，是从根节点开始的，每构建的一个节点，就添加了一个可能两个新扩展节点，我们可以在其中任意选择一个节点新构建，如此递归下去，完成整棵树的构建。</p>\n<p>那么，我们需要模拟整棵树的构建遍历过程，用<code>deque</code>存储每次构建时可以选择的节点，递归构造。如果<code>deque</code>为空，说明建构完成，把记录构建顺序的<code>path</code>加入答案即可。建构完成后回溯进行下一个节点的构建。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    vector&lt;vector&lt;int&gt;&gt; ansSet;\n    vector&lt;int&gt; path;\n    deque&lt;TreeNode*&gt; que;\n\npublic:\n    vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root)&#123;        \n        if(root) que.push_back(root);\n        BSTSequencesCore();\n        return ansSet;\n    &#125;\n\n    void BSTSequencesCore() &#123;\n        if(que.size() &#x3D;&#x3D; 0)&#123;\n            ansSet.push_back(path);\n            return;\n        &#125;\n        for(int i &#x3D; 0, size &#x3D; que.size(); i &lt; size; ++i)&#123;\n            auto node &#x3D; que.front(); \n            que.pop_front();\n            path.push_back(node-&gt;val);\n            if(node-&gt;left) que.push_back(node-&gt;left);\n            if(node-&gt;right) que.push_back(node-&gt;right);\n\n            &#x2F;&#x2F; 选择有效节点，进入递归\n            BSTSequencesCore();\n            \n            &#x2F;&#x2F; 回溯状态\n            path.pop_back();\n            if(node-&gt;left) que.pop_back();\n            if(node-&gt;right) que.pop_back();\n            que.push_back(node); &#x2F;&#x2F; 回溯状态要逆序‘’\n            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"T0SQSD","excerpt":"<h1 id=\"面试题-04-09-BST-Sequences-LCCI\"><a href=\"#面试题-04-09-BST-Sequences-LCCI\" class=\"headerlink\" title=\"面试题 04.09. BST Sequences LCCI\"></a><a href=\"https://leetcode-cn.com/problems/bst-sequences-lcci/\">面试题 04.09. BST Sequences LCCI</a></h1><p>懵树下你和我，快乐刷刷题</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>二叉树的构建，是从根节点开始的，每构建的一个节点，就添加了一个可能两个新扩展节点，我们可以在其中任意选择一个节点新构建，如此递归下去，完成整棵树的构建。</p>\n<p>那么，我们需要模拟整棵树的构建遍历过程，用<code>deque</code>存储每次构建时可以选择的节点，递归构造。如果<code>deque</code>为空，说明建构完成，把记录构建顺序的<code>path</code>加入答案即可。建构完成后回溯进行下一个节点的构建。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\n    vector&lt;vector&lt;int&gt;&gt; ansSet;\n    vector&lt;int&gt; path;\n    deque&lt;TreeNode*&gt; que;\n\npublic:\n    vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root)&#123;        \n        if(root) que.push_back(root);\n        BSTSequencesCore();\n        return ansSet;\n    &#125;\n\n    void BSTSequencesCore() &#123;\n        if(que.size() &#x3D;&#x3D; 0)&#123;\n            ansSet.push_back(path);\n            return;\n        &#125;\n        for(int i &#x3D; 0, size &#x3D; que.size(); i &lt; size; ++i)&#123;\n            auto node &#x3D; que.front(); \n            que.pop_front();\n            path.push_back(node-&gt;val);\n            if(node-&gt;left) que.push_back(node-&gt;left);\n            if(node-&gt;right) que.push_back(node-&gt;right);\n\n            &#x2F;&#x2F; 选择有效节点，进入递归\n            BSTSequencesCore();\n            \n            &#x2F;&#x2F; 回溯状态\n            path.pop_back();\n            if(node-&gt;left) que.pop_back();\n            if(node-&gt;right) que.pop_back();\n            que.push_back(node); &#x2F;&#x2F; 回溯状态要逆序‘’\n            \n        &#125;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"148. 排序链表","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-03-31T02:46:40.000Z","_content":"\n\n\n\n\n\n\n# [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)\n\n\n\n我写过最累最烦的链表题，循环归并排序思路比较好想，但是容易错，非常容易错，哈哈。\n\n<!-- more -->\n\n\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* midNode(ListNode* head, ListNode* end = nullptr){\n        ListNode* fastp  = head, *slowp = head;\n        while(fastp){\n            fastp = fastp->next;\n            if(fastp) fastp = fastp->next;\n            slowp = slowp->next;\n        }\n        return slowp;\n    }\n\n    ListNode *split(ListNode* node, int nums){\n        ListNode* p = node;\n        if(p == nullptr) return nullptr;\n        int k = 1;\n        while(k < nums && p->next){\n            p = p->next;\n            ++k;\n        }\n        ListNode *ans =  p->next;\n        p->next = nullptr;\n        return ans;\n    }\n\n    ListNode* merger(ListNode* heada, ListNode* headb, ListNode* &pre) {\n        ListNode *p1 = heada, *p2 = headb, *head = new ListNode(), *p = head;\n        if(!p1 && !p2){\n            pre->next = nullptr;\n            return nullptr;\n        }\n        while(p1 && p2){\n            if(p1->val < p2->val){\n                p->next = p1;\n                p1 = p1->next;\n            }else{\n                p->next = p2;\n                p2 = p2->next;\n            }\n            p = p->next;\n        }\n        p->next = p1 ? p1 : p2;\n        while(p->next) p = p->next;\n        \n        // link prenode and endnode.\n        if(pre) pre->next = head->next;\n        pre = p;\n        // return merged list head;\n        p = head->next;\n        delete head;\n        //print(p, \"p->next\");\n        return p;\n    }\n\n    ListNode* sortList(ListNode* head) {\n        ListNode* p1 = head, *p2 = head;\n        ListNode * prehead = new ListNode();\n        prehead->next = head;\n        int flag = 1;\n        for(int i = 1; flag; i *= 2){\n            ListNode* pre = prehead;\n            ListNode * nextp1 = prehead->next; // #bug: nextp1 = head； but head has be reset.\n            flag = 0;\n            p2 = prehead; // @reset p2\n            //print(prehead, \"@\");\n            while(p2){\n                flag++;\n                p1 = nextp1;\n                p2 = split(p1, i);                \n                nextp1 = split(p2, i);\n               // print(p1, \"p1\");\n               //  print(p2, \"p2\");\n                merger(p1, p2, pre); // merge and link.\n               // print(prehead, \"#\");\n                if(p1 == prehead->next && !p2 && flag == 1) flag = 0;\n            }\n\n        }\n        head = prehead->next;\n        delete prehead;\n        return head;\n    }\n\n    void print(ListNode* head, string s = \"@\"){\n        cout << s  + \":\" ;\n        while(head){\n            cout << head->val << ' ';\n            head = head->next;\n        } \n        cout <<endl;\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/链表\n/148-排序链表.md","raw":"---\ntitle: 148. 排序链表\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ndate: 2021-03-31 10:46:40\ntags:\ncategories:\n---\n\n\n\n\n\n\n\n# [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)\n\n\n\n我写过最累最烦的链表题，循环归并排序思路比较好想，但是容易错，非常容易错，哈哈。\n\n<!-- more -->\n\n\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* midNode(ListNode* head, ListNode* end = nullptr){\n        ListNode* fastp  = head, *slowp = head;\n        while(fastp){\n            fastp = fastp->next;\n            if(fastp) fastp = fastp->next;\n            slowp = slowp->next;\n        }\n        return slowp;\n    }\n\n    ListNode *split(ListNode* node, int nums){\n        ListNode* p = node;\n        if(p == nullptr) return nullptr;\n        int k = 1;\n        while(k < nums && p->next){\n            p = p->next;\n            ++k;\n        }\n        ListNode *ans =  p->next;\n        p->next = nullptr;\n        return ans;\n    }\n\n    ListNode* merger(ListNode* heada, ListNode* headb, ListNode* &pre) {\n        ListNode *p1 = heada, *p2 = headb, *head = new ListNode(), *p = head;\n        if(!p1 && !p2){\n            pre->next = nullptr;\n            return nullptr;\n        }\n        while(p1 && p2){\n            if(p1->val < p2->val){\n                p->next = p1;\n                p1 = p1->next;\n            }else{\n                p->next = p2;\n                p2 = p2->next;\n            }\n            p = p->next;\n        }\n        p->next = p1 ? p1 : p2;\n        while(p->next) p = p->next;\n        \n        // link prenode and endnode.\n        if(pre) pre->next = head->next;\n        pre = p;\n        // return merged list head;\n        p = head->next;\n        delete head;\n        //print(p, \"p->next\");\n        return p;\n    }\n\n    ListNode* sortList(ListNode* head) {\n        ListNode* p1 = head, *p2 = head;\n        ListNode * prehead = new ListNode();\n        prehead->next = head;\n        int flag = 1;\n        for(int i = 1; flag; i *= 2){\n            ListNode* pre = prehead;\n            ListNode * nextp1 = prehead->next; // #bug: nextp1 = head； but head has be reset.\n            flag = 0;\n            p2 = prehead; // @reset p2\n            //print(prehead, \"@\");\n            while(p2){\n                flag++;\n                p1 = nextp1;\n                p2 = split(p1, i);                \n                nextp1 = split(p2, i);\n               // print(p1, \"p1\");\n               //  print(p2, \"p2\");\n                merger(p1, p2, pre); // merge and link.\n               // print(prehead, \"#\");\n                if(p1 == prehead->next && !p2 && flag == 1) flag = 0;\n            }\n\n        }\n        head = prehead->next;\n        delete prehead;\n        return head;\n    }\n\n    void print(ListNode* head, string s = \"@\"){\n        cout << s  + \":\" ;\n        while(head){\n            cout << head->val << ' ';\n            head = head->next;\n        } \n        cout <<endl;\n    }\n};\n```\n\n","slug":"刷题-数据结构-链表-148-排序链表","published":1,"updated":"2021-04-01T08:30:07.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7m005rl5uo3ltw3ko9","content":"<h1 id=\"148-排序链表\"><a href=\"#148-排序链表\" class=\"headerlink\" title=\"148. 排序链表\"></a><a href=\"https://leetcode-cn.com/problems/sort-list/\">148. 排序链表</a></h1><p>我写过最累最烦的链表题，循环归并排序思路比较好想，但是容易错，非常容易错，哈哈。</p>\n<span id=\"more\"></span>\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* midNode(ListNode* head, ListNode* end &#x3D; nullptr)&#123;\n        ListNode* fastp  &#x3D; head, *slowp &#x3D; head;\n        while(fastp)&#123;\n            fastp &#x3D; fastp-&gt;next;\n            if(fastp) fastp &#x3D; fastp-&gt;next;\n            slowp &#x3D; slowp-&gt;next;\n        &#125;\n        return slowp;\n    &#125;\n\n    ListNode *split(ListNode* node, int nums)&#123;\n        ListNode* p &#x3D; node;\n        if(p &#x3D;&#x3D; nullptr) return nullptr;\n        int k &#x3D; 1;\n        while(k &lt; nums &amp;&amp; p-&gt;next)&#123;\n            p &#x3D; p-&gt;next;\n            ++k;\n        &#125;\n        ListNode *ans &#x3D;  p-&gt;next;\n        p-&gt;next &#x3D; nullptr;\n        return ans;\n    &#125;\n\n    ListNode* merger(ListNode* heada, ListNode* headb, ListNode* &amp;pre) &#123;\n        ListNode *p1 &#x3D; heada, *p2 &#x3D; headb, *head &#x3D; new ListNode(), *p &#x3D; head;\n        if(!p1 &amp;&amp; !p2)&#123;\n            pre-&gt;next &#x3D; nullptr;\n            return nullptr;\n        &#125;\n        while(p1 &amp;&amp; p2)&#123;\n            if(p1-&gt;val &lt; p2-&gt;val)&#123;\n                p-&gt;next &#x3D; p1;\n                p1 &#x3D; p1-&gt;next;\n            &#125;else&#123;\n                p-&gt;next &#x3D; p2;\n                p2 &#x3D; p2-&gt;next;\n            &#125;\n            p &#x3D; p-&gt;next;\n        &#125;\n        p-&gt;next &#x3D; p1 ? p1 : p2;\n        while(p-&gt;next) p &#x3D; p-&gt;next;\n        \n        &#x2F;&#x2F; link prenode and endnode.\n        if(pre) pre-&gt;next &#x3D; head-&gt;next;\n        pre &#x3D; p;\n        &#x2F;&#x2F; return merged list head;\n        p &#x3D; head-&gt;next;\n        delete head;\n        &#x2F;&#x2F;print(p, &quot;p-&gt;next&quot;);\n        return p;\n    &#125;\n\n    ListNode* sortList(ListNode* head) &#123;\n        ListNode* p1 &#x3D; head, *p2 &#x3D; head;\n        ListNode * prehead &#x3D; new ListNode();\n        prehead-&gt;next &#x3D; head;\n        int flag &#x3D; 1;\n        for(int i &#x3D; 1; flag; i *&#x3D; 2)&#123;\n            ListNode* pre &#x3D; prehead;\n            ListNode * nextp1 &#x3D; prehead-&gt;next; &#x2F;&#x2F; #bug: nextp1 &#x3D; head； but head has be reset.\n            flag &#x3D; 0;\n            p2 &#x3D; prehead; &#x2F;&#x2F; @reset p2\n            &#x2F;&#x2F;print(prehead, &quot;@&quot;);\n            while(p2)&#123;\n                flag++;\n                p1 &#x3D; nextp1;\n                p2 &#x3D; split(p1, i);                \n                nextp1 &#x3D; split(p2, i);\n               &#x2F;&#x2F; print(p1, &quot;p1&quot;);\n               &#x2F;&#x2F;  print(p2, &quot;p2&quot;);\n                merger(p1, p2, pre); &#x2F;&#x2F; merge and link.\n               &#x2F;&#x2F; print(prehead, &quot;#&quot;);\n                if(p1 &#x3D;&#x3D; prehead-&gt;next &amp;&amp; !p2 &amp;&amp; flag &#x3D;&#x3D; 1) flag &#x3D; 0;\n            &#125;\n\n        &#125;\n        head &#x3D; prehead-&gt;next;\n        delete prehead;\n        return head;\n    &#125;\n\n    void print(ListNode* head, string s &#x3D; &quot;@&quot;)&#123;\n        cout &lt;&lt; s  + &quot;:&quot; ;\n        while(head)&#123;\n            cout &lt;&lt; head-&gt;val &lt;&lt; &#39; &#39;;\n            head &#x3D; head-&gt;next;\n        &#125; \n        cout &lt;&lt;endl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1W3BVHT","excerpt":"<h1 id=\"148-排序链表\"><a href=\"#148-排序链表\" class=\"headerlink\" title=\"148. 排序链表\"></a><a href=\"https://leetcode-cn.com/problems/sort-list/\">148. 排序链表</a></h1><p>我写过最累最烦的链表题，循环归并排序思路比较好想，但是容易错，非常容易错，哈哈。</p>","more":"<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* midNode(ListNode* head, ListNode* end &#x3D; nullptr)&#123;\n        ListNode* fastp  &#x3D; head, *slowp &#x3D; head;\n        while(fastp)&#123;\n            fastp &#x3D; fastp-&gt;next;\n            if(fastp) fastp &#x3D; fastp-&gt;next;\n            slowp &#x3D; slowp-&gt;next;\n        &#125;\n        return slowp;\n    &#125;\n\n    ListNode *split(ListNode* node, int nums)&#123;\n        ListNode* p &#x3D; node;\n        if(p &#x3D;&#x3D; nullptr) return nullptr;\n        int k &#x3D; 1;\n        while(k &lt; nums &amp;&amp; p-&gt;next)&#123;\n            p &#x3D; p-&gt;next;\n            ++k;\n        &#125;\n        ListNode *ans &#x3D;  p-&gt;next;\n        p-&gt;next &#x3D; nullptr;\n        return ans;\n    &#125;\n\n    ListNode* merger(ListNode* heada, ListNode* headb, ListNode* &amp;pre) &#123;\n        ListNode *p1 &#x3D; heada, *p2 &#x3D; headb, *head &#x3D; new ListNode(), *p &#x3D; head;\n        if(!p1 &amp;&amp; !p2)&#123;\n            pre-&gt;next &#x3D; nullptr;\n            return nullptr;\n        &#125;\n        while(p1 &amp;&amp; p2)&#123;\n            if(p1-&gt;val &lt; p2-&gt;val)&#123;\n                p-&gt;next &#x3D; p1;\n                p1 &#x3D; p1-&gt;next;\n            &#125;else&#123;\n                p-&gt;next &#x3D; p2;\n                p2 &#x3D; p2-&gt;next;\n            &#125;\n            p &#x3D; p-&gt;next;\n        &#125;\n        p-&gt;next &#x3D; p1 ? p1 : p2;\n        while(p-&gt;next) p &#x3D; p-&gt;next;\n        \n        &#x2F;&#x2F; link prenode and endnode.\n        if(pre) pre-&gt;next &#x3D; head-&gt;next;\n        pre &#x3D; p;\n        &#x2F;&#x2F; return merged list head;\n        p &#x3D; head-&gt;next;\n        delete head;\n        &#x2F;&#x2F;print(p, &quot;p-&gt;next&quot;);\n        return p;\n    &#125;\n\n    ListNode* sortList(ListNode* head) &#123;\n        ListNode* p1 &#x3D; head, *p2 &#x3D; head;\n        ListNode * prehead &#x3D; new ListNode();\n        prehead-&gt;next &#x3D; head;\n        int flag &#x3D; 1;\n        for(int i &#x3D; 1; flag; i *&#x3D; 2)&#123;\n            ListNode* pre &#x3D; prehead;\n            ListNode * nextp1 &#x3D; prehead-&gt;next; &#x2F;&#x2F; #bug: nextp1 &#x3D; head； but head has be reset.\n            flag &#x3D; 0;\n            p2 &#x3D; prehead; &#x2F;&#x2F; @reset p2\n            &#x2F;&#x2F;print(prehead, &quot;@&quot;);\n            while(p2)&#123;\n                flag++;\n                p1 &#x3D; nextp1;\n                p2 &#x3D; split(p1, i);                \n                nextp1 &#x3D; split(p2, i);\n               &#x2F;&#x2F; print(p1, &quot;p1&quot;);\n               &#x2F;&#x2F;  print(p2, &quot;p2&quot;);\n                merger(p1, p2, pre); &#x2F;&#x2F; merge and link.\n               &#x2F;&#x2F; print(prehead, &quot;#&quot;);\n                if(p1 &#x3D;&#x3D; prehead-&gt;next &amp;&amp; !p2 &amp;&amp; flag &#x3D;&#x3D; 1) flag &#x3D; 0;\n            &#125;\n\n        &#125;\n        head &#x3D; prehead-&gt;next;\n        delete prehead;\n        return head;\n    &#125;\n\n    void print(ListNode* head, string s &#x3D; &quot;@&quot;)&#123;\n        cout &lt;&lt; s  + &quot;:&quot; ;\n        while(head)&#123;\n            cout &lt;&lt; head-&gt;val &lt;&lt; &#39; &#39;;\n            head &#x3D; head-&gt;next;\n        &#125; \n        cout &lt;&lt;endl;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"42. Trapping Rain Water","thumbnail":"http://static.come2rss.xyz/黑色幽默.jpg","toc":true,"top":10,"date":"2021-04-16T09:58:37.000Z","_content":"\n\n\n\n\n# [42. Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n\n\n## 思路：\n\n这题蛮hard的，挺考验思路；\n\n思考一下，下雨的过程，水往低处流，一点一点汇聚起来，逐渐逐渐升高水面。我们是否可以在先求出低水平面的水量，在此之上求出高水平面的水量。\n\n> `43234`中就有两个水沟：`2`上的`1*1`的水沟，和`323`上的`3*1`水沟。\n\n用这种想法，我们只需要遍历得到一个水平面的右边界，记录该水平面的左边界，获取低水平面的高度，填充下新水平面的水量即可。\n\n最小值单调栈`S`可以帮助我们维持左边界的`pos`，记`S`的栈顶元素指向的高度为`a`，`a`之下的元素指向的高度为`b`。其性质必然有`a > b`。遍历到高度`c`，\n\n- 若`c < a`，则对蓄水没有影响。\n- 如果`c > b`，则三者形成了一个水沟，计算🦁式子见代码，并且该水沟可能可以继续往上“看看”，在适当条件上看看单调栈，循环填充高水位水沟。\n- 如果`c==a`，则显然应该替换掉`a`，因为单调栈维持的是等高水沟的最新端，试想`33323`。\n\n经过上述填充过程，单调栈的性质也要维护一下，详细见代码。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        if(height.size() <= 1) return 0;\n        stack<int> sck;\n        int amount = 0;\n        for(int i = 0; i < height.size(); ++i){\n            while(sck.size() >= 2 && height[sck.top()] <= height[i]){\n                int lowh = height[sck.top()]; \n                sck.pop();\n                amount += (i - sck.top() - 1) * (min(height[i], height[sck.top()]) - lowh);\n              //  cout << amount << endl;\n            }\n            while(!sck.empty() && height[sck.top()] <= height[i]) sck.pop();  // <= 按次序出现的等高的山峰A,B， 明显的有AB填充了水量，下一个被填充的应该是B,所以A必须被pop\n            if(sck.empty() || height[i] < height[sck.top()]) sck.push(i);\n        }\n        return amount;\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/栈和队列/单调栈\n/42-Trapping-Rain-Water.md","raw":"---\ntitle: 42. Trapping Rain Water\nthumbnail: 'http://static.come2rss.xyz/黑色幽默.jpg'\ntoc: true\ntop: 10\ndate: 2021-04-16 17:58:37\ntags:\ncategories:\n---\n\n\n\n\n\n# [42. Trapping Rain Water](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n\n\n## 思路：\n\n这题蛮hard的，挺考验思路；\n\n思考一下，下雨的过程，水往低处流，一点一点汇聚起来，逐渐逐渐升高水面。我们是否可以在先求出低水平面的水量，在此之上求出高水平面的水量。\n\n> `43234`中就有两个水沟：`2`上的`1*1`的水沟，和`323`上的`3*1`水沟。\n\n用这种想法，我们只需要遍历得到一个水平面的右边界，记录该水平面的左边界，获取低水平面的高度，填充下新水平面的水量即可。\n\n最小值单调栈`S`可以帮助我们维持左边界的`pos`，记`S`的栈顶元素指向的高度为`a`，`a`之下的元素指向的高度为`b`。其性质必然有`a > b`。遍历到高度`c`，\n\n- 若`c < a`，则对蓄水没有影响。\n- 如果`c > b`，则三者形成了一个水沟，计算🦁式子见代码，并且该水沟可能可以继续往上“看看”，在适当条件上看看单调栈，循环填充高水位水沟。\n- 如果`c==a`，则显然应该替换掉`a`，因为单调栈维持的是等高水沟的最新端，试想`33323`。\n\n经过上述填充过程，单调栈的性质也要维护一下，详细见代码。\n\n<!-- more -->\n\n## 代码：\n\n```c++\n\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        if(height.size() <= 1) return 0;\n        stack<int> sck;\n        int amount = 0;\n        for(int i = 0; i < height.size(); ++i){\n            while(sck.size() >= 2 && height[sck.top()] <= height[i]){\n                int lowh = height[sck.top()]; \n                sck.pop();\n                amount += (i - sck.top() - 1) * (min(height[i], height[sck.top()]) - lowh);\n              //  cout << amount << endl;\n            }\n            while(!sck.empty() && height[sck.top()] <= height[i]) sck.pop();  // <= 按次序出现的等高的山峰A,B， 明显的有AB填充了水量，下一个被填充的应该是B,所以A必须被pop\n            if(sck.empty() || height[i] < height[sck.top()]) sck.push(i);\n        }\n        return amount;\n    }\n};\n```\n\n","slug":"刷题-数据结构-栈和队列-单调栈-42-Trapping-Rain-Water","published":1,"updated":"2021-04-16T10:17:05.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7m005sl5uo0aycbvxt","content":"<h1 id=\"42-Trapping-Rain-Water\"><a href=\"#42-Trapping-Rain-Water\" class=\"headerlink\" title=\"42. Trapping Rain Water\"></a><a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">42. Trapping Rain Water</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题蛮hard的，挺考验思路；</p>\n<p>思考一下，下雨的过程，水往低处流，一点一点汇聚起来，逐渐逐渐升高水面。我们是否可以在先求出低水平面的水量，在此之上求出高水平面的水量。</p>\n<blockquote>\n<p><code>43234</code>中就有两个水沟：<code>2</code>上的<code>1*1</code>的水沟，和<code>323</code>上的<code>3*1</code>水沟。</p>\n</blockquote>\n<p>用这种想法，我们只需要遍历得到一个水平面的右边界，记录该水平面的左边界，获取低水平面的高度，填充下新水平面的水量即可。</p>\n<p>最小值单调栈<code>S</code>可以帮助我们维持左边界的<code>pos</code>，记<code>S</code>的栈顶元素指向的高度为<code>a</code>，<code>a</code>之下的元素指向的高度为<code>b</code>。其性质必然有<code>a &gt; b</code>。遍历到高度<code>c</code>，</p>\n<ul>\n<li>若<code>c &lt; a</code>，则对蓄水没有影响。</li>\n<li>如果<code>c &gt; b</code>，则三者形成了一个水沟，计算🦁式子见代码，并且该水沟可能可以继续往上“看看”，在适当条件上看看单调栈，循环填充高水位水沟。</li>\n<li>如果<code>c==a</code>，则显然应该替换掉<code>a</code>，因为单调栈维持的是等高水沟的最新端，试想<code>33323</code>。</li>\n</ul>\n<p>经过上述填充过程，单调栈的性质也要维护一下，详细见代码。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        if(height.size() &lt;&#x3D; 1) return 0;\n        stack&lt;int&gt; sck;\n        int amount &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; height.size(); ++i)&#123;\n            while(sck.size() &gt;&#x3D; 2 &amp;&amp; height[sck.top()] &lt;&#x3D; height[i])&#123;\n                int lowh &#x3D; height[sck.top()]; \n                sck.pop();\n                amount +&#x3D; (i - sck.top() - 1) * (min(height[i], height[sck.top()]) - lowh);\n              &#x2F;&#x2F;  cout &lt;&lt; amount &lt;&lt; endl;\n            &#125;\n            while(!sck.empty() &amp;&amp; height[sck.top()] &lt;&#x3D; height[i]) sck.pop();  &#x2F;&#x2F; &lt;&#x3D; 按次序出现的等高的山峰A,B， 明显的有AB填充了水量，下一个被填充的应该是B,所以A必须被pop\n            if(sck.empty() || height[i] &lt; height[sck.top()]) sck.push(i);\n        &#125;\n        return amount;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"1HJZ789","excerpt":"<h1 id=\"42-Trapping-Rain-Water\"><a href=\"#42-Trapping-Rain-Water\" class=\"headerlink\" title=\"42. Trapping Rain Water\"></a><a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">42. Trapping Rain Water</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><p>这题蛮hard的，挺考验思路；</p>\n<p>思考一下，下雨的过程，水往低处流，一点一点汇聚起来，逐渐逐渐升高水面。我们是否可以在先求出低水平面的水量，在此之上求出高水平面的水量。</p>\n<blockquote>\n<p><code>43234</code>中就有两个水沟：<code>2</code>上的<code>1*1</code>的水沟，和<code>323</code>上的<code>3*1</code>水沟。</p>\n</blockquote>\n<p>用这种想法，我们只需要遍历得到一个水平面的右边界，记录该水平面的左边界，获取低水平面的高度，填充下新水平面的水量即可。</p>\n<p>最小值单调栈<code>S</code>可以帮助我们维持左边界的<code>pos</code>，记<code>S</code>的栈顶元素指向的高度为<code>a</code>，<code>a</code>之下的元素指向的高度为<code>b</code>。其性质必然有<code>a &gt; b</code>。遍历到高度<code>c</code>，</p>\n<ul>\n<li>若<code>c &lt; a</code>，则对蓄水没有影响。</li>\n<li>如果<code>c &gt; b</code>，则三者形成了一个水沟，计算🦁式子见代码，并且该水沟可能可以继续往上“看看”，在适当条件上看看单调栈，循环填充高水位水沟。</li>\n<li>如果<code>c==a</code>，则显然应该替换掉<code>a</code>，因为单调栈维持的是等高水沟的最新端，试想<code>33323</code>。</li>\n</ul>\n<p>经过上述填充过程，单调栈的性质也要维护一下，详细见代码。</p>","more":"<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\nclass Solution &#123;\npublic:\n    int trap(vector&lt;int&gt;&amp; height) &#123;\n        if(height.size() &lt;&#x3D; 1) return 0;\n        stack&lt;int&gt; sck;\n        int amount &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; height.size(); ++i)&#123;\n            while(sck.size() &gt;&#x3D; 2 &amp;&amp; height[sck.top()] &lt;&#x3D; height[i])&#123;\n                int lowh &#x3D; height[sck.top()]; \n                sck.pop();\n                amount +&#x3D; (i - sck.top() - 1) * (min(height[i], height[sck.top()]) - lowh);\n              &#x2F;&#x2F;  cout &lt;&lt; amount &lt;&lt; endl;\n            &#125;\n            while(!sck.empty() &amp;&amp; height[sck.top()] &lt;&#x3D; height[i]) sck.pop();  &#x2F;&#x2F; &lt;&#x3D; 按次序出现的等高的山峰A,B， 明显的有AB填充了水量，下一个被填充的应该是B,所以A必须被pop\n            if(sck.empty() || height[i] &lt; height[sck.top()]) sck.push(i);\n        &#125;\n        return amount;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"739. Daily Temperatures","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2021-01-23T10:21:51.000Z","_content":"\n\n\n## [739. Daily Temperatures](https://leetcode-cn.com/problems/daily-temperatures/)\n\n\n\n## 思路：\n\n1. 单调栈；用单调栈维护从后往前遍历当前元素的最大值，便可以轻松获取当前元素之后的最大值下标，即可以更新下一个更大元素的时间差。\n\n2. KMP失败匹配算法；从后往前遍历，当前元素的更大值要么是当前元素的下一个元素，要么是下一个元素的更大值，要么是下一个元素的更大值的更大值……如此“递归”查找可得下一个最大值。如果查找不到，就不存在最大值。\n\n   <!-- more -->\n\n\n\n## 思路：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& T) {\n        int n = T.size();\n        stack<int> pos, val;\n        vector<int> day(n);\n        for(int i = n - 1; i >= 0; --i){\n\n            if(!val.empty()){\n                while(val.size() && val.top() <= T[i]){\n                    val.pop();\n                    pos.pop();\n                }\n            }\n            if(val.empty()) day[i] = 0;\n            else day[i] = pos.top() - i;\n\n            if(val.empty() || val.top() >=  T[i]){\n                pos.push(i);\n                val.push(T[i]);\n            }\n        }\n        return day;\n    }\n};\n```\n\n简化版\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& T) {\n        int n = T.size();\n        stack<int> pos, val;\n        vector<int> day(n);\n        for(int i = n - 1; i >= 0; --i){\n\n            while(val.size() && val.top() <= T[i]){\n                  \n                val.pop();\n                pos.pop();\n            }\n            if(val.size())day[i] = pos.top() - i;\n            if(val.empty() || val.top() >=  T[i]){ //  取smaller元素加入队列，也可以直接添加，毕竟上面有pop;\n                pos.push(i);\n                val.push(T[i]);\n            }\n        }\n        return day;\n    }\n};\n```\n\n\n\n```c++\n// KPM构造数组思路启发得来\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& T) {\n        int n = T.size();\n        vector<int> day(n);\n        for(int i = n - 2; i >= 0; --i){\n            int pos = i + 1;\n            while(T[pos] <= T[i]){  // 尽量从day偏移更多元素\n                if(day[pos] == 0) break; // 此后没有更大的元素\n                pos += day[pos];\n            }\n            if(T[pos] > T[i]) day[i] = pos - i;\n        }\n        return day;\n    }\n};\n\n\n```","source":"_posts/刷题/数据结构/栈和队列/单调栈\n/739-Daily-Temperatures.md","raw":"---\ntitle: 739. Daily Temperatures\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2021-01-23 18:21:51\n---\n\n\n\n## [739. Daily Temperatures](https://leetcode-cn.com/problems/daily-temperatures/)\n\n\n\n## 思路：\n\n1. 单调栈；用单调栈维护从后往前遍历当前元素的最大值，便可以轻松获取当前元素之后的最大值下标，即可以更新下一个更大元素的时间差。\n\n2. KMP失败匹配算法；从后往前遍历，当前元素的更大值要么是当前元素的下一个元素，要么是下一个元素的更大值，要么是下一个元素的更大值的更大值……如此“递归”查找可得下一个最大值。如果查找不到，就不存在最大值。\n\n   <!-- more -->\n\n\n\n## 思路：\n\n\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& T) {\n        int n = T.size();\n        stack<int> pos, val;\n        vector<int> day(n);\n        for(int i = n - 1; i >= 0; --i){\n\n            if(!val.empty()){\n                while(val.size() && val.top() <= T[i]){\n                    val.pop();\n                    pos.pop();\n                }\n            }\n            if(val.empty()) day[i] = 0;\n            else day[i] = pos.top() - i;\n\n            if(val.empty() || val.top() >=  T[i]){\n                pos.push(i);\n                val.push(T[i]);\n            }\n        }\n        return day;\n    }\n};\n```\n\n简化版\n\n```c++\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& T) {\n        int n = T.size();\n        stack<int> pos, val;\n        vector<int> day(n);\n        for(int i = n - 1; i >= 0; --i){\n\n            while(val.size() && val.top() <= T[i]){\n                  \n                val.pop();\n                pos.pop();\n            }\n            if(val.size())day[i] = pos.top() - i;\n            if(val.empty() || val.top() >=  T[i]){ //  取smaller元素加入队列，也可以直接添加，毕竟上面有pop;\n                pos.push(i);\n                val.push(T[i]);\n            }\n        }\n        return day;\n    }\n};\n```\n\n\n\n```c++\n// KPM构造数组思路启发得来\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& T) {\n        int n = T.size();\n        vector<int> day(n);\n        for(int i = n - 2; i >= 0; --i){\n            int pos = i + 1;\n            while(T[pos] <= T[i]){  // 尽量从day偏移更多元素\n                if(day[pos] == 0) break; // 此后没有更大的元素\n                pos += day[pos];\n            }\n            if(T[pos] > T[i]) day[i] = pos - i;\n        }\n        return day;\n    }\n};\n\n\n```","slug":"刷题-数据结构-栈和队列-单调栈-739-Daily-Temperatures","published":1,"updated":"2021-01-28T14:04:37.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7n005tl5uobvzd2dp2","content":"<h2 id=\"739-Daily-Temperatures\"><a href=\"#739-Daily-Temperatures\" class=\"headerlink\" title=\"739. Daily Temperatures\"></a><a href=\"https://leetcode-cn.com/problems/daily-temperatures/\">739. Daily Temperatures</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>单调栈；用单调栈维护从后往前遍历当前元素的最大值，便可以轻松获取当前元素之后的最大值下标，即可以更新下一个更大元素的时间差。</p>\n</li>\n<li><p>KMP失败匹配算法；从后往前遍历，当前元素的更大值要么是当前元素的下一个元素，要么是下一个元素的更大值，要么是下一个元素的更大值的更大值……如此“递归”查找可得下一个最大值。如果查找不到，就不存在最大值。</p>\n<span id=\"more\"></span>\n\n\n\n</li>\n</ol>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;\n        int n &#x3D; T.size();\n        stack&lt;int&gt; pos, val;\n        vector&lt;int&gt; day(n);\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)&#123;\n\n            if(!val.empty())&#123;\n                while(val.size() &amp;&amp; val.top() &lt;&#x3D; T[i])&#123;\n                    val.pop();\n                    pos.pop();\n                &#125;\n            &#125;\n            if(val.empty()) day[i] &#x3D; 0;\n            else day[i] &#x3D; pos.top() - i;\n\n            if(val.empty() || val.top() &gt;&#x3D;  T[i])&#123;\n                pos.push(i);\n                val.push(T[i]);\n            &#125;\n        &#125;\n        return day;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>简化版</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;\n        int n &#x3D; T.size();\n        stack&lt;int&gt; pos, val;\n        vector&lt;int&gt; day(n);\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)&#123;\n\n            while(val.size() &amp;&amp; val.top() &lt;&#x3D; T[i])&#123;\n                  \n                val.pop();\n                pos.pop();\n            &#125;\n            if(val.size())day[i] &#x3D; pos.top() - i;\n            if(val.empty() || val.top() &gt;&#x3D;  T[i])&#123; &#x2F;&#x2F;  取smaller元素加入队列，也可以直接添加，毕竟上面有pop;\n                pos.push(i);\n                val.push(T[i]);\n            &#125;\n        &#125;\n        return day;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; KPM构造数组思路启发得来\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;\n        int n &#x3D; T.size();\n        vector&lt;int&gt; day(n);\n        for(int i &#x3D; n - 2; i &gt;&#x3D; 0; --i)&#123;\n            int pos &#x3D; i + 1;\n            while(T[pos] &lt;&#x3D; T[i])&#123;  &#x2F;&#x2F; 尽量从day偏移更多元素\n                if(day[pos] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 此后没有更大的元素\n                pos +&#x3D; day[pos];\n            &#125;\n            if(T[pos] &gt; T[i]) day[i] &#x3D; pos - i;\n        &#125;\n        return day;\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","site":{"data":{}},"abbrlink":"RSMW8R","excerpt":"<h2 id=\"739-Daily-Temperatures\"><a href=\"#739-Daily-Temperatures\" class=\"headerlink\" title=\"739. Daily Temperatures\"></a><a href=\"https://leetcode-cn.com/problems/daily-temperatures/\">739. Daily Temperatures</a></h2><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li><p>单调栈；用单调栈维护从后往前遍历当前元素的最大值，便可以轻松获取当前元素之后的最大值下标，即可以更新下一个更大元素的时间差。</p>\n</li>\n<li><p>KMP失败匹配算法；从后往前遍历，当前元素的更大值要么是当前元素的下一个元素，要么是下一个元素的更大值，要么是下一个元素的更大值的更大值……如此“递归”查找可得下一个最大值。如果查找不到，就不存在最大值。</p>","more":"</li>\n</ol>\n<h2 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;\n        int n &#x3D; T.size();\n        stack&lt;int&gt; pos, val;\n        vector&lt;int&gt; day(n);\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)&#123;\n\n            if(!val.empty())&#123;\n                while(val.size() &amp;&amp; val.top() &lt;&#x3D; T[i])&#123;\n                    val.pop();\n                    pos.pop();\n                &#125;\n            &#125;\n            if(val.empty()) day[i] &#x3D; 0;\n            else day[i] &#x3D; pos.top() - i;\n\n            if(val.empty() || val.top() &gt;&#x3D;  T[i])&#123;\n                pos.push(i);\n                val.push(T[i]);\n            &#125;\n        &#125;\n        return day;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>简化版</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;\n        int n &#x3D; T.size();\n        stack&lt;int&gt; pos, val;\n        vector&lt;int&gt; day(n);\n        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)&#123;\n\n            while(val.size() &amp;&amp; val.top() &lt;&#x3D; T[i])&#123;\n                  \n                val.pop();\n                pos.pop();\n            &#125;\n            if(val.size())day[i] &#x3D; pos.top() - i;\n            if(val.empty() || val.top() &gt;&#x3D;  T[i])&#123; &#x2F;&#x2F;  取smaller元素加入队列，也可以直接添加，毕竟上面有pop;\n                pos.push(i);\n                val.push(T[i]);\n            &#125;\n        &#125;\n        return day;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; KPM构造数组思路启发得来\nclass Solution &#123;\npublic:\n    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;\n        int n &#x3D; T.size();\n        vector&lt;int&gt; day(n);\n        for(int i &#x3D; n - 2; i &gt;&#x3D; 0; --i)&#123;\n            int pos &#x3D; i + 1;\n            while(T[pos] &lt;&#x3D; T[i])&#123;  &#x2F;&#x2F; 尽量从day偏移更多元素\n                if(day[pos] &#x3D;&#x3D; 0) break; &#x2F;&#x2F; 此后没有更大的元素\n                pos +&#x3D; day[pos];\n            &#125;\n            if(T[pos] &gt; T[i]) day[i] &#x3D; pos - i;\n        &#125;\n        return day;\n    &#125;\n&#125;;\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"84. Largest Rectangle in Histogram","thumbnail":"http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png","toc":true,"top":10,"date":"2021-04-30T03:24:11.000Z","_content":"\n<!-- more -->\n\n# [84. Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n\n\n\n## 思路：\n\n1. 遍历高度数组的同时，维护形成的矩阵，并更新最大面积。\n2. 观察，矩阵的面积可以不严格递增的情况下在从左到右扩展的，再严格递减的情况下可以确定出矩阵面积。正向数据缓存，逆向面积计算-> 单调栈。[read more](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/)\n3. \n\n\n\n\n\n\n\n## 代码：\n\n```c++\nclass Solution {\n    map<int, pair<int,int>> reg;\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int maxarea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            \n            for(auto &item : reg){\n                auto high = item.first; \n                auto &pii = item.second;\n                auto l = pii.first;\n                auto &r = pii.second;\n                if(high > heights[i]){\n                    reg.insert({heights[i], {l, i}});\n                    maxarea = max(maxarea, heights[i] *(i - l + 1));\n                    reg.erase(reg.find(high), reg.end());\n                    \n                    break;\n                } \n                else if(high <= heights[i]){\n                    r = i;\n                    maxarea = max(high * (r - l + 1), maxarea);\n                }\n            }\n            if(reg.count(heights[i]) == 0){\n                reg.insert({heights[i], {i, i}});\n                maxarea = max(maxarea, heights[i]);\n            }\n        }\n        return maxarea;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\n    stack<int> s;\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int maxarea = 0;\n        heights.push_back(0); // 为了计算所有面积\n        for(int i = 0; i < heights.size(); ++i){\n            if(s.empty()) s.push(i);\n            else if(heights[s.top()] < heights[i]) s.push(i);\n            else if(heights[s.top()] == heights[i]) s.top() = i; // 如果相邻的高度相同，则更新；因为不更新单调栈中矩阵左边界会扩展更多\n            else if(heights[s.top()] > heights[i]){         \n                while(!s.empty() && (heights[s.top()] > heights[i])){                    \n                    int high = heights[s.top()]; \n                    s.pop();\n                    int temparea = ( i - (s.empty() ? -1 : s.top()) - 1) * high;\n                    maxarea = max(maxarea, temparea);\n                }\n                s.push(i);   \n            }   \n        }\n        return maxarea;\n    }\n};\n```\n\n> 当然，这里也可以添加一个哨兵，不过没什么影响。\n>\n> ","source":"_posts/刷题/数据结构/栈和队列/单调栈\n/84-Largest-Rectangle-in-Histogram.md","raw":"---\ntitle: 84. Largest Rectangle in Histogram\nthumbnail: 'http://static.come2rss.xyz/simptab-wallpaper-20201027164551.png'\ntoc: true\ntop: 10\ndate: 2021-04-30 11:24:11\ntags:\ncategories:\n---\n\n<!-- more -->\n\n# [84. Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)\n\n\n\n## 思路：\n\n1. 遍历高度数组的同时，维护形成的矩阵，并更新最大面积。\n2. 观察，矩阵的面积可以不严格递增的情况下在从左到右扩展的，再严格递减的情况下可以确定出矩阵面积。正向数据缓存，逆向面积计算-> 单调栈。[read more](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/)\n3. \n\n\n\n\n\n\n\n## 代码：\n\n```c++\nclass Solution {\n    map<int, pair<int,int>> reg;\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int maxarea = 0;\n        for(int i = 0; i < heights.size(); ++i){\n            \n            for(auto &item : reg){\n                auto high = item.first; \n                auto &pii = item.second;\n                auto l = pii.first;\n                auto &r = pii.second;\n                if(high > heights[i]){\n                    reg.insert({heights[i], {l, i}});\n                    maxarea = max(maxarea, heights[i] *(i - l + 1));\n                    reg.erase(reg.find(high), reg.end());\n                    \n                    break;\n                } \n                else if(high <= heights[i]){\n                    r = i;\n                    maxarea = max(high * (r - l + 1), maxarea);\n                }\n            }\n            if(reg.count(heights[i]) == 0){\n                reg.insert({heights[i], {i, i}});\n                maxarea = max(maxarea, heights[i]);\n            }\n        }\n        return maxarea;\n    }\n};\n```\n\n\n\n\n\n```c++\nclass Solution {\n    stack<int> s;\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int maxarea = 0;\n        heights.push_back(0); // 为了计算所有面积\n        for(int i = 0; i < heights.size(); ++i){\n            if(s.empty()) s.push(i);\n            else if(heights[s.top()] < heights[i]) s.push(i);\n            else if(heights[s.top()] == heights[i]) s.top() = i; // 如果相邻的高度相同，则更新；因为不更新单调栈中矩阵左边界会扩展更多\n            else if(heights[s.top()] > heights[i]){         \n                while(!s.empty() && (heights[s.top()] > heights[i])){                    \n                    int high = heights[s.top()]; \n                    s.pop();\n                    int temparea = ( i - (s.empty() ? -1 : s.top()) - 1) * high;\n                    maxarea = max(maxarea, temparea);\n                }\n                s.push(i);   \n            }   \n        }\n        return maxarea;\n    }\n};\n```\n\n> 当然，这里也可以添加一个哨兵，不过没什么影响。\n>\n> ","slug":"刷题-数据结构-栈和队列-单调栈-84-Largest-Rectangle-in-Histogram","published":1,"updated":"2021-04-30T04:30:04.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7p005ul5uobez7ca5d","content":"<span id=\"more\"></span>\n\n<h1 id=\"84-Largest-Rectangle-in-Histogram\"><a href=\"#84-Largest-Rectangle-in-Histogram\" class=\"headerlink\" title=\"84. Largest Rectangle in Histogram\"></a><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">84. Largest Rectangle in Histogram</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>遍历高度数组的同时，维护形成的矩阵，并更新最大面积。</li>\n<li>观察，矩阵的面积可以不严格递增的情况下在从左到右扩展的，再严格递减的情况下可以确定出矩阵面积。正向数据缓存，逆向面积计算-&gt; 单调栈。<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/\">read more</a></li>\n<li></li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    map&lt;int, pair&lt;int,int&gt;&gt; reg;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n        int maxarea &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; heights.size(); ++i)&#123;\n            \n            for(auto &amp;item : reg)&#123;\n                auto high &#x3D; item.first; \n                auto &amp;pii &#x3D; item.second;\n                auto l &#x3D; pii.first;\n                auto &amp;r &#x3D; pii.second;\n                if(high &gt; heights[i])&#123;\n                    reg.insert(&#123;heights[i], &#123;l, i&#125;&#125;);\n                    maxarea &#x3D; max(maxarea, heights[i] *(i - l + 1));\n                    reg.erase(reg.find(high), reg.end());\n                    \n                    break;\n                &#125; \n                else if(high &lt;&#x3D; heights[i])&#123;\n                    r &#x3D; i;\n                    maxarea &#x3D; max(high * (r - l + 1), maxarea);\n                &#125;\n            &#125;\n            if(reg.count(heights[i]) &#x3D;&#x3D; 0)&#123;\n                reg.insert(&#123;heights[i], &#123;i, i&#125;&#125;);\n                maxarea &#x3D; max(maxarea, heights[i]);\n            &#125;\n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    stack&lt;int&gt; s;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n        int maxarea &#x3D; 0;\n        heights.push_back(0); &#x2F;&#x2F; 为了计算所有面积\n        for(int i &#x3D; 0; i &lt; heights.size(); ++i)&#123;\n            if(s.empty()) s.push(i);\n            else if(heights[s.top()] &lt; heights[i]) s.push(i);\n            else if(heights[s.top()] &#x3D;&#x3D; heights[i]) s.top() &#x3D; i; &#x2F;&#x2F; 如果相邻的高度相同，则更新；因为不更新单调栈中矩阵左边界会扩展更多\n            else if(heights[s.top()] &gt; heights[i])&#123;         \n                while(!s.empty() &amp;&amp; (heights[s.top()] &gt; heights[i]))&#123;                    \n                    int high &#x3D; heights[s.top()]; \n                    s.pop();\n                    int temparea &#x3D; ( i - (s.empty() ? -1 : s.top()) - 1) * high;\n                    maxarea &#x3D; max(maxarea, temparea);\n                &#125;\n                s.push(i);   \n            &#125;   \n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>当然，这里也可以添加一个哨兵，不过没什么影响。</p>\n</blockquote>\n","site":{"data":{}},"abbrlink":"3BADN2E","excerpt":"","more":"<h1 id=\"84-Largest-Rectangle-in-Histogram\"><a href=\"#84-Largest-Rectangle-in-Histogram\" class=\"headerlink\" title=\"84. Largest Rectangle in Histogram\"></a><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">84. Largest Rectangle in Histogram</a></h1><h2 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h2><ol>\n<li>遍历高度数组的同时，维护形成的矩阵，并更新最大面积。</li>\n<li>观察，矩阵的面积可以不严格递增的情况下在从左到右扩展的，再严格递减的情况下可以确定出矩阵面积。正向数据缓存，逆向面积计算-&gt; 单调栈。<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/\">read more</a></li>\n<li></li>\n</ol>\n<h2 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    map&lt;int, pair&lt;int,int&gt;&gt; reg;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n        int maxarea &#x3D; 0;\n        for(int i &#x3D; 0; i &lt; heights.size(); ++i)&#123;\n            \n            for(auto &amp;item : reg)&#123;\n                auto high &#x3D; item.first; \n                auto &amp;pii &#x3D; item.second;\n                auto l &#x3D; pii.first;\n                auto &amp;r &#x3D; pii.second;\n                if(high &gt; heights[i])&#123;\n                    reg.insert(&#123;heights[i], &#123;l, i&#125;&#125;);\n                    maxarea &#x3D; max(maxarea, heights[i] *(i - l + 1));\n                    reg.erase(reg.find(high), reg.end());\n                    \n                    break;\n                &#125; \n                else if(high &lt;&#x3D; heights[i])&#123;\n                    r &#x3D; i;\n                    maxarea &#x3D; max(high * (r - l + 1), maxarea);\n                &#125;\n            &#125;\n            if(reg.count(heights[i]) &#x3D;&#x3D; 0)&#123;\n                reg.insert(&#123;heights[i], &#123;i, i&#125;&#125;);\n                maxarea &#x3D; max(maxarea, heights[i]);\n            &#125;\n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\n    stack&lt;int&gt; s;\npublic:\n    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;\n        int maxarea &#x3D; 0;\n        heights.push_back(0); &#x2F;&#x2F; 为了计算所有面积\n        for(int i &#x3D; 0; i &lt; heights.size(); ++i)&#123;\n            if(s.empty()) s.push(i);\n            else if(heights[s.top()] &lt; heights[i]) s.push(i);\n            else if(heights[s.top()] &#x3D;&#x3D; heights[i]) s.top() &#x3D; i; &#x2F;&#x2F; 如果相邻的高度相同，则更新；因为不更新单调栈中矩阵左边界会扩展更多\n            else if(heights[s.top()] &gt; heights[i])&#123;         \n                while(!s.empty() &amp;&amp; (heights[s.top()] &gt; heights[i]))&#123;                    \n                    int high &#x3D; heights[s.top()]; \n                    s.pop();\n                    int temparea &#x3D; ( i - (s.empty() ? -1 : s.top()) - 1) * high;\n                    maxarea &#x3D; max(maxarea, temparea);\n                &#125;\n                s.push(i);   \n            &#125;   \n        &#125;\n        return maxarea;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>当然，这里也可以添加一个哨兵，不过没什么影响。</p>\n</blockquote>"},{"title":"面试题 二叉树","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:25:51.000Z","_content":"\n\n\n收集二叉树相关题目，相关测试代码见[此](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp)。\n\n<!-- more -->\n\nsCmd = ‘C:; cd C:\\Users\\xusx\\Sumo\\SUMO\\bin; duarouter -n xsxlankershim.net.xml –route-files xsx.flow.xml -o rou.rou.xml’\nos.system(sCmd)\n\n### 结构\n\n```\nstruct BinaryTreeNode{\n    double dbValue;\n    BinaryTreeNode *pLeft;\n    BinaryTreeNode *pRight;   \n}\n```\n\n## 面7：中序遍历和前序遍历序列来重建二叉树\n\n```\nBinaryTreeNode* ConstructNode(int *startPreorder,  int *endPreordrer, \n                              int *startInorder, int *endInorder){\n    //这个代码健壮性就很好！对空值和非法输出进行了区分。\n\tif(startPreorder > endPreorder  || startInorder > endInorder ){\t\n        if(startPreorder == endPreorder - 1  && startInorder ==  endInorder - 1) \n        \treturn nullptr;\n        else \n            throw std::exception(\"Invalid Input.\\n\");\n    } \n    //寻找中序遍历中的根节点值坐标\n    int nodeValue = startPreordre[0];\n\tint *rootInorder = startInorder;\n    for(; rootInorder <= enInorder && *rootInordre != nodevalue; rootInorder++);\n\t//健壮一下\n    if(enInorder < rootInorder){\n        throw std::exception(\"Invalid input!\\n\");\n    }\n    //构建左右子树\n    BinaryTreeNode* pNode = new BinaryTreeNode();\n    int lNodeNum = rootInorder - startInorder;\n    pNode->pLeft = \n        ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1);\n    pNode->pRight = \n        ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder);\n    pNode->value = nodeValue;\n    return pNode;\n\t\n}\n\nBinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length){\n    //length == 0的代码的健壮性显然不如 length <= 0\n    if(preorder == null || inorder == null || length <= 0) return nullptr;\n\treturn ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1);\n    \n}\n```\n\n## 面8：二叉树的下一个节点\n\n第一次考虑的时候居然还想错了，分析不够全面。从二叉树中序遍历来看，若一个节点有右子树，则下一个节点就是其右子树的最左节点。倘若没有，则必然是考虑父亲节点。如果该节点是父亲节点的左子节点，那么下一个节点就是父亲节点，不然可以溯源查找其父辈节点是左子树的祖父节点。这个过程可以使用父亲节点和迭代完成。\n\n```\nBinaryTreeNode *GetNext(BinaryTreeNode *pNode){\n    if(pNode == nullptr) return;\n    if(pNode->pRight){\n        BinaryTreeNode* pChild = pNode->pRight;\n        while(pChild->pLeft != nullptr) pChild = pChild->pRight;\n        return pChild;\n    }else{\n        BinaryTreeNode* pParent = pNode->pParent, *pCurrent = pNode;\n\t\t//循环控制条件有点像哨兵，没有找到的话pParent自然就是unllptr,代码更加简洁了\n        while(pParent != nullptr && pParent->pRight != pCurrent){\n            pCurrent = pParent;\n            pParent = pParent->pParent;\n        }\n        return pParent;       \n    }\n    return nullptr;\n}\n```\n\n> 相比之前的代码这个写法差一点点\n>\n> ```\n> while(pParent->pParent != nullptr && pParent->pRight != pCurrent){\n>             pCurrent = pParent;\n>             pParent = pParent->pParent;\n>         }\n>         if(pParent->pRight == pCurrent){\n>             return pParent;\n>         }\n>        \n> ```\n\n## 面26：树的子结构\n\n### 题面：\n\n输入两棵树`A`和`B`，判断`B`是否是`A`的子结构。`B`是`A`的子结构子结构定义为`A`的一部分和`B`完全相同。\n\n### 思路：\n\n递归的判断对`A`的每一个节点判断该节点下的是否有`B`的结构。\n\n### 代码：\n\n```\nbool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){\n\tif(pRoot2 == nullptr) return true;\n    else if(pRoot1 == nullptr) return false;\n    \n    if(equal(pRoot1->dbValue, pRoot2->dbValue)){\n        if(pRoot2->pRight == nullptr && pRoot2->pLeft == nullptr) return true;\n\t    return judgeSameTree(pRoot1->pLeft, pRoot2->pLeft)\n            && judgeSameTree(pRoot2->pRight, pRoot2->pRight);\n    }\n    return false;\n}\n\nbool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){\n\tif(pRoot1){\n        if(judgeSameTree(pRoot1, pRoot2)) return true;\n        else return HasSubtreeCore(pRoot1->pLeft, pRoot2) \n            \t|| HasSubtreeCore(pRoot1->pRight, pRight);\n    }\n    return false;\n}\nbool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){\n    if(pRoot2 == nullptr) return true;\n    if(pRoot1 == nullptr) return false;\n    return HasSubtreeCore(pRoot1, pRoot2);   \t    \n}\n```\n\n### 测试：\n\n[参见](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp)\n\n## 面27：翻转二叉树\n\n### 题面：\n\n给出一棵二叉树并返回其镜像二叉树。\n\n### 思路：\n\n直接交换节点的左右指针节点即可。\n\n### 代码：\n\n```\nBinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode){\n    if(pNode == nullptr) return nullptr;\n    BinaryTreeNode *pTemp = pNode->pRight;\n    pNode->pRight = pNode->pLeft;\n    pNode->pLeft = pTemp;\n\tMirrorRecursively(pNode->pLeft);\n    MirrorRecursively(pNode->pRight);\n    return pNode;    \n}\n```\n\n## 面28：对称二叉树\n\n### 题面：\n\n判断一棵树是否对称。\n\n### 思路：\n\n从第一个节点左子树开始递归的判断，其右子树的节点是否完全相同。只需要一边对另一边镜像操作就ok。\n\n### 代码：\n\n```\nbool isSymmetrical(BinaryTreeNode* pHead){\n\tif(pHead == nullptr) return true;\n    return isSymmetricalCore(pHead->pLeft, pHead->pRight);\n}\nbool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2){\n    if(p1 == nullptr && p2 == nullptr) return true;\n    if(p1 == nullptr && p2 != nullptr \n       || p2 == nullptr && p1 != nullptr\n      || p1->value != p2->value) \n    \treturn false;\n    return isSemmetricalCore(p1->left, p2->right) \n    \t&&  isSemmetricalCore(p1->right, p2->left);    \n}\n```\n\n> 有趣的是，我这种写法也可以看成前序遍历序列和对称前序遍历序列的比较。\n\n## 面32：层序遍历二叉树\n\n### 题面：\n\n如标题\n\n### 思路：\n\n层序遍历\n\n### 代码：\n\n```\nvoid PrintByLayer(BinaryTreeNode* pHead){\n    if(pHead == nullptr) return;\n    queue<BinaryTreeNode*> que;\n    que.push(pHead);\n    while(que.size()){\n        BinaryTreeNode *pNode = que.front();\n        que.pop();\n        printf(\"%.2f \", pNode->dbValue);\n        if(pNode->pLeft) que.push(pNode->pLeft);\n        if(pNode->pRight) que.push(pNode->pRight);        \n    }\n    printf(\"\\n\");\n}\n```\n\n## 面32相关题：分行打印层序遍历二叉树\n\n### 题面：\n\n如标题\n\n### 思路：\n\n在层序遍历的基础上，有两种解题思路：一是记录当前层未打印的节点数量和下一层的需要打印的节点数量，二是在队列中添加一个一层的节点末端的标志符、\n\n### 代码：\n\n```\nvoid PrintByLayerSparate(BinaryTreeNode* pHead){\n    if(pHead == nullptr) return;\n    queue<BinaryTreeNode*> que;\n    que.push(pHead);\n\tint printValue = 1, nextValue = 0;\n    while(que.size()){\n        BinaryTreeNode *pNode = que.front();\n        que.pop();\n        printValue--;\n        printf(\"%.2f \", pNode->dbValue);\n        if(pNode->pLeft){\n          \tque.push(pNode->pLeft);\n            nextValue++;\n        } \n        if(pNode->pRight){\n            que.push(pNode->pRight);          \n            nextValue++;\n        }\n        \n        if(printValue == 0){\n            printValue = nextValue;\n            nextValue = 0;\n            printf(\"\\n\");\n        }\n    }\n    \n}\n```\n\n## 面32相关题：之字形打印二叉树\n\n### 题面：\n\n如标题\n\n### 思路：\n\n一种方法就是分层层序遍历+栈逆序存储并输出。\n\n第二种方法就用栈把一层的节点逆序输出，并将下一层的节点记录在另一个栈中，如此循环，输出所有的层。\n\n### 代码：\n\n```\nvoid PirntZhi(BinaryTreeNode *pHead){\n    if(pHead == nullptr) return;\n    stack<BinaryTreeNode*> s[2];\n    int cur = 0;\n    s[cur].push(pHead);\n    BinaryTreeNode *pNode = nullptr;\n    while(s[cur].size()){\n        while(s[cur].size()){\n\t\t   pNode = s[cur].top();\n            s[cur].pop();\n            printf(\"%.2 \", pNode->dbValue);\n            if(cur == 0){\n                if(pNode->pLeft) s[1 - cur].push(pNode->pLeft);\n                if(pNode->pRight) s[1 - cur].push(pNode->pRight);                \n            }else{\n                if(pNode->pRight) s[1 - cur].push(pNode->pRight);                \n            \tif(pNode->pLeft) s[1 - cur].push(pNode->pLeft);                \n            }\n        }\n       \tprintf(\"\\n\");\n        cur = 1- cur;\n    }\n    \n}\n```\n\n\n\n#### [103. Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if(!root) return {};\n        stack<TreeNode*> cur1, cur2;\n        cur1.push(root);\n        vector<vector<int>> zigarr;\n        int flag = 1;\n        while(cur1.size() || cur2.size()){\n            if(flag) zigview(cur1, cur2, zigarr, flag), flag = 1 - flag ;\n            else  zigview(cur2, cur1, zigarr, flag), flag = 1 - flag;\n        }\n        return zigarr;\n    }\n\n    void zigview(stack<TreeNode*>& now, stack<TreeNode*>& next, vector<vector<int>> &zigarr, int flag){\n        vector<int> arr;\n        while(!now.empty()){\n            arr.push_back(now.top()->val);\n            if(flag){\n                if(now.top()->left) next.push(now.top()->left);\n                if(now.top()->right) next.push(now.top()->right);\n                now.pop();\n            }else{\n                if(now.top()->right) next.push(now.top()->right);\n                if(now.top()->left) next.push(now.top()->left);\n                now.pop();\n            }            \n        }\n        zigarr.push_back(arr);\n    }\n};\n```\n\n\n\n## 面33:判断后序遍历序列有效性\n\n### 题面：\n\n给定一颗二叉搜索树的后续遍历序列，判断该后序遍历序列是否合法。\n\n### 思路：\n\n依据后续遍历的定义，可以把序列依据最后一个元素`K`分成两半，且满足前一部分全部小于`K`的值，后一部分全部大于`K`的值，若不符合这个结论，则该后序遍历不可能存在一颗二叉树与之对应。递归的判断这两部分是否符合这些定义。\n\n### 代码：\n\n```\nbool isPostSequenceCore(int sequence[], int start, int end){\n    if(start >= end) return true;\n    int key = sequence[end - 1];\n    int split = start;\n    while(sequence[split] < key) split++;\n    for(int i = split; i < end; i++){\n        if(sequence[i] < key) return false;\n    }\n    return isPostSequenceCore(sequence, start, split) \n        && isPostSequenceCore(sequence, split, end - 1);\n}\n\nbool isPostSequence(int sequence[], int len){\n    if(sequence == nullptr || len <= 0) return false;\n    return isPostSequenceCore(sequence, 0, len);\n}\n```\n\n> 如果是c++的话，也可以直接用指针代替start。\n\n## 面34：树的路径的元素之和\n\n### 题面：\n\n打印出树的路径上的值之和与给定数字相同的所有路径。路径从根到叶子。\n\n### 思路：\n\ndfs遍历 + 记录路径即可。\n\n### 代码：\n\n```\nvoid PrintPathCore(BinaryTreeNode* pNode, stack<int> &s, int add, int expectedSum){\n    s.push((int)pNode->dbValue);\n    add += (int)(pNode->dbValue);\n    if(pNode->pLeft == nullptr && pNode->pRight == nullptr){\n        if(add == expectedSum){\n            stack<int> sTemp;\n            while(s.size()){\n               \n                sTemp.push(s.top());\n                s.pop();                \n            }\n            while(sTemp.size()){\n                printf(\"%d->\", sTemp.top());\n                s.push(sTemp.top());\n                sTemp.pop();\n            }\n            printf(\"\\n\");\n        }\n        // printf(\"%d, %d, %d\\n\", expectedSum, add, s.size());\n        s.pop();\n        return;\n    }\n    if(pNode->pLeft) PrintPathCore(pNode->pLeft, s, add, expectedSum);    \n    if(pNode->pRight) PrintPathCore(pNode->pRight, s, add, expectedSum);\n    s.pop();\n}\n\n\nvoid PrintPath(BinaryTreeNode* pHead, int expectedSum){\n    if(pHead == nullptr) return;\n\tstack<int> s;\n    PrintPathCore(pHead, s, 0, expectedSum);\n    printf(\"\\n\");\n}\n```\n\n> 中午时间不要打代码，太困了\n\n\n\n## [437. Path Sum III](https://leetcode-cn.com/problems/path-sum-iii/) 路径之和\n\n类似，但不相同。\n\n前缀和 + 递归\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int count = 0;\n    int pathSum(TreeNode* root, int sum) {\n        add(root, 0);    \n        findNode(root, sum, 0);\n        return count;\n    }\n    void findNode(TreeNode* root, int num, int presum){\n        if(!root) return;\n        cal(root, num, presum);\n        findNode(root->left, num, root->val);\n        findNode(root->right, num, root->val);\n    }\n    void cal(TreeNode* root, int target, int presum){\n        if(!root) return;\n        if(root->val - presum == target) count++;\n        cal(root->left, target, presum);\n        cal(root->right, target, presum);\n    }\n    void add(TreeNode* root, int presum){\n        if(!root) return;\n        root->val += presum;\n        add(root->left, root->val);\n        add(root->right, root->val);\n    }\n};\n```\n\n\n\n写法二：提供一种递归的小小思路\n\n```c++\nclass Solution {\npublic:\n    int count = 0;\n    int pathSum(TreeNode* root, int sum) {\n        if(!root) return 0;\n        return cal(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n    }\n    int cal(TreeNode* root, int sum){\n        if(!root) return 0;\n        sum -= root->val;\n        return (sum == 0) + cal(root->left, sum) + cal(root->right, sum);\n    }\n    \n};\n```\n\n\n\n最优解法：前缀和 + 回溯 + 维护前缀和出现的次数：`times[presum]`\n\n> 突然想到3数之和。\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<int, int> ct = {{0,1}};\n    int pathSum(TreeNode* root, int sum) {\n        int amount = 0;\n        dfs(root, 0, sum, amount);\n        return amount;\n    }\n    void dfs(TreeNode *root, int presum, int sum, int &amount){\n        if(!root) return;\n        root->val += presum;\n        amount += ct[root->val - sum];\n\n        ++ct[root->val];\n        dfs(root->left, root->val, sum, amount);\n        dfs(root->right, root->val, sum, amount);\n        --ct[root->val];\n\n    }\n    \n};\n```\n\n\n\n## 面36：把二叉搜索树转化为双向链表（同链表中的内容）\n\n### 题面：\n\n如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。\n\n### 思路：\n\n可以从递归的角度入手。对于一个节点`A`，中序遍历到`A`，则`A`的左子树已经转化为了链表，连接好`A`和`A`的左子树的最大节点（前一个指针）的指针则连接完成。\n\n那对于`A`的右子树的最小节点`B`与`A`之间的连接，也可以看成`B`与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。\n\n注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。\n\n> 对于一个节点`A`的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点`B`的指针，并设置好`B`的右指针和`A`的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是`NULL`，所以无需修改。\n\n### 代码：\n\n```\nvoid AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&preNode, BinaryTreeNode *&pHead){\n    if(pRoot == nullptr) return;\n  \tAdjustLinkCore(pRoot->pLeft, preNode, pHead);\n\n    if(pHead == nullptr) pHead = pRoot;\n    pRoot->pLeft = preNode;\n    if(preNode) preNode->pRight = pRoot;\n    preNode = pRoot;\n    \n    AdjustLinkCore(pRoot->pRight, preNode, pHead);\n}\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){\n    BinaryTreeNode *preNode = nullptr;\n    BinaryTreeNode *pHead = nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n}\n```\n\n## 面36：序列化和反序列化二叉树\n\n### 题面：\n\n序列化定义：\n\n> 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。\n\n二叉树的序列化可以把非空节点的值序列化，把空节点序列化为`$`。\n\n### 思路：\n\n由于序列化把空节点的信息也包含进来了，所以无需添加更多序列。\n\n> 这题更像流的应用题\n\n### 代码：\n\n```\nvoid Serialize(BinaryTreeNode *pRoot, ostream& stream){\n    if(pRoot == nullptr){\n        stream << '$';\n        return;\n    } \n    stream << pRoot->value << ',';\n    Serialize(pRoot->pLeft);\n    Serialize(pRoot->pRight);    \n}\n\nvoid Deserialize(BinaryTreeNode *&pRoot, istream& stream){\n\tint number;\n    if(ReadSteam(stream, &number)){\n        pRoot = new BinaryTreeNode();\n        pNew->pLeft = nullptr;\n        pNew->pRight = nullptr;\n        pNew->value = number;\n    }\n    Deserialize(pRoot->pLeft, stream);\n\tDeserialize(pRoot->pRight, steam);    \n}\n\n```\n\n","source":"_posts/刷题/数据结构/树/面试题-二叉树.md","raw":"---\ntitle: 面试题 二叉树\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:25:51\n---\n\n\n\n收集二叉树相关题目，相关测试代码见[此](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp)。\n\n<!-- more -->\n\nsCmd = ‘C:; cd C:\\Users\\xusx\\Sumo\\SUMO\\bin; duarouter -n xsxlankershim.net.xml –route-files xsx.flow.xml -o rou.rou.xml’\nos.system(sCmd)\n\n### 结构\n\n```\nstruct BinaryTreeNode{\n    double dbValue;\n    BinaryTreeNode *pLeft;\n    BinaryTreeNode *pRight;   \n}\n```\n\n## 面7：中序遍历和前序遍历序列来重建二叉树\n\n```\nBinaryTreeNode* ConstructNode(int *startPreorder,  int *endPreordrer, \n                              int *startInorder, int *endInorder){\n    //这个代码健壮性就很好！对空值和非法输出进行了区分。\n\tif(startPreorder > endPreorder  || startInorder > endInorder ){\t\n        if(startPreorder == endPreorder - 1  && startInorder ==  endInorder - 1) \n        \treturn nullptr;\n        else \n            throw std::exception(\"Invalid Input.\\n\");\n    } \n    //寻找中序遍历中的根节点值坐标\n    int nodeValue = startPreordre[0];\n\tint *rootInorder = startInorder;\n    for(; rootInorder <= enInorder && *rootInordre != nodevalue; rootInorder++);\n\t//健壮一下\n    if(enInorder < rootInorder){\n        throw std::exception(\"Invalid input!\\n\");\n    }\n    //构建左右子树\n    BinaryTreeNode* pNode = new BinaryTreeNode();\n    int lNodeNum = rootInorder - startInorder;\n    pNode->pLeft = \n        ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1);\n    pNode->pRight = \n        ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder);\n    pNode->value = nodeValue;\n    return pNode;\n\t\n}\n\nBinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length){\n    //length == 0的代码的健壮性显然不如 length <= 0\n    if(preorder == null || inorder == null || length <= 0) return nullptr;\n\treturn ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1);\n    \n}\n```\n\n## 面8：二叉树的下一个节点\n\n第一次考虑的时候居然还想错了，分析不够全面。从二叉树中序遍历来看，若一个节点有右子树，则下一个节点就是其右子树的最左节点。倘若没有，则必然是考虑父亲节点。如果该节点是父亲节点的左子节点，那么下一个节点就是父亲节点，不然可以溯源查找其父辈节点是左子树的祖父节点。这个过程可以使用父亲节点和迭代完成。\n\n```\nBinaryTreeNode *GetNext(BinaryTreeNode *pNode){\n    if(pNode == nullptr) return;\n    if(pNode->pRight){\n        BinaryTreeNode* pChild = pNode->pRight;\n        while(pChild->pLeft != nullptr) pChild = pChild->pRight;\n        return pChild;\n    }else{\n        BinaryTreeNode* pParent = pNode->pParent, *pCurrent = pNode;\n\t\t//循环控制条件有点像哨兵，没有找到的话pParent自然就是unllptr,代码更加简洁了\n        while(pParent != nullptr && pParent->pRight != pCurrent){\n            pCurrent = pParent;\n            pParent = pParent->pParent;\n        }\n        return pParent;       \n    }\n    return nullptr;\n}\n```\n\n> 相比之前的代码这个写法差一点点\n>\n> ```\n> while(pParent->pParent != nullptr && pParent->pRight != pCurrent){\n>             pCurrent = pParent;\n>             pParent = pParent->pParent;\n>         }\n>         if(pParent->pRight == pCurrent){\n>             return pParent;\n>         }\n>        \n> ```\n\n## 面26：树的子结构\n\n### 题面：\n\n输入两棵树`A`和`B`，判断`B`是否是`A`的子结构。`B`是`A`的子结构子结构定义为`A`的一部分和`B`完全相同。\n\n### 思路：\n\n递归的判断对`A`的每一个节点判断该节点下的是否有`B`的结构。\n\n### 代码：\n\n```\nbool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){\n\tif(pRoot2 == nullptr) return true;\n    else if(pRoot1 == nullptr) return false;\n    \n    if(equal(pRoot1->dbValue, pRoot2->dbValue)){\n        if(pRoot2->pRight == nullptr && pRoot2->pLeft == nullptr) return true;\n\t    return judgeSameTree(pRoot1->pLeft, pRoot2->pLeft)\n            && judgeSameTree(pRoot2->pRight, pRoot2->pRight);\n    }\n    return false;\n}\n\nbool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){\n\tif(pRoot1){\n        if(judgeSameTree(pRoot1, pRoot2)) return true;\n        else return HasSubtreeCore(pRoot1->pLeft, pRoot2) \n            \t|| HasSubtreeCore(pRoot1->pRight, pRight);\n    }\n    return false;\n}\nbool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){\n    if(pRoot2 == nullptr) return true;\n    if(pRoot1 == nullptr) return false;\n    return HasSubtreeCore(pRoot1, pRoot2);   \t    \n}\n```\n\n### 测试：\n\n[参见](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp)\n\n## 面27：翻转二叉树\n\n### 题面：\n\n给出一棵二叉树并返回其镜像二叉树。\n\n### 思路：\n\n直接交换节点的左右指针节点即可。\n\n### 代码：\n\n```\nBinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode){\n    if(pNode == nullptr) return nullptr;\n    BinaryTreeNode *pTemp = pNode->pRight;\n    pNode->pRight = pNode->pLeft;\n    pNode->pLeft = pTemp;\n\tMirrorRecursively(pNode->pLeft);\n    MirrorRecursively(pNode->pRight);\n    return pNode;    \n}\n```\n\n## 面28：对称二叉树\n\n### 题面：\n\n判断一棵树是否对称。\n\n### 思路：\n\n从第一个节点左子树开始递归的判断，其右子树的节点是否完全相同。只需要一边对另一边镜像操作就ok。\n\n### 代码：\n\n```\nbool isSymmetrical(BinaryTreeNode* pHead){\n\tif(pHead == nullptr) return true;\n    return isSymmetricalCore(pHead->pLeft, pHead->pRight);\n}\nbool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2){\n    if(p1 == nullptr && p2 == nullptr) return true;\n    if(p1 == nullptr && p2 != nullptr \n       || p2 == nullptr && p1 != nullptr\n      || p1->value != p2->value) \n    \treturn false;\n    return isSemmetricalCore(p1->left, p2->right) \n    \t&&  isSemmetricalCore(p1->right, p2->left);    \n}\n```\n\n> 有趣的是，我这种写法也可以看成前序遍历序列和对称前序遍历序列的比较。\n\n## 面32：层序遍历二叉树\n\n### 题面：\n\n如标题\n\n### 思路：\n\n层序遍历\n\n### 代码：\n\n```\nvoid PrintByLayer(BinaryTreeNode* pHead){\n    if(pHead == nullptr) return;\n    queue<BinaryTreeNode*> que;\n    que.push(pHead);\n    while(que.size()){\n        BinaryTreeNode *pNode = que.front();\n        que.pop();\n        printf(\"%.2f \", pNode->dbValue);\n        if(pNode->pLeft) que.push(pNode->pLeft);\n        if(pNode->pRight) que.push(pNode->pRight);        \n    }\n    printf(\"\\n\");\n}\n```\n\n## 面32相关题：分行打印层序遍历二叉树\n\n### 题面：\n\n如标题\n\n### 思路：\n\n在层序遍历的基础上，有两种解题思路：一是记录当前层未打印的节点数量和下一层的需要打印的节点数量，二是在队列中添加一个一层的节点末端的标志符、\n\n### 代码：\n\n```\nvoid PrintByLayerSparate(BinaryTreeNode* pHead){\n    if(pHead == nullptr) return;\n    queue<BinaryTreeNode*> que;\n    que.push(pHead);\n\tint printValue = 1, nextValue = 0;\n    while(que.size()){\n        BinaryTreeNode *pNode = que.front();\n        que.pop();\n        printValue--;\n        printf(\"%.2f \", pNode->dbValue);\n        if(pNode->pLeft){\n          \tque.push(pNode->pLeft);\n            nextValue++;\n        } \n        if(pNode->pRight){\n            que.push(pNode->pRight);          \n            nextValue++;\n        }\n        \n        if(printValue == 0){\n            printValue = nextValue;\n            nextValue = 0;\n            printf(\"\\n\");\n        }\n    }\n    \n}\n```\n\n## 面32相关题：之字形打印二叉树\n\n### 题面：\n\n如标题\n\n### 思路：\n\n一种方法就是分层层序遍历+栈逆序存储并输出。\n\n第二种方法就用栈把一层的节点逆序输出，并将下一层的节点记录在另一个栈中，如此循环，输出所有的层。\n\n### 代码：\n\n```\nvoid PirntZhi(BinaryTreeNode *pHead){\n    if(pHead == nullptr) return;\n    stack<BinaryTreeNode*> s[2];\n    int cur = 0;\n    s[cur].push(pHead);\n    BinaryTreeNode *pNode = nullptr;\n    while(s[cur].size()){\n        while(s[cur].size()){\n\t\t   pNode = s[cur].top();\n            s[cur].pop();\n            printf(\"%.2 \", pNode->dbValue);\n            if(cur == 0){\n                if(pNode->pLeft) s[1 - cur].push(pNode->pLeft);\n                if(pNode->pRight) s[1 - cur].push(pNode->pRight);                \n            }else{\n                if(pNode->pRight) s[1 - cur].push(pNode->pRight);                \n            \tif(pNode->pLeft) s[1 - cur].push(pNode->pLeft);                \n            }\n        }\n       \tprintf(\"\\n\");\n        cur = 1- cur;\n    }\n    \n}\n```\n\n\n\n#### [103. Binary Tree Zigzag Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if(!root) return {};\n        stack<TreeNode*> cur1, cur2;\n        cur1.push(root);\n        vector<vector<int>> zigarr;\n        int flag = 1;\n        while(cur1.size() || cur2.size()){\n            if(flag) zigview(cur1, cur2, zigarr, flag), flag = 1 - flag ;\n            else  zigview(cur2, cur1, zigarr, flag), flag = 1 - flag;\n        }\n        return zigarr;\n    }\n\n    void zigview(stack<TreeNode*>& now, stack<TreeNode*>& next, vector<vector<int>> &zigarr, int flag){\n        vector<int> arr;\n        while(!now.empty()){\n            arr.push_back(now.top()->val);\n            if(flag){\n                if(now.top()->left) next.push(now.top()->left);\n                if(now.top()->right) next.push(now.top()->right);\n                now.pop();\n            }else{\n                if(now.top()->right) next.push(now.top()->right);\n                if(now.top()->left) next.push(now.top()->left);\n                now.pop();\n            }            \n        }\n        zigarr.push_back(arr);\n    }\n};\n```\n\n\n\n## 面33:判断后序遍历序列有效性\n\n### 题面：\n\n给定一颗二叉搜索树的后续遍历序列，判断该后序遍历序列是否合法。\n\n### 思路：\n\n依据后续遍历的定义，可以把序列依据最后一个元素`K`分成两半，且满足前一部分全部小于`K`的值，后一部分全部大于`K`的值，若不符合这个结论，则该后序遍历不可能存在一颗二叉树与之对应。递归的判断这两部分是否符合这些定义。\n\n### 代码：\n\n```\nbool isPostSequenceCore(int sequence[], int start, int end){\n    if(start >= end) return true;\n    int key = sequence[end - 1];\n    int split = start;\n    while(sequence[split] < key) split++;\n    for(int i = split; i < end; i++){\n        if(sequence[i] < key) return false;\n    }\n    return isPostSequenceCore(sequence, start, split) \n        && isPostSequenceCore(sequence, split, end - 1);\n}\n\nbool isPostSequence(int sequence[], int len){\n    if(sequence == nullptr || len <= 0) return false;\n    return isPostSequenceCore(sequence, 0, len);\n}\n```\n\n> 如果是c++的话，也可以直接用指针代替start。\n\n## 面34：树的路径的元素之和\n\n### 题面：\n\n打印出树的路径上的值之和与给定数字相同的所有路径。路径从根到叶子。\n\n### 思路：\n\ndfs遍历 + 记录路径即可。\n\n### 代码：\n\n```\nvoid PrintPathCore(BinaryTreeNode* pNode, stack<int> &s, int add, int expectedSum){\n    s.push((int)pNode->dbValue);\n    add += (int)(pNode->dbValue);\n    if(pNode->pLeft == nullptr && pNode->pRight == nullptr){\n        if(add == expectedSum){\n            stack<int> sTemp;\n            while(s.size()){\n               \n                sTemp.push(s.top());\n                s.pop();                \n            }\n            while(sTemp.size()){\n                printf(\"%d->\", sTemp.top());\n                s.push(sTemp.top());\n                sTemp.pop();\n            }\n            printf(\"\\n\");\n        }\n        // printf(\"%d, %d, %d\\n\", expectedSum, add, s.size());\n        s.pop();\n        return;\n    }\n    if(pNode->pLeft) PrintPathCore(pNode->pLeft, s, add, expectedSum);    \n    if(pNode->pRight) PrintPathCore(pNode->pRight, s, add, expectedSum);\n    s.pop();\n}\n\n\nvoid PrintPath(BinaryTreeNode* pHead, int expectedSum){\n    if(pHead == nullptr) return;\n\tstack<int> s;\n    PrintPathCore(pHead, s, 0, expectedSum);\n    printf(\"\\n\");\n}\n```\n\n> 中午时间不要打代码，太困了\n\n\n\n## [437. Path Sum III](https://leetcode-cn.com/problems/path-sum-iii/) 路径之和\n\n类似，但不相同。\n\n前缀和 + 递归\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int count = 0;\n    int pathSum(TreeNode* root, int sum) {\n        add(root, 0);    \n        findNode(root, sum, 0);\n        return count;\n    }\n    void findNode(TreeNode* root, int num, int presum){\n        if(!root) return;\n        cal(root, num, presum);\n        findNode(root->left, num, root->val);\n        findNode(root->right, num, root->val);\n    }\n    void cal(TreeNode* root, int target, int presum){\n        if(!root) return;\n        if(root->val - presum == target) count++;\n        cal(root->left, target, presum);\n        cal(root->right, target, presum);\n    }\n    void add(TreeNode* root, int presum){\n        if(!root) return;\n        root->val += presum;\n        add(root->left, root->val);\n        add(root->right, root->val);\n    }\n};\n```\n\n\n\n写法二：提供一种递归的小小思路\n\n```c++\nclass Solution {\npublic:\n    int count = 0;\n    int pathSum(TreeNode* root, int sum) {\n        if(!root) return 0;\n        return cal(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n    }\n    int cal(TreeNode* root, int sum){\n        if(!root) return 0;\n        sum -= root->val;\n        return (sum == 0) + cal(root->left, sum) + cal(root->right, sum);\n    }\n    \n};\n```\n\n\n\n最优解法：前缀和 + 回溯 + 维护前缀和出现的次数：`times[presum]`\n\n> 突然想到3数之和。\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<int, int> ct = {{0,1}};\n    int pathSum(TreeNode* root, int sum) {\n        int amount = 0;\n        dfs(root, 0, sum, amount);\n        return amount;\n    }\n    void dfs(TreeNode *root, int presum, int sum, int &amount){\n        if(!root) return;\n        root->val += presum;\n        amount += ct[root->val - sum];\n\n        ++ct[root->val];\n        dfs(root->left, root->val, sum, amount);\n        dfs(root->right, root->val, sum, amount);\n        --ct[root->val];\n\n    }\n    \n};\n```\n\n\n\n## 面36：把二叉搜索树转化为双向链表（同链表中的内容）\n\n### 题面：\n\n如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。\n\n### 思路：\n\n可以从递归的角度入手。对于一个节点`A`，中序遍历到`A`，则`A`的左子树已经转化为了链表，连接好`A`和`A`的左子树的最大节点（前一个指针）的指针则连接完成。\n\n那对于`A`的右子树的最小节点`B`与`A`之间的连接，也可以看成`B`与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。\n\n注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。\n\n> 对于一个节点`A`的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点`B`的指针，并设置好`B`的右指针和`A`的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是`NULL`，所以无需修改。\n\n### 代码：\n\n```\nvoid AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&preNode, BinaryTreeNode *&pHead){\n    if(pRoot == nullptr) return;\n  \tAdjustLinkCore(pRoot->pLeft, preNode, pHead);\n\n    if(pHead == nullptr) pHead = pRoot;\n    pRoot->pLeft = preNode;\n    if(preNode) preNode->pRight = pRoot;\n    preNode = pRoot;\n    \n    AdjustLinkCore(pRoot->pRight, preNode, pHead);\n}\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){\n    BinaryTreeNode *preNode = nullptr;\n    BinaryTreeNode *pHead = nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n}\n```\n\n## 面36：序列化和反序列化二叉树\n\n### 题面：\n\n序列化定义：\n\n> 序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。\n\n二叉树的序列化可以把非空节点的值序列化，把空节点序列化为`$`。\n\n### 思路：\n\n由于序列化把空节点的信息也包含进来了，所以无需添加更多序列。\n\n> 这题更像流的应用题\n\n### 代码：\n\n```\nvoid Serialize(BinaryTreeNode *pRoot, ostream& stream){\n    if(pRoot == nullptr){\n        stream << '$';\n        return;\n    } \n    stream << pRoot->value << ',';\n    Serialize(pRoot->pLeft);\n    Serialize(pRoot->pRight);    \n}\n\nvoid Deserialize(BinaryTreeNode *&pRoot, istream& stream){\n\tint number;\n    if(ReadSteam(stream, &number)){\n        pRoot = new BinaryTreeNode();\n        pNew->pLeft = nullptr;\n        pNew->pRight = nullptr;\n        pNew->value = number;\n    }\n    Deserialize(pRoot->pLeft, stream);\n\tDeserialize(pRoot->pRight, steam);    \n}\n\n```\n\n","slug":"刷题/数据结构/树/面试题-二叉树","published":1,"updated":"2021-04-01T08:29:08.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7q005vl5uofept5k3t","content":"<p>收集二叉树相关题目，相关测试代码见<a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp\">此</a>。</p>\n<span id=\"more\"></span>\n\n<p>sCmd = ‘C:; cd C:\\Users\\xusx\\Sumo\\SUMO\\bin; duarouter -n xsxlankershim.net.xml –route-files xsx.flow.xml -o rou.rou.xml’<br>os.system(sCmd)</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">struct BinaryTreeNode&#123;\n    double dbValue;\n    BinaryTreeNode *pLeft;\n    BinaryTreeNode *pRight;   \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面7：中序遍历和前序遍历序列来重建二叉树\"><a href=\"#面7：中序遍历和前序遍历序列来重建二叉树\" class=\"headerlink\" title=\"面7：中序遍历和前序遍历序列来重建二叉树\"></a>面7：中序遍历和前序遍历序列来重建二叉树</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">BinaryTreeNode* ConstructNode(int *startPreorder,  int *endPreordrer, \n                              int *startInorder, int *endInorder)&#123;\n    &#x2F;&#x2F;这个代码健壮性就很好！对空值和非法输出进行了区分。\n\tif(startPreorder &gt; endPreorder  || startInorder &gt; endInorder )&#123;\t\n        if(startPreorder &#x3D;&#x3D; endPreorder - 1  &amp;&amp; startInorder &#x3D;&#x3D;  endInorder - 1) \n        \treturn nullptr;\n        else \n            throw std::exception(&quot;Invalid Input.\\n&quot;);\n    &#125; \n    &#x2F;&#x2F;寻找中序遍历中的根节点值坐标\n    int nodeValue &#x3D; startPreordre[0];\n\tint *rootInorder &#x3D; startInorder;\n    for(; rootInorder &lt;&#x3D; enInorder &amp;&amp; *rootInordre !&#x3D; nodevalue; rootInorder++);\n\t&#x2F;&#x2F;健壮一下\n    if(enInorder &lt; rootInorder)&#123;\n        throw std::exception(&quot;Invalid input!\\n&quot;);\n    &#125;\n    &#x2F;&#x2F;构建左右子树\n    BinaryTreeNode* pNode &#x3D; new BinaryTreeNode();\n    int lNodeNum &#x3D; rootInorder - startInorder;\n    pNode-&gt;pLeft &#x3D; \n        ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1);\n    pNode-&gt;pRight &#x3D; \n        ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder);\n    pNode-&gt;value &#x3D; nodeValue;\n    return pNode;\n\t\n&#125;\n\nBinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length)&#123;\n    &#x2F;&#x2F;length &#x3D;&#x3D; 0的代码的健壮性显然不如 length &lt;&#x3D; 0\n    if(preorder &#x3D;&#x3D; null || inorder &#x3D;&#x3D; null || length &lt;&#x3D; 0) return nullptr;\n\treturn ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1);\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面8：二叉树的下一个节点\"><a href=\"#面8：二叉树的下一个节点\" class=\"headerlink\" title=\"面8：二叉树的下一个节点\"></a>面8：二叉树的下一个节点</h2><p>第一次考虑的时候居然还想错了，分析不够全面。从二叉树中序遍历来看，若一个节点有右子树，则下一个节点就是其右子树的最左节点。倘若没有，则必然是考虑父亲节点。如果该节点是父亲节点的左子节点，那么下一个节点就是父亲节点，不然可以溯源查找其父辈节点是左子树的祖父节点。这个过程可以使用父亲节点和迭代完成。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BinaryTreeNode *GetNext(BinaryTreeNode *pNode)&#123;\n    if(pNode &#x3D;&#x3D; nullptr) return;\n    if(pNode-&gt;pRight)&#123;\n        BinaryTreeNode* pChild &#x3D; pNode-&gt;pRight;\n        while(pChild-&gt;pLeft !&#x3D; nullptr) pChild &#x3D; pChild-&gt;pRight;\n        return pChild;\n    &#125;else&#123;\n        BinaryTreeNode* pParent &#x3D; pNode-&gt;pParent, *pCurrent &#x3D; pNode;\n\t\t&#x2F;&#x2F;循环控制条件有点像哨兵，没有找到的话pParent自然就是unllptr,代码更加简洁了\n        while(pParent !&#x3D; nullptr &amp;&amp; pParent-&gt;pRight !&#x3D; pCurrent)&#123;\n            pCurrent &#x3D; pParent;\n            pParent &#x3D; pParent-&gt;pParent;\n        &#125;\n        return pParent;       \n    &#125;\n    return nullptr;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>相比之前的代码这个写法差一点点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">while(pParent-&gt;pParent !&#x3D; nullptr &amp;&amp; pParent-&gt;pRight !&#x3D; pCurrent)&#123;\n            pCurrent &#x3D; pParent;\n            pParent &#x3D; pParent-&gt;pParent;\n        &#125;\n        if(pParent-&gt;pRight &#x3D;&#x3D; pCurrent)&#123;\n            return pParent;\n        &#125;\n       <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<h2 id=\"面26：树的子结构\"><a href=\"#面26：树的子结构\" class=\"headerlink\" title=\"面26：树的子结构\"></a>面26：树的子结构</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>输入两棵树<code>A</code>和<code>B</code>，判断<code>B</code>是否是<code>A</code>的子结构。<code>B</code>是<code>A</code>的子结构子结构定义为<code>A</code>的一部分和<code>B</code>完全相同。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>递归的判断对<code>A</code>的每一个节点判断该节点下的是否有<code>B</code>的结构。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2)&#123;\n\tif(pRoot2 &#x3D;&#x3D; nullptr) return true;\n    else if(pRoot1 &#x3D;&#x3D; nullptr) return false;\n    \n    if(equal(pRoot1-&gt;dbValue, pRoot2-&gt;dbValue))&#123;\n        if(pRoot2-&gt;pRight &#x3D;&#x3D; nullptr &amp;&amp; pRoot2-&gt;pLeft &#x3D;&#x3D; nullptr) return true;\n\t    return judgeSameTree(pRoot1-&gt;pLeft, pRoot2-&gt;pLeft)\n            &amp;&amp; judgeSameTree(pRoot2-&gt;pRight, pRoot2-&gt;pRight);\n    &#125;\n    return false;\n&#125;\n\nbool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2)&#123;\n\tif(pRoot1)&#123;\n        if(judgeSameTree(pRoot1, pRoot2)) return true;\n        else return HasSubtreeCore(pRoot1-&gt;pLeft, pRoot2) \n            \t|| HasSubtreeCore(pRoot1-&gt;pRight, pRight);\n    &#125;\n    return false;\n&#125;\nbool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2)&#123;\n    if(pRoot2 &#x3D;&#x3D; nullptr) return true;\n    if(pRoot1 &#x3D;&#x3D; nullptr) return false;\n    return HasSubtreeCore(pRoot1, pRoot2);   \t    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><p><a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp\">参见</a></p>\n<h2 id=\"面27：翻转二叉树\"><a href=\"#面27：翻转二叉树\" class=\"headerlink\" title=\"面27：翻转二叉树\"></a>面27：翻转二叉树</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一棵二叉树并返回其镜像二叉树。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>直接交换节点的左右指针节点即可。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">BinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode)&#123;\n    if(pNode &#x3D;&#x3D; nullptr) return nullptr;\n    BinaryTreeNode *pTemp &#x3D; pNode-&gt;pRight;\n    pNode-&gt;pRight &#x3D; pNode-&gt;pLeft;\n    pNode-&gt;pLeft &#x3D; pTemp;\n\tMirrorRecursively(pNode-&gt;pLeft);\n    MirrorRecursively(pNode-&gt;pRight);\n    return pNode;    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面28：对称二叉树\"><a href=\"#面28：对称二叉树\" class=\"headerlink\" title=\"面28：对称二叉树\"></a>面28：对称二叉树</h2><h3 id=\"题面：-2\"><a href=\"#题面：-2\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>判断一棵树是否对称。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>从第一个节点左子树开始递归的判断，其右子树的节点是否完全相同。只需要一边对另一边镜像操作就ok。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool isSymmetrical(BinaryTreeNode* pHead)&#123;\n\tif(pHead &#x3D;&#x3D; nullptr) return true;\n    return isSymmetricalCore(pHead-&gt;pLeft, pHead-&gt;pRight);\n&#125;\nbool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2)&#123;\n    if(p1 &#x3D;&#x3D; nullptr &amp;&amp; p2 &#x3D;&#x3D; nullptr) return true;\n    if(p1 &#x3D;&#x3D; nullptr &amp;&amp; p2 !&#x3D; nullptr \n       || p2 &#x3D;&#x3D; nullptr &amp;&amp; p1 !&#x3D; nullptr\n      || p1-&gt;value !&#x3D; p2-&gt;value) \n    \treturn false;\n    return isSemmetricalCore(p1-&gt;left, p2-&gt;right) \n    \t&amp;&amp;  isSemmetricalCore(p1-&gt;right, p2-&gt;left);    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>有趣的是，我这种写法也可以看成前序遍历序列和对称前序遍历序列的比较。</p>\n</blockquote>\n<h2 id=\"面32：层序遍历二叉树\"><a href=\"#面32：层序遍历二叉树\" class=\"headerlink\" title=\"面32：层序遍历二叉树\"></a>面32：层序遍历二叉树</h2><h3 id=\"题面：-3\"><a href=\"#题面：-3\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如标题</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>层序遍历</p>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintByLayer(BinaryTreeNode* pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    queue&lt;BinaryTreeNode*&gt; que;\n    que.push(pHead);\n    while(que.size())&#123;\n        BinaryTreeNode *pNode &#x3D; que.front();\n        que.pop();\n        printf(&quot;%.2f &quot;, pNode-&gt;dbValue);\n        if(pNode-&gt;pLeft) que.push(pNode-&gt;pLeft);\n        if(pNode-&gt;pRight) que.push(pNode-&gt;pRight);        \n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面32相关题：分行打印层序遍历二叉树\"><a href=\"#面32相关题：分行打印层序遍历二叉树\" class=\"headerlink\" title=\"面32相关题：分行打印层序遍历二叉树\"></a>面32相关题：分行打印层序遍历二叉树</h2><h3 id=\"题面：-4\"><a href=\"#题面：-4\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如标题</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>在层序遍历的基础上，有两种解题思路：一是记录当前层未打印的节点数量和下一层的需要打印的节点数量，二是在队列中添加一个一层的节点末端的标志符、</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintByLayerSparate(BinaryTreeNode* pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    queue&lt;BinaryTreeNode*&gt; que;\n    que.push(pHead);\n\tint printValue &#x3D; 1, nextValue &#x3D; 0;\n    while(que.size())&#123;\n        BinaryTreeNode *pNode &#x3D; que.front();\n        que.pop();\n        printValue--;\n        printf(&quot;%.2f &quot;, pNode-&gt;dbValue);\n        if(pNode-&gt;pLeft)&#123;\n          \tque.push(pNode-&gt;pLeft);\n            nextValue++;\n        &#125; \n        if(pNode-&gt;pRight)&#123;\n            que.push(pNode-&gt;pRight);          \n            nextValue++;\n        &#125;\n        \n        if(printValue &#x3D;&#x3D; 0)&#123;\n            printValue &#x3D; nextValue;\n            nextValue &#x3D; 0;\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面32相关题：之字形打印二叉树\"><a href=\"#面32相关题：之字形打印二叉树\" class=\"headerlink\" title=\"面32相关题：之字形打印二叉树\"></a>面32相关题：之字形打印二叉树</h2><h3 id=\"题面：-5\"><a href=\"#题面：-5\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如标题</p>\n<h3 id=\"思路：-5\"><a href=\"#思路：-5\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>一种方法就是分层层序遍历+栈逆序存储并输出。</p>\n<p>第二种方法就用栈把一层的节点逆序输出，并将下一层的节点记录在另一个栈中，如此循环，输出所有的层。</p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PirntZhi(BinaryTreeNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    stack&lt;BinaryTreeNode*&gt; s[2];\n    int cur &#x3D; 0;\n    s[cur].push(pHead);\n    BinaryTreeNode *pNode &#x3D; nullptr;\n    while(s[cur].size())&#123;\n        while(s[cur].size())&#123;\n\t\t   pNode &#x3D; s[cur].top();\n            s[cur].pop();\n            printf(&quot;%.2 &quot;, pNode-&gt;dbValue);\n            if(cur &#x3D;&#x3D; 0)&#123;\n                if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft);\n                if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight);                \n            &#125;else&#123;\n                if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight);                \n            \tif(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft);                \n            &#125;\n        &#125;\n       \tprintf(&quot;\\n&quot;);\n        cur &#x3D; 1- cur;\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"103-Binary-Tree-Zigzag-Level-Order-Traversal\"><a href=\"#103-Binary-Tree-Zigzag-Level-Order-Traversal\" class=\"headerlink\" title=\"103. Binary Tree Zigzag Level Order Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">103. Binary Tree Zigzag Level Order Traversal</a></h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;\n        if(!root) return &#123;&#125;;\n        stack&lt;TreeNode*&gt; cur1, cur2;\n        cur1.push(root);\n        vector&lt;vector&lt;int&gt;&gt; zigarr;\n        int flag &#x3D; 1;\n        while(cur1.size() || cur2.size())&#123;\n            if(flag) zigview(cur1, cur2, zigarr, flag), flag &#x3D; 1 - flag ;\n            else  zigview(cur2, cur1, zigarr, flag), flag &#x3D; 1 - flag;\n        &#125;\n        return zigarr;\n    &#125;\n\n    void zigview(stack&lt;TreeNode*&gt;&amp; now, stack&lt;TreeNode*&gt;&amp; next, vector&lt;vector&lt;int&gt;&gt; &amp;zigarr, int flag)&#123;\n        vector&lt;int&gt; arr;\n        while(!now.empty())&#123;\n            arr.push_back(now.top()-&gt;val);\n            if(flag)&#123;\n                if(now.top()-&gt;left) next.push(now.top()-&gt;left);\n                if(now.top()-&gt;right) next.push(now.top()-&gt;right);\n                now.pop();\n            &#125;else&#123;\n                if(now.top()-&gt;right) next.push(now.top()-&gt;right);\n                if(now.top()-&gt;left) next.push(now.top()-&gt;left);\n                now.pop();\n            &#125;            \n        &#125;\n        zigarr.push_back(arr);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"面33-判断后序遍历序列有效性\"><a href=\"#面33-判断后序遍历序列有效性\" class=\"headerlink\" title=\"面33:判断后序遍历序列有效性\"></a>面33:判断后序遍历序列有效性</h2><h3 id=\"题面：-6\"><a href=\"#题面：-6\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给定一颗二叉搜索树的后续遍历序列，判断该后序遍历序列是否合法。</p>\n<h3 id=\"思路：-6\"><a href=\"#思路：-6\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>依据后续遍历的定义，可以把序列依据最后一个元素<code>K</code>分成两半，且满足前一部分全部小于<code>K</code>的值，后一部分全部大于<code>K</code>的值，若不符合这个结论，则该后序遍历不可能存在一颗二叉树与之对应。递归的判断这两部分是否符合这些定义。</p>\n<h3 id=\"代码：-6\"><a href=\"#代码：-6\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool isPostSequenceCore(int sequence[], int start, int end)&#123;\n    if(start &gt;&#x3D; end) return true;\n    int key &#x3D; sequence[end - 1];\n    int split &#x3D; start;\n    while(sequence[split] &lt; key) split++;\n    for(int i &#x3D; split; i &lt; end; i++)&#123;\n        if(sequence[i] &lt; key) return false;\n    &#125;\n    return isPostSequenceCore(sequence, start, split) \n        &amp;&amp; isPostSequenceCore(sequence, split, end - 1);\n&#125;\n\nbool isPostSequence(int sequence[], int len)&#123;\n    if(sequence &#x3D;&#x3D; nullptr || len &lt;&#x3D; 0) return false;\n    return isPostSequenceCore(sequence, 0, len);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>如果是c++的话，也可以直接用指针代替start。</p>\n</blockquote>\n<h2 id=\"面34：树的路径的元素之和\"><a href=\"#面34：树的路径的元素之和\" class=\"headerlink\" title=\"面34：树的路径的元素之和\"></a>面34：树的路径的元素之和</h2><h3 id=\"题面：-7\"><a href=\"#题面：-7\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>打印出树的路径上的值之和与给定数字相同的所有路径。路径从根到叶子。</p>\n<h3 id=\"思路：-7\"><a href=\"#思路：-7\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>dfs遍历 + 记录路径即可。</p>\n<h3 id=\"代码：-7\"><a href=\"#代码：-7\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintPathCore(BinaryTreeNode* pNode, stack&lt;int&gt; &amp;s, int add, int expectedSum)&#123;\n    s.push((int)pNode-&gt;dbValue);\n    add +&#x3D; (int)(pNode-&gt;dbValue);\n    if(pNode-&gt;pLeft &#x3D;&#x3D; nullptr &amp;&amp; pNode-&gt;pRight &#x3D;&#x3D; nullptr)&#123;\n        if(add &#x3D;&#x3D; expectedSum)&#123;\n            stack&lt;int&gt; sTemp;\n            while(s.size())&#123;\n               \n                sTemp.push(s.top());\n                s.pop();                \n            &#125;\n            while(sTemp.size())&#123;\n                printf(&quot;%d-&gt;&quot;, sTemp.top());\n                s.push(sTemp.top());\n                sTemp.pop();\n            &#125;\n            printf(&quot;\\n&quot;);\n        &#125;\n        &#x2F;&#x2F; printf(&quot;%d, %d, %d\\n&quot;, expectedSum, add, s.size());\n        s.pop();\n        return;\n    &#125;\n    if(pNode-&gt;pLeft) PrintPathCore(pNode-&gt;pLeft, s, add, expectedSum);    \n    if(pNode-&gt;pRight) PrintPathCore(pNode-&gt;pRight, s, add, expectedSum);\n    s.pop();\n&#125;\n\n\nvoid PrintPath(BinaryTreeNode* pHead, int expectedSum)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n\tstack&lt;int&gt; s;\n    PrintPathCore(pHead, s, 0, expectedSum);\n    printf(&quot;\\n&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>中午时间不要打代码，太困了</p>\n</blockquote>\n<h2 id=\"437-Path-Sum-III-路径之和\"><a href=\"#437-Path-Sum-III-路径之和\" class=\"headerlink\" title=\"437. Path Sum III 路径之和\"></a><a href=\"https://leetcode-cn.com/problems/path-sum-iii/\">437. Path Sum III</a> 路径之和</h2><p>类似，但不相同。</p>\n<p>前缀和 + 递归</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int count &#x3D; 0;\n    int pathSum(TreeNode* root, int sum) &#123;\n        add(root, 0);    \n        findNode(root, sum, 0);\n        return count;\n    &#125;\n    void findNode(TreeNode* root, int num, int presum)&#123;\n        if(!root) return;\n        cal(root, num, presum);\n        findNode(root-&gt;left, num, root-&gt;val);\n        findNode(root-&gt;right, num, root-&gt;val);\n    &#125;\n    void cal(TreeNode* root, int target, int presum)&#123;\n        if(!root) return;\n        if(root-&gt;val - presum &#x3D;&#x3D; target) count++;\n        cal(root-&gt;left, target, presum);\n        cal(root-&gt;right, target, presum);\n    &#125;\n    void add(TreeNode* root, int presum)&#123;\n        if(!root) return;\n        root-&gt;val +&#x3D; presum;\n        add(root-&gt;left, root-&gt;val);\n        add(root-&gt;right, root-&gt;val);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>写法二：提供一种递归的小小思路</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int count &#x3D; 0;\n    int pathSum(TreeNode* root, int sum) &#123;\n        if(!root) return 0;\n        return cal(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);\n    &#125;\n    int cal(TreeNode* root, int sum)&#123;\n        if(!root) return 0;\n        sum -&#x3D; root-&gt;val;\n        return (sum &#x3D;&#x3D; 0) + cal(root-&gt;left, sum) + cal(root-&gt;right, sum);\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>最优解法：前缀和 + 回溯 + 维护前缀和出现的次数：<code>times[presum]</code></p>\n<blockquote>\n<p>突然想到3数之和。</p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; ct &#x3D; &#123;&#123;0,1&#125;&#125;;\n    int pathSum(TreeNode* root, int sum) &#123;\n        int amount &#x3D; 0;\n        dfs(root, 0, sum, amount);\n        return amount;\n    &#125;\n    void dfs(TreeNode *root, int presum, int sum, int &amp;amount)&#123;\n        if(!root) return;\n        root-&gt;val +&#x3D; presum;\n        amount +&#x3D; ct[root-&gt;val - sum];\n\n        ++ct[root-&gt;val];\n        dfs(root-&gt;left, root-&gt;val, sum, amount);\n        dfs(root-&gt;right, root-&gt;val, sum, amount);\n        --ct[root-&gt;val];\n\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"面36：把二叉搜索树转化为双向链表（同链表中的内容）\"><a href=\"#面36：把二叉搜索树转化为双向链表（同链表中的内容）\" class=\"headerlink\" title=\"面36：把二叉搜索树转化为双向链表（同链表中的内容）\"></a>面36：把二叉搜索树转化为双向链表（同链表中的内容）</h2><h3 id=\"题面：-8\"><a href=\"#题面：-8\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。</p>\n<h3 id=\"思路：-8\"><a href=\"#思路：-8\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以从递归的角度入手。对于一个节点<code>A</code>，中序遍历到<code>A</code>，则<code>A</code>的左子树已经转化为了链表，连接好<code>A</code>和<code>A</code>的左子树的最大节点（前一个指针）的指针则连接完成。</p>\n<p>那对于<code>A</code>的右子树的最小节点<code>B</code>与<code>A</code>之间的连接，也可以看成<code>B</code>与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。</p>\n<p>注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。</p>\n<blockquote>\n<p>对于一个节点<code>A</code>的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点<code>B</code>的指针，并设置好<code>B</code>的右指针和<code>A</code>的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是<code>NULL</code>，所以无需修改。</p>\n</blockquote>\n<h3 id=\"代码：-8\"><a href=\"#代码：-8\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead)&#123;\n    if(pRoot &#x3D;&#x3D; nullptr) return;\n  \tAdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead);\n\n    if(pHead &#x3D;&#x3D; nullptr) pHead &#x3D; pRoot;\n    pRoot-&gt;pLeft &#x3D; preNode;\n    if(preNode) preNode-&gt;pRight &#x3D; pRoot;\n    preNode &#x3D; pRoot;\n    \n    AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead);\n&#125;\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot)&#123;\n    BinaryTreeNode *preNode &#x3D; nullptr;\n    BinaryTreeNode *pHead &#x3D; nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面36：序列化和反序列化二叉树\"><a href=\"#面36：序列化和反序列化二叉树\" class=\"headerlink\" title=\"面36：序列化和反序列化二叉树\"></a>面36：序列化和反序列化二叉树</h2><h3 id=\"题面：-9\"><a href=\"#题面：-9\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>序列化定义：</p>\n<blockquote>\n<p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p>\n</blockquote>\n<p>二叉树的序列化可以把非空节点的值序列化，把空节点序列化为<code>$</code>。</p>\n<h3 id=\"思路：-9\"><a href=\"#思路：-9\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>由于序列化把空节点的信息也包含进来了，所以无需添加更多序列。</p>\n<blockquote>\n<p>这题更像流的应用题</p>\n</blockquote>\n<h3 id=\"代码：-9\"><a href=\"#代码：-9\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void Serialize(BinaryTreeNode *pRoot, ostream&amp; stream)&#123;\n    if(pRoot &#x3D;&#x3D; nullptr)&#123;\n        stream &lt;&lt; &#39;$&#39;;\n        return;\n    &#125; \n    stream &lt;&lt; pRoot-&gt;value &lt;&lt; &#39;,&#39;;\n    Serialize(pRoot-&gt;pLeft);\n    Serialize(pRoot-&gt;pRight);    \n&#125;\n\nvoid Deserialize(BinaryTreeNode *&amp;pRoot, istream&amp; stream)&#123;\n\tint number;\n    if(ReadSteam(stream, &amp;number))&#123;\n        pRoot &#x3D; new BinaryTreeNode();\n        pNew-&gt;pLeft &#x3D; nullptr;\n        pNew-&gt;pRight &#x3D; nullptr;\n        pNew-&gt;value &#x3D; number;\n    &#125;\n    Deserialize(pRoot-&gt;pLeft, stream);\n\tDeserialize(pRoot-&gt;pRight, steam);    \n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"2YBVX0X","excerpt":"<p>收集二叉树相关题目，相关测试代码见<a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp\">此</a>。</p>","more":"<p>sCmd = ‘C:; cd C:\\Users\\xusx\\Sumo\\SUMO\\bin; duarouter -n xsxlankershim.net.xml –route-files xsx.flow.xml -o rou.rou.xml’<br>os.system(sCmd)</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">struct BinaryTreeNode&#123;\n    double dbValue;\n    BinaryTreeNode *pLeft;\n    BinaryTreeNode *pRight;   \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面7：中序遍历和前序遍历序列来重建二叉树\"><a href=\"#面7：中序遍历和前序遍历序列来重建二叉树\" class=\"headerlink\" title=\"面7：中序遍历和前序遍历序列来重建二叉树\"></a>面7：中序遍历和前序遍历序列来重建二叉树</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">BinaryTreeNode* ConstructNode(int *startPreorder,  int *endPreordrer, \n                              int *startInorder, int *endInorder)&#123;\n    &#x2F;&#x2F;这个代码健壮性就很好！对空值和非法输出进行了区分。\n\tif(startPreorder &gt; endPreorder  || startInorder &gt; endInorder )&#123;\t\n        if(startPreorder &#x3D;&#x3D; endPreorder - 1  &amp;&amp; startInorder &#x3D;&#x3D;  endInorder - 1) \n        \treturn nullptr;\n        else \n            throw std::exception(&quot;Invalid Input.\\n&quot;);\n    &#125; \n    &#x2F;&#x2F;寻找中序遍历中的根节点值坐标\n    int nodeValue &#x3D; startPreordre[0];\n\tint *rootInorder &#x3D; startInorder;\n    for(; rootInorder &lt;&#x3D; enInorder &amp;&amp; *rootInordre !&#x3D; nodevalue; rootInorder++);\n\t&#x2F;&#x2F;健壮一下\n    if(enInorder &lt; rootInorder)&#123;\n        throw std::exception(&quot;Invalid input!\\n&quot;);\n    &#125;\n    &#x2F;&#x2F;构建左右子树\n    BinaryTreeNode* pNode &#x3D; new BinaryTreeNode();\n    int lNodeNum &#x3D; rootInorder - startInorder;\n    pNode-&gt;pLeft &#x3D; \n        ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1);\n    pNode-&gt;pRight &#x3D; \n        ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder);\n    pNode-&gt;value &#x3D; nodeValue;\n    return pNode;\n\t\n&#125;\n\nBinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length)&#123;\n    &#x2F;&#x2F;length &#x3D;&#x3D; 0的代码的健壮性显然不如 length &lt;&#x3D; 0\n    if(preorder &#x3D;&#x3D; null || inorder &#x3D;&#x3D; null || length &lt;&#x3D; 0) return nullptr;\n\treturn ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1);\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面8：二叉树的下一个节点\"><a href=\"#面8：二叉树的下一个节点\" class=\"headerlink\" title=\"面8：二叉树的下一个节点\"></a>面8：二叉树的下一个节点</h2><p>第一次考虑的时候居然还想错了，分析不够全面。从二叉树中序遍历来看，若一个节点有右子树，则下一个节点就是其右子树的最左节点。倘若没有，则必然是考虑父亲节点。如果该节点是父亲节点的左子节点，那么下一个节点就是父亲节点，不然可以溯源查找其父辈节点是左子树的祖父节点。这个过程可以使用父亲节点和迭代完成。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BinaryTreeNode *GetNext(BinaryTreeNode *pNode)&#123;\n    if(pNode &#x3D;&#x3D; nullptr) return;\n    if(pNode-&gt;pRight)&#123;\n        BinaryTreeNode* pChild &#x3D; pNode-&gt;pRight;\n        while(pChild-&gt;pLeft !&#x3D; nullptr) pChild &#x3D; pChild-&gt;pRight;\n        return pChild;\n    &#125;else&#123;\n        BinaryTreeNode* pParent &#x3D; pNode-&gt;pParent, *pCurrent &#x3D; pNode;\n\t\t&#x2F;&#x2F;循环控制条件有点像哨兵，没有找到的话pParent自然就是unllptr,代码更加简洁了\n        while(pParent !&#x3D; nullptr &amp;&amp; pParent-&gt;pRight !&#x3D; pCurrent)&#123;\n            pCurrent &#x3D; pParent;\n            pParent &#x3D; pParent-&gt;pParent;\n        &#125;\n        return pParent;       \n    &#125;\n    return nullptr;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>相比之前的代码这个写法差一点点</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">while(pParent-&gt;pParent !&#x3D; nullptr &amp;&amp; pParent-&gt;pRight !&#x3D; pCurrent)&#123;\n            pCurrent &#x3D; pParent;\n            pParent &#x3D; pParent-&gt;pParent;\n        &#125;\n        if(pParent-&gt;pRight &#x3D;&#x3D; pCurrent)&#123;\n            return pParent;\n        &#125;\n       <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<h2 id=\"面26：树的子结构\"><a href=\"#面26：树的子结构\" class=\"headerlink\" title=\"面26：树的子结构\"></a>面26：树的子结构</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>输入两棵树<code>A</code>和<code>B</code>，判断<code>B</code>是否是<code>A</code>的子结构。<code>B</code>是<code>A</code>的子结构子结构定义为<code>A</code>的一部分和<code>B</code>完全相同。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>递归的判断对<code>A</code>的每一个节点判断该节点下的是否有<code>B</code>的结构。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2)&#123;\n\tif(pRoot2 &#x3D;&#x3D; nullptr) return true;\n    else if(pRoot1 &#x3D;&#x3D; nullptr) return false;\n    \n    if(equal(pRoot1-&gt;dbValue, pRoot2-&gt;dbValue))&#123;\n        if(pRoot2-&gt;pRight &#x3D;&#x3D; nullptr &amp;&amp; pRoot2-&gt;pLeft &#x3D;&#x3D; nullptr) return true;\n\t    return judgeSameTree(pRoot1-&gt;pLeft, pRoot2-&gt;pLeft)\n            &amp;&amp; judgeSameTree(pRoot2-&gt;pRight, pRoot2-&gt;pRight);\n    &#125;\n    return false;\n&#125;\n\nbool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2)&#123;\n\tif(pRoot1)&#123;\n        if(judgeSameTree(pRoot1, pRoot2)) return true;\n        else return HasSubtreeCore(pRoot1-&gt;pLeft, pRoot2) \n            \t|| HasSubtreeCore(pRoot1-&gt;pRight, pRight);\n    &#125;\n    return false;\n&#125;\nbool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2)&#123;\n    if(pRoot2 &#x3D;&#x3D; nullptr) return true;\n    if(pRoot1 &#x3D;&#x3D; nullptr) return false;\n    return HasSubtreeCore(pRoot1, pRoot2);   \t    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"测试：\"><a href=\"#测试：\" class=\"headerlink\" title=\"测试：\"></a>测试：</h3><p><a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/BinaryTreeTest.cpp\">参见</a></p>\n<h2 id=\"面27：翻转二叉树\"><a href=\"#面27：翻转二叉树\" class=\"headerlink\" title=\"面27：翻转二叉树\"></a>面27：翻转二叉树</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一棵二叉树并返回其镜像二叉树。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>直接交换节点的左右指针节点即可。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">BinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode)&#123;\n    if(pNode &#x3D;&#x3D; nullptr) return nullptr;\n    BinaryTreeNode *pTemp &#x3D; pNode-&gt;pRight;\n    pNode-&gt;pRight &#x3D; pNode-&gt;pLeft;\n    pNode-&gt;pLeft &#x3D; pTemp;\n\tMirrorRecursively(pNode-&gt;pLeft);\n    MirrorRecursively(pNode-&gt;pRight);\n    return pNode;    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面28：对称二叉树\"><a href=\"#面28：对称二叉树\" class=\"headerlink\" title=\"面28：对称二叉树\"></a>面28：对称二叉树</h2><h3 id=\"题面：-2\"><a href=\"#题面：-2\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>判断一棵树是否对称。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>从第一个节点左子树开始递归的判断，其右子树的节点是否完全相同。只需要一边对另一边镜像操作就ok。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool isSymmetrical(BinaryTreeNode* pHead)&#123;\n\tif(pHead &#x3D;&#x3D; nullptr) return true;\n    return isSymmetricalCore(pHead-&gt;pLeft, pHead-&gt;pRight);\n&#125;\nbool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2)&#123;\n    if(p1 &#x3D;&#x3D; nullptr &amp;&amp; p2 &#x3D;&#x3D; nullptr) return true;\n    if(p1 &#x3D;&#x3D; nullptr &amp;&amp; p2 !&#x3D; nullptr \n       || p2 &#x3D;&#x3D; nullptr &amp;&amp; p1 !&#x3D; nullptr\n      || p1-&gt;value !&#x3D; p2-&gt;value) \n    \treturn false;\n    return isSemmetricalCore(p1-&gt;left, p2-&gt;right) \n    \t&amp;&amp;  isSemmetricalCore(p1-&gt;right, p2-&gt;left);    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>有趣的是，我这种写法也可以看成前序遍历序列和对称前序遍历序列的比较。</p>\n</blockquote>\n<h2 id=\"面32：层序遍历二叉树\"><a href=\"#面32：层序遍历二叉树\" class=\"headerlink\" title=\"面32：层序遍历二叉树\"></a>面32：层序遍历二叉树</h2><h3 id=\"题面：-3\"><a href=\"#题面：-3\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如标题</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>层序遍历</p>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintByLayer(BinaryTreeNode* pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    queue&lt;BinaryTreeNode*&gt; que;\n    que.push(pHead);\n    while(que.size())&#123;\n        BinaryTreeNode *pNode &#x3D; que.front();\n        que.pop();\n        printf(&quot;%.2f &quot;, pNode-&gt;dbValue);\n        if(pNode-&gt;pLeft) que.push(pNode-&gt;pLeft);\n        if(pNode-&gt;pRight) que.push(pNode-&gt;pRight);        \n    &#125;\n    printf(&quot;\\n&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面32相关题：分行打印层序遍历二叉树\"><a href=\"#面32相关题：分行打印层序遍历二叉树\" class=\"headerlink\" title=\"面32相关题：分行打印层序遍历二叉树\"></a>面32相关题：分行打印层序遍历二叉树</h2><h3 id=\"题面：-4\"><a href=\"#题面：-4\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如标题</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>在层序遍历的基础上，有两种解题思路：一是记录当前层未打印的节点数量和下一层的需要打印的节点数量，二是在队列中添加一个一层的节点末端的标志符、</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintByLayerSparate(BinaryTreeNode* pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    queue&lt;BinaryTreeNode*&gt; que;\n    que.push(pHead);\n\tint printValue &#x3D; 1, nextValue &#x3D; 0;\n    while(que.size())&#123;\n        BinaryTreeNode *pNode &#x3D; que.front();\n        que.pop();\n        printValue--;\n        printf(&quot;%.2f &quot;, pNode-&gt;dbValue);\n        if(pNode-&gt;pLeft)&#123;\n          \tque.push(pNode-&gt;pLeft);\n            nextValue++;\n        &#125; \n        if(pNode-&gt;pRight)&#123;\n            que.push(pNode-&gt;pRight);          \n            nextValue++;\n        &#125;\n        \n        if(printValue &#x3D;&#x3D; 0)&#123;\n            printValue &#x3D; nextValue;\n            nextValue &#x3D; 0;\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面32相关题：之字形打印二叉树\"><a href=\"#面32相关题：之字形打印二叉树\" class=\"headerlink\" title=\"面32相关题：之字形打印二叉树\"></a>面32相关题：之字形打印二叉树</h2><h3 id=\"题面：-5\"><a href=\"#题面：-5\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如标题</p>\n<h3 id=\"思路：-5\"><a href=\"#思路：-5\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>一种方法就是分层层序遍历+栈逆序存储并输出。</p>\n<p>第二种方法就用栈把一层的节点逆序输出，并将下一层的节点记录在另一个栈中，如此循环，输出所有的层。</p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PirntZhi(BinaryTreeNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    stack&lt;BinaryTreeNode*&gt; s[2];\n    int cur &#x3D; 0;\n    s[cur].push(pHead);\n    BinaryTreeNode *pNode &#x3D; nullptr;\n    while(s[cur].size())&#123;\n        while(s[cur].size())&#123;\n\t\t   pNode &#x3D; s[cur].top();\n            s[cur].pop();\n            printf(&quot;%.2 &quot;, pNode-&gt;dbValue);\n            if(cur &#x3D;&#x3D; 0)&#123;\n                if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft);\n                if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight);                \n            &#125;else&#123;\n                if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight);                \n            \tif(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft);                \n            &#125;\n        &#125;\n       \tprintf(&quot;\\n&quot;);\n        cur &#x3D; 1- cur;\n    &#125;\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"103-Binary-Tree-Zigzag-Level-Order-Traversal\"><a href=\"#103-Binary-Tree-Zigzag-Level-Order-Traversal\" class=\"headerlink\" title=\"103. Binary Tree Zigzag Level Order Traversal\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">103. Binary Tree Zigzag Level Order Traversal</a></h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;\n        if(!root) return &#123;&#125;;\n        stack&lt;TreeNode*&gt; cur1, cur2;\n        cur1.push(root);\n        vector&lt;vector&lt;int&gt;&gt; zigarr;\n        int flag &#x3D; 1;\n        while(cur1.size() || cur2.size())&#123;\n            if(flag) zigview(cur1, cur2, zigarr, flag), flag &#x3D; 1 - flag ;\n            else  zigview(cur2, cur1, zigarr, flag), flag &#x3D; 1 - flag;\n        &#125;\n        return zigarr;\n    &#125;\n\n    void zigview(stack&lt;TreeNode*&gt;&amp; now, stack&lt;TreeNode*&gt;&amp; next, vector&lt;vector&lt;int&gt;&gt; &amp;zigarr, int flag)&#123;\n        vector&lt;int&gt; arr;\n        while(!now.empty())&#123;\n            arr.push_back(now.top()-&gt;val);\n            if(flag)&#123;\n                if(now.top()-&gt;left) next.push(now.top()-&gt;left);\n                if(now.top()-&gt;right) next.push(now.top()-&gt;right);\n                now.pop();\n            &#125;else&#123;\n                if(now.top()-&gt;right) next.push(now.top()-&gt;right);\n                if(now.top()-&gt;left) next.push(now.top()-&gt;left);\n                now.pop();\n            &#125;            \n        &#125;\n        zigarr.push_back(arr);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"面33-判断后序遍历序列有效性\"><a href=\"#面33-判断后序遍历序列有效性\" class=\"headerlink\" title=\"面33:判断后序遍历序列有效性\"></a>面33:判断后序遍历序列有效性</h2><h3 id=\"题面：-6\"><a href=\"#题面：-6\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给定一颗二叉搜索树的后续遍历序列，判断该后序遍历序列是否合法。</p>\n<h3 id=\"思路：-6\"><a href=\"#思路：-6\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>依据后续遍历的定义，可以把序列依据最后一个元素<code>K</code>分成两半，且满足前一部分全部小于<code>K</code>的值，后一部分全部大于<code>K</code>的值，若不符合这个结论，则该后序遍历不可能存在一颗二叉树与之对应。递归的判断这两部分是否符合这些定义。</p>\n<h3 id=\"代码：-6\"><a href=\"#代码：-6\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">bool isPostSequenceCore(int sequence[], int start, int end)&#123;\n    if(start &gt;&#x3D; end) return true;\n    int key &#x3D; sequence[end - 1];\n    int split &#x3D; start;\n    while(sequence[split] &lt; key) split++;\n    for(int i &#x3D; split; i &lt; end; i++)&#123;\n        if(sequence[i] &lt; key) return false;\n    &#125;\n    return isPostSequenceCore(sequence, start, split) \n        &amp;&amp; isPostSequenceCore(sequence, split, end - 1);\n&#125;\n\nbool isPostSequence(int sequence[], int len)&#123;\n    if(sequence &#x3D;&#x3D; nullptr || len &lt;&#x3D; 0) return false;\n    return isPostSequenceCore(sequence, 0, len);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>如果是c++的话，也可以直接用指针代替start。</p>\n</blockquote>\n<h2 id=\"面34：树的路径的元素之和\"><a href=\"#面34：树的路径的元素之和\" class=\"headerlink\" title=\"面34：树的路径的元素之和\"></a>面34：树的路径的元素之和</h2><h3 id=\"题面：-7\"><a href=\"#题面：-7\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>打印出树的路径上的值之和与给定数字相同的所有路径。路径从根到叶子。</p>\n<h3 id=\"思路：-7\"><a href=\"#思路：-7\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>dfs遍历 + 记录路径即可。</p>\n<h3 id=\"代码：-7\"><a href=\"#代码：-7\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintPathCore(BinaryTreeNode* pNode, stack&lt;int&gt; &amp;s, int add, int expectedSum)&#123;\n    s.push((int)pNode-&gt;dbValue);\n    add +&#x3D; (int)(pNode-&gt;dbValue);\n    if(pNode-&gt;pLeft &#x3D;&#x3D; nullptr &amp;&amp; pNode-&gt;pRight &#x3D;&#x3D; nullptr)&#123;\n        if(add &#x3D;&#x3D; expectedSum)&#123;\n            stack&lt;int&gt; sTemp;\n            while(s.size())&#123;\n               \n                sTemp.push(s.top());\n                s.pop();                \n            &#125;\n            while(sTemp.size())&#123;\n                printf(&quot;%d-&gt;&quot;, sTemp.top());\n                s.push(sTemp.top());\n                sTemp.pop();\n            &#125;\n            printf(&quot;\\n&quot;);\n        &#125;\n        &#x2F;&#x2F; printf(&quot;%d, %d, %d\\n&quot;, expectedSum, add, s.size());\n        s.pop();\n        return;\n    &#125;\n    if(pNode-&gt;pLeft) PrintPathCore(pNode-&gt;pLeft, s, add, expectedSum);    \n    if(pNode-&gt;pRight) PrintPathCore(pNode-&gt;pRight, s, add, expectedSum);\n    s.pop();\n&#125;\n\n\nvoid PrintPath(BinaryTreeNode* pHead, int expectedSum)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n\tstack&lt;int&gt; s;\n    PrintPathCore(pHead, s, 0, expectedSum);\n    printf(&quot;\\n&quot;);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>中午时间不要打代码，太困了</p>\n</blockquote>\n<h2 id=\"437-Path-Sum-III-路径之和\"><a href=\"#437-Path-Sum-III-路径之和\" class=\"headerlink\" title=\"437. Path Sum III 路径之和\"></a><a href=\"https://leetcode-cn.com/problems/path-sum-iii/\">437. Path Sum III</a> 路径之和</h2><p>类似，但不相同。</p>\n<p>前缀和 + 递归</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    int count &#x3D; 0;\n    int pathSum(TreeNode* root, int sum) &#123;\n        add(root, 0);    \n        findNode(root, sum, 0);\n        return count;\n    &#125;\n    void findNode(TreeNode* root, int num, int presum)&#123;\n        if(!root) return;\n        cal(root, num, presum);\n        findNode(root-&gt;left, num, root-&gt;val);\n        findNode(root-&gt;right, num, root-&gt;val);\n    &#125;\n    void cal(TreeNode* root, int target, int presum)&#123;\n        if(!root) return;\n        if(root-&gt;val - presum &#x3D;&#x3D; target) count++;\n        cal(root-&gt;left, target, presum);\n        cal(root-&gt;right, target, presum);\n    &#125;\n    void add(TreeNode* root, int presum)&#123;\n        if(!root) return;\n        root-&gt;val +&#x3D; presum;\n        add(root-&gt;left, root-&gt;val);\n        add(root-&gt;right, root-&gt;val);\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>写法二：提供一种递归的小小思路</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int count &#x3D; 0;\n    int pathSum(TreeNode* root, int sum) &#123;\n        if(!root) return 0;\n        return cal(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);\n    &#125;\n    int cal(TreeNode* root, int sum)&#123;\n        if(!root) return 0;\n        sum -&#x3D; root-&gt;val;\n        return (sum &#x3D;&#x3D; 0) + cal(root-&gt;left, sum) + cal(root-&gt;right, sum);\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>最优解法：前缀和 + 回溯 + 维护前缀和出现的次数：<code>times[presum]</code></p>\n<blockquote>\n<p>突然想到3数之和。</p>\n</blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for a binary tree node.\n * struct TreeNode &#123;\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    unordered_map&lt;int, int&gt; ct &#x3D; &#123;&#123;0,1&#125;&#125;;\n    int pathSum(TreeNode* root, int sum) &#123;\n        int amount &#x3D; 0;\n        dfs(root, 0, sum, amount);\n        return amount;\n    &#125;\n    void dfs(TreeNode *root, int presum, int sum, int &amp;amount)&#123;\n        if(!root) return;\n        root-&gt;val +&#x3D; presum;\n        amount +&#x3D; ct[root-&gt;val - sum];\n\n        ++ct[root-&gt;val];\n        dfs(root-&gt;left, root-&gt;val, sum, amount);\n        dfs(root-&gt;right, root-&gt;val, sum, amount);\n        --ct[root-&gt;val];\n\n    &#125;\n    \n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"面36：把二叉搜索树转化为双向链表（同链表中的内容）\"><a href=\"#面36：把二叉搜索树转化为双向链表（同链表中的内容）\" class=\"headerlink\" title=\"面36：把二叉搜索树转化为双向链表（同链表中的内容）\"></a>面36：把二叉搜索树转化为双向链表（同链表中的内容）</h2><h3 id=\"题面：-8\"><a href=\"#题面：-8\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。</p>\n<h3 id=\"思路：-8\"><a href=\"#思路：-8\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以从递归的角度入手。对于一个节点<code>A</code>，中序遍历到<code>A</code>，则<code>A</code>的左子树已经转化为了链表，连接好<code>A</code>和<code>A</code>的左子树的最大节点（前一个指针）的指针则连接完成。</p>\n<p>那对于<code>A</code>的右子树的最小节点<code>B</code>与<code>A</code>之间的连接，也可以看成<code>B</code>与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。</p>\n<p>注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。</p>\n<blockquote>\n<p>对于一个节点<code>A</code>的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点<code>B</code>的指针，并设置好<code>B</code>的右指针和<code>A</code>的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是<code>NULL</code>，所以无需修改。</p>\n</blockquote>\n<h3 id=\"代码：-8\"><a href=\"#代码：-8\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead)&#123;\n    if(pRoot &#x3D;&#x3D; nullptr) return;\n  \tAdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead);\n\n    if(pHead &#x3D;&#x3D; nullptr) pHead &#x3D; pRoot;\n    pRoot-&gt;pLeft &#x3D; preNode;\n    if(preNode) preNode-&gt;pRight &#x3D; pRoot;\n    preNode &#x3D; pRoot;\n    \n    AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead);\n&#125;\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot)&#123;\n    BinaryTreeNode *preNode &#x3D; nullptr;\n    BinaryTreeNode *pHead &#x3D; nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面36：序列化和反序列化二叉树\"><a href=\"#面36：序列化和反序列化二叉树\" class=\"headerlink\" title=\"面36：序列化和反序列化二叉树\"></a>面36：序列化和反序列化二叉树</h2><h3 id=\"题面：-9\"><a href=\"#题面：-9\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>序列化定义：</p>\n<blockquote>\n<p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p>\n</blockquote>\n<p>二叉树的序列化可以把非空节点的值序列化，把空节点序列化为<code>$</code>。</p>\n<h3 id=\"思路：-9\"><a href=\"#思路：-9\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>由于序列化把空节点的信息也包含进来了，所以无需添加更多序列。</p>\n<blockquote>\n<p>这题更像流的应用题</p>\n</blockquote>\n<h3 id=\"代码：-9\"><a href=\"#代码：-9\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void Serialize(BinaryTreeNode *pRoot, ostream&amp; stream)&#123;\n    if(pRoot &#x3D;&#x3D; nullptr)&#123;\n        stream &lt;&lt; &#39;$&#39;;\n        return;\n    &#125; \n    stream &lt;&lt; pRoot-&gt;value &lt;&lt; &#39;,&#39;;\n    Serialize(pRoot-&gt;pLeft);\n    Serialize(pRoot-&gt;pRight);    \n&#125;\n\nvoid Deserialize(BinaryTreeNode *&amp;pRoot, istream&amp; stream)&#123;\n\tint number;\n    if(ReadSteam(stream, &amp;number))&#123;\n        pRoot &#x3D; new BinaryTreeNode();\n        pNew-&gt;pLeft &#x3D; nullptr;\n        pNew-&gt;pRight &#x3D; nullptr;\n        pNew-&gt;value &#x3D; number;\n    &#125;\n    Deserialize(pRoot-&gt;pLeft, stream);\n\tDeserialize(pRoot-&gt;pRight, steam);    \n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"},{"title":"面试题 链表相关","thumbnail":"http://static.come2rss.xyz/尼尔机械.jpg","toc":true,"top":10,"date":"2020-08-07T05:32:38.000Z","_content":"\n\n<!-- more -->\n\n所有关于链表的题目都会总结在这里。假设这些题目的链表的头结点都是带有效值的\n\n\n\n## 定义链表\n\n```\nstruct ListNode{\n    int Value;\n    ListNode* pNext;\n};\n```\n\n## 尾插入节点\n\n注意第一个参数是指针的指针，因为有可能需要修改第一个链表节点。\n\n```\nvoid AddToTail(ListNode **pHead, int value){\n    if(pHead == null) return;\n\tListNode *pNew = new ListNode();\n    pNew->Value = value;\n    pNew->pNext = nullptr;\n    if(*pHead == null){\n        *pHead = pNew;\n    }else{\n        ListNode* pNode = *pHead;\n        while(pNode->pNext != null){\n            pNode = pNode->pNext;\n        }\n        *pNode->pNext = pNew;        \n    }\n}\n```\n\n## 删除第一个对应值的链表\n\n```\nviod RemoveNode(ListNode** pHead, int value){\n    if(pHead == nullptr || *pHead == nullptr) return;\n    ListNode *pToDeleted = nullptr;\n    if((*pHead)->value == value){\n        pToDeleted = *pHead;\n        *pHead = (*pHead)->pNext;\n    }else{\n        ListNode *pNode = *pHead;\n        //pNode指向检查节点的前一个节点\n        while((*pNode)->pNext != null && (*pNode)->pNext->value != value){\n            pNode = pNode->pNext;\n        }\n        if((*pNode)->pNext != null && (*pNode)->pNext->value == value){\n\t\t\tpToDeleted = (*pNode)->pNext;\n        }\n    }\n\tif(pToDeleted != nullptr){\n        delte pToDelted;\n        pToDelted = nullptr; //释放内存后，即使是不需要使用的指针，也要做好清除工作，不然不容易维护            \n    }\n\t\n}\n```\n\n> `pToDeleted = *pNode->pNext;`上面遍历链表中代码不应该用`pToDeleted`来记录链表值，否然容易出现代码指针值意义混乱，造成不该删的指针却删掉了。\n\n## 面试题6 从尾到头打印链表\n\n假如对空间复杂度在O(N)O(N)之上，那么可以使用栈或者递归。\n\n**栈代码如下**\n\n```\nvoid PrintListReversingly_Iteratively(ListNode* pHead){\n    //使用指针类型的STACK更省内存？\n    std::stack<ListNode*> nodes;\n    ListNode* pNode = pHead;\n    while(pNode != nullptr){\n        nodes.push(pNode);\n        pNode = pNode->pNext;\n    }\n    while(!nodes.empty()){\n        pNode = nodes.top();\n        printf(\"%d\\n\", pNode->value);\n        nodes.pop();\n    }   \n}\n```\n\n**递**\n\n**归代码**\n\n```\nvoid PrintListReversingly_Recursively(ListNode* pHead){\n    if(pHead == nullptr) return;\n    PrintListReversingly_Recursively(pHead->pNext);\n    printf(\"%d\\n\", pHead->pNext);\n    \n}\n```\n\n## 面试18：删除一个链表节点\n\n### 题面：\n\n给定一个单向链表的头结点指针和一个指向待删除的节点的指针，要求用O(N)O(N)时间删除节点。\n\n### 思路：\n\n教科书上的链表删除都是遍历得到上一个待删除的节点的指针，时间复杂度O(N)O(N)。显然不行，也可以直接把待删除的节点`K`的下一个节点`J`的内容复制到`K`上，再删除`J`，就可以快速删除。考虑边界上，如果没有下一个节点则需要从头遍历；如果只有一个头结点且删除的是头结点，那么只能把头结点置`nullptr`。\n\n其时间复杂度为(n−1)∗O(1)+O(N)(n−1)∗O(1)+O(N)。\n\n### 代码：\n\n```\nvoid DeleteNode(ListNode **pHead, ListNode *pToBeDeleted){\n    if(pHead == nullptr || (*phead) == nullptr || (*pToBeDeleted) == nullptr ) return;\n    ListNode *pFree = nullptr;\n    \n    if(pToBeDeleted->pNext){\n        pFree = ToBeDeleted->pNext;\n        pToBeDeleted->value = pToBeDeleted->pNext->value;   \n        pToBeDeleted->pNext = pToBeDeleted->pNext->pNext;   \n        \n    }\n    //删除节点无后继节点，且是头结点\n    else if( *pHead == pToBeDeleted){\n\t\tpFree = *pHead;\n        *pHead = nullptr;\n    }\n    // 链表中多个节点，且删除节点在末尾\n    else{\n\t\tListNode *pCur = *pHead\n        for(; pCur->pNext->pNext != nullptr; pCur = pCur->pNext);\n        pFree = pCur->pNext;\n        pCur->pNext = nullptr;\n    }\n    Delete pFree;\n}\n```\n\n> 错误点：\n>\n> - the properiry of “*” > the properity of “==”\n> - 链表插入和删除后没有设置指针\n>\n> 注意点：\n>\n> 这个函数假设了待删除的节点一定在链表中；\n>\n> 头结点可能删除掉，所以设置了头结点为指针的指针。\n\n## 面18（题目二）：删除重复值的链表节点\n\n### 题面：\n\n删除一条已排序的链表中的所有的其值重复出现的节点。\n\n### 思路：\n\n在上面学习的基础上，连续删除就行，应该是比较简单的。\n\n### 代码：\n\n```\nvoid DeleteDuplication(ListNode **pHead){\n    if(pHead == nullptr || *pHead == nullptr) return;\n    \n    ListNode *pCur = *pHead, *pPre = nullptr, *pFree = nullptr;\n    //定义一个头结点，避免不同情况的删除\n    ListNode *pKid = new ListNode();\n    pKid->pNext = *pHead;\n    pPre = pKid;\n    \n    while(pCur != nullptr){\n\t\tint value = pCur->value,  isDuplication = 0;\n        //删除后面的重复节点\n        while(pCur->pNext && pCur->pNext->value == value){\n            pFree = pCur->pNext;\n            pCur->pNext = pFree->pNext;\n            delete pFree;\n            isDuplication = 1;\n        }\n        \n        //若重复，则删除第一个重复节点\n\t\tif(isDuplication){\n\t\t\tpFree = pCur;\t\t\t\n\t\t\tpCur = pCur->pNext;\t\t\t\n\t\t\tpPre->pNext = pCur;\n            delete pFree;\n\t\t\t// if(pFree) printf(\"@\");\n        }\n        //不重复则下移\n        else{\n            pPre = pPre->pNext;\n            pCur = pCur->pNext;\n        }\n    }\n\t*pHead = pKid->pNext;\n    delete pKid;\n}\n```\n\n## **测试**\n\n[参见](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp)\n\n## 面22：倒数第K个节点\n\n### 题面：\n\n给出一个链表，返回倒数第K个节点。\n\n### 思路：\n\n最直观的思路是遍历到终点，反向遍历`K-1`次，但是对单链表无可奈何，而且效率不高。\n\n第二种思路可以遍历一次求链表的长度`L`，第二次遍历`L - K + 1`个节点。但是需要遍历两次链表。\n\n三种思路更秒，采用双指针，第一个指针先遍历K个节点，随后两个节点一起遍历，直到第一个指针为空，第二个指针就指向了倒数第K个节点。\n\n### 代码：\n\n```\nListNode *FindKthToTail(ListNode *pHead, unsigned int K){\n    if(pHead == nullptr) return nullptr;\n    ListNode *p1 = pHead, *p2 = pHead;\n    \n    for(int i = 0; i < K; i++){\n        if(p1 == nullptr) return nullptr;\n        p1 = p1->pNext;\n    }\n    while(p1!=nullptr){\n        p1 = p1->pNext;\n        p2 = p2->pNext;\n    }\n    return p2;\n}\n```\n\n> 这代码写的比剑指offer代码写的优美多了\n\n### 相关扩展：\n\n相关题目有找出链表的中间节点；判断一个链表是否有环；更难一点判断链表的环的入口节点！\n\n**其思路宗旨都是使用两个进度不一样的指针指向不同的节点来解决问题！**\n\n## 面23：链表中的环的入口节点\n\n### 题面：\n\n给出一个链表，求出其成环的入口节点。\n\n### 思路：\n\n首先得判断有环，可以使用一个快一慢的两只指针（移动速度分别为2和1）指向链表头。如果链表有环，则快慢指针就一定会相遇。\n\n那么对于有环的链表如何确定其入口节点呢？假设环的中节点有`K`个，快指针从头先遍历`K`次之后，快慢指针同时开始遍历，正好两个指针会在入口节点上汇合！\n\n如何确定环中节点呢？这个！可以直接在确定有环后，记录下该节点的位置，再继续遍历直到重新到该节点同时统计经过的节点数量即可。\n\n> amazing啊\n\n### 代码：\n\n```\nListNode *FindCycleNode(ListNode* pHead){\n\tif(pHead == nullptr) return nullptr;\n    ListNode *pSlow, *pQuick, *pRecord = nullptr ;\n    //判断有没有环\n    pSlow = pQuick = pHead;\n    while(pQuick != nullptr){\n\t    pQuick = pQuick->pNext;\n        if(pQuick) pQuick = pQuick->pNext;\n        if(pSlow) pSlow = pSlow->pNext;        \n        if(pSlow == pQuick) break;\n    }\n    if(pQuick == nullptr) return nullptr;\n    //确定环内数量\n    pRecord = pSlow;\n    int numberOfCycle = 0;\n    while(pRecord != pSlow){\n        numberOfCycle++;\n        pSlow = pSlow->pNext;\n    }\n    //确定环的入口节点\n    pSlow = pQuick = pHead;\n    for(int i = 0; i < numberOfCycle; i++){\n        pQuick = pQuick->pNext;\n    }\n    while(pSlow != pQuick){\n        pQuick = pQuick->pNext;\n        pSlow = pSlow->pNext;                \n    }\n    return pSlow;\n}\n```\n\n## 面24：反转链表\n\n### 题面：\n\n输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。\n\n### 思路：\n\n在反转过程中，假设有三个顺序排列的待反转的链表`i`，`j`，`k`，其中`j`是待反转的链表。初始化，`i`为空指针，`j`为头节点，`k`为头结点的下一个指针指向的内容（可能为空），并把`i`的指针指空。在链表反转过程如下：`j`的指针指向`i`，然后把`i`，`j`，`k`分别按次序向后移动。重复执行上述步骤直到`j`为空。\n\n### 代码：\n\n```\nListNode *ReverseList(ListNode *pHead){\n    if(pHead == nullptr) return nullptr;\n    ListNode *p1 = nullptr, *p2 = pHead, *p3 = pHead->pNext;\n    while(p2 != nullptr){\n        p2->pNext = p1;\n        p1 = p2;\n        p2 = p3;\n        if(p3) p3 = p3->next;        \n    }\n    return p2;    \n}\n```\n\n## 面25：合并链表\n\n### 题面：\n\n将两个链表增序合并成一条链表。\n\n### 思路：\n\n用两个指针指向两条链表的头结点，用合并数组的思路合并即可。注意一条链表为空后，另一条不为空的链表可以直接连上去。\n\n### 代码：\n\n```\nListNode *Merge(ListNode *pHead1, ListNode *pHead2){\n    if( pHead1 == nullptr && pHead2 == nullptr){\n        return nullptr;\n    }else if(pHead1 == nullptr) return pHead2;\n    else if(pHead2 == nullpr) return pHead1;\n    \n    ListNode *p1 = pHead1, *p2 = pHead2, *pHead3 = new ListNode(), *p3 = pHead3;\n    \n    while(p1 && p2){\n        if(p1->value <= p2->value){\n            p3->pNext = p1;\n            p3 = p1;            \n            p1 = p1->pNext;\n\n        }else{\n            p3->pNext = p2;\n            p3 = p2;\n            p2 = p2->pNext;\n        }                 \n    }\n    p3->pNext = nullptr;       \n    if(p1){\n        p3->pNext = p1;\n    }else if(p2){\n        p3->pNext = p2;\n    }\n    ListNode *pFree = pHead3;\n    pHead3 = pHead->pNext;\n    delete pFree;\n\treturn pHead3;        \n}\n```\n\n### 测试\n\n[参见](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp)\n\n## 面35：复杂链表的分解\n\n### 题面：\n\n给出一个有两个指针的链表数据结构，一个指针1指向下一个节点，另一个指针2可指向任意一个节点，或者为空。将给出的链表复制并返回头结点。\n\n### 思路：\n\n这题目还是挺不错的！属于比较复杂的题目，而且有思考空间。\n\n将复制的过程分解为两个部分，第一步先不管指针2，复制整个链表；第二步再设置指针2。第一步需要的复杂度为O(N)O(N)。第二步再复制的过程中需要确定复制链表中指针2指向的节点的的位置。\n\n第一种确定位置的思路：就是从原链表遍历寻找原指针指向的节点位置，同样的在复制链表上一起遍历。复杂度为O(N2)O(N2)。\n\n第二种确定位置的思路：直接用hash表记录下原链表中节点和复制链表中对应节点的映射关系。复杂度为O(N)O(N)。是用了空间换时间的思路。\n\n> 害怕碰撞。\n\n脱离上面的方案的限制，更巧妙的方法来了。链表的顺序遍历远远比随机遍历方便很多，而且指针指向的节点的位置不随链表节点而变化。可以考虑把复制节点直接插入到被复制节点的后面。全部复制完成后，由于原节点的指针2指向的节点的后一个节点就是复制节点的指针2指向的节点，所以可以直接指向。复杂度为O(N)O(N)，空间复杂度为O(1)O(1)。\n\n### 代码：\n\n```\nstruct ComplexListNode{\n    int value;\n    ComplexListNode *pNext;\n    ComplexListNode *pSibling;    \n}\n\nvoid CopyNode(ComplexListNode *pHead){\n    if(pHead == nullptr) return null;\n    ComplexListNode *pNode = pHead;\n    while(pNode){\n        ComplexListNode *pNew = new ComplexListNode();\n        pNew->value = pNode->value;\n        pNew->pNext = pNode->pNext;\n        pNew->pSibling = nullptr;\n        \n        pNode->pNext = pNew;\n    \tpNode = pNew->pNext;\n    }    \n}\n\nvoid SetSiblingLink(ComplexListNode * pHead){\n    if(pHead == nullptr )return nullptr;\n    ComplexListNode *pNode  = pHead;\n    while(pNode){\n\t\tComplexListNode *pNext = pNode->pNext;\n        pNext->pSibling = pNode->pSibliing->pNext;\n        pNode = pNext->pNext;\n    }    \n}\n\nComplexListNode *GetComplexList(ComplexListNode *pHead){\n    if(pHead == nullptr) return nullptr;\n\tComplexListNode *pNode = pHead;\n    ComplexListNode *pClonedHead = pNode->pNext;\n    ComplexListNode *pClonedNode = pNode->pNext;\n    pNode->next = pClonedNode->next;\n    pNode = pClneNode->next;\n    while(pNode){\n        pClonedNode->pNext = pNode->pNext;        \n        pNode->pNext = pNode->pNext->pNext;\n        pClonedNode = pNode->pNext;\n        pNode = pClonedNode->pNext;   \n        /*\n        //we can write in this way.\n        pClonedNode->pNext = pNode->pNext;        \n        pClonedNode = pClonedNode->pNext;\n\t\tpNode->pNext = pClonedNode->pNext;\n        pNode = pNode->pNext;                  \n        */\n    }\n    return pClonedHead;      \n}\nComplexListNode *Clone(ComplexListNode* pHead){\n    CopyNode(pHead);\n    SetSiblingLink(pHead);\n    return GetComplexList(pHead);\n}\n```\n\n## 面36：把二叉搜索树转化为双向链表\n\n### 题面：\n\n如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。\n\n### 思路：\n\n可以从递归的角度入手。对于一个节点`A`，中序遍历到`A`，则`A`的左子树已经转化为了链表，连接好`A`和`A`的左子树的最大节点（前一个指针）的指针则连接完成。\n\n那对于`A`的右子树的最小节点`B`与`A`之间的连接，也可以看成`B`与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。\n\n注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。\n\n> 对于一个节点`A`的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点`B`的指针，并设置好`B`的右指针和`A`的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是`NULL`，所以无需修改。\n\n### 代码：\n\n```\nvoid AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&preNode, BinaryTreeNode *&pHead){\n    if(pRoot == nullptr) return;\n  \tAdjustLinkCore(pRoot->pLeft, preNode, pHead);\n\n    if(pHead == nullptr) pHead = pRoot;\n    pRoot->pLeft = preNode;\n    if(preNode) preNode->pRight = pRoot;\n    preNode = pRoot;\n    \n    AdjustLinkCore(pRoot->pRight, preNode, pHead);\n}\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){\n    BinaryTreeNode *preNode = nullptr;\n    BinaryTreeNode *pHead = nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n}\n```\n\n## 面52：两个链表的第一个公共节点\n\n### 题面：\n\n如题。\n\n### 思路：\n\n明显地，可以用栈来存储两个链表遍历过程。空间复杂度和时间复杂度都是O(N)O(N)。\n\n换一种想法，能不能直接遍历就使两个链表同时遍历到第一个公共节点。定义两个指针来遍历两条链表。只要让一个指向长链表的节点的指针多走多出的节点，就可以让两个节点同时同序的遍历到公共节点。时间复杂度为O(N+M)O(N+M)，空间复杂度O(1)O(1)。\n\n### 代码：\n\n```\nint GetLenOfList(ListNode *pHead){\n    int len = 0;\n    ListNode *pNode = pHead;\n    while(pNode){\n        pNode = pNode->pNext;\n        len++;\n    }\n    return len;\n}\nListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2){\n    if(pHead1 == nullptr || pHead2 == nullptr) return nullptr;\n    int len1 = GetLenOfList(pHead1);\n    int len2 = GetLenOfList(pHead2);\n    if(len1 < len2){\n        swap(pHead1, pHead2);\n        swap(len1, len2);\n    }\n    int step = len1 - len2;\n\tListNode *pNode1 = pHead1;\n    ListNode *pNode2 = pHead2;\n    while(step){\n        pNode1 = pNode->pNext;\n        step--;\n    }\n    while(pNode1 != pNode2){\n        pNode1 = pNode1->pNext;\n        pNode2 = pNode1->pNext;\n    }\n    //two pNodes maybe refer to null or the first common node.\n    return pNode1;\n}\n```\n\n\n\n[更简单的解法：](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/) \n\n双指针遍历两条链表，遍历到结尾则跳到另一条链表上。路径长度的相等一定会有两个指针相遇。\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p1 = headA,  *p2 = headB;\n        while(p1 != p2){\n            p1 = p1 == nullptr ? headB : p1->next;\n            p2 = p2 == nullptr ? headA : p2->next;\n        }\n        return p1;\n    }\n};\n```\n\n\n\n\n\n## [链表回文判断]()\n\n[234. Palindrome Linked List](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n`O(n)`时间，`O(1)`空间\n\n### 思路：\n\n朴素的思路：先用快慢指针找到链表中间节点，之后翻转后半部分链表。判断两个链表是否相同。\n\n其中奇数个节点链表需要考虑一下。\n\n\n\n### 代码\n\n````c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        ListNode *slow ,*quick;\n        slow = quick = head;\n        while(quick && quick->next){\n            slow = slow->next;\n            quick = quick->next->next;\n        }\n        ListNode *p2 = reverseList(slow), *p1 = head;\n        while(p1 && p2){\n            if(p1->val != p2->val) return false;\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        return true;\n        \n    }\n\n    ListNode *reverseList(ListNode* head){\n        if(head == nullptr) return head;\n        ListNode *per = nullptr, *cur = head, *next = head->next;\n        while(cur){\n            cur->next = per;\n            per = cur;\n            cur = next;\n            if(next) next = next->next;\n        }\n        return per;\n    }\n};\n````\n\n## [奇偶链表节点分解](https://leetcode-cn.com/problems/odd-even-linked-list/)\n\n\n\n非常容易写复杂的题目。\n\n````c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if(!(head && head->next)) return head;\n        // ListNode *p1 = head, *p2 = new ListNode(), *evenHead = p2, *pre = nullptr;\n        // while(p1 && p1->next){\n        //     p2->next = p1->next;\n        //     p2 = p2->next;\n        //     p1->next = p2->next;\n        //     pre = p1;\n        //     p1 = p2->next;\n        // }\n        // p2->next = nullptr;    \n        // p1 = p1 ? p1 : pre;\n        // p1->next = evenHead->next;\n        // delete evenHead;\n        // return head;\n        ListNode *evenHead = head->next, *odd = head, *even = head->next;\n        while(even && even->next){\n            odd->next = even->next;\n            odd = odd->next;\n            even->next = odd->next;\n            even = even->next;\n        }\n        odd->next = evenHead;\n        return head;\n    }\n};\n````\n\n## [删除倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/)\n\n\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode node, *pre = &node;\n        pre->next = head;\n        ListNode *quick, *slow;\n        quick = slow = pre;\n        for(int i = 0; i < n; ++i) quick = quick->next;\n        while(quick->next){\n            quick = quick->next;\n            slow = slow->next;\n        }\n        ListNode *fordel = slow->next;\n        slow->next = fordel->next;\n        if(fordel == head){ //删除节点 务必小心：1.删了头结点，需要重置头结点 2.考虑后续节点\n            head = fordel->next;\n        }\n        delete fordel;            \n        return head; \n\n    }\n};\n```\n\n","source":"_posts/刷题/数据结构/链表\n/面试题-链表相关.md","raw":"---\ntitle: 面试题 链表相关\nthumbnail: 'http://static.come2rss.xyz/尼尔机械.jpg'\ntoc: true\ntop: 10\ntags:\ncategories:\ndate: 2020-08-07 13:32:38\n---\n\n\n<!-- more -->\n\n所有关于链表的题目都会总结在这里。假设这些题目的链表的头结点都是带有效值的\n\n\n\n## 定义链表\n\n```\nstruct ListNode{\n    int Value;\n    ListNode* pNext;\n};\n```\n\n## 尾插入节点\n\n注意第一个参数是指针的指针，因为有可能需要修改第一个链表节点。\n\n```\nvoid AddToTail(ListNode **pHead, int value){\n    if(pHead == null) return;\n\tListNode *pNew = new ListNode();\n    pNew->Value = value;\n    pNew->pNext = nullptr;\n    if(*pHead == null){\n        *pHead = pNew;\n    }else{\n        ListNode* pNode = *pHead;\n        while(pNode->pNext != null){\n            pNode = pNode->pNext;\n        }\n        *pNode->pNext = pNew;        \n    }\n}\n```\n\n## 删除第一个对应值的链表\n\n```\nviod RemoveNode(ListNode** pHead, int value){\n    if(pHead == nullptr || *pHead == nullptr) return;\n    ListNode *pToDeleted = nullptr;\n    if((*pHead)->value == value){\n        pToDeleted = *pHead;\n        *pHead = (*pHead)->pNext;\n    }else{\n        ListNode *pNode = *pHead;\n        //pNode指向检查节点的前一个节点\n        while((*pNode)->pNext != null && (*pNode)->pNext->value != value){\n            pNode = pNode->pNext;\n        }\n        if((*pNode)->pNext != null && (*pNode)->pNext->value == value){\n\t\t\tpToDeleted = (*pNode)->pNext;\n        }\n    }\n\tif(pToDeleted != nullptr){\n        delte pToDelted;\n        pToDelted = nullptr; //释放内存后，即使是不需要使用的指针，也要做好清除工作，不然不容易维护            \n    }\n\t\n}\n```\n\n> `pToDeleted = *pNode->pNext;`上面遍历链表中代码不应该用`pToDeleted`来记录链表值，否然容易出现代码指针值意义混乱，造成不该删的指针却删掉了。\n\n## 面试题6 从尾到头打印链表\n\n假如对空间复杂度在O(N)O(N)之上，那么可以使用栈或者递归。\n\n**栈代码如下**\n\n```\nvoid PrintListReversingly_Iteratively(ListNode* pHead){\n    //使用指针类型的STACK更省内存？\n    std::stack<ListNode*> nodes;\n    ListNode* pNode = pHead;\n    while(pNode != nullptr){\n        nodes.push(pNode);\n        pNode = pNode->pNext;\n    }\n    while(!nodes.empty()){\n        pNode = nodes.top();\n        printf(\"%d\\n\", pNode->value);\n        nodes.pop();\n    }   \n}\n```\n\n**递**\n\n**归代码**\n\n```\nvoid PrintListReversingly_Recursively(ListNode* pHead){\n    if(pHead == nullptr) return;\n    PrintListReversingly_Recursively(pHead->pNext);\n    printf(\"%d\\n\", pHead->pNext);\n    \n}\n```\n\n## 面试18：删除一个链表节点\n\n### 题面：\n\n给定一个单向链表的头结点指针和一个指向待删除的节点的指针，要求用O(N)O(N)时间删除节点。\n\n### 思路：\n\n教科书上的链表删除都是遍历得到上一个待删除的节点的指针，时间复杂度O(N)O(N)。显然不行，也可以直接把待删除的节点`K`的下一个节点`J`的内容复制到`K`上，再删除`J`，就可以快速删除。考虑边界上，如果没有下一个节点则需要从头遍历；如果只有一个头结点且删除的是头结点，那么只能把头结点置`nullptr`。\n\n其时间复杂度为(n−1)∗O(1)+O(N)(n−1)∗O(1)+O(N)。\n\n### 代码：\n\n```\nvoid DeleteNode(ListNode **pHead, ListNode *pToBeDeleted){\n    if(pHead == nullptr || (*phead) == nullptr || (*pToBeDeleted) == nullptr ) return;\n    ListNode *pFree = nullptr;\n    \n    if(pToBeDeleted->pNext){\n        pFree = ToBeDeleted->pNext;\n        pToBeDeleted->value = pToBeDeleted->pNext->value;   \n        pToBeDeleted->pNext = pToBeDeleted->pNext->pNext;   \n        \n    }\n    //删除节点无后继节点，且是头结点\n    else if( *pHead == pToBeDeleted){\n\t\tpFree = *pHead;\n        *pHead = nullptr;\n    }\n    // 链表中多个节点，且删除节点在末尾\n    else{\n\t\tListNode *pCur = *pHead\n        for(; pCur->pNext->pNext != nullptr; pCur = pCur->pNext);\n        pFree = pCur->pNext;\n        pCur->pNext = nullptr;\n    }\n    Delete pFree;\n}\n```\n\n> 错误点：\n>\n> - the properiry of “*” > the properity of “==”\n> - 链表插入和删除后没有设置指针\n>\n> 注意点：\n>\n> 这个函数假设了待删除的节点一定在链表中；\n>\n> 头结点可能删除掉，所以设置了头结点为指针的指针。\n\n## 面18（题目二）：删除重复值的链表节点\n\n### 题面：\n\n删除一条已排序的链表中的所有的其值重复出现的节点。\n\n### 思路：\n\n在上面学习的基础上，连续删除就行，应该是比较简单的。\n\n### 代码：\n\n```\nvoid DeleteDuplication(ListNode **pHead){\n    if(pHead == nullptr || *pHead == nullptr) return;\n    \n    ListNode *pCur = *pHead, *pPre = nullptr, *pFree = nullptr;\n    //定义一个头结点，避免不同情况的删除\n    ListNode *pKid = new ListNode();\n    pKid->pNext = *pHead;\n    pPre = pKid;\n    \n    while(pCur != nullptr){\n\t\tint value = pCur->value,  isDuplication = 0;\n        //删除后面的重复节点\n        while(pCur->pNext && pCur->pNext->value == value){\n            pFree = pCur->pNext;\n            pCur->pNext = pFree->pNext;\n            delete pFree;\n            isDuplication = 1;\n        }\n        \n        //若重复，则删除第一个重复节点\n\t\tif(isDuplication){\n\t\t\tpFree = pCur;\t\t\t\n\t\t\tpCur = pCur->pNext;\t\t\t\n\t\t\tpPre->pNext = pCur;\n            delete pFree;\n\t\t\t// if(pFree) printf(\"@\");\n        }\n        //不重复则下移\n        else{\n            pPre = pPre->pNext;\n            pCur = pCur->pNext;\n        }\n    }\n\t*pHead = pKid->pNext;\n    delete pKid;\n}\n```\n\n## **测试**\n\n[参见](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp)\n\n## 面22：倒数第K个节点\n\n### 题面：\n\n给出一个链表，返回倒数第K个节点。\n\n### 思路：\n\n最直观的思路是遍历到终点，反向遍历`K-1`次，但是对单链表无可奈何，而且效率不高。\n\n第二种思路可以遍历一次求链表的长度`L`，第二次遍历`L - K + 1`个节点。但是需要遍历两次链表。\n\n三种思路更秒，采用双指针，第一个指针先遍历K个节点，随后两个节点一起遍历，直到第一个指针为空，第二个指针就指向了倒数第K个节点。\n\n### 代码：\n\n```\nListNode *FindKthToTail(ListNode *pHead, unsigned int K){\n    if(pHead == nullptr) return nullptr;\n    ListNode *p1 = pHead, *p2 = pHead;\n    \n    for(int i = 0; i < K; i++){\n        if(p1 == nullptr) return nullptr;\n        p1 = p1->pNext;\n    }\n    while(p1!=nullptr){\n        p1 = p1->pNext;\n        p2 = p2->pNext;\n    }\n    return p2;\n}\n```\n\n> 这代码写的比剑指offer代码写的优美多了\n\n### 相关扩展：\n\n相关题目有找出链表的中间节点；判断一个链表是否有环；更难一点判断链表的环的入口节点！\n\n**其思路宗旨都是使用两个进度不一样的指针指向不同的节点来解决问题！**\n\n## 面23：链表中的环的入口节点\n\n### 题面：\n\n给出一个链表，求出其成环的入口节点。\n\n### 思路：\n\n首先得判断有环，可以使用一个快一慢的两只指针（移动速度分别为2和1）指向链表头。如果链表有环，则快慢指针就一定会相遇。\n\n那么对于有环的链表如何确定其入口节点呢？假设环的中节点有`K`个，快指针从头先遍历`K`次之后，快慢指针同时开始遍历，正好两个指针会在入口节点上汇合！\n\n如何确定环中节点呢？这个！可以直接在确定有环后，记录下该节点的位置，再继续遍历直到重新到该节点同时统计经过的节点数量即可。\n\n> amazing啊\n\n### 代码：\n\n```\nListNode *FindCycleNode(ListNode* pHead){\n\tif(pHead == nullptr) return nullptr;\n    ListNode *pSlow, *pQuick, *pRecord = nullptr ;\n    //判断有没有环\n    pSlow = pQuick = pHead;\n    while(pQuick != nullptr){\n\t    pQuick = pQuick->pNext;\n        if(pQuick) pQuick = pQuick->pNext;\n        if(pSlow) pSlow = pSlow->pNext;        \n        if(pSlow == pQuick) break;\n    }\n    if(pQuick == nullptr) return nullptr;\n    //确定环内数量\n    pRecord = pSlow;\n    int numberOfCycle = 0;\n    while(pRecord != pSlow){\n        numberOfCycle++;\n        pSlow = pSlow->pNext;\n    }\n    //确定环的入口节点\n    pSlow = pQuick = pHead;\n    for(int i = 0; i < numberOfCycle; i++){\n        pQuick = pQuick->pNext;\n    }\n    while(pSlow != pQuick){\n        pQuick = pQuick->pNext;\n        pSlow = pSlow->pNext;                \n    }\n    return pSlow;\n}\n```\n\n## 面24：反转链表\n\n### 题面：\n\n输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。\n\n### 思路：\n\n在反转过程中，假设有三个顺序排列的待反转的链表`i`，`j`，`k`，其中`j`是待反转的链表。初始化，`i`为空指针，`j`为头节点，`k`为头结点的下一个指针指向的内容（可能为空），并把`i`的指针指空。在链表反转过程如下：`j`的指针指向`i`，然后把`i`，`j`，`k`分别按次序向后移动。重复执行上述步骤直到`j`为空。\n\n### 代码：\n\n```\nListNode *ReverseList(ListNode *pHead){\n    if(pHead == nullptr) return nullptr;\n    ListNode *p1 = nullptr, *p2 = pHead, *p3 = pHead->pNext;\n    while(p2 != nullptr){\n        p2->pNext = p1;\n        p1 = p2;\n        p2 = p3;\n        if(p3) p3 = p3->next;        \n    }\n    return p2;    \n}\n```\n\n## 面25：合并链表\n\n### 题面：\n\n将两个链表增序合并成一条链表。\n\n### 思路：\n\n用两个指针指向两条链表的头结点，用合并数组的思路合并即可。注意一条链表为空后，另一条不为空的链表可以直接连上去。\n\n### 代码：\n\n```\nListNode *Merge(ListNode *pHead1, ListNode *pHead2){\n    if( pHead1 == nullptr && pHead2 == nullptr){\n        return nullptr;\n    }else if(pHead1 == nullptr) return pHead2;\n    else if(pHead2 == nullpr) return pHead1;\n    \n    ListNode *p1 = pHead1, *p2 = pHead2, *pHead3 = new ListNode(), *p3 = pHead3;\n    \n    while(p1 && p2){\n        if(p1->value <= p2->value){\n            p3->pNext = p1;\n            p3 = p1;            \n            p1 = p1->pNext;\n\n        }else{\n            p3->pNext = p2;\n            p3 = p2;\n            p2 = p2->pNext;\n        }                 \n    }\n    p3->pNext = nullptr;       \n    if(p1){\n        p3->pNext = p1;\n    }else if(p2){\n        p3->pNext = p2;\n    }\n    ListNode *pFree = pHead3;\n    pHead3 = pHead->pNext;\n    delete pFree;\n\treturn pHead3;        \n}\n```\n\n### 测试\n\n[参见](https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp)\n\n## 面35：复杂链表的分解\n\n### 题面：\n\n给出一个有两个指针的链表数据结构，一个指针1指向下一个节点，另一个指针2可指向任意一个节点，或者为空。将给出的链表复制并返回头结点。\n\n### 思路：\n\n这题目还是挺不错的！属于比较复杂的题目，而且有思考空间。\n\n将复制的过程分解为两个部分，第一步先不管指针2，复制整个链表；第二步再设置指针2。第一步需要的复杂度为O(N)O(N)。第二步再复制的过程中需要确定复制链表中指针2指向的节点的的位置。\n\n第一种确定位置的思路：就是从原链表遍历寻找原指针指向的节点位置，同样的在复制链表上一起遍历。复杂度为O(N2)O(N2)。\n\n第二种确定位置的思路：直接用hash表记录下原链表中节点和复制链表中对应节点的映射关系。复杂度为O(N)O(N)。是用了空间换时间的思路。\n\n> 害怕碰撞。\n\n脱离上面的方案的限制，更巧妙的方法来了。链表的顺序遍历远远比随机遍历方便很多，而且指针指向的节点的位置不随链表节点而变化。可以考虑把复制节点直接插入到被复制节点的后面。全部复制完成后，由于原节点的指针2指向的节点的后一个节点就是复制节点的指针2指向的节点，所以可以直接指向。复杂度为O(N)O(N)，空间复杂度为O(1)O(1)。\n\n### 代码：\n\n```\nstruct ComplexListNode{\n    int value;\n    ComplexListNode *pNext;\n    ComplexListNode *pSibling;    \n}\n\nvoid CopyNode(ComplexListNode *pHead){\n    if(pHead == nullptr) return null;\n    ComplexListNode *pNode = pHead;\n    while(pNode){\n        ComplexListNode *pNew = new ComplexListNode();\n        pNew->value = pNode->value;\n        pNew->pNext = pNode->pNext;\n        pNew->pSibling = nullptr;\n        \n        pNode->pNext = pNew;\n    \tpNode = pNew->pNext;\n    }    \n}\n\nvoid SetSiblingLink(ComplexListNode * pHead){\n    if(pHead == nullptr )return nullptr;\n    ComplexListNode *pNode  = pHead;\n    while(pNode){\n\t\tComplexListNode *pNext = pNode->pNext;\n        pNext->pSibling = pNode->pSibliing->pNext;\n        pNode = pNext->pNext;\n    }    \n}\n\nComplexListNode *GetComplexList(ComplexListNode *pHead){\n    if(pHead == nullptr) return nullptr;\n\tComplexListNode *pNode = pHead;\n    ComplexListNode *pClonedHead = pNode->pNext;\n    ComplexListNode *pClonedNode = pNode->pNext;\n    pNode->next = pClonedNode->next;\n    pNode = pClneNode->next;\n    while(pNode){\n        pClonedNode->pNext = pNode->pNext;        \n        pNode->pNext = pNode->pNext->pNext;\n        pClonedNode = pNode->pNext;\n        pNode = pClonedNode->pNext;   \n        /*\n        //we can write in this way.\n        pClonedNode->pNext = pNode->pNext;        \n        pClonedNode = pClonedNode->pNext;\n\t\tpNode->pNext = pClonedNode->pNext;\n        pNode = pNode->pNext;                  \n        */\n    }\n    return pClonedHead;      \n}\nComplexListNode *Clone(ComplexListNode* pHead){\n    CopyNode(pHead);\n    SetSiblingLink(pHead);\n    return GetComplexList(pHead);\n}\n```\n\n## 面36：把二叉搜索树转化为双向链表\n\n### 题面：\n\n如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。\n\n### 思路：\n\n可以从递归的角度入手。对于一个节点`A`，中序遍历到`A`，则`A`的左子树已经转化为了链表，连接好`A`和`A`的左子树的最大节点（前一个指针）的指针则连接完成。\n\n那对于`A`的右子树的最小节点`B`与`A`之间的连接，也可以看成`B`与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。\n\n注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。\n\n> 对于一个节点`A`的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点`B`的指针，并设置好`B`的右指针和`A`的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是`NULL`，所以无需修改。\n\n### 代码：\n\n```\nvoid AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&preNode, BinaryTreeNode *&pHead){\n    if(pRoot == nullptr) return;\n  \tAdjustLinkCore(pRoot->pLeft, preNode, pHead);\n\n    if(pHead == nullptr) pHead = pRoot;\n    pRoot->pLeft = preNode;\n    if(preNode) preNode->pRight = pRoot;\n    preNode = pRoot;\n    \n    AdjustLinkCore(pRoot->pRight, preNode, pHead);\n}\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){\n    BinaryTreeNode *preNode = nullptr;\n    BinaryTreeNode *pHead = nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n}\n```\n\n## 面52：两个链表的第一个公共节点\n\n### 题面：\n\n如题。\n\n### 思路：\n\n明显地，可以用栈来存储两个链表遍历过程。空间复杂度和时间复杂度都是O(N)O(N)。\n\n换一种想法，能不能直接遍历就使两个链表同时遍历到第一个公共节点。定义两个指针来遍历两条链表。只要让一个指向长链表的节点的指针多走多出的节点，就可以让两个节点同时同序的遍历到公共节点。时间复杂度为O(N+M)O(N+M)，空间复杂度O(1)O(1)。\n\n### 代码：\n\n```\nint GetLenOfList(ListNode *pHead){\n    int len = 0;\n    ListNode *pNode = pHead;\n    while(pNode){\n        pNode = pNode->pNext;\n        len++;\n    }\n    return len;\n}\nListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2){\n    if(pHead1 == nullptr || pHead2 == nullptr) return nullptr;\n    int len1 = GetLenOfList(pHead1);\n    int len2 = GetLenOfList(pHead2);\n    if(len1 < len2){\n        swap(pHead1, pHead2);\n        swap(len1, len2);\n    }\n    int step = len1 - len2;\n\tListNode *pNode1 = pHead1;\n    ListNode *pNode2 = pHead2;\n    while(step){\n        pNode1 = pNode->pNext;\n        step--;\n    }\n    while(pNode1 != pNode2){\n        pNode1 = pNode1->pNext;\n        pNode2 = pNode1->pNext;\n    }\n    //two pNodes maybe refer to null or the first common node.\n    return pNode1;\n}\n```\n\n\n\n[更简单的解法：](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/) \n\n双指针遍历两条链表，遍历到结尾则跳到另一条链表上。路径长度的相等一定会有两个指针相遇。\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p1 = headA,  *p2 = headB;\n        while(p1 != p2){\n            p1 = p1 == nullptr ? headB : p1->next;\n            p2 = p2 == nullptr ? headA : p2->next;\n        }\n        return p1;\n    }\n};\n```\n\n\n\n\n\n## [链表回文判断]()\n\n[234. Palindrome Linked List](https://leetcode-cn.com/problems/palindrome-linked-list/)\n\n`O(n)`时间，`O(1)`空间\n\n### 思路：\n\n朴素的思路：先用快慢指针找到链表中间节点，之后翻转后半部分链表。判断两个链表是否相同。\n\n其中奇数个节点链表需要考虑一下。\n\n\n\n### 代码\n\n````c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        ListNode *slow ,*quick;\n        slow = quick = head;\n        while(quick && quick->next){\n            slow = slow->next;\n            quick = quick->next->next;\n        }\n        ListNode *p2 = reverseList(slow), *p1 = head;\n        while(p1 && p2){\n            if(p1->val != p2->val) return false;\n            p1 = p1->next;\n            p2 = p2->next;\n        }\n        return true;\n        \n    }\n\n    ListNode *reverseList(ListNode* head){\n        if(head == nullptr) return head;\n        ListNode *per = nullptr, *cur = head, *next = head->next;\n        while(cur){\n            cur->next = per;\n            per = cur;\n            cur = next;\n            if(next) next = next->next;\n        }\n        return per;\n    }\n};\n````\n\n## [奇偶链表节点分解](https://leetcode-cn.com/problems/odd-even-linked-list/)\n\n\n\n非常容易写复杂的题目。\n\n````c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if(!(head && head->next)) return head;\n        // ListNode *p1 = head, *p2 = new ListNode(), *evenHead = p2, *pre = nullptr;\n        // while(p1 && p1->next){\n        //     p2->next = p1->next;\n        //     p2 = p2->next;\n        //     p1->next = p2->next;\n        //     pre = p1;\n        //     p1 = p2->next;\n        // }\n        // p2->next = nullptr;    \n        // p1 = p1 ? p1 : pre;\n        // p1->next = evenHead->next;\n        // delete evenHead;\n        // return head;\n        ListNode *evenHead = head->next, *odd = head, *even = head->next;\n        while(even && even->next){\n            odd->next = even->next;\n            odd = odd->next;\n            even->next = odd->next;\n            even = even->next;\n        }\n        odd->next = evenHead;\n        return head;\n    }\n};\n````\n\n## [删除倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/)\n\n\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode node, *pre = &node;\n        pre->next = head;\n        ListNode *quick, *slow;\n        quick = slow = pre;\n        for(int i = 0; i < n; ++i) quick = quick->next;\n        while(quick->next){\n            quick = quick->next;\n            slow = slow->next;\n        }\n        ListNode *fordel = slow->next;\n        slow->next = fordel->next;\n        if(fordel == head){ //删除节点 务必小心：1.删了头结点，需要重置头结点 2.考虑后续节点\n            head = fordel->next;\n        }\n        delete fordel;            \n        return head; \n\n    }\n};\n```\n\n","slug":"刷题-数据结构-链表-面试题-链表相关","published":1,"updated":"2021-02-20T10:32:03.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckoq26j7r005wl5uoc82i4ism","content":"<span id=\"more\"></span>\n\n<p>所有关于链表的题目都会总结在这里。假设这些题目的链表的头结点都是带有效值的</p>\n<h2 id=\"定义链表\"><a href=\"#定义链表\" class=\"headerlink\" title=\"定义链表\"></a>定义链表</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ListNode&#123;\n    int Value;\n    ListNode* pNext;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"尾插入节点\"><a href=\"#尾插入节点\" class=\"headerlink\" title=\"尾插入节点\"></a>尾插入节点</h2><p>注意第一个参数是指针的指针，因为有可能需要修改第一个链表节点。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void AddToTail(ListNode **pHead, int value)&#123;\n    if(pHead &#x3D;&#x3D; null) return;\n\tListNode *pNew &#x3D; new ListNode();\n    pNew-&gt;Value &#x3D; value;\n    pNew-&gt;pNext &#x3D; nullptr;\n    if(*pHead &#x3D;&#x3D; null)&#123;\n        *pHead &#x3D; pNew;\n    &#125;else&#123;\n        ListNode* pNode &#x3D; *pHead;\n        while(pNode-&gt;pNext !&#x3D; null)&#123;\n            pNode &#x3D; pNode-&gt;pNext;\n        &#125;\n        *pNode-&gt;pNext &#x3D; pNew;        \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"删除第一个对应值的链表\"><a href=\"#删除第一个对应值的链表\" class=\"headerlink\" title=\"删除第一个对应值的链表\"></a>删除第一个对应值的链表</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">viod RemoveNode(ListNode** pHead, int value)&#123;\n    if(pHead &#x3D;&#x3D; nullptr || *pHead &#x3D;&#x3D; nullptr) return;\n    ListNode *pToDeleted &#x3D; nullptr;\n    if((*pHead)-&gt;value &#x3D;&#x3D; value)&#123;\n        pToDeleted &#x3D; *pHead;\n        *pHead &#x3D; (*pHead)-&gt;pNext;\n    &#125;else&#123;\n        ListNode *pNode &#x3D; *pHead;\n        &#x2F;&#x2F;pNode指向检查节点的前一个节点\n        while((*pNode)-&gt;pNext !&#x3D; null &amp;&amp; (*pNode)-&gt;pNext-&gt;value !&#x3D; value)&#123;\n            pNode &#x3D; pNode-&gt;pNext;\n        &#125;\n        if((*pNode)-&gt;pNext !&#x3D; null &amp;&amp; (*pNode)-&gt;pNext-&gt;value &#x3D;&#x3D; value)&#123;\n\t\t\tpToDeleted &#x3D; (*pNode)-&gt;pNext;\n        &#125;\n    &#125;\n\tif(pToDeleted !&#x3D; nullptr)&#123;\n        delte pToDelted;\n        pToDelted &#x3D; nullptr; &#x2F;&#x2F;释放内存后，即使是不需要使用的指针，也要做好清除工作，不然不容易维护            \n    &#125;\n\t\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p><code>pToDeleted = *pNode-&gt;pNext;</code>上面遍历链表中代码不应该用<code>pToDeleted</code>来记录链表值，否然容易出现代码指针值意义混乱，造成不该删的指针却删掉了。</p>\n</blockquote>\n<h2 id=\"面试题6-从尾到头打印链表\"><a href=\"#面试题6-从尾到头打印链表\" class=\"headerlink\" title=\"面试题6 从尾到头打印链表\"></a>面试题6 从尾到头打印链表</h2><p>假如对空间复杂度在O(N)O(N)之上，那么可以使用栈或者递归。</p>\n<p><strong>栈代码如下</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintListReversingly_Iteratively(ListNode* pHead)&#123;\n    &#x2F;&#x2F;使用指针类型的STACK更省内存？\n    std::stack&lt;ListNode*&gt; nodes;\n    ListNode* pNode &#x3D; pHead;\n    while(pNode !&#x3D; nullptr)&#123;\n        nodes.push(pNode);\n        pNode &#x3D; pNode-&gt;pNext;\n    &#125;\n    while(!nodes.empty())&#123;\n        pNode &#x3D; nodes.top();\n        printf(&quot;%d\\n&quot;, pNode-&gt;value);\n        nodes.pop();\n    &#125;   \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>递</strong></p>\n<p><strong>归代码</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintListReversingly_Recursively(ListNode* pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    PrintListReversingly_Recursively(pHead-&gt;pNext);\n    printf(&quot;%d\\n&quot;, pHead-&gt;pNext);\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面试18：删除一个链表节点\"><a href=\"#面试18：删除一个链表节点\" class=\"headerlink\" title=\"面试18：删除一个链表节点\"></a>面试18：删除一个链表节点</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给定一个单向链表的头结点指针和一个指向待删除的节点的指针，要求用O(N)O(N)时间删除节点。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>教科书上的链表删除都是遍历得到上一个待删除的节点的指针，时间复杂度O(N)O(N)。显然不行，也可以直接把待删除的节点<code>K</code>的下一个节点<code>J</code>的内容复制到<code>K</code>上，再删除<code>J</code>，就可以快速删除。考虑边界上，如果没有下一个节点则需要从头遍历；如果只有一个头结点且删除的是头结点，那么只能把头结点置<code>nullptr</code>。</p>\n<p>其时间复杂度为(n−1)∗O(1)+O(N)(n−1)∗O(1)+O(N)。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void DeleteNode(ListNode **pHead, ListNode *pToBeDeleted)&#123;\n    if(pHead &#x3D;&#x3D; nullptr || (*phead) &#x3D;&#x3D; nullptr || (*pToBeDeleted) &#x3D;&#x3D; nullptr ) return;\n    ListNode *pFree &#x3D; nullptr;\n    \n    if(pToBeDeleted-&gt;pNext)&#123;\n        pFree &#x3D; ToBeDeleted-&gt;pNext;\n        pToBeDeleted-&gt;value &#x3D; pToBeDeleted-&gt;pNext-&gt;value;   \n        pToBeDeleted-&gt;pNext &#x3D; pToBeDeleted-&gt;pNext-&gt;pNext;   \n        \n    &#125;\n    &#x2F;&#x2F;删除节点无后继节点，且是头结点\n    else if( *pHead &#x3D;&#x3D; pToBeDeleted)&#123;\n\t\tpFree &#x3D; *pHead;\n        *pHead &#x3D; nullptr;\n    &#125;\n    &#x2F;&#x2F; 链表中多个节点，且删除节点在末尾\n    else&#123;\n\t\tListNode *pCur &#x3D; *pHead\n        for(; pCur-&gt;pNext-&gt;pNext !&#x3D; nullptr; pCur &#x3D; pCur-&gt;pNext);\n        pFree &#x3D; pCur-&gt;pNext;\n        pCur-&gt;pNext &#x3D; nullptr;\n    &#125;\n    Delete pFree;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>错误点：</p>\n<ul>\n<li>the properiry of “*” &gt; the properity of “==”</li>\n<li>链表插入和删除后没有设置指针</li>\n</ul>\n<p>注意点：</p>\n<p>这个函数假设了待删除的节点一定在链表中；</p>\n<p>头结点可能删除掉，所以设置了头结点为指针的指针。</p>\n</blockquote>\n<h2 id=\"面18（题目二）：删除重复值的链表节点\"><a href=\"#面18（题目二）：删除重复值的链表节点\" class=\"headerlink\" title=\"面18（题目二）：删除重复值的链表节点\"></a>面18（题目二）：删除重复值的链表节点</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>删除一条已排序的链表中的所有的其值重复出现的节点。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>在上面学习的基础上，连续删除就行，应该是比较简单的。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void DeleteDuplication(ListNode **pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr || *pHead &#x3D;&#x3D; nullptr) return;\n    \n    ListNode *pCur &#x3D; *pHead, *pPre &#x3D; nullptr, *pFree &#x3D; nullptr;\n    &#x2F;&#x2F;定义一个头结点，避免不同情况的删除\n    ListNode *pKid &#x3D; new ListNode();\n    pKid-&gt;pNext &#x3D; *pHead;\n    pPre &#x3D; pKid;\n    \n    while(pCur !&#x3D; nullptr)&#123;\n\t\tint value &#x3D; pCur-&gt;value,  isDuplication &#x3D; 0;\n        &#x2F;&#x2F;删除后面的重复节点\n        while(pCur-&gt;pNext &amp;&amp; pCur-&gt;pNext-&gt;value &#x3D;&#x3D; value)&#123;\n            pFree &#x3D; pCur-&gt;pNext;\n            pCur-&gt;pNext &#x3D; pFree-&gt;pNext;\n            delete pFree;\n            isDuplication &#x3D; 1;\n        &#125;\n        \n        &#x2F;&#x2F;若重复，则删除第一个重复节点\n\t\tif(isDuplication)&#123;\n\t\t\tpFree &#x3D; pCur;\t\t\t\n\t\t\tpCur &#x3D; pCur-&gt;pNext;\t\t\t\n\t\t\tpPre-&gt;pNext &#x3D; pCur;\n            delete pFree;\n\t\t\t&#x2F;&#x2F; if(pFree) printf(&quot;@&quot;);\n        &#125;\n        &#x2F;&#x2F;不重复则下移\n        else&#123;\n            pPre &#x3D; pPre-&gt;pNext;\n            pCur &#x3D; pCur-&gt;pNext;\n        &#125;\n    &#125;\n\t*pHead &#x3D; pKid-&gt;pNext;\n    delete pKid;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><strong>测试</strong></h2><p><a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp\">参见</a></p>\n<h2 id=\"面22：倒数第K个节点\"><a href=\"#面22：倒数第K个节点\" class=\"headerlink\" title=\"面22：倒数第K个节点\"></a>面22：倒数第K个节点</h2><h3 id=\"题面：-2\"><a href=\"#题面：-2\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个链表，返回倒数第K个节点。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>最直观的思路是遍历到终点，反向遍历<code>K-1</code>次，但是对单链表无可奈何，而且效率不高。</p>\n<p>第二种思路可以遍历一次求链表的长度<code>L</code>，第二次遍历<code>L - K + 1</code>个节点。但是需要遍历两次链表。</p>\n<p>三种思路更秒，采用双指针，第一个指针先遍历K个节点，随后两个节点一起遍历，直到第一个指针为空，第二个指针就指向了倒数第K个节点。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *FindKthToTail(ListNode *pHead, unsigned int K)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return nullptr;\n    ListNode *p1 &#x3D; pHead, *p2 &#x3D; pHead;\n    \n    for(int i &#x3D; 0; i &lt; K; i++)&#123;\n        if(p1 &#x3D;&#x3D; nullptr) return nullptr;\n        p1 &#x3D; p1-&gt;pNext;\n    &#125;\n    while(p1!&#x3D;nullptr)&#123;\n        p1 &#x3D; p1-&gt;pNext;\n        p2 &#x3D; p2-&gt;pNext;\n    &#125;\n    return p2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>这代码写的比剑指offer代码写的优美多了</p>\n</blockquote>\n<h3 id=\"相关扩展：\"><a href=\"#相关扩展：\" class=\"headerlink\" title=\"相关扩展：\"></a>相关扩展：</h3><p>相关题目有找出链表的中间节点；判断一个链表是否有环；更难一点判断链表的环的入口节点！</p>\n<p><strong>其思路宗旨都是使用两个进度不一样的指针指向不同的节点来解决问题！</strong></p>\n<h2 id=\"面23：链表中的环的入口节点\"><a href=\"#面23：链表中的环的入口节点\" class=\"headerlink\" title=\"面23：链表中的环的入口节点\"></a>面23：链表中的环的入口节点</h2><h3 id=\"题面：-3\"><a href=\"#题面：-3\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个链表，求出其成环的入口节点。</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>首先得判断有环，可以使用一个快一慢的两只指针（移动速度分别为2和1）指向链表头。如果链表有环，则快慢指针就一定会相遇。</p>\n<p>那么对于有环的链表如何确定其入口节点呢？假设环的中节点有<code>K</code>个，快指针从头先遍历<code>K</code>次之后，快慢指针同时开始遍历，正好两个指针会在入口节点上汇合！</p>\n<p>如何确定环中节点呢？这个！可以直接在确定有环后，记录下该节点的位置，再继续遍历直到重新到该节点同时统计经过的节点数量即可。</p>\n<blockquote>\n<p>amazing啊</p>\n</blockquote>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *FindCycleNode(ListNode* pHead)&#123;\n\tif(pHead &#x3D;&#x3D; nullptr) return nullptr;\n    ListNode *pSlow, *pQuick, *pRecord &#x3D; nullptr ;\n    &#x2F;&#x2F;判断有没有环\n    pSlow &#x3D; pQuick &#x3D; pHead;\n    while(pQuick !&#x3D; nullptr)&#123;\n\t    pQuick &#x3D; pQuick-&gt;pNext;\n        if(pQuick) pQuick &#x3D; pQuick-&gt;pNext;\n        if(pSlow) pSlow &#x3D; pSlow-&gt;pNext;        \n        if(pSlow &#x3D;&#x3D; pQuick) break;\n    &#125;\n    if(pQuick &#x3D;&#x3D; nullptr) return nullptr;\n    &#x2F;&#x2F;确定环内数量\n    pRecord &#x3D; pSlow;\n    int numberOfCycle &#x3D; 0;\n    while(pRecord !&#x3D; pSlow)&#123;\n        numberOfCycle++;\n        pSlow &#x3D; pSlow-&gt;pNext;\n    &#125;\n    &#x2F;&#x2F;确定环的入口节点\n    pSlow &#x3D; pQuick &#x3D; pHead;\n    for(int i &#x3D; 0; i &lt; numberOfCycle; i++)&#123;\n        pQuick &#x3D; pQuick-&gt;pNext;\n    &#125;\n    while(pSlow !&#x3D; pQuick)&#123;\n        pQuick &#x3D; pQuick-&gt;pNext;\n        pSlow &#x3D; pSlow-&gt;pNext;                \n    &#125;\n    return pSlow;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面24：反转链表\"><a href=\"#面24：反转链表\" class=\"headerlink\" title=\"面24：反转链表\"></a>面24：反转链表</h2><h3 id=\"题面：-4\"><a href=\"#题面：-4\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>在反转过程中，假设有三个顺序排列的待反转的链表<code>i</code>，<code>j</code>，<code>k</code>，其中<code>j</code>是待反转的链表。初始化，<code>i</code>为空指针，<code>j</code>为头节点，<code>k</code>为头结点的下一个指针指向的内容（可能为空），并把<code>i</code>的指针指空。在链表反转过程如下：<code>j</code>的指针指向<code>i</code>，然后把<code>i</code>，<code>j</code>，<code>k</code>分别按次序向后移动。重复执行上述步骤直到<code>j</code>为空。</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *ReverseList(ListNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return nullptr;\n    ListNode *p1 &#x3D; nullptr, *p2 &#x3D; pHead, *p3 &#x3D; pHead-&gt;pNext;\n    while(p2 !&#x3D; nullptr)&#123;\n        p2-&gt;pNext &#x3D; p1;\n        p1 &#x3D; p2;\n        p2 &#x3D; p3;\n        if(p3) p3 &#x3D; p3-&gt;next;        \n    &#125;\n    return p2;    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面25：合并链表\"><a href=\"#面25：合并链表\" class=\"headerlink\" title=\"面25：合并链表\"></a>面25：合并链表</h2><h3 id=\"题面：-5\"><a href=\"#题面：-5\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>将两个链表增序合并成一条链表。</p>\n<h3 id=\"思路：-5\"><a href=\"#思路：-5\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>用两个指针指向两条链表的头结点，用合并数组的思路合并即可。注意一条链表为空后，另一条不为空的链表可以直接连上去。</p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *Merge(ListNode *pHead1, ListNode *pHead2)&#123;\n    if( pHead1 &#x3D;&#x3D; nullptr &amp;&amp; pHead2 &#x3D;&#x3D; nullptr)&#123;\n        return nullptr;\n    &#125;else if(pHead1 &#x3D;&#x3D; nullptr) return pHead2;\n    else if(pHead2 &#x3D;&#x3D; nullpr) return pHead1;\n    \n    ListNode *p1 &#x3D; pHead1, *p2 &#x3D; pHead2, *pHead3 &#x3D; new ListNode(), *p3 &#x3D; pHead3;\n    \n    while(p1 &amp;&amp; p2)&#123;\n        if(p1-&gt;value &lt;&#x3D; p2-&gt;value)&#123;\n            p3-&gt;pNext &#x3D; p1;\n            p3 &#x3D; p1;            \n            p1 &#x3D; p1-&gt;pNext;\n\n        &#125;else&#123;\n            p3-&gt;pNext &#x3D; p2;\n            p3 &#x3D; p2;\n            p2 &#x3D; p2-&gt;pNext;\n        &#125;                 \n    &#125;\n    p3-&gt;pNext &#x3D; nullptr;       \n    if(p1)&#123;\n        p3-&gt;pNext &#x3D; p1;\n    &#125;else if(p2)&#123;\n        p3-&gt;pNext &#x3D; p2;\n    &#125;\n    ListNode *pFree &#x3D; pHead3;\n    pHead3 &#x3D; pHead-&gt;pNext;\n    delete pFree;\n\treturn pHead3;        \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p><a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp\">参见</a></p>\n<h2 id=\"面35：复杂链表的分解\"><a href=\"#面35：复杂链表的分解\" class=\"headerlink\" title=\"面35：复杂链表的分解\"></a>面35：复杂链表的分解</h2><h3 id=\"题面：-6\"><a href=\"#题面：-6\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个有两个指针的链表数据结构，一个指针1指向下一个节点，另一个指针2可指向任意一个节点，或者为空。将给出的链表复制并返回头结点。</p>\n<h3 id=\"思路：-6\"><a href=\"#思路：-6\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>这题目还是挺不错的！属于比较复杂的题目，而且有思考空间。</p>\n<p>将复制的过程分解为两个部分，第一步先不管指针2，复制整个链表；第二步再设置指针2。第一步需要的复杂度为O(N)O(N)。第二步再复制的过程中需要确定复制链表中指针2指向的节点的的位置。</p>\n<p>第一种确定位置的思路：就是从原链表遍历寻找原指针指向的节点位置，同样的在复制链表上一起遍历。复杂度为O(N2)O(N2)。</p>\n<p>第二种确定位置的思路：直接用hash表记录下原链表中节点和复制链表中对应节点的映射关系。复杂度为O(N)O(N)。是用了空间换时间的思路。</p>\n<blockquote>\n<p>害怕碰撞。</p>\n</blockquote>\n<p>脱离上面的方案的限制，更巧妙的方法来了。链表的顺序遍历远远比随机遍历方便很多，而且指针指向的节点的位置不随链表节点而变化。可以考虑把复制节点直接插入到被复制节点的后面。全部复制完成后，由于原节点的指针2指向的节点的后一个节点就是复制节点的指针2指向的节点，所以可以直接指向。复杂度为O(N)O(N)，空间复杂度为O(1)O(1)。</p>\n<h3 id=\"代码：-6\"><a href=\"#代码：-6\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ComplexListNode&#123;\n    int value;\n    ComplexListNode *pNext;\n    ComplexListNode *pSibling;    \n&#125;\n\nvoid CopyNode(ComplexListNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return null;\n    ComplexListNode *pNode &#x3D; pHead;\n    while(pNode)&#123;\n        ComplexListNode *pNew &#x3D; new ComplexListNode();\n        pNew-&gt;value &#x3D; pNode-&gt;value;\n        pNew-&gt;pNext &#x3D; pNode-&gt;pNext;\n        pNew-&gt;pSibling &#x3D; nullptr;\n        \n        pNode-&gt;pNext &#x3D; pNew;\n    \tpNode &#x3D; pNew-&gt;pNext;\n    &#125;    \n&#125;\n\nvoid SetSiblingLink(ComplexListNode * pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr )return nullptr;\n    ComplexListNode *pNode  &#x3D; pHead;\n    while(pNode)&#123;\n\t\tComplexListNode *pNext &#x3D; pNode-&gt;pNext;\n        pNext-&gt;pSibling &#x3D; pNode-&gt;pSibliing-&gt;pNext;\n        pNode &#x3D; pNext-&gt;pNext;\n    &#125;    \n&#125;\n\nComplexListNode *GetComplexList(ComplexListNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return nullptr;\n\tComplexListNode *pNode &#x3D; pHead;\n    ComplexListNode *pClonedHead &#x3D; pNode-&gt;pNext;\n    ComplexListNode *pClonedNode &#x3D; pNode-&gt;pNext;\n    pNode-&gt;next &#x3D; pClonedNode-&gt;next;\n    pNode &#x3D; pClneNode-&gt;next;\n    while(pNode)&#123;\n        pClonedNode-&gt;pNext &#x3D; pNode-&gt;pNext;        \n        pNode-&gt;pNext &#x3D; pNode-&gt;pNext-&gt;pNext;\n        pClonedNode &#x3D; pNode-&gt;pNext;\n        pNode &#x3D; pClonedNode-&gt;pNext;   \n        &#x2F;*\n        &#x2F;&#x2F;we can write in this way.\n        pClonedNode-&gt;pNext &#x3D; pNode-&gt;pNext;        \n        pClonedNode &#x3D; pClonedNode-&gt;pNext;\n\t\tpNode-&gt;pNext &#x3D; pClonedNode-&gt;pNext;\n        pNode &#x3D; pNode-&gt;pNext;                  \n        *&#x2F;\n    &#125;\n    return pClonedHead;      \n&#125;\nComplexListNode *Clone(ComplexListNode* pHead)&#123;\n    CopyNode(pHead);\n    SetSiblingLink(pHead);\n    return GetComplexList(pHead);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面36：把二叉搜索树转化为双向链表\"><a href=\"#面36：把二叉搜索树转化为双向链表\" class=\"headerlink\" title=\"面36：把二叉搜索树转化为双向链表\"></a>面36：把二叉搜索树转化为双向链表</h2><h3 id=\"题面：-7\"><a href=\"#题面：-7\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。</p>\n<h3 id=\"思路：-7\"><a href=\"#思路：-7\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以从递归的角度入手。对于一个节点<code>A</code>，中序遍历到<code>A</code>，则<code>A</code>的左子树已经转化为了链表，连接好<code>A</code>和<code>A</code>的左子树的最大节点（前一个指针）的指针则连接完成。</p>\n<p>那对于<code>A</code>的右子树的最小节点<code>B</code>与<code>A</code>之间的连接，也可以看成<code>B</code>与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。</p>\n<p>注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。</p>\n<blockquote>\n<p>对于一个节点<code>A</code>的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点<code>B</code>的指针，并设置好<code>B</code>的右指针和<code>A</code>的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是<code>NULL</code>，所以无需修改。</p>\n</blockquote>\n<h3 id=\"代码：-7\"><a href=\"#代码：-7\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead)&#123;\n    if(pRoot &#x3D;&#x3D; nullptr) return;\n  \tAdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead);\n\n    if(pHead &#x3D;&#x3D; nullptr) pHead &#x3D; pRoot;\n    pRoot-&gt;pLeft &#x3D; preNode;\n    if(preNode) preNode-&gt;pRight &#x3D; pRoot;\n    preNode &#x3D; pRoot;\n    \n    AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead);\n&#125;\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot)&#123;\n    BinaryTreeNode *preNode &#x3D; nullptr;\n    BinaryTreeNode *pHead &#x3D; nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面52：两个链表的第一个公共节点\"><a href=\"#面52：两个链表的第一个公共节点\" class=\"headerlink\" title=\"面52：两个链表的第一个公共节点\"></a>面52：两个链表的第一个公共节点</h2><h3 id=\"题面：-8\"><a href=\"#题面：-8\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题。</p>\n<h3 id=\"思路：-8\"><a href=\"#思路：-8\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显地，可以用栈来存储两个链表遍历过程。空间复杂度和时间复杂度都是O(N)O(N)。</p>\n<p>换一种想法，能不能直接遍历就使两个链表同时遍历到第一个公共节点。定义两个指针来遍历两条链表。只要让一个指向长链表的节点的指针多走多出的节点，就可以让两个节点同时同序的遍历到公共节点。时间复杂度为O(N+M)O(N+M)，空间复杂度O(1)O(1)。</p>\n<h3 id=\"代码：-8\"><a href=\"#代码：-8\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int GetLenOfList(ListNode *pHead)&#123;\n    int len &#x3D; 0;\n    ListNode *pNode &#x3D; pHead;\n    while(pNode)&#123;\n        pNode &#x3D; pNode-&gt;pNext;\n        len++;\n    &#125;\n    return len;\n&#125;\nListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2)&#123;\n    if(pHead1 &#x3D;&#x3D; nullptr || pHead2 &#x3D;&#x3D; nullptr) return nullptr;\n    int len1 &#x3D; GetLenOfList(pHead1);\n    int len2 &#x3D; GetLenOfList(pHead2);\n    if(len1 &lt; len2)&#123;\n        swap(pHead1, pHead2);\n        swap(len1, len2);\n    &#125;\n    int step &#x3D; len1 - len2;\n\tListNode *pNode1 &#x3D; pHead1;\n    ListNode *pNode2 &#x3D; pHead2;\n    while(step)&#123;\n        pNode1 &#x3D; pNode-&gt;pNext;\n        step--;\n    &#125;\n    while(pNode1 !&#x3D; pNode2)&#123;\n        pNode1 &#x3D; pNode1-&gt;pNext;\n        pNode2 &#x3D; pNode1-&gt;pNext;\n    &#125;\n    &#x2F;&#x2F;two pNodes maybe refer to null or the first common node.\n    return pNode1;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/\">更简单的解法：</a> </p>\n<p>双指针遍历两条链表，遍历到结尾则跳到另一条链表上。路径长度的相等一定会有两个指针相遇。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        ListNode *p1 &#x3D; headA,  *p2 &#x3D; headB;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; p1 &#x3D;&#x3D; nullptr ? headB : p1-&gt;next;\n            p2 &#x3D; p2 &#x3D;&#x3D; nullptr ? headA : p2-&gt;next;\n        &#125;\n        return p1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h2 id=\"链表回文判断\"><a href=\"#链表回文判断\" class=\"headerlink\" title=\"链表回文判断\"></a><a href=\"\">链表回文判断</a></h2><p><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">234. Palindrome Linked List</a></p>\n<p><code>O(n)</code>时间，<code>O(1)</code>空间</p>\n<h3 id=\"思路：-9\"><a href=\"#思路：-9\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>朴素的思路：先用快慢指针找到链表中间节点，之后翻转后半部分链表。判断两个链表是否相同。</p>\n<p>其中奇数个节点链表需要考虑一下。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isPalindrome(ListNode* head) &#123;\n        ListNode *slow ,*quick;\n        slow &#x3D; quick &#x3D; head;\n        while(quick &amp;&amp; quick-&gt;next)&#123;\n            slow &#x3D; slow-&gt;next;\n            quick &#x3D; quick-&gt;next-&gt;next;\n        &#125;\n        ListNode *p2 &#x3D; reverseList(slow), *p1 &#x3D; head;\n        while(p1 &amp;&amp; p2)&#123;\n            if(p1-&gt;val !&#x3D; p2-&gt;val) return false;\n            p1 &#x3D; p1-&gt;next;\n            p2 &#x3D; p2-&gt;next;\n        &#125;\n        return true;\n        \n    &#125;\n\n    ListNode *reverseList(ListNode* head)&#123;\n        if(head &#x3D;&#x3D; nullptr) return head;\n        ListNode *per &#x3D; nullptr, *cur &#x3D; head, *next &#x3D; head-&gt;next;\n        while(cur)&#123;\n            cur-&gt;next &#x3D; per;\n            per &#x3D; cur;\n            cur &#x3D; next;\n            if(next) next &#x3D; next-&gt;next;\n        &#125;\n        return per;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"奇偶链表节点分解\"><a href=\"#奇偶链表节点分解\" class=\"headerlink\" title=\"奇偶链表节点分解\"></a><a href=\"https://leetcode-cn.com/problems/odd-even-linked-list/\">奇偶链表节点分解</a></h2><p>非常容易写复杂的题目。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* oddEvenList(ListNode* head) &#123;\n        if(!(head &amp;&amp; head-&gt;next)) return head;\n        &#x2F;&#x2F; ListNode *p1 &#x3D; head, *p2 &#x3D; new ListNode(), *evenHead &#x3D; p2, *pre &#x3D; nullptr;\n        &#x2F;&#x2F; while(p1 &amp;&amp; p1-&gt;next)&#123;\n        &#x2F;&#x2F;     p2-&gt;next &#x3D; p1-&gt;next;\n        &#x2F;&#x2F;     p2 &#x3D; p2-&gt;next;\n        &#x2F;&#x2F;     p1-&gt;next &#x3D; p2-&gt;next;\n        &#x2F;&#x2F;     pre &#x3D; p1;\n        &#x2F;&#x2F;     p1 &#x3D; p2-&gt;next;\n        &#x2F;&#x2F; &#125;\n        &#x2F;&#x2F; p2-&gt;next &#x3D; nullptr;    \n        &#x2F;&#x2F; p1 &#x3D; p1 ? p1 : pre;\n        &#x2F;&#x2F; p1-&gt;next &#x3D; evenHead-&gt;next;\n        &#x2F;&#x2F; delete evenHead;\n        &#x2F;&#x2F; return head;\n        ListNode *evenHead &#x3D; head-&gt;next, *odd &#x3D; head, *even &#x3D; head-&gt;next;\n        while(even &amp;&amp; even-&gt;next)&#123;\n            odd-&gt;next &#x3D; even-&gt;next;\n            odd &#x3D; odd-&gt;next;\n            even-&gt;next &#x3D; odd-&gt;next;\n            even &#x3D; even-&gt;next;\n        &#125;\n        odd-&gt;next &#x3D; evenHead;\n        return head;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"删除倒数第N个节点\"><a href=\"#删除倒数第N个节点\" class=\"headerlink\" title=\"删除倒数第N个节点\"></a><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\">删除倒数第N个节点</a></h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;\n        ListNode node, *pre &#x3D; &amp;node;\n        pre-&gt;next &#x3D; head;\n        ListNode *quick, *slow;\n        quick &#x3D; slow &#x3D; pre;\n        for(int i &#x3D; 0; i &lt; n; ++i) quick &#x3D; quick-&gt;next;\n        while(quick-&gt;next)&#123;\n            quick &#x3D; quick-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;\n        ListNode *fordel &#x3D; slow-&gt;next;\n        slow-&gt;next &#x3D; fordel-&gt;next;\n        if(fordel &#x3D;&#x3D; head)&#123; &#x2F;&#x2F;删除节点 务必小心：1.删了头结点，需要重置头结点 2.考虑后续节点\n            head &#x3D; fordel-&gt;next;\n        &#125;\n        delete fordel;            \n        return head; \n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","site":{"data":{}},"abbrlink":"Q9RRTJ","excerpt":"","more":"<p>所有关于链表的题目都会总结在这里。假设这些题目的链表的头结点都是带有效值的</p>\n<h2 id=\"定义链表\"><a href=\"#定义链表\" class=\"headerlink\" title=\"定义链表\"></a>定义链表</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ListNode&#123;\n    int Value;\n    ListNode* pNext;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"尾插入节点\"><a href=\"#尾插入节点\" class=\"headerlink\" title=\"尾插入节点\"></a>尾插入节点</h2><p>注意第一个参数是指针的指针，因为有可能需要修改第一个链表节点。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void AddToTail(ListNode **pHead, int value)&#123;\n    if(pHead &#x3D;&#x3D; null) return;\n\tListNode *pNew &#x3D; new ListNode();\n    pNew-&gt;Value &#x3D; value;\n    pNew-&gt;pNext &#x3D; nullptr;\n    if(*pHead &#x3D;&#x3D; null)&#123;\n        *pHead &#x3D; pNew;\n    &#125;else&#123;\n        ListNode* pNode &#x3D; *pHead;\n        while(pNode-&gt;pNext !&#x3D; null)&#123;\n            pNode &#x3D; pNode-&gt;pNext;\n        &#125;\n        *pNode-&gt;pNext &#x3D; pNew;        \n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"删除第一个对应值的链表\"><a href=\"#删除第一个对应值的链表\" class=\"headerlink\" title=\"删除第一个对应值的链表\"></a>删除第一个对应值的链表</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">viod RemoveNode(ListNode** pHead, int value)&#123;\n    if(pHead &#x3D;&#x3D; nullptr || *pHead &#x3D;&#x3D; nullptr) return;\n    ListNode *pToDeleted &#x3D; nullptr;\n    if((*pHead)-&gt;value &#x3D;&#x3D; value)&#123;\n        pToDeleted &#x3D; *pHead;\n        *pHead &#x3D; (*pHead)-&gt;pNext;\n    &#125;else&#123;\n        ListNode *pNode &#x3D; *pHead;\n        &#x2F;&#x2F;pNode指向检查节点的前一个节点\n        while((*pNode)-&gt;pNext !&#x3D; null &amp;&amp; (*pNode)-&gt;pNext-&gt;value !&#x3D; value)&#123;\n            pNode &#x3D; pNode-&gt;pNext;\n        &#125;\n        if((*pNode)-&gt;pNext !&#x3D; null &amp;&amp; (*pNode)-&gt;pNext-&gt;value &#x3D;&#x3D; value)&#123;\n\t\t\tpToDeleted &#x3D; (*pNode)-&gt;pNext;\n        &#125;\n    &#125;\n\tif(pToDeleted !&#x3D; nullptr)&#123;\n        delte pToDelted;\n        pToDelted &#x3D; nullptr; &#x2F;&#x2F;释放内存后，即使是不需要使用的指针，也要做好清除工作，不然不容易维护            \n    &#125;\n\t\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p><code>pToDeleted = *pNode-&gt;pNext;</code>上面遍历链表中代码不应该用<code>pToDeleted</code>来记录链表值，否然容易出现代码指针值意义混乱，造成不该删的指针却删掉了。</p>\n</blockquote>\n<h2 id=\"面试题6-从尾到头打印链表\"><a href=\"#面试题6-从尾到头打印链表\" class=\"headerlink\" title=\"面试题6 从尾到头打印链表\"></a>面试题6 从尾到头打印链表</h2><p>假如对空间复杂度在O(N)O(N)之上，那么可以使用栈或者递归。</p>\n<p><strong>栈代码如下</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintListReversingly_Iteratively(ListNode* pHead)&#123;\n    &#x2F;&#x2F;使用指针类型的STACK更省内存？\n    std::stack&lt;ListNode*&gt; nodes;\n    ListNode* pNode &#x3D; pHead;\n    while(pNode !&#x3D; nullptr)&#123;\n        nodes.push(pNode);\n        pNode &#x3D; pNode-&gt;pNext;\n    &#125;\n    while(!nodes.empty())&#123;\n        pNode &#x3D; nodes.top();\n        printf(&quot;%d\\n&quot;, pNode-&gt;value);\n        nodes.pop();\n    &#125;   \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>递</strong></p>\n<p><strong>归代码</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">void PrintListReversingly_Recursively(ListNode* pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return;\n    PrintListReversingly_Recursively(pHead-&gt;pNext);\n    printf(&quot;%d\\n&quot;, pHead-&gt;pNext);\n    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面试18：删除一个链表节点\"><a href=\"#面试18：删除一个链表节点\" class=\"headerlink\" title=\"面试18：删除一个链表节点\"></a>面试18：删除一个链表节点</h2><h3 id=\"题面：\"><a href=\"#题面：\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给定一个单向链表的头结点指针和一个指向待删除的节点的指针，要求用O(N)O(N)时间删除节点。</p>\n<h3 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>教科书上的链表删除都是遍历得到上一个待删除的节点的指针，时间复杂度O(N)O(N)。显然不行，也可以直接把待删除的节点<code>K</code>的下一个节点<code>J</code>的内容复制到<code>K</code>上，再删除<code>J</code>，就可以快速删除。考虑边界上，如果没有下一个节点则需要从头遍历；如果只有一个头结点且删除的是头结点，那么只能把头结点置<code>nullptr</code>。</p>\n<p>其时间复杂度为(n−1)∗O(1)+O(N)(n−1)∗O(1)+O(N)。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void DeleteNode(ListNode **pHead, ListNode *pToBeDeleted)&#123;\n    if(pHead &#x3D;&#x3D; nullptr || (*phead) &#x3D;&#x3D; nullptr || (*pToBeDeleted) &#x3D;&#x3D; nullptr ) return;\n    ListNode *pFree &#x3D; nullptr;\n    \n    if(pToBeDeleted-&gt;pNext)&#123;\n        pFree &#x3D; ToBeDeleted-&gt;pNext;\n        pToBeDeleted-&gt;value &#x3D; pToBeDeleted-&gt;pNext-&gt;value;   \n        pToBeDeleted-&gt;pNext &#x3D; pToBeDeleted-&gt;pNext-&gt;pNext;   \n        \n    &#125;\n    &#x2F;&#x2F;删除节点无后继节点，且是头结点\n    else if( *pHead &#x3D;&#x3D; pToBeDeleted)&#123;\n\t\tpFree &#x3D; *pHead;\n        *pHead &#x3D; nullptr;\n    &#125;\n    &#x2F;&#x2F; 链表中多个节点，且删除节点在末尾\n    else&#123;\n\t\tListNode *pCur &#x3D; *pHead\n        for(; pCur-&gt;pNext-&gt;pNext !&#x3D; nullptr; pCur &#x3D; pCur-&gt;pNext);\n        pFree &#x3D; pCur-&gt;pNext;\n        pCur-&gt;pNext &#x3D; nullptr;\n    &#125;\n    Delete pFree;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>错误点：</p>\n<ul>\n<li>the properiry of “*” &gt; the properity of “==”</li>\n<li>链表插入和删除后没有设置指针</li>\n</ul>\n<p>注意点：</p>\n<p>这个函数假设了待删除的节点一定在链表中；</p>\n<p>头结点可能删除掉，所以设置了头结点为指针的指针。</p>\n</blockquote>\n<h2 id=\"面18（题目二）：删除重复值的链表节点\"><a href=\"#面18（题目二）：删除重复值的链表节点\" class=\"headerlink\" title=\"面18（题目二）：删除重复值的链表节点\"></a>面18（题目二）：删除重复值的链表节点</h2><h3 id=\"题面：-1\"><a href=\"#题面：-1\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>删除一条已排序的链表中的所有的其值重复出现的节点。</p>\n<h3 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>在上面学习的基础上，连续删除就行，应该是比较简单的。</p>\n<h3 id=\"代码：-1\"><a href=\"#代码：-1\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void DeleteDuplication(ListNode **pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr || *pHead &#x3D;&#x3D; nullptr) return;\n    \n    ListNode *pCur &#x3D; *pHead, *pPre &#x3D; nullptr, *pFree &#x3D; nullptr;\n    &#x2F;&#x2F;定义一个头结点，避免不同情况的删除\n    ListNode *pKid &#x3D; new ListNode();\n    pKid-&gt;pNext &#x3D; *pHead;\n    pPre &#x3D; pKid;\n    \n    while(pCur !&#x3D; nullptr)&#123;\n\t\tint value &#x3D; pCur-&gt;value,  isDuplication &#x3D; 0;\n        &#x2F;&#x2F;删除后面的重复节点\n        while(pCur-&gt;pNext &amp;&amp; pCur-&gt;pNext-&gt;value &#x3D;&#x3D; value)&#123;\n            pFree &#x3D; pCur-&gt;pNext;\n            pCur-&gt;pNext &#x3D; pFree-&gt;pNext;\n            delete pFree;\n            isDuplication &#x3D; 1;\n        &#125;\n        \n        &#x2F;&#x2F;若重复，则删除第一个重复节点\n\t\tif(isDuplication)&#123;\n\t\t\tpFree &#x3D; pCur;\t\t\t\n\t\t\tpCur &#x3D; pCur-&gt;pNext;\t\t\t\n\t\t\tpPre-&gt;pNext &#x3D; pCur;\n            delete pFree;\n\t\t\t&#x2F;&#x2F; if(pFree) printf(&quot;@&quot;);\n        &#125;\n        &#x2F;&#x2F;不重复则下移\n        else&#123;\n            pPre &#x3D; pPre-&gt;pNext;\n            pCur &#x3D; pCur-&gt;pNext;\n        &#125;\n    &#125;\n\t*pHead &#x3D; pKid-&gt;pNext;\n    delete pKid;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a><strong>测试</strong></h2><p><a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp\">参见</a></p>\n<h2 id=\"面22：倒数第K个节点\"><a href=\"#面22：倒数第K个节点\" class=\"headerlink\" title=\"面22：倒数第K个节点\"></a>面22：倒数第K个节点</h2><h3 id=\"题面：-2\"><a href=\"#题面：-2\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个链表，返回倒数第K个节点。</p>\n<h3 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>最直观的思路是遍历到终点，反向遍历<code>K-1</code>次，但是对单链表无可奈何，而且效率不高。</p>\n<p>第二种思路可以遍历一次求链表的长度<code>L</code>，第二次遍历<code>L - K + 1</code>个节点。但是需要遍历两次链表。</p>\n<p>三种思路更秒，采用双指针，第一个指针先遍历K个节点，随后两个节点一起遍历，直到第一个指针为空，第二个指针就指向了倒数第K个节点。</p>\n<h3 id=\"代码：-2\"><a href=\"#代码：-2\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *FindKthToTail(ListNode *pHead, unsigned int K)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return nullptr;\n    ListNode *p1 &#x3D; pHead, *p2 &#x3D; pHead;\n    \n    for(int i &#x3D; 0; i &lt; K; i++)&#123;\n        if(p1 &#x3D;&#x3D; nullptr) return nullptr;\n        p1 &#x3D; p1-&gt;pNext;\n    &#125;\n    while(p1!&#x3D;nullptr)&#123;\n        p1 &#x3D; p1-&gt;pNext;\n        p2 &#x3D; p2-&gt;pNext;\n    &#125;\n    return p2;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>这代码写的比剑指offer代码写的优美多了</p>\n</blockquote>\n<h3 id=\"相关扩展：\"><a href=\"#相关扩展：\" class=\"headerlink\" title=\"相关扩展：\"></a>相关扩展：</h3><p>相关题目有找出链表的中间节点；判断一个链表是否有环；更难一点判断链表的环的入口节点！</p>\n<p><strong>其思路宗旨都是使用两个进度不一样的指针指向不同的节点来解决问题！</strong></p>\n<h2 id=\"面23：链表中的环的入口节点\"><a href=\"#面23：链表中的环的入口节点\" class=\"headerlink\" title=\"面23：链表中的环的入口节点\"></a>面23：链表中的环的入口节点</h2><h3 id=\"题面：-3\"><a href=\"#题面：-3\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个链表，求出其成环的入口节点。</p>\n<h3 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>首先得判断有环，可以使用一个快一慢的两只指针（移动速度分别为2和1）指向链表头。如果链表有环，则快慢指针就一定会相遇。</p>\n<p>那么对于有环的链表如何确定其入口节点呢？假设环的中节点有<code>K</code>个，快指针从头先遍历<code>K</code>次之后，快慢指针同时开始遍历，正好两个指针会在入口节点上汇合！</p>\n<p>如何确定环中节点呢？这个！可以直接在确定有环后，记录下该节点的位置，再继续遍历直到重新到该节点同时统计经过的节点数量即可。</p>\n<blockquote>\n<p>amazing啊</p>\n</blockquote>\n<h3 id=\"代码：-3\"><a href=\"#代码：-3\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *FindCycleNode(ListNode* pHead)&#123;\n\tif(pHead &#x3D;&#x3D; nullptr) return nullptr;\n    ListNode *pSlow, *pQuick, *pRecord &#x3D; nullptr ;\n    &#x2F;&#x2F;判断有没有环\n    pSlow &#x3D; pQuick &#x3D; pHead;\n    while(pQuick !&#x3D; nullptr)&#123;\n\t    pQuick &#x3D; pQuick-&gt;pNext;\n        if(pQuick) pQuick &#x3D; pQuick-&gt;pNext;\n        if(pSlow) pSlow &#x3D; pSlow-&gt;pNext;        \n        if(pSlow &#x3D;&#x3D; pQuick) break;\n    &#125;\n    if(pQuick &#x3D;&#x3D; nullptr) return nullptr;\n    &#x2F;&#x2F;确定环内数量\n    pRecord &#x3D; pSlow;\n    int numberOfCycle &#x3D; 0;\n    while(pRecord !&#x3D; pSlow)&#123;\n        numberOfCycle++;\n        pSlow &#x3D; pSlow-&gt;pNext;\n    &#125;\n    &#x2F;&#x2F;确定环的入口节点\n    pSlow &#x3D; pQuick &#x3D; pHead;\n    for(int i &#x3D; 0; i &lt; numberOfCycle; i++)&#123;\n        pQuick &#x3D; pQuick-&gt;pNext;\n    &#125;\n    while(pSlow !&#x3D; pQuick)&#123;\n        pQuick &#x3D; pQuick-&gt;pNext;\n        pSlow &#x3D; pSlow-&gt;pNext;                \n    &#125;\n    return pSlow;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面24：反转链表\"><a href=\"#面24：反转链表\" class=\"headerlink\" title=\"面24：反转链表\"></a>面24：反转链表</h2><h3 id=\"题面：-4\"><a href=\"#题面：-4\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>输入一个链表的头结点，反转该链表并输出反转后的链表的头结点。</p>\n<h3 id=\"思路：-4\"><a href=\"#思路：-4\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>在反转过程中，假设有三个顺序排列的待反转的链表<code>i</code>，<code>j</code>，<code>k</code>，其中<code>j</code>是待反转的链表。初始化，<code>i</code>为空指针，<code>j</code>为头节点，<code>k</code>为头结点的下一个指针指向的内容（可能为空），并把<code>i</code>的指针指空。在链表反转过程如下：<code>j</code>的指针指向<code>i</code>，然后把<code>i</code>，<code>j</code>，<code>k</code>分别按次序向后移动。重复执行上述步骤直到<code>j</code>为空。</p>\n<h3 id=\"代码：-4\"><a href=\"#代码：-4\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *ReverseList(ListNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return nullptr;\n    ListNode *p1 &#x3D; nullptr, *p2 &#x3D; pHead, *p3 &#x3D; pHead-&gt;pNext;\n    while(p2 !&#x3D; nullptr)&#123;\n        p2-&gt;pNext &#x3D; p1;\n        p1 &#x3D; p2;\n        p2 &#x3D; p3;\n        if(p3) p3 &#x3D; p3-&gt;next;        \n    &#125;\n    return p2;    \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面25：合并链表\"><a href=\"#面25：合并链表\" class=\"headerlink\" title=\"面25：合并链表\"></a>面25：合并链表</h2><h3 id=\"题面：-5\"><a href=\"#题面：-5\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>将两个链表增序合并成一条链表。</p>\n<h3 id=\"思路：-5\"><a href=\"#思路：-5\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>用两个指针指向两条链表的头结点，用合并数组的思路合并即可。注意一条链表为空后，另一条不为空的链表可以直接连上去。</p>\n<h3 id=\"代码：-5\"><a href=\"#代码：-5\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">ListNode *Merge(ListNode *pHead1, ListNode *pHead2)&#123;\n    if( pHead1 &#x3D;&#x3D; nullptr &amp;&amp; pHead2 &#x3D;&#x3D; nullptr)&#123;\n        return nullptr;\n    &#125;else if(pHead1 &#x3D;&#x3D; nullptr) return pHead2;\n    else if(pHead2 &#x3D;&#x3D; nullpr) return pHead1;\n    \n    ListNode *p1 &#x3D; pHead1, *p2 &#x3D; pHead2, *pHead3 &#x3D; new ListNode(), *p3 &#x3D; pHead3;\n    \n    while(p1 &amp;&amp; p2)&#123;\n        if(p1-&gt;value &lt;&#x3D; p2-&gt;value)&#123;\n            p3-&gt;pNext &#x3D; p1;\n            p3 &#x3D; p1;            \n            p1 &#x3D; p1-&gt;pNext;\n\n        &#125;else&#123;\n            p3-&gt;pNext &#x3D; p2;\n            p3 &#x3D; p2;\n            p2 &#x3D; p2-&gt;pNext;\n        &#125;                 \n    &#125;\n    p3-&gt;pNext &#x3D; nullptr;       \n    if(p1)&#123;\n        p3-&gt;pNext &#x3D; p1;\n    &#125;else if(p2)&#123;\n        p3-&gt;pNext &#x3D; p2;\n    &#125;\n    ListNode *pFree &#x3D; pHead3;\n    pHead3 &#x3D; pHead-&gt;pNext;\n    delete pFree;\n\treturn pHead3;        \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p><a href=\"https://github.com/Ruth-Seven/CodeInterviewWithC-/blob/master/ListTest.cpp\">参见</a></p>\n<h2 id=\"面35：复杂链表的分解\"><a href=\"#面35：复杂链表的分解\" class=\"headerlink\" title=\"面35：复杂链表的分解\"></a>面35：复杂链表的分解</h2><h3 id=\"题面：-6\"><a href=\"#题面：-6\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>给出一个有两个指针的链表数据结构，一个指针1指向下一个节点，另一个指针2可指向任意一个节点，或者为空。将给出的链表复制并返回头结点。</p>\n<h3 id=\"思路：-6\"><a href=\"#思路：-6\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>这题目还是挺不错的！属于比较复杂的题目，而且有思考空间。</p>\n<p>将复制的过程分解为两个部分，第一步先不管指针2，复制整个链表；第二步再设置指针2。第一步需要的复杂度为O(N)O(N)。第二步再复制的过程中需要确定复制链表中指针2指向的节点的的位置。</p>\n<p>第一种确定位置的思路：就是从原链表遍历寻找原指针指向的节点位置，同样的在复制链表上一起遍历。复杂度为O(N2)O(N2)。</p>\n<p>第二种确定位置的思路：直接用hash表记录下原链表中节点和复制链表中对应节点的映射关系。复杂度为O(N)O(N)。是用了空间换时间的思路。</p>\n<blockquote>\n<p>害怕碰撞。</p>\n</blockquote>\n<p>脱离上面的方案的限制，更巧妙的方法来了。链表的顺序遍历远远比随机遍历方便很多，而且指针指向的节点的位置不随链表节点而变化。可以考虑把复制节点直接插入到被复制节点的后面。全部复制完成后，由于原节点的指针2指向的节点的后一个节点就是复制节点的指针2指向的节点，所以可以直接指向。复杂度为O(N)O(N)，空间复杂度为O(1)O(1)。</p>\n<h3 id=\"代码：-6\"><a href=\"#代码：-6\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">struct ComplexListNode&#123;\n    int value;\n    ComplexListNode *pNext;\n    ComplexListNode *pSibling;    \n&#125;\n\nvoid CopyNode(ComplexListNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return null;\n    ComplexListNode *pNode &#x3D; pHead;\n    while(pNode)&#123;\n        ComplexListNode *pNew &#x3D; new ComplexListNode();\n        pNew-&gt;value &#x3D; pNode-&gt;value;\n        pNew-&gt;pNext &#x3D; pNode-&gt;pNext;\n        pNew-&gt;pSibling &#x3D; nullptr;\n        \n        pNode-&gt;pNext &#x3D; pNew;\n    \tpNode &#x3D; pNew-&gt;pNext;\n    &#125;    \n&#125;\n\nvoid SetSiblingLink(ComplexListNode * pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr )return nullptr;\n    ComplexListNode *pNode  &#x3D; pHead;\n    while(pNode)&#123;\n\t\tComplexListNode *pNext &#x3D; pNode-&gt;pNext;\n        pNext-&gt;pSibling &#x3D; pNode-&gt;pSibliing-&gt;pNext;\n        pNode &#x3D; pNext-&gt;pNext;\n    &#125;    \n&#125;\n\nComplexListNode *GetComplexList(ComplexListNode *pHead)&#123;\n    if(pHead &#x3D;&#x3D; nullptr) return nullptr;\n\tComplexListNode *pNode &#x3D; pHead;\n    ComplexListNode *pClonedHead &#x3D; pNode-&gt;pNext;\n    ComplexListNode *pClonedNode &#x3D; pNode-&gt;pNext;\n    pNode-&gt;next &#x3D; pClonedNode-&gt;next;\n    pNode &#x3D; pClneNode-&gt;next;\n    while(pNode)&#123;\n        pClonedNode-&gt;pNext &#x3D; pNode-&gt;pNext;        \n        pNode-&gt;pNext &#x3D; pNode-&gt;pNext-&gt;pNext;\n        pClonedNode &#x3D; pNode-&gt;pNext;\n        pNode &#x3D; pClonedNode-&gt;pNext;   \n        &#x2F;*\n        &#x2F;&#x2F;we can write in this way.\n        pClonedNode-&gt;pNext &#x3D; pNode-&gt;pNext;        \n        pClonedNode &#x3D; pClonedNode-&gt;pNext;\n\t\tpNode-&gt;pNext &#x3D; pClonedNode-&gt;pNext;\n        pNode &#x3D; pNode-&gt;pNext;                  \n        *&#x2F;\n    &#125;\n    return pClonedHead;      \n&#125;\nComplexListNode *Clone(ComplexListNode* pHead)&#123;\n    CopyNode(pHead);\n    SetSiblingLink(pHead);\n    return GetComplexList(pHead);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面36：把二叉搜索树转化为双向链表\"><a href=\"#面36：把二叉搜索树转化为双向链表\" class=\"headerlink\" title=\"面36：把二叉搜索树转化为双向链表\"></a>面36：把二叉搜索树转化为双向链表</h2><h3 id=\"题面：-7\"><a href=\"#题面：-7\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题，要求不创建任何新节点，只能调整树中节点的指向。输出调整后的排序链表。</p>\n<h3 id=\"思路：-7\"><a href=\"#思路：-7\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>可以从递归的角度入手。对于一个节点<code>A</code>，中序遍历到<code>A</code>，则<code>A</code>的左子树已经转化为了链表，连接好<code>A</code>和<code>A</code>的左子树的最大节点（前一个指针）的指针则连接完成。</p>\n<p>那对于<code>A</code>的右子树的最小节点<code>B</code>与<code>A</code>之间的连接，也可以看成<code>B</code>与前一个节点的指针相互链接。那么我们只需要在中序遍历的过程中改变前一个指针的内容即可。</p>\n<p>注意一下整棵树的最大的右指针和最小节点的左指针，发现都应该是空，无需额外修改。</p>\n<blockquote>\n<p>对于一个节点<code>A</code>的左右指针，分别指向按顺序排列的旁边两个节点。可以用中序遍历来获取该节点的前一个节点<code>B</code>的指针，并设置好<code>B</code>的右指针和<code>A</code>的左指针。如此就可以在中序遍历的后设置除了最后一个节点的右指针，但是右指针本来就应该是<code>NULL</code>，所以无需修改。</p>\n</blockquote>\n<h3 id=\"代码：-7\"><a href=\"#代码：-7\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">void AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead)&#123;\n    if(pRoot &#x3D;&#x3D; nullptr) return;\n  \tAdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead);\n\n    if(pHead &#x3D;&#x3D; nullptr) pHead &#x3D; pRoot;\n    pRoot-&gt;pLeft &#x3D; preNode;\n    if(preNode) preNode-&gt;pRight &#x3D; pRoot;\n    preNode &#x3D; pRoot;\n    \n    AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead);\n&#125;\nBinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot)&#123;\n    BinaryTreeNode *preNode &#x3D; nullptr;\n    BinaryTreeNode *pHead &#x3D; nullptr;\n    AdjustLinkCore(pRoot, preNode, pHead);\n    return pHead;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"面52：两个链表的第一个公共节点\"><a href=\"#面52：两个链表的第一个公共节点\" class=\"headerlink\" title=\"面52：两个链表的第一个公共节点\"></a>面52：两个链表的第一个公共节点</h2><h3 id=\"题面：-8\"><a href=\"#题面：-8\" class=\"headerlink\" title=\"题面：\"></a>题面：</h3><p>如题。</p>\n<h3 id=\"思路：-8\"><a href=\"#思路：-8\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>明显地，可以用栈来存储两个链表遍历过程。空间复杂度和时间复杂度都是O(N)O(N)。</p>\n<p>换一种想法，能不能直接遍历就使两个链表同时遍历到第一个公共节点。定义两个指针来遍历两条链表。只要让一个指向长链表的节点的指针多走多出的节点，就可以让两个节点同时同序的遍历到公共节点。时间复杂度为O(N+M)O(N+M)，空间复杂度O(1)O(1)。</p>\n<h3 id=\"代码：-8\"><a href=\"#代码：-8\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int GetLenOfList(ListNode *pHead)&#123;\n    int len &#x3D; 0;\n    ListNode *pNode &#x3D; pHead;\n    while(pNode)&#123;\n        pNode &#x3D; pNode-&gt;pNext;\n        len++;\n    &#125;\n    return len;\n&#125;\nListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2)&#123;\n    if(pHead1 &#x3D;&#x3D; nullptr || pHead2 &#x3D;&#x3D; nullptr) return nullptr;\n    int len1 &#x3D; GetLenOfList(pHead1);\n    int len2 &#x3D; GetLenOfList(pHead2);\n    if(len1 &lt; len2)&#123;\n        swap(pHead1, pHead2);\n        swap(len1, len2);\n    &#125;\n    int step &#x3D; len1 - len2;\n\tListNode *pNode1 &#x3D; pHead1;\n    ListNode *pNode2 &#x3D; pHead2;\n    while(step)&#123;\n        pNode1 &#x3D; pNode-&gt;pNext;\n        step--;\n    &#125;\n    while(pNode1 !&#x3D; pNode2)&#123;\n        pNode1 &#x3D; pNode1-&gt;pNext;\n        pNode2 &#x3D; pNode1-&gt;pNext;\n    &#125;\n    &#x2F;&#x2F;two pNodes maybe refer to null or the first common node.\n    return pNode1;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/\">更简单的解法：</a> </p>\n<p>双指针遍历两条链表，遍历到结尾则跳到另一条链表上。路径长度的相等一定会有两个指针相遇。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        ListNode *p1 &#x3D; headA,  *p2 &#x3D; headB;\n        while(p1 !&#x3D; p2)&#123;\n            p1 &#x3D; p1 &#x3D;&#x3D; nullptr ? headB : p1-&gt;next;\n            p2 &#x3D; p2 &#x3D;&#x3D; nullptr ? headA : p2-&gt;next;\n        &#125;\n        return p1;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h2 id=\"链表回文判断\"><a href=\"#链表回文判断\" class=\"headerlink\" title=\"链表回文判断\"></a><a href=\"\">链表回文判断</a></h2><p><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">234. Palindrome Linked List</a></p>\n<p><code>O(n)</code>时间，<code>O(1)</code>空间</p>\n<h3 id=\"思路：-9\"><a href=\"#思路：-9\" class=\"headerlink\" title=\"思路：\"></a>思路：</h3><p>朴素的思路：先用快慢指针找到链表中间节点，之后翻转后半部分链表。判断两个链表是否相同。</p>\n<p>其中奇数个节点链表需要考虑一下。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    bool isPalindrome(ListNode* head) &#123;\n        ListNode *slow ,*quick;\n        slow &#x3D; quick &#x3D; head;\n        while(quick &amp;&amp; quick-&gt;next)&#123;\n            slow &#x3D; slow-&gt;next;\n            quick &#x3D; quick-&gt;next-&gt;next;\n        &#125;\n        ListNode *p2 &#x3D; reverseList(slow), *p1 &#x3D; head;\n        while(p1 &amp;&amp; p2)&#123;\n            if(p1-&gt;val !&#x3D; p2-&gt;val) return false;\n            p1 &#x3D; p1-&gt;next;\n            p2 &#x3D; p2-&gt;next;\n        &#125;\n        return true;\n        \n    &#125;\n\n    ListNode *reverseList(ListNode* head)&#123;\n        if(head &#x3D;&#x3D; nullptr) return head;\n        ListNode *per &#x3D; nullptr, *cur &#x3D; head, *next &#x3D; head-&gt;next;\n        while(cur)&#123;\n            cur-&gt;next &#x3D; per;\n            per &#x3D; cur;\n            cur &#x3D; next;\n            if(next) next &#x3D; next-&gt;next;\n        &#125;\n        return per;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"奇偶链表节点分解\"><a href=\"#奇偶链表节点分解\" class=\"headerlink\" title=\"奇偶链表节点分解\"></a><a href=\"https://leetcode-cn.com/problems/odd-even-linked-list/\">奇偶链表节点分解</a></h2><p>非常容易写复杂的题目。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* oddEvenList(ListNode* head) &#123;\n        if(!(head &amp;&amp; head-&gt;next)) return head;\n        &#x2F;&#x2F; ListNode *p1 &#x3D; head, *p2 &#x3D; new ListNode(), *evenHead &#x3D; p2, *pre &#x3D; nullptr;\n        &#x2F;&#x2F; while(p1 &amp;&amp; p1-&gt;next)&#123;\n        &#x2F;&#x2F;     p2-&gt;next &#x3D; p1-&gt;next;\n        &#x2F;&#x2F;     p2 &#x3D; p2-&gt;next;\n        &#x2F;&#x2F;     p1-&gt;next &#x3D; p2-&gt;next;\n        &#x2F;&#x2F;     pre &#x3D; p1;\n        &#x2F;&#x2F;     p1 &#x3D; p2-&gt;next;\n        &#x2F;&#x2F; &#125;\n        &#x2F;&#x2F; p2-&gt;next &#x3D; nullptr;    \n        &#x2F;&#x2F; p1 &#x3D; p1 ? p1 : pre;\n        &#x2F;&#x2F; p1-&gt;next &#x3D; evenHead-&gt;next;\n        &#x2F;&#x2F; delete evenHead;\n        &#x2F;&#x2F; return head;\n        ListNode *evenHead &#x3D; head-&gt;next, *odd &#x3D; head, *even &#x3D; head-&gt;next;\n        while(even &amp;&amp; even-&gt;next)&#123;\n            odd-&gt;next &#x3D; even-&gt;next;\n            odd &#x3D; odd-&gt;next;\n            even-&gt;next &#x3D; odd-&gt;next;\n            even &#x3D; even-&gt;next;\n        &#125;\n        odd-&gt;next &#x3D; evenHead;\n        return head;\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"删除倒数第N个节点\"><a href=\"#删除倒数第N个节点\" class=\"headerlink\" title=\"删除倒数第N个节点\"></a><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\">删除倒数第N个节点</a></h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n *&#x2F;\nclass Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;\n        ListNode node, *pre &#x3D; &amp;node;\n        pre-&gt;next &#x3D; head;\n        ListNode *quick, *slow;\n        quick &#x3D; slow &#x3D; pre;\n        for(int i &#x3D; 0; i &lt; n; ++i) quick &#x3D; quick-&gt;next;\n        while(quick-&gt;next)&#123;\n            quick &#x3D; quick-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;\n        ListNode *fordel &#x3D; slow-&gt;next;\n        slow-&gt;next &#x3D; fordel-&gt;next;\n        if(fordel &#x3D;&#x3D; head)&#123; &#x2F;&#x2F;删除节点 务必小心：1.删了头结点，需要重置头结点 2.考虑后续节点\n            head &#x3D; fordel-&gt;next;\n        &#125;\n        delete fordel;            \n        return head; \n\n    &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckoq26j270000l5uoau4van64","category_id":"ckoq26jd0005xl5uo8uoa3o2a","_id":"ckoq26jmc0060l5uoecu6fdre"},{"post_id":"ckoq26j2d0001l5uo7fel1ifl","category_id":"ckoq26jd0005xl5uo8uoa3o2a","_id":"ckoq26jmi0061l5uobx796qhn"},{"post_id":"ckoq26j2e0002l5uod2ox9wvm","category_id":"ckoq26jmb005zl5uo41hegxyq","_id":"ckoq26jr800byl5uo0m8m2nva"},{"post_id":"ckoq26j2e0002l5uod2ox9wvm","category_id":"ckoq26jr600bwl5uo8wi07l4f","_id":"ckoq26jr800c0l5uo91ak419n"},{"post_id":"ckoq26j2g0003l5uo0dfz5hxy","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jr900c2l5uoecji8jjt"},{"post_id":"ckoq26j2g0003l5uo0dfz5hxy","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jr900c3l5uo7dxo6xpr"},{"post_id":"ckoq26j2h0004l5uo0b979zil","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jra00c5l5uo3gnj0a5a"},{"post_id":"ckoq26j2h0004l5uo0b979zil","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrb00c6l5uoatl5eop3"},{"post_id":"ckoq26j2i0005l5uog4lyf6lp","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrf00c8l5uo09fa2p4g"},{"post_id":"ckoq26j2i0005l5uog4lyf6lp","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrg00c9l5uo35xibk4x"},{"post_id":"ckoq26j2j0006l5uocksufq4c","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrh00cbl5uo0bu82o0v"},{"post_id":"ckoq26j2j0006l5uocksufq4c","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrh00ccl5uo6xucdtcp"},{"post_id":"ckoq26j2k0007l5uobeqjd16i","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jri00cel5uoadn42xb1"},{"post_id":"ckoq26j2k0007l5uobeqjd16i","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jri00cfl5uoadofgx8c"},{"post_id":"ckoq26j2l0008l5uoh4rw9tck","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jri00chl5uo4pl45f06"},{"post_id":"ckoq26j2l0008l5uoh4rw9tck","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrj00cil5uodemidvxk"},{"post_id":"ckoq26j2n0009l5uo5vv69u29","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrj00ckl5uo4f2a0114"},{"post_id":"ckoq26j2n0009l5uo5vv69u29","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrk00cll5uo2n1p7r0z"},{"post_id":"ckoq26j2o000al5uo0yh2gma7","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrl00cnl5uo9e484czm"},{"post_id":"ckoq26j2o000al5uo0yh2gma7","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrm00col5uoag69hoyx"},{"post_id":"ckoq26j2q000bl5uo11nb5yiu","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrn00cql5uo0a177lb5"},{"post_id":"ckoq26j2q000bl5uo11nb5yiu","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrn00crl5uo9ucl21u6"},{"post_id":"ckoq26j2r000cl5uo60j36ge1","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jro00ctl5uo3h1kh9c8"},{"post_id":"ckoq26j2r000cl5uo60j36ge1","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrp00cul5uofb6qfcc5"},{"post_id":"ckoq26j2x000dl5uo39848qqe","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrq00cwl5uo0ltcad24"},{"post_id":"ckoq26j2x000dl5uo39848qqe","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrr00cxl5uo3faxa5sy"},{"post_id":"ckoq26j2z000el5uo44qx6ywa","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jru00czl5uo9svs1sqt"},{"post_id":"ckoq26j2z000el5uo44qx6ywa","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrv00d0l5uo7x5h8v6i"},{"post_id":"ckoq26j30000fl5uo3dqfd63x","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrw00d2l5uoegcxe6x0"},{"post_id":"ckoq26j30000fl5uo3dqfd63x","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrx00d3l5uofqkn9jik"},{"post_id":"ckoq26j31000gl5uohfna98sv","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jrx00d5l5uoea063jwr"},{"post_id":"ckoq26j31000gl5uohfna98sv","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jry00d6l5uofggr7z8l"},{"post_id":"ckoq26j32000hl5uo99xehp4b","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jry00d8l5uo0wpv0rdv"},{"post_id":"ckoq26j32000hl5uo99xehp4b","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jrz00d9l5uo9m97b7cb"},{"post_id":"ckoq26j33000il5uo07an2zza","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js000dbl5uo5wul9rl0"},{"post_id":"ckoq26j33000il5uo07an2zza","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js000dcl5uo4psh8ggs"},{"post_id":"ckoq26j33000jl5uo373thcht","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js100del5uo5d5g10v7"},{"post_id":"ckoq26j33000jl5uo373thcht","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js200dfl5uo6m5j2xdk"},{"post_id":"ckoq26j34000kl5uo3mdlczr1","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js200dhl5uoa7l0c59i"},{"post_id":"ckoq26j34000kl5uo3mdlczr1","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js200dil5uobwogffsv"},{"post_id":"ckoq26j35000ll5uobgczd39e","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js300dkl5uob8xs27ta"},{"post_id":"ckoq26j35000ll5uobgczd39e","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js300dll5uo2zsrfpxx"},{"post_id":"ckoq26j36000ml5uodnlo0n6d","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js300dnl5uo4e60f1ao"},{"post_id":"ckoq26j36000ml5uodnlo0n6d","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js400dol5uofhdibjn6"},{"post_id":"ckoq26j39000nl5uo3e4l78c1","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js400dql5uo7eep7s5b"},{"post_id":"ckoq26j39000nl5uo3e4l78c1","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js500drl5uocxmqfbbe"},{"post_id":"ckoq26j3a000ol5uo2ppf9pdr","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js500dtl5uoced16pha"},{"post_id":"ckoq26j3a000ol5uo2ppf9pdr","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js500dul5uo7thsfw5m"},{"post_id":"ckoq26j3b000pl5uo8b45f38f","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js600dwl5uod3ryhwrc"},{"post_id":"ckoq26j3b000pl5uo8b45f38f","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js600dxl5uo424scihi"},{"post_id":"ckoq26j3c000ql5uodj59gfp2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26js700dzl5uo5s0g34y8"},{"post_id":"ckoq26j3c000ql5uodj59gfp2","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26js900e0l5uogzx02wqm"},{"post_id":"ckoq26j3d000rl5uocs2qg76x","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsa00e2l5uo0zcahyzl"},{"post_id":"ckoq26j3d000rl5uocs2qg76x","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsb00e3l5uof1z3blsl"},{"post_id":"ckoq26j3e000sl5uo282s4esi","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsb00e5l5uo2gn8aj8n"},{"post_id":"ckoq26j3e000sl5uo282s4esi","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsd00e6l5uo77j3a2hm"},{"post_id":"ckoq26j3f000tl5uo8e552zzw","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsd00e8l5uo3z0vafda"},{"post_id":"ckoq26j3f000tl5uo8e552zzw","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jse00e9l5uocmhr6rdr"},{"post_id":"ckoq26j3g000ul5uo08zffgfh","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsf00ebl5uoafyr8vz3"},{"post_id":"ckoq26j3g000ul5uo08zffgfh","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsg00ecl5uo6q90a7l5"},{"post_id":"ckoq26j3h000vl5uo83lygzcx","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsh00eel5uoalj640qq"},{"post_id":"ckoq26j3h000vl5uo83lygzcx","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsi00efl5uo1buae7v5"},{"post_id":"ckoq26j3i000wl5uo4s1law8c","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsj00ehl5uo38ys5g5t"},{"post_id":"ckoq26j3i000wl5uo4s1law8c","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsk00eil5uodr5b0lln"},{"post_id":"ckoq26j3j000xl5uo94w57x2v","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsk00ekl5uog80v0j00"},{"post_id":"ckoq26j3j000xl5uo94w57x2v","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsl00ell5uo2313b5s7"},{"post_id":"ckoq26j3k000yl5uobkfb5drb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsl00enl5uoc54gdc5m"},{"post_id":"ckoq26j3k000yl5uobkfb5drb","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsm00eol5uo1ikxecdx"},{"post_id":"ckoq26j3l000zl5uo855bbsi2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsm00eql5uo4u6zh2lk"},{"post_id":"ckoq26j3l000zl5uo855bbsi2","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsn00erl5uoacf9gg4n"},{"post_id":"ckoq26j3m0010l5uof5plhgim","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsn00etl5uo005c9l0h"},{"post_id":"ckoq26j3m0010l5uof5plhgim","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsn00eul5uods3yd9wi"},{"post_id":"ckoq26j3m0011l5uocm04fnna","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jso00ewl5uo6slk69sc"},{"post_id":"ckoq26j3m0011l5uocm04fnna","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jso00exl5uoamb7bxo2"},{"post_id":"ckoq26j3n0012l5uoh52ihpo8","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsp00ezl5uo2gpz8njd"},{"post_id":"ckoq26j3n0012l5uoh52ihpo8","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsp00f0l5uo4uitam5q"},{"post_id":"ckoq26j3o0013l5uo680g6oh2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsq00f2l5uo15332syq"},{"post_id":"ckoq26j3o0013l5uo680g6oh2","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsq00f3l5uoep4kgnya"},{"post_id":"ckoq26j3p0014l5uoartp1rfq","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsr00f5l5uo3vw7g1ze"},{"post_id":"ckoq26j3p0014l5uoartp1rfq","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jsr00f6l5uoc493g78y"},{"post_id":"ckoq26j3q0015l5uodocibff4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jss00f7l5uo41tc2a91"},{"post_id":"ckoq26j3q0015l5uodocibff4","category_id":"ckoq26jr700bxl5uocsgdbzn4","_id":"ckoq26jst00f9l5uofmwrhcex"},{"post_id":"ckoq26j3q0016l5uo1lwe3229","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsu00fbl5uo98cybnnk"},{"post_id":"ckoq26j3q0016l5uo1lwe3229","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jsv00fcl5uo1pbt0abi"},{"post_id":"ckoq26j3s0017l5uo8dz03eac","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsv00fel5uodfp7a6rw"},{"post_id":"ckoq26j3s0017l5uo8dz03eac","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jsw00ffl5uo9zox8sop"},{"post_id":"ckoq26j3t0018l5uo57is14aj","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsx00fhl5uo8umbdk8a"},{"post_id":"ckoq26j3t0018l5uo57is14aj","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jsx00fil5uo9o2afgwf"},{"post_id":"ckoq26j3u0019l5uo3n8obza2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsy00fkl5uofeuuedd2"},{"post_id":"ckoq26j3u0019l5uo3n8obza2","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jsy00fll5uohlz4aex1"},{"post_id":"ckoq26j3x001al5uoabqe8nnh","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jsz00fnl5uoe00ca6y0"},{"post_id":"ckoq26j3x001al5uoabqe8nnh","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt000fol5uoduaable4"},{"post_id":"ckoq26j3y001bl5uog5q7exee","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt000fql5uofhm73sks"},{"post_id":"ckoq26j3y001bl5uog5q7exee","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt100frl5uo7sx399hq"},{"post_id":"ckoq26j3z001cl5uobie7fzog","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt100ftl5uo4djo4czm"},{"post_id":"ckoq26j3z001cl5uobie7fzog","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt200ful5uoa1w78bba"},{"post_id":"ckoq26j40001dl5uo09af94hb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt200fwl5uo6ocp63ao"},{"post_id":"ckoq26j40001dl5uo09af94hb","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt300fxl5uoceod28qo"},{"post_id":"ckoq26j40001el5uo23oggehd","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt300fzl5uofjandxvq"},{"post_id":"ckoq26j40001el5uo23oggehd","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt400g0l5uo4tei4f7v"},{"post_id":"ckoq26j41001fl5uo24ri8cza","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt400g2l5uo5tqch0h3"},{"post_id":"ckoq26j41001fl5uo24ri8cza","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt400g3l5uofl641cni"},{"post_id":"ckoq26j42001gl5uodtj70lx8","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt500g5l5uo8nqlb4ih"},{"post_id":"ckoq26j42001gl5uodtj70lx8","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt500g6l5uo68mhgqio"},{"post_id":"ckoq26j43001hl5uo4kjvfngo","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt500g7l5uob31d150m"},{"post_id":"ckoq26j43001hl5uo4kjvfngo","category_id":"ckoq26jsq00f4l5uo57izhj9g","_id":"ckoq26jt600g9l5uo22w18e0r"},{"post_id":"ckoq26j44001il5uob8lteanj","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt600gbl5uo2d5a8axx"},{"post_id":"ckoq26j44001il5uob8lteanj","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jt700gcl5uo1yn85r98"},{"post_id":"ckoq26j46001jl5uofccqdizt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt700gel5uo4ntkhaw9"},{"post_id":"ckoq26j46001jl5uofccqdizt","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jt800gfl5uo6rh0c9yc"},{"post_id":"ckoq26j48001kl5uo8biz8hkn","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt800ghl5uobkn1csh2"},{"post_id":"ckoq26j48001kl5uo8biz8hkn","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jt900gil5uo2oxw0thx"},{"post_id":"ckoq26j49001ll5uobo1l44vx","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jt900gkl5uo1s6zcosh"},{"post_id":"ckoq26j49001ll5uobo1l44vx","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jta00gll5uo9z71gpgv"},{"post_id":"ckoq26j4a001ml5uo1oxb6p9s","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jta00gnl5uocnasg3xl"},{"post_id":"ckoq26j4a001ml5uo1oxb6p9s","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtb00gol5uo5e1cfuno"},{"post_id":"ckoq26j4b001nl5uoa0fse7qg","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtb00gql5uobqptbb71"},{"post_id":"ckoq26j4b001nl5uoa0fse7qg","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtb00grl5uo4w775qgb"},{"post_id":"ckoq26j4b001ol5uo910l5hv4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtc00gtl5uofsvv9rrw"},{"post_id":"ckoq26j4b001ol5uo910l5hv4","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtc00gul5uo8fh8c83k"},{"post_id":"ckoq26j4c001pl5uoa4cc3ffz","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtd00gwl5uo7o971mcv"},{"post_id":"ckoq26j4c001pl5uoa4cc3ffz","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtd00gxl5uobyqx0yjx"},{"post_id":"ckoq26j4d001ql5uo84t040et","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jte00gzl5uo1are367k"},{"post_id":"ckoq26j4d001ql5uo84t040et","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jte00h0l5uo7v0kd49j"},{"post_id":"ckoq26j4f001rl5uocd6jhiy6","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jte00h2l5uohr8o8cvj"},{"post_id":"ckoq26j4f001rl5uocd6jhiy6","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtf00h3l5uo9taofbrm"},{"post_id":"ckoq26j4g001sl5uocnp6d9ro","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtg00h5l5uo75vkheqa"},{"post_id":"ckoq26j4g001sl5uocnp6d9ro","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtg00h6l5uo7kdu4i3m"},{"post_id":"ckoq26j4h001tl5uobdd76mxe","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jti00h8l5uo3lnd1tcg"},{"post_id":"ckoq26j4h001tl5uobdd76mxe","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtj00h9l5uo07dhaz5q"},{"post_id":"ckoq26j4h001ul5uo6udddq4z","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtj00hbl5uo2wn064ac"},{"post_id":"ckoq26j4h001ul5uo6udddq4z","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtk00hcl5uoem14ezce"},{"post_id":"ckoq26j4i001vl5uo437cc22o","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtk00hel5uod01e01he"},{"post_id":"ckoq26j4i001vl5uo437cc22o","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtk00hfl5uocgigbm2k"},{"post_id":"ckoq26j4j001wl5uoh5v9dqb6","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtl00hhl5uodg5ocirh"},{"post_id":"ckoq26j4j001wl5uoh5v9dqb6","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtl00hil5uogr2cac7j"},{"post_id":"ckoq26j4j001xl5uobac08rd1","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtm00hkl5uo3nidb38f"},{"post_id":"ckoq26j4j001xl5uobac08rd1","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtq00hll5uockpn5cn0"},{"post_id":"ckoq26j4k001yl5uo750mfzle","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtr00hnl5uo1zldaya4"},{"post_id":"ckoq26j4k001yl5uo750mfzle","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jts00hol5uo53pafz2t"},{"post_id":"ckoq26j4l001zl5uobz469rzt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jts00hql5uo8wrvcdkb"},{"post_id":"ckoq26j4l001zl5uobz469rzt","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtt00hrl5uo2s5s2mh8"},{"post_id":"ckoq26j4m0020l5uo8ks3f8ht","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtt00htl5uoewfrcr62"},{"post_id":"ckoq26j4m0020l5uo8ks3f8ht","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtu00hul5uogbirgj2q"},{"post_id":"ckoq26j4n0021l5uoejkg1shg","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtu00hwl5uo42ua0cn0"},{"post_id":"ckoq26j4n0021l5uoejkg1shg","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtv00hxl5uo5zty2siv"},{"post_id":"ckoq26j4p0022l5uohy0kauaw","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtv00hzl5uo4ml90g3q"},{"post_id":"ckoq26j4p0022l5uohy0kauaw","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtw00i0l5uo6ky61xyh"},{"post_id":"ckoq26j4r0023l5uocukufkhb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtw00i2l5uo8e2ecsbj"},{"post_id":"ckoq26j4r0023l5uocukufkhb","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtx00i3l5uobwxicp1g"},{"post_id":"ckoq26j4s0024l5uo516k4qyy","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jty00i5l5uoax9h8k5o"},{"post_id":"ckoq26j4s0024l5uo516k4qyy","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jtz00i6l5uo9iq6ds0f"},{"post_id":"ckoq26j4t0025l5uoa4jz4n9l","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jtz00i8l5uo3lvkclbe"},{"post_id":"ckoq26j4t0025l5uoa4jz4n9l","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju000i9l5uo1tuz62cc"},{"post_id":"ckoq26j4u0026l5uo28z384jw","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju000ibl5uoh6dz4l52"},{"post_id":"ckoq26j4u0026l5uo28z384jw","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju100icl5uo93xch1cu"},{"post_id":"ckoq26j4v0027l5uohar8byxt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju100iel5uo9s6k3au8"},{"post_id":"ckoq26j4v0027l5uohar8byxt","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju200ifl5uohjychswj"},{"post_id":"ckoq26j4w0028l5uo13361nb4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju200ihl5uobny5cr4m"},{"post_id":"ckoq26j4w0028l5uo13361nb4","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju300iil5uocm4j6pap"},{"post_id":"ckoq26j4w0029l5uo7nrhda3t","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju300ikl5uocp828jwu"},{"post_id":"ckoq26j4w0029l5uo7nrhda3t","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju300ill5uo0kmk3i8d"},{"post_id":"ckoq26j4x002al5uocge17mjg","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju400inl5uo7vsh4y8z"},{"post_id":"ckoq26j4x002al5uocge17mjg","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju400iol5uobfpg17hs"},{"post_id":"ckoq26j4x002bl5uo9jqoa3ij","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju500iql5uo3cbhftfm"},{"post_id":"ckoq26j4x002bl5uo9jqoa3ij","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju500irl5uo89sr4u8o"},{"post_id":"ckoq26j4y002cl5uoh7te2fq0","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju600itl5uo2od8gb89"},{"post_id":"ckoq26j4y002cl5uoh7te2fq0","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju600iul5uoell14zsa"},{"post_id":"ckoq26j4z002dl5uo2d3bgcz2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju600ivl5uodm2879vr"},{"post_id":"ckoq26j4z002dl5uo2d3bgcz2","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26ju700ixl5uo2weocb3e"},{"post_id":"ckoq26j4z002el5uofldef59r","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju700izl5uo59pj11j5"},{"post_id":"ckoq26j4z002el5uofldef59r","category_id":"ckoq26ju500isl5uobjr014mz","_id":"ckoq26ju700j0l5uo55e9a4fy"},{"post_id":"ckoq26j50002fl5uoeg9aeni4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju700j1l5uo732j083y"},{"post_id":"ckoq26j50002fl5uoeg9aeni4","category_id":"ckoq26ju500isl5uobjr014mz","_id":"ckoq26ju800j3l5uo0amm78br"},{"post_id":"ckoq26j51002gl5uo14e2ftp5","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju800j5l5uoafquf9wz"},{"post_id":"ckoq26j51002gl5uo14e2ftp5","category_id":"ckoq26ju700iyl5uo4vsda2cz","_id":"ckoq26ju900j6l5uodb2jgq8t"},{"post_id":"ckoq26j52002hl5uo1ljqfxqs","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26ju900j8l5uob2nc0h6x"},{"post_id":"ckoq26j52002hl5uo1ljqfxqs","category_id":"ckoq26ju700iyl5uo4vsda2cz","_id":"ckoq26jua00j9l5uo78ua227r"},{"post_id":"ckoq26j53002il5uo05rx1uaa","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jub00jbl5uo3rg60k9s"},{"post_id":"ckoq26j53002il5uo05rx1uaa","category_id":"ckoq26ju700iyl5uo4vsda2cz","_id":"ckoq26juc00jcl5uofv3mhbtl"},{"post_id":"ckoq26j53002jl5uo175b2keg","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juf00jel5uo7wri9064"},{"post_id":"ckoq26j53002jl5uo175b2keg","category_id":"ckoq26ju700iyl5uo4vsda2cz","_id":"ckoq26juf00jfl5uo46fa6son"},{"post_id":"ckoq26j54002kl5uoh5cy5awk","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jug00jhl5uo7a9oe42r"},{"post_id":"ckoq26j54002kl5uoh5cy5awk","category_id":"ckoq26ju700iyl5uo4vsda2cz","_id":"ckoq26jui00jil5uo2tqpem13"},{"post_id":"ckoq26j55002ll5uo8wu62jvf","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juj00jkl5uo7uzv1pw4"},{"post_id":"ckoq26j55002ll5uo8wu62jvf","category_id":"ckoq26ju700iyl5uo4vsda2cz","_id":"ckoq26juj00jll5uo5poc3jyg"},{"post_id":"ckoq26j55002ml5uogwy005um","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juj00jml5uod18y8tp4"},{"post_id":"ckoq26j55002ml5uogwy005um","category_id":"ckoq26ju700iyl5uo4vsda2cz","_id":"ckoq26juk00jol5uo1zcgg0lv"},{"post_id":"ckoq26j56002nl5uo6y8n3nmm","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juk00jql5uohz6nem9q"},{"post_id":"ckoq26j56002nl5uo6y8n3nmm","category_id":"ckoq26jui00jjl5uogys09aaz","_id":"ckoq26jul00jrl5uoczho2efz"},{"post_id":"ckoq26j56002ol5uo5zaoec8n","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jun00jtl5uoclu73n09"},{"post_id":"ckoq26j56002ol5uo5zaoec8n","category_id":"ckoq26jui00jjl5uogys09aaz","_id":"ckoq26juo00jul5uodv7a31wl"},{"post_id":"ckoq26j57002pl5uogwxlehp8","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juo00jwl5uoauzl4nes"},{"post_id":"ckoq26j57002pl5uogwxlehp8","category_id":"ckoq26jui00jjl5uogys09aaz","_id":"ckoq26jup00jxl5uo5kts4m6s"},{"post_id":"ckoq26j58002ql5uobziz9avc","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jup00jzl5uoh5lg4b23"},{"post_id":"ckoq26j58002ql5uobziz9avc","category_id":"ckoq26jui00jjl5uogys09aaz","_id":"ckoq26jup00k0l5uo31c974vt"},{"post_id":"ckoq26j58002rl5uo9yrycara","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juq00k1l5uoeeslcvkj"},{"post_id":"ckoq26j58002rl5uo9yrycara","category_id":"ckoq26jui00jjl5uogys09aaz","_id":"ckoq26jur00k3l5uob94u84g2"},{"post_id":"ckoq26j59002sl5uo4fpv4lq2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jus00k5l5uobtecdysu"},{"post_id":"ckoq26j59002sl5uo4fpv4lq2","category_id":"ckoq26jup00jyl5uo904l3hpu","_id":"ckoq26jut00k6l5uo8ngvegup"},{"post_id":"ckoq26j5a002tl5uo2v0d3ns7","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jut00k8l5uo0goq6taf"},{"post_id":"ckoq26j5a002tl5uo2v0d3ns7","category_id":"ckoq26jup00jyl5uo904l3hpu","_id":"ckoq26jut00k9l5uohffhgl9o"},{"post_id":"ckoq26j5a002ul5uoenh6bazg","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juu00kal5uobdqg2903"},{"post_id":"ckoq26j5a002ul5uoenh6bazg","category_id":"ckoq26jup00jyl5uo904l3hpu","_id":"ckoq26juu00kcl5uoazan3ml6"},{"post_id":"ckoq26j5b002vl5uo00itfiki","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juv00kel5uo3xqpbiy5"},{"post_id":"ckoq26j5b002vl5uo00itfiki","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26juw00kfl5uobi56cjqi"},{"post_id":"ckoq26j5c002wl5uoas9ab7g2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juw00khl5uo4ybo82vh"},{"post_id":"ckoq26j5c002wl5uoas9ab7g2","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jux00kil5uof6fzcfi1"},{"post_id":"ckoq26j5c002xl5uo8vx42j6i","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jux00kkl5uo3w847mor"},{"post_id":"ckoq26j5c002xl5uo8vx42j6i","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26juy00kll5uoaj9cc2zy"},{"post_id":"ckoq26j5d002yl5uohklebbmb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juy00knl5uo5nfjej8y"},{"post_id":"ckoq26j5d002yl5uohklebbmb","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26juz00kol5uocjd7enu5"},{"post_id":"ckoq26j5d002zl5uo3bfeg4xw","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26juz00kql5uoh3ascrly"},{"post_id":"ckoq26j5d002zl5uo3bfeg4xw","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv000krl5uo6a8e3kb9"},{"post_id":"ckoq26j5e0030l5uo0mv09kjj","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv000ktl5uo4yw4b6r0"},{"post_id":"ckoq26j5e0030l5uo0mv09kjj","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv000kul5uo42tc7c2q"},{"post_id":"ckoq26j5f0031l5uofk3j34k2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv100kwl5uo8r4l3qo1"},{"post_id":"ckoq26j5f0031l5uofk3j34k2","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv200kxl5uog9td0lem"},{"post_id":"ckoq26j5f0032l5uo7y0wcwl3","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv200kzl5uo4xrohcb8"},{"post_id":"ckoq26j5f0032l5uo7y0wcwl3","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv200l0l5uockb28rzb"},{"post_id":"ckoq26j5g0033l5uockdzfjeu","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv300l2l5uog6ck76vt"},{"post_id":"ckoq26j5g0033l5uockdzfjeu","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv300l3l5uo8ww197f0"},{"post_id":"ckoq26j5h0034l5uobo89fe3d","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv400l5l5uo0zk7950e"},{"post_id":"ckoq26j5h0034l5uobo89fe3d","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv400l6l5uo2nc770v3"},{"post_id":"ckoq26j5h0035l5uo5h3b7isu","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv400l8l5uoh5hm7ua1"},{"post_id":"ckoq26j5h0035l5uo5h3b7isu","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv500l9l5uo37zfb49b"},{"post_id":"ckoq26j5i0036l5uodbh9hj3j","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv500lbl5uo5cc13t4j"},{"post_id":"ckoq26j5i0036l5uodbh9hj3j","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv600lcl5uo73tccwwu"},{"post_id":"ckoq26j5j0037l5uo7jba9xmb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv600lel5uo2dcif4go"},{"post_id":"ckoq26j5j0037l5uo7jba9xmb","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv700lfl5uo0brz31vp"},{"post_id":"ckoq26j5k0038l5uodjhw8joj","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv700lhl5uoe99sh2nr"},{"post_id":"ckoq26j5k0038l5uodjhw8joj","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv800lil5uo38dt1bi3"},{"post_id":"ckoq26j5k0039l5uodix7evso","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv800lkl5uo2lsbh8us"},{"post_id":"ckoq26j5k0039l5uodix7evso","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jv900lll5uo02rl17pw"},{"post_id":"ckoq26j5l003al5uoe4dt82m4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jv900lnl5uohbkn4h6q"},{"post_id":"ckoq26j5l003al5uoe4dt82m4","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jva00lol5uodph44zrq"},{"post_id":"ckoq26j5m003bl5uo32447jhd","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jva00lql5uogb4obav5"},{"post_id":"ckoq26j5m003bl5uo32447jhd","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jva00lrl5uo94btgzda"},{"post_id":"ckoq26j5m003cl5uog8mhgt9y","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvb00ltl5uoa03z4rg2"},{"post_id":"ckoq26j5m003cl5uog8mhgt9y","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jvb00lul5uodokv6h9g"},{"post_id":"ckoq26j5n003dl5uo1i1v0ovt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvc00lwl5uo9ell49qh"},{"post_id":"ckoq26j5n003dl5uo1i1v0ovt","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jvc00lxl5uoebx8eki2"},{"post_id":"ckoq26j5n003el5uo773ug7mr","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvd00lzl5uohgo5hctj"},{"post_id":"ckoq26j5n003el5uo773ug7mr","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jvd00m0l5uo4cw62d5c"},{"post_id":"ckoq26j5o003fl5uobxmba9zt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvd00m2l5uo5yk91dvd"},{"post_id":"ckoq26j5o003fl5uobxmba9zt","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jve00m3l5uo0odr1ifg"},{"post_id":"ckoq26j5p003gl5uofq9qcr1o","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvf00m5l5uogozc1fjt"},{"post_id":"ckoq26j5p003gl5uofq9qcr1o","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jvf00m6l5uo2cwxazma"},{"post_id":"ckoq26j5p003hl5uoc30e7kc2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvf00m7l5uo3koz0izh"},{"post_id":"ckoq26j5p003hl5uoc30e7kc2","category_id":"ckoq26jut00k7l5uoc5afbyz1","_id":"ckoq26jvg00m9l5uo41svg7xm"},{"post_id":"ckoq26j5q003il5uobgfz1vze","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvg00mbl5uo09zj028n"},{"post_id":"ckoq26j5q003il5uobgfz1vze","category_id":"ckoq26jve00m4l5uo8r3mfozl","_id":"ckoq26jvg00mcl5uo80cigujj"},{"post_id":"ckoq26j5q003jl5uo4v9wdkwf","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvh00mel5uog97r88js"},{"post_id":"ckoq26j5q003jl5uo4v9wdkwf","category_id":"ckoq26jve00m4l5uo8r3mfozl","_id":"ckoq26jvh00mfl5uo7q9jbfpn"},{"post_id":"ckoq26j5r003kl5uog6nua06l","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvi00mhl5uod0j753es"},{"post_id":"ckoq26j5r003kl5uog6nua06l","category_id":"ckoq26jve00m4l5uo8r3mfozl","_id":"ckoq26jvi00mil5uo7hnteb8m"},{"post_id":"ckoq26j5s003ll5uo6364e47c","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvi00mjl5uod9o2agbo"},{"post_id":"ckoq26j5s003ll5uo6364e47c","category_id":"ckoq26jve00m4l5uo8r3mfozl","_id":"ckoq26jvj00mll5uo4j09fdal"},{"post_id":"ckoq26j5t003ml5uo5k8cffyq","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvj00mnl5uo6tfthtq2"},{"post_id":"ckoq26j5t003ml5uo5k8cffyq","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvk00mol5uo1h3rfxw7"},{"post_id":"ckoq26j5t003nl5uoch911pm8","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvk00mql5uofdhp9xdl"},{"post_id":"ckoq26j5t003nl5uoch911pm8","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvl00mrl5uobikuhiec"},{"post_id":"ckoq26j5v003ol5uoc2h35jei","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvl00mtl5uogluycckt"},{"post_id":"ckoq26j5v003ol5uoc2h35jei","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvl00mul5uoa15y2egq"},{"post_id":"ckoq26j5v003pl5uogkoldkz4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvm00mwl5uock678u6t"},{"post_id":"ckoq26j5v003pl5uogkoldkz4","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvm00mxl5uo9fee1xn9"},{"post_id":"ckoq26j5w003ql5uo70nh5gnt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvn00mzl5uo3ogv6jnr"},{"post_id":"ckoq26j5w003ql5uo70nh5gnt","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvn00n0l5uofn7kdjd3"},{"post_id":"ckoq26j5x003rl5uo5xmqcrx4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvo00n2l5uohxaf0opw"},{"post_id":"ckoq26j5x003rl5uo5xmqcrx4","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvo00n3l5uob7jz1hof"},{"post_id":"ckoq26j5x003sl5uo5or79vgz","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvp00n5l5uo9vpm6786"},{"post_id":"ckoq26j5x003sl5uo5or79vgz","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvp00n6l5uo1u4r32bn"},{"post_id":"ckoq26j5y003tl5uo7xr5d1r4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jvp00n7l5uoe9biguu9"},{"post_id":"ckoq26j5y003tl5uo7xr5d1r4","category_id":"ckoq26jvh00mgl5uo249s5zwi","_id":"ckoq26jvq00n9l5uo3vhmebyl"},{"post_id":"ckoq26j60003ul5uoeb1qcwjj","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxb00pdl5uo3qckagt5"},{"post_id":"ckoq26j60003ul5uoeb1qcwjj","category_id":"ckoq26jvp00n4l5uocqnsd21z","_id":"ckoq26jxb00pfl5uohz26e2ud"},{"post_id":"ckoq26j60003ul5uoeb1qcwjj","category_id":"ckoq26jxa00pbl5uogocc9lz5","_id":"ckoq26jxc00pgl5uohjnm5b59"},{"post_id":"ckoq26j60003vl5uo2a7g0i0b","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxc00pil5uo8lls5s7f"},{"post_id":"ckoq26j60003vl5uo2a7g0i0b","category_id":"ckoq26jvp00n4l5uocqnsd21z","_id":"ckoq26jxc00pjl5uohxyx8g1k"},{"post_id":"ckoq26j60003vl5uo2a7g0i0b","category_id":"ckoq26jxa00pcl5uoa61ndqgp","_id":"ckoq26jxd00pll5uodivnfcos"},{"post_id":"ckoq26j61003wl5uoc1pqcgur","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxd00pml5uo2ixb1pze"},{"post_id":"ckoq26j61003wl5uoc1pqcgur","category_id":"ckoq26jt500g4l5uo3bwme7o8","_id":"ckoq26jxe00pol5uo60mv615i"},{"post_id":"ckoq26j61003wl5uoc1pqcgur","category_id":"ckoq26jxb00pel5uo5lmyc6h4","_id":"ckoq26jxe00ppl5uo51lzasw7"},{"post_id":"ckoq26j62003xl5uo4yai1dc7","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxe00prl5uo5y6y92ls"},{"post_id":"ckoq26j62003xl5uo4yai1dc7","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxf00psl5uo37c5839x"},{"post_id":"ckoq26j62003xl5uo4yai1dc7","category_id":"ckoq26jxc00phl5uog8ljc1vp","_id":"ckoq26jxg00pul5uoaq76b7yk"},{"post_id":"ckoq26j62003yl5uohki44k94","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxh00pvl5uo2ivk81ao"},{"post_id":"ckoq26j62003yl5uohki44k94","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxj00pxl5uod180hzeo"},{"post_id":"ckoq26j62003yl5uohki44k94","category_id":"ckoq26jxc00phl5uog8ljc1vp","_id":"ckoq26jxk00pyl5uo5deh4eo8"},{"post_id":"ckoq26j63003zl5uoc5cg5hcj","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxk00q0l5uodu9d48ca"},{"post_id":"ckoq26j63003zl5uoc5cg5hcj","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxl00q1l5uohft65co7"},{"post_id":"ckoq26j63003zl5uoc5cg5hcj","category_id":"ckoq26jxd00pnl5uo0zgqcevq","_id":"ckoq26jxm00q3l5uoafz6a4gr"},{"post_id":"ckoq26j640040l5uohow9agg9","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxm00q4l5uo4vgegvqh"},{"post_id":"ckoq26j640040l5uohow9agg9","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxm00q5l5uo07iedwr9"},{"post_id":"ckoq26j640040l5uohow9agg9","category_id":"ckoq26jxd00pnl5uo0zgqcevq","_id":"ckoq26jxn00q7l5uo7trr3gah"},{"post_id":"ckoq26j640041l5uo0dxsc9kr","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxn00q8l5uoggxler5x"},{"post_id":"ckoq26j640041l5uo0dxsc9kr","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxn00qal5uocjbu2sqm"},{"post_id":"ckoq26j640041l5uo0dxsc9kr","category_id":"ckoq26jxd00pnl5uo0zgqcevq","_id":"ckoq26jxo00qbl5uo27ote2ns"},{"post_id":"ckoq26j650042l5uo6mk0abqb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxo00qdl5uof3w0dk3n"},{"post_id":"ckoq26j650042l5uo6mk0abqb","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxp00qel5uoa2jrgbjh"},{"post_id":"ckoq26j650042l5uo6mk0abqb","category_id":"ckoq26jxd00pnl5uo0zgqcevq","_id":"ckoq26jxp00qgl5uo3daiae3k"},{"post_id":"ckoq26j650043l5uo9ie8dx5a","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxq00qhl5uo45235f55"},{"post_id":"ckoq26j650043l5uo9ie8dx5a","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxq00qjl5uo44jb1bei"},{"post_id":"ckoq26j650043l5uo9ie8dx5a","category_id":"ckoq26jxd00pnl5uo0zgqcevq","_id":"ckoq26jxr00qkl5uoebulamv1"},{"post_id":"ckoq26j660044l5uo45ue3nwb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxr00qml5uoc68pgpxd"},{"post_id":"ckoq26j660044l5uo45ue3nwb","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxs00qnl5uo7y4xd5cn"},{"post_id":"ckoq26j660044l5uo45ue3nwb","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jxs00qpl5uogljx0twk"},{"post_id":"ckoq26j670045l5uodljf3q3j","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxs00qql5uo7mh96yq0"},{"post_id":"ckoq26j670045l5uodljf3q3j","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxt00qsl5uo0z0d7bt3"},{"post_id":"ckoq26j670045l5uodljf3q3j","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jxt00qtl5uoa8fv7q4m"},{"post_id":"ckoq26j670046l5uo1a72eno3","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxu00qvl5uodj7z44rd"},{"post_id":"ckoq26j670046l5uo1a72eno3","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxu00qwl5uo2exp1co0"},{"post_id":"ckoq26j670046l5uo1a72eno3","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jxv00qyl5uo1uzr5s25"},{"post_id":"ckoq26j680047l5uocbeu3ut3","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxv00qzl5uoc3kt7hb0"},{"post_id":"ckoq26j680047l5uocbeu3ut3","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxw00r1l5uo0eqbag9q"},{"post_id":"ckoq26j680047l5uocbeu3ut3","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jxw00r2l5uoak2qc719"},{"post_id":"ckoq26j690048l5uo5zhn6knt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxx00r4l5uo0imn2pwv"},{"post_id":"ckoq26j690048l5uo5zhn6knt","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxx00r5l5uoh5qs1k87"},{"post_id":"ckoq26j690048l5uo5zhn6knt","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jxy00r7l5uo1whqdoat"},{"post_id":"ckoq26j6b0049l5uo7c300nzn","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jxy00r8l5uohwambx1z"},{"post_id":"ckoq26j6b0049l5uo7c300nzn","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jxz00ral5uoaht0bgp5"},{"post_id":"ckoq26j6b0049l5uo7c300nzn","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jxz00rbl5uoa5nr329v"},{"post_id":"ckoq26j6c004al5uob4wz6byb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy000rdl5uo8kj1gp91"},{"post_id":"ckoq26j6c004al5uob4wz6byb","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy000rel5uoh6qceinz"},{"post_id":"ckoq26j6c004al5uob4wz6byb","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jy100rgl5uobhcber6c"},{"post_id":"ckoq26j6d004bl5uoeyo00ive","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy100rhl5uobk8u2ava"},{"post_id":"ckoq26j6d004bl5uoeyo00ive","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy200rjl5uoarhr9hxh"},{"post_id":"ckoq26j6d004bl5uoeyo00ive","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jy200rkl5uo8ivm8qpo"},{"post_id":"ckoq26j6e004cl5uoe20ibbpq","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy200rml5uo4xr22iwy"},{"post_id":"ckoq26j6e004cl5uoe20ibbpq","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy300rnl5uohqx9bkf1"},{"post_id":"ckoq26j6e004cl5uoe20ibbpq","category_id":"ckoq26jxl00q2l5uo3le8domd","_id":"ckoq26jy300rpl5uo5yr911u1"},{"post_id":"ckoq26j6f004dl5uo225r8e3o","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy400rql5uo3hp7fd2a"},{"post_id":"ckoq26j6f004dl5uo225r8e3o","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy400rsl5uo8l4q6o7s"},{"post_id":"ckoq26j6f004dl5uo225r8e3o","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jy400rtl5uoftrfek1a"},{"post_id":"ckoq26j6h004el5uoarlta7ij","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy500rvl5uohf71cawi"},{"post_id":"ckoq26j6h004el5uoarlta7ij","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy500rwl5uo6alr5wbd"},{"post_id":"ckoq26j6h004el5uoarlta7ij","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jy600ryl5uo3dpy3pq5"},{"post_id":"ckoq26j6h004fl5uoaaox4jwr","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy600rzl5uoci6v5yjl"},{"post_id":"ckoq26j6h004fl5uoaaox4jwr","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy700s0l5uo9e6zeqtf"},{"post_id":"ckoq26j6h004fl5uoaaox4jwr","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jy700s2l5uoacot1qhv"},{"post_id":"ckoq26j6i004gl5uohmi444os","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy700s3l5uoaq7y0bv3"},{"post_id":"ckoq26j6i004gl5uohmi444os","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy800s5l5uoagozdtcr"},{"post_id":"ckoq26j6i004gl5uohmi444os","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jy800s6l5uo902ugnx5"},{"post_id":"ckoq26j6j004hl5uoamx3eqxf","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jy900s8l5uocvqqawc7"},{"post_id":"ckoq26j6j004hl5uoamx3eqxf","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jy900s9l5uo3dag8ai9"},{"post_id":"ckoq26j6j004hl5uoamx3eqxf","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jya00sbl5uo78gng1rz"},{"post_id":"ckoq26j6j004il5uo118q1he0","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jya00scl5uodr0k0kio"},{"post_id":"ckoq26j6j004il5uo118q1he0","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jyb00sel5uo710fd2ed"},{"post_id":"ckoq26j6j004il5uo118q1he0","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jyb00sfl5uod2277src"},{"post_id":"ckoq26j6k004jl5uo78e809mf","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyc00shl5uo5po7gnpf"},{"post_id":"ckoq26j6k004jl5uo78e809mf","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jyc00sil5uobiy688j4"},{"post_id":"ckoq26j6k004jl5uo78e809mf","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jyd00skl5uofjkng03r"},{"post_id":"ckoq26j6l004kl5uo3j9v1jf2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyd00sll5uo1fyjd0zm"},{"post_id":"ckoq26j6l004kl5uo3j9v1jf2","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jye00snl5uo41cw5wdd"},{"post_id":"ckoq26j6l004kl5uo3j9v1jf2","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jye00sol5uo3n6a31p9"},{"post_id":"ckoq26j6l004ll5uoeu6m90p4","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyf00sql5uo5hak6g9n"},{"post_id":"ckoq26j6l004ll5uoeu6m90p4","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jyf00srl5uobi6a1ha7"},{"post_id":"ckoq26j6l004ll5uoeu6m90p4","category_id":"ckoq26jxt00qul5uo7q1x1pvo","_id":"ckoq26jyg00stl5uo0i762yzg"},{"post_id":"ckoq26j6m004ml5uo4nodb4wk","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyg00sul5uo2k9801ke"},{"post_id":"ckoq26j6m004ml5uo4nodb4wk","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jyg00svl5uoh6a52frg"},{"post_id":"ckoq26j6m004ml5uo4nodb4wk","category_id":"ckoq26jy200rll5uoebzb5oak","_id":"ckoq26jyh00sxl5uo7zwzdsj8"},{"post_id":"ckoq26j6n004nl5uo8xt2d4n3","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyi00syl5uo6aezg2yt"},{"post_id":"ckoq26j6n004nl5uo8xt2d4n3","category_id":"ckoq26jvr00nbl5uodhvra99b","_id":"ckoq26jyi00t0l5uohmd4cka0"},{"post_id":"ckoq26j6n004nl5uo8xt2d4n3","category_id":"ckoq26jy200rll5uoebzb5oak","_id":"ckoq26jyj00t1l5uof4kf1txx"},{"post_id":"ckoq26j6n004ol5uob7px2byc","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyk00t3l5uocww3bjkm"},{"post_id":"ckoq26j6n004ol5uob7px2byc","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyk00t4l5uogi2vb0wo"},{"post_id":"ckoq26j6n004ol5uob7px2byc","category_id":"ckoq26jy400rrl5uodglk3cg1","_id":"ckoq26jyl00t6l5uo28lf2b8p"},{"post_id":"ckoq26j6u004pl5uo5m77aebi","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyn00t7l5uo51v4b5pn"},{"post_id":"ckoq26j6u004pl5uo5m77aebi","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jys00t9l5uocqhy0837"},{"post_id":"ckoq26j6u004pl5uo5m77aebi","category_id":"ckoq26jy400rrl5uodglk3cg1","_id":"ckoq26jys00tal5uod9ck28il"},{"post_id":"ckoq26j6v004ql5uo1nj34f6c","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyt00tcl5uobcoabhve"},{"post_id":"ckoq26j6v004ql5uo1nj34f6c","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyt00tdl5uoafboh7p7"},{"post_id":"ckoq26j6v004ql5uo1nj34f6c","category_id":"ckoq26jy600rxl5uo3xo620dc","_id":"ckoq26jyu00tfl5uocd3x65qj"},{"post_id":"ckoq26j6w004rl5uo9qom0e1u","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyu00tgl5uo6xu3b7vz"},{"post_id":"ckoq26j6w004rl5uo9qom0e1u","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyv00til5uoa6q45pg3"},{"post_id":"ckoq26j6w004rl5uo9qom0e1u","category_id":"ckoq26jy700s1l5uo63gsev8v","_id":"ckoq26jyv00tjl5uo33l1h1e8"},{"post_id":"ckoq26j6w004sl5uo5xgefm39","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyw00tll5uo3t1v5t2o"},{"post_id":"ckoq26j6w004sl5uo5xgefm39","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyw00tml5uoatex9oqp"},{"post_id":"ckoq26j6w004sl5uo5xgefm39","category_id":"ckoq26jy700s4l5uogmdmbmk6","_id":"ckoq26jyx00tol5uoanwi1apy"},{"post_id":"ckoq26j6x004tl5uoao31b2ss","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyx00tpl5uo954n2um1"},{"post_id":"ckoq26j6x004tl5uoao31b2ss","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyy00trl5uogaq3btmi"},{"post_id":"ckoq26j6x004tl5uoao31b2ss","category_id":"ckoq26jy700s4l5uogmdmbmk6","_id":"ckoq26jyy00tsl5uo1z8fgxby"},{"post_id":"ckoq26j6y004ul5uo96kvbn3e","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jyz00tul5uo15uy3fcq"},{"post_id":"ckoq26j6y004ul5uo96kvbn3e","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jyz00tvl5uo223hcxbd"},{"post_id":"ckoq26j6y004ul5uo96kvbn3e","category_id":"ckoq26jy700s4l5uogmdmbmk6","_id":"ckoq26jz000txl5uo4jm17xmz"},{"post_id":"ckoq26j6y004vl5uoc2g86i2x","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jz000tyl5uobqavep35"},{"post_id":"ckoq26j6y004vl5uoc2g86i2x","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jz100u0l5uo9kai579e"},{"post_id":"ckoq26j6y004vl5uoc2g86i2x","category_id":"ckoq26jy700s4l5uogmdmbmk6","_id":"ckoq26jz100u1l5uo17ev3y5w"},{"post_id":"ckoq26j6z004wl5uocmvt7xxb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jz200u3l5uo68yk18q8"},{"post_id":"ckoq26j6z004wl5uocmvt7xxb","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jz200u4l5uo4boy9yc7"},{"post_id":"ckoq26j6z004wl5uocmvt7xxb","category_id":"ckoq26jy700s4l5uogmdmbmk6","_id":"ckoq26jz300u6l5uo838t6c4u"},{"post_id":"ckoq26j6z004xl5uo0iob9tbu","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jz300u7l5uo55go8cyv"},{"post_id":"ckoq26j6z004xl5uo0iob9tbu","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jz500u9l5uofy7e6t0u"},{"post_id":"ckoq26j6z004xl5uo0iob9tbu","category_id":"ckoq26jy700s4l5uogmdmbmk6","_id":"ckoq26jz500ual5uogc771xwa"},{"post_id":"ckoq26j70004yl5uod8wp4j51","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jz700ucl5uo13tm1ccd"},{"post_id":"ckoq26j70004yl5uod8wp4j51","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jz700udl5uod97cg5dz"},{"post_id":"ckoq26j70004yl5uod8wp4j51","category_id":"ckoq26jy700s4l5uogmdmbmk6","_id":"ckoq26jz800ufl5uo7r7w44wf"},{"post_id":"ckoq26j70004zl5uog80b2iqb","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jz900ugl5uoaylo4sxq"},{"post_id":"ckoq26j70004zl5uog80b2iqb","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jza00uil5uo4wexbicx"},{"post_id":"ckoq26j70004zl5uog80b2iqb","category_id":"ckoq26jyf00spl5uohfen6n1t","_id":"ckoq26jzb00ujl5uoc00tgnn3"},{"post_id":"ckoq26j710050l5uoeuy3a910","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzc00ull5uobfelhg13"},{"post_id":"ckoq26j710050l5uoeuy3a910","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzc00uml5uogx4m5v9d"},{"post_id":"ckoq26j710050l5uoeuy3a910","category_id":"ckoq26jyg00ssl5uogzaha1fa","_id":"ckoq26jzd00uol5uobi4q166q"},{"post_id":"ckoq26j720051l5uo291wdgc3","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzd00upl5uo9pda26fc"},{"post_id":"ckoq26j720051l5uo291wdgc3","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jze00url5uo3yvfcd8r"},{"post_id":"ckoq26j720051l5uo291wdgc3","category_id":"ckoq26jyg00ssl5uogzaha1fa","_id":"ckoq26jze00usl5uo8tuwdcp8"},{"post_id":"ckoq26j720052l5uoddap23nr","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzf00uul5uo9jahd79e"},{"post_id":"ckoq26j720052l5uoddap23nr","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzf00uvl5uogtupesuq"},{"post_id":"ckoq26j720052l5uoddap23nr","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzg00uxl5uo6mpp74un"},{"post_id":"ckoq26j730053l5uo1qdr5ren","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzg00uyl5uo2t7fdaqs"},{"post_id":"ckoq26j730053l5uo1qdr5ren","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzh00v0l5uo0oe886m5"},{"post_id":"ckoq26j730053l5uo1qdr5ren","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzh00v1l5uocnc6b73c"},{"post_id":"ckoq26j730054l5uo492danje","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzi00v3l5uoh8xv51jx"},{"post_id":"ckoq26j730054l5uo492danje","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzi00v4l5uo1foyho52"},{"post_id":"ckoq26j730054l5uo492danje","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzj00v6l5uo0od37k5d"},{"post_id":"ckoq26j740055l5uo7m7s3cpj","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzj00v7l5uof2h4gm66"},{"post_id":"ckoq26j740055l5uo7m7s3cpj","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzk00v9l5uo465oalsu"},{"post_id":"ckoq26j740055l5uo7m7s3cpj","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzk00val5uo15up1q52"},{"post_id":"ckoq26j750056l5uo89mpapmt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzl00vcl5uofgqx8x1l"},{"post_id":"ckoq26j750056l5uo89mpapmt","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzm00vdl5uogzm59e6s"},{"post_id":"ckoq26j750056l5uo89mpapmt","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzm00vfl5uodcomgvzw"},{"post_id":"ckoq26j750057l5uo2op20tss","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzn00vgl5uo8xm23mr3"},{"post_id":"ckoq26j750057l5uo2op20tss","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzn00vil5uod95f1dgs"},{"post_id":"ckoq26j750057l5uo2op20tss","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzn00vjl5uo3x7de0pr"},{"post_id":"ckoq26j760058l5uo4a212yw9","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzo00vll5uo2qr7bkb2"},{"post_id":"ckoq26j760058l5uo4a212yw9","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzo00vml5uofzwy8f49"},{"post_id":"ckoq26j760058l5uo4a212yw9","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzp00vnl5uo541qcij5"},{"post_id":"ckoq26j770059l5uo3rood1mo","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzp00vpl5uo21fs6uoj"},{"post_id":"ckoq26j770059l5uo3rood1mo","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzq00vql5uo5a9n9d72"},{"post_id":"ckoq26j770059l5uo3rood1mo","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzq00vsl5uo291pcw63"},{"post_id":"ckoq26j77005al5uo5aahchgt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzr00vtl5uo23d3fddx"},{"post_id":"ckoq26j77005al5uo5aahchgt","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzr00vul5uoh3529yyv"},{"post_id":"ckoq26j77005al5uo5aahchgt","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzr00vvl5uo1b2getv0"},{"post_id":"ckoq26j78005bl5uo5e00cnyo","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzr00vwl5uoc6h2bsb2"},{"post_id":"ckoq26j78005bl5uo5e00cnyo","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzr00vxl5uof4avde8p"},{"post_id":"ckoq26j78005bl5uo5e00cnyo","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzr00vyl5uo01u76f7v"},{"post_id":"ckoq26j7a005cl5uofsfi5aqk","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzr00vzl5uo2p9qfxsi"},{"post_id":"ckoq26j7a005cl5uofsfi5aqk","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00w0l5uo8azb5io3"},{"post_id":"ckoq26j7a005cl5uofsfi5aqk","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00w1l5uocjvyhb3s"},{"post_id":"ckoq26j7a005dl5uob7hy3fc3","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00w2l5uo3q2gfg88"},{"post_id":"ckoq26j7a005dl5uob7hy3fc3","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00w3l5uogjjjgs9u"},{"post_id":"ckoq26j7a005dl5uob7hy3fc3","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00w4l5uo12d4fsi5"},{"post_id":"ckoq26j7b005el5uo2ztv8w0z","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00w5l5uogwvo55ix"},{"post_id":"ckoq26j7b005el5uo2ztv8w0z","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00w6l5uo2x0v2dln"},{"post_id":"ckoq26j7b005el5uo2ztv8w0z","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00w7l5uocoz37c4e"},{"post_id":"ckoq26j7d005fl5uo4cwef6ps","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00w8l5uo68133z33"},{"post_id":"ckoq26j7d005fl5uo4cwef6ps","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00w9l5uo6hr7db1f"},{"post_id":"ckoq26j7d005fl5uo4cwef6ps","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00wal5uo6nsr79x6"},{"post_id":"ckoq26j7d005gl5uoe4wv2x73","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00wbl5uobkli2e4z"},{"post_id":"ckoq26j7d005gl5uoe4wv2x73","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00wcl5uocsdr4xyi"},{"post_id":"ckoq26j7d005gl5uoe4wv2x73","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00wdl5uoa8s9b6ax"},{"post_id":"ckoq26j7e005hl5uofa23241f","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00wel5uoex9xgyyf"},{"post_id":"ckoq26j7e005hl5uofa23241f","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00wfl5uo1qp8csnv"},{"post_id":"ckoq26j7e005hl5uofa23241f","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00wgl5uob4t00ww7"},{"post_id":"ckoq26j7f005il5uohway9p5v","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00whl5uocmg39cg1"},{"post_id":"ckoq26j7f005il5uohway9p5v","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00wil5uoa8iehh31"},{"post_id":"ckoq26j7f005il5uohway9p5v","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00wjl5uo91sv4957"},{"post_id":"ckoq26j7g005jl5uofcgadjjr","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00wkl5uocb8v8982"},{"post_id":"ckoq26j7g005jl5uofcgadjjr","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00wll5uocu577347"},{"post_id":"ckoq26j7g005jl5uofcgadjjr","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00wml5uo9lz4a2a3"},{"post_id":"ckoq26j7h005kl5uo0z1uaohi","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00wnl5uo0e020156"},{"post_id":"ckoq26j7h005kl5uo0z1uaohi","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00wol5uo6z0m6uen"},{"post_id":"ckoq26j7h005kl5uo0z1uaohi","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00wpl5uoh3h3ht8k"},{"post_id":"ckoq26j7i005ll5uo3uam15en","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00wql5uoct1o3scr"},{"post_id":"ckoq26j7i005ll5uo3uam15en","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00wrl5uohx718x1j"},{"post_id":"ckoq26j7i005ll5uo3uam15en","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzs00wsl5uo39ji2ghf"},{"post_id":"ckoq26j7i005ml5uo4ddl1zhe","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzs00wtl5uo9m4sapdd"},{"post_id":"ckoq26j7i005ml5uo4ddl1zhe","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzs00wul5uoc1jb13l8"},{"post_id":"ckoq26j7i005ml5uo4ddl1zhe","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzt00wvl5uo4w0qb3v4"},{"post_id":"ckoq26j7j005nl5uofutmb63v","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00wwl5uo9hbp2h6y"},{"post_id":"ckoq26j7j005nl5uofutmb63v","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00wxl5uogybaeo3p"},{"post_id":"ckoq26j7j005nl5uofutmb63v","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzt00wyl5uoaokf7ob9"},{"post_id":"ckoq26j7j005ol5uoa2970boa","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00wzl5uobz4ufvpv"},{"post_id":"ckoq26j7j005ol5uoa2970boa","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00x0l5uogq5lan9x"},{"post_id":"ckoq26j7j005ol5uoa2970boa","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzt00x1l5uo2n926ix1"},{"post_id":"ckoq26j7k005pl5uodopl89nq","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00x2l5uo0hot9h7h"},{"post_id":"ckoq26j7k005pl5uodopl89nq","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00x3l5uo6cg95h33"},{"post_id":"ckoq26j7k005pl5uodopl89nq","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzt00x4l5uodut89d55"},{"post_id":"ckoq26j7l005ql5uo7nnseqdm","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00x5l5uo4861825l"},{"post_id":"ckoq26j7l005ql5uo7nnseqdm","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00x6l5uoh0q384el"},{"post_id":"ckoq26j7l005ql5uo7nnseqdm","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzt00x7l5uo78en0yt2"},{"post_id":"ckoq26j7m005rl5uo3ltw3ko9","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00x8l5uoeb4b2kjk"},{"post_id":"ckoq26j7m005rl5uo3ltw3ko9","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00x9l5uof8zkh9zz"},{"post_id":"ckoq26j7m005rl5uo3ltw3ko9","category_id":"ckoq26jzi00v2l5uo9kw640p4","_id":"ckoq26jzt00xal5uo0kpvf6y4"},{"post_id":"ckoq26j7q005vl5uofept5k3t","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00xbl5uoe3a4ai9p"},{"post_id":"ckoq26j7q005vl5uofept5k3t","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00xcl5uo023daell"},{"post_id":"ckoq26j7q005vl5uofept5k3t","category_id":"ckoq26jyx00tql5uo49be93kr","_id":"ckoq26jzt00xdl5uoanqg5roi"},{"post_id":"ckoq26j7r005wl5uoc82i4ism","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00xel5uo9ru4g8xj"},{"post_id":"ckoq26j7r005wl5uoc82i4ism","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00xfl5uofbttb873"},{"post_id":"ckoq26j7r005wl5uoc82i4ism","category_id":"ckoq26jzi00v2l5uo9kw640p4","_id":"ckoq26jzt00xgl5uof8fv721t"},{"post_id":"ckoq26j7m005sl5uo0aycbvxt","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00xhl5uo6mgp9ckt"},{"post_id":"ckoq26j7m005sl5uo0aycbvxt","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00xil5uo9gpz4jmt"},{"post_id":"ckoq26j7m005sl5uo0aycbvxt","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzt00xjl5uo6j8v0sci"},{"post_id":"ckoq26j7m005sl5uo0aycbvxt","category_id":"ckoq26jzo00vkl5uo5rjq3fix","_id":"ckoq26jzt00xkl5uo5kgob74h"},{"post_id":"ckoq26j7n005tl5uobvzd2dp2","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzt00xll5uo9h2a69pi"},{"post_id":"ckoq26j7n005tl5uobvzd2dp2","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzt00xml5uoh80745au"},{"post_id":"ckoq26j7n005tl5uobvzd2dp2","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzt00xnl5uo8djs6sp2"},{"post_id":"ckoq26j7n005tl5uobvzd2dp2","category_id":"ckoq26jzo00vkl5uo5rjq3fix","_id":"ckoq26jzu00xol5uo9ry99jdj"},{"post_id":"ckoq26j7p005ul5uobez7ca5d","category_id":"ckoq26jmi0062l5uo4rffa56j","_id":"ckoq26jzu00xpl5uoc7fmdbpc"},{"post_id":"ckoq26j7p005ul5uobez7ca5d","category_id":"ckoq26jw900o2l5uof9xr1yp9","_id":"ckoq26jzu00xql5uod3rp9ugl"},{"post_id":"ckoq26j7p005ul5uobez7ca5d","category_id":"ckoq26jyi00szl5uoe7yb1bo1","_id":"ckoq26jzu00xrl5uo33jx4d2g"},{"post_id":"ckoq26j7p005ul5uobez7ca5d","category_id":"ckoq26jzo00vkl5uo5rjq3fix","_id":"ckoq26jzu00xsl5uo8mgj5t6c"}],"PostTag":[],"Tag":[]}}