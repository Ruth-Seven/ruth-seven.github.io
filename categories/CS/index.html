<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: CS - Hexo</title><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Hexo","image":["http://yoursite.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="http://static.come2rss.xyz/%E9%93%81%E7%94%B2%E5%9F%8Elogo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://static.come2rss.xyz/%E9%92%A2%E9%93%81%E4%BE%A0.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Ruth-Seven"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">CS</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="数据结构知识点笔记 "></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:27:22.000Z" title="2020-08-07T04:27:22.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/DS/">DS</a></span><span class="level-item">7 minutes read (About 982 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/DS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/">数据结构知识点笔记 </a></h1><div class="content"><p>（有时候确实读黑书应该读原著，中文翻译著作时常有些令人琢磨不透的表达）</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>O(f(N))O(f(N))表算法复杂度T(N)T(N)的函数上限，其ff增长率≥T(N)≥T(N)的增长率。</p>
<p>Ω(f(N))Ω(f(N))表算法复杂度T(N)T(N)的函数下限，其ff增长率≤T(N)≤T(N)的增长率。</p>
<p>Θ(f(N))Θ(f(N))表 ff的增长率等于TT的增长率。</p>
<p>o(f(N))o(f(N))表 ff的增长率&gt;T&gt;T的增长率。</p>
<h2 id="表、栈和队列"><a href="#表、栈和队列" class="headerlink" title="表、栈和队列"></a>表、栈和队列</h2><p>表或者说线性表的特征在于一组有次序（非大小有序的有序，这里指前后次序的序）的元素。实现物理结构：</p>
<ul>
<li>链表<ul>
<li>带头结点的链表</li>
<li>双链表</li>
<li>循环链表</li>
<li><strong>多重表</strong></li>
</ul>
</li>
<li>数组</li>
</ul>
<p>栈是删除和插入都在同一端点处进行的表。物理实现同样有链表和数组。</p>
<blockquote>
<p>经典题目：<strong>后缀表示式计算、中缀转后缀</strong></p>
</blockquote>
<p>队列是队尾插入，队头删除的表。物理实现：</p>
<ul>
<li>循环数组的队列</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树实际上只有一个源节点的DAG。最常见的如二叉查找树（限制了子节点和节点的关系的二叉树）、AVL、哈夫曼树</p>
<p>算法：</p>
<ul>
<li>先序遍历、中序遍历、后序遍历</li>
<li>二叉查找树的创建、插入、<strong>删除</strong></li>
<li>AVL树的旋转（四种）、插入、删除（调整 ）</li>
<li>展开树（p92？）</li>
<li>m阶B树的性质</li>
<li>哈夫曼树 （Haffman）</li>
</ul>
<p>实现：</p>
<ul>
<li>儿子链表</li>
<li>兄弟儿子表示法</li>
<li>父亲表示法</li>
</ul>
<blockquote>
<p>经典题目：表达式树的创建</p>
</blockquote>
<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>散列是将关键字映射到不同的数组单元DS。三个要点：</p>
<ul>
<li>散列函数</li>
<li>消除冲突<ul>
<li>分离链接法</li>
<li>开放定址法<ul>
<li>线性探测法</li>
<li>平方探测法</li>
<li>双散列</li>
<li><em>再散列是重新建表重新映射到新数组</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>优先队列是用堆实现的保持堆序性的完全二叉树。</p>
<p>算法:</p>
<ul>
<li>上浮、下滤、插入、删除；注意建堆的复杂度是O(N)O(N)。</li>
</ul>
<p>其他数据结构（我的神啊p147？）：</p>
<ul>
<li>d-堆</li>
<li>左式堆</li>
<li>斜堆</li>
<li>二项队列</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>插入排序</li>
<li>希尔排序</li>
<li>堆排序</li>
<li>归并排序</li>
<li>快速排序：枢纽元的一个有效选取办法就是三数中值，随机数代价高昂</li>
<li>桶式排序</li>
<li><strong>外部排序</strong>： 順串的产生（优先队列 + 最小元素锚定），順串的合并（归并算法）</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>并查集算法</p>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>数据表示：邻接表、邻接矩阵、邻接多重表（无向图）、十字链表（有向图）<br>算法：</p>
<ul>
<li><p>拓扑排序</p>
</li>
<li><p>最短路径</p>
<ul>
<li><p>无权图：遍历</p>
</li>
<li><p>非负权图：Dijkstra（最小堆优化）</p>
<blockquote>
<p>Dijkstra复杂度：</p>
<p>邻接矩阵实现：O(V2)O(V2)</p>
<p>邻接表实现：O(V2+VE)O(V2+VE)</p>
<p>堆优化实现：O(V∗log(V)+Elog(V))O(V∗log(V)+Elog(V))<br>思考复杂度真是有趣</p>
</blockquote>
</li>
<li><p>负权值图：</p>
</li>
</ul>
</li>
<li><p>遍历：DFS，BFS</p>
</li>
<li><p>网络流问题</p>
</li>
<li><p>最小生成树：Prim，Kruskal</p>
</li>
<li><p>非双连通性的无向图割点问题：DFS</p>
<ul>
<li>有向图？</li>
</ul>
</li>
</ul>
<h2 id="NP问题"><a href="#NP问题" class="headerlink" title="NP问题"></a>NP问题</h2><p>NP问题值非确定性多项式时间问题，如果可以在多项式时间内验证一个问题的所有“对”为正确，那么该问题就是NP问题。而NP-完全问题就是NP问题在的一个子集，所有NP问题都可以通过映射转化为NP-C问题，所以NP-C问题是最难的。（。。。。。。。）</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/DS/AVL/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="AVL"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:26:38.000Z" title="2020-08-07T04:26:38.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/DS/">DS</a></span><span class="level-item">2 minutes read (About 345 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/DS/AVL/">AVL</a></h1><div class="content"><p>老模板了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This is Code of JJ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Problem      :AVL tree</span></span><br><span class="line"><span class="comment">Source       :</span></span><br><span class="line"><span class="comment">Solution     :</span></span><br><span class="line"><span class="comment">AnyDetial    :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DateAndTime  :5,18</span></span><br><span class="line"><span class="comment">CostofTime   :17:07</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data, <span class="built_in">height</span>;</span><br><span class="line">    Node *lchild, *rchild;</span><br><span class="line">    Node(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        data = x;</span><br><span class="line">        <span class="built_in">height</span> = <span class="number">1</span>;</span><br><span class="line">        lchild = <span class="literal">NULL</span>;</span><br><span class="line">        rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//! child node may be is NULL.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeightFactor</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild)) + <span class="number">1</span>;<span class="comment">//!!! add 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  search(root-&gt;rchild,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! right rotate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r_rotate</span><span class="params">(Node *&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"R\n"</span>;</span><br><span class="line">    Node* tmpr = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = tmpr-&gt;rchild;</span><br><span class="line">    tmpr-&gt;rchild = root;</span><br><span class="line">    updateHeight(root);<span class="comment">//!!!update the height of tree</span></span><br><span class="line">    updateHeight(tmpr);</span><br><span class="line">    root = tmpr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//! left rotate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l_rotate</span><span class="params">(Node *&amp;root)</span><span class="comment">///!!! left rotating replace root with root's right child.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"L\n"</span>;</span><br><span class="line">    Node* tmpr = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = tmpr-&gt;lchild;</span><br><span class="line">    tmpr-&gt;lchild = root;</span><br><span class="line">    updateHeight(root);<span class="comment">//!!!update the height of tree</span></span><br><span class="line">    updateHeight(tmpr);</span><br><span class="line">    root = tmpr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root  = <span class="keyword">new</span> Node(x);;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//!!you should update the weight after changing the number or the height of root and child;</span></span><br><span class="line">    updateHeight(root);</span><br><span class="line">    <span class="keyword">if</span>(getHeightFactor(root)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(getHeightFactor(root-&gt;lchild)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r_rotate(root);<span class="comment">//!!! change the root</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getHeightFactor(root-&gt;lchild)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l_rotate(root-&gt;lchild);</span><br><span class="line">            r_rotate(root);<span class="comment">//!!! change the root</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(getHeightFactor(root)==<span class="number">-2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(getHeightFactor(root-&gt;rchild)==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l_rotate(root);<span class="comment">//!!! change the root</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(getHeightFactor(root-&gt;rchild)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r_rotate(root-&gt;rchild);</span><br><span class="line">            l_rotate(root);<span class="comment">//!!! change the root</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function">Node *<span class="title">create</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Node * root = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         insert(root,a[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">     preorder(root-&gt;lchild);</span><br><span class="line">     preorder(root-&gt;rchild);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">pr</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"data: %3d   h:%d\n"</span>,root-&gt;data,root-&gt;<span class="built_in">height</span>);</span><br><span class="line">     pr(root-&gt;lchild);</span><br><span class="line">     pr(root-&gt;rchild);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    Node *root = create(a,<span class="number">10</span>);</span><br><span class="line"><span class="comment">//    preorder(root);</span></span><br><span class="line">    pr(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/DS/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="二叉查找树实现"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:25:42.000Z" title="2020-08-07T04:25:42.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/DS/">DS</a></span><span class="level-item">5 minutes read (About 795 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/DS/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AE%9E%E7%8E%B0/">二叉查找树实现</a></h1><div class="content"><p>二叉查找树的一个实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">尤其注意删除那一部分的逻辑！</span><br><span class="line"></span><br><span class="line"><span class="comment">/** This is Code of JJ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Problem      :</span></span><br><span class="line"><span class="comment">Source       :</span></span><br><span class="line"><span class="comment">Solution     :</span></span><br><span class="line"><span class="comment">AnyDetial    :</span></span><br><span class="line"><span class="comment">注意点：</span></span><br><span class="line"><span class="comment">1.递归边界是root为NULL</span></span><br><span class="line"><span class="comment">2.插入：</span></span><br><span class="line"><span class="comment">    查找失败--NULL--即为插入点</span></span><br><span class="line"><span class="comment">    利用插入创建时，第一个数据就是查找失败的点！</span></span><br><span class="line"><span class="comment">3.层序遍历：队列里存的是地址；</span></span><br><span class="line"><span class="comment">DateAndTime  :</span></span><br><span class="line"><span class="comment">CostofTime   :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,layer;</span><br><span class="line">    Node *lchild,*rchild;</span><br><span class="line">    Node()</span><br><span class="line">    &#123;</span><br><span class="line">        lchild = <span class="literal">NULL</span>;</span><br><span class="line">        rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        data = a;</span><br><span class="line">        lchild = <span class="literal">NULL</span>;</span><br><span class="line">        rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> a)</span><span class="comment">//! create a node with new!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! find those nodes whose data is x and replace those data with x;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_node</span><span class="params">(Node* root, <span class="keyword">int</span> key, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==key) root-&gt;data = x;<span class="comment">//! a -&gt; data !</span></span><br><span class="line">    search_node(root-&gt;rchild,key,x);</span><br><span class="line">    search_node(root-&gt;lchild,key,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//! The</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = newnode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;<span class="comment">//!the index begin with 0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;!</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">    preorder(root-&gt;lchild);</span><br><span class="line">    preorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//!可用于递归赋值父节点信息和遍历输出根到所有节点的路径</span></span><br><span class="line"></span><br><span class="line">Node *path[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_withrint</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    path[++pos] = root;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;pos&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pos;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i]-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,path[pos]-&gt;data);</span><br><span class="line"><span class="comment">//    printf("%d ",root-&gt;data);</span></span><br><span class="line">    preorder_withrint(root-&gt;lchild);</span><br><span class="line">    preorder_withrint(root-&gt;rchild);</span><br><span class="line">    pos--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!错误代码 ： 此代码无法识别已经某一节点右节点是否已经压入过栈，而陷入无限循环之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inoder_withrecursion</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Worry Code!\n"</span>;</span><br><span class="line">    Node *q;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        getchar()</span><br><span class="line">        ;q = s.top();</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild)<span class="comment">//!一个错误点</span></span><br><span class="line">            s.push(q-&gt;lchild);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,q-&gt;data);</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;rchild)</span><br><span class="line">                s.push(q-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerorder</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,t-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;lchild!=<span class="literal">NULL</span>) q.push(t-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;rchild!=<span class="literal">NULL</span>) q.push(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">layerorder_withlayer</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> Nol = <span class="number">0</span>,Non = <span class="number">0</span>,maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line">    root -&gt; layer = <span class="number">1</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *t = q.front();</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;layer!=Nol)&#123;</span><br><span class="line">            Nol = t-&gt;layer;</span><br><span class="line">            Non = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"?"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            Non ++;</span><br><span class="line">        maxn = <span class="built_in">max</span>(Non,maxn);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,t-&gt;data,t-&gt;layer);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;lchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            t-&gt;lchild-&gt;layer = Nol + <span class="number">1</span>;</span><br><span class="line">            q.push(t-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            t-&gt;rchild-&gt;layer = Nol + <span class="number">1</span>;</span><br><span class="line">            q.push(t-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//!前序遍历和中序遍历重建树</span></span><br><span class="line"><span class="function">Node *<span class="title">create_in_pre</span><span class="params">( <span class="keyword">int</span> inorder[], <span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> preorder[], <span class="keyword">int</span> prel, <span class="keyword">int</span> prer)</span><span class="comment">//! in[l,r], pre[l,r],</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inl&gt;inr || prel&gt;prer) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos_in = inl;</span><br><span class="line">    <span class="keyword">for</span>(;pos_in&lt;=inr;pos_in++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[pos_in]==preorder[prel])<span class="comment">// find the index of root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numleft = pos_in - inl;<span class="comment">// the number of left tree;</span></span><br><span class="line">    Node *root = newnode(preorder[prel]);</span><br><span class="line">    root-&gt;lchild = create_in_pre(inorder, inl, pos_in<span class="number">-1</span>, preorder, prel+<span class="number">1</span>, prel+numleft);</span><br><span class="line">    root-&gt;rchild = create_in_pre(inorder, pos_in+<span class="number">1</span>, inr, preorder, prel+numleft+<span class="number">1</span>, prer);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!后序遍历和中序遍历重建树</span></span><br><span class="line"><span class="function">Node *<span class="title">create_in_post</span><span class="params">(<span class="keyword">int</span> in[],<span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> post[], <span class="keyword">int</span> postl, <span class="keyword">int</span> postr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inl&gt;inr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Node *root = newnode(post[postr]);</span><br><span class="line">    <span class="keyword">int</span> pos = inl;</span><br><span class="line">    <span class="keyword">for</span>(;pos&lt;inr;pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[pos]==root-&gt;data) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = pos - inl;</span><br><span class="line">    root-&gt;lchild = create_in_post(in,inl,pos<span class="number">-1</span>,post,postl,postl+k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild = create_in_post(in,pos+<span class="number">1</span>,inr,post,postl+k,postr<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">-10</span>,<span class="number">15</span>,<span class="number">0</span>&#125; ,n = <span class="number">8</span>;</span><br><span class="line">    Node *root = create(a,n);</span><br><span class="line"><span class="comment">//    preorder(root);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    inoder_withrecursion(root);</span></span><br><span class="line">    preorder_withrint(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    postorder(root);</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    layerorder(root);</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl&lt;&lt;"max of Layer\n"&lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;layerorder_withlayer(root);</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    int pre[10] = &#123;1 ,-2 ,-10, 0, 3 ,5 ,7 ,15&#125;;</span></span><br><span class="line"><span class="comment">//    int in[10] = &#123;-10, -2, 0, 1, 3, 5, 7, 15&#125;;</span></span><br><span class="line"><span class="comment">//    int post[10] = &#123;-10 ,-2, 0, 3, 5, 7, 15 ,1&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    Node *newroot1 = create_in_pre(in,0,7,pre,0,7);</span></span><br><span class="line"><span class="comment">//    Node *newroot2 = create_in_post(in,0,7,post,0,7);</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;"!recreate!\n";</span></span><br><span class="line"><span class="comment">//    inorder(newroot1);</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    inorder(newroot2);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/DS/%E5%A0%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="堆算法和堆排序"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:24:34.000Z" title="2020-08-07T04:24:34.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/DS/">DS</a></span><span class="level-item">2 minutes read (About 345 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/DS/%E5%A0%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/">堆算法和堆排序</a></h1><div class="content"><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> x, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">2</span> * x; p &lt;= len; p *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; len  &amp;&amp; arr[p] &lt; arr[p+<span class="number">1</span>]) p++;</span><br><span class="line">        <span class="keyword">if</span>(arr[x] &gt; arr[p]) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[x], arr[p]);</span><br><span class="line">        x = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    a.resize(n + <span class="number">1</span>);</span><br><span class="line">    b.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>, ch;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; n &amp;&amp; b[p] &lt;= b[p + <span class="number">1</span>]) p++;</span><br><span class="line">    <span class="keyword">for</span>(ch = p + <span class="number">1</span>; ch &lt;= n &amp;&amp; a[ch] == b[ch]; ch++);</span><br><span class="line">    <span class="keyword">if</span>(ch == n + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Insertion Sort\n"</span>;</span><br><span class="line">        sort(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">begin</span>() + <span class="number">2</span> + p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Heap Sort\n"</span>;</span><br><span class="line">        <span class="keyword">int</span> k = n;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; b[k] &gt; b[<span class="number">1</span>]) k--;</span><br><span class="line">        swap(b[<span class="number">1</span>], b[k]);</span><br><span class="line">        adjustDown(b, <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">        a = b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(i == n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全堆排序"><a href="#完全堆排序" class="headerlink" title="完全堆排序"></a>完全堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> heap[MAXN] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line"><span class="comment">///! down</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = p * <span class="number">2</span>; x &lt;= len; x += x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; len &amp;&amp; heap[x] &lt; heap[x + <span class="number">1</span>]) x++;</span><br><span class="line">        <span class="keyword">if</span>(heap[x] &lt; heap[p]) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[x], heap[p]);</span><br><span class="line">        p = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n/2;i++)</span></span><br><span class="line">    <span class="comment">//! 叶子的一个下标是 n/2向下取整+1</span></span><br><span class="line">    <span class="comment">//! 必须从底部开始调整，不然不能保持之前的子堆的有序性质</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">        downAdjust(i,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///!delete element</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[n--];<span class="comment">//! n--</span></span><br><span class="line">    downAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///!!!up</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = p /<span class="number">2</span> ; x &gt;= <span class="number">1</span>; x /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[x] &gt; heap[p]) <span class="keyword">break</span>;</span><br><span class="line">        swap(heap[x], heap[p]);</span><br><span class="line">        p = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[++n] = x;</span><br><span class="line">    upAdjust(n,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///! head sort</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headSort</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buildHeap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">2</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(heap[<span class="number">1</span>],heap[i]);</span><br><span class="line">        downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//!! heap only have n-1 elements;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    show();</span><br><span class="line">    buildHeap();</span><br><span class="line">    insert(<span class="number">25</span>);</span><br><span class="line">    show();</span><br><span class="line">    headSort(n);</span><br><span class="line">    show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/DS/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9B%86%E5%90%88/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="二叉树集合"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:23:28.000Z" title="2020-08-07T04:23:28.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/DS/">DS</a></span><span class="level-item">4 minutes read (About 531 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/DS/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9B%86%E5%90%88/">二叉树集合</a></h1><div class="content"><p>（好像不怎么用心的样子呢）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This is Code of JJ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Problem      :</span></span><br><span class="line"><span class="comment">Source       :</span></span><br><span class="line"><span class="comment">Solution     :</span></span><br><span class="line"><span class="comment">AnyDetial    :</span></span><br><span class="line"><span class="comment">注意点：</span></span><br><span class="line"><span class="comment">1.递归边界是root为NULL</span></span><br><span class="line"><span class="comment">2.插入：</span></span><br><span class="line"><span class="comment">    查找失败--NULL--即为插入点</span></span><br><span class="line"><span class="comment">    利用插入创建时，第一个数据就是查找失败的点！</span></span><br><span class="line"><span class="comment">3.层序遍历：队列里存的是地址；</span></span><br><span class="line"><span class="comment">DateAndTime  :</span></span><br><span class="line"><span class="comment">CostofTime   :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *lchild,*rchild;</span><br><span class="line">    Node()</span><br><span class="line">    &#123;</span><br><span class="line">        lchild = <span class="literal">NULL</span>;</span><br><span class="line">        rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        data = a;</span><br><span class="line">        lchild = <span class="literal">NULL</span>;</span><br><span class="line">        rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> a)</span><span class="comment">//! create a node with new!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! find those nodes whose data is x and replace those data with x;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_node</span><span class="params">(Node* root, <span class="keyword">int</span> key, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==key) root-&gt;data = x;<span class="comment">//! a -&gt; data !</span></span><br><span class="line">    search_node(root-&gt;rchild,key,x);</span><br><span class="line">    search_node(root-&gt;lchild,key,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Node *&amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//! The</span></span><br><span class="line">    &#123;</span><br><span class="line">        root = newnode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;<span class="comment">//!the index begin with 0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;!</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">    preorder(root-&gt;lchild);</span><br><span class="line">    preorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerorder</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt;q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,t-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;lchild!=<span class="literal">NULL</span>) q.push(t-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(t-&gt;rchild!=<span class="literal">NULL</span>) q.push(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//!前序遍历和中序遍历重建树</span></span><br><span class="line"><span class="function">Node *<span class="title">create_in_pre</span><span class="params">( <span class="keyword">int</span> inorder[], <span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> preorder[], <span class="keyword">int</span> prel, <span class="keyword">int</span> prer)</span><span class="comment">//! in[l,r], pre[l,r],</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inl&gt;inr || prel&gt;prer) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> pos_in = inl;</span><br><span class="line">    <span class="keyword">for</span>(;pos_in&lt;=inr;pos_in++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[pos_in]==preorder[prel])<span class="comment">// find the index of root</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numleft = pos_in - inl;<span class="comment">// the number of left tree;</span></span><br><span class="line">    Node *root = newnode(preorder[prel]);</span><br><span class="line">    root-&gt;lchild = create_in_pre(inorder, inl, pos_in<span class="number">-1</span>, preorder, prel+<span class="number">1</span>, prel+numleft);</span><br><span class="line">    root-&gt;rchild = create_in_pre(inorder, pos_in+<span class="number">1</span>, inr, preorder, prel+numleft+<span class="number">1</span>, prer);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!后序遍历和中序遍历重建树</span></span><br><span class="line"><span class="function">Node *<span class="title">create_in_post</span><span class="params">(<span class="keyword">int</span> in[],<span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> post[], <span class="keyword">int</span> postl, <span class="keyword">int</span> postr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inl&gt;inr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Node *root = newnode(post[postr]);</span><br><span class="line">    <span class="keyword">int</span> pos = inl;</span><br><span class="line">    <span class="keyword">for</span>(;pos&lt;inr;pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[pos]==root-&gt;data) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = pos - inl;</span><br><span class="line">    root-&gt;lchild = create_in_post(in,inl,pos<span class="number">-1</span>,post,postl,postl+k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild = create_in_post(in,pos+<span class="number">1</span>,inr,post,postl+k,postr<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">-10</span>,<span class="number">15</span>,<span class="number">0</span>&#125; ,n = <span class="number">8</span>;</span><br><span class="line">    Node *root = create(a,n);</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    postorder(root);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> pre[<span class="number">10</span>] = &#123;<span class="number">1</span> ,<span class="number">-2</span> ,<span class="number">-10</span>, <span class="number">0</span>, <span class="number">3</span> ,<span class="number">5</span> ,<span class="number">7</span> ,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> in[<span class="number">10</span>] = &#123;<span class="number">-10</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> post[<span class="number">10</span>] = &#123;<span class="number">-10</span> ,<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span> ,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Node *newroot1 = create_in_pre(in,<span class="number">0</span>,<span class="number">7</span>,pre,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    Node *newroot2 = create_in_post(in,<span class="number">0</span>,<span class="number">7</span>,post,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"!recreate!\n"</span>;</span><br><span class="line">    inorder(newroot1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    inorder(newroot2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0%E6%A2%97%E6%A6%82/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="数据库管理复习梗概"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:22:24.000Z" title="2020-08-07T04:22:24.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/DB/">DB</a></span><span class="level-item">21 minutes read (About 3165 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/DB/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0%E6%A2%97%E6%A6%82/">数据库管理复习梗概</a></h1><div class="content"><p>参考书籍：《数据库系统教程》3Ed. 施伯乐</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul>
<li><p>数据库（DateBase，DB）：长期存储在计算机内的数据集合</p>
</li>
<li><p>数据库管理系统（DataBase Mangement System, DBMS）：管理数据库的软件，其操作包括CRUD。</p>
</li>
<li><p>数据库系统（DataBase System，DBS）：由计算机软硬件和数据资源组成的计算机系统。</p>
</li>
<li><p>实体联系（Entity Relationship，ER）模型：对实体和实体之间关系的抽象。</p>
</li>
<li><p>概念模型：对用户需要的建模，往往建立出了ER模型。</p>
</li>
<li><p>逻辑模型：表达了数据库整体逻辑的模型。最重要的是关系模型，对象模型，还包括层次模型、网状模型。</p>
</li>
<li><p>逻辑独立性：应用程序与数据库的逻辑结构保持独立，即数据库的逻辑结构由DBMS即使变化了，应用程序也无需变化。</p>
</li>
<li><p>物理独立性：应用程序与数据库的物理结构保持独立，即数据库在磁盘的保存格式有数据库管理系统设置，应用程序无需关注数据库的物理结构。</p>
<blockquote>
<p>两种独立性都是将数据在磁盘中的定义和存储格式独立分离出去，因而简化应用程序编程，减少了程序维护和修改。</p>
</blockquote>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3></li>
<li><p>关系模型：简单理解为一个二维表格</p>
</li>
<li><p>子模式：用户需要用到数据的描述（？）</p>
<ul>
<li>记录\元祖：表格中的一行数据</li>
<li>关系\实例：元祖的集合</li>
<li>字段\属性：表的一列的<strong>列本身</strong></li>
<li>元数：属性的个数</li>
<li>基数：元祖个数</li>
</ul>
</li>
<li><p>关键码\key\键：字段或者字段的集合</p>
<ul>
<li>超键（super key）：可以唯一标识元祖的键</li>
<li>候选键（Candidate key）：不含多余属性的超键</li>
<li>主键（Primary key）：用户选择的候选键</li>
<li>外键（Foreign key）：其他关系模型的主键</li>
</ul>
</li>
<li><p>完全性规则（*表示省略相同成分）：</p>
<ul>
<li>实体：主键不可缺</li>
<li>参照：外键指向的元祖不可空</li>
<li>用户：用户可自己定义完整性</li>
</ul>
</li>
<li><p>关系代数</p>
<ul>
<li>并：两个关系模型的去重合并</li>
<li>差：关系模型AB相减</li>
<li>笛卡尔积：两个关系模型的全排列</li>
<li>投影：选择一个关系模型若干列</li>
<li>选择：选择一个关系模型的若干行</li>
<li>————</li>
<li>交：求两个关系模型的公共元祖</li>
<li>连接：筛选出符合条件的两个模型的笛卡尔积</li>
<li>自然连接：条件是公共字段相同的连接，并去除公共字段</li>
<li>除法：A/B即尽可能 包含了所有B字段的且除了B字段A字段值相同的元祖集合。（简要的记忆为寻找公因数）</li>
<li>————</li>
<li>改名</li>
<li>广义投影：允许投影中使用算术运算</li>
<li>外连接：就是把自然连接过程中丢失的元祖加以填充空值（NULL）并加入自然连接的结果</li>
<li>左（右）外连接：类似于外连接，就是把单单是左（右）边的模型丢弃掉的元祖加入</li>
<li>半连接：自然连接后投影到一个关系模型（不残缺的那边）上</li>
</ul>
</li>
</ul>
<hr>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>基本表：关系模式<ul>
<li>表的三种类型：<ul>
<li>基本表：实际存储在数据库中的表</li>
<li>视图：若干表和其他视图组成的表的定义，在用户面前都是一样的</li>
<li>导出表：查询导出的表</li>
</ul>
</li>
</ul>
</li>
<li>存储文件：存储模式（文件存储的方式）</li>
<li>视图：子模式</li>
<li>行：元祖</li>
<li>列：属性</li>
<li>SQL模式（schema）：<strong>表</strong>和<strong>约束</strong>的<strong>集合</strong>（可能有多个表）</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>模式创建</strong>：<code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</code></p>
<p><strong>模式撤销</strong>：<code>DROP SCHEMA &lt;模式名&gt; [CASCADE | RESTRICT]</code> ; <code>CASCADE</code>即级联式，撤销下属的模式中所有的基本表、视图、索引；<code>RESTRICT</code>即约束式，仅当模式不存在任何下属元素才允许撤销；（<code>SCHEMA</code>可以替换为<code>DATABASE</code>）</p>
<p><strong>添加自定义类型</strong>：<code>CREATE DOMAIN &lt;YOUR_DOMAIN&gt; CHAR(8)</code>这里把<code>CHAR(8)</code>定义成了自定义的domain名，可直接使用</p>
<p><strong>创建基本表</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;基本表名&gt;</span><br><span class="line">	(</span><br><span class="line">      --列表类型</span><br><span class="line">      T#  CHAR(4) NOT NULL, --默认允许空值（与主键定义冗余）</span><br><span class="line">	 TITLE CHAR(10), </span><br><span class="line">     -- 完整性约束</span><br><span class="line">	 PRIMARY KEY(T#)    -- 定义主键</span><br><span class="line">     FOREIGN KEY(C#) REFERENCES S(C#) --定义外键为C#，且对应S表的主键C#</span><br><span class="line">    </span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p><strong>插入数据：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSRET</span><br></pre></td></tr></table></figure>

<p><strong>修改基本表：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--增加表的列</span><br><span class="line">ALTER TABLE &lt;基本表名&gt; ADD  &lt;列名&gt; &lt;类型&gt;</span><br><span class="line">--删除表的列</span><br><span class="line">ALTER TABLE &lt;基本表名&gt; DROP &lt;列名&gt; [CASCADE | RESTRICT ]</span><br><span class="line">	-- CASCADE表明删除列的同时删除所有使用该列约束和视图</span><br><span class="line">--修改列形状</span><br><span class="line">ALTER TABLE &lt;基本表名&gt; MODIFY   &lt;列名&gt; &lt;类型&gt;</span><br></pre></td></tr></table></figure>

<p><strong>撤销基本表：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE &lt;基本表名&gt; [ CASCADE| RESTRICT] --同理</span><br></pre></td></tr></table></figure>

<p>索引：？？</p>
<p><strong>数据查询：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--- 基本sql查询语句</span><br><span class="line">SELECT 属性1,属性2.....属性n </span><br><span class="line">FROM 表1,表2......表N</span><br><span class="line">WHERE 关系表达式</span><br><span class="line"></span><br><span class="line">---sql语句之间可以使用UNION（并） \ INTERSECT（交） \ EXCEPT（差）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----嵌套查询，括号中的子查询优先进行</span><br><span class="line">SELECT 属性1,属性2.....属性n </span><br><span class="line">FROM 表1,表2......表N</span><br><span class="line">WHERE 关系表达式 IN (</span><br><span class="line">	SQL查询语句</span><br><span class="line">	)</span><br><span class="line">	---嵌套查询的速度往往比笛卡尔积的运算速度快</span><br></pre></td></tr></table></figure>

<p><strong>待补充：更复杂的还有相关子查询（。。）、where使用的运算符,以及（P85~P101）</strong></p>
<hr>
<h2 id="关系数据库的规范设计"><a href="#关系数据库的规范设计" class="headerlink" title="关系数据库的规范设计"></a>关系数据库的规范设计</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>函数依赖（FD，Functional Dependency）：</strong>当一个基本表中的属性集Y是属性集X的”函数值”(即X的值可以确定出唯一的Y)，就说明了X-&gt;Y,或者说Y依赖于X，这个基本表存在函数依赖。</p>
<p>（函数蕴涵P120）</p>
<p><strong>逻辑蕴涵：</strong>若函数依赖集合F中存在的FD X→YX→Y和Y→ZY→Z，存在X→ZX→Z成立，则可称为F逻辑蕴涵X→ZX→Z 。</p>
<p><strong>闭包：</strong> 就是函数依赖集上FF所有函数依赖和逻辑蕴涵推出来的依赖关系的完整集合，即为F+F+ 闭包。</p>
<p><strong>FD推理规则：</strong> A→BA→B</p>
<ul>
<li>自反性：AA自身能确定出自身的子集，这样推导出来的FD也称<strong>平凡的FD</strong></li>
<li>增广性：依赖两边可以同时增加变量</li>
<li>传递性：可传递（逻辑蕴涵）</li>
<li>————</li>
<li>合并性：同时能推导出两个结果BCBC，就能推导出两个结果的和B,CB,C</li>
<li>分解性：与合并性相反，是将结果BCBC拆分成两个B,CB,C</li>
<li>伪传递性：传递过程中需要添加一个因素，X→Y,YZ→WX→Y,YZ→W 等价于XZ→WXZ→W</li>
<li>复合型：两个FD可以两边组成成一个FD</li>
<li>————</li>
<li>可以使用FD的定义来定义超键和候选键</li>
</ul>
<p>当函数依赖集的闭包相等时，函数依赖集<strong>等价</strong>。可定义最难小函数依赖集：</p>
<ul>
<li>FD右边都是单属性；</li>
<li>无冗余FD</li>
<li>FD的左边的属性集不是冗余的（子集无法代替集</li>
</ul>
<p><strong>求出R的最小依赖集算法</strong></p>
<ol>
<li>分解FD的右边属性集，并去重</li>
<li>消除左边冗余的FD</li>
<li>消除R中冗余FD</li>
</ol>
<p>模式分解特性</p>
<p><strong>无损分解：</strong>把数据库模式分解为多个模式，并将分解的模式全部自然连接发现多出了元祖（<strong>寄生元祖</strong>）（也就是有损分解，实际上是信息的丢失，信息论！不确定性越大，信息量越小）。反之如果元祖不多不少就是无损分解。</p>
<blockquote>
<p>上述讨论中假设模式存在一个“范关系”rr，可以分解为多个子关系rkrk。</p>
<p>当然也存在不存在范关系的rr，在连接过程中某个riri子关系的元祖会被丢失掉，这个被称为破环范关系的<strong>悬挂元祖</strong></p>
</blockquote>
<p><strong>依赖保持：</strong>就是分解的模式中的依赖的并与原模式的依赖等价。</p>
<p>无损分解的测试方法：略（p128）</p>
<p>保持函数依赖的分解：略（p129）</p>
<h3 id="关系模式的范式"><a href="#关系模式的范式" class="headerlink" title="关系模式的范式"></a>关系模式的范式</h3><p><strong>第一范式：</strong>关系模式的R的关系r的属性值都是不可分的单一的（反例“AB”）</p>
<p><strong>第二范式：</strong>每个非主属性完全依赖于候选键（挺严格的）。不完全依赖也就是局部依赖意味着A→BA→B 这个条件存在BB依赖于AA的一个子集，（注意这个FD推理规则A1不一样）</p>
<blockquote>
<p>主属性：关系模式中R的候选键中的属性</p>
<p>化解成第二范式的算法：将一个局部依赖X→YX→Y的属性XYXY提出来形成一个关系，同时在原有属性集UU形成一个新的关系U−YU−Y；重复上述动作直到没有局部依赖。</p>
</blockquote>
<p><strong>第三范式：</strong>每个非主属性都不传递依赖与候选键，即为第三范式</p>
<blockquote>
<p>传递依赖就是：X→Y,Y→ZX→Y,Y→Z 且X不依赖与Y，Z不是Y的子集</p>
</blockquote>
<p><strong>BC范式：</strong> 每个主属性不都传递依赖于候选键，则为BC范式。（相比于第三范式排除了主属性对候选键的传递依赖）</p>
<p>分解方法：略（p134）</p>
<hr>
<h2 id="数据库设计和ER模式"><a href="#数据库设计和ER模式" class="headerlink" title="数据库设计和ER模式"></a>数据库设计和ER模式</h2><h3 id="数据库设计过程："><a href="#数据库设计过程：" class="headerlink" title="数据库设计过程："></a>数据库设计过程：</h3><ol>
<li>规划：调查、可行性分析等</li>
<li>需求分析：分析用户活动，系统范围，分数用户数据，数据流图；数据字典(描述数据)</li>
<li>概念设计：数据抽象设计局部概念模型和全局概念模型（比如ER）</li>
<li>逻辑设计：把上一步概念模型转化符合具体DBMS的逻辑模型，比如关系模型；设计外模型（api接口）；评价模型；修正模型</li>
<li>物理设计：存储记录结构设计；确定存储位置；完全性和安全性考虑；</li>
</ol>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p><strong>组成结构：</strong></p>
<ul>
<li>实体：数据对象</li>
<li>联系：实体之间的关系<ul>
<li>元数\度数（degree）：联系所涉及的实体个数</li>
<li>数值约束：<ul>
<li>（x,y）表示该实体的联系的<strong>另一方</strong>的数量限制</li>
<li>N或者：表示对实体在联系中的<strong>映射数量关系</strong></li>
</ul>
</li>
<li>参与约束：<ul>
<li>双直线：完全参数该联系</li>
<li>单直线：部分参与该联系</li>
</ul>
</li>
</ul>
</li>
<li>属性：实体的特征<ul>
<li>简单属性和复合属性：在于可不可分</li>
<li>单值和多值属性：在于可不可同时取多个值<ul>
<li>替换：<ul>
<li>多值属性替换为一个新的实体类型</li>
<li>用多个单值属性代替</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>ER转关系模型的算法：</strong></p>
<ol>
<li>实体直接转化为一个关系</li>
<li>关系的转化方法<ol>
<li>一元关系直接转化属性</li>
<li>1：1关系转化为一个实体的外键和属性</li>
<li>1：N关系转化”N处”实体的外键和属性</li>
<li>N:M关系转化为两个实体的主键和一个属性</li>
<li>————</li>
<li>三元关系可类比二元关系的转化方法（太无聊了不看了）</li>
</ol>
</li>
</ol>
<hr>
<h2 id="数据库存储结构"><a href="#数据库存储结构" class="headerlink" title="数据库存储结构"></a>数据库存储结构</h2><h4 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h4><p>定长存储：连接方法和顺序方法</p>
<p>不定长存储解决方案：</p>
<ul>
<li><p>字符串表示形式：分槽式页结构（定长的首部顺序排列并记录剩余数据的其实起始地址，不定长的二进制数据从低端生长）</p>
</li>
<li><p>变长记录的定长表现形式：预留空间、固定块的溢出块相补充、定长块的连接形式（p187）</p>
<p>(不想看了555)</p>
</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/CSAPP/CSAPP%E7%AC%94%E8%AE%B02/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="CSAPP笔记2"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:16:59.000Z" title="2020-08-07T04:16:59.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/CSAPP/">CSAPP</a></span><span class="level-item">4 minutes read (About 655 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/CSAPP/CSAPP%E7%AC%94%E8%AE%B02/">CSAPP笔记2</a></h1><div class="content"><h1 id="程序结构和执行过程"><a href="#程序结构和执行过程" class="headerlink" title="程序结构和执行过程"></a>程序结构和执行过程</h1><p>本章主要讲解程序在机器级代码上的执行过程以及程序编译翻译过程。</p>
<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>相比人类熟悉的代表了十指的十进制，二进制的稳定性、表达形态少、对硬件芯片的友好性是建造计算机的更优选择。典型的二进制应用就是记录数值，<code>float-point encoding</code> 和 <code>Unsigned encoding</code>就是代表。</p>
<blockquote>
<p>有趣的是，计算机的算术运算过程即使是对溢出运算也会满足结合律(associative)</p>
</blockquote>
<p>数值组成的bit有限就造成了数据表达的有限，从而引出的计算溢出，甚至安全问题都是编程者需要考虑的。</p>
<hr>
<p>虚拟空间(virtual memory)是计算机操作系统提供的虚拟空间，以C语言的指针举例，一个C pointer指向的一定是一个数据类型(int, float, or structure)的第一个字节的虚拟地址。C语言本身会组织类型信息(<em>type</em> information)以便获取指针指向的数据内容，但是在机器级的代码中所有的程序对象都是一样的bit。(p63)</p>
<blockquote>
<p>C语言在早期计算机语言发展占据重要的位置，比如提供了内存分配器（memory allocator）——the malloc library function。C语言的编译可以对GCC（Gun Compiler Collection）添加参数以控制编译版本</p>
<ul>
<li><code>gcc -std=c11 prog.c</code> 指定了C11标准版本</li>
<li><code>-std=c99</code>指定了C99版本</li>
<li><code>-ansi</code>和<code>-std=c89</code>指定了C90版本</li>
<li><code>-std=gnu11</code>指定了GNU项目的开发的一个版本，包括了ISO C11的内容</li>
</ul>
<p>C语言支持向后兼容（backward compliale，“后”就是指过去，而非口语所说的“以后”），那么C语言编译的32bit的程序也可以在64位机子上跑。但是64bit的程序不能在32位的机子上跑。</p>
<ul>
<li><code>gcc -m32 prog.c</code> 设置了编译的位数，同理<code>-m64</code>设置了64bits</li>
</ul>
</blockquote>
<blockquote>
<p>C的指针有两个方面——值和类型，值指向了指针指向的内容的地址，类型指出了指向的地址的存放的信息的种类。</p>
</blockquote>
<p>十六进制计数 （Hexadecimal Notation）</p>
<p><a href="http://static.come2rss.xyz/image-20200503124826544.png"><img src="http://static.come2rss.xyz/image-20200503124826544.png" alt="image-20200503124826544"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503124826544.png">image-20200503124826544</a></p>
<p>1000多页是时候考虑时间问题了，有更值得去做事情去干，暂时读的话还不读英文版了。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/CSAPP/CSAPP%E7%AC%94%E8%AE%B01/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="CSAPP笔记1"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:16:31.000Z" title="2020-08-07T04:16:31.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/CSAPP/">CSAPP</a></span><span class="level-item">25 minutes read (About 3767 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/CSAPP/CSAPP%E7%AC%94%E8%AE%B01/">CSAPP笔记1</a></h1><div class="content"><h1 id="Programmer’s-Perspective-–3th-edition"><a href="#Programmer’s-Perspective-–3th-edition" class="headerlink" title="Programmer’s Perspective )–3th edition"></a>Programmer’s Perspective )–3th edition</h1><p>考完了研究生，浪荡了许久，终于肯安下心来钻研提升内功，就从这本书开始吧，抄录两端话送给自己的激励！</p>
<blockquote>
<p>读完了本书以后你将成为极少数的“牛人”，这些“牛人”知道事情是怎么运作的，也知道当事情出现故障是如何修复。你写的程序将能更好利用操作系统和系统软件提供的功能，对各种操作条件和运行时的参数都能正确操作，运行起来更快，并避免出现使得成型容易受到网络攻击的缺陷。同时你也要做好更深入探究的准备。研究像编译器，计算机体系结构，操作系统，嵌入式系统、网络互连和网络安全这样高级题目。——译者序</p>
<p>We cover data representations, mechine level representations of C programs, processor architecture, program optimizations, the memory hierarchy, exceptional control flow(exceptions, interrupts, processes, and Unix signals), virtual memory and memory management, system-level I/O, basic network programming, and concurrent programming. THes concepts are suppeorted by series of fun and hands-on lab assignments. —— CSAPP online.</p>
</blockquote>
<p>正如书籍的题目，此书的编写者考虑到大多数人都不会编写一个OS或者制作一个CPU，那么从一个程序员的角度可以更具体而实用的理解类似于C语言是怎么编译成汇编语言，不同的设置是如何影响计算机性能的，代理是如何工作的计算机<strong>基础内容</strong>。此书着手于x86处理器机器和Linux类系统，并用C作为工具来实操，提供了多个Lab。</p>
<h1 id="CHAPTER-1-The-wonder-of-computer-system"><a href="#CHAPTER-1-The-wonder-of-computer-system" class="headerlink" title="CHAPTER 1 The wonder of computer system"></a>CHAPTER 1 The wonder of computer system</h1><h2 id="伟大的编译器"><a href="#伟大的编译器" class="headerlink" title="伟大的编译器"></a>伟大的编译器</h2><p>一个最基本的C源文件是由N个ASCII码组成的数据串，将以文件的形式存储在计算机磁盘中。而每个ASCII都有由8bit组成，或者说是一字节组成，容易忽视的是，文本每一行的末尾都有<code>\n</code>符号，其编码为<code>10</code>，或者是<code>00001010</code>。</p>
<blockquote>
<p>中文的注释计算机将怎么处理？猜测可能有文件保存读取编码方式有关。</p>
</blockquote>
<p>在linux环境下每一个C源文件都会被编译驱动(compiler driver)所编译为machine-language instructions 组成的可执行程序。</p>
<p><a href="http://static.come2rss.xyz/image-20200503124858005.png"><img src="http://static.come2rss.xyz/image-20200503124858005.png" alt="image-20200503124858005"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503124858005.png">image-20200503124858005</a></p>
<blockquote>
<p>Pre-processor：预处理器</p>
<p>Assembler：汇编器</p>
<p>Linker：链接器</p>
</blockquote>
<p><code>gcc -o hello hello.c</code> 运作四个步骤：Preprocessing phase将<code>#include&lt;stdio.h&gt;</code>的语句所标记的系统头文件stdio.h内容插入到程序文本中，并形成hello.i；Compilation phase:将hello.i翻译成assembly-language program(汇编程序)；</p>
<blockquote>
<p>汇编语言作用之处在于给多种高层次语句的不同编译器提供同一个低层次的输出语言。</p>
</blockquote>
<p>Assembly phase： 汇编器将汇编程序hello.s翻译成机器及的二进制relocatable object program(可重定位程序)。</p>
<blockquote>
<p>GCC是伟大的自由(free speach的自由)软件思想主导的运动GUN（GUN’s Not Unix, hh递归的）的产物，其功能强大，能够支持多种语言。同样的GUN产物还有GDB debugger，EMACS editor。</p>
</blockquote>
<p>Linking phase：linker将预编译好的printf.o文件链接到可重定位文件hello.o形成了最终的可执行文件hello。</p>
<h2 id="重视编译器的效率问题"><a href="#重视编译器的效率问题" class="headerlink" title="重视编译器的效率问题"></a>重视编译器的效率问题</h2><p>作为现代工具的使用者，我们程序员无需重造一个编译器或者了解其中的构造，但是更有意义的是去了解如何编写代码才能让编译器翻译出更有效率的代码。书中提出了几个例子：<code>if-else</code>是否比<code>switch</code>更有效？<code>for</code>和<code>while</code>哪个效率更高？pointer referenes 是否比数组下标更快？为什么简单的重新放置算数表达式参数(arithmetic expression)可以提高效率？</p>
<h2 id="处理器读取和接触存储在内存中的指令"><a href="#处理器读取和接触存储在内存中的指令" class="headerlink" title="处理器读取和接触存储在内存中的指令"></a>处理器读取和接触存储在内存中的指令</h2><p>commmand-line interpreter ——shell 可以接受指令并运行，如果输入的指令一个word不是built-in shell command，那么shell就会默认该字符为可执行文文件并load和执行,如<code>./hello</code>将执行可执行文件hello，shell会等待程序结束(terminate)，之后输出提示符(a prompt)。</p>
<h2 id="系统硬件组织"><a href="#系统硬件组织" class="headerlink" title="系统硬件组织"></a>系统硬件组织</h2><p><a href="http://static.come2rss.xyz/image-20200503124915375.png"><img src="http://static.come2rss.xyz/image-20200503124915375.png" alt="image-20200503124915375"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503124915375.png">image-20200503124915375</a></p>
<blockquote>
<p>一个Inter风格的硬件组织图</p>
</blockquote>
<h3 id="总线-Buses"><a href="#总线-Buses" class="headerlink" title="总线(Buses)"></a>总线(Buses)</h3><p>类似人体血管的贯通系统内部传输固定大小电子信息比特的管道(conduits)，通常这个大小的值不固定。</p>
<h3 id="I-O-设备-I-O-Devices"><a href="#I-O-设备-I-O-Devices" class="headerlink" title="I/O 设备(I/O Devices)"></a>I/O 设备(I/O Devices)</h3><p>I/O设备是计算机系统负责接收发送给外部世界的设备，通过控制器(contrlllers)和适配器(adapter)连接到I/O总线。控制器和适配器的目的为了传输信息，但是控制器是由计算机原有的芯片控制的或者说是在母板(motherboard)上的电路印刷而成的，适配器是可以插入母板插槽的芯片卡。常见的外部设备有磁盘、显示器和鼠标键盘。</p>
<h3 id="主存-Main-Memory"><a href="#主存-Main-Memory" class="headerlink" title="主存(Main Memory)"></a>主存(Main Memory)</h3><p>主存是系统在运行程序时的暂时存放数据和指令的空间。物理上，其一般有动态随机存储芯片(dynamic random access memory, DRAM)芯片组成。逻辑上说内存实际就是一个地址从零开始的线性字节数组。另外系统指令可由多个比特组成，数据项大小随数据类型不同而变化。</p>
<blockquote>
<p>原句： In general, each of the machine instructions that constitute a program can <strong>consist of</strong> a variable number of bytes</p>
</blockquote>
<h3 id="处理器-Processor"><a href="#处理器-Processor" class="headerlink" title="处理器(Processor)"></a>处理器(Processor)</h3><p>中央处理器(central processing unit)是计算机的心脏，负责解释(interpet)和执行(execute)从内存运送到CPU的IR(instrruction register)的指令。简单的说，CPU包括了其运算器部分（如ALU，寄存器等）和控制器部分（如PC，IR等等）。在CPU运行过程中，CPU解释PC指向的指令，根据指令执行操作并更新PC值。</p>
<p>简单来说，指令包括了Load、Store、Operate(数据运算)和Jump类。</p>
<h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p>从硬件底层在理解一次刚刚的运行过程，在我们打入<code>./hello</code>命令指示，shell程序将键盘输入的字符通过寄存器和总线存储到内存中，当输入<code>Enter1</code>后shell开始执行shell程序。</p>
<blockquote>
<p>有趣！</p>
</blockquote>
<p><a href="http://static.come2rss.xyz/image-20200503124936718.png"><img src="http://static.come2rss.xyz/image-20200503124936718.png" alt="image-20200503124936718"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503124936718.png">image-20200503124936718</a></p>
<p>shell将原本存储在Disk中的代码和数据复制到内存中。系统借助了直接存储器存储器(direct memory access, DMA)而无需通过CPU传输数据直达主存。</p>
<p><a href="http://static.come2rss.xyz/image-20200503124954066.png"><img src="http://static.come2rss.xyz/image-20200503124954066.png" alt="image-20200503124954066"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503124954066.png">image-20200503124954066</a></p>
<p>最后，CPU运行hello程序，执行对应指令，并把数据<code>hello,world\n</code>复制到寄存器并打印到屏幕。</p>
<p><a href="http://static.come2rss.xyz/image-20200503125006147.png"><img src="http://static.come2rss.xyz/image-20200503125006147.png" alt="image-20200503125006147"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125006147.png">image-20200503125006147</a></p>
<blockquote>
<p>其中必然包括了中断技术。</p>
</blockquote>
<h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>从上文的例子看到程序运行过程中存在大量数据和指令移动，而现有的机械结构却造成了存储器速度和容量之间的取舍难题。往往速度快的存储器（比如寄存器）容量却很小，相反的容量大的存储器比如磁盘、光盘存储速度都很慢。为了解决这一难题，现在计算机配备了高速缓存(cache)，甚至是多级高速缓存。其运用了局部性原理(<em>locality</em>)。这对程序<strong>性能</strong>有着重要影响。</p>
<blockquote>
<p><em>locality</em>:程序会倾向于使用局部区域的代码和数据</p>
</blockquote>
<p><a href="http://static.come2rss.xyz/image-20200503125016708.png"><img src="http://static.come2rss.xyz/image-20200503125016708.png" alt="image-20200503125016708"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125016708.png">image-20200503125016708</a></p>
<p>cache的加入让我们有一个更美妙的想法：存储器层次结构(memory hierarchy)，这种结构从上到下，速度逐渐变慢，价格变低，同时容量上升。更有趣的是，上层可以视为相邻下层的缓存，相邻下层可以视为上层的存储，比如分布式系统中的本地磁盘就是远程存储系统的缓存。</p>
<h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>hello程序运行中时，外部数据的输入和打印屏幕这些操作硬件的举动都不是源程序或者shell所做的，都是使用了操作系统所提供的接口。操作系统是计算机硬件和应用软件之间的管理层，一方面负责保护硬件不直接受到应用软件的操作，另一方面提供给所有应用软件统一且简单的接口。</p>
<p><a href="file:///D:/Blogfile/pic/CSAPP阅读笔记/image-20200503125027579.png"><img src="file:///D:/Blogfile/pic/CSAPP%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20200503125027579.png" alt="image-20200503125027579"></a></p>
<p><a href="file:///D:/Blogfile/pic/CSAPP阅读笔记/image-20200503125027579.png">image-20200503125027579</a></p>
<p>操作系统通过几个抽象的功能来实现对计算机资源的管理，如下图。</p>
<blockquote>
<p>确实抽象，Processes本身带着运行程序的位置信息、进程信息和源程序信息，也就是说Processes是对三者的管理。其他类似</p>
</blockquote>
<p><a href="http://static.come2rss.xyz/image-20200503125035839.png"><img src="http://static.come2rss.xyz/image-20200503125035839.png" alt="image-20200503125035839"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125035839.png">image-20200503125035839</a></p>
<h3 id="进程-Processes"><a href="#进程-Processes" class="headerlink" title="进程(Processes)"></a>进程(Processes)</h3><p>即使是单核处理器(<em>uniprocessor</em>)计算机也可以同时（宏观）运行多个进程，操作系统在记录并控制了所有进程的上下文(<em>content</em>)。操作系统通过保存当前的进程上下文，并载入一个新进程的上下文可以实现进程切换。</p>
<p><a href="http://static.come2rss.xyz/image-20200503125045850.png"><img src="http://static.come2rss.xyz/image-20200503125045850.png" alt="image-20200503125045850"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125045850.png">image-20200503125045850</a></p>
<p>一个正在运行的进程可以通过系统调用来调用操作系统的功能，比如读写磁盘，执行另一个程序创建新进程。</p>
<h3 id="线程-Threads"><a href="#线程-Threads" class="headerlink" title="线程(Threads)"></a>线程(Threads)</h3><p>线程作为“轻量级”的进程，能快速访问同进程下的共享资源，占有更少的内存空间，运行效率更高，可以充分利用多核计算机的计算效能。</p>
<h3 id="虚拟内存（Virutual-Memory）"><a href="#虚拟内存（Virutual-Memory）" class="headerlink" title="虚拟内存（Virutual Memory）"></a>虚拟内存（Virutual Memory）</h3><p>顾名思义，虚拟内存是操作系统在内存的基础上虚拟空间。对于软件来说虚拟内存唯一可以接触到的空间，物理内存对他们是透明的。</p>
<p><a href="http://static.come2rss.xyz/image-20200503125120329.png"><img src="http://static.come2rss.xyz/image-20200503125120329.png" alt="image-20200503125120329"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125120329.png">image-20200503125120329</a></p>
<p>从低地址到高地址所存放的内容分别是：</p>
<ul>
<li>程序的代码和数据</li>
<li>读写数据</li>
<li>堆(heap)：可以由进程通过程序malloca，new动态创建</li>
<li>分享库(shared libraries)：比如C++的<code>math</code>库</li>
<li>栈：在用户调用函数增长，返回函数时减小，</li>
<li>内核虚拟内存：保留给内核程序的空间。用户应用程序无法读取这部分内容，也无法直接掉调用。</li>
</ul>
<h3 id="文件-Files"><a href="#文件-Files" class="headerlink" title="文件(Files)"></a>文件(Files)</h3><p>至少在Unix I/O上，file系统将各式的外设输入输出设备、甚至网络建模成一个文件。统一的文件形式给系统操作员极大的方便。</p>
<blockquote>
<p>linux: a complex, Posix-compliant version of the Unix operating system.</p>
<p>posix，Portable Operating System Interface X——可移植操作系统接口</p>
</blockquote>
<h2 id="网络：计算机与其他系统的沟通桥梁"><a href="#网络：计算机与其他系统的沟通桥梁" class="headerlink" title="网络：计算机与其他系统的沟通桥梁"></a>网络：计算机与其他系统的沟通桥梁</h2><blockquote>
<p>讲的太粗略，不计</p>
</blockquote>
<h2 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h2><blockquote>
<p>This <strong>concludes our initial whirlwind tour</strong> of systems. An important idea to take away from this discussion is that a system is more than just hardware. It is a collection of intertwined hardware and systems software that must cooperate in order to achieve the ultimate goal of running application programs.</p>
</blockquote>
<h3 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a>Amdahl’s Law</h3><p>Amdahl’s Law假设简单系统的各个部件线性工作，提升一个部件的效率其实对整齐来说提升并不明显。</p>
<p><a href="http://static.come2rss.xyz/image-20200503125132267.png"><img src="http://static.come2rss.xyz/image-20200503125132267.png" alt="image-20200503125132267"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125132267.png">image-20200503125132267</a></p>
<h3 id="并发-Concurrency-和并行-Parallelism"><a href="#并发-Concurrency-和并行-Parallelism" class="headerlink" title="并发(Concurrency)和并行(Parallelism)"></a>并发(Concurrency)和并行(Parallelism)</h3><p>并发是对计算机同时运行多个事件的广义概念。并行是指？？？</p>
<p>在分时(time-sharing)操作系统上，所谓的并发仅仅只是一种模拟(simulated)，通过不断的切换进程（在进程(Process-Level Concurrency)级别上 ）让电脑同时相应多个用户的操作。而在线程级别(Threa-Level)上，即时在单核对一个单一的进程也有执行的多重控制流。</p>
<p>随着由多个有单独的操作系统内核管理的单个处理器组成的多核处理器(multiple processors)的到来，多核操作系统诞生了，随之而来的是超线程(hyperthreading)！</p>
<p><a href="http://static.come2rss.xyz/image-20200503125144846.png"><img src="http://static.come2rss.xyz/image-20200503125144846.png" alt="image-20200503125144846"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125144846.png">image-20200503125144846</a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125157325.png"><img src="http://static.come2rss.xyz/image-20200503125157325.png" alt="image-20200503125157325"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125157325.png">image-20200503125157325</a></p>
<p>超线程（也称为<em>sinultaneous multi-threading</em>）是一种允许一个核同时执行的多个控制流，涉及了部分硬件的多分设计，比如PC(program countes)，寄存器文件，而其余硬件只设一份，比如浮点数计算。可以说，在并发概念提出50年的铺垫后，多核处理器和超线程的出现才引爆了对多线程编程应用和并行的极大热情。（Eng. P55）</p>
<p>指令级并行通过多核处理的<strong>多核处理</strong>能力，以及<strong>现代流水线架构</strong>来实现。</p>
<p>单指令多数据(<em>SIMD，single-instruction, multile-data</em>)并行是通过特殊硬件允许一条指令同时进行多重操作。常常用于处理图像、声音等数据。</p>
<h3 id="抽象-abstraction-的重要性"><a href="#抽象-abstraction-的重要性" class="headerlink" title="抽象(abstraction)的重要性"></a>抽象(abstraction)的重要性</h3><blockquote>
<p>计算机最重要的两个概念——抽象和局部性原理</p>
</blockquote>
<p>抽象在计算机领域无处不在，提供给调用者的统一的函数接口API(Application program inteface)是函数的抽象，文件本身就是输出输入设备和物理数据的抽象，虚拟内存是内存和文件的抽象，进程是指令和数据的抽象，而计算机本身也是一个运行在硬件上的虚拟机(可见开头图)</p>
<blockquote>
<p>终于读完了一个综述，开心 :heart: :happy::happy::happy:~~于2020.04.27.10:17</p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/CN/CNAME%E5%92%8CA%E8%AE%B0%E5%BD%95/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="CNAME和A记录"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:15:24.000Z" title="2020-08-07T04:15:24.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/CN/">CN</a></span><span class="level-item">3 minutes read (About 495 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/CN/CNAME%E5%92%8CA%E8%AE%B0%E5%BD%95/">CNAME和A记录</a></h1><div class="content"><h2 id="域名解析中A记录、CNAME记录的区别和联系"><a href="#域名解析中A记录、CNAME记录的区别和联系" class="headerlink" title="域名解析中A记录、CNAME记录的区别和联系"></a>域名解析中A记录、CNAME记录的区别和联系</h2><p><strong>域名解析</strong>就是域名申请后做的到IP地址的转换过程。域名的解析工作由DNS服务器完成。</p>
<p><strong>A (Address) 记录</strong>是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</p>
<p><strong>CNAME记录</strong>即：别名记录。这种记录允许您将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就 “<a href="http://www.mydomain.com"/">www.mydomain.com”</a> 和“mail.mydomain.com”。实际上他们都指向“host.mydomain.com”。</p>
<p><strong>两者的区别在于</strong>A记录就是把一个域名解析到一个IP地址（Address，特制数字IP地址），而CNAME记录就是把域名解析到另外一个域名。其功能是差不多，CNAME将几个主机名指向一个别名，其实跟指向IP地址是一样的，因为这个别名也要做一个A记录的。但是使用CNAME记录可以很方便地变更IP地址。如果一台服务器有100个网站，他们都做了别名，该台服务器变更IP时，只需要变更别名的A记录就可以了。</p>
<p>域名解析CNAME记录A记录对网站的影响不大。但是：CNAME有一个好处就是稳定，就好像一个IP与一个域名的区别</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="排序总结"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:14:28.000Z" title="2020-08-07T04:14:28.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">5 minutes read (About 694 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/">排序总结</a></h1><div class="content"><h2 id="交换类？"><a href="#交换类？" class="headerlink" title="交换类？"></a>交换类？</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>不具有稳定性，复杂度稳定在O(n2)O(n2)。</p>
<blockquote>
<p>存在不同元素大范围交换，所以不稳定。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F; freopen(&quot;.&#x2F;data.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    int c[6] &#x3D; &#123;5, 3, 2, 1, 7, 2&#125;, n &#x3D; 6;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">		int mp &#x3D; i;</span><br><span class="line">        for(int j &#x3D; i + 1; j &lt; n; j++)&#123;</span><br><span class="line">            if(c[j] &lt; c[mp])&#123;</span><br><span class="line">				mp &#x3D; j;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp &#x3D; c[mp];</span><br><span class="line">        c[mp] &#x3D; c[i];</span><br><span class="line">        c[i] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0; i &lt; n; i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F; freopen(&quot;.&#x2F;data.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    int c[6] &#x3D; &#123;5, 3, 2, 1, 7, 2&#125;, n &#x3D; 6;</span><br><span class="line">    for(int i&#x3D;0; i &lt; n-1; i++)&#123;</span><br><span class="line">        int flag &#x3D; 0;</span><br><span class="line">        for(int j&#x3D;0; j &lt; n - 1 - i; j++)&#123;</span><br><span class="line">            if(c[j] &gt; c[j+1])&#123;</span><br><span class="line">                int temp &#x3D; c[j];</span><br><span class="line">                c[j] &#x3D; c[j + 1];</span><br><span class="line">                c[j + 1 ] &#x3D; temp;</span><br><span class="line">                flag &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag) break;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0; i &lt; n; i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="？？"><a href="#？？" class="headerlink" title="？？"></a>？？</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>具有稳定性，复杂度为O(n)O(n)到O(n2)O(n2)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F; freopen(&quot;.&#x2F;data.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    int c[6] &#x3D; &#123;5, 3, 2, 1, 7, 2&#125;, n &#x3D; 6;</span><br><span class="line">    for(int i &#x3D; 1; i &lt; n; i++)&#123;</span><br><span class="line">        int j &#x3D; i, t &#x3D; c[j];</span><br><span class="line">        while(j &gt; 0 &amp;&amp; t &lt; c[j - 1])&#123;</span><br><span class="line">            c[j] &#x3D; c[j - 1];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        c[j] &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0; i &lt; n; i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>稳定，复杂度为O(nlgn)O(nlgn)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int printArr(int A[], int r, int l)&#123;</span><br><span class="line">    for(int i&#x3D;r; i &lt; l + 1; i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int maxn  &#x3D; 100;</span><br><span class="line">int merge(int arr[], int l1, int r1, int l2, int r2)&#123;</span><br><span class="line">	int i &#x3D; l1, j &#x3D; l2, k &#x3D; 0;</span><br><span class="line">	int temp[maxn];</span><br><span class="line">	while(i &lt;&#x3D; r1 &amp;&amp; j &lt;&#x3D; r2)&#123;</span><br><span class="line">		if(arr[i] &lt; arr[j])</span><br><span class="line">			temp[k++] &#x3D; arr[i++]; </span><br><span class="line">		else if(arr[i] &gt;&#x3D; arr[j])</span><br><span class="line">			temp[k++] &#x3D; arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(i &lt;&#x3D; r1)</span><br><span class="line">    	temp[k++] &#x3D; arr[i++]; </span><br><span class="line">	while(j &lt;&#x3D; r2)</span><br><span class="line">    	temp[k++] &#x3D; arr[j++]; </span><br><span class="line">    for(int i &#x3D; l1, k &#x3D; 0; i &lt;&#x3D; r2; i++, k++) arr[i] &#x3D; temp[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递归写法</span><br><span class="line">int mergeSort_re(int A[], int l, int r)&#123;</span><br><span class="line">	if(l &lt; r)&#123;</span><br><span class="line">		int mid &#x3D; (l + r) &#x2F; 2;</span><br><span class="line">		mergeSort_re(A, l, mid);</span><br><span class="line">		mergeSort_re(A, mid + 1, r);</span><br><span class="line">		merge(A, l, mid, mid + 1, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 迭代写法</span><br><span class="line">int mergeSort_for(int A[], int l, int r)&#123;</span><br><span class="line">	if(l &lt; r)&#123;</span><br><span class="line">		int n &#x3D; r - l + 1;</span><br><span class="line">		&#x2F;&#x2F;step为组内元素个数</span><br><span class="line">		for(int step &#x3D; 1; step &lt;&#x3D; n; step *&#x3D; 2)&#123;</span><br><span class="line">			for(int i &#x3D; 0; i &lt; n; i +&#x3D; 2*step)&#123;</span><br><span class="line">				&#x2F;&#x2F;这么写行不行？测试一下A[5]</span><br><span class="line">				&#x2F;&#x2F; 事实证明这种写法很优美!</span><br><span class="line">				merge(&amp;A[l], i, i + step - 1, i + step, min(i + 2 * step - 1, n - 1));</span><br><span class="line">			&#125;</span><br><span class="line">		    printArr(A, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F; freopen(&quot;.&#x2F;data.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    int c[10] &#x3D; &#123;5, 3, 2, 1, 7, 2, 10, 3, 5, -1&#125;, n &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; mergeSort_re(c, 0, n - 1);</span><br><span class="line">    mergeSort_for(c, 5, n - 1);</span><br><span class="line">    </span><br><span class="line">    printArr(c, 0, n - 1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>不稳定，复杂度为O(nlgn)O(nlgn)到O(n2)O(n2)，最广泛使用的排序算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;挖沙法 分割</span><br><span class="line">int Partition(int A[], int l, int r)&#123;</span><br><span class="line">	&#x2F;&#x2F;三个数取最小值</span><br><span class="line">    int minp &#x3D; l;</span><br><span class="line">    if(A[r] &lt; A[minp]) minp &#x3D; r;</span><br><span class="line">    if(A[(r + l) &#x2F; 2] &lt; A[minp]) minp &#x3D; (r + l) &#x2F; 2;</span><br><span class="line">    int temp &#x3D; A[minp];</span><br><span class="line">    A[minp] &#x3D; A[l];</span><br><span class="line">    A[l] &#x3D; temp;</span><br><span class="line">    int i &#x3D; l, j &#x3D; r;</span><br><span class="line">    while(i &lt; j)&#123;</span><br><span class="line">        while(i &lt; j &amp;&amp; temp &lt; A[j]) j--;</span><br><span class="line">        A[i] &#x3D; A[j];</span><br><span class="line">        while(i &lt; j &amp;&amp; temp &gt;&#x3D; A[i]) i++;</span><br><span class="line">        A[j] &#x3D; A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    A[j] &#x3D; temp;</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line">void quickSort(int A[], int l, int r)&#123;</span><br><span class="line">    if(l &gt;&#x3D; r) return;</span><br><span class="line">    int mid &#x3D; partition(A, l, r);</span><br><span class="line">        printArr(A, 0, 9);</span><br><span class="line">        printf(&quot;%d\n&quot;, mid);</span><br><span class="line">    quickSort(A, l, mid - 1); &#x2F;&#x2F; 如果这里取mid - 1, 可能会导致mid为右侧最小值的情况时，无限partition！（没错，微妙的递归）</span><br><span class="line">    quickSort(A, mid + 1, r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E5%BF%AB%E9%80%9F%E5%B9%82/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="快速幂"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:13:59.000Z" title="2020-08-07T04:13:59.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">a few seconds read (About 99 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E5%BF%AB%E9%80%9F%E5%B9%82/">快速幂</a></h1><div class="content"><p>快速幂算法，也称二分幂。 递归写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">ll binaryPow(ll a, ll b, ll m)&#123;</span><br><span class="line">	if(b &#x3D;&#x3D; 0) return 1;</span><br><span class="line">	if(b &amp; 1) return a * binaryPow(a, b - 1, m) % m;</span><br><span class="line">	else&#123;</span><br><span class="line">		ll mul &#x3D; binaryPow(a, b &#x2F; 2, m);</span><br><span class="line">		return mul * mul % m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span><br><span class="line">ll binaryPow(ll a, ll b, ll m)&#123;</span><br><span class="line">	ll res &#x3D; 1， pow &#x3D; a;</span><br><span class="line">	while(b)&#123;</span><br><span class="line">		if(b &amp; 1)</span><br><span class="line">			res &#x3D; res * pow % m; &#x2F;&#x2F;注意这两个地方的取余</span><br><span class="line">		pow &#x3D; pow * pow % m; </span><br><span class="line">		b &gt;&gt; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="双指针法"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:12:51.000Z" title="2020-08-07T04:12:51.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">2 minutes read (About 260 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/">双指针法</a></h1><div class="content"><p>双指针算法作为编程中的一种思想，利用了数据有序性，有效减少了算法复杂度。比如在两数之和的题目，可达到O(n)O(n)复杂度，而非O(n2)O(n2)。在序列递增的数组中找两个数之和为aim。</p>
<ul>
<li>对于a[i]+a[j]==Ma[i]+a[j]==M, 结果成立；</li>
<li>对于a[i]+a[j]&lt;Ma[i]+a[j]&lt;M，则有a[i−1]+a[j]&lt;Ma[i−1]+a[j]&lt;M成立，但是a[i+1]+a[j]a[i+1]+a[j]大小未知。尝试ii向上移动</li>
<li>对于a[i]+a[j]&gt;Ma[i]+a[j]&gt;M，则有a[i]+a[j+1]&gt;Ma[i]+a[j+1]&gt;M成立，但是a[i]+a[j−1]a[i]+a[j−1]大小未知。尝试jj向上移动</li>
</ul>
<blockquote>
<p>上面的算法推导有一个不太严谨的地方：没有证明[0,i−1]和[j+1,n−1][0,i−1]和[j+1,n−1]之间的元素的任何搭配不成立。</p>
<p> 诶好像可以用归纳法！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> aim, i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = arr[i] + arr[j];</span><br><span class="line">	<span class="keyword">if</span>(sum ==aim)&#123;</span><br><span class="line">		pirntf(<span class="string">"%d,%d\n"</span>, arr[i], arr[j]);</span><br><span class="line">		i++; j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum &lt; aim)&#123;</span><br><span class="line">		i++</span><br><span class="line">	&#125;<span class="keyword">else</span> j--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他例子，如两个数列合并的双指针例子。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="最大公约数——欧几里得算法"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:12:04.000Z" title="2020-08-07T04:12:04.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">a few seconds read (About 64 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/">最大公约数——欧几里得算法</a></h1><div class="content"><p>欧几里得算法又称碾转相除法，其算法基于以下定理：</p>
<p>gcd(a,b)=gcd(b,agcd(a,b)=gcd(b,a</p>
<p>其中gcd(a, b)表示a除于b的余数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b? gcd(b, a % b) : a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E7%B4%A0%E6%95%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="素数"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:11:10.000Z" title="2020-08-07T04:11:10.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">a minute read (About 129 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E7%B4%A0%E6%95%B0/">素数</a></h1><div class="content"><h3 id="用素数性质简单判断"><a href="#用素数性质简单判断" class="headerlink" title="用素数性质简单判断"></a>用素数性质简单判断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isPrime(int n)&#123;</span><br><span class="line">    if(n &lt;&#x3D; 1) return false;</span><br><span class="line">    int sqr &#x3D; (int)sqrt(1.0 * n);</span><br><span class="line">    for(int i &#x3D; 2; i &lt;&#x3D; sqr; i++)</span><br><span class="line">        if(n % i &#x3D;&#x3D; 0) return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打素数表"><a href="#打素数表" class="headerlink" title="打素数表"></a>打素数表</h3><p>经典的埃氏筛法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1e5;</span><br><span class="line">int prime[maxn], pNum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void findPrime()&#123;</span><br><span class="line">    for(int i &#x3D; 2; i &lt; maxn; i++)&#123;</span><br><span class="line">        if(prime[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            prime[pNum++] &#x3D; i;</span><br><span class="line">            for(int j &#x3D; i * 2; j &lt; maxn; j +&#x3D; i)</span><br><span class="line">                prime[j] &#x3D; 1;</span><br><span class="line">            printf(&quot;%d\n&quot;, i);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>素数表的经典应用就是分解质因子，在有了素数表的情况下分解一个数字的因子的复杂度为O(n−−√)O(n)</p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E4%B8%AD%E7%BC%80%E5%BC%8F%E8%AE%A1%E7%AE%97/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="中缀式计算"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:09:56.000Z" title="2020-08-07T04:09:56.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">4 minutes read (About 526 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E4%B8%AD%E7%BC%80%E5%BC%8F%E8%AE%A1%E7%AE%97/">中缀式计算</a></h1><div class="content"><p>中缀表示式计算分为两个步骤，一是中缀转后缀，二是后缀表达式计算；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stop</span>; <span class="comment">// 符号栈</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; opp; <span class="comment">// 运算符 映射到优先级 the priority of operators</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; stn;<span class="comment">// 数字栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">mid2Post</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]) || s[i] == <span class="string">'.'</span>) res += s[i];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">' '</span>) <span class="keyword">continue</span>; <span class="comment">//去空格</span></span><br><span class="line">			<span class="keyword">if</span>(s[i] == <span class="string">'('</span>) <span class="built_in">stop</span>.push(s[i]);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="built_in">stop</span>.top() != <span class="string">'('</span>)&#123;</span><br><span class="line">					res += <span class="built_in">stop</span>.top();</span><br><span class="line">					<span class="built_in">stop</span>.pop();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">stop</span>.pop();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> pro = opp[s[i]];</span><br><span class="line">				<span class="comment">//为运算符两旁数字插入空格,否则无法区分数字</span></span><br><span class="line">				res += <span class="string">' '</span>;</span><br><span class="line">				<span class="comment">//pop出运算优先级高的运算操作符</span></span><br><span class="line">				<span class="keyword">while</span>( !<span class="built_in">stop</span>.empty() &amp;&amp; pro &lt;= opp[<span class="built_in">stop</span>.top()])&#123; <span class="comment">//注意这里stack要有数据,</span></span><br><span class="line">					res += <span class="built_in">stop</span>.top();</span><br><span class="line">					<span class="built_in">stop</span>.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">stop</span>.push(s[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">stop</span>.empty())&#123;</span><br><span class="line">		res += <span class="built_in">stop</span>.top();</span><br><span class="line">		<span class="built_in">stop</span>.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正数（可有小数点）</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getNum</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> &amp;pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = pos, flag = <span class="number">1</span>;<span class="comment">// flag = 1表计算正整数</span></span><br><span class="line">	<span class="keyword">double</span> inter = <span class="number">0</span>, fac = <span class="number">0</span>, pow10 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(str[k]) || str[k] == <span class="string">'.'</span>)&#123;</span><br><span class="line">	 	<span class="keyword">if</span>( str[k] == <span class="string">'.'</span>) flag = <span class="number">0</span>;  </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;	<span class="comment">//计算正整数</span></span><br><span class="line">			inter = inter * <span class="number">10</span> + (<span class="keyword">double</span>)(str[k] - <span class="string">'0'</span>); <span class="comment">//地址？</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;	<span class="comment">// 计算小数</span></span><br><span class="line">			fac += (<span class="keyword">double</span>)(str[k]-<span class="string">'0'</span>) / pow10;</span><br><span class="line">			pow10 *= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">	 	<span class="keyword">if</span>(k &gt;= str.<span class="built_in">size</span>() ) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pos = k;</span><br><span class="line">	<span class="keyword">return</span> inter + fac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算后缀表达式的值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calPost</span><span class="params">(<span class="built_in">string</span> pStr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pStr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pStr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">isdigit</span>(pStr[i]))&#123; <span class="comment">//对于数字</span></span><br><span class="line">			<span class="keyword">double</span> t = getNum(pStr, i);</span><br><span class="line">			i--; <span class="comment">//多加了一次i</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%f\n"</span>, t);</span><br><span class="line">			stn.push(t);			</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pStr[i] == <span class="string">'+'</span> || pStr[i] == <span class="string">'-'</span> ||</span><br><span class="line">			pStr[i] == <span class="string">'*'</span> || pStr[i] == <span class="string">'/'</span>) &#123; <span class="comment">// 对于运算符（不包括小数，理论上规范的格式中应该被数据包裹着）</span></span><br><span class="line">			<span class="keyword">double</span> op2 = stn.top(); stn.pop(); <span class="comment">//注意压栈后 数据顺序是反的</span></span><br><span class="line">             <span class="keyword">double</span> op1 = stn.top(); stn.pop();</span><br><span class="line">    		<span class="keyword">if</span>(pStr[i] == <span class="string">'+'</span>) stn.push(op1 + op2);</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(pStr[i] == <span class="string">'-'</span>) stn.push(op1 - op2);</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(pStr[i] == <span class="string">'*'</span>) stn.push(op1 * op2);</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(pStr[i] == <span class="string">'/'</span>) stn.push(op1 / op2); <span class="comment">//不做非零判断了</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>( stn.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error! the size of stck of num isn't 1.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> stn.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("data.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	getline(<span class="built_in">cin</span>, str);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	opp[<span class="string">'+'</span>] = opp[<span class="string">'-'</span>] = <span class="number">1</span>;</span><br><span class="line">    opp[<span class="string">'/'</span>] = opp[<span class="string">'*'</span>] = <span class="number">2</span>;</span><br><span class="line">	opp[<span class="string">'('</span>] = <span class="number">0</span>; <span class="comment">//'(' 特殊处理</span></span><br><span class="line">    <span class="built_in">string</span> pStr = mid2Post(str);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> calRes = calPost(pStr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, calRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节上也可以再改动，比如在识别数字的时候就把它提取出来并用结构体的形式存储下来。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="拓扑排序"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:09:07.000Z" title="2020-08-07T04:09:07.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">a minute read (About 113 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">拓扑排序</a></h1><div class="content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** This is Code of JJ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Problem      :拓扑排序</span></span><br><span class="line"><span class="comment">Source       :</span></span><br><span class="line"><span class="comment">Solution     :</span></span><br><span class="line"><span class="comment">AnyDetial    :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">DateAndTime  :2.26</span></span><br><span class="line"><span class="comment">CostofTime   :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;adj[N];</span><br><span class="line"><span class="keyword">int</span> indegree[N],dvis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sortnum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; u &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[u].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = adj[u][j];</span><br><span class="line">            indegree[k]--;</span><br><span class="line">            <span class="keyword">if</span>(indegree[k]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortnum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sortnum==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs 逆序输出拓扑排序</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;adj[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = adj[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(u);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1, c2, w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c1,&amp;c2);</span><br><span class="line">        adj[c1].push_back(c2);</span><br><span class="line">        indegree[c2] ++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    topu();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">0 2</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">*/</span>w</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E6%9C%80%E7%9F%AD%E8%B7%AF/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="最短路"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:07:08.000Z" title="2020-08-07T04:07:08.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">3 minutes read (About 455 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E6%9C%80%E7%9F%AD%E8%B7%AF/">最短路</a></h1><div class="content"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3ffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MX = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, l, cap, s, t;</span><br><span class="line"><span class="keyword">int</span> dis[MX], vis[MX], bvis[MX], edge[MX][MX], fushe[MX];</span><br><span class="line"><span class="keyword">int</span> bec = <span class="number">-1</span>    , becfu = INF, allp;</span><br><span class="line"><span class="keyword">double</span> rate = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[MX], bepath, nwpath;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disjk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dis,dis + MX, INF);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minv =  INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; minv)&#123;</span><br><span class="line">                minv = dis[j];</span><br><span class="line">                u  = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span> ) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( edge[u][v] != INF &amp;&amp; !vis[v])&#123;<span class="comment">//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点</span></span><br><span class="line">                                            <span class="comment">//! 但是之前已经放缩的节点是绝对不会再被放缩的。。因为无负权</span></span><br><span class="line"><span class="comment">//            if( edge[u][v] != INF )&#123;//! vis[v] == 0 必须成立， 根据Dijkstra算法不能放缩已经标记过的节点</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + edge[u][v] )&#123;</span><br><span class="line">                    dis[v] = dis[u] + edge[u][v];</span><br><span class="line">                    path[v].<span class="built_in">clear</span>();</span><br><span class="line">                    path[v].push_back(u);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( dis[v] ==  dis[u] + edge[u][v])&#123;</span><br><span class="line">                    path[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que, lay;</span><br><span class="line">    que.push(s);</span><br><span class="line">    lay.push(<span class="number">0</span>);</span><br><span class="line">    bvis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(), layer = lay.front(); que.pop(), lay.pop();</span><br><span class="line">        <span class="keyword">if</span>(layer &lt; l)</span><br><span class="line">            fushe[u] += (<span class="keyword">int</span>)(<span class="built_in">ceil</span>(<span class="number">1.0</span> * fushe[u] * (l - layer) / l));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">            <span class="keyword">if</span>(edge[u][i] != INF &amp;&amp; !bvis[i])&#123;<span class="comment">//!</span></span><br><span class="line">                que.push(i);</span><br><span class="line">                bvis[i] = <span class="number">1</span>;</span><br><span class="line">                lay.push( layer + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    nwpath.push_back(u);</span><br><span class="line">    <span class="keyword">if</span>(u == s)&#123;</span><br><span class="line">        allp ++;</span><br><span class="line">        <span class="keyword">int</span> npc = <span class="number">0</span>, npfushe = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nwpath.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            npc += fushe[nwpath[i]];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nwpath.<span class="built_in">size</span>() / <span class="number">2</span>) npfushe += fushe[nwpath[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        npc = npc % cap;</span><br><span class="line">        <span class="keyword">if</span>(npc &gt; bec || npc == bec &amp;&amp; npfushe &lt; becfu)&#123; <span class="comment">//! npc &gt;= bec</span></span><br><span class="line">            bepath = nwpath;</span><br><span class="line">            bec = npc;</span><br><span class="line">            becfu = npfushe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; path[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">            dfs(path[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    nwpath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(edge[<span class="number">0</span>], edge[<span class="number">0</span>] + MX * MX , INF);<span class="comment">//! init</span></span><br><span class="line">    <span class="keyword">int</span> c1, c2, tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; cap &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">cin</span> &gt;&gt; fushe[i] ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;c1, &amp;c2, &amp;tmp);</span><br><span class="line">        edge[c1][c2] = edge[c2][c1] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    disjk();</span><br><span class="line">    dfs(t);</span><br><span class="line">    <span class="keyword">if</span>( !bvis[t]) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, allp, dis[t], bec, becfu);</span><br><span class="line">        reverse(bepath.<span class="built_in">begin</span>(), bepath.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//        if(bepath.size()) printf("%d", bepath[0]);//! runtime error</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; bepath.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> == bepath.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">"%d"</span>, bepath[i]);</span><br><span class="line">            <span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">"%d-&gt;"</span>, bepath[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="关键路径"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:06:27.000Z" title="2020-08-07T04:06:27.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">3 minutes read (About 466 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/">关键路径</a></h1><div class="content"><p>​    ```</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mss = <span class="number">1e3</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> edge[mss][mss], n, m;</span><br><span class="line"><span class="keyword">int</span> ve[mss], vl[mss], e[mss][mss], l[mss][mss];</span><br><span class="line"><span class="keyword">int</span> ingree[mss], maxtime;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; activity[mss], tempp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span>(ingree[i] == <span class="number">0</span>) que.push(i);</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">        stk.push(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[u][i] != INF)&#123;</span><br><span class="line">                ingree[i] --;</span><br><span class="line">                <span class="keyword">if</span>(ingree[i] == <span class="number">0</span>) que.push(i);</span><br><span class="line">                ve[i] = <span class="built_in">max</span>(ve[i], ve[u] + edge[u][i]);<span class="comment">// 拓扑排序兵同时计算 每个节点的最早开始时间</span></span><br><span class="line"><span class="comment">//                cout &lt;&lt; ve[u] &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stk.<span class="built_in">size</span>() == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">critical_path</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化汇点</span></span><br><span class="line">    <span class="keyword">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>( maxv &lt; ve[i]) maxv =  ve[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        vl[i] = maxv;</span><br><span class="line">    maxtime = maxv;</span><br><span class="line">    <span class="comment">//逆拓扑排序地计算每个节点的最晚开始时间</span></span><br><span class="line">    <span class="keyword">while</span>(stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = stk.top(); stk.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[u][i] != INF)</span><br><span class="line">                vl[u] = <span class="built_in">min</span>( vl[u], vl[i] - edge[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找关键路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i][j] != INF)&#123;</span><br><span class="line">                e[i][j] = ve[i];</span><br><span class="line">                l[i][j] = vl[j] - edge[i][j];</span><br><span class="line">                <span class="keyword">if</span>(e[i][j] == l[i][j])&#123;<span class="comment">//插入path 以便查询所关键路径</span></span><br><span class="line">                    activity[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序以保证按序输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        sort(activity[i].<span class="built_in">begin</span>(), activity[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;<span class="comment">//输出所有关键路径</span></span><br><span class="line">    tempp.push_back(u);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(activity[u].<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt; tempp.<span class="built_in">size</span>() ;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tempp[i];</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> != tempp.<span class="built_in">size</span>()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; activity[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">            dfs( activity[u][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tempp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(edge[<span class="number">0</span>], edge[<span class="number">0</span>] + mss * mss, INF);</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        edge[u][v] = w;</span><br><span class="line">        ingree[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!topu())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">    critical_path();</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e[u][v] &lt;&lt; <span class="string">' '</span> &lt;&lt; l[u][v] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxtime &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span>( activity[i].<span class="built_in">size</span>() &amp;&amp; ve[i] == <span class="number">0</span>) dfs(i); <span class="comment">//一个关键路径的起点的后序存在节点的 且最早开始时间为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="字符串hash"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:02:09.000Z" title="2020-08-07T04:02:09.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">a minute read (About 160 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/%E5%AD%97%E7%AC%A6%E4%B8%B2hash/">字符串hash</a></h1><div class="content"><p>滚动哈希：O(n+m)时间内完成字符串匹配；<br>实现：选取两个台适的互素数$b$和h(l&lt;b&lt;h)，假设字符串 C=clc2c3…CmC=clc2c3…Cm，定义哈希函数：<br>$$<br>H(C)=(C_1b_{m−1}+C_2b_{m−2}+⋯+C_mb_0)<br>$$</p>
<p>其中b是基数。</p>
<p>可以得出O(n)的时间复杂度就可以计算得到一个串的Hash值。而由取余性质</p>
<p>$$<br>(A+B)<br>$$</p>
<p>以滚动计算hash值，可实现以复杂度O(1)O(1)计算每个母串的长度为nn子串的hash值。最后再O(n+m)时间内完成字符串匹配。在实现时，可以使用64位无符号整数计算哈希值，并取M等于264264，通过自然溢出省去求模运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> ull b=<span class="number">100000007</span>;<span class="comment">//哈希的基数；</span></span><br><span class="line"><span class="comment">//C是否在S中出现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(<span class="built_in">string</span> C,<span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> m = C.length(), n = S.length();</span><br><span class="line">     <span class="keyword">if</span>(m &gt; n)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">//计算b的m次方</span></span><br><span class="line">     ull t=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++)   t *= b;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//计算C和S长度为m的前缀对应的哈希值</span></span><br><span class="line">     ull Chash=<span class="number">0</span>, Shash=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m; i++)   Chash = Chash * b + C[i];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)   Shash = Shash * b + S[i];</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//对S不断右移一位，更新哈希值并判断</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt; n; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(Chash == Shash)  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//S从位置i开始长度为m的字符串子串等于C；</span></span><br><span class="line">          Shash = Shash * b - S[i] * t + S[i+m];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/CS/Algorithms/LCA%E9%97%AE%E9%A2%98/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="LCA问题"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:00:46.000Z" title="2020-08-07T04:00:46.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/CS/">CS</a><span> / </span><a class="link-muted" href="/categories/CS/Algorithms/">Algorithms</a></span><span class="level-item">a few seconds read (About 23 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/CS/Algorithms/LCA%E9%97%AE%E9%A2%98/">LCA问题</a></h1><div class="content"><p>LCA问题即最近公共祖先问题</p>
<p>常见解法有递归法，向上</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="http://static.come2rss.xyz/%E9%93%81%E7%94%B2%E5%9F%8Elogo.png" alt="Ove"></figure><p class="title is-size-4 is-block line-height-inherit">Ove</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>宁波</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">90</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知乎" href="https://www.zhihu.com/people/ddd-37-43"><i class="http://static.come2rss.xyz/zhihu.png"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/15-3sum/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="15 3sum"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:15:37.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/15-3sum/">15 3sum</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="1190. Reverse Substrings Between Each Pair of Parentheses"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:14:44.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses/">1190. Reverse Substrings Between Each Pair of Parentheses</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-DP-%E8%B4%AA%E5%BF%83/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="面试题 DP 贪心"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:14:08.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-DP-%E8%B4%AA%E5%BF%83/">面试题 DP 贪心</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/">剑指offer</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="786. 第 K 个最小的素数分数"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:13:32.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/">786. 第 K 个最小的素数分数</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="1025 除数博弈"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:13:01.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/">1025 除数博弈</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">90</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/AI/DL/"><span class="level-start"><span class="level-item">DL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CS/Algorithms/"><span class="level-start"><span class="level-item">Algorithms</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/CN/"><span class="level-start"><span class="level-item">CN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/CSAPP/"><span class="level-start"><span class="level-item">CSAPP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/DB/"><span class="level-start"><span class="level-item">DB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/DS/"><span class="level-start"><span class="level-item">DS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/"><span class="level-start"><span class="level-item">Code tools</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Anki/"><span class="level-start"><span class="level-item">Anki</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Matlab/"><span class="level-start"><span class="level-item">Matlab</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Pycharm/"><span class="level-start"><span class="level-item">Pycharm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/VScode/"><span class="level-start"><span class="level-item">VScode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Language/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">刷题</span></span><span class="level-end"><span class="level-item tag">31</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/PAT/"><span class="level-start"><span class="level-item">PAT</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/"><span class="level-start"><span class="level-item">剑指offer</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://static.come2rss.xyz/%E9%92%A2%E9%93%81%E4%BE%A0.png" alt="Hexo" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>