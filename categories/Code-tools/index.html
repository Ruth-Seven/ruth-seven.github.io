<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Code tools - Hexo</title><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Hexo","image":["http://yoursite.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="http://static.come2rss.xyz/%E9%93%81%E7%94%B2%E5%9F%8Elogo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://static.come2rss.xyz/%E9%92%A2%E9%93%81%E4%BE%A0.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Ruth-Seven"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Code tools</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Linux/shell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="shell命令笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:19:34.000Z" title="2020-08-07T05:19:34.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Linux/">Linux</a></span><span class="level-item">21 minutes read (About 3161 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Linux/shell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/">shell命令笔记</a></h1><div class="content"><!-- mroe -->



<h2 id="Shell-Tools-and-Scripting"><a href="#Shell-Tools-and-Scripting" class="headerlink" title="Shell Tools and Scripting"></a><a href="https://missing.csail.mit.edu/2020/shell-tools/">Shell Tools and Scripting</a></h2><blockquote>
<p><a href="https://missing.csail.mit.edu/2020/shell-tools/">前面部分参考课程</a></p>
</blockquote>
<h2 id="简单规则"><a href="#简单规则" class="headerlink" title="简单规则"></a>简单规则</h2><p><strong>赋值：</strong><code>foo=bar</code> 赋值语句中不可添加空格</p>
<p><strong><code>&quot;</code>和<code>&#39;</code>的区别：</strong>Strings in bash can be defined with <code>&#39;</code> and <code>&quot;</code> delimiters but they are <strong>not equivalent.</strong> Strings delimited with <code>&#39;</code> are literal strings and will not substitute variable values whereas <code>&quot;</code> delimited strings will.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo&#x3D;bar</span><br><span class="line">echo &quot;$foo&quot;</span><br><span class="line"># prints bar</span><br><span class="line">echo &#39;$foo&#39;</span><br><span class="line"># prints $foo</span><br></pre></td></tr></table></figure>

<p><strong>函数体定义：</strong>As with most programming languages, bash supports control flow techniques including <code>if</code>, <code>case</code>, <code>while</code> and <code>for</code>. Similarly, <code>bash</code> has functions that take arguments and can operate with them. Here is an example of a <strong>function</strong> that creates a directory and <code>cd</code>s into it.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p &quot;$1&quot;</span><br><span class="line">    cd &quot;$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量名定义：</strong>Here <code>$1</code> is the first argument to the script/function. Unlike other scripting languages, bash uses a variety of special variables to refer to <strong>arguments, error codes and other relevant variables</strong>. Below is a list of some of them. A more comprehensive list can be found <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">here</a>.</p>
<ul>
<li><code>$0</code> - Name of the script</li>
<li><code>$1</code> to <code>$9</code> - Arguments to the script. <code>$1</code> is the first argument and so on.</li>
<li><code>$@</code> - All the arguments</li>
<li><code>$#</code> - Number of arguments</li>
<li><code>$?</code> - Return code of the previous command</li>
<li><code>$$</code> - Process Identification number for the current script</li>
<li><code>!!</code> - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions, then you can quickly execute it with sudo by doing <code>sudo !!</code></li>
<li><code>$_</code> - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing <code>Esc</code> followed by <code>.</code></li>
</ul>
<p>Commands will often return output using <code>STDOUT</code>, errors through <code>STDERR</code> and a Return Code to report errors in a more script friendly manner. Return code or exit status is the way scripts/commands have to communicate how execution went. <strong>A value of 0 usually means everything went OK,</strong> anything different from 0 means an error occurred.</p>
<p><strong>神奇的脚本符号：</strong></p>
<p><code>false || echo &quot;opes its false&quot;</code> <code>||</code>语句会在第一个命令执行失败后执行第二条。</p>
<p>The <code>true</code> program will always have a 0 return code and the <code>false</code> command will always have a 1 return code.</p>
<blockquote>
<p>注意仅当返回值为<code>0</code>时命令</p>
</blockquote>
<p><code>true &amp;&amp; echo &quot;Things went well&quot;</code> 那就是仅在第一条命令执行成功后，第二条命令才会继续执行</p>
<p><code>command1 ; command2</code> 就是无论如何都会按顺序执行两条命令</p>
<p><code>!!</code> 一个神奇的命令，可以获取上一条运行过的完整的命令，可以使用在再次调用Sudo上，可用tap或者enter获取。</p>
<p><code>foo=$(pwd)</code> （<em>command substitution</em>）等号两边不可加空格，因为他不是命令。其次<code>$(pwd)</code>是获取命令的返回值的意思。再其次，<code>echo $foo</code>才能打印出变量<code>$foo</code>的结果。</p>
<p><code>&lt;( CMD )</code>(<em>process substitution</em>), will execute <code>CMD</code> and place the output in a temporary file and substitute the <code>&lt;()</code> with that file’s name. This is useful when commands expect values to be passed by file instead of by STDIN. For example, <code>diff &lt;(ls foo) &lt;(ls bar)</code> will show differences between files in dirs <code>foo</code> and <code>bar</code>.</p>
<p><strong>Wildcards</strong> - Whenever you want to perform some sort of wildcard matching you can use <code>?</code> and <code>*</code> to match one or any amount of characters respectively. For instance, given files <code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> and <code>bar</code>, the command <code>rm foo?</code> will delete <code>foo1</code> and <code>foo2</code> whereas <code>rm foo*</code> will delete all but <code>bar</code>.</p>
<p><strong>Curly braces <code>{}</code></strong> - Whenever you have a common substring in a series of commands you can use curly braces for bash to expand this automatically. This comes in very handy when moving or converting files.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Globbing techniques can also be combined</span><br><span class="line">mv *&#123;.py,.sh&#125; folder</span><br><span class="line"># Will move all *.py and *.sh files</span><br><span class="line"></span><br><span class="line">mkdir foo bar</span><br><span class="line"># This creates files foo&#x2F;a, foo&#x2F;b, ... foo&#x2F;h, bar&#x2F;a, bar&#x2F;b, ... bar&#x2F;h</span><br><span class="line">touch &#123;foo,bar&#125;&#x2F;&#123;a..h&#125;</span><br><span class="line">touch foo&#x2F;x bar&#x2F;y</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>,<code>grep</code> for the string <code>foobar</code> and append it to the file as a comment if it’s not found.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">echo &quot;Starting program at $(date)&quot; # Date will be substituted</span><br><span class="line"></span><br><span class="line">echo &quot;Running program $0 with $# arguments with pid $$&quot;</span><br><span class="line"></span><br><span class="line">for file in $@; do</span><br><span class="line">    grep foobar $file &gt; &#x2F;dev&#x2F;null 2&gt; &#x2F;dev&#x2F;null</span><br><span class="line">    # When pattern is not found, grep has exit status 1</span><br><span class="line">    # We redirect STDOUT and STDERR to a null register since we do not care about them</span><br><span class="line">    if [[ $? -ne 0 ]]; then</span><br><span class="line">        echo &quot;File $file does not have any foobar, adding one&quot;</span><br><span class="line">        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>In the comparison we tested whether <code>$?</code> was not equal to 0. Bash implements many comparisons of this sort, you can find a detailed list in the manpage for <a href="http://man7.org/linux/man-pages/man1/test.1.html"><code>test</code></a>. When performing comparisons in bash try to use double brackets <code>[[ ]]</code> in favor of simple brackets <code>[ ]</code>. Chances of making mistakes are lower although it won’t be portable to <code>sh</code>. A more detailed explanation can be found <a href="http://mywiki.wooledge.org/BashFAQ/031">here</a>.</p>
<p><strong>shell检查工具：</strong>Writing <code>bash</code> scripts can be tricky and unintuitive. There are tools like <a href="https://github.com/koalaman/shellcheck">shellcheck</a> that will help you find out errors in your sh/bash scripts.</p>
<p><strong>scripts：</strong></p>
<p>Python脚本使用<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>（下面例子中的<code>#!</code>开头的句子）来确定Python脚本语言的执行解释器。更灵活的写法是使用<code>env</code>命令，比如<code>#!/usr/local/bin/env python</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python</span><br><span class="line">import sys</span><br><span class="line">for arg in reversed(sys.argv[1:]):</span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure>

<p>Some differences between shell functions and scripts that you should keep in mind are:</p>
<ul>
<li>函数定义以后就会载入，执行时无需再载入，速度快。</li>
<li>函数可以在当前shell环境执行，但是脚本运行在他们的进程中；所以函数可以改变环境变量，比如进入目录，然而脚本不能。Scripts will be passed by value environment variables that have been exported using <a href="http://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a></li>
<li>As with any programming language functions are a powerful construct to achieve modularity, code reuse and clarity of shell code. Often shell scripts will include their own function definitions.</li>
</ul>
<h2 id="Shell-Tools"><a href="#Shell-Tools" class="headerlink" title="Shell Tools"></a>Shell Tools</h2><h3 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-h&#96;或者&#96;-help</span><br><span class="line">man command</span><br></pre></td></tr></table></figure>

<p><a href="https://tldr.sh/">TLDR pages</a> are a nifty complementary solution that focuses on giving example use cases of a command so you can quickly figure out which options to use. （推荐！）</p>
<h3 id="Finding-files"><a href="#Finding-files" class="headerlink" title="Finding files"></a>Finding files</h3><p><a href="http://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a> 即时查找文件，强大的文本属性描述，可支持对文件执行命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Find all directories named src</span><br><span class="line">find . -name src -type d</span><br><span class="line"># Find all python files that have a folder named test in their path</span><br><span class="line">find . -path &#39;**&#x2F;test&#x2F;**&#x2F;*.py&#39; -type f</span><br><span class="line"># Find all files modified in the last day</span><br><span class="line">find . -mtime -1</span><br><span class="line"># Find all zip files with size in range 500k to 10M</span><br><span class="line">find . -size +500k -size -10M -name &#39;*.tar.gz&#39;</span><br><span class="line"># Delete all files with .tmp extension</span><br><span class="line">find . -name &#39;*.tmp&#39; -exec rm &#123;&#125; \;</span><br><span class="line"># Find all PNG files and convert them to JPG</span><br><span class="line">find . -name &#39;*.png&#39; -exec convert &#123;&#125; &#123;.&#125;.jpg \;</span><br></pre></td></tr></table></figure>

<p>在数据库支持下的文件搜索程序，速度更快，但是由于数据库更新频率限制，可能结果不完整。 <code>locate</code> uses a database that is updated using <a href="http://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>. In most systems <code>updatedb</code> is updated daily via <a href="http://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>. Therefore one trade-off between the two is speed vs freshness.</p>
<p>A more in depth comparison between <code>find</code> and <code>locate</code> can be found <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">here</a>.</p>
<h3 id="Finding-code"><a href="#Finding-code" class="headerlink" title="Finding code"></a>Finding code</h3><p><a href="http://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>, a generic tool for matching patterns from the input text. It is an incredibly valuable shell tool and we will cover it more in detail during the data wrangling lecture.</p>
<p><code>-C</code> for getting <strong>C</strong>ontext（上下文） around the matching line</p>
<p><code>-v</code> for in<strong>v</strong>erting the match, i.e. print all lines that do <strong>not</strong> match the pattern.</p>
<p><code>-R</code> since it will <strong>R</strong>ecursively go into directories and look for text files for the matching string.</p>
<p>其他<code>grep</code>的升级版 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> and <a href="https://github.com/BurntSushi/ripgrep">rg</a>. All of them are fantastic but pretty much cover the same need. For now I am sticking with ripgrep (<code>rg</code>) given how fast and intuitive it is. Some examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Find all python files where I used the requests library</span><br><span class="line">rg -t py &#39;import requests&#39;</span><br><span class="line"># Find all files (including hidden files) without a shebang line</span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"># Find all matches of foo and print the following 5 lines</span><br><span class="line">rg foo -A 5</span><br><span class="line"># Print statistics of matches (# of matched lines and files )</span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure>

<p>Note that as with <code>find</code>/<code>fd</code>, it is important that you know that these problems can be quickly solved using one of these tools, while <strong>the specific tools you use are not as important</strong>.</p>
<h3 id="Finding-shell-commands"><a href="#Finding-shell-commands" class="headerlink" title="Finding shell commands"></a>Finding shell commands</h3><p>up arrow（方向向上键）可以查找历史命令</p>
<p><code>history</code> ：可以显示运行过的命令，可以配合<code>grep</code>使用，如 <code>history | grep find</code> will print commands with the substring “find”.</p>
<p><code>Ctrl+R</code> ：perform backwards search through your history.<code>zsh</code>也可以使用上下方向键来搜索。<code>fzf</code>提供更强大的模糊搜索命令功能。可见<a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a>、<a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a>。</p>
<p><code>fish</code>: <a href="https://fishshell.com/">fish</a> shell, this feature dynamically <strong>autocompletes</strong> your current shell command with the most recent command that you typed that shares a common prefix with it. It can be enabled in <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> and it is a great quality of life trick for your shell.</p>
<p>消除敏感信息：If you make the mistake of not adding the leading space you can always manually remove the entry by editing your <code>.bash_history</code> or <code>.zhistory</code>.</p>
<h3 id="Directory-Navigation"><a href="#Directory-Navigation" class="headerlink" title="Directory Navigation"></a>Directory Navigation</h3><p><code>fasd</code>: 支持将命令重命名，支持使用文件名的子串并填充为完整文件。</p>
<p><a href="https://github.com/clvv/fasd"><code>fasd</code></a> Fasd ranks files and directories by <a href="https://developer.mozilla.org/en/The_Places_frecency_algorithm"><em>frecency</em></a>, that is, by both <em>frequency</em> and <em>recency</em>. The most straightforward use is <em>autojump</em> which adds a <code>z</code> command that you can use to quickly <code>cd</code> using a substring of a <em>frecent</em> directory. E.g. if you often go to <code>/home/user/files/cool_project</code> you can simply <code>z cool</code> to jump there.</p>
<p>More complex tools exist to quickly get an overview of a directory structure <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> or even full fledged file managers like <a href="https://github.com/jarun/nnn"><code>nnn</code></a> or <a href="https://github.com/ranger/ranger"><code>ranger</code></a></p>
<h2 id="shell学习笔记"><a href="#shell学习笔记" class="headerlink" title="shell学习笔记"></a>shell学习笔记</h2><p>基础和变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># string , variable </span><br><span class="line">readonly your&#x3D;&quot;Ruth_name&quot; #readonly</span><br><span class="line"></span><br><span class="line"># unset your:delete &#39;your&#39;</span><br><span class="line"></span><br><span class="line">#echo</span><br><span class="line">echo &quot;Hi Guys!&quot; &quot;Welcome to my world!&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># this a variable</span><br><span class="line">name1&#x3D;&quot;HU, hahahaha&quot;</span><br><span class="line"></span><br><span class="line"># string :strcat;</span><br><span class="line">echo &quot;$name1:&quot;$&#123;name1&#125;&quot;!&quot;</span><br><span class="line"></span><br><span class="line"># string len </span><br><span class="line">echo $&#123;#name1&#125;</span><br><span class="line"></span><br><span class="line"># string substring</span><br><span class="line">echo &#96;expr index &quot;$&#123;name1&#125;&quot; ha&#96;</span><br><span class="line"></span><br><span class="line"># string substring</span><br><span class="line">string_cat&#x3D;&quot;aaaaaaaaaaaaa&quot;</span><br><span class="line">string_cat&#x3D;$&#123;string_cat:1:5&#125;</span><br><span class="line">echo $string_cat</span><br><span class="line"></span><br><span class="line">###########################</span><br><span class="line">#array </span><br><span class="line">array_name&#x3D;(1 2 3 4 5 6)</span><br><span class="line">array_name[7]&#x3D;7</span><br><span class="line">echo $&#123;array_name[7]&#125;</span><br><span class="line"># 取得数组元素的个数</span><br><span class="line">length&#x3D;$&#123;#array_name[@]&#125;</span><br><span class="line">length&#x3D;$&#123;#array_name[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度</span><br><span class="line">lengthn&#x3D;$&#123;#array_name[n]&#125;</span><br><span class="line"></span><br><span class="line">######################</span><br><span class="line">  </span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#########################</span><br><span class="line">a&#x3D;10;</span><br><span class="line">b&#x3D;20;</span><br><span class="line">val&#x3D;&#96;expr $a + $b&#96;</span><br><span class="line">echo &quot;a + b : $val&quot;</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $a - $b&#96;</span><br><span class="line">echo &quot;a - b : $val&quot;</span><br><span class="line">#乘号(*)前边必须加反斜杠(\)才能实现乘法运算；</span><br><span class="line">val&#x3D;&#96;expr $a \* $b&#96;</span><br><span class="line">echo &quot;a * b : $val&quot;</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $b &#x2F; $a&#96;</span><br><span class="line">echo &quot;b &#x2F; a : $val&quot;</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $b % $a&#96;</span><br><span class="line">echo &quot;b % a : $val&quot;</span><br><span class="line">#条件表达式要放在方括号之间，并且要有空格，例如: [$a&#x3D;&#x3D;$b] 是错误的，必须写成 [ $a &#x3D;&#x3D; $b ]</span><br><span class="line">if [ $a &#x3D;&#x3D; $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a !&#x3D; $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ne $b: a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ne $b : a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -gt $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -gt $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -lt $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -lt $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ge $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ge $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -le $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -le $b: a 大于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#----------------------------导论----------------------</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">Shell 和其他编程语言一样，支持多种运算符，包括：</span><br><span class="line"></span><br><span class="line">    算数运算符</span><br><span class="line">    关系运算符</span><br><span class="line">    布尔运算符</span><br><span class="line">    字符串运算符</span><br><span class="line">    文件测试运算符</span><br><span class="line"></span><br><span class="line">原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</span><br><span class="line"></span><br><span class="line">expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</span><br><span class="line"></span><br><span class="line">例如，两个数相加(注意使用的是反引号 &#96; 而不是单引号 &#39;)：</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr 2 + 2&#96;</span><br><span class="line">echo &quot;两数之和为 : $val&quot;</span><br><span class="line">#表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</span><br><span class="line">#完整的表达式要被 &#96; &#96; 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</span><br><span class="line">#----------------------------运算----------------------</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">+ 	加法 	&#96;expr $a + $b&#96; 结果为 30。</span><br><span class="line">- 	减法 	&#96;expr $a - $b&#96; 结果为 -10。</span><br><span class="line">* 	乘法 	&#96;expr $a \* $b&#96; 结果为  200。</span><br><span class="line">&#x2F; 	除法 	&#96;expr $b &#x2F; $a&#96; 结果为 2。</span><br><span class="line">% 	取余 	&#96;expr $b % $a&#96; 结果为 0。</span><br><span class="line">&#x3D; 	赋值 	a&#x3D;$b 将把变量 b 的值赋给 a。</span><br><span class="line">&#x3D;&#x3D; 	相等。用于比较两个数字，相同则返回 true。 	[ $a &#x3D;&#x3D; $b ] 返回 false。</span><br><span class="line">!&#x3D; 	不相等。用于比较两个数字，不相同则返回 true。 	[ $a !&#x3D; $b ] 返回 true。</span><br><span class="line">EOF</span><br><span class="line">a&#x3D;10</span><br><span class="line">b&#x3D;20</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $a + $b&#96;</span><br><span class="line">echo &quot;a + b : $val&quot;</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $a - $b&#96;</span><br><span class="line">echo &quot;a - b : $val&quot;</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $a \* $b&#96;</span><br><span class="line">echo &quot;a * b : $val&quot;</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $b &#x2F; $a&#96;</span><br><span class="line">echo &quot;b &#x2F; a : $val&quot;</span><br><span class="line"></span><br><span class="line">val&#x3D;&#96;expr $b % $a&#96;</span><br><span class="line">echo &quot;b % a : $val&quot;</span><br><span class="line"></span><br><span class="line">#----------------------------关系运算符----------------------</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line"> 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</span><br><span class="line"></span><br><span class="line">下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</span><br><span class="line">运算符 	说明 	举例</span><br><span class="line">-eq 	检测两个数是否相等，相等返回 true。 	[ $a -eq $b ] 返回 false。</span><br><span class="line">-ne 	检测两个数是否不相等，不相等返回 true。 	[ $a -ne $b ] 返回 true。</span><br><span class="line">-gt 	检测左边的数是否大于右边的，如果是，则返回 true。 	[ $a -gt $b ] 返回 false。</span><br><span class="line">-lt 	检测左边的数是否小于右边的，如果是，则返回 true。 	[ $a -lt $b ] 返回 true。</span><br><span class="line">-ge 	检测左边的数是否大于等于右边的，如果是，则返回 true。 	[ $a -ge $b ] 返回 false。</span><br><span class="line">-le 	检测左边的数是否小于等于右边的，如果是，则返回 true。 	[ $a -le $b ] 返回 true。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">布尔运算符</span><br><span class="line"></span><br><span class="line">下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</span><br><span class="line">运算符 	说明 	举例</span><br><span class="line">! 	非运算，表达式为 true 则返回 false，否则返回 true。 	[ ! false ] 返回 true。</span><br><span class="line">-o 	或运算，有一个表达式为 true 则返回 true。 	[ $a -lt 20 -o $b -gt 100 ] 返回 true。</span><br><span class="line">-a 	与运算，两个表达式都为 true 才返回 true。 	[ $a -lt 20 -a $b -gt 100 ] 返回 false。</span><br><span class="line"></span><br><span class="line">逻辑运算符</span><br><span class="line"></span><br><span class="line">以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</span><br><span class="line">运算符 	说明 	举例</span><br><span class="line">&amp;&amp; 	逻辑的 AND 	[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</span><br><span class="line">|| 	逻辑的 OR 	[[ $a -lt 100 || $b -gt 100 ]] 返回 true</span><br><span class="line"></span><br><span class="line">字符串运算符</span><br><span class="line"></span><br><span class="line">下表列出了常用的字符串运算符，假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;：</span><br><span class="line">运算符 	说明 	举例</span><br><span class="line">&#x3D; 	检测两个字符串是否相等，相等返回 true。 	[ $a &#x3D; $b ] 返回 false。</span><br><span class="line">!&#x3D; 	检测两个字符串是否相等，不相等返回 true。 	[ $a !&#x3D; $b ] 返回 true。</span><br><span class="line">-z 	检测字符串长度是否为0，为0返回 true。 	[ -z $a ] 返回 false。</span><br><span class="line">-n 	检测字符串长度是否为0，不为0返回 true。 	[ -n &quot;$a&quot; ] 返回 true。</span><br><span class="line">str 	检测字符串是否为空，不为空返回 true。 	[ $a ] 返回 true。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件测试运算符</span><br><span class="line"></span><br><span class="line">文件测试运算符用于检测 Unix 文件的各种属性。</span><br><span class="line"></span><br><span class="line">属性检测描述如下：</span><br><span class="line">操作符 	说明 	举例</span><br><span class="line">-b file 	检测文件是否是块设备文件，如果是，则返回 true。 	[ -b $file ] 返回 false。</span><br><span class="line">-c file 	检测文件是否是字符设备文件，如果是，则返回 true。 	[ -c $file ] 返回 false。</span><br><span class="line">-d file 	检测文件是否是目录，如果是，则返回 true。 	[ -d $file ] 返回 false。</span><br><span class="line">-f file 	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 	[ -f $file ] 返回 true。</span><br><span class="line">-g file 	检测文件是否设置了 SGID 位，如果是，则返回 true。 	[ -g $file ] 返回 false。</span><br><span class="line">-k file 	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 	[ -k $file ] 返回 false。</span><br><span class="line">-p file 	检测文件是否是有名管道，如果是，则返回 true。 	[ -p $file ] 返回 false。</span><br><span class="line">-u file 	检测文件是否设置了 SUID 位，如果是，则返回 true。 	[ -u $file ] 返回 false。</span><br><span class="line">-r file 	检测文件是否可读，如果是，则返回 true。 	[ -r $file ] 返回 true。</span><br><span class="line">-w file 	检测文件是否可写，如果是，则返回 true。 	[ -w $file ] 返回 true。</span><br><span class="line">-x file 	检测文件是否可执行，如果是，则返回 true。 	[ -x $file ] 返回 true。</span><br><span class="line">-s file 	检测文件是否为空（文件大小是否大于0），不为空返回 true。 	[ -s $file ] 返回 true。</span><br><span class="line">-e file 	检测文件（包括目录）是否存在，如果是，则返回 true。 	[ -e $file ] 返回 true。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line">变量 file 表示文件&quot;&#x2F;var&#x2F;www&#x2F;runoob&#x2F;test.sh&quot;，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">shell 函数</span><br><span class="line">linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</span><br><span class="line"></span><br><span class="line">shell中函数的定义格式如下：</span><br><span class="line"></span><br><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">1.可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</span><br><span class="line">2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br><span class="line">#函数返回值在调用该函数后通过 $? 来获得。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------------------------------------函数参数</span><br><span class="line">在Shell中，调用函数时可以向其传递参数。</span><br><span class="line">在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...</span><br><span class="line"></span><br><span class="line">带参数的函数示例：</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"></span><br><span class="line">注意，$10 不能获取第十个参数，获取第十个参数需要$&#123;10&#125;。当n&gt;&#x3D;10时，需要使用$&#123;n&#125;来获取参数。</span><br><span class="line">另外，还有几个特殊字符用来处理参数：</span><br><span class="line"></span><br><span class="line">参数处理	说明</span><br><span class="line">$#	传递到脚本的参数个数</span><br><span class="line">$*	以一个单字符串显示所有向脚本传递的参数</span><br><span class="line">$$	脚本运行的当前进程ID号</span><br><span class="line">$!	后台运行的最后一个进程的ID号</span><br><span class="line">$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">$-	显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"># ----------------------echo</span><br><span class="line">#这里的双引号完全可以省略，以下命令与上面实例效果一致：</span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line"></span><br><span class="line">echo It is a test</span><br><span class="line">#2.显示转义字符</span><br><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;</span><br><span class="line">&quot;It is a test&quot;</span><br><span class="line"></span><br><span class="line">#--------------------read</span><br><span class="line">#read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">read name </span><br><span class="line">echo &quot;$name It is a test&quot;</span><br><span class="line">以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</span><br><span class="line"></span><br><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br><span class="line">EOF</span><br><span class="line">#------------------换行</span><br><span class="line">#4.显示换行</span><br><span class="line">echo -e &quot;OK! \n&quot; # -e 开启转义</span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line"></span><br><span class="line">#5.显示不换行</span><br><span class="line"></span><br><span class="line">echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--------------结果定向至文件</span><br><span class="line">echo &quot;It is a test&quot; &gt; myfile</span><br><span class="line"></span><br><span class="line">#---原样输出字符串，不进行转义或取变量(用单引号)</span><br><span class="line">echo &#39;$name\&quot;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#----显示命令执行结果</span><br><span class="line">echo &#96;date&#96;</span><br><span class="line">#注意： 这里使用的是反引号 &#96;, 而不是单引号 &#39;。</span><br><span class="line"></span><br><span class="line">#-----------结果将显示当前日期</span><br><span class="line"></span><br><span class="line">#Thu Jul 24 10:08:46 CST 2014</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------#------------------------------------------------</span><br><span class="line"></span><br><span class="line"># ------------------printf-----------------------</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">rintf 命令的语法：</span><br><span class="line">printf  format-string  [arguments...]</span><br><span class="line">参数说明：</span><br><span class="line">format-string: 为格式控制字符串</span><br><span class="line">arguments: 为参数列表。</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876</span><br><span class="line"></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">%s %c %d %f都是格式替代符</span><br><span class="line"></span><br><span class="line">%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</span><br><span class="line"></span><br><span class="line">%-4.2f 指格式化为小数，其中.2指保留2位小数。</span><br><span class="line"></span><br><span class="line">\a	警告字符，通常为ASCII的BEL字符</span><br><span class="line">\b	后退</span><br><span class="line">\c	抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</span><br><span class="line">\f	换页（formfeed）</span><br><span class="line">\n	换行</span><br><span class="line">\r	回车（Carriage return）</span><br><span class="line">\t	水平制表符</span><br><span class="line">\v	垂直制表符</span><br><span class="line">\\	一个字面上的反斜杠字符</span><br><span class="line">\ddd	表示1到3位数八进制值的字符。仅在格式字符串中有效</span><br><span class="line">\0ddd	表示1到3位的八进制值字符</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------</span><br><span class="line">#------------------------------------------------#------------------------------------------------</span><br><span class="line"></span><br><span class="line"># ------------------test-----------------------</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</span><br><span class="line"></span><br><span class="line">数值测试</span><br><span class="line">参数	说明</span><br><span class="line">-eq	等于则为真</span><br><span class="line">-ne	不等于则为真</span><br><span class="line">-gt	大于则为真</span><br><span class="line">-ge	大于等于则为真</span><br><span class="line">-lt	小于则为真</span><br><span class="line">-le	小于等于则为真</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1&#x3D;100</span><br><span class="line">num2&#x3D;100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#39;两个数相等！&#39;</span><br><span class="line">else</span><br><span class="line">    echo &#39;两个数不相等！&#39;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#代码中的 [] 执行基本的算数运算，</span><br><span class="line">a&#x3D;5</span><br><span class="line">b&#x3D;6</span><br><span class="line"></span><br><span class="line">result&#x3D;$[a+b] # 注意等号两边不能有空格</span><br><span class="line">echo &quot;result 为： $result&quot;</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">字符串测试</span><br><span class="line">参数	说明</span><br><span class="line">&#x3D;	等于则为真</span><br><span class="line">!&#x3D;	不相等则为真</span><br><span class="line">-z 字符串	字符串的长度为零则为真</span><br><span class="line">-n 字符串	字符串的长度不为零则为真</span><br><span class="line">实例演示：</span><br><span class="line"></span><br><span class="line">num1&#x3D;&quot;ru1noob&quot;</span><br><span class="line">num2&#x3D;&quot;runoob&quot;</span><br><span class="line">if test $num1 &#x3D; $num2</span><br><span class="line">then</span><br><span class="line">    echo &#39;两个字符串相等!&#39;</span><br><span class="line">else</span><br><span class="line">    echo &#39;两个字符串不相等!&#39;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件测试</span><br><span class="line">参数	说明</span><br><span class="line">-e 文件名	如果文件存在则为真</span><br><span class="line">-r 文件名	如果文件存在且可读则为真</span><br><span class="line">-w 文件名	如果文件存在且可写则为真</span><br><span class="line">-x 文件名	如果文件存在且可执行则为真</span><br><span class="line">-s 文件名	如果文件存在且至少有一个字符则为真</span><br><span class="line">-d 文件名	如果文件存在且为目录则为真</span><br><span class="line">-f 文件名	如果文件存在且为普通文件则为真</span><br><span class="line">-c 文件名	如果文件存在且为字符型特殊文件则为真</span><br><span class="line">-b 文件名	如果文件存在且为块特殊文件则为真</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!&quot;最高，&quot;-a&quot;次之，&quot;-o&quot;最低。例如：</span><br><span class="line"></span><br><span class="line">cd &#x2F;bin</span><br><span class="line">if test -e .&#x2F;notFile -o -e .&#x2F;bash</span><br><span class="line">then</span><br><span class="line">    echo &#39;至少有一个文件存在!&#39;</span><br><span class="line">else</span><br><span class="line">    echo &#39;两个文件都不存在&#39;</span><br><span class="line">fi</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">shell 函数</span><br><span class="line">linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</span><br><span class="line"></span><br><span class="line">shell中函数的定义格式如下：</span><br><span class="line"></span><br><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">1.可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</span><br><span class="line">2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br><span class="line">#函数返回值在调用该函数后通过 $? 来获得。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------------------------------------函数参数</span><br><span class="line">在Shell中，调用函数时可以向其传递参数。</span><br><span class="line">在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...</span><br><span class="line"></span><br><span class="line">带参数的函数示例：</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># author:菜鸟教程</span><br><span class="line"># url:www.runoob.com</span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"></span><br><span class="line">注意，$10 不能获取第十个参数，获取第十个参数需要$&#123;10&#125;。当n&gt;&#x3D;10时，需要使用$&#123;n&#125;来获取参数。</span><br><span class="line">另外，还有几个特殊字符用来处理参数：</span><br><span class="line"></span><br><span class="line">参数处理	说明</span><br><span class="line">$#	传递到脚本的参数个数</span><br><span class="line">$*	以一个单字符串显示所有向脚本传递的参数</span><br><span class="line">$$	脚本运行的当前进程ID号</span><br><span class="line">$!	后台运行的最后一个进程的ID号</span><br><span class="line">$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。</span><br><span class="line">$-	显示Shell使用的当前选项，与set命令功能相同。</span><br><span class="line">$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="监控系统信息"><a href="#监控系统信息" class="headerlink" title="监控系统信息"></a>监控系统信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Get system infomation</span><br><span class="line">(</span><br><span class="line">sys_time&#x3D;$(date +&quot;%Y-%m-%d %k:%M:%S&quot;)</span><br><span class="line">#os_version&#x3D;$(lsb_release -a | sed -n &#39;&#x2F;Description&#x2F;p&#39; | awk -F &#39;[:]&#39; &#39;&#123;print $2&#125;&#39; | sed &#39;s&#x2F;^[[:space:]]*&#x2F;&#x2F;&#39;)</span><br><span class="line">os_version&#x3D;$(cat &#x2F;etc&#x2F;issue | grep Linux)</span><br><span class="line">kernel_release&#x3D;$(uname -r)</span><br><span class="line">netcard_num&#x3D;$(ifconfig -a | grep eth | wc -l)</span><br><span class="line">echo &quot;[public_info]&quot;</span><br><span class="line">echo -e &quot;sys_time&#x3D;$sys_time\t#系统时间&quot;</span><br><span class="line">echo -e &quot;os_version&#x3D;$os_version\t#操作系统版本&quot;</span><br><span class="line">echo -e &quot;kernel-release&#x3D;$kernel_release\t#内核版本&quot;</span><br><span class="line"></span><br><span class="line">#########NETCADE INFOMATION##########</span><br><span class="line">echo </span><br><span class="line">echo &quot;[netcard_info]&quot;</span><br><span class="line">echo &quot;netcard_num&#x3D;$netcard_num&quot;</span><br><span class="line">echo &quot;#网卡名字|IP|MAC|网卡驱动|网卡速率|网卡发送流量(bytes)|网卡接收流量(bytes)|网卡总流量(bytes)&quot;</span><br><span class="line">for((n&#x3D;0;n&lt;$netcard_num;n++))</span><br><span class="line">do</span><br><span class="line">Receive_byte&#x3D;$(cat &#x2F;proc&#x2F;net&#x2F;dev | grep eth$n | awk &#39;&#123;print$2&#125;&#39;)</span><br><span class="line">Send_byte&#x3D;$(cat &#x2F;proc&#x2F;net&#x2F;dev | grep eth$n | awk &#39;&#123;print$10&#125;&#39;)</span><br><span class="line">echo &quot;netcard_$((n+1))&#x3D;eth$n|\</span><br><span class="line">$(ifconfig eth$n | grep &quot;inet addr&quot; | awk &#39;&#123;print$2&#125;&#39; | awk -F&#39;[:]&#39; &#39;&#123;print$2&#125;&#39;)|\</span><br><span class="line">$(ifconfig -a | grep eth$n | awk &#39;&#123;print$5&#125;&#39;)|\</span><br><span class="line">$(ethtool eth$n | grep Speed | awk &#39;&#123;print$2&#125;&#39; | sed &#39;s&#x2F;^[[:space:]]*&#x2F;&#x2F;&#39;)|\</span><br><span class="line">$&#123;Receive_byte&#125;|\</span><br><span class="line">$&#123;Send_bytei&#125;|\</span><br><span class="line">$(($Receive_byte + $Send_byte))&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">##########CPU INFOMATION##############</span><br><span class="line">cpu_phical_count&#x3D;$(cat &#x2F;proc&#x2F;cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l)</span><br><span class="line">cpu_model&#x3D;$(cat &#x2F;proc&#x2F;cpuinfo | grep &quot;model name&quot; | uniq | awk -F&#39;[:]&#39; &#39;&#123;print$2&#125;&#39;)</span><br><span class="line">cpu_core_num&#x3D;$(cat &#x2F;proc&#x2F;cpuinfo | grep cores | uniq | awk -F&#39;[:]&#39; &#39;&#123;print $2&#125;&#39; | sed &#39;s&#x2F;^[[:space:]]*&#x2F;&#x2F;&#39;)</span><br><span class="line">cpu_process_num&#x3D;$(cat &#x2F;proc&#x2F;cpuinfo | grep process | wc -l)</span><br><span class="line">cpu_frequency&#x3D;$(cat &#x2F;proc&#x2F;cpuinfo |grep MHz|uniq | awk -F&#39;[:]&#39; &#39;&#123;print $2&#125;&#39; | sed &#39;s&#x2F;^[[:space:]]*&#x2F;&#x2F;&#39;)</span><br><span class="line">cache_size&#x3D;$(cat &#x2F;proc&#x2F;cpuinfo | grep &quot;cache size&quot; | uniq | awk -F&#39;[:]&#39; &#39;&#123;print$2&#125;&#39;)</span><br><span class="line">cpu_idle&#x3D;$(mpstat | grep all | awk &#39;&#123;print$11&#125;&#39;)</span><br><span class="line">cpu_used&#x3D;$(mpstat | grep all | awk &#39;&#123;print$3&#125;&#39;)</span><br><span class="line">echo</span><br><span class="line">echo &quot;[cpu_info]&quot;</span><br><span class="line">echo -e &quot;cpu_model&#x3D;$cpu_model\t#cpu型号&quot;</span><br><span class="line">echo -e &quot;cpu_core_num&#x3D;$cpu_core_num\t#cpu核数&quot;</span><br><span class="line">echo -e &quot;cpu_phical_count&#x3D;$cpu_phical_count\t#cpu个数&quot;</span><br><span class="line">echo -e &quot;cpu_frequendy&#x3D;$cpu_frequency\t#主频&#x2F;单个&quot;</span><br><span class="line">echo -e &quot;cache_size&#x3D;$&#123;cache_size&#125;*$cpu_process_num\t#缓存&quot;</span><br><span class="line">echo -e &quot;cpu_idle&#x3D;$&#123;cpu_idle&#125;%\t#空闲率&quot;</span><br><span class="line">echo -e &quot;cpu_used&#x3D;$&#123;cpu_used&#125;%\t#使用率&quot;</span><br><span class="line"></span><br><span class="line">###########memeber info###############</span><br><span class="line">echo</span><br><span class="line">echo &quot;[mem_info]&quot;</span><br><span class="line">echo -e &quot;mem_total&#x3D;$(free -m | grep Mem | awk &#39;&#123;print$2&#125;&#39;)\t#总内存&quot;</span><br><span class="line">echo -e &quot;mem_used&#x3D;$(free -m | grep buffers&#x2F;cache | awk &#39;&#123;print$3&#125;&#39;)\t#已使用&quot;</span><br><span class="line">echo -e &quot;mem_free&#x3D;$(free -m | grep buffers&#x2F;cache | awk &#39;&#123;print$4&#125;&#39;)\t#可使用&quot;</span><br><span class="line"></span><br><span class="line">###########hard info ##################</span><br><span class="line">file_system_num&#x3D;$(df -Ph | grep &#x2F; | wc -l)</span><br><span class="line">echo</span><br><span class="line">echo &quot;[hard_info]&quot;</span><br><span class="line">echo &quot;file_system_num&#x3D;$file_system_num&quot;</span><br><span class="line">echo &quot;#磁盘总容量(单位M)|已用容量(单位M)|可用流量(单位M)|已用百分比（%）|挂载目录&quot;</span><br><span class="line">df -Pm | grep &#x2F; | awk &#39;&#123;print$2&quot;|&quot;$3&quot;|&quot;$4&quot;|&quot;$5&quot;|&quot;$6&#125;&#39;</span><br><span class="line">exit 0</span><br><span class="line">) &gt;system_infomation.txt</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Docker/DockerCompose/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="DockerCompose笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T05:01:29.000Z" title="2020-08-07T05:01:29.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Docker/">Docker</a></span><span class="level-item">a few seconds read (About 61 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Docker/DockerCompose/">DockerCompose笔记</a></h1><div class="content"><p>Docker Compose工具是为了加快多个Docker容器部署工具，可以一键部署、启动、暂停多个容器。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>docker-compose up -d</code> 后台启动当前目录下的docker-compose.yml文件的容器</p>
<!-- mroe --></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Linux/linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B7%A5%E5%85%B7/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="linux有趣的工具"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:59:58.000Z" title="2020-08-07T04:59:58.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Linux/">Linux</a></span><span class="level-item">11 minutes read (About 1724 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Linux/linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B7%A5%E5%85%B7/">linux有趣的工具</a></h1><div class="content"><p> 这是慕课上的作业笔记，网站以后再补。</p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2></div><a class="article-more button is-small size-small" href="/2020/08/07/Code%20tools/Linux/linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B7%A5%E5%85%B7/#more">Read More</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Windows/window%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="window工作环境"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:58:08.000Z" title="2020-08-07T04:58:08.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Windows/">Windows</a></span><span class="level-item">2 minutes read (About 296 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Windows/window%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/">window工作环境</a></h1><div class="content"><p>都知道Window的PATH和工具包管理的缺乏是公认的难用，不巧的是Linux的系统不是那么让我喜爱，尤其很多软件在Linux兼容性不好。如今WLS的推出了让我们可以在Window下直接体验近乎原生linux的畅爽体验，(虽然说虚拟机+linux+局域网连接好像也行，就是太费资源了)。</p>
<!-- mroe -->

<p>盘一盘我的Window下安装工具和配置方式：</p>
<ul>
<li>Fluent-Terminal 工具美化原生的WSL终端和PS界面<ul>
<li><a href="https://iterm2colorschemes.com/">配色方案</a>超级多</li>
<li>方便调节字体、透明度、支持快捷键、标签式管理页面啧啧啧~</li>
</ul>
</li>
<li>VSCode：刚刚入坑，听说了宇宙第一编辑器的大名久已<ul>
<li><a href="https://code.visualstudio.com/docs/?dv=win">官方入门</a></li>
<li>可配合WSL本地远程编程， 可参考<a href="https://code.visualstudio.com/docs/?dv=win">Dev in WSL</a></li>
<li><a href="https://code.visualstudio.com/docs/cpp/config-wsl#_step-through-the-code">VS在WSL进行开发调试</a></li>
</ul>
</li>
<li>WSL：不论是WSL1，还是WSL2功能都非常的强大，诶忍不住的香<ul>
<li>可参考<a href="https://code.visualstudio.com/docs/?dv=win">Dev in WSL</a></li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Windows/win10%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="win10基本技巧"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:57:20.000Z" title="2020-08-07T04:57:20.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Windows/">Windows</a></span><span class="level-item">2 minutes read (About 328 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Windows/win10%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/">win10基本技巧</a></h1><div class="content"><!-- mroe -->

<h1 id="WIN10基本技巧"><a href="#WIN10基本技巧" class="headerlink" title="WIN10基本技巧"></a>WIN10基本技巧</h1><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h2><p><code>cmd</code> 运行cmd Terminal</p>
<p><code>services.msc</code> 打开服务窗口（也可以通过任务管理器的服务页打开，或者计算机管理的 “服务和应用程序/服务”打开）。</p>
<p><code>shell:startup</code>打开开机自启动软件的文件夹。</p>
<p><code>msinfo32</code>显示系统详细信息</p>
<h2 id="CMD指令"><a href="#CMD指令" class="headerlink" title="CMD指令"></a>CMD指令</h2><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><p>TREE [drive:][path] [/F] [/A]</p>
<p>/F 显示每个文件夹中文件的名称。（带扩展名）</p>
<p>/A 使用 ASCII 字符，而不使用扩展字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">tree -f &gt; list.txt  -- 将带扩展名的文件目录输出到list.txt文件中</span><br><span class="line">卷 资料 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 70BA-EEC3</span><br><span class="line">H:.</span><br><span class="line">│  README.md</span><br><span class="line">│  README.txt</span><br><span class="line">│  </span><br><span class="line">├─grangerData</span><br><span class="line">│  ├─Airdata1</span><br><span class="line">│  │      1226A_filled.csv</span><br><span class="line">│  │      1239A_filled.csv</span><br><span class="line">│  │      1241A_filled.csv</span><br><span class="line">│  │      1243A_filled.csv</span><br><span class="line">│  │      1247A_filled.csv</span><br><span class="line">│  │      1260A_filled.csv</span><br><span class="line">│  │      </span><br><span class="line">│  ├─matched</span><br><span class="line">│  │      1226A_58457_filled.csv</span><br><span class="line">│  │      1239A_58569_filled.csv</span><br><span class="line">│  │      1241A_58239_filled.csv</span><br><span class="line">│  │      1243A_58752_filled.csv</span><br><span class="line">│</span><br></pre></td></tr></table></figure>

<h3 id="Ver"><a href="#Ver" class="headerlink" title="Ver"></a>Ver</h3><p>显示系统版本信息。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="进入安全模式"><a href="#进入安全模式" class="headerlink" title="进入安全模式"></a>进入安全模式</h3><p>在锁屏界面点击电源，按下shift键，再点击重启。在弹出的蓝色界面中依次选择“疑难解惑”-“高级方案”-“重启”-“安全模式”（有点记不清了）</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Windows/wls2%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="wls2折腾笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:56:47.000Z" title="2020-08-07T04:56:47.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Windows/">Windows</a></span><span class="level-item">3 minutes read (About 471 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Windows/wls2%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/">wls2折腾笔记</a></h1><div class="content"><p><a href="https://docs.microsoft.com/en-us/windows/wsl/about">推荐阅读官方博客</a> 其中对<a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-index">WSL2介绍</a>。<br>基于 Hyper-V 结构，WSL2大幅改进了上一代WSL在系统层面的的I/O效率，增加了系统调用的全面性，甚至还能支持Docker,唯一遗憾的是网关上做了隔离（？）。</p>
<!-- mroe -->

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>安装官网博客的配置后，应该已经能够使用WLS2了。快速摘录几条命令。<br>更改Linux distro的WLS的运行版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-version &lt;Distro&gt; 2 #设置为启动WSL2</span><br><span class="line">wsl --set-version &lt;Distro&gt; 1 #设置为启动WSL1</span><br></pre></td></tr></table></figure>

<p>设置默认安装distr的WSL2版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>

<p>检查各个distr的WSL版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --list --verbose #or wsl -l -v</span><br></pre></td></tr></table></figure>

<h2 id="网络连接问题"><a href="#网络连接问题" class="headerlink" title="网络连接问题"></a>网络连接问题</h2><h3 id="Linux连PC"><a href="#Linux连PC" class="headerlink" title="Linux连PC"></a>Linux连PC</h3><p>（In the initial builds of WSL2 preview）从Linux访问Windows中软件需要Linux连接主机的host ip。</p>
<p>获取主机LAN IP方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.comf</span><br></pre></td></tr></table></figure>

<p>之后就可以使用该IP地址连接到PC的服务器上了。</p>
<h3 id="PC连Linux"><a href="#PC连Linux" class="headerlink" title="PC连Linux"></a>PC连Linux</h3><p>在高于18945版本的WIN10系统可以直接访问Localhost来访问Linux Dis的服务器。对应的低于此版本的WIN10需要获取Linux虚拟机的IP地址。即可由以下命令获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr | grep  eth0</span><br></pre></td></tr></table></figure>

<h2 id="迁移WSL"><a href="#迁移WSL" class="headerlink" title="迁移WSL"></a>迁移WSL</h2><p>如果你更换了电脑，如何将WSL迁移至新的电脑或windows系统中呢？</p>
<p>在旧电脑或系统中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export distro_name file_name.tar</span><br></pre></td></tr></table></figure>

<p>此时wsl系统已经被打包成tar文件，在新的电脑或系统中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import distro_name install_location file_name.tar</span><br></pre></td></tr></table></figure>

<p>此时就完成了wsl迁移。如果想删除wsl则执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister distro_name</span><br></pre></td></tr></table></figure>

<p>查询wsl安装情况执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --list</span><br></pre></td></tr></table></figure>
<p>上述命令在windows powershell里执行。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/VScode/Vscode%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Vscode笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:56:13.000Z" title="2020-08-07T04:56:13.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/VScode/">VScode</a></span><span class="level-item">a few seconds read (About 72 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/VScode/Vscode%E7%AC%94%E8%AE%B0/">Vscode笔记</a></h1><div class="content"><!-- mroe -->



<h1 id="VS-Code-使用笔记"><a href="#VS-Code-使用笔记" class="headerlink" title="VS Code 使用笔记"></a><a href="http://blog.come2rss.xyz/2020/05/07/tools/vs-code/">VS Code 使用笔记</a></h1><h2 id="优秀插件"><a href="#优秀插件" class="headerlink" title="优秀插件"></a>优秀插件</h2><p><code>Code Runne</code>集成大多数语言的运行命令，一键运行。</p>
<blockquote>
<p>在Setting的extension中可以设置<code>Run Code Configuration</code>的Run in Terminal为True，可以方便在终端中输入输出程序</p>
</blockquote>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Pycharm/Pycharm/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Pycharm笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:54:38.000Z" title="2020-08-07T04:54:38.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Pycharm/">Pycharm</a></span><span class="level-item">10 minutes read (About 1471 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Pycharm/Pycharm/">Pycharm笔记</a></h1><div class="content"><p>足够的搜索能力和优秀英文阅读能力才是驾驭一个优秀的IED的不二法宝。</p>
<h2 id="虚拟空间"><a href="#虚拟空间" class="headerlink" title="虚拟空间"></a>虚拟空间</h2><p>血的教训</p>
<ul>
<li><p>不要随便改项目文件的路径，不然可能导致项目的terminal无法使用正确的解释器</p>
<!-- mroe -->
</li>
<li><p>升级包的两种方法：命令升级；Setting中的点击特定package并在新页面中选定特定版本Install即可。</p>
</li>
</ul>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>Terminal 可以在setting的tools里调整Terminal的解释器。</p>
<p>Terminal检查解释器和激活虚拟空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在Terminal中进入文件，并激活</span><br><span class="line">cd .&#x2F;venv&#x2F;Scripts</span><br><span class="line">activate</span><br><span class="line">检查：创建文件test，内容如下</span><br><span class="line">import pip;</span><br><span class="line">print(pip.__file__)</span><br><span class="line">运行后查看路径是否在虚拟环境即可判断</span><br></pre></td></tr></table></figure>



<h2 id="Pycharm快捷键"><a href="#Pycharm快捷键" class="headerlink" title="Pycharm快捷键"></a>Pycharm快捷键</h2><p><a href="https://www.jianshu.com/p/00461341771b">作者：意气相许的许</a></p>
<p><strong>PyCharm3.0默认快捷键</strong></p>
<p><strong>1、编辑（Editing）</strong></p>
<p>Ctrl + Space 基本的代码完成（类、方法、属性）</p>
<p>Ctrl + Alt + Space 快速导入任意类</p>
<p>Ctrl + Shift + Enter 语句完成</p>
<p>Ctrl + P 参数信息（在方法中调用参数）</p>
<p>Ctrl + Q 快速查看文档</p>
<p>Shift + F1 外部文档</p>
<p>Ctrl + 鼠标 简介</p>
<p>Ctrl + F1 显示错误描述或警告信息</p>
<p>Alt + Insert 自动生成代码</p>
<p>Ctrl + O 重新方法</p>
<p>Ctrl + Alt + T 选中</p>
<p>Ctrl + / 行注释</p>
<p>Ctrl + Shift + / 块注释</p>
<p>Ctrl + W 选中增加的代码块</p>
<p>Ctrl + Shift + W 回到之前状态</p>
<p>Ctrl + Shift + ]/[ 选定代码块结束、开始</p>
<p>Alt + Enter 快速修正</p>
<p>Ctrl + Alt + L 代码格式化</p>
<p>Ctrl + Alt + O 优化导入</p>
<p>Ctrl + Alt + I 自动缩进</p>
<p>Tab / Shift + Tab 缩进、不缩进当前行</p>
<p>Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板</p>
<p>Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板</p>
<p>Ctrl+V/Shift+Insert 从剪贴板粘贴</p>
<p>Ctrl + Shift + V 从最近的缓冲区粘贴</p>
<p>Ctrl + D 复制选定的区域或行</p>
<p>Ctrl + Y 删除选定的行</p>
<p>Ctrl + Shift + J 添加智能线</p>
<p>Ctrl + Enter 智能线切割</p>
<p>Shift + Enter 另起一行</p>
<p>Ctrl + Shift + U 在选定的区域或代码块间切换</p>
<p>Ctrl + Delete 删除到字符结束</p>
<p>Ctrl + Backspace 删除到字符开始</p>
<p>Ctrl + Numpad+/- 展开折叠代码块</p>
<p>Ctrl + Numpad+ 全部展开</p>
<p>Ctrl + Numpad- 全部折叠</p>
<p>Ctrl + F4 关闭运行的选项卡</p>
<p><strong>2、查找/替换(Search/Replace)</strong></p>
<p>F3 下一个</p>
<p>Shift + F3 前一个</p>
<p>Ctrl + R 替换</p>
<p>Ctrl + Shift + F 全局查找</p>
<p>Ctrl + Shift + R 全局替换</p>
<p><strong>3、运行(Running)</strong></p>
<p>Alt + Shift + F10 运行模式配置</p>
<p>Alt + Shift + F9 调试模式配置</p>
<p>Shift + F10 运行</p>
<p>Shift + F9 调试</p>
<p>Ctrl + Shift + F10 运行编辑器配置</p>
<p>Ctrl + Alt + R 运行manage.py任务</p>
<p><strong>4、调试(Debugging)</strong></p>
<p>F8 跳过</p>
<p>F7 进入</p>
<p>Shift + F8 退出</p>
<p>Alt + F9 运行游标</p>
<p>Alt + F8 验证表达式</p>
<p>Ctrl + Alt + F8 快速验证表达式</p>
<p>F9 恢复程序</p>
<p>Ctrl + F8 断点开关</p>
<p>Ctrl + Shift + F8 查看断点</p>
<p><strong>5、导航(Navigation)</strong></p>
<p>Ctrl + N 跳转到类</p>
<p>Ctrl + Shift + N 跳转到符号</p>
<p>Alt + Right/Left 跳转到下一个、前一个编辑的选项卡</p>
<p>F12 回到先前的工具窗口</p>
<p>Esc 从工具窗口回到编辑窗口</p>
<p>Shift + Esc 隐藏运行的、最近运行的窗口</p>
<p>Ctrl + Shift + F4 关闭主动运行的选项卡</p>
<p>Ctrl + G 查看当前行号、字符号</p>
<p>Ctrl + E 当前文件弹出</p>
<p>Ctrl+Alt+Left/Right 后退、前进</p>
<p>Ctrl+Shift+Backspace 导航到最近编辑区域</p>
<p>Alt + F1 查找当前文件或标识</p>
<p>Ctrl+B / Ctrl+Click 跳转到声明</p>
<p>Ctrl + Alt + B 跳转到实现</p>
<p>Ctrl + Shift + I查看快速定义</p>
<p>Ctrl + Shift + B跳转到类型声明</p>
<p>Ctrl + U跳转到父方法、父类</p>
<p>Alt + Up/Down跳转到上一个、下一个方法</p>
<p>Ctrl + ]/[跳转到代码块结束、开始</p>
<p>Ctrl + F12弹出文件结构</p>
<p>Ctrl + H类型层次结构</p>
<p>Ctrl + Shift + H方法层次结构</p>
<p>Ctrl + Alt + H调用层次结构</p>
<p>F2 / Shift + F2下一条、前一条高亮的错误</p>
<p>F4 / Ctrl + Enter编辑资源、查看资源</p>
<p>Alt + Home显示导航条F11书签开关</p>
<p>Ctrl + Shift + F11书签助记开关</p>
<p>Ctrl + #[0-9]跳转到标识的书签</p>
<p>Shift + F11显示书签</p>
<p><strong>6、搜索相关(Usage Search)</strong></p>
<p>Alt + F7/Ctrl + F7文件中查询用法</p>
<p>Ctrl + Shift + F7文件中用法高亮显示</p>
<p>Ctrl + Alt + F7显示用法</p>
<p><strong>7、重构(Refactoring)</strong></p>
<p>F5复制F6剪切</p>
<p>Alt + Delete安全删除</p>
<p>Shift + F6重命名</p>
<p>Ctrl + F6更改签名</p>
<p>Ctrl + Alt + N内联</p>
<p>Ctrl + Alt + M提取方法</p>
<p>Ctrl + Alt + V提取属性</p>
<p>Ctrl + Alt + F提取字段</p>
<p>Ctrl + Alt + C提取常量</p>
<p>Ctrl + Alt + P提取参数</p>
<p><strong>8、控制VCS/Local History</strong></p>
<p>Ctrl + K提交项目</p>
<p>Ctrl + T更新项目</p>
<p>Alt + Shift + C查看最近的变化</p>
<p>Alt + BackQuote(’)VCS快速弹出</p>
<p><strong>9、模版(Live Templates)</strong></p>
<p>Ctrl + Alt + J当前行使用模版</p>
<p>Ctrl +Ｊ插入模版</p>
<p><strong>10、基本(General)</strong></p>
<p>Alt + #[0-9]打开相应的工具窗口</p>
<p>Ctrl + Alt + Y同步</p>
<p>Ctrl + Shift + F12最大化编辑开关</p>
<p>Alt + Shift + F添加到最喜欢</p>
<p>Alt + Shift + I根据配置检查当前文件</p>
<p>Ctrl + BackQuote(’)快速切换当前计划</p>
<p>Ctrl + Alt + S　打开设置页</p>
<p>Ctrl + Shift + A查找编辑器里所有的动作</p>
<p>Ctrl + Tab在窗口间进行切换</p>
<p><strong>一些常用设置：</strong></p>
<ol>
<li><p>pycharm默认是自动保存的，习惯自己按ctrl + s 的可以进行如下设置：</p>
<ul>
<li>.file -&gt; Setting -&gt; General -&gt; Synchronization -&gt; Save files on frame deactivation 和 Save files automatically if application is idle for .. sec 的勾去掉</li>
</ul>
</li>
<li><p>file -&gt;Setting -&gt; Editor -&gt; Editor Tabs -&gt; Mark modified tabs with asterisk 打上勾</p>
</li>
<li><p>Alt + Enter: 自动添加包</p>
</li>
<li><p>对于常用的快捷键，可以设置为visual studio(eclipse…)一样的：</p>
<p>file -&gt; Setting -&gt; Keymap -&gt; Keymaps -&gt; vuisual studio -&gt; Apply</p>
</li>
<li><p>Pycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在file -&gt; Setting -&gt;Editor-〉Mouse中设置</p>
</li>
<li><p>要设置Pycharm的字体，要先在file -&gt; Setting -&gt;Editor-〉Editor中选择一种风格并保存，然后才可以改变</p>
</li>
<li><p>在setting中搜索theme可以改变主题，所有配色统一改变</p>
</li>
</ol>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Matlab/Matlab%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Matlab笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:53:36.000Z" title="2020-08-07T04:53:36.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Matlab/">Matlab</a></span><span class="level-item">38 minutes read (About 5697 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Matlab/Matlab%E7%AC%94%E8%AE%B0/">Matlab笔记</a></h1><div class="content"><p>待学习的内容 <a href="https://blog.csdn.net/wangcj625/article/details/6287735">绘图大量的笔记</a></p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p><code>disp(Var)</code> 打印很方便</p>
<!-- mroe -->

<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;a &#x3D; pi; %pi &#x3D; pai </span><br><span class="line">&gt;&gt; disp(sprintf(&#39;2 decimals: %0.6f&#39;, a)) %字符串拼接和显示</span><br><span class="line">2 decimals: 3.141593</span><br></pre></td></tr></table></figure>

<p>:happy:</p>
<p>:kissing_heart:</p>
<p>:carousel_horse:</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a><strong>矩阵</strong></h2><p><strong>创建</strong></p>
<p>逗号和分号的运算起了标志行的作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; v &#x3D; [1 2 3]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">     1     2     3</span><br><span class="line"></span><br><span class="line">&gt;&gt; v  &#x3D; [1 ; 2; 3;]</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">     2</span><br><span class="line">     3</span><br><span class="line">&gt;&gt; v &#x3D; 1:0.1:2</span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000    1.8000    1.9000    2.0000</span><br></pre></td></tr></table></figure>

<p><strong>常见函数：</strong></p>
<p><code>ones(shape)</code> <code>zeroe(shape)</code> <code>rand(shape)</code> <code>randi(shape)</code> % shape 代表数字列， 如2，3，5，1。</p>
<p><code>randn(shape)</code> %正态分布的随机数 Gussses rand?</p>
<p><code>eye(K)</code> % 单位矩阵</p>
<p><strong>矩阵运算：</strong></p>
<p>常见的有矩阵乘法和矩阵点乘，点除，点方。</p>
<p>matlab不主持类似python的numpy的广播机制，但是仍然支持数字 + 矩阵的模式，同时 不同维度的矩阵无法相加减。</p>
<p><strong>广播</strong></p>
<p>只要阵列具有“兼容大小”，就允许在阵列之间进行上述二进制操作。当一个数组中的每个维度正好等于另一个数组中的相同维度，或者等于<code>1</code>时，大小被认为是“兼容的”。比如。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; magic(3) + (1:3)</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     9     3     9</span><br><span class="line">     4     7    10</span><br><span class="line">     5    11     5</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">描述</th>
<th align="left">第一个数组大小</th>
<th align="left">第二个数组大小</th>
<th align="left">结果大小</th>
</tr>
</thead>
<tbody><tr>
<td align="left">矢量和标量</td>
<td align="left"><code>[3x1]</code></td>
<td align="left"><code>[1x1]</code></td>
<td align="left"><code>[3x1]</code></td>
</tr>
<tr>
<td align="left">行和列向量</td>
<td align="left"><code>[1x3]</code></td>
<td align="left"><code>[2x1]</code></td>
<td align="left"><code>[2x3]</code></td>
</tr>
<tr>
<td align="left">矢量和二维矩阵</td>
<td align="left"><code>[1x3]</code></td>
<td align="left"><code>[5x3]</code></td>
<td align="left"><code>[5x3]</code></td>
</tr>
<tr>
<td align="left">ND和KD阵列</td>
<td align="left"><code>[1x3x3]</code></td>
<td align="left"><code>[5x3x1x4x2]</code></td>
<td align="left"><code>[5x3x3x4x2]</code></td>
</tr>
</tbody></table>
<p><strong>复制扩展</strong></p>
<p><code>repmat( A , m , n )</code> : 将向量／矩阵在垂直方向复制为m倍，在水平方向复制为n倍。</p>
<p><strong>求和以及其他函数</strong></p>
<p>引出一个matlab与python极为类似的但略有不同的概念，<code>axis</code>。常常在函数计算中起到指定运算方向的作用，如axis=1，则计算沿着竖直方向计算。</p>
<p>如<code>sum(A, axis)</code></p>
<p><a href="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1581927781476.png"><img src="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1581927781476.png" alt="1581927781476"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1581927781476.png">1581927781476</a></p>
<p>其他函数 如<code>mean()</code> <code>max()</code> 也是如此。</p>
<h2 id="索引以及选择"><a href="#索引以及选择" class="headerlink" title="索引以及选择"></a>索引以及选择</h2><p>matlab的数据索引从1开始。对于矩阵可以使用<code>[C]</code>进行矩阵的数据合并，<code>(C)</code>进行索引。对于cell元胞可以通过<code>{}</code>索引。</p>
<p><strong>Boolean索引</strong> 是一个非常强大的功能，通过逻辑表达式的组合可以删选出复杂的规则条件下的数据。而矩阵的逻辑运算一般都是扩展到各个元素的，这就方便了通过一个条件判断矩阵来索引出真正数据的操作。</p>
<p><strong>下标索引</strong> 拿一维矩阵来举例，常见的操作有 单一索引<code>A(1)</code>, 范围索引<code>A(1:end)</code>, 间隔索引 <code>A(1:2:end)</code> , 向量索引<code>A([1,3,5], :)</code>。如果其他维度的数据需要索引最好把其他维度索引也写上，不管是不是需要全部索引。（这些索引名字 我自己想的~~ ）:kiss: :kiss:</p>
<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; length(A) % give the longest dimension.</span><br><span class="line">&gt;&gt; who % 查看变量</span><br><span class="line">您的变量为:</span><br><span class="line"></span><br><span class="line">A    I    a    ans  c    v    w    </span><br><span class="line">&gt;&gt; whos % 查看变量</span><br><span class="line">  Name      Size                   Bytes  Class     Attributes</span><br><span class="line">  A         2x3                       48  double             </span><br><span class="line">  I         4x4                      128  double            </span><br><span class="line"></span><br><span class="line">%保存</span><br><span class="line">&gt;&gt; save  test 		% 保存所有变量 当然也可以用laod 载入mat</span><br><span class="line">&gt;&gt; save test2.mat Y % 保存单个变量</span><br><span class="line">&gt;&gt; save test2.txt Y -ascii % save as test(ASCII)</span><br></pre></td></tr></table></figure>

<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line">% 乘法</span><br><span class="line">&gt;&gt; A &#x3D; [1 2 ; 3 4 ; 5 6];</span><br><span class="line">&gt;&gt; B &#x3D; [2 3 ; 4 5];</span><br><span class="line">&gt;&gt; c &#x3D; A * B </span><br><span class="line"></span><br><span class="line">c &#x3D;</span><br><span class="line"></span><br><span class="line">    10    13</span><br><span class="line">    22    29</span><br><span class="line">    34    45</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">% element-wise operation</span><br><span class="line">% 一个3*1的矩阵和一个3*2的矩阵相乘类似于两个3 * 2的矩阵element-wise乘， 但是只要一个矩阵不是n*1或是1*n，或者两个矩阵维度不一样，那么就会无法element-wise乘。</span><br><span class="line">&gt;&gt; D &#x3D; A .* c </span><br><span class="line">D &#x3D;</span><br><span class="line"></span><br><span class="line">    10    26</span><br><span class="line">    66   116</span><br><span class="line">   170   270</span><br><span class="line">   </span><br><span class="line">&gt;&gt; A.^2 % element-wise operation</span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     1     4</span><br><span class="line">     9    16</span><br><span class="line">    25    36</span><br><span class="line">&gt;&gt; 1.&#x2F;A % element-wise operation </span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1.0000    0.5000</span><br><span class="line">    0.3333    0.2500</span><br><span class="line">    0.2000    0.1667</span><br><span class="line">&gt;&gt; v &lt; 3 % every element is judged.</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">  1×6 logical 数组</span><br><span class="line"></span><br><span class="line">   1   1   0   0   0   0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%% such as log(), abs() and exp() is element-wise opetation too.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%add</span><br><span class="line">&gt;&gt; A + ones(3,2)</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     2     3</span><br><span class="line">     4     5</span><br><span class="line">% 也可直接➕1</span><br><span class="line"></span><br><span class="line">&gt;&gt; A + 1</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     2     3</span><br><span class="line">     4     5</span><br><span class="line">     6     7</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">%transpose</span><br><span class="line">&gt;&gt; A&#39;</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     1     3     5</span><br><span class="line">     2     4     6</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">%max</span><br><span class="line">&gt;&gt; A</span><br><span class="line"></span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">     1     2</span><br><span class="line">     3     4</span><br><span class="line">     5     6</span><br><span class="line">&gt;&gt; max(A) % if A is matrix, output is column-wise</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     5     6</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">&gt;&gt; [val, idx] &#x3D; max([1     2     3     4     7     6])</span><br><span class="line"></span><br><span class="line">val &#x3D;</span><br><span class="line"></span><br><span class="line">     7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">idx &#x3D;</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">&gt;&gt; max([1     2     3     4     7     6])</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     7</span><br><span class="line">     </span><br><span class="line">&gt;&gt; R1 &#x3D; rand(3) % element-wise max</span><br><span class="line"></span><br><span class="line">R1 &#x3D;</span><br><span class="line"></span><br><span class="line">    0.4873    0.4805    0.8880</span><br><span class="line">    0.6459    0.1431    0.3434</span><br><span class="line">    0.8356    0.6037    0.5764</span><br><span class="line"></span><br><span class="line">&gt;&gt; R2 &#x3D; rand(3)</span><br><span class="line"></span><br><span class="line">R2 &#x3D;</span><br><span class="line"></span><br><span class="line">    0.2988    0.6937    0.2178</span><br><span class="line">    0.3194    0.7549    0.4476</span><br><span class="line">    0.6043    0.2309    0.6584</span><br><span class="line">&gt;&gt; max(R1, R2)</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    0.4873    0.6937    0.8880</span><br><span class="line">    0.6459    0.7549    0.4476</span><br><span class="line">    0.8356    0.6037    0.6584</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A, [], 1) % 1 means that get the max column-wise value. </span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     5     6</span><br><span class="line"></span><br><span class="line">&gt;&gt; A</span><br><span class="line"></span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">     1     2</span><br><span class="line">     3     4</span><br><span class="line">     5     6</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A, [], 2) % 2 is </span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     2</span><br><span class="line">     4</span><br><span class="line">     6</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(A(:))</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     6</span><br><span class="line"></span><br><span class="line">&gt;&gt; max(max(A))</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     6</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">%%find</span><br><span class="line">&gt;&gt; v</span><br><span class="line">v &#x3D; </span><br><span class="line"></span><br><span class="line">     1     2     3     4     5     6</span><br><span class="line"></span><br><span class="line">&gt;&gt; find(v &lt; 3) % to vector</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     1     2</span><br><span class="line">     </span><br><span class="line">&gt;&gt; M &#x3D; magic(3) % to matrix </span><br><span class="line"></span><br><span class="line">M &#x3D;</span><br><span class="line"></span><br><span class="line">     8     1     6</span><br><span class="line">     3     5     7</span><br><span class="line">     4     9     2</span><br><span class="line"></span><br><span class="line">&gt;&gt; find(M &lt; 7) </span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     2</span><br><span class="line">     3</span><br><span class="line">     4</span><br><span class="line">     5</span><br><span class="line">     7</span><br><span class="line">     9</span><br><span class="line"></span><br><span class="line">&gt;&gt; [r, c] &#x3D; find(M &lt; 7) % anther way to get index</span><br><span class="line"></span><br><span class="line">r &#x3D;</span><br><span class="line"></span><br><span class="line">     2</span><br><span class="line">     3</span><br><span class="line">     1</span><br><span class="line">     2</span><br><span class="line">     1</span><br><span class="line">     3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c &#x3D;</span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">     1</span><br><span class="line">     2</span><br><span class="line">     2</span><br><span class="line">     3</span><br><span class="line">     3</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">% 其他函数</span><br><span class="line">&gt;&gt; a &#x3D; [1, 15, 0.5, 2.5]</span><br><span class="line"></span><br><span class="line">a &#x3D;</span><br><span class="line"></span><br><span class="line">    1.0000   15.0000    0.5000    2.5000</span><br><span class="line"></span><br><span class="line">%sum</span><br><span class="line">&gt;&gt; sum(a)</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    19</span><br><span class="line"></span><br><span class="line">A &#x3D;</span><br><span class="line"></span><br><span class="line">     1     2</span><br><span class="line">     3     4</span><br><span class="line">     5     6</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A,1) % 以列为单位相加</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     9    12</span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(A,2) % 以行为单位相加</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">     7</span><br><span class="line">    11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt; prod(a)%</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   18.7500</span><br><span class="line"></span><br><span class="line">&gt;&gt; floor(a)</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     1    15     0     2</span><br><span class="line"></span><br><span class="line">&gt;&gt; ceil(a)</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">     1    15     1     3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%flipud</span><br><span class="line">&gt;&gt; sum(sum( flipud(eye(9)) .* magic(9)) ) %矩阵上下翻转</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">   369</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% identity matrix</span><br><span class="line">&gt;&gt; M &#x3D; magic(3)</span><br><span class="line"></span><br><span class="line">M &#x3D;</span><br><span class="line"></span><br><span class="line">     8     1     6</span><br><span class="line">     3     5     7</span><br><span class="line">     4     9     2</span><br><span class="line"></span><br><span class="line">&gt;&gt; N &#x3D; pinv(M)</span><br><span class="line"></span><br><span class="line">N &#x3D;</span><br><span class="line"></span><br><span class="line">    0.1472   -0.1444    0.0639</span><br><span class="line">   -0.0611    0.0222    0.1056</span><br><span class="line">   -0.0194    0.1889   -0.1028</span><br><span class="line"></span><br><span class="line">&gt;&gt; N * M</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    1.0000    0.0000   -0.0000</span><br><span class="line">   -0.0000    1.0000    0.0000</span><br><span class="line">    0.0000   -0.0000    1.0000</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串本质来说只是带<strong>字符</strong>的向量，可以进行多种类似向量的操作，比如索引、拼接之类。</p>
<h3 id="比较-strcmp"><a href="#比较-strcmp" class="headerlink" title="比较 strcmp"></a>比较 <code>strcmp</code></h3><p><code>tf = strcmp(s1,s2)</code> 比较 <code>s1</code> 和 <code>s2</code>，如果二者相同，则返回 <code>1</code> (<code>true</code>)，否则返回 <code>0</code> (<code>false</code>)。如果文本的大小和内容相同，则它们将视为相等。返回结果 <code>tf</code> 的数据类型为 <code>logical</code>。</p>
<h3 id="格式化-sprintf"><a href="#格式化-sprintf" class="headerlink" title="格式化 sprintf"></a>格式化 <code>sprintf</code></h3><p><code>str = sprintf(formatSpec,A1,...,An)</code> 使用 <code>formatSpec</code> 指定的格式化操作符格式化数组 <code>A1,...,An</code> 中的数据，并在 <code>str</code> 中返回结果文本。<code>sprintf</code> 函数按列顺序格式化 <code>A1,...,An</code> 中的值。如果 <code>formatSpec</code> 是字符串，则输出 <code>str</code> 也是字符串。否则，<code>str</code> 是字符向量。</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">formatSpec &#x3D; &#39;The array is %dx%d.&#39;;</span><br><span class="line">A1 &#x3D; 2;</span><br><span class="line">A2 &#x3D; 3;</span><br><span class="line">str &#x3D; sprintf(formatSpec,A1,A2)</span><br></pre></td></tr></table></figure>

<h3 id="打印字符串-fprintf"><a href="#打印字符串-fprintf" class="headerlink" title="打印字符串 fprintf"></a>打印字符串 <code>fprintf</code></h3><p>直接格式化并打印字符串到显示器上，其中格式方式同<code>sprintf</code>。</p>
<h3 id="字符串拼接-三种方法"><a href="#字符串拼接-三种方法" class="headerlink" title="字符串拼接 三种方法"></a>字符串拼接 三种方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法一：用中括号将str1和str2像矩阵元素一样包含起来：</span><br><span class="line">&gt;&gt; SC&#x3D;[str1,str2]</span><br><span class="line">方法二：用strcat函数</span><br><span class="line">&gt;&gt; SB&#x3D;strcat(str1,str2) </span><br><span class="line">% 其他用途 &gt;&gt; strcat(&#123;&#39;Red&#39;,&#39;Yellow&#39;&#125;,&#123;&#39;Green&#39;,&#39;Blue&#39;&#125;)</span><br><span class="line">方法三：利用sprintf函数</span><br><span class="line">&gt;&gt; number&#x3D;123;</span><br><span class="line">&gt;&gt; STR&#x3D;sprintf(&#39;%s%d&#39;,str1,number)</span><br></pre></td></tr></table></figure>

<h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><p>强大的绘图功能是Matlab的特点之一，Matlab提供了一系列的绘图函数，用户不需要过多的考虑绘图的细节，只需要给出一些基本参数就能得到所需图形，这类函数称为高层绘图函数。此外，Matlab还提供了直接对图形句柄进行操作的低层绘图操作。这类操作将图形的每个图形元素（如坐标轴、曲线、文字等）看做一个独立的对象，系统给每个对象分配一个句柄，可以通过句柄对该图形元素进行操作，而不影响其他部分</p>
<h2 id="PLOT"><a href="#PLOT" class="headerlink" title="PLOT"></a><strong>PLOT</strong></h2><ol>
<li>基本用法： 一组向量对</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; plot(t,y);</span><br><span class="line">&gt;&gt; hold on;</span><br><span class="line">&gt;&gt; z &#x3D; pi * cos(t);</span><br><span class="line">&gt;&gt; plot(t,z);</span><br></pre></td></tr></table></figure>

<ol>
<li>多组向量对</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%plot函数可以包含若干组向量对，每一组可以绘制出一条曲线。含多个输入参数的plot函数调用格式为：plot(x1，y1，x2，y2，…，xn，yn)</span><br><span class="line">%如下列命令可以在同一坐标中画出3条曲线。</span><br><span class="line">&gt;&gt; x&#x3D;linspace(0,2*pi,100);</span><br><span class="line">&gt;&gt; plot(x,sin(x),x,2*sin(x),x,3*sin(x))</span><br></pre></td></tr></table></figure>

<ol>
<li><p>当输入参数有矩阵形式时，配对的x,y按对应的列元素为横坐标和纵坐标绘制曲线，曲线条数等于矩阵的列数</p>
</li>
<li><p>绘图选项</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">线型</th>
<th align="left">颜色</th>
<th align="left">标记符号</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">- 实线</td>
<td align="left">b蓝色</td>
<td align="left">. 点</td>
<td align="left">s 方块</td>
</tr>
<tr>
<td align="left">: 虚线</td>
<td align="left">g绿色</td>
<td align="left">o 圆圈</td>
<td align="left">d 菱形</td>
</tr>
<tr>
<td align="left">-. 点划线</td>
<td align="left">r红色</td>
<td align="left">× 叉号</td>
<td align="left">∨朝下三角符号</td>
</tr>
<tr>
<td align="left">– 双划线</td>
<td align="left">c青色</td>
<td align="left">+ 加号</td>
<td align="left">∧朝上三角符号</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">m品红</td>
<td align="left">* 星号</td>
<td align="left">&lt;朝左三角符号</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">y黄色</td>
<td align="left"></td>
<td align="left">&gt;朝右三角符号</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">k黑色</td>
<td align="left"></td>
<td align="left">p 五角星</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">w白色</td>
<td align="left"></td>
<td align="left">h 六角星</td>
</tr>
</tbody></table>
<ol>
<li><p>坐标控制</p>
<p>想要精密的控制坐标轴的表现，需要下面多条命令的操作。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xlim([2, 46]);%只设定x轴的绘制范围</span><br><span class="line">ylim([0, 132]);%只设定x轴的绘制范围</span><br><span class="line">set(gca,&#39;XTick&#39;,[2:2:46]) %改变x轴坐标间隔显示 这里间隔为2</span><br><span class="line">%以上就可以对x轴做很好的控制了，y轴类似。</span><br><span class="line"></span><br><span class="line">axis([2,46,0,2]) % axis([xmin,xmax,ymin,ymax])，用这个语句可以对x，y轴的上限与下限绘制范围一起做控制，但是间隔还是要用上面的set来改</span><br></pre></td></tr></table></figure>

<ol>
<li>其他注释</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xlabel(&#39;x name&#39;);% x轴名称</span><br><span class="line">ylabel(&#39;y name&#39;);</span><br><span class="line">legend(&#39;xxx&#39;); %线条注释,多条的话: 	    legend(&#39;xxx&#39;,&#39;xxx2&#39;,&#39;xxx3&#39;）</span><br></pre></td></tr></table></figure>

<ol>
<li>文字注释</li>
</ol>
<p><code>text</code>可以接受向量化的数据输入，从而同时注释多个点的文字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xt &#x3D; [-2 2];</span><br><span class="line">yt &#x3D; [16 -16];</span><br><span class="line">str &#x3D; &#123;&#39;local max&#39;,&#39;local min&#39;&#125;;</span><br><span class="line">text(xt,yt,str)</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>hold on</strong> 维持画布不变化； <strong>figure</strong> 新开两个figure画板。subplot在同一个窗口上开多个子画板。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; subplot(1,2,1); plot(t,z);</span><br><span class="line">&gt;&gt; subplot(1,2,2); plot(t,y);</span><br><span class="line">&gt;&gt; axis([5 10 0 4]) % X轴范围为[5,10],y轴范围为[0,4];</span><br><span class="line"></span><br><span class="line">&gt;&gt; clf - 清除当前图窗窗口</span><br><span class="line">    此 MATLAB 函数 从当前图窗中删除其句柄未隐藏的所有图形对象（即它们的 HandleVisibility 属性设置为 on）。</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578539038766.png"><img src="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578539038766.png" alt="img"></a></p>
<h2 id="SCATTER"><a href="#SCATTER" class="headerlink" title="SCATTER"></a>SCATTER</h2><p>还是看<a href="https://ww2.mathworks.cn/help/matlab/ref/scatter.html?searchHighlight=scatter#btrj9jn-1-c">官方文档</a></p>
<h2 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function [x,y] &#x3D; circle(R,cx,cy,nb_pts)</span><br><span class="line">%%%%%%%%%%%%%%%%%%%</span><br><span class="line">% 画圆函数</span><br><span class="line">%%%%%%%%%%%%%%%%%%%</span><br><span class="line">alpha&#x3D;0:pi&#x2F;nb_pts:2*pi;%角度[0,2*pi]</span><br><span class="line">%R&#x3D;2;%半径</span><br><span class="line">x&#x3D;R*cos(alpha)+cx;</span><br><span class="line">y&#x3D;R*sin(alpha)+cy;</span><br><span class="line">plot(cx,cy,&#39;r+&#39;,x,y);</span><br><span class="line">grid on;</span><br><span class="line">axis equal;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="IMAGESC-涂色"><a href="#IMAGESC-涂色" class="headerlink" title="IMAGESC 涂色"></a>IMAGESC 涂色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; figure(3)</span><br><span class="line">&gt;&gt; imagesc(magic(15)),colorbar, colormap gray</span><br><span class="line">% imagesc 生成一个对应于矩阵数值和数量的‘像素块’图像</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578539625571.png"><img src="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578539625571.png" alt="img"></a></p>
<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1:10, %这里也可遍历矩阵</span><br><span class="line">w &#x3D; w +  5;</span><br><span class="line">if( i &gt; 5) break;</span><br><span class="line">end;</span><br><span class="line">end;</span><br><span class="line">&gt;&gt; w</span><br><span class="line">w &#x3D;</span><br><span class="line"></span><br><span class="line">    35</span><br><span class="line"></span><br><span class="line">&gt;&gt; if( v &#x3D;&#x3D; 2)</span><br><span class="line">disp(&quot;dsf is the strongest person in the confusing world!&quot;)</span><br><span class="line">else v &#x3D; 0 ;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">v &#x3D;</span><br><span class="line"></span><br><span class="line">     3</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function [value1, value2] &#x3D; Function_name(par1, par2)</span><br><span class="line">value1 &#x3D; </span><br><span class="line">value2 &#x3D;</span><br></pre></td></tr></table></figure>

<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><p>typing ctrl-c to quit the running program.</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="保存与载入程序数据"><a href="#保存与载入程序数据" class="headerlink" title="保存与载入程序数据"></a>保存与载入程序数据</h2><p>非常使用的两个函数，不过我一般只用来保存临时变量。</p>
<p><code>save(&#39;FILENAME&#39;, &#39;VARIABLES&#39;)</code> <code>load(&#39;FILENAME&#39;, &#39;VARIABLES&#39;)</code> 的括号可以去掉</p>
<h2 id="Excel文件的导入与导出"><a href="#Excel文件的导入与导出" class="headerlink" title="Excel文件的导入与导出"></a>Excel文件的导入与导出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[num, txt, raw] &#x3D; xlsread(&#39;文件名.xls&#39;,&#39;工作表&#39;, &#39;数据范围&#39;)</span><br><span class="line">status &#x3D; xlswrite(‘filename.xls’, ‘数据’, ‘工作表’, ‘指定区域’)</span><br></pre></td></tr></table></figure>

<h2 id="混合文本读入（目前可用csv）"><a href="#混合文本读入（目前可用csv）" class="headerlink" title="混合文本读入（目前可用csv）"></a>混合文本读入（目前可用csv）</h2><p>一般来说，最难读入是这种文办，数据内容比较复杂，常常带有数字、字符串等内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textscan(fid, &#39;format&#39;, N, &#39;param&#39;, value);</span><br></pre></td></tr></table></figure>

<p>其中，<code>fid</code>为文件句柄；<code>format</code>为读取格式；<code>N</code>表示用该格式读取N次数据；<code>param</code>,<code>value</code>（可选项）指定分隔符和值对。 N其实也是可选项。</p>
<p>注意：使用<code>textscan</code>之前，必须先用<code>fopen</code>打开要读入的文件；函数<code>textread</code>用法类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fid&#x3D;fopen(&#39;data6.txt&#39;,&#39;r&#39;);  %打开文件句柄</span><br><span class="line"></span><br><span class="line">C&#x3D;textscan(fid, &#39;%s%s%f32%d8%u%f%f%s%f&#39;);  %按格式读入元胞数组C</span><br><span class="line"></span><br><span class="line">fclose(fid);  %关闭文件句柄</span><br></pre></td></tr></table></figure>

<h1 id="向量化编程"><a href="#向量化编程" class="headerlink" title="向量化编程"></a>向量化编程</h1><p><a href="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578547281323.png"><img src="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578547281323.png" alt="img"></a></p>
<p>可见图中的两个更新公式中，仅有xixi的部分是不同的。把多个xixi座位一个整体，那么就可以得到一个简洁的公式：</p>
<p><a href="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578547400047.png"><img src="http://blog.come2rss.xyz/2020/04/26/tools/windows/matlab-note/matlab-note/1578547400047.png" alt="img"></a></p>
<p>（图中各个符号的维度如图所示）</p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">%标准差</span><br><span class="line">std</span><br><span class="line">&gt;&gt; help std</span><br><span class="line">std - 标准差</span><br><span class="line"></span><br><span class="line">    此 MATLAB 函数 返回 A 沿大小不等于 1 的第一个数组维度的元素的标准差。 如果 A 是观测值的向量，则标准差为标量。 如果 A</span><br><span class="line">    是一个列为随机变量且行为观测值的矩阵，则 S 是一个包含与每列对应的标准差的行向量。</span><br><span class="line">    </span><br><span class="line">%help</span><br><span class="line">&gt;&gt; help mean</span><br><span class="line">mean - 数组的均值</span><br><span class="line"></span><br><span class="line">    此 MATLAB 函数 返回 A 沿大小不等于 1 的第一个数组维度的元素的均值。</span><br><span class="line"></span><br><span class="line">    M &#x3D; mean(A)</span><br><span class="line">    M &#x3D; mean(A,dim)</span><br><span class="line">    M &#x3D; mean(___,outtype)</span><br><span class="line">    M &#x3D; mean(___,nanflag)</span><br><span class="line"></span><br><span class="line">    另请参阅 median, mode, std, sum, var</span><br><span class="line"></span><br><span class="line">    mean 的参考页</span><br><span class="line">    名为 mean 的其他函数</span><br><span class="line"></span><br><span class="line">&gt;&gt; M &#x3D; magic(5);</span><br><span class="line">&gt;&gt; mean(M,1)</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    13    13    13    13    13</span><br><span class="line"></span><br><span class="line">&gt;&gt; mean(M,2)</span><br><span class="line"></span><br><span class="line">ans &#x3D;</span><br><span class="line"></span><br><span class="line">    13</span><br><span class="line">    13</span><br><span class="line">    13</span><br><span class="line">    13</span><br><span class="line">    13</span><br></pre></td></tr></table></figure>

<h1 id="高阶操作"><a href="#高阶操作" class="headerlink" title="高阶操作"></a>高阶操作</h1><h2 id="STRING-命令化"><a href="#STRING-命令化" class="headerlink" title="STRING 命令化"></a>STRING 命令化</h2><p>主要应对多个重复但无法向量化处理的操作，比如多个不同长度的数据的绘图任务，不可以直接塞给plot一个矩阵完事，会有多与少数据掺杂进去的。</p>
<p>其实现方式是通过eval执行命令的string。eval函数的功能是将字符串转换为matlab可执行语句。</p>
<p>比如重复执行导入随名次变化的名字的mat文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i&#x3D;1:100 </span><br><span class="line">	eval([‘load ’ num2str(i) ‘.mat’]) </span><br><span class="line">	</span><br><span class="line">end </span><br><span class="line">% 当然也可以使用 sprintf打印字符串；</span><br></pre></td></tr></table></figure>

<p>Note：string中不能含有<strong>’</strong>，也就是说遇到<strong>’</strong>，需要特殊处理比如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 执行 plot(nii, &#39;LineWidth&#39;, &#39;2&#39;);</span><br><span class="line">eval([&#39;plot(n&#39;,num2str(ii),char(39),&#39;LineWidth&#39;, char(39), &#39;,2&#39;);</span><br></pre></td></tr></table></figure>

<h2 id="像素点级画图"><a href="#像素点级画图" class="headerlink" title="像素点级画图"></a>像素点级画图</h2><p>出自Andrew的第四周编程练习PlotPic。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">function [h, display_array] &#x3D; displayData(X, example_width)</span><br><span class="line">%DISPLAYDATA Display 2D data in a nice grid</span><br><span class="line">%   [h, display_array] &#x3D; DISPLAYDATA(X, example_width) displays 2D data</span><br><span class="line">%   stored in X in a nice grid. It returns the figure handle h and the </span><br><span class="line">%   displayed array if requested.</span><br><span class="line"></span><br><span class="line">% Set example_width automatically if not passed in</span><br><span class="line">if ~exist(&#39;example_width&#39;, &#39;var&#39;) || isempty(example_width) </span><br><span class="line">	example_width &#x3D; round(sqrt(size(X, 2)));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% Gray Image</span><br><span class="line">colormap(gray);</span><br><span class="line"></span><br><span class="line">% Compute rows, cols</span><br><span class="line">[m n] &#x3D; size(X);</span><br><span class="line">example_height &#x3D; (n &#x2F; example_width);</span><br><span class="line"></span><br><span class="line">% Compute number of items to display</span><br><span class="line">display_rows &#x3D; floor(sqrt(m));</span><br><span class="line">display_cols &#x3D; ceil(m &#x2F; display_rows);</span><br><span class="line"></span><br><span class="line">% Between images padding</span><br><span class="line">pad &#x3D; 1;</span><br><span class="line"></span><br><span class="line">% Setup blank display</span><br><span class="line">% 画板</span><br><span class="line">display_array &#x3D; - ones(pad + display_rows * (example_height + pad), ...</span><br><span class="line">                       pad + display_cols * (example_width + pad));</span><br><span class="line"></span><br><span class="line">% Copy each example into a patch on the display array</span><br><span class="line">curr_ex &#x3D; 1;</span><br><span class="line">for j &#x3D; 1:display_rows</span><br><span class="line">	for i &#x3D; 1:display_cols</span><br><span class="line">		if curr_ex &gt; m, </span><br><span class="line">			break; </span><br><span class="line">		end</span><br><span class="line">		% Copy the patch</span><br><span class="line">		</span><br><span class="line">		% Get the max value of the patch</span><br><span class="line">        % 格子作画： reshape改变图片像素排列方式</span><br><span class="line">		max_val &#x3D; max(abs(X(curr_ex, :)));</span><br><span class="line">		display_array(pad + (j - 1) * (example_height + pad) + (1:example_height), ...</span><br><span class="line">		              pad + (i - 1) * (example_width + pad) + (1:example_width)) &#x3D; ...</span><br><span class="line">						reshape(X(curr_ex, :), example_height, example_width) &#x2F; max_val;</span><br><span class="line">		curr_ex &#x3D; curr_ex + 1;</span><br><span class="line">	end</span><br><span class="line">	if curr_ex &gt; m, </span><br><span class="line">		break; </span><br><span class="line">	end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% Display Image</span><br><span class="line">% 每个元素代表了一个像素点</span><br><span class="line">h &#x3D; imagesc(display_array, [-1 1]);</span><br><span class="line"></span><br><span class="line">% Do not show axis</span><br><span class="line">axis image off</span><br><span class="line"></span><br><span class="line">drawnow;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h1 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h1><p>编辑文件: edit file ： 可同时创建文件</p>
<h2 id="工作路径"><a href="#工作路径" class="headerlink" title="工作路径"></a>工作路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">your path here&#39;)&#96;这条语句就可以把此路径加入到matlab工作路径中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">比如一些基本的 &#96;cd&#96;, &#96;pwd&#96;, &#96;ls&#96;都可以使用。</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;matlab</span><br><span class="line">&gt; &gt; pwd % give the path where works</span><br><span class="line">ans &#x3D;</span><br></pre></td></tr></table></figure>

<p>‘G:\Matlab\bin’<br>​```</p>
<blockquote>
<blockquote>
<p>cd ‘H:\重要文件\在校学习比赛\学习资料\机器学习\机器学习 Andrew’<br>ls</p>
</blockquote>
</blockquote>
<p>Linear Regression with multiple variables.md<br>2 Linear Regression with multiple variables.assets</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"># 错误笔记</span><br><span class="line"></span><br><span class="line">$n*1$的矢量相加或相减与一个$1*n$的矢量得到的确实一个$n*n$的矩阵！</span><br><span class="line"></span><br><span class="line">## </span><br><span class="line"></span><br><span class="line"># 快捷键</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MATLAB 命令栏显示处理的常用命令</span><br><span class="line"></span><br><span class="line">清屏：clc</span><br><span class="line"></span><br><span class="line">紧凑显示格式：format compact</span><br><span class="line"></span><br><span class="line">宽松显示格式：format loose</span><br><span class="line"></span><br><span class="line">数据高精度显示：format longG</span><br><span class="line"></span><br><span class="line">数据低精度显示：format short</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**编辑器窗口（Editor）下的常用快捷键：**</span><br><span class="line">自动对齐程序（整理缩进）-自动整理代码 用鼠标选中代码行，按Ctrl + I</span><br><span class="line">**快速注释**代码段 拖动鼠标选中需要注释的代码行，按Ctrl + R</span><br><span class="line">快速取消注释代码段 拖动鼠标选中已经注释的代码行，按Ctrl + T</span><br><span class="line">撤销改动 Ctrl + Z</span><br><span class="line">取消撤销（撤销过多时使用） Ctrl + Y</span><br><span class="line">多行代码增加缩进（代码段右移） 选中代码段，按   Tab键   或   Ctrl + ]</span><br><span class="line">多行代码减少缩进（代码段左移） 选中代码段，按   Shift+Tab键   或   Ctrl + [</span><br><span class="line">自动补全命令（记不全函数名时使用） 输入函数的前几个字母，再按Tab</span><br><span class="line">查找或替换变量名、函数名 Ctrl + F</span><br><span class="line">关闭当前的程序文本（.m）文件 Ctrl + W</span><br><span class="line">在Editor窗体中**切换**</span><br><span class="line">Ctrl + PageUp&#x2F;PageDown</span><br><span class="line"></span><br><span class="line">Ctrl+PgUp表示编辑器窗口向左切换文件</span><br><span class="line"></span><br><span class="line">Ctrl+PgDn表示编辑器窗口向右切换文件</span><br><span class="line"></span><br><span class="line"> Ediotor\命令行**窗口切换**：ctrl+Tab</span><br><span class="line"></span><br><span class="line">**代码调试常用快捷键：**</span><br><span class="line">运行 F5可保存并直接运行程序</span><br><span class="line">执行选中代码段 F9</span><br><span class="line">单步执行 F10</span><br><span class="line">F11 表示step in，即当遇见子函数时，使用此快捷键，进入函数内部</span><br><span class="line">Shift + F11 表示step out，即使用此快捷键，执行完子函数的剩余程序，并跳出子函数</span><br><span class="line">设置或取消断点的方法有两种</span><br><span class="line">(1) 在要设置断点的行左侧的-处单击；</span><br><span class="line"></span><br><span class="line">(2) 可按F12设置断点。</span><br><span class="line"></span><br><span class="line">直接跳至某行 Ctrl + G， </span><br><span class="line">强制中断程序的运行 Ctrl + C</span><br><span class="line">命令窗口（Command Window）下的常用快捷键与命令：</span><br><span class="line">再现历史命令</span><br><span class="line">上下光标键↑↓   ，在命令窗口中，上下光标键可以调用Matlab最近使用过的历史命令，便于快速重新执行。 如果输入命令的前几个字母，再使用光标键，则只会选择以这些字母开始的命令。 上下箭头寻找此前和此后输入的命令，每次一条。</span><br><span class="line"></span><br><span class="line">快速退出MATLAB Ctrl + Q</span><br><span class="line">清除输入的命令 Esc</span><br><span class="line">将光标处至结尾之间的代码删除 Ctrl + K</span><br><span class="line">what 显示当前工作路径中的所有代码文件</span><br><span class="line">type 代码文件名 显示代码文件的内容</span><br><span class="line">edit 启动编辑器，并新建一个空白文件</span><br><span class="line">edit 代码文件名 打开相应代码文件</span><br><span class="line">whatsnew 列出MATLAB新版本更新的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**切换窗口快捷键：**</span><br><span class="line">Ctrl+0 命令行窗口（Command Window）</span><br><span class="line">Ctrl + Shift + 0 编辑器窗口（Editor）</span><br><span class="line">Ctrl + 1 历史命令窗口（Command History）</span><br><span class="line">Ctrl + 2 当前工作窗口（Current Folder）</span><br><span class="line">Ctrl + 3</span><br><span class="line"></span><br><span class="line">**工作空间（Workspace）**</span><br><span class="line"></span><br><span class="line">初学者要把下面的基本使用规则，牢记于心：</span><br><span class="line"></span><br><span class="line">1. 输入时，标点必须是英文状态下的</span><br><span class="line">2. 大多数情况下，MATLAB对空格不予处理</span><br><span class="line">3. 小括号代表运算级别，中括号用于生成矩阵，大括号用于构成单元数组</span><br><span class="line">4. 分号  ;  的作用：不显示运算结果（抑制输出），但对图形窗口不起作用。分号也用于区分行。</span><br><span class="line">5. 逗号  ,  的作用：函数参数分隔符，也用于区分行，显示运算结果，当然不加标点也显示运算结果</span><br><span class="line">6. 冒号  :  多用于数组</span><br><span class="line">7. 续行号  ...  不能放在等号后面使用，不能放在变量名中间使用，起作用时默认显蓝色</span><br><span class="line">8. 双引号 &#39;string&#39; 是字符串的标识符</span><br><span class="line">9. 感叹号  !  用于调用操作系统运算</span><br><span class="line">10. 百分号  %  是注释符号，对于百分号后面直到行末的语句，matlab跳过执行。另外还可用于代码块注释，即对多行代码一次注释，  格式为：（注意%&#123; 和%&#125;都要单独成行</span><br><span class="line">11. 乘号 * 总是不能省略的，除了表示复数，比如2+3i时可以省略</span><br><span class="line">12. 除号有 &#x2F; 或 \ ，它两个的关系是：a除以b表示为a&#x2F;b，或 b\a</span><br><span class="line">13. 等号 &#x3D; 用于赋值</span><br><span class="line">14. &#x3D;&#x3D; 表示数学意义上的等号</span><br><span class="line"></span><br><span class="line">15. 主窗口（Command Window）里面，输入时，换行用Shift+Enter</span><br><span class="line"></span><br><span class="line">16. 主窗口（Command Window）里面，运行程序，执行命令用Enter</span><br><span class="line"></span><br><span class="line">17. 矩阵中用圆括号表示下标，单元数组（cell）用大括号表示下标</span><br><span class="line"></span><br><span class="line">18. 对变量名的基本要求：区分大小写，不超过63个字符，以字母开头，只能是字母，数字和下划线</span><br><span class="line"></span><br><span class="line">19. clc             clear command（命令窗口中清除所有代码）（清屏），</span><br><span class="line"></span><br><span class="line">        clf              clear figure（清理图形窗口）（并非关闭figure窗口）</span><br><span class="line"></span><br><span class="line">         close         关闭最近的figure窗口</span><br><span class="line"></span><br><span class="line">         close all     关闭所有figure窗口</span><br><span class="line"></span><br><span class="line">         clear          清理工作空间（workspace）中的所有变量</span><br><span class="line"></span><br><span class="line">          clear+变量名     清理工作空间中的指定变量（如果是多个变量，用空格隔开）</span><br><span class="line"></span><br><span class="line">          edit+函数名       查看或编辑源文件</span><br><span class="line"></span><br><span class="line">          who      显示工作空间中的所有变量名（仅展示出变量的名字）</span><br><span class="line"></span><br><span class="line">          whos    显示工作空间中的所有变量名及其属性（大小、字节数、数据类型，等等）</span><br><span class="line"></span><br><span class="line">          which+函数名     证实该函数是否在当前路径</span><br><span class="line"></span><br><span class="line">          what      列出当前路径的所有matlab文件</span><br><span class="line"></span><br><span class="line">          load       加载外部文件</span><br><span class="line"></span><br><span class="line">          save      保存变量到外部文件。如果save后面没有任何东西，则默认将工作空间中的所有变量保存在文件matlab.mat中。</span><br><span class="line"></span><br><span class="line">          save 文件名  指定变量列表——将指定变量保存在文件中（其中文件名不需要用单引号括起来，文件名的 .mat 后缀也可省略）。（具体地，可以执行doc save来查看save如何使用。）  例如：</span><br><span class="line"></span><br><span class="line">          \&gt;&gt;save var2 x y ;  —— 将变量x和y保存在文件var2.mat中。</span><br><span class="line"></span><br><span class="line">          \&gt;&gt;load var2</span><br><span class="line"></span><br><span class="line">          在 save 和 load 命令中，文件名、变量名可以用字符串来表示，这时将 save 和 load 看作函数来调用：（推荐使用这种形式）</span><br><span class="line"></span><br><span class="line">          \&gt;&gt;save( &#39;var2&#39;, &#39;x&#39;, &#39;y&#39; );  % 功能与  save var2 x y ;  相同。</span><br><span class="line"></span><br><span class="line">          \&gt;&gt;s &#x3D; &#39;var2&#39;;</span><br><span class="line"></span><br><span class="line">          \&gt;&gt;load( s ) % 功能与  load var2  相同。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">20. MATLAB的帮助函数：</span><br><span class="line"></span><br><span class="line">          help</span><br><span class="line"></span><br><span class="line">          help+函数名   或   help+函数类名      精确查询</span><br><span class="line"></span><br><span class="line">          helpwin                   打开帮助窗口</span><br><span class="line"></span><br><span class="line">          helpwin+函数名      精确查询</span><br><span class="line"></span><br><span class="line">          helpdesk                 打开帮助窗口</span><br><span class="line"></span><br><span class="line">          doc                          打开帮助窗口</span><br><span class="line"></span><br><span class="line">          doc+函数名             打开帮助窗口， 精确查询 </span><br><span class="line"></span><br><span class="line">          lookfor+关键字        matlab中的谷歌，模糊查询</span><br><span class="line"></span><br><span class="line">21. 函数式M文件的文件名，在MATLAB主窗口下不区分大小写，</span><br><span class="line"></span><br><span class="line">          函数式M文件中，变量都是局部变量</span><br><span class="line"></span><br><span class="line">          脚本式M文件中，变量都是全局变量</span><br><span class="line"></span><br><span class="line">22. MATLAB搜索路径</span><br><span class="line"></span><br><span class="line">          MATLAB通过搜索路径来查找M文件。因此，MATLAB的系统文件、Toolboxes工具箱函数、用户自己编写的M文件等都应该保存在搜索路径中。当用户输入一个标识符（例如Value）时，MATLAB按下列步骤处理：</span><br><span class="line"></span><br><span class="line">          （1）检查 Value 是否为变量</span><br><span class="line"></span><br><span class="line">          （2）检查 Value 是否为内部函数</span><br><span class="line"></span><br><span class="line">          （3）在当前的工作目录下是否存在 Value.m 文件</span><br><span class="line"></span><br><span class="line">          （4）在MATLAB搜索路径中是否存在 Value.m 文件</span><br><span class="line"></span><br><span class="line">          如果在搜索路径中存在多个 Value.m 文件，则只执行第一个 Value.m 文件；如果找不到这一文件，则报错。</span><br><span class="line"></span><br><span class="line">23. eps —— 在MATLAB编程中，对于除法运算，为了避免分母为零的情况出现，将分母的数与eps相加。（直接在命令窗口输入eps，再回车，会返回eps的值——2.2204e-16）。</span><br><span class="line"></span><br><span class="line">准确讲，eps表示数1.0到与它相邻的最大的双精度浮点数。简单记，就是代表一个特别小的数。</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Linux/Linux%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Linux笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:52:29.000Z" title="2020-08-07T04:52:29.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Linux/">Linux</a></span><span class="level-item">10 minutes read (About 1544 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Linux/Linux%E7%AC%94%E8%AE%B0/">Linux笔记</a></h1><div class="content"><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><p><code>uname -r</code> 查看内核版本</p></div><a class="article-more button is-small size-small" href="/2020/08/07/Code%20tools/Linux/Linux%E7%AC%94%E8%AE%B0/#more">Read More</a></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Linux/ssh%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/image-20200504091052190.png" alt="ssh笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:51:22.000Z" title="2020-08-07T04:51:22.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Linux/">Linux</a></span><span class="level-item">9 minutes read (About 1334 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Linux/ssh%E7%AC%94%E8%AE%B0/">ssh笔记</a></h1><div class="content"><p><a href="https://missing.csail.mit.edu/2020/command-line/">这内容是真的丰富</a></p>
<p>Secure Shell(SSH) 是由 IETF(The Internet Engineering Task Force) 制定的建立在应用层基础上的安全网络协议。它是专为远程登录会话(甚至可以用Windows远程登录Linux服务器进行文件互传)和其他网络服务提供安全性的协议，可有效弥补网络中的漏洞。通过SSH，可以把所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。目前已经成为Linux系统的标准配置。</p>
<!-- mroe -->

<h1 id="ssh安全机制"><a href="#ssh安全机制" class="headerlink" title="ssh安全机制"></a>ssh安全机制</h1><p>SSH之所以能够保证安全，原因在于它采用了非对称加密技术(RSA)加密了所有传输的数据。传统的网络服务程序，如FTP、Pop和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。</p>
<p>但并不是说SSH就是绝对安全的，因为它本身提供两种级别的验证方法：</p>
<p>第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人攻击”这种方式的攻击。</p>
<p>第二种级别（基于密钥的安全验证）：你必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公钥，然后把它和你发送过来的公钥进行比较。如果两个密钥一致，服务器就用公钥加密“质询”(challenge)并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私钥在本地解密再把它发送给服务器完成登录。与第一种级别相比，第二种级别不仅加密所有传输的数据，也不需要在网络上传送口令，因此安全性更高，可以有效防止中间人攻击。</p>
<p><a href="https://blog.csdn.net/li528405176/article/details/82810342">原文链接</a></p>
<h1 id="ssh基本操作"><a href="#ssh基本操作" class="headerlink" title="ssh基本操作"></a>ssh基本操作</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>查看安装包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep ssh</span><br></pre></td></tr></table></figure>

<p>安装本地的ssh的服务器和客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-client #连其他人</span><br><span class="line">sudo apt-get install openssh-server #让别人连</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动ssh服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># -e identail to -A select all processe</span><br><span class="line">ps -e | grep ssh #如果有sshd 表示ssh已经启动</span><br><span class="line">#没有则启动ssh</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;ssh start</span><br></pre></td></tr></table></figure>

<p>停止和重启ssh服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;ssh stop  #server停止ssh服务 </span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;ssh restart  #server重启ssh服务</span><br></pre></td></tr></table></figure>

<h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><h3 id="口令登陆"><a href="#口令登陆" class="headerlink" title="口令登陆"></a><strong>口令登陆</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssh name@ip</span><br><span class="line"></span><br><span class="line">#调用图形界面</span><br><span class="line">ssh -X name@ip</span><br><span class="line"></span><br><span class="line">#如何客户机和服务器的登陆用户名相同可以省略用户名</span><br><span class="line">ssh ip</span><br><span class="line"></span><br><span class="line">#设置端口, 默认22	</span><br><span class="line">ssh -p port name@ip</span><br></pre></td></tr></table></figure>

<p>如果是第一次登陆还需要把服务器的IP加入可信列表。之后输入密码即可登陆</p>
<h3 id="公钥登陆"><a href="#公钥登陆" class="headerlink" title="公钥登陆"></a>公钥登陆</h3><p>本机生成密钥对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa # -t 表示密钥类型</span><br><span class="line">#密钥生成后存在放 &#x2F;home&#x2F;用户名&#x2F;.ssh,其中私钥为id_rsa, 公钥为 id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>上传密钥到远程主机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id name@ip</span><br><span class="line">#或者</span><br><span class="line">ssh-copy-id -i .ssh&#x2F;id_ed25519.pub foobar@remote</span><br><span class="line">#再或者</span><br><span class="line">cat .ssh&#x2F;id_ed25519.pub | ssh foobar@remote &#39;cat &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys&#39;</span><br></pre></td></tr></table></figure>

<p>之后就可以直接使用ssh登陆而无需输入密码了</p>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">#或者按 Ctrl + D</span><br></pre></td></tr></table></figure>

<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>当我们利用ssh在远程主机上跑程序的时候，只要关闭了终端就会中断ssh连接，然后远程主机上正在跑的程序或者服务就会自动停止运行。我们可以利用 nohup + 需要运行的程序 使运行的程序在切断ssh连接的时候仍然能够继续在远程主机中运行。nohup即no hang up(不挂起)。</p>
<h2 id="Executing-commands"><a href="#Executing-commands" class="headerlink" title="Executing commands"></a>Executing commands</h2><p>An often overlooked feature of ssh is the ability to run commands directly. ssh foobar@server ls will execute ls in the home folder of foobar. It works with pipes, so ssh foobar@server ls | grep PATTERN will grep locally the remote output of ls and ls | ssh foobar@server grep PATTERN will grep remotely the local output of ls</p>
<blockquote>
<p>注意两个命令的区别</p>
</blockquote>
<p><em>参考文章： (基本内容)[<a href="https://blog.csdn.net/li528405176/article/details/82810342]">https://blog.csdn.net/li528405176/article/details/82810342]</a>, (进阶)[<a href="https://blog.csdn.net/pipisorry/article/details/52269785]">https://blog.csdn.net/pipisorry/article/details/52269785]</a></em></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Windows/WSL%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="WSL杀死进程"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:50:25.000Z" title="2020-08-07T04:50:25.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Windows/">Windows</a></span><span class="level-item">a few seconds read (About 31 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Windows/WSL%E6%9D%80%E6%AD%BB%E8%BF%9B%E7%A8%8B/">WSL杀死进程</a></h1><div class="content"><p>WLS2的Ubuntu18.04下没有办法直接使用<code>kill -s 9 PID</code>杀死进程，可是神奇的用<code>kill -9 PID</code>代替。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Jupyter/jupyter%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="jupyter笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:48:55.000Z" title="2020-08-07T04:48:55.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Jupyter/">Jupyter</a></span><span class="level-item">2 minutes read (About 238 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Jupyter/jupyter%E7%AC%94%E8%AE%B0/">jupyter笔记</a></h1><div class="content"><h2 id="设置默认工作目录"><a href="#设置默认工作目录" class="headerlink" title="设置默认工作目录"></a>设置默认工作目录</h2><p>Jupyter notebook 只能在打开的工作目录下工作（创建文件，运行代码），所以十分有必要修改默认代码目录。</p>
<!-- mroe -->

<h5 id="在Anaconda-Prompt中生成配置文件"><a href="#在Anaconda-Prompt中生成配置文件" class="headerlink" title="在Anaconda Prompt中生成配置文件"></a>在Anaconda Prompt中生成配置文件</h5><p>打开Anaconda Prompt，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config1</span><br></pre></td></tr></table></figure>



<h5 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h5><p>根据显示的路径，打开配置文件jupyter_notebook_config.py，全文搜索【notebook_dir】，找到后填入自己的工作路径并保存。（注意：工作路径不能出现中文，否则无法打开Jupyter Notebook）</p>
<p><a href="http://static.come2rss.xyz/image-20200503125317705.png"><img src="http://static.come2rss.xyz/image-20200503125317705.png" alt="image-20200503125317705"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200503125317705.png">image-20200503125317705</a></p>
<h5 id="修改JupyterNotebook快捷方式的目标属性-如果用Prompt也许就不用了"><a href="#修改JupyterNotebook快捷方式的目标属性-如果用Prompt也许就不用了" class="headerlink" title="修改JupyterNotebook快捷方式的目标属性(如果用Prompt也许就不用了)"></a>修改JupyterNotebook快捷方式的目标属性(如果用Prompt也许就不用了)</h5><p>右击JupyterNotebook快捷方式，选择【属性】，删除【目标】属性中的【%USERPROFILE%】，点击【应用】–【确定】。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Git/Git%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Git笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:47:30.000Z" title="2020-08-07T04:47:30.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Git/">Git</a></span><span class="level-item">29 minutes read (About 4380 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Git/Git%E7%AC%94%E8%AE%B0/">Git笔记</a></h1><div class="content"><!-- mroe -->

<p>基础概念</p>
<p>七个非常非常常用的命令如下图所示。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note//%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.jpg"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note//%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.jpg" alt="img"></a></p>
<h2 id="提交-查看-删除命令"><a href="#提交-查看-删除命令" class="headerlink" title="提交\查看\删除命令"></a>提交\查看\删除命令</h2><p><code>.git</code>文件就是<strong>版本库（</strong>Repository），一般的目录就是<strong>工作区</strong>（Working Directory）</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%A4%BA%E6%84%8F.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%A4%BA%E6%84%8F.png" alt="image-20200425184450980"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%A4%BA%E6%84%8F.png">image-20200425184450980</a></p>
<p><code>git init</code>初始化Git仓库（也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的）</p>
<p><code>git add</code>把多个文件添加到stage; <code>git add fiilename</code>可单独添加文件。<code>git add</code>的工作就是要提交的所有修改放到<strong>暂存区</strong>（Stage）</p>
<p><code>git commit -m &quot;comment it&quot;</code> 次性把暂存区的所有修改提交到分支。（</p>
<p>Note：add之后的修改是不会被commit上去的; 要使用双引号而不是引号。</p>
<p><code>git status</code>查看仓库当前的状态</p>
<blockquote>
<p>Note:一般有三种状态<code>untracked</code>(文件没被添加）,<code>Changes not staged for commit</code>:（修改存没有存放在stage中），<code>Changes to be committed:</code>（修改已经添加到stage但是没有提交）、<code>nothing to commit, working tree clean</code>(全部已提交)；<code>changes</code>中也有几种状态<code>modified</code>,<code>deleted</code>等等。</p>
</blockquote>
<p><code>git diff</code> 查可以查看<strong>工作区和版本库</strong>里面最新版本的区别：<code>git diff HEAD -- readme.txt</code>可指定文件</p>
<p>Note：diff好像是按行比较的， <code>@@ -1,2 +1,7 @@</code>表示变化的开始和结束的行数和变化号（？）<code>git diff --cached</code>针对<strong>暂存区</strong>查看差别。</p>
<p><code>git rm filename</code>可以删除<strong>暂存区和工作区</strong>中的的文件。</p>
<blockquote>
<p>Note: 若有误删，只能使用<code>reset HEAD filename</code>恢复到最新提交的版本，而commited之后的<strong>修改都会丢失</strong>，即存在数据丢失的情况。</p>
</blockquote>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p><code>git log</code>查看commit的日志；<code>--pretty=oneline</code>参数可简化输出。</p>
<blockquote>
<p>如1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</p>
<p><em>1094adb7b9b3807259d8cb349e7df1d4d6477073</em> 是commit id(版本号)</p>
</blockquote>
<p><code>git log --all --graph --decorate</code>: visualizes history as a DAG</p>
<p><code>git reflog</code> 查看使用的每一条commit和reset [ren’e’san’tian]命令，可用来查找从新版本回退的到旧版本之时的新版本的ID号。</p>
<p>首先在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，也可以写成<code>HEAD~DIFF_VERSION_NUMBER</code>。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/head%E6%8C%87%E9%92%88.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/head%E6%8C%87%E9%92%88.png" alt="image-20200425184637910"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/head%E6%8C%87%E9%92%88.png">image-20200425184637910</a></p>
<p><code>git checkout --filename</code>可以丢弃<strong>工作区</strong>的<strong>修改或者<code>rm</code>的删除</strong> （这里很有意思！），这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<blockquote>
<p>Note:<code>git checkout -- file</code>没有<code>--</code>，就变成了“切换到另一个分支”的命令；</p>
</blockquote>
<p><code>git checkout</code>其实是用<strong>版本库里的版本替换工作区的版本</strong>，无论工作区是<strong>修改还是删除</strong>，都可以“一键还原”。</p>
<p><code>git reset HEAD filename</code>可以把暂存区的<strong>修改和删除</strong>撤销掉，重新放回工作区。（状态从to be committed 变成了 changes）。用于应对提交了错误代码或者<code>git rm</code>到stage，操作完后再用上述<code>checkout</code>命令改回原来的代码。</p>
<blockquote>
<p>Note：<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区</p>
</blockquote>
<p><code>git reset --hard HEAD</code> 回退到上一个版本。也可以这么写<code>git reset --hard 1022a</code>,这个例子中<code>1022a</code>是所需要回退的版本的ID前几位（长度足够长而不至于重了就行）。</p>
<blockquote>
<p>Note: 如果在没有把已经commit的错误代码推送到远程库中，可在本地版本库中版本回退。</p>
</blockquote>
<p><code>git mergetool</code>: use a fancy tool to help resolve merge conflicts</p>
<p><code>git rebase</code>: rebase set of patches onto a new base</p>
<h1 id="Git学习资源推荐"><a href="#Git学习资源推荐" class="headerlink" title="Git学习资源推荐"></a>Git学习资源推荐</h1><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><ul>
<li><strong>GUIs</strong>: there are many <a href="https://git-scm.com/downloads/guis">GUI clients</a> out there for Git. We personally don’t use them and use the command-line interface instead.</li>
<li><strong>Shell integration</strong>: it’s super handy to have a Git status as part of your shell prompt (<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>). Often included in frameworks like <a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a>.</li>
<li><strong>Editor integration</strong>: similarly to the above, handy integrations with many features. <a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> is the standard one for Vim.</li>
<li><strong>Workflows</strong>: we taught you the data model, plus some basic commands; we didn’t tell you what practices to follow when working on big projects (and there are <a href="https://nvie.com/posts/a-successful-git-branching-model/">many</a> <a href="https://www.endoflineblog.com/gitflow-considered-harmful">different</a> <a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">approaches</a>).</li>
<li><strong>GitHub</strong>: Git is not GitHub. GitHub has a specific way of contributing code to other projects, called <a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">pull requests</a>.</li>
<li><strong>Other Git providers</strong>: GitHub is not special: there are many Git repository hosts, like <a href="https://about.gitlab.com/">GitLab</a> and <a href="https://bitbucket.org/">BitBucket</a>.</li>
</ul>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li><a href="https://git-scm.com/book/en/v2">Pro Git</a> is <strong>highly recommended reading</strong>. Going through Chapters 1–5 should teach you most of what you need to use Git proficiently, now that you understand the data model. The later chapters have some interesting, advanced material.</li>
<li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> is a short guide on how to recover from some common Git mistakes.</li>
<li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> is a short explanation of Git’s data model, with less pseudocode and more fancy diagrams than these lecture notes.</li>
<li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a> is a detailed explanation of Git’s implementation details beyond just the data model, for the curious.</li>
<li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a></li>
<li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> is a browser-based game that teaches you Git.</li>
</ul>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>Github允许使用了HTTP和SSH两种方式使用GIT，设置SSH能免去HTTP的权限和输入密码等限制。</p>
<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>ssh — Secure Shell 工具是与远程服务器沟通的渠道。我们不仅可以使用 ssh 登录远程服务器，还可以利用 ssh 在不输入 GitHub 账户密码的情况下将 Git 仓库内容推送至 GitHub 远程仓库。</p>
<h3 id="ssh-登录-GitHub"><a href="#ssh-登录-GitHub" class="headerlink" title="ssh 登录 GitHub"></a>ssh 登录 GitHub</h3><p>下面配置与 GitHub 连接的 SSH 密钥（linux）</p>
<ul>
<li><p>在 WSL 下生成 SSH 公钥 — 私钥对，此时生成的 SSH 密钥默认位于 <code>~/.ssh</code> 路径下，公钥为 <code>id_rsa.pub</code>，私钥为 <code>id_rsa</code>：</p>
<blockquote>
<p>windows下的私钥放在个人用户的文件夹下<code>.ssh</code>。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>打开 ssh-agent 使之在后台运行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>将私钥添加到 ssh-agent 之中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure>

<ul>
<li>查看公钥并将之复制到剪贴板：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看公钥内容</span><br><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line"></span><br><span class="line"># 将公钥复制到剪贴板</span><br><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub | clip.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>将复制好的公钥添加到 GitHub 账户密钥里面[<a href="https://dowww.spencerwoo.com/1.0/2-cli/2-3-others.html#fn2">2]</a></li>
</ul>
<h3 id="测试ssh"><a href="#测试ssh" class="headerlink" title="测试ssh"></a>测试ssh</h3><p><code>ssh -T git@github.com</code>测试ssh是否能连接到github上 <code>ssh -T -p 443 git@ssh.github.com</code>换端口测试</p>
<p>编辑<code>~/.ssh/config</code>文件（没有则创建一个），然后补充下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>

<h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a><strong>新建仓库</strong></h2><p>远程仓无内容：在本地仓上<strong>新建一个仓库名与远程仓</strong>一样的仓库，记得<code>add\\commit</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">#push after commiting your code.</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来。以后可以使用<code>git push origin master</code>推送最新修改。</p>
<blockquote>
<p><code>git push --set-upstream [origin_source] [origin brance]</code> 也可以把本地分支追踪到远程分支。</p>
</blockquote>
<p>本地仓无内容：（最好）新建一个远程仓，在<code>clone</code>下来，使用<code>$ git clone git@github.com:michaelliao/gitskills.git</code>。如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>命令实例：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示remote仓库</span><br><span class="line">git remote -v</span><br><span class="line">&#x2F;&#x2F;添加远程仓库</span><br><span class="line">git remote add &lt;shortname&gt; https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line">git pull &lt;remote&gt;</span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br><span class="line">&#x2F;&#x2F;设置远程仓库上游分支</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="如果远程仓库已经提交过代码"><a href="#如果远程仓库已经提交过代码" class="headerlink" title="如果远程仓库已经提交过代码"></a>如果远程仓库已经提交过代码</h3><p>在本地和远程仓库都提交了至少一次commit之后，无法直接push上去代码，只能先pull下来（我观察）。可使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">git  pull origin master </span><br><span class="line"># 允许无相关历史的代码合并</span><br><span class="line">git  pull origin master --allow-unrelated-histories   </span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><p>由于涉及到一些多人操作，所以暂时不学了 等待下一个机会</p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320">廖老师的多人协作</a></p>
<h3 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h3><p>win10可能未开启ssh服务， 在powershell中测试并打开, <code>Get-Service ssh-agent</code>可获取openssh服务运行状态，<code>Get-Service -Name ssh-agent | Set-Service -StartupType Manual</code>开启ssh服务。<a href="https://stackoverflow.com/questions/52113738/starting-ssh-agent-on-windows-10-fails-unable-to-start-ssh-agent-service-erro">SO的答案</a></p>
<p><code>ssh -T git@github.com</code>可用于测试ssh秘钥是否连接正常；一定要输入yes不然会一直报错。。。</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>传统的工作分支示例:</p>
<p>一人对应一个支线，<strong>每个feature对应一个新支线</strong>。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%B7%A5%E4%BD%9C%E5%88%86%E6%94%AF.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%B7%A5%E4%BD%9C%E5%88%86%E6%94%AF.png" alt="image-20200425185348609"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%B7%A5%E4%BD%9C%E5%88%86%E6%94%AF.png">image-20200425185348609</a></p>
<p>廖雪峰关于GIT分支管理的讲述很清晰，精彩；<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">连接如下</a></p>
<p>本质上，每一个所谓的分支都是一个指针，每一个指针指向都是个提交的节点，创建和删除一个新的分支只不过是添加删除了一个指针。而一个新的<strong>提交commit</strong>也不过需要额外再移动一下指针罢了。而<code>HEAD</code>更是一个指向当前工作区的分支的指针。如图</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/master%E5%88%86%E6%94%AF.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/master%E5%88%86%E6%94%AF.png" alt="image-20200425185438219"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/master%E5%88%86%E6%94%AF.png">image-20200425185438219</a></p>
<h2 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h2><p><strong>友情提示</strong>：每次在一个分支做的修改一定要commit之后，再去switch分支,不然出现会出现内容混乱的现象。保存现场参见下文。</p>
<p><code>git brabch</code>列出所有分支，当前分支前面会标一个<code>*</code>号</p>
<p><code>git switch -c dev</code> 创建（<code>-c</code> create）和切换到一个新的分支。相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建：</span><br><span class="line">git branch dev </span><br><span class="line">切换：</span><br><span class="line">git checkout dev 或者 git switch dev</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: <code>git chechout -c dev</code>作用等同。</p>
</blockquote>
<p><code>git branch -d dev</code> (合并完成后，当然不是必须的，只是从工程目的上讲),可以删除<code>dev</code>分支了。<code>git branch -D dev</code> 可删除没有合并的分支，即<strong>强行删除</strong>（<code>-D</code>）。因为该分支没有被合并，如果删除，就会失去修改。</p>
<p><code>git merge dev</code> 把dev分支合并到master（<strong>现在所在的分支</strong>,这里有两个信息，一个是隐含的）分支上。dev的修改就合并到了master上。</p>
<blockquote>
<p>Note：<code>Fast-forward</code>意味着“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，合并速度非常快。但这种模式下，删除分支后，会丢掉分支信息。请使用<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
</blockquote>
<h2 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h2><p>分支冲突出现在两个在同一文件下修改相同地方的分支合并之时。（那都得是commit过了）</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%88%86%E6%94%AF%E5%86%B2%E7%AA%81.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%88%86%E6%94%AF%E5%86%B2%E7%AA%81.png" alt="image-20200425185901715"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E5%88%86%E6%94%AF%E5%86%B2%E7%AA%81.png">image-20200425185901715</a></p>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容 。修改源文件，解决冲突后，提交过可得；</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81.png" alt="image-20200425185942196"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-note/Git-note/%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81.png">image-20200425185942196</a></p>
<p><code>git log --graph --pretty=oneline --abbrev-commit</code>可以以图形化方式查看提交合并结果；<code>git log</code>本身也能查看结果。</p>
<h2 id="保存现场以及修改BUG"><a href="#保存现场以及修改BUG" class="headerlink" title="保存现场以及修改BUG"></a>保存现场以及修改BUG</h2><p>如果当前任务没有完成，不能commit。则可以把<strong>未被追踪过的文件（即没有被add过）</strong><code>git add</code>（追踪后），使用<code>git stash</code>保存现场。而Git把stash内容存在某个地方了，恢复现场有两个办法：一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除。另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。</p>
<blockquote>
<p>很像堆栈思想的上下文恢复</p>
</blockquote>
<p><code>git stash list</code>可以查看 git保存的工作现场的内容。</p>
<p><strong>应用：</strong>工作中突然发现在过去的分支就出现一个bug，补救方法如下：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900388704535136">廖雪峰教程</a></p>
<p>如果不能直接把当前的工作commit掉，只能先<code>stash</code>,在切换分支、开分支、修bug然后commit，merge, 删除分支；如果后来开发的支线也有主线的bug，可以方便的使用`</p>
<p><code>git cherry_pick commit-id</code>可在<strong>当前分支</strong>“<strong>复制</strong>”一次commit-id所修改的内容，他会自动提交一次<strong>commit</strong>。可以方便的解决不同支线相同bug的处理问题。</p>
<h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h2><p><code>git config --global alias.st status</code>就把<code>git st</code>就等价于<code>git status</code>。实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#花里胡哨的命令！</span><br><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit</span><br></pre></td></tr></table></figure>

<p>配置Git的时候，加上<code>--global</code>是针对<strong>当前用户</strong>起作用的，如果不加，那只针对当前的仓库起作用。每个<strong>仓库的Git配置文件</strong>都放在<code>.git/config</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git&#x2F;config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion &#x3D; 0</span><br><span class="line">    filemode &#x3D; true</span><br><span class="line">    bare &#x3D; false</span><br><span class="line">    logallrefupdates &#x3D; true</span><br><span class="line">    ignorecase &#x3D; true</span><br><span class="line">    precomposeunicode &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url &#x3D; git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line">[alias]</span><br><span class="line">    last &#x3D; log -1</span><br></pre></td></tr></table></figure>

<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co &#x3D; checkout</span><br><span class="line">    ci &#x3D; commit</span><br><span class="line">    br &#x3D; branch</span><br><span class="line">    st &#x3D; status</span><br><span class="line">[user]</span><br><span class="line">    name &#x3D; Your Name</span><br><span class="line">    email &#x3D; your@email.com</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>忽略特殊文件： 有时必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，每次<code>git status</code>都会显示<code>Untracked files ...</code>。解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<blockquote>
<p>Note:<code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理；不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接<a href="https://github.com/github/gitignore">在线浏览</a></p>
</blockquote>
<p>编写忽略文件的<strong>原则</strong>是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>对被忽略的文件，可以用<code>-f</code><strong>强制</strong>添加到Git：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure>

<p>可以用<code>git check-ignore</code>命令<strong>检查</strong><code>.gitignore</code>忽略某文件的某行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class	App.class</span><br></pre></td></tr></table></figure>

<h2 id="git-设置代理"><a href="#git-设置代理" class="headerlink" title="git 设置代理"></a>git 设置代理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy http:&#x2F;&#x2F;proxyUsername:proxyPassword@proxy.server.com:port</span><br></pre></td></tr></table></figure>

<p>例如设置本地无认证的socks5代理，端口1080</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。所以版本控制是无法追踪WORD之类的二进制文件的。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Git/Git%E5%88%86%E6%94%AF%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Git分支详细笔记"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:46:06.000Z" title="2020-08-07T04:46:06.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Git/">Git</a></span><span class="level-item">an hour read (About 9566 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Git/Git%E5%88%86%E6%94%AF%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/">Git分支详细笔记</a></h1><div class="content"><blockquote>
<p>很神奇 很有趣 仔细做了笔记 很有收获</p>
</blockquote>
<h2 id="何谓分支"><a href="#何谓分支" class="headerlink" title="何谓分支"></a>何谓分支</h2><blockquote>
<p>Tips：简而言之 分支都是指向commit的指针，每一个分支都随着commit的提交而向新commit移动</p>
</blockquote>
<!-- mroe -->

<p>Git 保存的不是文件差异或者变化量，而只是一系列文件快照。</p>
<p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>
<p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m &#39;initial commit of my project&#39;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>git commit</code> 新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>
<p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图 3-1 所示：</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-commit-%E5%AF%B9%E8%B1%A1.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-commit-%E5%AF%B9%E8%B1%A1.png" alt="image-20200425191333714"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-commit-%E5%AF%B9%E8%B1%A1.png">image-20200425191333714</a></p>
<p> 图 3-1. 单个提交对象在仓库中的数据结构</p>
<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成图 3-2 的样子：</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B3%E7%B3%BB.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B3%E7%B3%BB.png" alt="image-20200425191533650"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%93%BE%E6%8E%A5%E5%85%B3%E7%B3%BB.png">image-20200425191533650</a></p>
<p> 图 3-2. 多个提交对象之间的链接关系</p>
<p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%86%E6%94%AF%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%BB%8E%E6%9F%90%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1%E5%BE%80%E5%9B%9E%E7%9C%8B%E7%9A%84%E5%8E%86%E5%8F%B2.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%86%E6%94%AF%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%BB%8E%E6%9F%90%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1%E5%BE%80%E5%9B%9E%E7%9C%8B%E7%9A%84%E5%8E%86%E5%8F%B2.png" alt="image-20200425191623606"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%86%E6%94%AF%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%BB%8E%E6%9F%90%E4%B8%AA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1%E5%BE%80%E5%9B%9E%E7%9C%8B%E7%9A%84%E5%8E%86%E5%8F%B2.png">image-20200425191623606</a></p>
<p> 图 3-3. 分支其实就是从某个提交对象往回看的历史</p>
<h2 id="创建和增长分支"><a href="#创建和增长分支" class="headerlink" title="创建和增长分支"></a>创建和增长分支</h2><p>那么，Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 <code>git branch</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>

<p>这会在当前 commit 对象上新建一个分支指针</p>
<p>其实答案也很简单，它保存着一个名为 HEAD 的特别指针。它指向你正在工作中的本地分支。运行 <code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作（参考图 3-5）。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD-%E6%8C%87%E5%90%91%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E7%9A%84%E5%88%86%E6%94%AF.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD-%E6%8C%87%E5%90%91%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E7%9A%84%E5%88%86%E6%94%AF.png" alt="image-20200425191947610"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD-%E6%8C%87%E5%90%91%E5%BD%93%E5%89%8D%E6%89%80%E5%9C%A8%E7%9A%84%E5%88%86%E6%94%AF.png">image-20200425191947610</a></p>
<p> 图 3-5. HEAD 指向当前所在的分支</p>
<p>要切换到其他分支，可以执行 <code>git checkout</code> 命令。我们现在转换到新建的 testing 分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>

<p>这样 HEAD 就指向了 testing 分支（见图3-6）。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD-%E5%9C%A8%E4%BD%A0%E8%BD%AC%E6%8D%A2%E5%88%86%E6%94%AF%E6%97%B6%E6%8C%87%E5%90%91%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD-%E5%9C%A8%E4%BD%A0%E8%BD%AC%E6%8D%A2%E5%88%86%E6%94%AF%E6%97%B6%E6%8C%87%E5%90%91%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF.png" alt="image-20200425192041060"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD-%E5%9C%A8%E4%BD%A0%E8%BD%AC%E6%8D%A2%E5%88%86%E6%94%AF%E6%97%B6%E6%8C%87%E5%90%91%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF.png">image-20200425192041060</a></p>
<p> 图 3-6. HEAD 在你转换分支时指向新的分支</p>
<p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &#39;made a change&#39;</span><br></pre></td></tr></table></figure>

<p>图 3-7 展示了提交后的结果。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E9%9A%8F%E7%9D%80%E5%88%86%E6%94%AF%E4%B8%80%E8%B5%B7%E5%90%91%E5%89%8D%E7%A7%BB%E5%8A%A8.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E9%9A%8F%E7%9D%80%E5%88%86%E6%94%AF%E4%B8%80%E8%B5%B7%E5%90%91%E5%89%8D%E7%A7%BB%E5%8A%A8.png" alt="image-20200425192314264"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E9%9A%8F%E7%9D%80%E5%88%86%E6%94%AF%E4%B8%80%E8%B5%B7%E5%90%91%E5%89%8D%E7%A7%BB%E5%8A%A8.png">image-20200425192314264</a></p>
<p> 图 3-7. 每次提交后 HEAD 随着分支一起向前移动</p>
<p>非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。现在我们回到 master 分支看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure>

<p>图 3-8 显示了结果。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD%E5%9C%A8%E4%B8%80%E6%AC%A1-checkout-%E4%B9%8B%E5%90%8E%E7%A7%BB%E5%8A%A8%E5%88%B0%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD%E5%9C%A8%E4%B8%80%E6%AC%A1-checkout-%E4%B9%8B%E5%90%8E%E7%A7%BB%E5%8A%A8%E5%88%B0%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF.png" alt="image-20200425192426649"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/HEAD%E5%9C%A8%E4%B8%80%E6%AC%A1-checkout-%E4%B9%8B%E5%90%8E%E7%A7%BB%E5%8A%A8%E5%88%B0%E4%BA%86%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF.png">image-20200425192426649</a></p>
<p> 图 3-8. HEAD 在一次 checkout 之后移动到了另一个分支</p>
<p>这条命令做了<strong>两件事</strong>。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p>
<p>我们作些修改后再次提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim test.rb</span><br><span class="line">$ git commit -a -m &#39;made other changes&#39;</span><br></pre></td></tr></table></figure>

<p>现在我们的项目提交历史产生了分叉（如图 3-9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要 <code>branch</code> 和 <code>checkout</code> 这两条命令就可以完成。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%B8%8D%E5%90%8C%E6%B5%81%E5%90%91%E7%9A%84%E5%88%86%E6%94%AF%E5%8E%86%E5%8F%B2.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%B8%8D%E5%90%8C%E6%B5%81%E5%90%91%E7%9A%84%E5%88%86%E6%94%AF%E5%8E%86%E5%8F%B2.png" alt="image-20200425192554108"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%B8%8D%E5%90%8C%E6%B5%81%E5%90%91%E7%9A%84%E5%88%86%E6%94%AF%E5%8E%86%E5%8F%B2.png">image-20200425192554108</a></p>
<p> 图 3-9. 不同流向的分支历史</p>
<p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。</p>
<p>Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即 <code>parent</code> 对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障。</p>
<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p><code>git branch</code> 命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>若要详细查看信息，运行 <code>git branch -v</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#39;iss53&#39;</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure>

<p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用 <code>--merged</code> 和 <code>--no-merged</code> 选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">$ git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure>

<p>一般来说，列表中没有 <code>*</code> 的分支通常都可以用 <code>git branch -d</code> 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。对应的，如果简单地用 <code>git branch -d</code> 删除未合并的分支会提示错误，因为那样做会丢失数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d testing</span><br><span class="line">error: The branch &#39;testing&#39; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#39;git branch -D testing&#39;.</span><br></pre></td></tr></table></figure>

<p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项 <code>-D</code> 强制执行，就像上面提示信息中给出的那样。</p>
<p><code>git branch -r</code>查看远程分支。</p>
<h1 id="分支例子"><a href="#分支例子" class="headerlink" title="分支例子"></a>分支例子</h1><blockquote>
<p>官方内容写的很好，我进行一些简单的概括，<a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">官方链接</a>（不过廖老师的例子和官方的好像啊 hhh）</p>
</blockquote>
<p><strong>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</strong></p>
<ol>
<li><strong>开发某个网站。</strong></li>
<li><strong>为实现某个新的需求，创建一个分支。</strong></li>
<li><strong>在这个分支上开展工作.。</strong></li>
</ol>
<p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>
<ol>
<li>返回到原先已经发布到生产服务器上的分支。</li>
<li>为这次紧急修补建立一个新分支，并在其中修复问题。</li>
<li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。</li>
<li>切换到之前实现新需求的分支，继续工作。</li>
</ol>
<h2 id="分支的新建与切换"><a href="#分支的新建与切换" class="headerlink" title="分支的新建与切换"></a><strong>分支的新建与切换</strong></h2><p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图 3-10）。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%B8%80%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%B8%80%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2.png" alt="image-20200425193307440"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%B8%80%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2.png">image-20200425193307440</a></p>
<p> 图 3-10. 一个简短的提交历史</p>
<p>现在，你决定要修补问题追踪系统上的 #53 问题。把新建的分支取名为 iss53。要新建并切换到该分支，运行 <code>git checkout</code> 并加上 <code>-b</code> 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch &#39;iss53&#39;</span><br></pre></td></tr></table></figure>

<p>这相当于执行下面这两条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure>

<p>图 3-11 示意该命令的执行结果。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E5%88%86%E6%94%AF%E7%9A%84%E6%8C%87%E9%92%88.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E5%88%86%E6%94%AF%E7%9A%84%E6%8C%87%E9%92%88.png" alt="image-20200425193327729"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E5%88%86%E6%94%AF%E7%9A%84%E6%8C%87%E9%92%88.png">image-20200425193327729</a></p>
<p> 图 3-11. 创建了一个新分支的指针</p>
<p>接着你开始尝试修复问题，在提交了若干次更新后，<code>iss53</code> 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 <code>HEAD</code> 指针正指向 <code>iss53</code>，见图 3-12）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#39;added a new footer [issue 53]&#39;</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/iss53-%E5%88%86%E6%94%AF%E9%9A%8F%E5%B7%A5%E4%BD%9C%E8%BF%9B%E5%B1%95%E5%90%91%E5%89%8D%E6%8E%A8%E8%BF%9B.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/iss53-%E5%88%86%E6%94%AF%E9%9A%8F%E5%B7%A5%E4%BD%9C%E8%BF%9B%E5%B1%95%E5%90%91%E5%89%8D%E6%8E%A8%E8%BF%9B.png" alt="image-20200425193347879"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/iss53-%E5%88%86%E6%94%AF%E9%9A%8F%E5%B7%A5%E4%BD%9C%E8%BF%9B%E5%B1%95%E5%90%91%E5%89%8D%E6%8E%A8%E8%BF%9B.png">image-20200425193347879</a></p>
<p> 图 3-12. iss53 分支随工作进展向前推进</p>
<p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 <code>iss53</code> 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回 <code>master</code> 分支。</p>
<p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。<strong>切换分支的时候最好保持一个清洁的工作区域</strong>。目前已经提交了所有的修改，所以接下来可以正常转换到 <code>master</code> 分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>

<p>此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p>
<p>接下来，你得进行紧急修补。我们创建一个紧急修补分支 <code>hotfix</code> 来开展工作，直到搞定（见图 3-13）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch &#39;hotfix&#39;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#39;fixed the broken email address&#39;</span><br><span class="line">[hotfix 3a0874c] fixed the broken email address</span><br><span class="line"> 1 files changed, 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/hotfix-%E5%88%86%E6%94%AF%E6%98%AF%E4%BB%8E-master-%E5%88%86%E6%94%AF%E6%89%80%E5%9C%A8%E7%82%B9%E5%88%86%E5%8C%96%E5%87%BA%E6%9D%A5%E7%9A%84.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/hotfix-%E5%88%86%E6%94%AF%E6%98%AF%E4%BB%8E-master-%E5%88%86%E6%94%AF%E6%89%80%E5%9C%A8%E7%82%B9%E5%88%86%E5%8C%96%E5%87%BA%E6%9D%A5%E7%9A%84.png" alt="image-20200425193421149"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/hotfix-%E5%88%86%E6%94%AF%E6%98%AF%E4%BB%8E-master-%E5%88%86%E6%94%AF%E6%89%80%E5%9C%A8%E7%82%B9%E5%88%86%E5%8C%96%E5%87%BA%E6%9D%A5%E7%9A%84.png">image-20200425193421149</a></p>
<p> 图 3-13. hotfix 分支是从 master 分支所在点分化出来的</p>
<p>有必要作些测试，确保修补是成功的，然后回到 <code>master</code> 分支并把它合并进来，然后发布到生产服务器。用 <code>git merge</code> 命令来进行合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> README | 1 -</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>请注意，合并时出现了“Fast forward”的提示。由于当前 <code>master</code> 分支所在的提交对象是要并入的 <code>hotfix</code>分支的直接上游，Git 只需把 <code>master</code> 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会<strong>简单地把指针右移</strong>，因为这种单线的历史分支不存在任何需要解决的分歧，<strong>所以这种合并过程可以称为快进（Fast forward）。</strong></p>
<p>现在最新的修改已经在当前 <code>master</code> 分支所指向的提交对象中了，可以部署到生产服务器上去了（见图 3-14）。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%86%E6%94%AF%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%BD%8D%E7%BD%AE.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%86%E6%94%AF%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%BD%8D%E7%BD%AE.png" alt="image-20200425193448731"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E5%88%86%E6%94%AF%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%BD%8D%E7%BD%AE.png">image-20200425193448731</a></p>
<p> 图 3-14. 合并之后，master 分支和 hotfix 分支指向同一位置。</p>
<p>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 <code>hotfix</code> 分支和 <code>master</code> 都指向相同的提交对象，所以 <code>hotfix</code> 已经完成了历史使命，可以删掉了。使用 <code>git branch</code> 的 <code>-d</code> 选项执行删除操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (was 3a0874c).</span><br></pre></td></tr></table></figure>

<p>现在回到之前未完成的 #53 问题修复分支上继续工作（图 3-15）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout iss53</span><br><span class="line">Switched to branch &#39;iss53&#39;</span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit -a -m &#39;finished the new footer [issue 53]&#39;</span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/iss53-%E5%88%86%E6%94%AF%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D%E7%BB%A7%E7%BB%AD%E6%8E%A8%E8%BF%9B.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/iss53-%E5%88%86%E6%94%AF%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D%E7%BB%A7%E7%BB%AD%E6%8E%A8%E8%BF%9B.png" alt="image-20200425193514085"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/iss53-%E5%88%86%E6%94%AF%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8F%97%E5%BD%B1%E5%93%8D%E7%BB%A7%E7%BB%AD%E6%8E%A8%E8%BF%9B.png">image-20200425193514085</a></p>
<p> 图 3-15. iss53 分支可以不受影响继续推进。</p>
<p>值得注意的是之前 <code>hotfix</code> 分支的修改内容<strong>尚未</strong>包含到 <code>iss53</code> 中来。如果需要纳入此次修补，可以用 <code>git merge master</code> 把 master 分支合并到 <code>iss53</code>；或者等 <code>iss53</code> 完成之后，再将 <code>iss53</code> 分支中的更新并入 <code>master</code>。</p>
<h2 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a><strong>分支的合并</strong></h2><p>在问题 #53 相关的工作完成之后，可以合并回 <code>master</code> 分支。实际操作同前面合并 <code>hotfix</code> 分支差不多，只需回到 <code>master</code> 分支，运行 <code>git merge</code> 命令指定要合并进来的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging README</span><br><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line"> README | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p><strong>请注意，这次合并操作的底层实现，并不同于之前 <code>hotfix</code> 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 <code>master</code> 分支所指向的提交对象（C4）并不是 <code>iss53</code> 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象：</strong></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E4%B8%BA%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E5%87%BA%E6%9C%80%E4%BD%B3%E7%9A%84%E5%90%8C%E6%BA%90%E5%90%88%E5%B9%B6%E7%82%B9.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E4%B8%BA%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E5%87%BA%E6%9C%80%E4%BD%B3%E7%9A%84%E5%90%8C%E6%BA%90%E5%90%88%E5%B9%B6%E7%82%B9.png" alt="image-20200425193538900"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E4%B8%BA%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E5%87%BA%E6%9C%80%E4%BD%B3%E7%9A%84%E5%90%8C%E6%BA%90%E5%90%88%E5%B9%B6%E7%82%B9.png">image-20200425193538900</a></p>
<p> 图 3-16. Git 为分支合并自动识别出最佳的同源合并点。</p>
<p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图 3-17）。这个提交<strong>对象比较特殊，它有两个祖先</strong>（C4 和 C5）。</p>
<p>值得一提的是 <strong>Git 可以自己裁决哪个共同祖先才是最佳合并基础</strong>；这和 CVS 或 Subversion（1.5 以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让 Git 的合并操作比其他系统都要简单不少。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E4%BA%86%E5%90%88%E5%B9%B6%E7%BB%93%E6%9E%9C%E7%9A%84%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E4%BA%86%E5%90%88%E5%B9%B6%E7%BB%93%E6%9E%9C%E7%9A%84%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1.png" alt="image-20200425193934126"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E4%BA%86%E5%90%88%E5%B9%B6%E7%BB%93%E6%9E%9C%E7%9A%84%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1.png">image-20200425193934126</a></p>
<p> 图 3-17. Git 自动创建了一个包含了合并结果的提交对象。</p>
<p>既然之前的工作成果已经合并到 <code>master</code> 了，那么 <code>iss53</code> 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d iss53</span><br></pre></td></tr></table></figure>

<h2 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a><strong>遇到冲突时的分支合并</strong></h2><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了 <code>hotfix</code> 中修改的部分，将得到类似下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>Git 作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <code>git status</code> 查阅：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;contact : email.support@github.com&lt;&#x2F;div&gt;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">  please contact us at support@github.com</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>=======</code> 隔开的上半部分，是 <code>HEAD</code>（即 <code>master</code> 分支，在运行 <code>merge</code> 命令时所切换到的分支）中的内容，下半部分是在 <code>iss53</code> 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">please contact us at email.support@github.com</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行。在解决了所有文件里的所有冲突后，运行 <code>git add</code> 将把它们标记为已解决状态（译注<strong>：实际上就是来一次快照保存到暂存区域</strong>。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行 <code>git mergetool</code>，它会调用一个可视化的合并工具并引导你解决所有冲突：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because &#39;merge.tool&#39; is not configured.</span><br><span class="line">See &#39;git mergetool --tool-help&#39; or &#39;git help config&#39; for more details.</span><br><span class="line">&#39;git mergetool&#39; will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for &#39;index.html&#39;:</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure>

<p>如果不想用默认的合并工具（Git 为我默认选择了 <code>opendiff</code>，因为我在 Mac 上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。</p>
<p>退出合并工具以后，Git 会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p>
<p>再运行一次 <code>git status</code> 来确认所有冲突都已解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br></pre></td></tr></table></figure>

<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用 <code>git commit</code> 来完成这次合并提交。提交的记录差不多是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#39;iss53&#39;</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">  index.html</span><br><span class="line">#</span><br><span class="line"># It looks like you may be committing a merge.</span><br><span class="line"># If this is not correct, please remove the file</span><br><span class="line">#       .git&#x2F;MERGE_HEAD</span><br><span class="line"># and try again.</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p>
<h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支（ <em>remote branch</em> ）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p>
<p>我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时 master 分支的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p>
<p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为 origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作</p>
<p>如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动（见图 3-23）。</p>
<p>可以运行 git fetch origin 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上（见图 3-24）。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/git-fetch-%E5%91%BD%E4%BB%A4%E4%BC%9A%E6%9B%B4%E6%96%B0-remote-%E7%B4%A2%E5%BC%95.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/git-fetch-%E5%91%BD%E4%BB%A4%E4%BC%9A%E6%9B%B4%E6%96%B0-remote-%E7%B4%A2%E5%BC%95.png" alt="image-20200425194111488"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/git-fetch-%E5%91%BD%E4%BB%A4%E4%BC%9A%E6%9B%B4%E6%96%B0-remote-%E7%B4%A2%E5%BC%95.png">image-20200425194111488</a></p>
<p>图 3-24. git fetch 命令会更新 remote 索引。</p>
<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用（见图 3-25）。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E6%8A%8A%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E4%B8%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E6%8A%8A%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E4%B8%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png" alt="image-20200425194159710"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E6%8A%8A%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E4%B8%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png">image-20200425194159710</a></p>
<p> 图 3-25. 把另一个服务器加为远程仓库</p>
<p>现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 teamone/master 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e（见图 3-26）。</p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%BD%A0%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%9C%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91.png"><img src="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%BD%A0%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%9C%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91.png" alt="image-20200425194223404"></a></p>
<p><a href="http://blog.come2rss.xyz/2020/04/25/tools/linux/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/Git-%E5%88%86%E6%94%AF%E8%AF%A6%E8%A7%A3/%E4%BD%A0%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%9C%89%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91.png">image-20200425194223404</a></p>
<p>图 3-26. 你在本地有了一个指向 teamone 服务器上 master 分支的索引。</p>
<h4 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h4><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你创建的本地分支不会因为你的写入操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p>
<p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 <code>git push (远程仓库名) (分支名)</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Compressing objects: 100% (14&#x2F;14), done.</span><br><span class="line">Writing objects: 100% (15&#x2F;15), 1.74 KiB, done.</span><br><span class="line">Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon&#x2F;simplegit.git</span><br><span class="line"> * [new branch]      serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为</p>
<p>refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍 refs/heads/ 部分的细节，不过一般使用的时候都可以省略它。也可以运行 git push origin serverfix:serverfix 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 git push origin serverfix:awesomebranch 来推送数据。</p>
</blockquote>
<p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个<strong>新的远程分支</strong> origin/serverfix，并指向服务器上 serverfix 所指向的版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 20, done.</span><br><span class="line">remote: Compressing objects: 100% (14&#x2F;14), done.</span><br><span class="line">remote: Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (15&#x2F;15), done.</span><br><span class="line">From git@github.com:schacon&#x2F;simplegit</span><br><span class="line"> * [new branch]      serverfix    -&gt; origin&#x2F;serverfix</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的 serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。</p>
<h3 id="合并远程分支或者分化"><a href="#合并远程分支或者分化" class="headerlink" title="合并远程分支或者分化"></a>合并远程分支或者分化</h3><p><strong>如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/serverfix。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch refs&#x2F;remotes&#x2F;origin&#x2F;serverfix.</span><br><span class="line">Switched to a new branch &quot;serverfix&quot;</span><br></pre></td></tr></table></figure>

<p>这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin/serverfix 一致，这样你就可以在里面继续开发了。</p>
<h4 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h4><p>从远程分支 checkout 出来的本地分支，称为**跟踪分支(tracking branch)**。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 <code>git push</code> 和 <code>git pull</code> 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：<code>git checkout -b [分支名] [远程名]/[分支名]</code>。如果你有 1.6.2 以上版本的 Git，还可以用<code>–track</code>选项简化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin&#x2F;serverfix</span><br><span class="line">Branch serverfix set up to track remote branch refs&#x2F;remotes&#x2F;origin&#x2F;serverfix.</span><br><span class="line">Switched to a new branch &quot;serverfix&quot;</span><br></pre></td></tr></table></figure>

<p>要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin&#x2F;serverfix</span><br><span class="line">Branch sf set up to track remote branch refs&#x2F;remotes&#x2F;origin&#x2F;serverfix.</span><br><span class="line">Switched to a new branch &quot;sf&quot;</span><br></pre></td></tr></table></figure>

<p>现在你的本地分支 sf 会<strong>自动将推送和抓取数据的位置定位</strong>到 origin/serverfix 了。</p>
<h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：git push [远程名] :[分支名]。如果想在服务器上删除 serverfix 分支，运行下面的命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">To git@github.com:schacon&#x2F;simplegit.git</span><br><span class="line"> - [deleted]         serverfix</span><br></pre></td></tr></table></figure>

<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code>语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。</p>
<p>经过查阅资料发现，高版本的git也可以这么删除分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete Chapater6</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Docker/Docker%E7%BD%91%E7%BB%9C/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Docker网络"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:40:59.000Z" title="2020-08-07T04:40:59.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Docker/">Docker</a></span><span class="level-item">3 minutes read (About 388 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Docker/Docker%E7%BD%91%E7%BB%9C/">Docker网络</a></h1><div class="content"><blockquote>
<p>这部分涉及了具体的Linux网络部分，理解的不是特别透彻</p>
</blockquote>
<p>Docker网络分为单host网络和多host网络，单host网络又分为无网络、host网络、 bridge网络和user-definer网络。</p>
<!-- mroe -->

<h2 id="单host网络"><a href="#单host网络" class="headerlink" title="单host网络"></a>单host网络</h2><p>单host网络实际上就是仅在一个主机上的多容器的网络，相反的多host网络定义就呼之欲出了。</p>
<h3 id="无网络"><a href="#无网络" class="headerlink" title="无网络"></a>无网络</h3><p>无网络即没有任何网络可以连接，适用于安全要求高无网络连接需要的容器，可以通过<code>docker run --network=none</code>中指定。</p>
<h3 id="host网络"><a href="#host网络" class="headerlink" title="host网络"></a>host网络</h3><p>host网络即直接使用host主机上的网络配置，与主机配置一样，但是容易出现端口占用而冲突。通过<code>--network=host</code>指定。</p>
<h3 id="bridge网络"><a href="#bridge网络" class="headerlink" title="bridge网络"></a>bridge网络</h3><p>docker安装时会创建一个名为docker0的Linux bridge。不指定<code>--network</code>默认创建的容器都会连接到docker0上。</p>
<p>新建的容器连接到网桥上会建立一个<code>interfaces</code>，容器自身会建立一个网卡<code>eho@xxx</code>，容器的网卡会连接到docker0网桥上的<code>interfaces</code>。其拓扑结构如下：</p>
<p><a href="http://static.come2rss.xyz/image-20200511125601000.png"><img src="http://static.come2rss.xyz/image-20200511125601000.png" alt="image-20200511125601000"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200511125601000.png">image-20200511125601000</a></p>
<p>（接下来的内容就非常的计算机网络了！，不同的网桥为啥不能通信？如果加上路由器（网管）就能通信了吗？希望以后读过TCP/IP之后再去学习）</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Docker/Docker%E5%AE%B9%E5%99%A8/"><img class="thumbnail" src="http://static.come2rss.xyz/th-1589169613559.jpg" alt="Docker容器"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:39:54.000Z" title="2020-08-07T04:39:54.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Docker/">Docker</a></span><span class="level-item">4 minutes read (About 557 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Docker/Docker%E5%AE%B9%E5%99%A8/">Docker容器</a></h1><div class="content"><blockquote>
<p>值得注意的是，命令中指定容器不同于镜像，需要指出名字。指定容器可以使用ps中显示的名称</p>
<p>和sID和<code>docker run</code>返回的lID（长ID）。</p>
<p>ID一般都是指容器的ID，当然ID也可用其他值代替，比如系统取的随机名称。</p>
</blockquote>
<!-- mroe -->

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>（看吐了Orz）</p>
<p>有两种方法可以进入容器，一种是<code>docker attch ID</code>，另一种是<code>docker exec -it id bash|sh</code>。</p>
<p>前者直径进入容器启动命令的终端，只适用于查看输出，适用性一般，而且可以使用<code>docker logs -f id</code>代替；后者会在容器中开启一个新进程并可以启动其他进程，除了查看输出优先推荐使用。</p>
<p>前者使用<code>ctrl+p</code> + <code>ctrl+q</code>组合推出终端，后者使用<code>exit</code>推出终端。</p>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p>容器其实是docker host上的一个进程。</p>
<p><code>docker stop id</code> 停止容器——向该进程发送<code>SIGTERM</code>信号。</p>
<p><code>docker kill id</code> 杀死容器——向该进程发送<code>SIGKILL</code>信号。</p>
<p><code>docker start id</code> 重启容器，当然会保留第一次启动时运行的参数。</p>
<p><code>docker restart id</code>重启容器，就是<code>stop</code>和<code>start</code>的组合。</p>
<p><code>docker pasuse id</code> 暂时停止工作，容器不再占据CPU资源；<code>docker unpasuse id</code> 恢复工作；</p>
<p><code>docker rm id</code> 删除容器；</p>
<blockquote>
<p><strong>批量删除：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v $(docker ps -aq -f status&#x3D;exited)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="容器声明周期"><a href="#容器声明周期" class="headerlink" title="容器声明周期"></a>容器声明周期</h2><p><a href="http://static.come2rss.xyz/docker-life-machine.png"><img src="http://static.come2rss.xyz/docker-life-machine.png" alt="docker-life-machine"></a></p>
<p><a href="http://static.come2rss.xyz/docker-life-machine.png">docker-life-machine</a></p>
<p>注意两个点：</p>
<ol>
<li>容器可以先<code>creat</code>再<code>start</code>，也可指直接<code>run</code>。</li>
<li>从这张图看<code>kill</code>和<code>stop</code>命令效果相同。</li>
<li>只有当容器正常退出和非正常退出，除了<code>kill</code>和<code>stop</code>之外都会依据<code>--restart</code>判断是否要重启</li>
</ol>
<h2 id="Docker底层"><a href="#Docker底层" class="headerlink" title="Docker底层"></a>Docker底层</h2><p>Docker技术采用了cgroup来配置容器的各个性能限制的额度，用namespace来实现各个容器的共享和相互隔离同一个或多个设备、网络、文件和用户。</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Docker/Docker%E9%95%9C%E5%83%8F/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Docker镜像"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:39:04.000Z" title="2020-08-07T04:39:04.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Docker/">Docker</a></span><span class="level-item">11 minutes read (About 1699 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Docker/Docker%E9%95%9C%E5%83%8F/">Docker镜像</a></h1><div class="content"><p>Dockerfile是镜像的描述文件，定义了如何构建镜像。</p>
<p>镜像中最基础的镜像是base镜像，不依赖于其他镜像，同时可以提供给其他镜像作为基础来扩展。那对应的Base镜像从Scratch构建。通常来说Base镜像是那些提供操作系统平台的镜像。</p>
<!-- mroe -->

<p>Linux的空间由内核空间（kernel）和用户空间（/dev,/proc等文件）组成。Linux启动时会加载bootfs文件系统，之后卸载掉bootfs，载入rootfs。对于base镜像而言，他底层使用的是Host的kernel，自身提供rootfs，比如基本命令、工具和程序库。也就是说对于镜像而言，内部他的kernel和host的kernel一致，而且无法修改。如果镜像对kernel有要求，可能使用虚拟机会更好一点。</p>
<p><a href="http://static.come2rss.xyz/image-20200509141013201.png"><img src="http://static.come2rss.xyz/image-20200509141013201.png" alt="img"></a></p>
<p>如下图，两个不同Base镜像可以在同一个host共用底层kernel。</p>
<p><a href="http://static.come2rss.xyz/image-20200509141349614.png"><img src="http://static.come2rss.xyz/image-20200509141349614.png" alt="img"></a></p>
<h3 id="容器的分层结构"><a href="#容器的分层结构" class="headerlink" title="容器的分层结构"></a>容器的分层结构</h3><p>构建一个新容器如下图dockfile所示，docker按照命令构建了多层级的叠加起来的容器。</p>
<p><a href="http://static.come2rss.xyz/image-20200509141824955.png"><img src="http://static.come2rss.xyz/image-20200509141824955.png" alt="img"></a></p>
<p><a href="http://static.come2rss.xyz/image-20200509141836171.png"><img src="http://static.come2rss.xyz/image-20200509141836171.png" alt="img"></a></p>
<p>一个重要的原因就是共享资源，也就是说Docker会共享不同镜像中的相同层的资源，避免重复载入。同时Docker最后添加一个可写层（称为容器层，其之下都称为镜像层）到每一个镜像的顶部，所有镜像的修改都会记录到Writable Container。</p>
<p><a href="http://static.come2rss.xyz/image-20200509142359240.png"><img src="http://static.come2rss.xyz/image-20200509142359240.png" alt="img"></a></p>
<p>其操作如下：</p>
<ol>
<li>添加文件：直接添加到容器层。</li>
<li>读取文件：从上到下依次到各个镜像寻找此文件</li>
<li>修改文件：同上查找文件并复制到容器层，然后修改（这称之为Copy-on-write）</li>
<li>删除文件：同上查找文件并在容器层中记录下删除记录</li>
</ol>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>有两种方式创建新镜像。一种是docker commit命令，另一种是写Dockerfile。</p>
<h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>这种方法不推荐使用，对其他人不知晓其构建方法，不透明，不安全，重现性差。</p>
<p>具体步骤：</p>
<ol>
<li><p>运行容器</p>
</li>
<li><p>安装软件</p>
</li>
<li><p>保存为新镜像并重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps #查看docker名字old_name</span><br><span class="line">docker commit old_name new_name</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><h5 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h5><p>可以在<code>/root</code>目录下构建一个Dockerfile文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y vim</span><br></pre></td></tr></table></figure>

<h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p>在Dockerfile文件夹下运行以下命令即可完成构建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ubuntu-with-vi-dockerfile .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>.</code>构建imagename为名的docker镜像， <code>-t</code>为命名参数，<code>-f</code>可指定Dockerfile位置。其中<code>.</code>表示build context为当前目录。Docker默认从bulid context中查找Dockerfile文件，并通过<code>ADD</code>，<code>COPY</code>命令将Build context中的文件添加到镜像。</p>
</blockquote>
<p><code>---&gt;20983rfjehwuh0e</code>就是表示docker构建了一个新的镜像，其iD为那串数字。</p>
<p><code>---&gt;Running in s132fj1142dSf</code>就是表示docker临时构建了一个镜像。</p>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>Docker会缓存已有的镜像的镜像层，比如包含<code>RUN apt-get update &amp;&amp; apt-get install -y vim</code>的新Dockerfile文件在构建时会直接利用已经存在的镜像，可以通过<code>--no-cache</code>禁用cache。</p>
<p>同时Dockfile的镜像层都是上层<strong>依赖</strong>下层的，所以只有之前一层的发生变化，镜像层的缓存就会失效。</p>
<p>在Docker<strong>下载上传镜像</strong>之时也会检查之前相同的docker镜像层来减少下载量。</p>
<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>进入在构建镜像失败之前的<strong>成功的镜像</strong>进行调试。</p>
<h5 id="Run-vs-CMD-vs-ENTRYPOINT"><a href="#Run-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="Run vs CMD vs ENTRYPOINT"></a>Run vs CMD vs ENTRYPOINT</h5><p>三种命令有两种编写格式：<code>Shell</code>和<code>Exec</code>。</p>
<p><code>Shell</code>格式比较简单。他会调用底层<code>shell</code>来执行命令，同时解析掉<strong>环境变量</strong>。其形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;instruction&gt; &lt;command&gt;</span><br><span class="line">ENV name Cloun Man ENTRYPOINT echo &quot;Hello ,$name&quot; #输出 Hello, Cloud man</span><br></pre></td></tr></table></figure>

<p><code>Exec</code>更易读。默认不解析而是直接调用命令, 当然也可以通过调用<code>sh</code>来解析环境变量，形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;instruction&gt; [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;,...]</span><br><span class="line">ENV name Cloud Man ENTRYPOINT [&quot;&#x2F;bin&#x2F;echo&quot;, &quot;Hello, $name&quot;] #输出：Hello, $name</span><br><span class="line">ENV name Cloud Man ENTRYPOINT [&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot; &quot;Hello, $name&quot;] #输出：Hello, Cloud man</span><br></pre></td></tr></table></figure>

<p><code>RUN</code>命令会执行命令并创建新的镜像层，常常用于安装软件包。注意要把<code>sudo apt-get update &amp;&amp; apt-get insatll -y\package</code>放在一起，不然分层的特性可能导致更新的那层是很久之前构建的。</p>
<p><code>CMD</code>命令将在容器运行初（docker run）执行命令，有三种格式：</p>
<ol>
<li>推荐的<code>Exec</code>：<code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>
<li>为<code>ENRTYPOINT</code>提供参数，此时必须使用<code>Exec</code>：<code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code></li>
<li><code>Shell</code>格式：<code>CMD command param1 param2</code></li>
</ol>
<p>注意<code>CMD</code>命令会被<code>docker run</code>指定的命令所<strong>代替</strong>，且只有<strong>最后</strong>一个CMD命令会生效</p>
<p><code>ENTRYPOINT</code>类似于<code>CMD</code>的执行命令格式，但是他不会被<code>docker run</code>指定的命令代替。同样的<code>ENTRYPOINT</code>有两种命令格式，但是不同的上面也讲了。<code>ENTRYPOINT</code>的参数一定都会被使用，同时可以由<code>CMD</code>提供参数，当然<code>CMD</code>参数也可以在容器启动是被动态替换掉。</p>
<blockquote>
<p><code>RUN</code>安装应用和服务；<code>CMD</code>设置默认启动命令；``ENTRYPOINT<code>运行服务和应用，同时用</code>CMD`提供动态可变参数。</p>
</blockquote>
<h4 id="其他Dockefile参数"><a href="#其他Dockefile参数" class="headerlink" title="其他Dockefile参数"></a>其他Dockefile参数</h4><p>（待学习）</p>
<h3 id="分发镜像"><a href="#分发镜像" class="headerlink" title="分发镜像"></a>分发镜像</h3><p>特定镜像名字格式：<code>[image name] = [registry]:[port]/[username]/[repository]:[tag]</code></p>
<p>默认tag值为<code>latest</code>，如果<code>build -t imagename:tag</code>中tag没有指明就会默认使用<code>latest</code>。registry默认为<code>hub.docker.com</code>，port默认为<code>5000</code>。</p>
<p>Docker Hub的repository的<strong>Tag命令方式</strong>如下：</p>
<ol>
<li><code>imagename:1</code>指向1这个分支中最新版本；</li>
<li><code>imagename:1.2</code>指向1.2这个分支中最新版本；</li>
<li><code>imagename:1.2.3</code>指向1.2.3这个分支中的版本；</li>
<li><code>imagename:latest</code>指向最新版本；</li>
</ol>
<p>用户上传的镜像的完整命名需要包含用户名字，形如<code>username/imagename:tag</code>。（官方维护的image没有名字）。而当用户上传到自己的registry是<strong>记得加registry:post</strong>。</p>
<h4 id="构建自己的Registry"><a href="#构建自己的Registry" class="headerlink" title="构建自己的Registry"></a>构建自己的Registry</h4><p>官网上已经开源了repository的docker，可以直接安装。</p>
<p>注意对自己建立的registry上传的image<strong>上传、下载</strong>时，需要写成完整正确的image名字</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Docker/Docker%E5%9F%BA%E7%A1%80%E9%80%9F%E8%AE%B0%E5%92%8C%E6%9E%B6%E6%9E%84/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="Docker基础速记和架构"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:38:24.000Z" title="2020-08-07T04:38:24.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Docker/">Docker</a></span><span class="level-item">11 minutes read (About 1577 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Docker/Docker%E5%9F%BA%E7%A1%80%E9%80%9F%E8%AE%B0%E5%92%8C%E6%9E%B6%E6%9E%84/">Docker基础速记和架构</a></h1><div class="content"><p>Docker是现代软件开发微服务的一个重要支柱，他让复杂多变的服务和系统能在仅一次调试和配置之后稳定运行——Build once, Vonfigure Once, and Run Auywhere.<br>Docker具有轻量、隔离的特性。Docker相比于虚拟化技术所需要的部署虚拟系统所要承担的巨大代价不同，Docker只需要将软件和依赖打包在一个镜像中，并与系统相隔离。Docker的图标的集装箱暗示了Container的作用——将软件打包起来，更快更方便的部署环境，消除了开发测试和生产环境的不一致性。</p>
<!-- mroe -->



<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>(官方在Ubuntu下的<a href="https://docs.docker.com/engine/install/ubuntu/">安装和升级教程</a>，当然我更喜欢的是WIn10下WLS2中的<a href="https://docs.docker.com/docker-for-windows/wsl-tech-preview/#download">Docker官方安装</a>（可见WSL2折腾笔记）和<a href="https://code.visualstudio.com/blogs/2020/03/02/docker-in-wsl2">VSCode的教程</a>。</p>
<p>这里我配合WSL2和Window下的Docker安装，成功在PS中开启了Docker命令，同时在WSL2的Linux dis开启了Docker进程，并且可以通过Localhost访问~按照VsCode教程来说这样已经可以通过VSCode直接访问（access）WLS中的容器了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>PS运行，可以访问localhost查看服务器，里面有docker更多教程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 80:80 docker&#x2F;getting-started</span><br></pre></td></tr></table></figure>

<p>Linux Dis 运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 如果成功，可以看到getting-started的容器正在运行！</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Windows10下的配合WLS2的Docker使用建议：</strong></p>
<ul>
<li><p>docker文题最好运行在Linux目录下，而非挂载在<code>/mnt</code>下的Win文件</p>
</li>
<li><p>VHDX文件的大小限制<a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-ux-changes#understanding-wsl-2-uses-a-vhd-and-what-to-do-if-you-reach-its-max-size">WSL tooling built into Windows</a>.</p>
</li>
<li><p>CPU和内存限制<a href="https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945">WSL 2 utility VM</a></p>
</li>
<li><p>安装桌面版Docker之前最好删除Linux Dis下的Docker版本</p>
</li>
</ul>
</blockquote>
<h3 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h3><p>为了提升镜像的安装速度，可以在<code>daocloud.io</code>中注册账户并点击顶部菜单的<strong>加速器</strong>，获取加速器命令，长得像这个样子`culr -sSl httpxxxxx | sh -s``。<strong>执行</strong>后，重启docker deamon即可获取飞一般的感觉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker.service #WSL2环境不支持此命令</span><br></pre></td></tr></table></figure>

<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>Docke以C/S为架构，组成部分为：Docker Clinet（docker命令启动）、Docker Server（Docker daemon）、Docker image、Registry和Docker Container。</p>
<p><a href="http://static.come2rss.xyz/image-20200509133957253.png"><img src="http://static.come2rss.xyz/image-20200509133957253.png" alt="img"></a></p>
<p>用户通过Docker Clinet启动Docker，用命令来制作下载Docker镜像并运行。Docker daemon是服务器组建，以Linux后台服务的方式运行，负责创建、运行、监控容器、构建和存储镜像。</p>
<p>默认情况下Docker deamon<strong>只能监听本地</strong>host的客户端请求，如果需要远程客户端请求，可以添加配置（具体Google）。</p>
<p>Docker images和Docker container的关系就像模子和陶瓷，可以通过Docker images创建Docker containers。镜像的制作方法有三种：（1）从头创建；（2）下载并使用其他人的现成镜像；（3）在一个镜像基础上创建一个新的镜像。</p>
<p>Docker container作为Docker images的运行实例，可以通过CLI（命令行接口）和API启动。</p>
<p>Registry是存放Docker镜像的仓库，分为公有和默认的，其中Docker Hub( <a href="https://hub.docker.com/)%E5%B0%B1%E6%98%AFDocker%E5%85%AC%E5%8F%B8%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%85%AC%E6%9C%89%E9%95%9C%E5%83%8F%E5%BA%93%E3%80%82">https://hub.docker.com/)就是Docker公司维护的公有镜像库。</a></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果第一次安装Docker，运行这条命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 80:80 httpd</span><br></pre></td></tr></table></figure>

<p>实际上Docker是这么处理的：</p>
<p><a href="http://static.come2rss.xyz/image-20200509135238794.png"><img src="http://static.come2rss.xyz/image-20200509135238794.png" alt="img"></a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><blockquote>
<p>ID一般都是指容器的ID，当然ID也可用其他值代替，比如系统取的随机名称。</p>
</blockquote>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><blockquote>
</blockquote>
<p><code>docker build -t imagename .</code> 在<code>.</code>构建imagename为名的docker镜像， <code>-t</code>为命名参数，<code>-f</code>可指定Dockerfile位置。</p>
<p><code>docker images imagename</code> 查看docker images 信息</p>
<p><code>docker history imagename</code>可以获取镜像的构建历史</p>
<p><code>docker tag imagename username/image:tag</code>实际上tag更像是一个改镜像名命令（原来image还保持原样）</p>
<p><code>docker rmi imagename</code> 仅仅删除Docker host中的镜像。或者说删除某一个tag的镜像，当然如果一个镜像有多个tag，直到删除最后一个tag，这个镜像才被删干净。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><code>docker run imagename</code> 运行docker images ，并输出容器的lID（长ID）</p>
<blockquote>
<p><code>-it</code> 交互模式进入容器</p>
<p><code>-d</code> 后台运行</p>
<p><code>-p</code> 端口映射</p>
<p><code>--name</code>显式命名镜像，不加就会自动为镜像命名</p>
<p><code>--restart=always</code>容器“停止运行”（包括正常退出）时，总是重启容器</p>
<p> 也可以<code>--restart=on-failure:3</code>最多重启三次</p>
</blockquote>
<blockquote>
<p>长期运行容器示例：<code>docker run imagename /bin/bash -c &quot;while true; do sleep 1; done&quot;</code></p>
<p><strong>资源限制</strong></p>
<p><code>-m</code>或者<code>--memory</code> 设置内存使用额度，如 <code>-m 200M --memory-swap=300M</code>设置了20M内存和300MSWAP磁盘额度。若参数为<code>-1</code>表示没有限制。</p>
<p><code>--vm n</code>开启n个内存工作线程</p>
<p><code>--vm-bytes 280M</code> 每个线程分配280M</p>
<p><code>-c 2048</code> 设置单个容器分配CPU权重（CPU share），其CPU share决定了该容器CPU分配时间占所有容器的权重，也就是算比例。默认参数为1024。</p>
<p>限制读写 可以查询block IO。</p>
</blockquote>
<p><code>docker create imagename</code>创建容器</p>
<p><code>docker start id</code>启动容器</p>
<p><code>docker pause id</code> `docker unpause id` 停止\恢复容器</p>
<p><code>docker stop id</code> 停止容器</p>
<p><code>docker kill id</code> 杀死容器</p>
<p><code>docker attach id</code> attach到容器启动进程的终端</p>
<p><code>docker exec id</code> 进入容器中并启动新进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps&#96; 显示运行中的容器。等价于&#96;docker container ls</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-a</code> 显示所有状态的容器，包括运行结束的镜像</p>
</blockquote>
<p><code>docker logs -f id</code> 持续打印输出</p>
<blockquote>
<p><code>-f</code>持续打印</p>
</blockquote>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p><code>docker login -u username</code> 登陆Docker</p>
<p><code>docker push imagename</code> 上传镜像到Docker hub。其镜像不用加tag就是上传统一repository中的所有镜像。</p>
<p><code>docker pull imagename</code>下载对应镜像</p>
<p><code>docker search imagename</code> 搜索镜像</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2020/08/07/Code%20tools/Anki/anki-GD%E5%8D%95%E8%AF%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="anki+GD单词解决方案"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-07T04:32:27.000Z" title="2020-08-07T04:32:27.000Z">2020-08-07</time><span class="level-item"><a class="link-muted" href="/categories/Code-tools/">Code tools</a><span> / </span><a class="link-muted" href="/categories/Code-tools/Anki/">Anki</a></span><span class="level-item">4 minutes read (About 558 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/07/Code%20tools/Anki/anki-GD%E5%8D%95%E8%AF%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">anki+GD单词解决方案</a></h1><div class="content"><p>Anki作为一款记忆神器，丰富的插件和本身的记忆原理相得益彰。这几天学习了一下其强大的功能，作为背单词的实用工具。本身只用Anki背诵单词，那么主要采取两种方法来快速生成导入单词卡片。</p></div><a class="article-more button is-small size-small" href="/2020/08/07/Code%20tools/Anki/anki-GD%E5%8D%95%E8%AF%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#more">Read More</a></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Code-tools/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/Code-tools/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Code-tools/">1</a></li><li><a class="pagination-link" href="/categories/Code-tools/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="http://static.come2rss.xyz/%E9%93%81%E7%94%B2%E5%9F%8Elogo.png" alt="Ove"></figure><p class="title is-size-4 is-block line-height-inherit">Ove</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>宁波</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">90</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知乎" href="https://www.zhihu.com/people/ddd-37-43"><i class="http://static.come2rss.xyz/zhihu.png"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/15-3sum/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="15 3sum"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:15:37.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/15-3sum/">15 3sum</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="1190. Reverse Substrings Between Each Pair of Parentheses"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:14:44.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses/">1190. Reverse Substrings Between Each Pair of Parentheses</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-DP-%E8%B4%AA%E5%BF%83/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="面试题 DP 贪心"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:14:08.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/%E9%9D%A2%E8%AF%95%E9%A2%98-DP-%E8%B4%AA%E5%BF%83/">面试题 DP 贪心</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/">剑指offer</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="786. 第 K 个最小的素数分数"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:13:32.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/786-%E7%AC%AC-K-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/">786. 第 K 个最小的素数分数</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article><article class="media"><a class="media-left" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/"><p class="image is-64x64"><img class="thumbnail" src="http://static.come2rss.xyz/尼尔机械.jpg" alt="1025 除数博弈"></p></a><div class="media-content size-small"><p><time dateTime="2020-08-07T06:13:01.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E5%88%B7%E9%A2%98/LeetCode/1025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/">1025 除数博弈</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a> / <a class="link-muted" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/">LeetCode</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">90</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/AI/DL/"><span class="level-start"><span class="level-item">DL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CS/Algorithms/"><span class="level-start"><span class="level-item">Algorithms</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/CN/"><span class="level-start"><span class="level-item">CN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/CSAPP/"><span class="level-start"><span class="level-item">CSAPP</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/DB/"><span class="level-start"><span class="level-item">DB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CS/DS/"><span class="level-start"><span class="level-item">DS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/"><span class="level-start"><span class="level-item">Code tools</span></span><span class="level-end"><span class="level-item tag">24</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Anki/"><span class="level-start"><span class="level-item">Anki</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Jupyter/"><span class="level-start"><span class="level-item">Jupyter</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Matlab/"><span class="level-start"><span class="level-item">Matlab</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Pycharm/"><span class="level-start"><span class="level-item">Pycharm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/VScode/"><span class="level-start"><span class="level-item">VScode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Code-tools/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">14</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Language/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Go/"><span class="level-start"><span class="level-item">Go</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Language/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">刷题</span></span><span class="level-end"><span class="level-item tag">31</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/PAT/"><span class="level-start"><span class="level-item">PAT</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer/"><span class="level-start"><span class="level-item">剑指offer</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://static.come2rss.xyz/%E9%92%A2%E9%93%81%E4%BE%A0.png" alt="Hexo" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>