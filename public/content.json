{"pages":[],"posts":[{"title":"ä¼˜ç§€æ˜¯ä¼šé—ä¼ çš„å§ï¼Ÿ","text":"Gå§å¦ˆå¦ˆè®¿è°ˆå½•å¬åˆ°Gå§éº»éº»å’ŒGå§çš„è®¿è°ˆï¼Œéå¸¸éå¸¸éœ‡æƒŠã€‚Gå§å®¶åº­ç¯å¢ƒéå¸¸å¥½ï¼Œçˆ¸çˆ¸æ˜¯å¯ŒäºŒä»£ï¼Œå¦ˆå¦ˆç¾å›½åæ ¡ç¡•å£«ï¼Œå“ˆä½›åšå£«åã€‚å¦ˆå¦ˆæ¯”è¾ƒå¼€æ˜ï¼Œç†æ€§ï¼Œå¯¹å®¶åº­å’Œå­©å­éƒ½æ˜¯é‡‡å–é¼“åŠ±å¼æ•™è‚²ã€‚æˆ‘æœ€æ¬£èµçš„æ˜¯Gå¦ˆèº«ä¸Šé‚£è‚¡ä¸“æ³¨æŠ•èº«äºå‘½è¿çš„ä¸“æ³¨ï¼Œé‚£ç§å…¨èº«å¿ƒçš„æŠ•å…¥ç›®æ ‡ä¸­å»ï¼ŒæŠ—äº‰æ‰€èƒ½äº‰å–çš„ï¼Œä»ä¸ç–²åŠ³ä¸æŠ±æ€¨çš„çŠ¶æ€å’Œå¿ƒå¢ƒã€‚åŒæ—¶ä¹Ÿä¸ºå¥¹è¿™ç§çœ‹é€äººä¸–çš„æ™ºæ…§ï¼Œå·§å¦™çš„ä¸äººç›¸å¤„çš„æ°”è´¨æ‰€è†œæ‹œã€‚ å“ˆå“ˆï¼Œä½†æ„¿æˆ‘ä¹Ÿèƒ½æ‰¾åˆ°è¿™ä¹ˆä¸€ä¸ªä¼˜ç§€çš„å¥³å­©å­ã€‚å¯ä»¥çœ‹çœ‹èƒ¸å¤§æœ‰è„‘ç”¨å¿ƒåšè§†é¢‘çš„Gå§ã€‚","link":"/2020/11/25/sui-tan/you-xiu-shi-hui-yi-chuan-de-ba/"},{"title":"å¤§æ•°æ®äº§å“æ€è€ƒâ€”â€”åœ°çƒä¿å«è€…","text":"åœ°çƒå®ˆæŠ¤è€…å°±è¯¾å ‚ä½œä¸šæ‰¯æ‰¯æ·¡ åŸè°…æˆ‘çš„æ–‡ä¸å¯¹é¢˜ å¤§æ•°æ®ä¹‹æ‰€ä»¥å¤§ï¼Œæ˜¯å¾—åˆ©äºç°ä»£åŒ–æ•°å­—åŒ–ç”Ÿæ´»çš„åœ¨å…¨å›½å…¨çƒèŒƒå›´çš„å¿«é€Ÿæ™®åŠå’Œå‘å±•ï¼Œå…¶ä¸­æ•°æ®çš„èµ·æºæ¥æºäºå¤§ä¼—ç”Ÿæ´»ä¸­é‡å¤çš„éœ€æ±‚å’Œè¡Œä¸ºã€‚æ¯”å¦‚ç¾å›¢æ§åˆ¶äº†å¤–å–ï¼Œç‚¹é¤çš„ä¿¡æ¯æ¸ é“ï¼Œæ”¯ä»˜å®å’Œå¾®ä¿¡æ”¯ä»˜æŠŠæŒäº†äººæ°‘æ”¯ä»˜è¡Œä¸ºçš„å·¨å¤§å…¥å£ã€‚ç°æœ‰çš„æ¨¡å¼ï¼ˆæˆ‘è§‚å¯Ÿåˆ°çš„ï¼‰å°±æœ‰ï¼šå¹³å°æ¨å‡ºæ–°æ¨¡å¼æ”¹å˜ç”¨æˆ·è¡Œä¸ºï¼Œå‹ç¼©ä¼ ç»Ÿå¸‚åœºå æœ‰ç©ºé—´ï¼Œç”±æ­¤åœ¨å¹³å°ä¸Šæ”¶é›†ç”¨æˆ·å¤§æ•°æ®ï¼Œå¹¶ç”¨å¤§æ•°æ®è¿›è¡Œå†³ç­–ä¼˜åŒ–ä»¥æå‡è¥æ”¶ã€‚æ¯”å¦‚Keepè®©ç”¨æˆ·æ¥å—äº†è®°å½•è¿åŠ¨ç”Ÿæ´»ï¼Œè¿›è€Œå°è¯•ä»˜è´¹è§£é”è¿åŠ¨å¥åº·çŸ¥è¯†ï¼Œè€ŒæŒæ¡äº†å¤§é‡äººç¾¤çš„è¿åŠ¨æ•°æ®å¯ä»¥å¸®åŠ©keepåˆ†æç”¨æˆ·ï¼Œä½†çœŸæ­£çš„éœ€æ±‚è¿˜æ˜¯è¿åŠ¨ã€‚ è¿™ä¸ªæ¡ˆä¾‹æ˜¯å¤§æ•°æ®é™„åŠ åœ¨äº§å“å¹³å°ä¸Šçš„å±æ€§ï¼Œæˆ‘åœ¨æ€è€ƒçœŸæ­£èƒ½å¤Ÿç”¨å¤§æ•°æ®é©±åŠ¨éœ€æ±‚äº§å“åˆ°åº•æœ‰ä»€ä¹ˆï¼Ÿä¹Ÿè®¸æœ‰å¤§æ•°æ®ç›‘æ§é“è·¯ï¼Œç›‘æ§ç”Ÿæ€ï¼Œæ™ºèƒ½åŸå¸‚ç®¡ç†ä¹‹ç±»çš„éœ€æ±‚ï¼ˆè¿™äº›éƒ½ç”¨äººåšäº†ï¼‰ã€‚æˆ‘æƒ³å¯èƒ½ç”¨å¤§æ•°æ®ç›‘æ§å¤ªé˜³ç³»çªå…¥èµ·æ¥çš„å°è¡Œæ˜Ÿé˜²æ­¢æ’å‡»åœ°çƒæ˜¯ä¸€ä¸ªå¥½ä¸»æ„ï¼æ²¡é”™ çœŸæ­£çš„å›°éš¾ä¸ä»…ä»…åœ¨äºå¦‚ä½•æ„è±¡å‡ºä¸€æ¬¾å¤§æ•°æ®äº§å“ï¼Œè€Œæ˜¯å¦‚ä½•è·å–åˆ°ç”¨æˆ·ï¼ˆæˆ–æ”¿åºœä¸€æŠ‘æˆ–å…¬å¸ï¼Œçœ‹ä½ ä»¬åšå“ªä¸ªç«¯ï¼‰çš„æ•°æ®ã€‚æ”¿åºœçš„æ•°æ®å› ä¸ºä¿å¯†ã€å®‰å…¨ã€è®¾å¤‡è€æ—§å’Œäººè„‰ä¸é€šè€Œæ— æ³•è·å–ï¼Œå¤§å…¬å¸æ•°æ®å°±æ›´éš¾äº†ï¼Œä½ éƒ½æœ‰äº†ä¸ºå•¥è‡ªå·±ä¸åšä¸€ä¸ªï¼ˆè…¾è®¯ï¼šå·è¢­ï¼æˆ‘69å²çš„è€æ•°æ®ï¼‰ã€‚åˆ°åº•æ˜¯ä¸ºäº†åšå¤§æ•°æ®äº§å“å»æ„è±¡ä¸€æ¬¾äº§å“å‘¢ï¼Œè¿˜æ˜¯ä¾æ®éœ€æ±‚å»åšä¸€ä¸ªäº§å“ï¼Œå¦‚æœèƒ½ç”¨å¤§æ•°æ®å°±ç”¨å¤§æ•°æ®ï¼Œå­°ä¼˜å­°åŠ£ã€‚ å¦‚æœç”¨å¤§æ•°æ®å¹³å°æŠ€æœ¯ä¼˜åŠ¿ä½œä¸ºä¼˜åŠ¿ç‚¹ï¼Œæˆ‘â€¦â€¦ ä¸Šè¡£é¢å¯¹å¹´è½»äººå¤šå…ƒåŒ–ï¼Œå¤šæ½®æµçš„æœè£…éœ€æ±‚ï¼Œä¸€ä¸ªå¿«é€Ÿæ¨èã€æŒ‡å‡ºæ½®æµæŒ‡æ•°ï¼Œè¡¨ç°ä¸ªäººæ¬²æœ›çš„å¹³å°å‘¼ä¹‹æ¬²å‡ºã€‚ä½ å¯ä»¥åœ¨å¹³å°poå‡ºä½ çš„ç€è£…ï¼Œå¹³å°ä¼šè‡ªåŠ¨è®°å½•è¯†åˆ«ç”¨æˆ·çš„æœè£…ç§ç±»ï¼Œè´­ä¹°å¹³å°ã€‚å¹³å°ä¼šå¯¹ç”¨æˆ·è¿›è¡Œç”¨æˆ·ç”»åƒï¼Œå°è¯•è¿›è¡Œç”¨æˆ·æ¨èç›¸ä¼¼çš„é£æ ¼çš„è¡£æœå’Œç”¨æˆ·ã€‚åœ¨å¤§æ•°æ®åŠ æŒä¸‹ï¼Œç”¨æˆ·å¯ä»¥åœ¨å¹³å°ä¸ŠæŸ¥çœ‹å½“å¤©å½“æœˆå½“å­£çš„æµè¡ŒæŒ‡æ•°ï¼Œæ¬£èµæœ€ç«çš„è¡£æœæ¨èï¼Œä»å¹³å°æ¨é€ä¸­åšå‡ºæ›´åŠ é€‚åˆè‡ªå·±çš„ï¼Œçœå¿ƒçš„é€‰æ‹©ã€‚åœ¨æ›´åŠ é«˜çº§çš„äººæ€§åŒ–å®šåˆ¶ï¼Œå¤§æ•°æ®èµ·åˆ°äº†æ›´å¤šçš„ä½œç”¨ï¼šä¸ªäººé£æ ¼è®¾è®¡ã€365å¤©ä¸é‡æ ·ä¸ªäººç€è£…è®¾è®¡â€¦â€¦ æ€»ä¹‹è¿™æ˜¯ä¸€ä¸ªç»“åˆç”¨æˆ·ç¤¾äº¤ä¸ªæ€§åŒ–å±•ç¤ºï¼Œç”¨æˆ·è¡£æœé€‰è´­ï¼Œç”¨æˆ·è¡£æœæµè¡Œè¶‹åŠ¿å±•ç¤ºçš„é€‰è¡£å¹³å°ã€‚ è¿™ä¸ªéœ€æ±‚å¾ˆçœŸï¼Œæˆ‘å°±æƒ³è¦ã€‚ ç—›ç‚¹ï¼šç§å­ç”¨æˆ·éš¾è·å– ç—’ç‚¹ï¼šå¯ä»¥åæ­£è¨€é¡ºçš„å‘è‡ªæ‹ çˆ½ç‚¹ï¼šè®©æ‡’é¬¼éšä¾¿é€‰æ‹©è¡£æœï¼Œè®©ä¸ªæ€§åŒ–é«˜çš„ç”¨æˆ·æœ‰å±•ç¤ºç©ºé—´ï¼Œè·å–è®¤åŒå’Œåæ°” å¸‚åœºè§„æ¨¡ï¼šå…¨å›½å…¨çƒ ç§å­ç”¨æˆ·ï¼šè¿™æ˜¯ä¸€ä¸ªè¾¹é™…è·å®¢æˆæœ¬å¾ˆä½çš„å¹³å°ã€‚ç§å­ç”¨æˆ·å»ºè®®åœ¨å¤§å­¦é«˜æ ¡ä¸­å¤§è§„æ¨¡æ¨å¹¿ï¼Œä»–ä»¬æ˜¯éœ€æ±‚æœ€å¤§çš„ç¾¤ä½“ã€‚ åˆ©æ¶¦æ¥æºï¼šè¡£æœæ¨èå•†çš„ä½£é‡‘ä»¥åŠé«˜åº¦è‡ªå®šä¹‰è¯çš„è¡£ç‰©ç•Œç›¸å…³é‡‘ä¸»å¹¿å‘Šæ¤å…¥ï¼Œåšæˆä¸€ä¸ªå…è´¹çš„å¹³å°æ˜¯äº’è”ç½‘å¸¸æ€å§ã€‚","link":"/2020/11/28/sui-tan/da-shu-ju-chan-pin-si-kao-di-qiu-bao-wei-zhe/"},{"title":"cmakeå­¦ä¹ ç´¢å¼•","text":"Cmakeç¬”è®°Cmakeæ˜¯è·¨ç³»ç»Ÿï¼ŒC++ç°è¡Œæ ‡å‡†æ„å»ºæ ‡å‡†çš„build system of build system`. æ¯”è¾ƒå¥½çš„å­¦ä¹ èµ„æºå¦‚ä¸‹ï¼š understand Cmake âœ…: ä¸€ä¸ªç®€å•çš„æ¥å— cmake official web ï¼š å¯¹å„ä¸ªå‘½ä»¤æœ‰æœ€è¯¦ç»†çš„è§£é‡Šï¼Œå½“å­—å…¸ç”¨ Cmake Tutorial: ğŸ’–ä»é›¶åŸºç¡€è§£é‡ŠCMakeåŸºç¡€æ¦‚å¿µï¼Œçœ‹å®Œè¿™ä¸ªå†çœ‹å®˜æ–¹æ•™ç¨‹å°±å¾ˆç®€å•äº† cmake tutorial âœ… ï¼šè·Ÿç€åšæ¯”è¾ƒæœ‰æ„æ€ï¼Œå¯ä»¥å¤šå¤šå°è¯•ï¼Œå°±æ˜¯æœ‰ç‚¹èŠ±æ—¶é—´ã€‚åé¢éƒ¨åˆ†å†…å®¹å¯ä»¥çœ‹çœ‹ Cmake Detailed tutorial âœ…: æœ€è¯¦ç»†ï¼Œæœ‰å¾ˆå¤šé¡¹ç›®ç»éªŒ çœ‹å®Œäº†ï¼Œç›´æ¥ä¸Šæ‰‹é¡¹ç›®æˆ–è€…çœ‹å…¶ä»–å¼€æºé¡¹ç›®å¦‚ä½•ç®¡ç†ä¹Ÿæ˜¯æœ‰ç‚¹å¯å‘æ»´ã€‚å½“ç„¶å¯¹ç…§ç€ä¸€ä¸ªçœŸå®é¡¹ç›®å­¦ä¹ Cmakeä¹Ÿæœ‰ç‚¹å¸®åŠ©ã€‚","link":"/2021/05/04/code-tools/build/cmake-xue-xi-suo-yin/"},{"title":"10. Regular Expression Matching","text":"10. Regular Expression Matchingæ€è·¯ï¼šhardçš„DPé¢˜ï¼Œæ€è·¯è§ä»£ç ã€‚ ä»£ç ï¼šclass Solution { public: bool isMatch(string s, string p) { int n = s.size(), m = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false)); dp[0][0] = true; for(int j = 1; j &lt;= m; j++){ if(j &gt; 1 &amp;&amp; p[j - 1] == '*') dp[0][j] = dp[0][j - 2]; for(int i = 1; i &lt;= n; i++){ if(p[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1]; else if(p[j - 1] != '*') dp[i][j] = dp[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1]; else if(s[i - 1] != p[j - 2] &amp;&amp; p[j - 2] != '.') dp[i][j] = dp[i][j -2]; else // C* å­ä¸²å¯ä»¥åŒ¹é… // 1. é‡å¤æ¨¡å¼ C, æ¯”å¦‚ [aaï¼Œa*] -&gt; [aï¼Œa*]ï¼Œ[baï¼Œba*] -&gt; [bï¼Œba*] (-&gt; [bï¼Œb]) // 2. æ”¾å¼ƒåŒ¹é… C, æ¯”å¦‚ [bï¼Œba*] -&gt; [bï¼Œb] // æˆ‘å°è¯•å»æ‰äº† 3 ä¹Ÿæ˜¯å¯ä»¥è¿‡çš„å‘µå‘µ~ // 3. ç¬¬ä¸€æ¬¡åŒ¹é… C, æ¯”å¦‚ [aï¼Œa*] -&gt; [a ï¼Œa] //è¿™é¢˜éš¾å°±éš¾åœ¨è¿™, æƒ³åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ dp[i][j] = dp[i -1][j] || dp[i][j - 2] ;//|| dp[i][j - 1]; } } return dp[n][m]; } };","link":"/2020/12/23/shua-ti/dp/10-regular-expression-matching/"},{"title":"121. Best Time to Buy and Sell Stock","text":"121. Best Time to Buy and Sell Stockæ€è·¯ï¼šè®°å½•æœ€å€¼ã€‚ ä»£ç ï¼šclass Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.size() == 0) return 0; int profit = 0; int minv = prices[0]; for(auto v : prices){ minv = min(minv, v); profit = max(profit, v - minv); } return profit; } };","link":"/2020/12/23/shua-ti/dp/121-best-time-to-buy-and-sell-stock/"},{"title":"123. Best Time to Buy and Sell Stock III","text":"123. Best Time to Buy and Sell Stock IIIæ€è·¯ï¼š å€Ÿç”¨ç®€å•è‚¡ç¥¨çš„æ€è·¯å¯ä»¥åŒå‘éå†price,è·å–price[0, i]å’Œprice[i, n]ä¸¤ä¸ªæ—¶é—´æ®µå„è‡ªæœ€å¤§çš„èŠ±è´¹ã€‚ æ¯”è¾ƒå·§å¦™ï¼Œç”¨ç¬¬ä¸€æ®µæ“ä½œçš„åˆ©æ¶¦å»æŠµæ¶ˆç¬¬äºŒæ®µè´­ä¹°æ—¶çš„èŠ±è´¹ï¼Œä¸€æ¬¡éå†ã€‚ è‚¡ç¥¨çš„é¢˜ç›®æœ‰å¾ˆå¤šï¼Œæ…¢æ…¢å†™ã€‚ ä»£ç ï¼š35% class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int d = prices.size(); vector&lt;int&gt; left(d, 0), right(d, 0); int maxv = prices[0], minv = prices[0], maxpro = 0; for(int i = 0; i &lt; d; ++i){ if(minv &gt; prices[i]){ maxv = minv = prices[i]; } maxv = max(maxv, prices[i]); maxpro = left[i] = max(left[i], max(maxpro, maxv - minv)); } maxv = minv = prices[d - 1], maxpro = 0; for(int i = d - 1; i &gt;= 0; --i){ if(maxv &lt; prices[i]){ maxv = minv = prices[i]; } minv = min(minv, prices[i]); maxpro = right[i] = max(right[i], max(maxpro, maxv - minv)); } int res = 0; for(int i = 0; i &lt; d; ++i){ res = max(res, left[i] + right[i]); // cout &lt;&lt; left[i] + right[i] &lt;&lt; endl; } return res; } }; 93% class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int d = prices.size(); int pro1, pro2, minp1, minp2; pro1 = pro2 = INT_MIN; minp1 = minp2 = INT_MAX; for(auto p : prices){ minp1 = min(p, minp1); pro1 = max(pro1, p - minp1); minp2 = min(minp2, p - pro1); pro2 = max(pro2, p - minp2); } return pro2; } };","link":"/2020/12/25/shua-ti/dp/123-best-time-to-buy-and-sell-stock-iii/"},{"title":"124. Binary Tree Maximum Path Sum","text":"124. Binary Tree Maximum Path Sumæ€è·¯ï¼šè¿™é¢˜æœ‰æ„æ€åœ¨DPã€‚ä½†ç®—ä¸ä¸Šhardã€‚ æ ‘ä¸Šçš„æœ€å¤§è·¯å¾„ä¹‹å’Œå¯ä»¥è½¬åŒ–ä¸ºä¸€ä¸ªèŠ‚ç‚¹ä¸Šçš„å·¦å³å­æ ‘è¿èµ·æ¥çš„è·¯å¾„ï¼Œè€Œå·¦å³è·¯å¾„çš„æœ€å¤§é•¿åº¦åˆ†åˆ«å¯ä»¥é€šè¿‡å·¦å³å­æ ‘çš„è·¯å¾„çš„ä¸€éƒ¨åˆ†æ±‚å¾—ã€‚è€ƒè™‘åˆ°å­æ ‘è·¯å¾„ä¹‹å’Œå°äº0çš„æƒ…å†µï¼Œæœ‰å½“å‰èŠ‚ç‚¹å’Œå·¦å³å­æ ‘è·¯å¾„çš„æœ€å¤§é•¿åº¦ä¸ºï¼šDP[i] = max(max(DP[i * 2],0), max(DP[i * 2 + 1],0) + val ã€‚åŒæ—¶å¯ä»¥æ±‚å‡ºï¼Œå½“å‰èŠ‚ç‚¹æœ€é•¿è·¯å¾„ï¼Œpathsum = max(DP[i * 2],0) + max(DP[i * 2 + 1],0) + valã€‚ ä»£ç ï¼š /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int maxv = 0; public: int maxPathSum(TreeNode* root) { maxv = root-&gt;val; maxPathSumCore(root); return maxv; } int maxPathSumCore(TreeNode *root){ if(!root) return 0; int lv = maxPathSumCore(root-&gt;left); lv = max(0, lv); int rv = maxPathSumCore(root-&gt;right); rv = max(0, rv); maxv = max(maxv, lv + rv + root-&gt;val); return root-&gt;val + max(lv, rv); } };","link":"/2021/04/19/shua-ti/dp/124-binary-tree-maximum-path-sum/"},{"title":"1289.Minimum Falling Path Sum2","text":"1289. Minimum Falling Path Sum IIæ€è·¯ï¼šè¿™é¢˜æ¯”è¾ƒç®€å•ï¼Œdpåšå°±è¡Œã€‚ å¯»æ‰¾æœ€å°å€¼çš„æ—¶å€™å¯ä»¥ç›´æ¥è®°å½•ï¼Œæˆ–è€…ç”¨å †è®°å½•å‰2ä¸ªæœ€å°å€¼ï¼Œä»è€Œå¿«é€Ÿdpã€‚è€Œè®°å½•çš„åŒæ—¶å¯ä»¥å‘ç°ï¼Œä¹‹å‰å¤šä½™dpä¿¡æ¯æ— éœ€å­˜å‚¨ï¼Œæ‰€ä»¥å¯ä»¥æŠŠç©ºé—´å¤æ‚åº¦ä»$O(n)$é™åˆ°$O(1)$ã€‚ ä»£ç ï¼šclass Solution { public: int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; arr) { int dp[2][300] = {0}; int minp[300]; int len = arr.size(); priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq; //init for(int i = 0; i &lt; len; i++){ dp[0][i] = arr[0][i]; if(pq.size() &lt; 2) pq.push(arr[0][i]); else if(pq.top() &gt; arr[0][i]){ pq.pop(); pq.push(arr[0][i]); } } //dp for(int i = 1; i &lt; len; i++){ int nowr = i &amp; 1; int lastr = (i - 1) &amp; 1; int min2 = pq.top(); pq.pop(); int min1 = pq.top(); pq.pop(); for(int j = 0; j &lt; len; j++){ if(min1 == dp[lastr][j]) dp[nowr][j] = min2 + arr[i][j]; else dp[nowr][j] = min1 + arr[i][j]; if(pq.size() &lt; 2){ pq.push(dp[nowr][j]); } else if(dp[nowr][j] &lt; pq.top()){ pq.pop(); pq.push(dp[nowr][j]); } } } pq.pop(); return pq.top(); } };","link":"/2020/09/23/shua-ti/dp/1289-minimum-falling-path-sum2/"},{"title":"139. Word Break","text":"139. Word Breakæ€è·¯ï¼šåŠ¨æ€è§„åˆ’ï¼š$dp[i]=1$è¡¨ç¤ºså­ä¸²s.substr(0,i + 1)å¯ä»¥è¢«åœ¨è¯å…¸ä¸­æ­£ç¡®åˆ‡åˆ†ã€‚ ä»£ç :77% class Solution { public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { // if(s.size()) set&lt;string&gt; dict; for(auto t : wordDict) dict.insert(t); vector&lt;int&gt; dp(s.size(), 0); // int lastdo = 0; for(int i = 0;i &lt; s.size(); ++i){ if(dict.count(s.substr(0, i + 1))) dp[i] = 1; for(int j = i; j &gt; 0; j--){ if(dp[j - 1] &amp;&amp; dict.count(s.substr(j, i - j + 1))){ dp[i] = 1; break; } } } if(dp[s.size() - 1]) return true; return false; } };","link":"/2020/12/13/shua-ti/dp/139-word-break/"},{"title":"1411. Number of Ways to Paint N Ã— 3 Grid","text":"1411. Number of Ways to Paint N Ã— 3 Grid é¢˜ç›®ä¸éš¾ï¼Œä½†æ˜¯å› ä¸ºä¸€ä¸ªç´¯åŠ çš„åˆå§‹åŒ–çš„å°bugæ²¡æœ‰æ‰¾å‡ºæ¥è€Œæµªè´¹äº†å¥½å¤šæ—¶é—´ï¼ æ€è·¯ï¼šå…ˆéå†å¯»æ‰¾å¯ä»¥å æ”¾çš„å›¾å—ï¼Œç„¶ådpæ•°é‡å³å¯ï¼Œç©ºé—´çŠ¶æ€å¯å‹ç¼©ã€‚æ³¨æ„ï¼Œæ¯æ¬¡dpæ•°ç»„ååˆå§‹åŒ–é—®é¢˜ã€‚ å½“ç„¶è¿™é‡Œä¹Ÿå¯ä»¥çœ‹æˆçŸ©é˜µä¹˜æ³•ã€‚ å®˜ç½‘çš„å¦ä¸€ä¸­è§£æ³•æ¶‰åŠåˆ°çº¿æ€§é€’æ¨å¼çš„ä¼˜åŒ–ã€‚ ä»£ç ï¼šclass Solution { public: int numOfWays(int n) { int cmap[13][13] ={0}; int posidx = 1; map&lt;int, int&gt; pos; for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ for(int k = 0; k &lt; 3; k++){ if(i == j || j == k) continue; int countR = i * 100 + j * 10 + k; if(pos[countR] == 0) pos[countR] = posidx++; for(int s = 0; s &lt; 3; s++){ for(int t = 0; t &lt; 3; t++){ for(int q = 0; q &lt; 3; q++){ if(s == t || t == q) continue; int countC = s * 100 + t * 10 + q; if(pos[countC] == 0) pos[countC] = posidx++; if(i == s || j == t || k == q) continue; cmap[pos[countR] - 1][pos[countC] - 1] = 1; } } } } } } cout &lt;&lt; posidx &lt;&lt; endl; // for(int i = 0; i &lt; 12; i++) { // for(int j = 0; j &lt; 12; j++) // cout &lt;&lt; cmap[i][j] &lt;&lt; ' '; // cout &lt;&lt; endl; // } long long dp[2][12] = {0}; long long MOD = 1e9 + 7; for(int i = 0; i &lt; 12; i++) dp[0][i] = 1; for(int i = 1; i &lt; n; i++){ int newr = i &amp; 1; int lastr = (i - 1) &amp; 1; for(int j = 0; j &lt; 12; j++){ dp[newr][j] = 0; for(int k = 0; k &lt; 12; k++) if(cmap[j][k] == 1){ dp[newr][j] = (dp[newr][j] + dp[lastr][k]) % MOD; } } // for(int t = 0; t &lt; 12; t++) // cout &lt;&lt; dp[newr][t] &lt;&lt; ' '; // cout &lt;&lt; endl; } long long sum = 0; int newr = (n - 1) &amp; 1; for(int i = 0; i &lt; 12; i++){ sum = (sum + dp[newr][i]) % MOD; } return sum; } };","link":"/2020/09/27/shua-ti/dp/1411-number-of-ways-to-paint-n-x-3-grid/"},{"title":"188. Best Time to Buy and Sell Stock IV","text":"188. Best Time to Buy and Sell Stock IVæ€è·¯ï¼šæŠŠtransactionæ‹†åˆ†ä¸ºä¹°buyå’Œå–sellï¼Œsell[i][j]ä»£è¡¨å¯¹äºç¬¬iä¸ªç‰©å“ï¼Œç¬¬jæ¬¡å–æ“ä½œåæœ€å¤§åˆ©æ¶¦ã€‚buyå’Œsellçš„è½¬ç§»æ–¹ç¨‹å¦‚ä»£ç æ‰€ç¤ºã€‚ å½¢å¼ä¸Šæ›´åƒä¸€ä¸ªçŠ¶æ€è½¬ç§»æœºã€‚ ä»£ç ï¼šclass Solution { public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { int d = prices.size(); if(d &lt; 2) return 0; k = min(k, d);// è¶…è¿‡nçš„kæ˜¯æ²¡æœ‰æ„ä¹‰çš„ // buyä¸€å¼€å§‹å•¥åˆ©æ¶¦éƒ½æ²¡æœ‰åº”è¯¥ä¸º0ï¼Œä½†æ˜¯ç”±äºè´­ä¹°ååˆ©æ¶¦å¯èƒ½ä¼šä¸ºè´Ÿæ•°ï¼Œæ‰€ä»¥å¿…é¡»åˆå§‹åŒ–ä¸º-INF vector&lt;int&gt; buy(k + 1, INT_MIN), sell(k + 1, 0); for(int i = 0;i &lt; d; ++i){ for(int j = 1; j &lt;= k; ++j){ buy[j] = max(buy[j], sell[j - 1] - prices[i]); sell[j] = max(sell[j], buy[j] + prices[i]); } } return sell[k]; } }; å…¶ä¸­ä¸ä¼˜åŒ–ç©ºé—´çš„è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š for(int i = 0;i &lt; d; ++i){ for(int j = 1; j &lt;= k; ++j){ buy[i][j] = max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]); sell[i][j] = max(sell[i - 1][j], buy[i - 1][j] + prices[i]); } }","link":"/2020/12/25/shua-ti/dp/188-best-time-to-buy-and-sell-stock-iv/"},{"title":"198. House Robber","text":"198. House Robberæ€è·¯ï¼š å°†å·å’Œä¸å·çš„ä¸¤ç§çŠ¶æ€åˆ†åˆ«è®°å½•åˆ°ä¸¤ä¸ªdpä¸Šï¼Œdpæ–¹ç¨‹è§ä»£ç 1 å¦‚æœä¸åˆ†è§£ï¼Œè®°$dp[i]$ä¸ºåœ¨æˆ¿å­$i$æ‰€èƒ½è·å¾—æœ€å¤§çš„é‡‘é’±æ”¶ç›Šï¼Œåº”è¯¥å¯ä»¥æ¯”è¾ƒå·çªƒç¬¬$i$æˆ¿å­åŠ ä¸Šä¹‹å‰$i-2$ä¸ªæˆ¿å­æ‰€èƒ½å·çªƒçš„æœ€å¤§é‡‘é¢ï¼Œå’Œåªå·çªƒå‰$i-1$æˆ¿å­çš„æœ€å¤§é‡‘é¢ã€‚ ä»£ç ï¼šä»£ç 1 class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; dp1(n, 0); vector&lt;int&gt; dp0(n, 0); dp0[0] = 0; dp1[0] = nums[0]; for(int i = 1; i &lt; n; ++i){ dp0[i] = max(dp0[i - 1], dp1[i - 1]); dp1[i] = dp0[i - 1] + nums[i]; } return max(dp1[n - 1], dp0[n - 1]); } }; dp2 100% class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; else if(n == 1) return nums[0]; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for(int i = 2; i &lt; n; ++i){ dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); } return dp[n - 1]; } };","link":"/2020/12/07/shua-ti/dp/198-house-robber/"},{"title":"213. House Robber II","text":"213. House Robber IIæ€è·¯ï¼šé¦–å’Œå°¾çš„æ•°å­—å…ƒç´ ä¸èƒ½åŒæ—¶é€‰æ‹©çš„ã€‚é‚£ä¹ˆç›´æ¥æŠŠåˆ—è¡¨æ‹†åˆ†æˆä¸¤ä¸ª$[0,â€¦., n - 2]$å’Œ$[1,â€¦..,n-1]$ï¼Œåˆ†å¼€DPå°±è¡Œäº†ã€‚ ä½¿ç”¨$dp[i]$è¡¨ç¤ºæ•°ç»„åœ¨å…ƒç´ $i$ä¸Šæ‰€èƒ½è·å¾—çš„æœ€å¤§é‡‘é’±ã€‚ å½“ç„¶ä¹Ÿå¯è¿›è¡ŒåŠ¨ä½œæ‹†åˆ†ã€‚ ä»£ç ï¼šclass Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; else if(n &lt;= 1) return nums[0]; return max(getdp(nums, 0, n - 1), getdp(nums, 1, n)); } int getdp(vector&lt;int&gt; nums, int s, int e){ if(s &gt;= e) return 0; if(s + 2 &lt;= e) //åˆå§‹åŒ– nums[s + 1] = max(nums[s], nums[s + 1]); for(int i = s + 2; i &lt; e; ++i){ nums[i] = max(nums[i - 2] + nums[i], nums[i - 1]); } return nums[e - 1]; } };","link":"/2020/12/28/shua-ti/dp/213-house-robber-ii/"},{"title":"221. Maximal Square","text":"221. Maximal Squareæ€è·¯ï¼š$dp[i][j]$ä¸ºæ­£æ–¹å½¢çš„å³ä¸‹è§’ã€‚æ ¹æ®è¡Œåˆ—æ‰©å±•æˆ–è€…ä¸‰ä¸ªæ­£æ–¹å½¢å¯ä»¥è¿›è¡Œdpã€‚ ä»£ç ï¼šæ€è€ƒä¸æˆç†Ÿçš„ä»£ç  15% class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int n = matrix.size(); if(n == 0) return 0; int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; row(n, vector&lt;int&gt;(m, 0)); vector&lt;vector&lt;int&gt;&gt; col(n, vector&lt;int&gt;(m, 0)); vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0)); int maxarea = 0; for(int i = 0;i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == '1'){ row[i][j] = (i == 0) ? 1 : row[i - 1][j] + 1; col[i][j] = (j == 0) ? 1 : col[i][j - 1] + 1; int minsqu; if(i == 0 || j == 0 ) minsqu = 0; else minsqu = squ[i - 1][j - 1]; int maxl = min(col[i][j], min(row[i][j], minsqu + 1)); squ[i][j] = maxl; maxarea = max(maxarea, maxl * maxl); }else{ row[i][j] = col[i][j] = squ[i][j] = 0; } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl; } } return maxarea; } }; çœŸæ»´æ‡’ï¼Œå†æ‡’ä¸èƒ½æ‡’è„‘åŠ›ã€‚ 24% class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int n = matrix.size(); if(n == 0) return 0; int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0)); int maxarea = 1; for(int i = 0;i &lt; n; ++i){ if(matrix[i][0] == '1') squ[i][0] = 1; if(matrix[0][i] == '1') squ[0][i] = 1; } for(int i = 1;i &lt; n; ++i){ for(int j = 1; j &lt; m; ++j){ if(matrix[i][j] == '1'){ int maxl = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1; squ[i][j] = maxl; maxarea = max(maxarea, maxl * maxl); }else{ squ[i][j] = 0; } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; squ[i][j] &lt;&lt; endl; } } return maxarea; } }; ä¼˜åŒ–æ—¶é—´ 98% class Solution { public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { if(matrix.empty()) return 0; int n = matrix.size(); int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; squ(n, vector&lt;int&gt;(m, 0)); int maxl = 0; for(int i = 0;i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == '1'){ if(i &gt; 0 &amp;&amp; j &gt; 0){ squ[i][j] = min(squ[i - 1][j - 1], min(squ[i - 1][j], squ[i][j - 1])) + 1; } else squ[i][j] = 1; if(squ[i][j] &gt; maxl ) maxl = squ[i][j]; } } } return maxl * maxl; } };","link":"/2020/12/09/shua-ti/dp/221-maximal-square/"},{"title":"279. Perfect Squares","text":"279. Perfect Squaresæ€è·¯ï¼š dpã€‚å‡æ‘Šå¤æ‚åº¦æ¯”è¾ƒä½ è´ªå¿ƒç®—æ³•ï¼Œè´ª bfs+è´ªå¿ƒ ä»£ç ï¼šdp 66% class Solution { public: int numSquares(int n) { vector&lt;long long&gt; dp(n + 1, INT_MAX); dp[0] = 0; for(long long i = 1; i &lt;= n; ++i){ for(long long j = 1; j * j &lt;= i; ++j){ long long t = i - j * j; dp[i] = min(dp[i], dp[t] + 1); } } return dp[n]; } }; è´ªå¿ƒæœç´¢ 70% class Solution { public: vector&lt;long long&gt; dp; //æ•°å­—å¹³æ–¹æœç´¢å€¼ int numSquares(int n) { dp.resize(sqrt(n) + 1); for(int i = 1; i &lt; dp.size(); ++i){ dp[i - 1] = i * i; } for(int i = 1; i &lt;= n; ++i){ if(getLevel(n, i)) return i; } return 0; } bool getLevel(int n, int ssize){// ssizeä¸ªå¹³æ–¹æ•°çš„å’Œæ˜¯å¦ç­‰äºn if(ssize == 1){ if(count(dp.begin(), dp.end(), n) &gt; 0) return true; return false; } for(int i = 0; i &lt; dp.size(); ++i){ if(getLevel(n - dp[i], ssize - 1)) return true; } return false; } }; bfsæœç´¢ 17%â€¦â€¦ unordered_setçš„çš„æŸè€—è¿˜æ˜¯å¤ªå¤§äº†å— class Solution { public: vector&lt;long long&gt; dp; int numSquares(int n) { dp.resize(sqrt(n) + 1); for(int i = 1; i &lt; dp.size() + 1; ++i){ dp[i - 1] = i * i; } int level = 1; unordered_set&lt;int&gt; que, next_que; //8%-&gt;17% que.insert(n); //å±‚åºéå†ï¼Œæ•´å±‚æ ‘ã€‚ while(1){ } return 0; } void search(unordered_set&lt;int&gt; que, unordered_set&lt;int&gt; next_que){ for(auto t : que){ for(int i = 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;= t ; ++i){ // cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl; if(dp[i] == t) return level; next_que.insert(t - dp[i]); } } level += 1; que = next_que; next_que.clear(); } }; å†ä¼˜åŒ–ä¸€ä¸‹28% class Solution { public: vector&lt;long long&gt; dp; int numSquares(int n) { dp.resize(sqrt(n) + 1); for(int i = 1; i &lt; dp.size() + 1; ++i){ dp[i - 1] = i * i; } int level = 1; unordered_set&lt;int&gt; que1, que2; //8%-&gt;17% que1.insert(n); //å±‚åºéå†ï¼Œæ•´å±‚æ ‘ã€‚ while(1){ if(level &amp; 1){ if(search(que1, que2)) return level; }else{ if(search(que2, que1)) return level; } level++; } return 0; } bool search(unordered_set&lt;int&gt; &amp;que, unordered_set&lt;int&gt; &amp;next_que){ for(auto t : que){ for(int i = 0; i &lt; dp.size() &amp;&amp; dp[i] &lt;= t ; ++i){ // cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl; if(dp[i] == t) return true; next_que.insert(t - dp[i]); } } que.clear(); return false; } };","link":"/2020/12/10/shua-ti/dp/279-perfect-squares/"},{"title":"300. Longest Increasing Subsequence","text":"300. Longest Increasing Subsequenceæ€è·¯ï¼š dpï¼Œå¤æ‚åº¦$O(n^2)$ã€‚ è´ªå¿ƒï¼Œç”¨$d[i]$ç»´æŠ¤é•¿åº¦ä¸ºiçš„å­ä¸²ç»“å°¾æ•°å­—çš„æœ€å°å€¼ã€‚åœ¨éå†çš„è¿‡ç¨‹ä¸­æ›´æ–°ï¼Œå¢é•¿d[i]ã€‚åŒæ—¶d[i]çš„å•è°ƒæ€§ï¼Œå¯è½»æ¾è¯æ˜ã€‚$o(nlogn)$ã€‚ å¦‚æœæ±‚è§£çš„ä¸æ˜¯strictly increasing subsequenceï¼Œåªéœ€è¦ç¨ç¨ä¿®æ”¹ä¸€ä¸‹å³å¯ã€‚ ä»£ç ï¼šdp class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; dp(n, 1); int maxl = 1; for(int i = 1; i &lt; n; i++){ for(int j = 0; j &lt; i; ++j){ if(nums[j] &lt; nums[i] &amp;&amp; dp[j] + 1 &gt; dp[i] ){ dp[i] = dp[j] + 1; maxl = max(dp[i], maxl); } } } return maxl; } }; è´ªå¿ƒ+äºŒåˆ† class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; d; int len = 0; for(int i = 0;i &lt; n; ++i){ if(len == 0 || d[len - 1] &lt; nums[i]){ d.push_back(nums[i]); len++; // cout &lt;&lt; len ; }else{ auto it = lower_bound(d.begin(), d.end(), nums[i]); if( *it &gt; nums[i]){ //æœç´¢ç¬¬ä¸€ä¸ªjï¼Œä½¿å¾—nums[j - 1] &lt; d[i] &lt; nums[j],åªéœ€è¦ä¸¤ä¸ªæ¡ä»¶lower_boundå’Œå¤§äºå·ç»„åˆå°±è¡Œï¼ *it = nums[i]; } } } return len; } };","link":"/2020/12/13/shua-ti/dp/300-longest-increasing-subsequence/"},{"title":"309. Best Time to Buy and Sell Stock with Cooldown","text":"309. Best Time to Buy and Sell Stock with Cooldownæ€è·¯ï¼šæ— é™è´­ä¹°ï¼Œæ¯ä¸ªpriceséƒ½å¯ä»¥è®¾ç½®ä¸ºä¸€ä¸ªè´­ä¹°ç‚¹ã€‚æŠŠçŠ¶æ€æŒ‰ç…§å·²ç»è´­ä¹°çŠ¶æ€$f[i][0]$ã€å¤„äºå†·å†»çŠ¶æ€çš„åˆšå–å‡º$f[i][1]$å’Œä¸å¤„äºå†·å†»æœŸçš„å–å‡ºçŠ¶æ€$f[i][2]$ï¼Œåˆ†æˆä¸‰ä¸ªéƒ¨åˆ†ï¼Œå¯ä»¥å†™å‡ºdpè½¬ç§»æ–¹ç¨‹ï¼š$$\\begin{split}f[i][0] &amp;= max(f[i - 1][0], f[i - 1][2] - prices[i]) \\\\f[i][1] &amp;= f[i - 1][0] + prices[i]\\\\f[i][2] &amp;= max(f[i - 1][1], f[i - 1][2]) \\\\end{split}$$åˆå§‹åŒ–$f[0][0]= -prices[0]$ï¼Œæœ€åå–ç»“æœ$max(f[n-1])[1], f[n-1][2])$ã€‚ DPçŠ¶æ€æ–¹ç¨‹å·§å¦™åœ¨æŠŠä¸€ä¸ªçŠ¶æ€æ‹†åˆ†æˆä¸åŒçš„å¹¶è¡ŒçŠ¶æ€ï¼ŒåŒæ—¶åœ¨ä¸åŒçŠ¶æ€å¯ä»¥ç›¸äº’è½¬ç§»ï¼Œè‡ªç„¶çš„æ·»åŠ äº†ä¸€æ¬¡è´­ä¹°ï¼Œä¸€æ¬¡å–å‡ºï¼Œä¸€æ¬¡ç­‰å¾…çš„é™åˆ¶ã€‚ ä»£ç ï¼šclass Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int d = prices.size(); if(d &lt;= 1) return 0; vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(3)); dp[0][0] = -prices[0]; for(int i = 1; i &lt; d; ++i){ dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]); dp[i][1] = dp[i - 1][0] + prices[i]; dp[i][2] = max(dp[i - 1][2], dp[i - 1][1]); } return max(dp[d - 1][1], dp[d - 1][2]); } };","link":"/2020/12/26/shua-ti/dp/309-best-time-to-buy-and-sell-stock-with-cooldown/"},{"title":"312. Burst Balloons","text":"312. Burst Balloonsæ€è·¯ï¼š Hardé¢˜åšäº†æ‰æœ‰æ”¶è·å•Šï¼lcä¸Šé¢˜åº“é‡Œå‡ é“ç»å…¸çš„å…·æœ‰é”»ç‚¼æ€ç»´å’Œæ€è€ƒèƒ½åŠ›çš„é¢˜ã€‚ æ‹¿åˆ°æ‰‹ï¼Œé¦–å…ˆæ˜ å…¥è„‘æµ·é‡Œæ˜æ˜¾åº”è¯¥æ˜¯è´ªå¿ƒæˆ–è€…åˆ†æ²»ç®—æ³•ï¼šä»”ç»†æ€è€ƒä¸€ä¸‹ï¼Œè´ªå¿ƒå‘ç°æ²¡æœ‰ä¾æ®ï¼Œä¹Ÿæ²¡æœ‰ä¾‹å­ï¼›åˆ†æ²»ç®—æ³•æŠŠè€ƒè™‘æŠŠæ±‚å–é—®é¢˜dp(l, r)â€”â€”å¼€åŒºé—´çš„(l,r)ä¸€ç»„æ°”çƒå…¨éƒ¨æˆ³çˆ†ä»¥åï¼Œå¯ä»¥è·å–æœ€å¤§é‡‘å¸æ•°é‡ã€‚å¦‚æœç¬¬ä¸€é€‰å–kä¸ªæ°”çƒæˆ³çˆ†ï¼Œåˆ™æœ‰å­é—®é¢˜(l,k)å’Œ(k,r)ï¼Œä½†æ˜¯å¯ä»¥å‘ç°ä¸¤ä¸ªå­é—®é¢˜æ˜¯ç›¸äº’ä¾èµ–çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªé—®é¢˜è§£çš„é€‰æ‹©ä¼šå½±å“å¦ä¸€ä¸ªé—®é¢˜çš„è§£çš„é€‰æ‹©ã€‚æ‰€ä»¥è¿™ä¸ªæ€è·¯ä¹Ÿä¸è¡Œã€‚ Amazingçš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥åè¿‡æ¥è€ƒè™‘é—®é¢˜ï¼æˆ‘ä»¬æŠŠæ•´ä¸ªè¿‡ç¨‹é€†åºï¼ŒæŠŠæˆ³çˆ†å­˜åœ¨çš„æ°”çƒï¼Œå˜æˆä»ä¸€ä¸ªæ°”çƒéƒ½ä¸å­˜åœ¨ï¼Œæ·»åŠ ä¸€ä¸ªä¸ªä¸å­˜åœ¨çš„æ°”çƒã€‚dp(l, r)é—®é¢˜å°±æ˜¯åœ¨å¯»æ‰¾ï¼ŒæŠŠ(l, r)ä¸­çš„æ‰€æœ‰ä½ç½®å¡«æ»¡æ°”çƒï¼Œå¯ä»¥è·å¾—æœ€å¤§é‡‘å¸æ•°é‡ã€‚æ€è€ƒä¸€ä¸‹å¦‚ä½•åˆ†è§£ä¸ºå­é—®é¢˜ï¼š$$dp(l, r) = max_{i = l + 1}^{r - 1}[dp(l , i) + dp(i, r) + nums[i] * nums[l] * nums[r]]$$å…·ä½“è®¡ç®—å¯ä»¥ç”¨è®°å¿†åŒ–æœç´¢å’ŒDPè®¡ç®—ã€‚ çœ‹äº†ä¸‹å¤§ç¥çš„è§£æ³•ï¼Œå±…ç„¶è¿˜æœ‰ç”¨å¯å‘å¼æœç´¢çš„ï¼å¤ªé¡¶äº†ï¼ ä»£ç ï¼šè®°å¿†åŒ–æœç´¢ï¼ˆè‡ªé¡¶å‘ä¸‹æœç´¢ï¼‰ï¼š class Solution { vector&lt;vector&lt;int&gt;&gt; dp; int n = 0; public: int maxCoins(vector&lt;int&gt;&amp; nums) { nums.insert(nums.begin(), 1); nums.push_back(1); n = nums.size(); dp.resize(n, vector&lt;int&gt;(n)); search(nums, 0, n - 1); return dp[0][n - 1]; } int search(vector&lt;int&gt;&amp;nums, int l, int r){ // find max coins in search scope (left, right). if(dp[l][r]) return dp[l][r]; int maxCoins = 0; for(int i = l + 1; i &lt; r; ++i){ int amount = search(nums, l, i) + search(nums, i, r) + nums[l] * nums[r] * nums[i]; maxCoins = max(maxCoins, amount); } return dp[l][r] = maxCoins; } }; DPè®¡ç®—ï¼ˆè‡ªåº•å‘ä¸Šæœç´¢ï¼‰ï¼š class Solution { vector&lt;vector&lt;int&gt;&gt; dp; int n = 0; public: int maxCoins(vector&lt;int&gt;&amp; nums) { nums.insert(nums.begin(), 1); nums.push_back(1); n = nums.size(); dp.resize(n, vector&lt;int&gt;(n)); // find max coins in search scope (left, right). // for(int len = 1; len &lt; n - 1; ++len){ // for(int i = 0; i + len + 1 &lt; n; ++i){ // int j = i + len + 1; // for(int k = i + 1; k &lt; j; ++k){ // dp[i][j] = max(dp[i][j], // dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]); // } // } // } // æ›´Cacheä¸€ç‚¹çš„å†™æ³•åº”è¯¥æ˜¯ for(int j = 2; j &lt; n; ++j){ for(int i = j - 2; i &gt;= 0; --i){ for(int k = j - 1; k &gt; i; --k){ //ä»jå‡ºå‘æ›´å¿«~ // for(int k = i + 1; k &lt; j; ++k){ dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]); } } } return dp[0][n - 1]; } }; è€ƒè™‘ä¸‹cacheä¼˜åŒ–è®¡ç®—è¿‡ç¨‹","link":"/2021/05/05/shua-ti/dp/312-burst-balloons/"},{"title":"322. Coin Change","text":"322. Coin Changeæ€è·¯ï¼šå®Œå…¨èƒŒåŒ…æ€è·¯ï¼Œæ³¨æ„ä¸€ä¸‹åˆå§‹å€¼ã€‚ ä»£ç ï¼šclass Solution { public: const int INF = INT_MAX / 2; int coinChange(vector&lt;int&gt;&amp; coins, int amount) { vector&lt;int&gt; dp(amount + 1, INF); // ç®€åŒ– åˆå§‹åŒ–ä¸º-1 ä¸å¥½åˆ©ç”¨min è¿‡æ»¤;ä½¿ç”¨æ¡ä»¶ ä¼˜åŒ–æ–¹å‘(dp[i]--)ä»åˆå§‹æ¡ä»¶ï¼ˆdp[i] = INFï¼‰å¼€å§‹ï¼Œ // ä¹Ÿè®¸æ›´å¥½çš„åˆå§‹å€¼æ˜¯ amount + 2; dp[0] = 0; for(auto v : coins){ for(int i = v; i &lt;= amount; ++i){ dp[i] = min(dp[i], dp[i - v] + 1); } } return dp[amount] == INF ? -1 : dp[amount]; } };","link":"/2020/12/18/shua-ti/dp/322-coin-change/"},{"title":"337. House Robber III","text":"337. House Robber IIIæ€è·¯ï¼šè¿™é‡Œçš„dpæ¨é”™äº†ï¼Œå°´å°¬å•Šã€‚ ä¸€ä¸ªç®€å•çš„æ ‘ä¸ŠDP ä»£ç ï¼š/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { using tii = tuple&lt;int, int&gt;; public: int rob(TreeNode* root) { tii res = stelan(root); return max(get&lt;0&gt;(res), get&lt;1&gt;(res)); } tii stelan(TreeNode* root){ if(!root) return make_tuple(0, 0); tii left = stelan(root-&gt;left); tii right = stelan(root-&gt;right); // dp æ¨å¯¼å¼ï¼š // dp[i][0] = max(dp[i * 2][1], dp[i * 2][0]) + max(dp[i * 2 + 1][1], dp[i * 2 + 1][0]) // dp[i][1] = val[i] + dp[i * 2][0] + dp[i * 2 + 1][0]; return make_tuple(max(get&lt;0&gt;(left), get&lt;1&gt;(left)) + max(get&lt;0&gt;(right), get&lt;1&gt;(right)), get&lt;0&gt;(left) + get&lt;0&gt;(right) + root-&gt;val); } };","link":"/2021/04/30/shua-ti/dp/337-house-robber-iii/"},{"title":"343. Integer Break","text":"343. Integer Breakæ€è·¯ï¼š dpåˆ†è§£ä¸ºä¸¤ä¸ªå’Œä¸ºnæ•°å­—ï¼Œæ±‚å‡ºæœ€å¤§ç§¯å³å¯ã€‚ æ•°å­¦æ–¹æ³•é¢˜è§£ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; dp; int getmaxdp(int k){ if(dp[k]) return dp[k]; int maxp = 0; for(int i = 1;i &lt;= k / 2 ; i++){ maxp = max(maxp, max(i, getmaxdp(i)) * max(k - i, getmaxdp(k - i))); } dp[k] = maxp; return maxp; } int integerBreak(int n) { dp.resize(60); dp[1] = 1; dp[2] = 1; return getmaxdp(n); } }; æ›´ç®€æ´çš„æ‹†åˆ†æ–¹æ³• class Solution { public: vector&lt;int&gt; dp; int getmaxdp(int k){ if(dp[k]) return dp[k]; int maxp = 0; for(int i = 1;i &lt; k ; i++){ maxp = max(maxp, max(i * (k - i), i * getmaxdp(k - i))); // æ‹†å‡ºä¸€ä¸ªæ•´æ•°ä½œä¸ºå› å­ } dp[k] = maxp; return maxp; } int integerBreak(int n) { dp.resize(60); dp[1] = 1; dp[2] = 1; return getmaxdp(n); } }; æ­£å‘dp class Solution { public: int integerBreak(int n) { vector&lt;int&gt; dp(60); dp[1] = 1; dp[2] = 1; for(int i = 3; i &lt;= n; ++i){ int cur = 1; for(int j = 1; j &lt; i; ++j){ cur = max(cur, max(j * (i - j), j * dp[i - j])); } dp[i] = cur; } return dp[n]; } }; æ•°å­¦æ–¹æ³• class Solution { public: int integerBreak(int n) { if(n &lt; 4) return n - 1; // 2:1, 3:2 int res = 1; while(n &gt; 4){ // å°½é‡å–3ä¸ºåˆ†è§£å› å­ res *= 3; n -= 3; } if(n == 4) res *= 4; // n % 3 == 1, å–ä¸€ä¸ª4ä½œä¸ºåˆ†è§£å› å­ else res *= n; return res; } };","link":"/2020/12/29/shua-ti/dp/343-integer-break/"},{"title":"376. Wiggle Subsequence","text":"376. Wiggle Subsequenceæ€è·¯ï¼šæ³¨æ„è¾¹ç•Œï¼Œæ°”æ­»äººã€‚ åˆ†æé—®é¢˜ä¸å¤Ÿä»”ç»†é€å½»ã€‚ ä»£ç ï¼š class Solution { public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; up(n), down(n); up[0] = down[0] = 1; for(int i = 1; i &lt; n; ++i){ if(nums[i] &gt; nums[i - 1]) up[i] = max(down[i - 1] + 1, up[i - 1]); else up[i] = up[i - 1]; if(nums[i] &lt; nums[i - 1]) down[i] = max(up[i - 1] + 1, down[i - 1]); else down[i] = down[i - 1]; } return max(up[n - 1], down[n - 1]); } }; è¿™é“é¢˜ä¹Ÿå¯ä»¥ç”¨è´ªå¿ƒå»åšã€‚å–å‡ºæœ€å¤§æ³¢è°·å˜åŒ–å°±å¯~","link":"/2020/12/31/shua-ti/dp/376-wiggle-subsequence/"},{"title":"413. Arithmetic Slices 2åˆ·","text":"413. Arithmetic Slicesæ€è·¯ï¼š dp[i]ä»¥æ•°å­—ithä¸ºç»“å°¾çš„æœ€é•¿arithmetic sequenceçš„é•¿åº¦ï¼Œï¼ˆè¢«åŒ…å«çš„dp[k]==0ï¼‰ $dp[i]$ä»¥æ•°å­—i thä¸ºç»“å°¾çš„arithmetic sequenceçš„æ•°ç›®ä¸ªæ•°ã€‚ ä»£ç ï¼šclass Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { int n = A.size(); vector&lt;int&gt; dp(n, 0); if(n &lt; 2) return 0; for(int i = 2; i &lt; n; ++i){ if(A[i - 1] - A[i - 2] == A[i] - A[i - 1]){ dp[i] = dp[i - 1] + 1; dp[i - 1] = 0; }// } int res = 0; for(int i = 2; i &lt; n; ++i){ if(dp[i]){ res += (dp[i] + 1) * dp[i] / 2; } } return res; } }; ä¹Ÿå¯ä»¥ç›´æ¥åŠ  class Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { // vector&lt;int&gt; dp(A.size(), 0); int sum = 0, lsum = 0; for(int i = 2; i &lt; A.size(); i++){ if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){ lsum++;//é•¿åº¦ä¸º3ï¼Œ4ï¼Œâ€¦â€¦ï¼Œlsumçš„ä»¥A[i]ä¸ºç»“å°¾çš„arithmetic sequence sum += lsum; }else lsum = 0; // } return sum; } };","link":"/2020/12/07/shua-ti/dp/413-arithmetic-slices-2-shua/"},{"title":"413. Arithmetic Slices","text":"413. Arithmetic Slicesé¢˜ç›®ç®€å•ï¼Œå€’æ˜¯é‡åˆ°ä¸€ä¸ªbugï¼šnewä¸€ä¸ªsize==0çš„æ•°ç»„ä¼šè¶Šç•Œé”™è¯¯ã€‚ ez æ€è·¯ï¼šdp[i]è¡¨ç¤ºä»¥iä¸ºç»ˆç‚¹çš„arthmetic arrayçš„æ•°é‡ã€‚ ä»£ç ï¼šclass Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { int *dp = new int[0]; int sum = 0; memset(dp, 0, sizeof(dp)); for(int i = 2; i &lt; A.size(); i++){ if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){ dp[i] = dp[i - 1] + 1; sum += dp[i]; } } return sum; } }; // 3: 1 // 4: 2 + 1 = 3 // 5: 3 + 2 + 1 =6; ä¼˜åŒ–ç©ºé—´ã€‚ class Solution { public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { // vector&lt;int&gt; dp(A.size(), 0); int sum = 0, lsum = 0; for(int i = 2; i &lt; A.size(); i++){ if(A[i] - A[i - 1] == A[i - 1] - A[i - 2]){ lsum++; sum += lsum; }else lsum = 0; // } return sum; } }; // 3: 1 // 4: 2 + 1 = 3 // 5: 3 + 2 + 1 =6;","link":"/2020/09/28/shua-ti/dp/413-arithmetic-slices/"},{"title":"416. Partition Equal Subset Sum","text":"416. Partition Equal Subset Sumæ€è·¯ç±»ä¼¼01èƒŒåŒ…çš„é¢˜ï¼Œä¸è¿‡ä¸ç”¨è€ƒè™‘ä»·å€¼ã€‚ ä»£ç  class Solution { public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum % 2) return false; int n = nums.size(); int target = sum / 2; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(target + 1, 0)); for(int i = 0; i &lt;= n; ++i){ dp[i][0] = 1; } for(int i = 1; i &lt;= n; ++i){ for(int j = nums[i - 1]; j &lt;= target; ++j){ dp[i][j] = dp[i - 1][j - nums[i - 1]] || dp[i - 1][j]; } } return dp[n][target]; } }; ç©ºé—´å‹ç¼© class Solution { public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum % 2) return false; int n = nums.size(); int target = sum / 2; vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; for(int i = 1; i &lt;= n; ++i){ for(int j = target; j &gt;= nums[i - 1]; --j){//é€†åº dp[j] = dp[j - nums[i - 1]] || dp[j]; } } return dp[target]; } };","link":"/2020/12/16/shua-ti/dp/416-partition-equal-subset-sum/"},{"title":"474. Ones and Zeroes","text":"474. Ones and Zeroesæ€è·¯ï¼šç±»ä¼¼äº01èƒŒåŒ…ï¼Œä½†æ˜¯ä¸åŒ çš„æ˜¯æœ‰ä¸¤ä¸ªèŒƒå›´é™åˆ¶ã€‚å±äºäºŒç»´dp. ä»£ç ï¼šclass Solution { public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for(auto str : strs){ auto [c1, c2] = count(str); for(int i = m; i &gt;= c1; i--){ for(int j = n; j &gt;= c2; j--){ dp[i][j] = max(dp[i][j], dp[i - c1][j - c2] + 1); } } } return dp[m][n]; } pair&lt;int, int&gt; count(string str){ int c1 = 0, c2 = 0; for(auto c : str){ if(c == '0') c1++; else c2++; } return make_pair(c1, c2); } };","link":"/2020/12/18/shua-ti/dp/474-ones-and-zeroes/"},{"title":"494. Target Sum","text":"494. Target Sumæ€è·¯ï¼š ä»£ç ï¼šclass Solution { public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) { const int T = 2001; if(nums.size() == 0) return 0; int sum = 0; for(auto v : nums) sum += abs(v); if(sum &lt; abs(S)) return 0; int dp[23][T * 2]; //bugs: 20; memset(dp, 0, sizeof(dp)); dp[0][T] = 1; for(int i = 0; i &lt; nums.size(); ++i){ for(int j = 0; j &lt; T * 2; ++j){ if(dp[i][j]){ dp[i + 1][j + nums[i]] += dp[i][j]; dp[i + 1][j - nums[i]] += dp[i][j]; // cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; j + nums[i] &lt;&lt; &quot; &quot; &lt;&lt; dp[i + 1][j + nums[i]] &lt;&lt; endl; // cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; j - nums[i] &lt;&lt; &quot; &quot; &lt;&lt; dp[i + 1][j - nums[i]] &lt;&lt; endl; } } // cout &lt;&lt; &quot;#&quot; &lt;&lt; i &lt;&lt;endl; } return dp[nums.size()][S + T]; } };","link":"/2020/12/31/shua-ti/dp/494-target-sum/"},{"title":"53. Maximum Subarray","text":"53. Maximum Subarrayæ€è·¯ï¼š dp çº¿æ®µæ ‘åŒºé—´æŸ¥è¯¢ ä»¥ä¸‹çš„é¢˜è§£ï¼Œæ‘˜å½•è‡ªLeetCodeï¼š ä¸Šé¢çš„æ—¶é—´æ¸è¿›ä¸Šç•Œå¤§æ¦‚æ˜¯$o(2N)$ã€‚ ä»£ç ï¼šclass Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n &lt;= 0 ) return 0; int maxsum = nums[0]; int adds = 0; for(int i = 0;i &lt; n; ++i){ adds += nums[i]; maxsum = max(maxsum, adds); if(adds &lt; 0){ adds = 0; } } return maxsum; } }; çº¿æ®µæ ‘å¤šæ®µæŸ¥è¯¢ class Solution { public: struct sts{ int msum, isum, lsum, rsum; }; sts pushup(sts l, sts r){ sts a; a.msum = max(max(l.msum, r.msum), l.rsum + r.lsum); a.lsum = max(l.isum + r.lsum, l.lsum); a.rsum = max(r.isum + l.rsum, r.rsum); a.isum = l.isum + r.isum; return (sts){a.msum, a.isum, a.lsum, a.rsum}; } sts get(vector&lt;int&gt; &amp;nums, int l, int r){ if(r == l){ return (sts){nums[r], nums[r], nums[r], nums[r]}; } int m = (r + l) &gt;&gt; 1; sts a = get(nums, l, m); sts b = get(nums, m + 1, r); return pushup(a, b); } int maxSubArray(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; return get(nums, 0, nums.size() - 1).msum; } };","link":"/2020/12/28/shua-ti/dp/53-maximum-subarray/"},{"title":"542. 01 Matrix","text":"542. 01 Matrixæ€è·¯ï¼š ä»æ•°å­—0å¼€å§‹bfsåˆ°1çš„æœ€çŸ­è·¯ ç”±äºä»æ•°å­—1åˆ°æœ€è¿‘çš„æ•°å­—é›¶ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œå¦‚æœä¸æ˜¯ç›¸é‚»ï¼Œé‚£ä¹ˆå¿…å®šæœ‰åœ¨è·¯å¾„ä¸Šæ•°å­—1åˆ°åŒæ ·çš„æ•°å­—0æœ‰ä¸€æ¡æœ€çŸ­è·¯å¾„ã€‚å¦‚æ­¤ä¾¿å¯ä»¥åœ¨å››ä¸ªç§»åŠ¨æ–¹å‘ä¸Šåˆ†åˆ«dpæœ€çŸ­è·¯å¾„é•¿åº¦å³å¯ã€‚ ä»£ç ï¼šbfs 66% class Solution { public: int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dis(n, vector&lt;int&gt;(m , 0)); vector&lt;vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0)); queue&lt;pair&lt;int,int&gt;&gt; que; for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == 0){ que.push(make_pair(i ,j)); vis[i][j] = 1; } } } int qsize; while(que.size()){ qsize = que.size(); for(int i = 0; i &lt; qsize; ++i){ pair&lt;int,int&gt; t = que.front(); que.pop(); int x = t.first; int y = t.second; // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; for(int j = 0; j &lt; 4; ++j){ int nx = x + dx[j]; int ny = y + dy[j]; // cout &lt;&lt;&quot;@&quot; &lt;&lt; nx &lt;&lt; ny &lt;&lt; endl; if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m) continue; if(!vis[nx][ny]){ vis[nx][ny] = 1; // exclude the deplucation of elements in queue. dis[nx][ny] = dis[x][y] + 1; que.push(make_pair(nx, ny)); // cout &lt;&lt; nx &lt;&lt; ' ' &lt;&lt; ny &lt;&lt; ' ' &lt;&lt; dis[nx][ny] &lt;&lt; endl; } } } } return dis; } }; dp 97% class Solution { public: int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); int m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m , INT_MAX - 3)); //bugs: max value should be bigger than m and n. for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ if(matrix[i][j] == 0){ dp[i][j] = 0; continue; } if(i &gt; 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1); if(j &gt; 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1); } } for(int i = n - 1; i &gt;=0; --i){ for(int j = m - 1; j &gt;= 0; --j){ if(matrix[i][j] == 0) continue; if(i != n - 1) dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1); if(j != m - 1) dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1); } } return dp; } };","link":"/2020/12/08/shua-ti/dp/542-01-matrix/"},{"title":"583. Delete Operation for Two Strings","text":"583. Delete Operation for Two Stringsæ€è·¯ï¼šæ­¤é¢˜å¯ä»¥è½¬åŒ–ä¸ºæœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆLCSï¼‰ã€‚ç”¨åŠ¨æ€è§„åˆ’è§£å†³LCSå³å¯ã€‚ ä»£ç ï¼šclass Solution { public: int minDistance(string word1, string word2) { int n = word1.size(), m = word2.size(); // vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1)); //vectoråˆ†é…ç©ºé—´è€—æ—¶å¾ˆå¤§ï¼ŒåŒæ—¶å ç”¨çš„ç©ºé—´ä¹Ÿå¤§ int dp[n + 1][m + 1]; memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= m;- ++j){ if(word1[i - 1] == word2[j - 1]){ dp[i][j] = dp[i - 1][j - 1] + 1; }else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); } } return n + m - 2 * dp[n][m]; } }; è¿è¡Œæ•ˆç‡ï¼šleetcodeçš„è¿è¡Œæ—¶é—´çœŸæ˜¯çš„è¿·ï¼Œä¸è¿‡æ•°æ®é›†å¤ªå°äº†ï¼Œç¡®å®éš¾ä»¥å‡†ç¡®è¯„ä¼°ã€‚","link":"/2020/12/29/shua-ti/dp/583-delete-operation-for-two-strings/"},{"title":"594. Longest Harmonious Subsequence","text":"594. Longest Harmonious Subsequenceæ€è·¯ï¼šä¸€é“ç»å…¸çš„æœ€å¤§é€’å¢å­åºåˆ—çš„å˜å½¢é¢˜ ç»“æœç”¨DPæ€è·¯åšäº†åŠå¤©ï¼Œå‘ç°è¶Šåšå¤æ‚ï¼ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ æ€€ç–‘äººç”Ÿçš„åŒæ—¶å‘ç°è‡ªå·±çš„æ€è·¯è¿˜æ˜¯å¤ªçª„äº†ã€‚ ä»£ç ï¼šclass Solution { public: int findLHS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); unordered_map&lt;int, int&gt; ct; int maxl = 0; for(auto &amp; v : nums){ ct[v]++; int t = max(ct[v+1], + ct[v - 1]); if(t) maxl = max(t + ct[v], maxl); } return maxl; } };","link":"/2021/01/30/shua-ti/dp/594-longest-harmonious-subsequence/"},{"title":"64. Minimum Path Sum","text":"64. Minimum Path Sumæ€è·¯:dpé•¿åº¦ ä»£ç ï¼šclass Solution { public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); if(n == 0) return 0; int m = grid[0].size(); if(m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, 0)); dp[0][0] = grid[0][0]; for(int i = 1; i &lt; m; ++i){ dp[0][i] = dp[0][i - 1] + grid[0][i]; } for(int i = 1; i &lt; n; ++i){ dp[i][0] = dp[i - 1][0] + grid[i][0]; } for(int i = 1; i &lt; n; ++i){ for(int j = 1; j &lt; m; ++j){ dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]; } } return dp[n - 1][m - 1]; } };","link":"/2020/12/08/shua-ti/dp/64-minimum-path-sum/"},{"title":"650. 2 Keys Keyboard","text":"650. 2 Keys Keyboardæ€è·¯ï¼šdp[i] ä¸ºé•¿åº¦ä¸ºiçš„å­—ç¬¦ä¸²éœ€è¦çš„æœ€å°æ“ä½œæ•°ã€‚ åæ¨ æœ€å°è´¨æ•° ç´ æ•°åˆ†è§£ ä»£ç ï¼šè¿™ä¸ªç©ºé—´é€Ÿåº¦ class Solution { public: int minSteps(int n) { vector&lt;int&gt; dp( n + 1, INT_MAX); dp[1] = 0; for(int i = 1; i &lt; n; i++){ if(dp[i] != INT_MAX){ if(i + i &lt;= n){ for(int j = i * 2, k = 2; j &lt;=n; j += i, k++){ dp[j] = min(dp[i] + k, dp[j]); } } } } return dp[n]; } }; è¿™ç§æ€è·¯æœ‰ä¸€ç‚¹ï¼šä¸ºå•¥æœ€å°çš„jå°±ä¼šæ˜¯dp[i]æœ€å°å‘¢ï¼Ÿ class Solution { public: int minSteps(int n) { vector&lt;int&gt; dp( n + 1, INT_MAX); dp[1] = 0; int h = sqrt(n); for(int i = 2; i &lt;= n; i++){ dp[i] = i; for(int j = 2; j &lt;= h; j++){ if(i % j == 0){ dp[i] = dp[j] + dp[i / j]; break; } } } return dp[n]; } }; ç´ æ•°åˆ†è§£ class Solution { public: int minSteps(int n) { int factor = 2, ans = 0; while(n &gt; 1){ while(n % factor == 0 &amp;&amp; n &gt; 1){ n /= factor; ans += factor; //é€‰æ‹©ï¼ˆå¤åˆ¶ + ç²˜ç²˜ï¼‰çš„ä¸€ä¸ªå¤åˆæ“ä½œæ˜¯æœ€å¿«çš„ï¼Œæ‰€ä»¥ç”¨æœ€å°çš„ç´ æ•°æ­¥éª¤è¿›è¡Œä¸€æ¬¡æ“ä½œ //ä¹‹æ‰€ä»¥æ˜¯ç´ æ•°æ­¥éª¤ï¼Œ æ˜¯å› ä¸ºåˆæ•°éƒ½è¢«æ¯”ä»–å°çš„ç´ æ•°å› å­æ‰€åˆ†è§£äº† } factor++; } return ans; } };","link":"/2020/12/21/shua-ti/dp/650-2-keys-keyboard/"},{"title":"70. Climbing Stairs","text":"70. Climbing Stairsæ€è·¯ï¼šdpï¼Œç”¨ä¸¤ä¸ªå˜é‡å­˜å‚¨é•¿åº¦ä¸ºNçš„æ•°ç»„ä¼˜åŒ–ç©ºé—´ ã€‚ ä»£ç ï¼š class Solution { public: int climbStairs(int n) { int a = 1, b = 1, c = 2, k = 2; while(k &lt;= n){ c = a + b; a = b; b = c; k++; } if(n == 0) return 0; else if(n == 1) return 1; else return c; } };","link":"/2020/12/07/shua-ti/dp/70-climbing-stairs/"},{"title":"714. Best Time to Buy and Sell Stock with Transaction Fee","text":"714. Best Time to Buy and Sell Stock with Transaction Feeæ€è·¯ï¼šåšè¿‡äº†309é¢˜çš„è¯ï¼Œè¿™é¢˜å°±éå¸¸å®¹æ˜“è§£å†³ã€‚æ³¨æ„feeçš„è´¹ç”¨åœ¨äº¤æ˜“å®Œæˆåç»“ç®—ï¼Œä¸ç„¶å¯èƒ½æœ‰æ‰‹ç»­è´¹æ²¡æœ‰æ‰£å®Œçš„å°´å°¬æƒ…å†µã€‚ ä»£ç ï¼šç©ºé—´å¯ä¼˜åŒ– class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { int d = prices.size(); if(d &lt;= 1) return 0; vector&lt;vector&lt;int&gt;&gt; dp(d, vector&lt;int&gt;(2)); dp[0][0] = -prices[0]; for(int i = 1; i &lt; d; ++i){ dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = max(dp[i -1][1], dp[i][0] + prices[i] - fee); } return dp[d- 1][1]; } };","link":"/2020/12/26/shua-ti/dp/714-best-time-to-buy-and-sell-stock-with-transaction-fee/"},{"title":"72. Edit Distance","text":"72. Edit Distance æ€è·¯ï¼šdp[i][j]è¡¨ç¤ºå­ä¸²word[0â€¦â€¦i)å’Œå­ä¸²word[0â€¦â€¦j)éœ€è¦å˜åŒ–çš„æœ€å°æ¬¡æ•°ã€‚ éå¸¸å·§å¦™å•Šï¼Œå¾ˆå¿«å°±å¯ä»¥æ•²å‡ºä»£ç ï¼Œæ³¨æ„åˆå§‹åŒ–è¾¹ç¼˜å€¼ã€‚ ä»£ç ï¼šclass Solution { public: int minDistance(string word1, string word2) { int n = word1.size(); int m = word2.size(); // if(n == 0 || m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for(int i = 0; i &lt;=n; ++i){ for(int j = 0; j &lt;= m; ++j){ if(i == 0) dp[i][j] = j; else if(j == 0) dp[i][j] = i; else{ dp[i][j] = min(dp[i-1][j - 1] + (word1[i - 1] == word2[j - 1]? 0 : 1), min(dp[i - 1][j], dp[i][j - 1]) + 1); } } } return dp[n][m]; } };","link":"/2020/12/21/shua-ti/dp/72-edit-distance/"},{"title":"790. Domino and Tromino Tiling","text":"è¿™é¢˜çœŸçš„éœ€è¦å¾ˆå¤šè€ƒè™‘ æ€è·¯ï¼šDPå¯ä»¥è¿›è¡Œbit dpï¼Œè®¾ç½®dp[status]ä¸ºå½“å‰åˆ—ä¸ºçŠ¶æ€statusæ—¶çš„æ‹¼æ¥æ–¹æ³•ã€‚ status = 0b00 : ä¸Šä¸‹æ ¼å­éƒ½ä¸ºç©º status = 0b10 : ä¸Šæ ¼å­å¡«å¥½ï¼Œä¸‹æ ¼å­ä¸ºç©º status = 0b01 : ä¸‹æ ¼å­å¡«å¥½ï¼Œä¸Šæ ¼å­ä¸ºç©º status = 0b11 : ä¸Šä¸‹æ ¼å­éƒ½å¡«å¥½ æ‰€ä»¥å°±æ˜¯æœ‰ä»¥ä¸‹DPæ–¹ç¨‹è½¬ç§»æ–¹å¼ï¼š æ³¨æ„dp[0]=0ã€‚ æ‰¾è§„å¾‹å¦ä¸€ç§æ–¹æ³•ä¹Ÿæ˜¯æˆ‘ä¸€å¼€å§‹æƒ³çš„æ–¹æ³•ï¼Œä¸è¿‡æƒ³é”™äº†ï¼Œæ²¡æœ‰è€ƒè™‘æ‰˜ç±³è¯ºå’Œå¤šç±³è¯ºæ— é™å¢é•¿çš„å¯èƒ½æ€§ã€‚ğŸ˜‘ğŸ¤ å‚è€ƒä»¥ä¸ºå¤§ä½¬çš„åšæ–‡ ä»£ç ï¼šDPclass Solution { public: int numTilings(int N) { const int MOD = 1e9 + 7; // int[] dp= new int[]{1,0,0,0}; long *dp = new long[]{1, 0, 0, 0}; for(int i = 0; i &lt; N; ++i){ long *ndp = new long[4]; ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD; ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD; ndp[0b10] = (dp[0b01] + dp[0b00]) % MOD; ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) % MOD; delete []dp; dp = ndp; } return dp[0]; } }; å¦å¤–ä¸Šè¿°çº¿æ€§å˜æ¢å¯ä»¥æ›¿æ¢ä¸ºçŸ©é˜µä¹˜æ³•çš„å˜æ¢å½¢å¼ï¼Œä¸è¿‡å¤ªç¨€ç–äº†â€¦â€¦ æ‰¾è§„å¾‹ï¼š class Solution { public: int numTilings(int N) { const int MOD = 1e9 + 7; int sum0 = 1, sum1 = 1, sum2 = 2, sum3 = 5, sum; for(int i = 4; i &lt;= N; ++i){ sum = ((sum3 * 2) % MOD + sum1) % MOD; sum1 = sum2; sum2 = sum3; sum3 = sum; } if(N == 1) return 1; else if(N == 2) return 2; else if(N == 3) return 5; return sum; } };s","link":"/2020/10/07/shua-ti/dp/790-domino-and-tromino-tiling/"},{"title":"91. Decode Ways","text":"91. Decode Waysæ€è·¯ï¼š$dp[i]$è¡¨ç¤ºæ•°å­—å­—ç¬¦å­ä¸²$S[0â€¦i]$æ‰€èƒ½è¡¨ç¤ºçš„å­—ç¬¦ä¸²æ•°é‡ã€‚dpæ–¹ç¨‹è§ä»£ç ã€‚ æ³¨æ„ç‚¹ï¼š $0$æ— æ³•è¢«ç›´æ¥è¡¨ç¤ºï¼Œå› æ­¤dpæ–¹ç¨‹åˆ†æ”¯æ‰©å¤§äº†ä¸€å€ã€‚ ä¸ºäº†æ–¹ä¾¿åˆå§‹åŒ–ï¼Œå¯ä»¥æ·»åŠ å‰ç¼€é›¶ã€‚ ä»£ç ï¼š class Solution { public: int numDecodings(string s) { s = &quot;00&quot; + s; //æ·»åŠ å‰ç¼€ï¼Œæ–¹ä¾¿è®¾ç½®dpåˆå§‹å€¼ int n = s.size(); vector&lt;int&gt;dp(n, 0); if(n == 2 || s[2] == '0') return 0; dp[0] = dp[1] = 1; for(int i = 2; i &lt; n; ++i){ if(s[i - 1] == '1' || (s[i - 1] == '2' &amp;&amp; s[i] &lt; '7')){ if(s[i] == '0') dp[i] = dp[i - 2]; else dp[i] = dp[i - 2] + dp[i - 1]; } else if(s[i] == '0') dp[i] = 0; else dp[i] = dp[i - 1]; } return dp[n - 1]; } };","link":"/2020/12/11/shua-ti/dp/91-decode-ways/"},{"title":"96. Unique Binary Search Trees","text":"96. Unique Binary Search Treessæ€è·¯ï¼šç†è§£ï¼Œåªè¦æ•°å­—ä¸é‡å¤ï¼Œå­æ ‘çš„å½¢çŠ¶å¯èƒ½æ€§å°±ä¸æ•°å­—å…·ä½“å¤§å°æ— å…³ã€‚æ‰€ä»¥å¯ä»¥ç”¨DPç®—å‡ºé•¿åº¦ä¸ºKçš„å­æ ‘çš„å¯èƒ½å½¢çŠ¶ã€‚ ä»£ç ï¼š class Solution { int allmount = 0; vector&lt;int&gt; dp; public: int numTrees(int n) { dp.resize(n + 1); dp[1] = 1; dp[0] = 1; return findBST(1, n); } int findBST(int L, int R){ if(dp[R - L + 1]) return dp[R - L + 1]; // if(L &gt;= R){ // return 1; // } int nums = 0; for(int i = L; i &lt;= R; ++i){ nums += findBST(L, i - 1) * findBST(i + 1, R); } // cout &lt;&lt; L &lt;&lt; ' ' &lt;&lt; R &lt;&lt; ' ' &lt;&lt; nums &lt;&lt; endl; dp[R - L + 1] = nums; return nums; } };","link":"/2021/04/29/shua-ti/dp/96-unique-binary-search-trees/"},{"title":"P1025 æ•°çš„åˆ’åˆ†","text":"æ€è·¯ï¼šç§€çš„ä¸€æ‰¹çš„dpï¼šå¯ä»¥æŠŠé—®é¢˜åˆ†è§£ä¸¤ä½å­é—®é¢˜Q1(a), Q2(b)ï¼Œå…¶ä¸­a+b==1ã€‚ Q1(a): å°†aåˆ†è§£ä¸ºå«æœ‰1çš„åˆ†è§£æ–¹æ¡ˆã€‚å°†å…¶ä¸­çš„ä¸€ä¸ª1å»æ‰ï¼Œå¯è½¬åŒ–å…¶ä»–é—®é¢˜ã€‚ Q2(b): å°†aåˆ†è§£ä¸ºä¸å«æœ‰1çš„åˆ†è§£æ–¹æ¡ˆã€‚å°†æ¯ä¸ªæ•°éƒ½å‡å»1ï¼Œå¯è½¬åŒ–ä¸ºå…¶ä»–é—®é¢˜ã€‚ é‚£ä¹ˆæœ‰é‚£ä¹ˆdp(n,k)=dp(n-1,k-1)+dp(n-k,k)ã€‚ ä¿æŒè¾¹ç•Œdp[i][1] = 1, i&gt;=1 &amp;&amp; i&lt;=nã€‚ ä»£ç ï¼š #include&lt;bits/stdc++.h&gt; int n = 205, k = 21; int dp[205][20] ={0}; int main(){ // dp[0][0] = 1; for(int i = 0;i &lt; n; i++) dp[i][1] = 1; for(int i = 2 ; i &lt;= n; i++){ printf(&quot;%d &quot;, dp[i][1]); for(int j = 2; j &lt;= i&amp;&amp; j &lt; k; j++){ if(i &gt;= j) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j]; printf(&quot;%d &quot;, dp[i][j]); } printf(&quot;\\n&quot;); } while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) != EOF){ printf(&quot;%d\\n&quot;, dp[n][k]); } return 0; }","link":"/2020/10/18/shua-ti/dp/p1025-shu-de-hua-fen/"},{"title":"é¢è¯•é¢˜ 17.24. æœ€å¤§å­çŸ©é˜µ","text":"é¢è¯•é¢˜ 17.24. æœ€å¤§å­çŸ©é˜µæ€è·¯ï¼šæœ¬é¢˜æ˜¯æœ€å¤§è¿ç»­å­æ•°ç»„çš„äºŒç»´follow up. ä¸€ç»´æƒ…å†µä¸‹ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨å¤šç§ç®—æ³•æ±‚è§£ï¼š ç´¯åŠ æ•°ç»„+äºŒç»´æœç´¢å·¦å³è¾¹ç•Œï¼Œ $O(N^2)$ äºŒç»´æœç´¢å·¦å³è¾¹ç•ŒåŒæ—¶ç´¯åŠ æ•°å­—ï¼Œ$O(N^2)$ åˆ†æ²»ç®—æ³•ï¼ŒæŠŠé—®é¢˜maxarr(i, j)åˆ†è§£ä¸ºmaxarr(i, mid)å’Œmaxarr(mid + 1, j)ã€‚å…¶ä¸­å­æ•°ç»„å¯èƒ½åœ¨å·¦å³ä¸¤ç«¯æ•°ç»„ä¸­æˆ–è€…æ¨ªè·¨ä¸¤ä¸ªæ®µï¼Œæ‰€ä»¥ä»ä¸­é—´å‘ä¸¤è¾¹æœç´¢æœ€å¤§è¿ç»­æ•°ç»„å’ŒSum1ï¼Œå¦‚æ­¤è§£å†³äº†ä¸€ä¸ªåŸºæœ¬é—®é¢˜ï¼Œå¹¶ä¸”é€’å½’çš„å°†å°é—®é¢˜è§£å†³ï¼Œè·å–æ€»çš„é—®é¢˜çš„è§£ã€‚$O(NLogN)$ çº¿æ®µæ ‘åšæ³•ï¼ŒåŒæ ·ä¹Ÿæ˜¯åˆ†æ²»çš„æ€æƒ³ï¼Œä½†æ˜¯è€ƒè™‘çš„æ›´å¤šã€‚maxarr(i, j)åˆ†è§£ä¸ºmaxarr(i, mid)å’Œmaxarr(mid + 1, j)ã€‚åŸºæœ¬é—®é¢˜æ˜¯arr(i, j)ä¸­çš„sumlï¼Œsumr, sumiå’Œsummï¼Œåˆ†åˆ«ä»£è¡¨ä»å·¦è¾¹å¼€å§‹çš„å­æ•°ç»„çš„å’Œï¼Œä»å³è¾¹å¼€å§‹çš„å­æ•°ç»„çš„å’Œï¼Œåœ¨ä¸­é—´æ‰©å±•çš„å­æ•°ç»„çš„å’Œï¼Œå’Œæ•´ä¸ªæ•°ç»„çš„å’Œã€‚è€Œæˆ‘ä»¬è¦å¤§é—®é¢˜çš„sumiå°±æ˜¯æ‰€è¦æ±‚çš„å€¼ï¼Œå·§å¦™çš„åœ°æ–¹åœ¨äºé—®é¢˜çš„åˆ†è§£ï¼Œsumiå¯ä»¥å°±æ˜¯å­æ•°ç»„çš„sumiå’Œå·¦å­æ®µçš„sumrä¸å³å­æ®µçš„sumlä¹‹å’Œæœ€å¤§å€¼ã€‚å…¶ä»–åŒç†ã€‚ DPåšæ³•ï¼Œä»¥dp[i]ä¸ºarr[i]ä¸ºç»“å°¾çš„å’Œæœ€å¤§çš„è¿ç»­å­æ•°ç»„çš„å’Œã€‚çŠ¶æ€æ›´æ–°æ–¹ç¨‹ä¸º$$dp[i] = max(dp[i - 1] + arr[i], arr[i])$$ è¿™å¾ˆæœ‰è¶£ï¼Œå®é™…ä¸Šå°±æ˜¯èˆå¼ƒæ‰å¯èƒ½ä¸ºè´Ÿæ•°çš„dp[i - 1]ï¼Œ å¦å¤–åœ¨èˆå¼ƒæ—¶ä¹Ÿå¯ä»¥è®°å½•ä¸‹æ•°ç»„èµ·ç‚¹ã€‚æ›´è¿›ä¸€æ­¥çš„è§‚å¯Ÿï¼Œç©ºé—´å¯ä»¥ä¼˜åŒ–åˆ°O(1)ã€‚ äºŒç»´æƒ…å†µä¸‹ï¼Œè™½ç„¶éå¸¸ç›¸ä¼¼ï¼Œä½†æ˜¯è§£æ³•ä¸€æ—¶æƒ³ä¸åˆ°ç›´æ¥æ‰©å±•åˆ°äºŒç»´ã€‚ä½†æ˜¯é—®é¢˜å¯ä»¥åŒ–è§£ä¸ºä¸€ç»´ã€‚ åœ¨ç¡®å®šäº†çŸ©é˜µè¡Œæ•°æ®ï¼Œæˆ–è€…é¦–å…ˆéå†çŸ©é˜µçš„ä¸Šä¸‹ç•Œåï¼Œé¡ºé“æ±‚å‡ºè¯¥çŸ©é˜µçš„åœ¨å„å„åˆ—çš„å’Œã€‚ä¹‹åä¾¿å¯ä»¥ç”¨ä¸€ç»´çš„åšæ³•æ±‚å‡ºè¿ç»­åˆ—çš„æœ€å¤§å’Œã€‚ ä»£ç ï¼šclass Solution { int n; int m; vector&lt;int&gt; b; public: vector&lt;int&gt; getMaxMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { n = matrix.size(); m = matrix[0].size(); b.resize(m); vector&lt;int&gt; ans(4); int maxval = matrix[0][0]; for(int i = 0; i &lt; n; ++i){ for(int j = i; j &lt; n; ++j){ // accumulate the matrix in vertical sequences. if(i == j){ for(int k = 0; k &lt; m; ++k) b[k] = matrix[i][k]; }else for(int k = 0; k &lt; m; ++k) b[k] += matrix[j][k]; int sum = 0; int begin = 0; for(int l = 0; l &lt; m; ++l){ // sum = max(b[l], b[l] + sum); if(sum &lt; 0){ sum = 0; begin = l; } sum += b[l]; if(sum &gt; maxval){ maxval = sum; ans[0] = i; ans[1] = begin; ans[2] = j; ans[3] = l; } } } } return ans; } };","link":"/2021/05/10/shua-ti/dp/mian-shi-ti-17-24-zui-da-zi-ju-zhen/"},{"title":"é¢è¯•é¢˜ DP è´ªå¿ƒ","text":"æ”¶é›†è´ªå¿ƒã€DPé¢è¯•é¢˜ é¢14ï¼šå‰ªç»³å­é¢˜é¢ï¼šå°†ä¸€ä¸²é•¿ä¸ºKçš„ç»³å­å‰ªæˆmï¼ˆm&gt;=2ï¼Œå„æ®µé•¿åº¦å–æ•´æ•°å€¼ï¼‰æ®µï¼Œå„æ®µçš„é•¿åº¦å¤§äº0ï¼Œæ±‚å‡ºæœ€å¤§çš„å„æ®µç»³å­é•¿åº¦ä¹‹ç§¯ã€‚ æ€è·¯1ï¼šç”±ä¹˜æ³•äº¤æ¢å¾‹å¯çŸ¥ç»³å­çš„ä¹˜ç§¯å¯ä»¥åˆ†è§£ï¼Œæå–å‡ºæ¥ã€‚æ‰€ä»¥æœ‰f(m+n)=f(n)*f(m)ï¼Œå…¶ä¸­f(n)æ˜¯é•¿åº¦nçš„ç»³å­çš„æœ€å¤§ä¹˜ç§¯ã€‚åˆ†æå…·ä½“é—®é¢˜å¯ä»¥äº†è§£åˆ°åˆå§‹æ¡ä»¶æ¯”è¾ƒç‰¹æ®Šï¼Œå®ƒå¯¹äºå°æ•°å­—æ¥è¯´ï¼Œåˆ†è§£è¿˜ä¸å¦‚å…¶æœ¬èº«å¤§ï¼Œæ‰€ä»¥å®šä¹‰è¾¹ç•Œæ¡ä»¶f(1) = 1, f(2) = 2, f(3) = 3ã€‚åŒæ—¶åœ¨DPè¡¨ç¤ºå¼ä¸ºï¼š f(n)=maxif(nâˆ’i)âˆ—f(i)f(n)=maxif(nâˆ’i)âˆ—f(i) æ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸ºO(N2)O(N2)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(N)O(N)ã€‚ æ€è·¯2ï¼šå¦ä¸€ç§å°±æ˜¯è´ªå¿ƒï¼Œå¯¹äºé•¿åº¦må¤§äº5çš„ç»³å­å°½å¯èƒ½çš„å‰ªæˆé•¿åº¦ä¸º3çš„ç»³å­ï¼ŒåŒæ—¶å¦‚æœm%3==1ï¼Œé‚£ä¹ˆå°±å°‘å‰ªä¸€æ®µç»³å­ï¼Œå‰ªæˆä¸¤æ®µé•¿ä¸º2çš„ç»³å­ã€‚è¯æ˜å¦‚ä¸‹:$$if \\ n \\geq 53*(n-3) \\geq n2*(n-2) \\geq n3*(n -3 ) \\geq 2*(n-2)$$ æµ‹è¯•ï¼š2 2 , 3 2 , 5 6 , 6 9 ä»£ç ï¼šDP int maxProduct_DP(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int* products = new int[length + 1]; //åˆè¯•æ¡ä»¶æ¯”è¾ƒç‰¹æ®Šï¼Œå°äº4çš„å¤§äº1çš„æ•°çš„åˆ†æ®µä¹˜ç§¯ä¸å¦‚å…¶æœ¬èº«å¤§ products[0] = 0; products[1] = 1; products[2] = 2; products[3] = 3; for(int i = 4; i &lt;= length; i++){ int mavV = 0; for(int j = 1; j &lt;= i / 2; j++){ maxV = max(maxV, products[i - j] * products[j]); } products[i] = maxv; } int res = products[length]; //é˜²æ­¢å†…å­˜æ³„æ¼ del[] products; return res; } è´ªå¿ƒ int maxProduct_greedy(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int timesOf3 = length / 3; if(legnth % 3 == 1) timesOf3 -= 1; int timesOf2 = (length - timesOf3 * 3) / 2; return (int)pow(3, timeOf3) * (int)pow(2, timesOf2); } é¢42ï¼šæœ€å¤§å­æ•°ç»„å’Œé¢˜é¢ï¼šå¦‚é¢˜ æ€è·¯ï¼šDPæ€æƒ³ã€‚æ•°ç»„ä¹‹é—´çš„é€‰æ‹©ä¸å†å²æ— å…³ï¼Œå¯ä»¥é‡‡å–DPçš„æ–¹æ³•ã€‚è®°f(i)ä¸ºä»¥A[i]ä¸ºç»“å°¾çš„æœ€å¤§æ•°ç»„å’Œã€‚è½¬ç§»æ–¹ç¨‹ä¸ºï¼š f(i)={A[i],if f(i-1)&lt;0 A[i]+f(iâˆ’1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(iâˆ’1),if f(i-1)&gt;0 å½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥ä»æ•°æ®çš„è§’åº¦ç†è§£ï¼Œä»£ç éƒ½æ˜¯ç›¸åŒçš„ã€‚ ä»£ç ï¼šint MaxSumOfSubArray(int A[], int length){ int dp[] = new int(length); int maxSum = A[0]; dp[0] = A[0]; for(int i = 1; i &lt; length; i++){ dp[i] = max(A[i], A[i] + dp[i-1]); maxSum = max(dp[i], maxSum); } delete[] dp; return maxSum; } å½“ç„¶è¿™é‡Œçš„dpæ•°ç»„ä¹Ÿå¯ä»¥ä¸è¦ã€‚ é¢45ï¼šæŠŠæ•°å­—æ’æˆæœ€å°çš„æ•°å­—é¢˜ç›®ï¼šç»™å®šä¸€ä¸²æ•°å­—ï¼Œç»„åˆæˆçš„ä¸€ä¸ªæ•°å­—ã€‚æ±‚å‡ºç»„åˆåæœ€å°æ•°å­—çš„ æ€è·¯ï¼šå¯ä»¥ç›´æ¥è´ªå¿ƒ+åè¯ã€‚æŒ‰å­—å…¸åºæ’åºæ•°å­—å³å¯ã€‚ ä»£ç ï¼šå°±ä¸å†™äº†ï¼Œç›´æ¥stringæ’åºè¾“å‡ºå³å¯ã€‚ é¢46ï¼šæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²é¢˜ç›®ï¼šæŠŠä¸€ä¸²æ•°å­—ç¿»è¯‘æˆæ•°å­—å¯¹åº”çš„å­—æ¯ï¼Œå¹¶æŒ‰åŸé¡ºåºç»„æˆå­—ç¬¦ä¸²ã€‚ç”±äºæ•°å­—åˆ†è£‚çš„ä¸åŒï¼Œç¿»è¯‘æ–¹æ³•æœ‰è®¸å¤šï¼Œæ±‚å‡ºç¿»è¯‘çš„æ–¹æ³•çš„ä¸ªæ•°ã€‚ æ€è·¯ï¼šç¬¬ä¸€ç§å°±æ˜¯ç›´æ¥é€’å½’åˆ†å‰²å­—ç¬¦ä¸²ã€‚æ˜¾ç„¶æœ‰å­é—®é¢˜é‡å çš„ç°è±¡ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨DPã€‚ ç¬¬äºŒç§ç”¨DPæ€æƒ³ï¼Œè€ƒè™‘dp[i]ä¸ºä»0åˆ°içš„å­—ç¬¦ä¸²ç¿»è¯‘æ–¹æ³•ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š dp[i]={dp[iâˆ’1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[iâˆ’1]+dp[iâˆ’2],else dp[i]={dp[iâˆ’1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[iâˆ’1]+dp[iâˆ’2],else ä»£ç ï¼šint GetTranslateCount(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int dp[] = new int(length); dp[0] = 1; for(int i = 1; i &lt; length; i++){ int add = A[i - 1] * 10 + A[i]; if( add &gt; 9 &amp;&amp; add &lt; 26){ if(i &lt; 2) dp = dp[i - 1] + 1; else dp[i] = dp[i - 1] + dp[i - 2]; } else dp[i] = dp[i - 1]; } delete[] dp; return dp[length - 1]; } é¢47ï¼šç¤¼ç‰©çš„æœ€å¤§ä»·å€¼é¢˜ç›®ï¼šä»ä¸€åœ¨æ ¼å­ä¸Šè£…æ»¡ç¤¼ç‰©çš„m*nçš„çŸ©å½¢æ£‹ç›˜ä¸Šï¼Œä»å·¦ä¸Šè§’å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ ¼åˆ°å³ä¸‹è§’ï¼Œæ±‚å‡ºè·¯å¾„ä¸Šç¤¼ç‰©ä»·å€¼çš„æœ€å¤§å€¼ã€‚ æ€è·¯ï¼šæ˜æ˜¾å°±æ˜¯DP ä»£ç ï¼šä¸å†™äº†ã€‚ é¢48ï¼šæœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²é¢˜ç›®ï¼šå¦‚é¢˜ æ€è·¯ï¼šæš´åŠ›ä¸å¯å–ã€‚ é‡‡ç”¨ç”¨DPæ€æƒ³ï¼Œè€ƒè™‘dp[i]ä¸ºä»¥S[i]ä¸ºç»“å°¾çš„æœ€é•¿ä¸é‡å¤å­—ç¬¦ä¸²ã€‚ä¸€ä¸ªä¸å«é‡å¤å­—ç¬¦çš„å­—ç¬¦ä¸²å¯ä»¥åœ¨ç”±å¦ä¸€ä¸ªä¸åŒçš„å­—ç¬¦ç»„æˆå¦ä¸€ä¸ªä¸å«é‡å¤å­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚å¯ä»¥åœ¨dpè¿‡ç¨‹ä¸­ï¼Œè®°å½•ä¸‹æœ€æ–°çš„å­—ç¬¦çš„ä½ç½®POSï¼Œåˆ¤æ–­S[i]çš„å‰ä¸€ä¸ªç›¸åŒå­—ç¬¦æ˜¯å¦åœ¨ä¸Šä¸€ä¸ªS[i-1]ä¸ºç»“å°¾çš„æœ€é•¿ä¸é‡å¤å­—ç¬¦ä¸²ä¹‹å†…ã€‚è®°ä¸Šä¸€ä¸ªå­—ç¬¦ä¸S[i-1]çš„é•¿åº¦dä¸ºi - POSã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š dp[i]={dp[iâˆ’1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[iâˆ’1]+1,if d &gt; dp[i - 1] d,else ä»£ç ï¼šint MaxSubStr(String s){ int dp[] = new int(s.length()); int pos[26]; for(int i = 0; i &lt; 26; i++) pos[[i] = -1; int maxL = 1; dp[0] = 1; for(int i = 1; i &lt; s.length(); i++){ int d = i - pos[s[i] - 'a']; if(dp[i - 1] &lt; d){ dp[i] = dp[i - 1] + 1; }else dp[i] = d; maxL = max(maxL, dp[i]); pos[s[i] - 'a'] = i; } delete[] dp; return maxL; }","link":"/2020/08/07/shua-ti/dp/mian-shi-ti-dp-tan-xin/"},{"title":"1286. Iterator for Combination","text":"æƒ³äº†ä¸€ä¸‹å…¨ç»„åˆçš„å†™æ³•ï¼Œé¡ºä¾¿å¤ä¹ äº†ä¸€ä¸‹å…¨æ’åˆ—(full permutaion)çš„æ€æƒ³ã€‚ 1286. Iterator for Combination å…¨æ’åˆ—æ€è·¯ï¼šå®˜æ–¹ç»™å‡ºäº†ç”Ÿæˆæ³•ï¼Œè¿™ç§æ–¹æ³•æ¯”è¾ƒæ­»æ¿ä¸å»å­¦ä¹ ã€‚ æˆ‘ä¾æ®å…¨æ’åˆ—çš„é€’å½’ç”Ÿæˆæ–¹æ³•ï¼Œæ‰©å±•åˆ°å…¨ç»„åˆçš„ç”Ÿæˆæ–¹æ³•ï¼Œä½†æ˜¯éœ€è¦å­˜å‚¨ã€‚æ€è·¯å°±æ˜¯ï¼šf(s,i,len,str)é€’å½’ç»™å‡ºå·²ç”Ÿæˆiä½strï¼Œè·å–sçš„lenåŠä¹‹åçš„å…¨ç»„åˆå­—ç¬¦ä¸²ã€‚ å¤§ç¥ç»™å‡ºäº†åŸºäºäºŒè¿›åˆ¶çš„å…¨ç»„åˆgeneratorfæ–¹æ³•ã€‚ç”±äºå…¨ç»„åˆçš„æ’åˆ—é¡ºåºåœ¨äºŒè¿›åˆ¶çœ‹æ¥å°±æ˜¯ç›¸åŒæ•°é‡çš„1å’Œ0çš„ç»„åˆï¼Œå› æ­¤å¯ä»¥ç”±å¤§åˆ°å°æ’åˆ—ã€‚ æ¯”å¦‚ï¼Œå­—å…¸åºæ’åºåº”è¯¥æ˜¯: ab ac ad bc bd åˆšå¥½å¯ä»¥å¯¹åº”äºŒè¿›åˆ¶æ•°ï¼Œä»å¤§åˆ°å°: 1100 1010 1001 0110 0101 0011 å†åˆ©ç”¨n&amp;(n-1)è®¡ç®—å‡º0bNçš„1çš„ä¸ªæ•°ã€‚ ä»£ç ï¼šå…¨ç»„åˆå†™æ³•ï¼š class CombinationIterator { public: queue&lt;string&gt; que; int len = -1; CombinationIterator(string characters, int combinationLength) { len = combinationLength; printCombination(characters, 0, 0, &quot;&quot;); } // å…¨æ’åˆ—å†™æ³•ï¼Œcombinationåªæ˜¯ç»„åˆï¼Œè€Œéå…¨æ’åˆ— void printPer(string a, int depth){ if(depth &gt; len) return; else if(depth == len){ // cout &lt;&lt; counter++ &lt;&lt; ' ' &lt;&lt; a.substr(0, len) &lt;&lt; endl; que.push(a.substr(0, len)); return; } for(int i = depth + 1;i &lt; a.size(); i++){ printPer(a, depth + 1); swap(a[i], a[depth]); } printPer(a, depth + 1); } // combinationå†™æ³• void printCombination(string a, int depth, int idx, string b){ if(depth &gt; len) return; else if(depth == len){ //cout &lt;&lt; counter++ &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; que.push(b); return; } for(int i = idx;i &lt; a.size() - len + depth + 1; i++){ printCombination(a, depth + 1, i + 1, b + a[i]); } } string next() { string res = que.front(); que.pop(); return res; } bool hasNext() { return !que.empty(); } }; /** * Your CombinationIterator object will be instantiated and called as such: * CombinationIterator* obj = new CombinationIterator(characters, combinationLength); * string param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */ bitç‰ˆï¼š class CombinationIterator { private: int cur; int sz; string chars; public: CombinationIterator(string characters, int combinationLength) { sz = combinationLength; chars = characters; cur = (1 &lt;&lt; chars.size()) - 1; } //è¦æ±‚è¾“å…¥å­—ç¬¦ä¸²é•¿åº¦&lt;= 31 int countone(int n){ int res = 0; while(n){ n = n &amp; (n - 1); res ++; } return res; } string next() { while(cur &gt; 0 &amp;&amp; countone(cur) != sz) cur--; if(cur &lt;= 0) return &quot;&quot;; string res = &quot;&quot;; cout &lt;&lt; cur &lt;&lt; endl; for(int i = 0; i &lt; chars.size(); i++){ if((cur &amp; (1 &lt;&lt; i)) != 0) res = chars[chars.size() - 1 - i] + res; } cur--; return res; } bool hasNext() { while(cur &gt; 0 &amp;&amp; countone(cur) != sz) cur--; if(cur &gt; 0) return true; else return false; } }; /** * Your CombinationIterator object will be instantiated and called as such: * CombinationIterator* obj = new CombinationIterator(characters, combinationLength); * string param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */","link":"/2020/10/08/shua-ti-wei-yun-suan-1286-iterator-for-combination/"},{"title":"136. Single Number","text":"136. Single Numberæ€è·¯ï¼š ä»£ç ï¼šclass Solution { public: int singleNumber(vector&lt;int&gt;&amp; nums) { int key = 0; for(auto &amp;k : nums){ key = k ^ key; } return key; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-136-single-number/"},{"title":"190. Reverse Bits","text":"190. Reverse Bitsæ€è·¯ï¼š ä»£ç ï¼šclass Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t z = 0; int k = 0; while(k &lt;= 31){ z = (z &lt;&lt; 1) | (n &amp; 1); n &gt;&gt;= 1; k++; } return z; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-190-reverse-bits/"},{"title":"260. Single Number III","text":"260. Single Number IIIæ€è·¯ï¼šåˆ’åˆ†æ•°ç»„ æ€è·¯éå¸¸ç²¾å·§ã€‚ç”¨å¼‚æˆ–æ‰€æœ‰æ•°ç»„ï¼Œç”±äºå¼‚æˆ–çš„æ€§è´¨ï¼Œåªæœ‰ä¸¤ä¸ªå”¯ä¸€ä¸”ä¸ç­‰çš„å‡ºç°çš„æ•°å­—$x$,$y$è¢«è®°å½•ä¸‹æ¥ï¼Œè®°ä¸º$z$ã€‚å¯ä»¥æ¨æµ‹ï¼Œ$z$æ¯”ä¸ä¸ºé›¶ï¼Œä¸”ç¬¬ä¸€ä¸ª1è¦ä¹ˆæ¥è‡ª$x$ï¼Œè¦ä¹ˆæ¥è‡ª$y$ã€‚åŒæ—¶å¯ä»¥æ ¹æ®è¿™ä¸ªâ€œç¬¬ä¸€ä¸ª1â€æ˜¯å¦åœ¨å…¶ä»–æ•°å­—ä¸Šå­˜åœ¨ï¼Œå°†æ•°ç»„åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€ç»„æ˜¯å¸¦æœ‰$x$å’Œæˆå¯¹çš„æ•°å­—ï¼Œå¦ä¸€ç»„ç±»ä¼¼ã€‚ å¦‚æ­¤åˆ’åˆ†æ•°ç»„ï¼ŒåŒæ—¶å¼‚æˆ–å…¶ä¸­ä¸€ç»„ï¼Œå°±å¯ä»¥å¾—åˆ°$x$æˆ–è€…$y$ã€‚å½“ç„¶ä¹Ÿå¯ä»¥é€šè¿‡ä¸Šé¢çš„$z$å¼‚æˆ–å…¶ä¸­ä¸€ä¸ªæ•°å­—æ¥å¾—åˆ°å¦ä¸€ä¸ªæ•°å­—ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) { int bitmask = 0; for(auto &amp; k : nums) bitmask ^= k; long long key = (long)bitmask &amp; (-(long)bitmask); int mask = 0; cout &lt;&lt; key &lt;&lt; endl; for(auto &amp; k : nums){ if(k &amp; key){ mask ^= k; } } return {mask, bitmask ^ mask}; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-260-single-number-iii/"},{"title":"268. Missing Number","text":"268. Missing Numberæ€è·¯ï¼š æ’åº å“ˆå¸Œ å¼‚æˆ–ä½è¿ç®— é«˜æ–¯æ±‚å’Œ 3å’Œ4å®ç°äº†$O(n)$çš„æ—¶é—´å¤æ‚åº¦å’Œ$O(1)$çš„ç©ºé—´å¤æ‚åº¦ã€‚ ä»£ç ï¼š class Solution { public: int missingNumber(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n == 0 ) return 0; int lose = 0; for(auto &amp; k : nums){ lose ^= k; } for(int i = 0; i &lt;= n; ++i) lose ^= i; return lose; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-268-missing-number/"},{"title":"318. Maximum Product of Word Lengths","text":"318. Maximum Product of Word Lengthsæ€è·¯ï¼šä¸ºäº†é¿å…æŸ¥è¯¢æ—¶å€™çš„é‡å¤æ¯”è¾ƒï¼Œå¯ä»¥å°†æ¯”è¾ƒå†…å®¹å˜æˆä¸€ä¸ªæ ‡å¿—ç¬¦ï¼Œå‡å°‘äº†æ¯”è¾ƒæ—¶å€™çš„é‡å¤è®¡ç®—ã€‚ è¿›ä¸€æ­¥çš„ï¼Œå¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–é‡å¤æ ‡å¿—ç¬¦çš„æŸ¥è¯¢æ¬¡æ•°ã€‚ ä»£ç ï¼š class Solution { public: int aderator(string s){ int pic = 0; for(auto &amp;c : s){ pic |= (1 &lt;&lt; (c - 'a')); } return pic; } int maxProduct(vector&lt;string&gt;&amp; words) { vector&lt;int&gt; pics; for(auto &amp;s : words){ pics.push_back(aderator(s)); } int maxl = 0; for(int i = 0; i &lt; pics.size(); ++i){ for(int j = i + 1; j &lt; pics.size(); ++j){ if((pics[i] &amp; pics[j]) == 0){ maxl = max(maxl, int(words[i].size() * words[j].size())); } } } return maxl; } }; åœ¨ä¸Šé¢˜åŸºç¡€ä¸Šï¼Œç”¨hashmapè®°å½•keyç›¸åŒçš„é•¿åº¦æœ€é•¿çš„stringï¼Œå‡å°‘æŸ¥è¯¢æ¬¡æ•°ã€‚ class Solution { public: int aderator(string s){ int pic = 0; for(auto &amp;c : s){ pic |= (1 &lt;&lt; (c - 'a')); } return pic; } int maxProduct(vector&lt;string&gt;&amp; words) { unordered_map&lt;int, int&gt; map; for(auto &amp;s : words){ int key = aderator(s); map[key] = max(map[key], (int)s.size()); } int maxl = 0; for(auto &amp;[key1, value1] : map){ for(auto &amp;[key2, value2] : map){ if((key1 &amp; key2) == 0){ maxl = max(maxl, int(value1 * value2)); } } } return maxl; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-318-maximum-product-of-word-lengths/"},{"title":"338. Counting Bits","text":"338. Counting Bitsæ€è·¯ï¼šåˆ©ç”¨äºŒè¿›åˆ¶ä¸Šæ•°å­—å˜åŒ–ï¼Œå°†æ•°å­—è®¡ç®—è½¬ç§»ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; countBits(int nums) { vector&lt;int&gt; dp(nums + 1); for(int i = 1; i &lt;= nums; ++i){ dp[i] = (i &amp; 1) ? dp[i - 1] + 1 : dp[i &gt;&gt; 1]; } return dp; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-338-counting-bits/"},{"title":"342. Power of Four","text":"342. Power of Fouræ€è·¯ï¼š åˆ¤æ–­å”¯ä¸€çš„1çš„ä½ç½®æ˜¯å¦åœ¨1çš„å€æ•°ä¸Š æ£€æŸ¥ $log_2x$æ˜¯å¦ä¸ºå¶æ•°å°±èƒ½åˆ¤æ–­ x æ˜¯å¦ä¸º 4 çš„å¹‚ ä»£ç ï¼š class Solution { public: bool isPowerOfFour(int n) { if(n &lt;= 0) return false; while(n != 1){ if((n &amp; 3)) return false; n &gt;&gt;= 2; } return true; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-342-power-of-four/"},{"title":"461. Hamming Distance","text":"461. Hamming Distanceæ€è·¯ï¼š ä»£ç ï¼šclass Solution { public: int hammingDistance(int x, int y) { int z = x ^ y; int ct = 0; while(z){ ct += z &amp; 1; z &gt;&gt;= 1; } return ct; } };","link":"/2021/01/17/shua-ti-wei-yun-suan-461-hamming-distance/"},{"title":"476. Number Complement","text":"476. Number Complementæ€è·¯ï¼šæ•°å­—å–åå‰æŠŠå‰ç¼€é›¶å…¨éƒ¨è½¬åŒ–ä¸ºå‰ç¼€1. ä»£ç ï¼šclass Solution { public: int findComplement(int num) { int c = 1; while( (num &gt;&gt; c) ) ++c; while(c &lt;= 31){ num = num | (1 &lt;&lt; c); c++; // cout &lt;&lt; num &lt;&lt; endl; } return ~num; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-476-number-complement/"},{"title":"693. Binary Number with Alternating Bits","text":"693. Binary Number with Alternating Bitsæ€è·¯: ä»£ç ï¼šclass Solution { public: bool hasAlternatingBits(int n) { if(n &lt; 1) return true; int obit = n &amp; 1, bit = 0; n &gt;&gt;= 1; while(n){ bit = n &amp; 1; n &gt;&gt;= 1; if(bit == obit) return false; obit = bit; } return true; } };","link":"/2021/01/19/shua-ti-wei-yun-suan-693-binary-number-with-alternating-bits/"},{"title":"é¢è¯•é¢˜-ä½è¿ç®—","text":"æ”¶é›†ä½è¿ç®—ç›¸å…³çš„é¢˜ç›®ã€‚ åˆ¤æ–­1çš„ä¸ªæ•° é¢˜é¢ï¼šç»™å‡ºä¸€ä¸ªæ•´æ•°Kï¼Œåˆ¤æ–­å…¶äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°ã€‚ æ€è·¯1ï¼šå…¸å‹çš„äºŒè¿›åˆ¶é¢˜ç›®ï¼Œå¯ä»¥ä½¿ç”¨ä¸è¿ç®—åˆ¤æ–­æ•°å­—KæŸä¸€ä½æ˜¯å¦æ˜¯1ã€‚å·§å¦™çš„æ˜¯ï¼Œæ—¢å¯ä»¥åœ¨è¿ç®—ä¸­ç§»ä½Kï¼Œä¹Ÿå¯ä»¥ä½ç§»flagã€‚æ˜¾ç„¶åé¢ä¸€ç§å¯ä»¥é¿å…Kæ•°å­—ä¸ºè´Ÿè€Œå¯¼è‡´çš„é«˜ä½å¡«é›¶çš„å³ç§»é—®é¢˜ã€‚ æ€è·¯2ï¼šæ›´å·§å¦™çš„æ–¹æ³•ï¼Œæ˜¯è€ƒè™‘åˆ°K-1åä¼šæŠŠKçš„ç¬¬ä¸€ä¸ªä½ä½1å’Œä¹‹åçš„0å…¨éƒ¨å–é¥­ï¼Œæ­¤æ—¶K &amp; (K -1)ç›¸æ¯”äºKä¼šå°‘ä¸€ä¸ªä½ä½1ã€‚å¦‚æ­¤åå¤æ“ä½œä¾¿å¯ç»Ÿè®¡æ‰€æœ‰1çš„ä¸ªæ•°ã€‚ æ€è·¯æ‰©å±•ï¼šåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯2çš„æ•´æ•°æ¬¡ï¼›å¯¹äºæ•°å­—méœ€è¦æ”¹å˜å¤šå°‘ä½æ‰èƒ½å˜æˆæ•°å­—nã€‚ ä»£ç ï¼šæ€è·¯1 int NumberOf1(int n){ int flag = 1, count = 0; while(flag){ if(flag &amp; n) count++; falg = flag &lt;&lt; 1; } return count; } æ€è·¯2 int NumberOf1(int n){ int count = 0; while(n){ count ++; n = (n - 1) &amp; n; } return count; }","link":"/2020/08/07/shua-ti-wei-yun-suan-mian-shi-ti-wei-yun-suan/"},{"title":"1025 é™¤æ•°åšå¼ˆ","text":"1025. é™¤æ•°åšå¼ˆéš¾åº¦ç®€å• æ€è·¯ï¼šå¯ä»¥ä»ç®€å•çš„ä¾‹å­å…¥æ‰‹å‘ç°ï¼Œçˆ±ä¸½ä¸æ‹¿1è¾“ï¼Œæ‹¿2èµ¢ï¼Œæ‹¿3è¾“ã€‚å¯¹äºBobåˆ™ç›¸åï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥æ‰¾å‡ºå°äºæ•°å­—Nçš„æ•°å­—xï¼Œä¸”N-xå¯ä»¥æ•´é™¤äºNï¼Œxå¯¹äºbobæ˜¯å¿…è¾“æ€ï¼Œé‚£ä¹ˆçˆ±ä¸½ä¸å¿…èƒœã€‚ ä¹Ÿå¯ä»¥ä»å¦ä¸€ä¸ªè§’åº¦å‡ºå‘ï¼šä»å¤šä¸ªä¾‹å­å¯ä»¥å¤§èƒ†æ¨æµ‹ï¼Œå¶æ•°å¿…èƒœï¼Œå¥‡æ•°å¿…è¾“ã€‚å¯ä»¥ç”¨å½’çº³æ³•è¯æ˜ã€‚é‚£ä¹ˆä»£ç å°±ç®€å•å¾ˆå¤šã€‚ ä»£ç ï¼šå †ç»´æŠ¤æ•°ç»„ class Solution { public: bool divisorGame(int N) { if(N &lt; 1 || N &gt; 1000) return false; int* dp = new int[1005]; dp[1] = 0; dp[2] = 1; for(int i = 3; i &lt; 1001; i++){ dp[i] = 0; for(int j = 1; j &lt; i; j++){ if(i % (i - j) == 0 &amp;&amp; dp[j] == 0){ dp[i] = 1; break; } } } return dp[N]; } };","link":"/2020/08/07/shua-ti/qi-ta/1025-chu-shu-bo-yi/"},{"title":"1027 æœ€é•¿ç­‰å·®æ•°åˆ—","text":"1027. æœ€é•¿ç­‰å·®æ•°åˆ—æ€è·¯ï¼šæ±‚æœ€é•¿ç­‰å·®åºåˆ—çš„é•¿åº¦ï¼Œå¯ä»¥çœ‹å‡ºåºåˆ—å¯ä»¥åˆ†è§£ä¸ºå¤šä¸ªåºåˆ—ï¼Œè€Œä¸”åºåˆ—çš„é€‰æ‹©ä¸å…·æœ‰å†å²å½±å“ã€‚å¯ä»¥å¯ä»¥è€ƒè™‘ç”¨DPåšã€‚ç”¨ä¸€ä¸ªçŠ¶æ€æ— æ³•è¡¨ç¤ºæ•°åˆ—çš„ç­‰å·®é‡å’Œæ•°åˆ—çš„ç«¯ç‚¹ä¸¤ä¸ªçŠ¶æ€ã€‚æ‰€ä»¥è‡³å°‘å¾—æœ‰ä¸¤ä¸ªçŠ¶æ€ï¼Œä¸”å¯ä»¥ç”¨ä¸¤ä¸ªçŠ¶æ€åˆ†åˆ«è¡¨ç¤ºä¸€ä¸ªç­‰å·®åºåˆ—çš„æœ€åä¸¤ä¸ªå…ƒç´ ä¸‹æ ‡ã€‚ DPæ–¹ç¨‹å¯ä»¥è¿™ä¹ˆå†™ï¼š dp[i][j]={dp[k][i]+1,if k is element of the array 2,elsedp[i][j]={dp[k][i]+1,if k is element of the array 2,else ä¸ºå•¥æ˜¯æœ€åä¸¤ä¸ªï¼Ÿå› ä¸ºä¸ºæœ€åä¸¤ä¸ªå…ƒç´ ç»„æˆçš„æœ€é•¿ç­‰å·®åºåˆ—ï¼Œå¯ä»¥ç»™åç»­DPæ–¹ç¨‹è®¡ç®—ã€‚è€Œä¸¤ä¸ªå…ƒç´ ä½œä¸ºå¼€å¤´æ— æ³•é€’æ¨ï¼ class Solution { public: int longestArithSeqLength(vector&lt;int&gt;&amp; A) { int n = A.size(); //ä¼˜ç§€çš„åˆå§‹åŒ–æ–¹æ³• // vector&lt;int&gt;(n, 2)åŠ¨æ€ç”Ÿæˆäº†ä¸€ä¸ªé•¿åº¦ä¸ºnï¼Œæ¯ä¸ªå…ƒç´ ä¸º2çš„vectorå¯¹è±¡ vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 2)); map&lt;int, int&gt; idx; int maxRes = 2; for(int i = 0; i &lt; (int)A.size() - 1; i++){ for(int j = i + 1; j &lt; A.size(); j++){ int target = A[i] * 2 - A[j]; if( idx.count( target )) dp[i][j] = dp[idx[target]][i] + 1; maxRes = max(maxRes, dp[i][j]); } idx[A[i]] = i; } return maxRes; } };","link":"/2020/08/07/shua-ti/qi-ta/1027-zui-chang-deng-chai-shu-lie/"},{"title":"1143. Longest Common Subsequence","text":"1143. Longest Common Subsequenceæ€è·¯ï¼šdp[i][[j]ä¸ºtext1å’Œtext2åœ¨ä½ç½®i,jçš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚ ä»£ç ï¼š80% class Solution { public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(), m = text2.size(); if(n == 0 || m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp; dp.resize(n, vector&lt;int&gt;(m, 0)); int flag = 0; for(int i = 0; i &lt; n; i++){ if(flag || text1[i] == text2[0]){ flag = 1; dp[i][0] = 1; } } flag = 0; for(int i = 0; i &lt; m; i++){ if(flag || text1[0] == text2[i]){ flag = 1; dp[0][i] = 1; } } for(int i = 1; i &lt; n; ++i){ for(int j = 1; j &lt; m; ++j){ if(text1[i] == text2[j]){ dp[i][j] = dp[i - 1][j - 1] + 1; }else dp[i][j] = max(dp[i][j -1], dp[i - 1][j]); // cout &lt;&lt; dp[i][j] &lt;&lt; ' '; } // cout&lt;&lt; endl; } return dp[n - 1][m - 1]; } };","link":"/2020/12/15/shua-ti/qi-ta/1143-longest-common-subsequence/"},{"title":"1190. Reverse Substrings Between Each Pair of Parentheses","text":"1190.Reverse Substrings Between Each Pair of Parentheses éš¾åº¦MDè¿™ä¸ªé¢˜ä¸€å¼€å§‹æ€è·¯å°±é”™äº†ï¼Œé¦–å…ˆæ˜¯æ‹¬å·åŒ¹é…é—®é¢˜ä¸èƒ½ä½¿ç”¨å·¦å³æŒ‡é’ˆé€‰æ‹©ï¼Œå…¶æ¬¡æ˜¯å­—ç¬¦ä¸²ç¿»è½¬å®Œå…¨å¯ä»¥å¿½ç•¥æ‰æ‹¬å·ï¼ˆæˆ–è€…è¯´è¿åŒæ‹¬å·ä¸€èµ·ç¿»è½¬ï¼‰ã€‚ä¸€å…±æœ‰ä¸¤ç§æ€è·¯ã€‚ æ€è·¯1å°†æ ˆåŒ¹é…+ç¿»è½¬ï¼Œå¤æ‚åº¦O(n2)O(n2)ã€‚ class Solution { public: // string reverseParentheses(string s) { // string ns = &quot;&quot;; // vector&lt;int&gt; idxl, idxr; // int singbrack = 0, calbrack = 0; // for(int i = 0; i &lt; s.size(); i++){ // if(s[i] == '(' || s[i] == ')') singbrack ++; // else ns.push_back(s[i]); // } // singbrack /= 2; // for(int i = 0, j = s.size() - 1; i &lt; j;){ // while(i &lt; j &amp;&amp; s[i] != '(') i++; // while(i &lt; j &amp;&amp; s[j] != ')') j--; // idxl.push_back(i - calbrack); // idxr.push_back(j - singbrack - (singbrack - calbrack - 1)); // reverse ç¿»è½¬çš„èŒƒå›´æ˜¯[),è¿™é‡Œæ³¨æ„01é”™è¯¯ // i++; // j--; // calbrack ++; // } // if(calbrack == 0) return ns; // for(int i = idxl.size() - 1; i &gt;= 0; i--){ // reverse(ns.begin() + idxl[i], ns.begin() + idxr[i]); // } // return ns; // } string reverseParentheses(string s) { string ns = &quot;&quot;; stack&lt;int&gt; sti; for(int i= 0; i &lt; s.size(); i++){ if( s[i] == '(') sti.push(i); else if(s[i] == ')'){ reverse( s.begin() + sti.top(), s.begin() + i); sti.pop(); } } for(int i = 0; i &lt; s.size(); i++){ if(s[i] == '(' || s[i] == ')' ) continue; ns.push_back(s[i]); } return ns; } }; æ€è·¯2ç¥å¥‡çš„é»‘é­”æ³•ï¼ˆè¿™ä¸ªç®—æ³•å±€é™äºè¿™ä¸ªåº”ç”¨ï¼Œæ„Ÿè§‰æŒºæ­»æ¿ï¼‰","link":"/2020/08/07/shua-ti/qi-ta/1190-reverse-substrings-between-each-pair-of-parentheses/"},{"title":"122. Best Time to Buy and Sell Stock II","text":"æ€è·¯ï¼šè´ªå¿ƒåšæ¯ä¸€ä¸ªå¯ä»¥äº¤æ˜“çš„äº¤æ˜“å°±è¡Œ ä»£ç ï¼šclass Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int sum = 0; for(int i = 0; i &lt; prices.size() - 1; ++i){ sum += (prices[i] &lt; prices[i + 1] )? prices[i + 1] - prices[i] : 0; } return sum; } };","link":"/2020/10/15/shua-ti/qi-ta/122-best-time-to-buy-and-sell-stock-ii/"},{"title":"1254. Number of Closed Islands","text":"1254. Number of Closed Islandséš¾åº¦MD æ€è·¯ï¼šDFSæˆ–è€…å¹¶æŸ¥é›† æ’é™¤æ³•ï¼šå°†æ‰€æœ‰æ¥è§¦è¿‡è¾¹ç•Œçš„0å—æ’é™¤æ‰ï¼Œæ¥ä¸‹æ¥ç»Ÿè®¡æ‰€æœ‰çš„0å—æ•°é‡å°±æ˜¯å²›å±¿çš„æ•°é‡å•¦~ ç›´æ¥æ³•ï¼šè€ƒè™‘æˆä¸ºå²›å±¿çš„æ¡ä»¶â€”â€”å²›å±¿ä¸Šæ‰€æœ‰0å—éƒ½ä¸ä¸è¾¹ç•Œç›¸äº¤ã€‚ æ¥ä¸‹æ¥åªéœ€è¦å†™DFSæˆ–è€…BFSå°±ğŸ‘Œã€‚ è€ƒè™‘ä½¿ç”¨å¹¶æŸ¥é›† æ’é™¤æ³• class Solution { public: //ä¿æŒå’Œç¬¬äºŒç§å†™æ³•ä¸€è‡´ï¼Œaddå‚æ•°å®é™…ä¸Šæ˜¯å¤šä½™çš„ void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add){ if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= M || grid[x][y] == 1) return; //if(grid[x][y] == 1) add = 1; grid[x][y] = 1; findBlockOf0(x, y+1, N, M, grid, add); findBlockOf0(x, y-1, N, M, grid, add); findBlockOf0(x+1, y, N, M, grid, add); findBlockOf0(x-1, y, N, M, grid, add); return; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts, add; //æ’é™¤æ‰é‚£äº›ä¸æ˜¯islandçš„blocks of 0 for(int i=0;i &lt; M; i++){ findBlockOf0(0,i, N, M, grid, counts); findBlockOf0(N-1,i, N, M, grid, counts); } for(int i=0;i &lt; N;i++){ findBlockOf0(i,0,N,M, grid, counts); findBlockOf0(i,M-1, N, M, grid, counts); } //æ¥ä¸‹æ¥æ‰€æœ‰çš„0å—éƒ½å¯ä»¥ç®—ä½œisland counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; findBlockOf0(x, y, N, M, grid, add); counts += 1; } } return counts; } }; ç›´æ¥æ³• class Solution { public: // æ³¨æ„éå†çš„æ—¶å€™ä¸èƒ½å‰ªæï¼Œå¦åˆ™å°±ä¼šå°±ä¼šå‡ºç°å²›å±¿æ–­è£‚æˆå¤šä¸ªâ€œå•ç‹¬â€å²›å±¿è€Œè®¡æ•°è¿‡å¤š void findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid, int &amp;add){ if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= M || grid[x][y] == 1) return; if(x == 0 || x == N-1|| y == 0 || y == M-1 ) add = 0; grid[x][y] = 1; // è¿™é‡Œçš„å››ä¸ªæ–¹å‘å…¶å®å¯ä»¥ç”¨FORå†™çš„æ›´ä¼˜é›…ä¸€äº› findBlockOf0(x, y+1, N, M, grid, add); findBlockOf0(x, y-1, N, M, grid, add); findBlockOf0(x+1, y, N, M, grid, add); findBlockOf0(x-1, y, N, M, grid, add); return; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts; counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; int add = 1; findBlockOf0(x, y, N, M, grid, add); counts += add; } } return counts; } }; å°è¯•ä½¿ç”¨BFSå†™ç¬¬äºŒç§å†™æ³•~ class Solution { public: // BFS int findBlockOf0(int x, int y,int N, int M, vector&lt; vector&lt;int&gt; &gt; &amp;grid){ int dX[4] = {0, 0, -1, 1}, dY[4] = {1, -1, 0, 0}, nX, nY; int flag = 1; queue&lt; vector&lt;int&gt; &gt; que; que.push( {x, y}); grid[x][y] = 1; while( !que.empty() ){ vector&lt;int&gt; point = que.front(); que.pop(); int x = point[0], y = point[1]; //æ³¨æ„ æ‰€æœ‰çš„ç‚¹éƒ½éœ€è¦åˆ¤æ–­æ˜¯å¦åœ¨è¾¹ç•Œä¸Š if(x == 0 || x == N - 1 ||y == 0 || y == M - 1) flag = 0; for(int i=0;i &lt; 4; i++){ nX = x + dX[i]; nY = y + dY[i]; if(nY &gt;= 0 &amp;&amp; nY &lt; M &amp;&amp; nX &gt;=0 &amp;&amp; nX &lt; N &amp;&amp; grid[nX][nY] == 0){ grid[nX][nY] = 1; que.push({nX, nY}); } } } return flag; } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int N = grid.size(), M = grid[0].size(), counts; counts = 0; for(int x = 0 ;x &lt; N;x++){ for(int y=0; y &lt; M; y++ ){ if(grid[x][y] != 0) continue; counts += findBlockOf0(x, y, N, M, grid); } } return counts; } }; å¹¶æŸ¥é›† æ”¹æ—¥å†æˆ˜","link":"/2020/08/07/shua-ti/qi-ta/1254-number-of-closed-islands/"},{"title":"15 3sum","text":"æ€è·¯ï¼š ç®€å•çš„è¯´ï¼Œå…ˆæœ‰åºåŒ–ï¼Œå†äºŒé‡å¾ªç¯éå†å‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œç¬¬ä¸‰ä¸ªæŒ‡é’ˆé‡‡ç”¨äºŒåˆ†æ³•å³å¯ã€‚æ³¨æ„è·³è¿‡é‡å¤å€¼ æ›´å·§å¦™çš„è§£æ³•â€”â€”åŒæŒ‡é’ˆè§£æ³•ã€‚å…ˆæœ‰åºåŒ–ï¼Œéå†ç¬¬ä¸€ä¸ªæ•°å­—çš„åŒæ—¶ï¼Œé‡‡ç”¨åŒæŒ‡é’ˆä»ä¸¤è¾¹é€¼è¿‘ç»“æœã€‚ å®é™…ä¸Šè¿™æ˜¯å¯¹æ•°ç»„æœ‰åºçš„åˆ©ç”¨ã€‚ äºŒé‡å¾ªç¯ + äºŒåˆ† class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt; vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); // for(int i = 0;i &lt; len; i++) // printf(&quot;%d&quot;, nums[i]); for(int i=0; i &lt; len - 2; i++){ //æ’é™¤é‡å¤ç»“æœ if(i!=0 &amp;&amp; nums[i-1] == nums[i]) continue; for(int j=i + 1; j &lt; len - 1; j++){ //æ’é™¤é‡å¤ç»“æœ if(j!=i+1 &amp;&amp; nums[j] == nums[j-1]) continue; int ld = j + 1, rd = len - 1, mid; while(ld &lt; rd){ mid = (ld + rd ) / 2; if( nums[mid] + nums[i] + nums[j] &gt;= 0) rd = mid; else ld = mid + 1; // æ³¨æ„è¿™é‡Œå‘ä¸ŠäºŒåˆ†çš„æ—¶å€™ï¼Œ midæ²¡æœ‰å˜åŠ¨ï¼ŒåŒæ—¶å¾ªç¯å¯èƒ½ç»“æŸã€‚å¯¼è‡´äº†midçš„å€¼å¯èƒ½åœ¨æŸç§æƒ…å†µä¸‹é›¨rdldä¸åŒ ï¼Œæ‰€ä»¥å¾ªç¯ç»“æŸæœ€å¥½é€‰ldæˆ–è€…rd } // printf(&quot;%d &quot;, mid); if(nums[rd] + nums[i] + nums[j] == 0){ res.push_back({nums[i], nums[j], nums[rd]}); } } } return res; } }; åŒæŒ‡é’ˆæ³• class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt; vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); for(int i=0;i &lt; len - 2; i++){ // æ’é™¤é‡å¤ç»“æœ if(i !=0 &amp;&amp; nums[i] == nums[i-1]) continue; int j = i + 1, k = len - 1; while(j &lt; k){ int sum = nums[i] + nums[k] + nums[j]; // æ’é™¤é‡å¤ç»“æœ if(j != i + 1 &amp;&amp; nums[j] == nums[j-1]){ j++; continue; } if(k != len -1 &amp;&amp; nums[k] == nums[k+1]){ k--; continue; } if(sum &gt; 0) k--; else if(sum &lt; 0) j++; else{ res.push_back({nums[i], nums[j], nums[k]}); j++, k--; } } } return res; } }; #äºŒåˆ†TWO POINTERS","link":"/2020/08/07/shua-ti/qi-ta/15-3sum/"},{"title":"240. Search a 2D Matrix II","text":"240. Search a 2D Matrix IIæ€è·¯ï¼šç”±äºmatrixåœ¨è¡Œå’Œåˆ—ä¸Šçš„é€’å¢ï¼Œ åœ¨å·¦ä¸‹è§’å’Œå³ä¸Šè§’æœ‰ç‰¹æ®Šçš„æ€§è´¨ã€‚åœ¨å·¦ä¸‹è§’æœ‰ï¼ŒA[i][j]æ¯”ä¸Šé¢çš„æ•°å­—éƒ½æ‰“ï¼Œ æ¯”å³è¾¹çš„æ•°å­—éƒ½å°ã€‚æ‰€ä»¥å¯ä»¥æ¯”è¾ƒtargetå’ŒA[i][j]æ•°å­—å¤§å°æ¥æ’é™¤ï¼Œä¸Šé¢ä¸€åˆ—æˆ–è€…å³è¾¹ä¸€è¡Œçš„æ‰€æœ‰æ•°å­—ã€‚é€’å½’çš„ä¸‹å»å¯ä»¥æœç´¢åˆ°åº”æœ‰çš„æ•°å­—ã€‚ å¦‚æœæ²¡æœ‰å°±ä¼šå‡ºç•Œã€‚ ä»£ç ï¼šclass Solution { public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int x, y, n = matrix.size(); x = n - 1; y = 0; while(x != 0 || y != n -1){ if(target == matrix[x][y]) return true; else if(target &gt; matrix[x][y]) y++; else if(target &lt; matrix[x][y]) x--; if(x &lt; 0 || y &gt;= n) return false; } return false; } };","link":"/2021/01/22/shua-ti/qi-ta/240-search-a-2d-matrix-ii/"},{"title":"303. Range Sum Query - Immutable","text":"303. Range Sum Query - Immutableæ€è·¯ï¼šå‰ç¼€å’Œ ä»£ç ï¼šclass NumArray { vector&lt;int&gt; nums; public: NumArray(vector&lt;int&gt;&amp; _nums) : nums(_nums) { nums.insert(nums.begin(), 0); for(int i = 1; i &lt; nums.size(); ++i) nums[i] += nums[i - 1]; } int sumRange(int i, int j) { return nums[j + 1] - nums[i]; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(i,j); */","link":"/2021/01/29/shua-ti/qi-ta/303-range-sum-query-immutable/"},{"title":"304. Range Sum Query 2D - Immutable","text":"304. Range Sum Query 2D - Immutableæ€è·¯ï¼šäºŒç»´å‰ç¼€å’Œï¼Œä¸ä»…æ˜¯è®¡ç®—äºŒç»´çŸ©é˜µä¹‹å’Œçš„è¿‡ç¨‹å¯ä»¥ç”¨äºŒç»´çŸ©é˜µç»„åˆèµ·æ¥ï¼Œè€Œä¸”äºŒç»´å‰ç¼€å’Œçš„è®¡ç®—è¿‡ç¨‹ä¹Ÿå¯ä»¥ç”¨ä¹‹å‰è®¡ç®—çš„çŸ©é˜µç®€åŒ–è®¡ç®—ã€‚ $o(n^2)$ ä»£ç ï¼š class NumMatrix { vector&lt;vector&lt;int&gt;&gt; summax; public: NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size() + 1; if(n == 1) return; int m = matrix[0].size() + 1; summax.resize(n); summax[0].resize(m); for(int i = 1; i &lt; n; ++i){ summax[i].resize(m + 1); for(int j = 1; j &lt; m; ++j){ summax[i][j] = matrix[i - 1][j - 1] + summax[i - 1][j] + summax[i][j - 1] - summax[i - 1][j - 1]; // cout &lt;&lt; summax[i][j] &lt;&lt; ' '; } // cout &lt;&lt; endl; } } int sumRegion(int row1, int col1, int row2, int col2) { return summax[row2 + 1][col2 + 1] - summax[row2 + 1][col1] - summax[row1][col2 + 1] + summax[row1][col1]; // return 0; } }; /** * Your NumMatrix object will be instantiated and called as such: * NumMatrix* obj = new NumMatrix(matrix); * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2); */","link":"/2021/01/29/shua-ti/qi-ta/304-range-sum-query-2d-immutable/"},{"title":"326. Power of Three","text":"326. Power of Threeç›´æ¥ä¸Šä»£ç ï¼š æ€è·¯ class Solution { public: bool isPowerOfThree(int n) { if(n == 1) return true; if(n &lt; 3) return false; int newn; while(n &gt;= 3){ newn = n / 3; if(newn * 3 != n) return false; n = newn; } return n == 1; } }; ä¸æ–­æ•´é™¤åˆ¤æ–­ä½™æ•°æ˜¯å¦ä¸ºé›¶ class Solution { public: bool isPowerOfThree(int n) { if(n &lt; 1) return false; while(n % 3 == 0){ n /= 3; } return n == 1; } }; 3çš„k+1æ¬¡å¹‚å¿…å®šå¯ä»¥è¢«3çš„kæ¬¡å¹‚æ•´é™¤ class Solution { public: bool isPowerOfThree(int n) { // int maxn = pow(3,floor(log(INT_MAX) / log(3))); //1162261467 // cout &lt;&lt; maxn &lt;&lt; endl; return n &gt; 0 &amp;&amp; 1162261467 % n == 0; } }; 3è¿›åˆ¶ç®—æ³•ï¼šæ•°1 class Solution { public: bool isPowerOfThree(int n) { int ct = 0, oldn = n; while(n){ ct += n % 3; if(ct &gt; 1) return false; n /= 3; } return oldn &gt; 0; } };","link":"/2021/01/08/shua-ti/qi-ta/326-power-of-three/"},{"title":"341. Flatten Nested List Iterator","text":"341. Flatten Nested List Iterator æ€è·¯ï¼šç¼“å­˜lazyæ³• stackå­˜å‚¨éå†ç©ºé—´æ³• ä»£ç ï¼š/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */ class NestedIterator { public: int pos = 0; queue&lt;int&gt; que; vector&lt;NestedInteger&gt; nestedList; NestedIterator(vector&lt;NestedInteger&gt; &amp;_nestedList) { // que.clear(); nestedList = _nestedList; } int next() { if(hasNext()){ int nexti = que.front(); que.pop(); return nexti; } return -1; } bool hasNext() { if(que.empty()){ if(nestedList.size() == pos){ return false; } //ä¸è¦å¿˜è®°pos+ while(pos != nestedList.size() &amp;&amp; que.empty()){ getInt2que(nestedList[pos++]); } } if(que.empty()) return false; else return true; } void getInt2que(NestedInteger ni){ if(ni.isInteger()){ que.push(ni.getInteger()); }else{ vector&lt;NestedInteger&gt; list = ni.getList(); for(auto item :list){ getInt2que(item); } } } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ ä¸å¤Ÿæœºæ™ºçš„å®ç° /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */ class NestedIterator { using nestedVecIt = vector&lt;NestedInteger&gt;::iterator; stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested; public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) { if(nestedList.size() &gt; 0) nested.push({nestedList.begin(), nestedList.end()}); } bool hasNext() { locate(); return !nested.empty(); } void locate(){ if(nested.size() == 0) return; while(nested.size()){ auto&amp; [itnested, itend] = nested.top(); if(itnested == itend) nested.pop(); else if(!itnested-&gt;isInteger()){ auto &amp; veclist = itnested-&gt;getList(); ++itnested; nested.push({veclist.begin(), veclist.end()}); } else break; } } int next() { if( hasNext()){ auto&amp; [itnested, itend] = nested.top(); int nextv = 0; if(itnested-&gt;isInteger()){ nextv = itnested-&gt;getInteger(); ++itnested; return nextv; } else{ auto &amp; nestedList = itnested-&gt;getList(); ++itnested; // æ— è®ºæ˜¯æ•°å­—è¿˜æ˜¯æ•°ç»„éƒ½è¦å‘å‰éå† nested.push({nestedList.begin(), nestedList.end()}); return next(); } } return -1; } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */ æ›´ä¼˜é›…çš„å®ç° /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger { * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * }; */ class NestedIterator { using nestedVecIt = vector&lt;NestedInteger&gt;::iterator; stack&lt;pair&lt;nestedVecIt, nestedVecIt&gt; &gt; nested; public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) { if(nestedList.size() &gt; 0) nested.push({nestedList.begin(), nestedList.end()}); } bool hasNext() { while(nested.size()){ auto&amp; [itnested, itend] = nested.top(); if(itnested == itend) nested.pop(); else if(!itnested-&gt;isInteger()){ auto &amp; veclist = itnested++-&gt;getList(); // è‡ªå¢åè·å– nestedList nested.push({veclist.begin(), veclist.end()}); } else break; } return !nested.empty(); } // ä¿è¯è°ƒç”¨å‰ æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ å­˜åœ¨ä¸”ä¸ºæ•°å­— int next() { return nested.top().first++-&gt;getInteger(); } }; /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */","link":"/2020/09/25/shua-ti/qi-ta/341-flatten-nested-list-iterator/"},{"title":"406. Queue Reconstruction by Height","text":"æ€è·¯ï¼šè´ªå¿ƒç­–ç•¥ï¼Œå› ä¸ºé˜Ÿåˆ—çš„å”¯ä¸€æ€§ï¼Œä»å¤´åˆ°å°¾reconstructå³å¯ã€‚ æŒ‰kå‡åºå†æŒ‰hé™åºï¼Œå†æŒ‰kå€¼æ’å…¥ã€‚éœ€è¦åœ¨æ’å…¥çš„åŒæ—¶ç»Ÿè®¡ç»´æŠ¤å‰é¢èº«é«˜å¤§äºhçš„äººæ•°å³å¯ã€‚ ä»£ç ï¼šclass Solution { public: int countBigger(int pos, vector&lt;vector&lt;int&gt;&gt; &amp;people){ int res = 0; for(int i = pos -1; i &gt;= 0; --i){ if(people[i][0] &gt;= people[pos][0]) res++; } return res; } vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) { sort(people.begin(), people.end(), [](vector&lt;int&gt;a, vector&lt;int&gt;b){ if(a[1] == b[1]) return a[0] &lt; b[0]; else return a[1] &lt; b[1]; }); int n = people.size(); for(int i = 0; i &lt; n; ++i){ int c = countBigger(i, people); int k = i; while(c &gt; people[k][1]){ if(people[k-1][0] &gt;= people[k][0]) c--; swap(people[k], people[k - 1]); k--; } } return people; } };","link":"/2020/10/15/shua-ti/qi-ta/406-queue-reconstruction-by-height/"},{"title":"448. Find All Numbers Disappeared in an Array","text":"448. Find All Numbers Disappeared in an Arrayæ€è·¯ï¼šæŠŠnumså½“åšå·²ç»å‡ºç°çš„å…ƒç´ çš„å‘é‡è¡¨ï¼Œé‡ç‚¹æ˜¯éå†çš„å…ƒç´ è¿‡ç¨‹ä¸­â€é€’å½’â€åœ°ç½®ä½å…ƒç´ ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt; nums.size(); ++i){ int t = nums[i]; if(t &lt; 0) continue; while(nums[t - 1] &gt; 0){ int newt = nums[t - 1]; nums[t - 1] = nums[t - 1] == -1 ? -2 : -1; t = newt; } } vector&lt;int&gt; ans; for(int i = 0; i &lt; nums.size(); ++i){ if(nums[i] &gt; 0) ans.push_back(i + 1); } return ans; } };","link":"/2021/01/22/shua-ti/qi-ta/448-find-all-numbers-disappeared-in-an-array/"},{"title":"48. Rotate Image","text":"48. Rotate Imageæ€è·¯ï¼šåŸåœ°ç¿»è½¬çš„æ€è·¯ï¼šæ¯”è¾ƒç®€å•ã€‚ ç¿»è½¬åšæ³•ã€‚å…ˆä¸Šä¸‹ç¿»è½¬ï¼Œ åå¯¹è§’çº¿ç¿»è½¬ å››ä¸ªå¯¹åº”çš„çŸ©é˜µå…ƒç´ ä½œä¸ºæ—‹è½¬ç‚¹ï¼Œé¡ºåŠ¿å°†çŸ©é˜µåˆ’åˆ†ä¸ºå››ä¸ªæ—‹è½¬éƒ¨åˆ†ã€‚éå†ä¸€ä¸ªéƒ¨åˆ†å¹¶æ—‹è½¬å…¶ä¸­æˆç»„çš„æ‰€æœ‰å…ƒç´ å³å¯ã€‚ ä»£ç ï¼šæ²™é›•ä»£ç ï¼š class Solution { public: void rotate_ele(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;matrix){ int n = matrix.size() - 1; vector&lt;pair&lt;int, int&gt;&gt; idx; idx.push_back({x, y}); idx.push_back({y, n - x}); idx.push_back({n - x, n- y}); idx.push_back({n- y, x}); int ordv = matrix[idx[0].first][idx[0].second]; for(int i = 0; i &lt; 4; ++i){ int bi = (i + 1) % 4; int &amp;rotated = matrix[idx[bi].first][idx[bi].second]; // alias; int newv = rotated; rotated = ordv; ordv = newv; } // for(int i = 0; i &lt; n + 1; ++i){ // for(int j = 0; j &lt; n + 1; ++j){ // cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;; // } // cout &lt;&lt; endl; // } } //å‘ç°æ—‹è½¬è§„å¾‹ // 1, 0 // 0, 2 // 2, 3 // 3, 1 // 0, 0 // 0, 3 // 3, 3 // 3, 0 void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.size() == 0) return; int cerX, cerY; cerX = cerY = (matrix.size() - 1) / 2; // ä¸­é—´æ•°ä¸‹æ ‡ //åˆ’åˆ†æ—‹è½¬ç‚¹ // æŒ‰ä¸€ä¸ªç‚¹æ—‹è½¬å¯¹åº”çš„4ä¸ªç‚¹ï¼Œç»„æˆä¸€ç»„è¿›è¡Œæ—‹è½¬ã€‚å„ä¸ªç»„çš„æ—‹è½¬èµ·ç‚¹å¦‚ä¸‹ï¼š // 1 1 1 0 // 0 1 0 0 // 0 0 0 0 // 0 0 0 0 // 1 1 0 // 0 1 0 // 0 0 0 for(int i = 0; i &lt;= cerX; ++i){ for(int j = i; j &lt; matrix.size() - 1 - i; ++j){ rotate_ele(i, j, matrix); } } } }; ç®€åŒ–ä¸€ä¸‹ class Solution { public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.size() == 0) return; int cerX, cerY, n = matrix.size() - 1; cerX = cerY = (matrix.size() - 1) / 2; // ä¸­é—´æ•°ä¸‹æ ‡ for(int i = 0; i &lt;= cerX; ++i){ for(int j = i; j &lt; matrix.size() - 1 - i; ++j){ int temp = matrix[i][j]; matrix[i][j] = matrix[n - j][i]; matrix[n - j][i] = matrix[n - i][n - j]; matrix[n - i][n - j] = matrix[j][n - i]; matrix[j][n - i] = temp; } } } }; ç¿»è½¬åšæ³• class Solution { public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if(matrix.size() == 0) return; int cerX, cerY, n = matrix.size() - 1; cerX = cerY = (matrix.size() - 1) / 2; // ä¸­é—´æ•°ä¸‹æ ‡ // ä¸Šä¸‹ç¿»è½¬ for(int i = 0; i &lt;= cerX; ++i){ for(int j = 0; j &lt; matrix.size(); ++j){ swap(matrix[i][j], matrix[n - i][j]); } } // å¯¹è§’çº¿ç¿»è½¬ for(int i = 0; i &lt;= matrix.size(); ++i){ for(int j = i + 1; j &lt; matrix.size(); ++j){ swap(matrix[i][j], matrix[j][i]); } } } };","link":"/2021/01/22/shua-ti/qi-ta/48-rotate-image/"},{"title":"524. Longest Word in Dictionary through Deleting","text":"524. Longest Word in Dictionary through Deleting2020.10.22æ—¥ è¿™é¢˜è¿˜æ˜¯ç¨å¾®é”»ç‚¼äº†ä¸€ä¸‹æˆ‘ã€ æ€è·¯ï¼šä¸ºäº†å°½é‡é™ä½ä»£ç å¤æ‚åº¦ï¼Œæˆ‘é€‰æ‹©äº†ç”¨hashä¿ç•™åœ°å€æ³•å­˜å‚¨æ¯ä¸ªç›¸åŒå­—ç¬¦çš„ä½ç½®ã€‚åœ¨éå†å­—å…¸ä¸­æ¯ä¸ªå­—ç¬¦ä¸­ï¼Œåˆ¤æ–­æ¯ä¸ªå­—ç¬¦ä¸²çš„å­—ç¬¦åˆç†å‡ºç°ä½ç½®ï¼ŒäºŒåˆ†hashé“¾å¼è¡¨ä¸­æ¯ä¸ªå­—ç¬¦çš„å¯èƒ½ä½ç½®å³å¯ã€‚ ä»£ç è™½ç„¶å¤æ‚ä¸€ç‚¹ï¼Œä½†æ˜¯å¾ˆå¿«ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(logL(s) * L(d[argmax\\ len(d[i])] * d.size()))$ ä»£ç ï¼šå…¶ä»–äººçš„çš„åŒæŒ‡é’ˆæ³•ï¼šå¾ˆæ…¢ class Solution { private: bool isZichuan(string target, string s) { //åˆ†åˆ«ä»å·¦ç«¯å¼€å§‹ç´¢å¼•ï¼Œæ£€æµ‹æ˜¯å¦ä¸ºå­åˆ— int i = 0, j = 0; while(i &lt; target.size() &amp;&amp; j &lt; s.size()) { if(target[i] == s[j]) i++; j++; } return i == target.size(); } public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) { string str = &quot;&quot;; for(int i = 0; i &lt; d.size(); i++) { int tag = str.length(); int leng = d[i].length(); //è‹¥å­—ç¬¦ä¸²æ›´çŸ­æˆ–è€…ä¸€æ ·é•¿ä¸”å­—æ¯é¡ºåºè¾ƒå¤§çš„ç›´æ¥èˆå» if(tag &gt; leng || (tag == leng &amp;&amp; str.compare(d[i]) &lt; 0)) continue; if(isZichuan(d[i], s)) { str = d[i]; } }a return str; } }; ä½œè€…ï¼šlu-guo-de-feng-2 é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/solution/zhi-xing-yong-shi-60-ms-zai-suo-you-c-ti-jiao-zh-3/ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ å‡»è´¥99.7% class Solution { public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) { vector&lt;int&gt; map[26]; for(int i = 0; i &lt; s.size(); i++){ map[s[i] - 'a'].push_back(i); } string maxs = &quot;&quot;; for(int i = 0; i &lt; d.size(); ++i){ int s = -1, flag = 1; for(int j = 0; j &lt; d[i].size(); ++j){ int cp = d[i][j] - 'a'; int l = 0, r = map[cp].size(), mid; while(l &lt; r){ mid = (l + r) / 2; if(map[cp][mid] &gt; s) r = mid; else l = mid + 1; } if(l == map[cp].size() || s &gt;= map[cp][l]){ flag = 0; break; } s = map[cp][l]; } // cout &lt;&lt; endl; if(flag &amp;&amp; ( maxs.size() &lt; d[i].size() || maxs.size() == d[i].size() &amp;&amp; maxs &gt; d[i])) maxs = d[i]; } return maxs; } };","link":"/2020/10/22/shua-ti/qi-ta/524-longest-word-in-dictionary-through-deleting/"},{"title":"540. Single Element in a Sorted Array","text":"540. Single Element in a Sorted Arrayæ€è·¯ï¼šè®¾è®¡ä¸€ä¸ªäºŒåˆ†å³å¯ã€‚ ä»£ç ï¼šclass Solution { public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int l = 0, r = n - 1, mid; while(l &lt; r){ mid = (l + r) / 2; int ct; if(mid == 0) return nums[0]; if(nums[mid] == nums[mid + 1]) ct = mid; else if(nums[mid] == nums[mid - 1]) ct = mid - 1; else return nums[mid]; if( (n - ct) % 2 == 0) r = mid; else l = mid + 1; } return nums[l]; } };","link":"/2020/11/09/shua-ti/qi-ta/540-single-element-in-a-sorted-array/"},{"title":"560. Subarray Sum Equals K","text":"560. Subarray Sum Equals Kæ€è·¯ï¼šhash+ å‰ç¼€ã€‚ ä»£ç ï¼šclass Solution { public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(n == 0) return 0; vector&lt;int&gt; dp(n + 1); unordered_map&lt;int, int&gt; map; int ct = 0; map[0] = 1; for(int i = 1; i &lt; n + 1; ++i) { dp[i] = dp[i - 1 ] + nums[i - 1]; ct += map[dp[i] - k]; map[dp[i]]++; } return ct; } }; //é”™è¯¯äºŒåˆ†ï¼Œæ•°ç»„ä¸ä¿è¯éƒ½ä¸ºæ­£æ•° // class Solution { // public: // int subarraySum(vector&lt;int&gt;&amp; nums, int k) { // int n = nums.size(); // if(n == 0) return 0; // vector&lt;int&gt; dp(n + 1); // for(int i = 1; i &lt; n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1]; // int ct = 0; // for(int i = 0; i &lt; n; ++i){ // int r = n - 1; // int l = i; // while(l &lt; r){ // int mid = (l + r) / 2; // if(dp[mid + 1] - dp[i] &gt;= k) r = mid; // else l = mid + 1; // } // if(l &lt; n &amp;&amp; dp[l + 1] - dp[i] == k) ct++; // } // return ct; // } // }; // class Solution { // public: // int subarraySum(vector&lt;int&gt;&amp; nums, int k) { // int n = nums.size(); // if(n == 0) return 0; // vector&lt;int&gt; dp(n + 1); // for(int i = 1; i &lt; n + 1; ++i) dp[i] = dp[i - 1 ] + nums[i - 1]; // int ct = 0; // for(int i = 0; i &lt; n; ++i){ // for(int j = i; j &lt; n; ++j) // if(k == dp[j + 1] - dp[i]) ct++; // } // return ct; // } // };","link":"/2021/01/29/shua-ti/qi-ta/560-subarray-sum-equals-k/"},{"title":"566. Reshape the Matrix","text":"566. Reshape the Matrixæ€è·¯ï¼š ä»ä»Šå¤©èµ·ï¼Œæœ‰äº›æ°´é¢˜å°±ä¸å†™äº†ã€‚æµªè´¹æ—¶é—´äº†ã€‚ ä»£ç ï¼šclass Solution { public: class Iter{ int i ,j; int n, m; public: vector&lt;vector&lt;int&gt;&gt; &amp;nums; // Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums){ Iter(vector&lt;vector&lt;int&gt;&gt; &amp;_nums): nums(_nums){ i =0, j = 0; n = nums.size(); m = (n == 0) ? 0 : nums[0].size(); } bool empty(){ return i &gt; n - 1 || i == n - 1 &amp;&amp; j &gt; m - 1; } int&amp; next(){ if(j == m){ j = 0; i = i + 1; } // cout &lt;&lt; nums[i][j] &lt;&lt; endl; return nums[i][j++]; } }; vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) { if(nums.size() == 0 || nums.size() * nums[0].size() != r * c) return vector&lt;vector&lt;int&gt;&gt;(nums); int n = nums.size(); int m = nums[0].size(); vector&lt;vector&lt;int&gt;&gt; mat(r, vector&lt;int&gt;(c)); Iter p1(nums), p2(mat); while(!p1.empty()){ p2.next() = p1.next(); } // cout &lt;&lt; p1.nums[0][0] &lt;&lt; endl; // cout &lt;&lt; p2.nums[0][0] &lt;&lt; endl; return p2.nums; } };","link":"/2021/01/30/shua-ti/qi-ta/566-reshape-the-matrix/"},{"title":"605. Can Place Flowers","text":"605. Can Place Flowersè¿™é¢˜è¿˜æ˜¯å…¸å‹çš„è´ªå¿ƒï¼Œä¸è¿‡å†™çš„æ—¶å€™ntï¼› æ€è·¯ï¼šç”¨è´ªå¿ƒçš„ç­–ç•¥å°½å¯èƒ½å…ˆç§èŠ±ï¼Œè¿™ç§ç­–ç•¥ä¸ä¼šå½±å“ç»“æœã€‚åªéœ€è¦åœ¨éå†ä¸‹è€ƒè™‘ä¸¤è¾¹å’Œè¾¹ç•Œæƒ…å†µå°±è¡Œäº†ã€‚ ä»£ç ï¼š class Solution { public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int res = 0, fn = flowerbed.size(); for(int i = 0; i &lt; flowerbed.size(); ++i){ if(flowerbed[i] == 0 &amp;&amp; (i == 0 || flowerbed[i - 1] == 0) &amp;&amp; (fn - 1 == i ||flowerbed[i + 1] == 0 )){ ++res; flowerbed[i] = 1; } } return res &gt;= n; } }; ç‰ˆæœ¬äºŒï¼š class Solution { public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int res = 0, fn = flowerbed.size(); if(fn == 1 &amp;&amp; flowerbed[0] == 0) return n &lt;= 1; for(int i = 0; i &lt; flowerbed.size(); ++i){ if(flowerbed[i] == 0 &amp;&amp; ( i == 0 &amp;&amp; flowerbed[1] == 0 || i == (fn - 1) &amp;&amp; flowerbed[fn - 2] == 0 || (i &lt; fn - 1 &amp;&amp; i &gt; 0 &amp;&amp; flowerbed[i -1] ==0 &amp;&amp; flowerbed[i + 1] == 0))){ ++res; flowerbed[i] = 1; } } return res &gt;= n; } };","link":"/2020/10/13/shua-ti/qi-ta/605-can-place-flowers/"},{"title":"697. Degree of an Array","text":"697. Degree of an Arrayæ€è·¯ï¼šç®€å•éå†ï¼Œä¸è¿‡æ•°æ®ç»™çš„æ°´ï¼Œå¯ä»¥ç¨ç¨æ”¾æ¾ä¸€ä¸‹éå†çš„èŒƒå›´ï¼Œå°±ä¸ç”¨å†™è¿™ä¹ˆé•¿äº†0 ä»£ç ï¼šclass Solution { public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) { map&lt;int, int&gt; s ,e, fre; int maxfre = 1; vector&lt;int&gt; maxnum(1, nums[0]); for(int i = 0; i &lt; nums.size(); i++){ int t = nums[i]; if(fre[t] == 0){ s[t] = i; } fre[t]++; if(maxfre &lt; fre[t]){ maxfre = fre[t]; maxnum.clear(); maxnum.push_back(t); }else if(maxfre == fre[t]) maxnum.push_back(t); e[t] = i; } int lens = 0x0fffffff; for(int i = 0;i &lt; maxnum.size(); i++){ lens = min(e[maxnum[i]] - s[maxnum[i]] + 1, lens); } return lens; } };","link":"/2020/10/11/shua-ti/qi-ta/697-degree-of-an-array/"},{"title":"747. Largest Number At Least Twice of Others","text":"747. Largest Number At Least Twice of Others EZ æ€è·¯ï¼šæ²™é›•é¢˜ç›®ã€‚ ä»£ç ï¼šclass Solution { public: int dominantIndex(vector&lt;int&gt;&amp; nums) { int numbig = -1, numlitter= -1, idx = -1; if(nums.size() == 1) return 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] &gt; numbig){ idx = i; numlitter = numbig; numbig = nums[i]; } else if(nums[i] &gt; numlitter){ numlitter = nums[i]; } } if(numbig &gt;= numlitter * 2 ){ return idx; } else return -1; } };","link":"/2020/09/24/shua-ti/qi-ta/747-largest-number-at-least-twice-of-others/"},{"title":"769. Max Chunks To Make Sorted","text":"769. Max Chunks To Make Sortedæ€è·¯ï¼šæš´åŠ›æ³•ã€‚ ç®€å•çš„æ€è·¯ï¼Œ ä»å·¦åˆ°å³åˆ’åˆ†chrunkï¼Œåˆ¤æ–­æœ€å·¦è¾¹çš„chrunkæœ€å¤§å€¼ï¼Œå…¶å€¼+1å°±æ˜¯chrunkçš„sizeã€‚ ä¾æ¬¡è¿›è¡Œå°±å¯ä»¥è·å¾—å¤šä¸ªchrunkçš„sizeã€‚ ä»£ç ï¼šclass Solution { public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int split = -1; int num = 0; for(int i = 0; i &lt; arr.size(); ++i){ split = arr[i]; for(int j = 0; j &lt; split + 1; ++j){ split = max(split, arr[j]); } num++; i = split; } return num; } };","link":"/2021/01/22/shua-ti/qi-ta/769-max-chunks-to-make-sorted/"},{"title":"786. ç¬¬ K ä¸ªæœ€å°çš„ç´ æ•°åˆ†æ•°","text":"786. ç¬¬ K ä¸ªæœ€å°çš„ç´ æ•°åˆ†æ•°éš¾åº¦hard æ€è·¯ï¼šæ˜æ˜¾çš„æœ‰A[i] &lt; A[j]ï¼Œèƒ½å¤Ÿæ¨å‡ºA[i]/A[j] &gt; A[i]/A[j+1]ï¼Œä½†æ˜¯ä¸èƒ½æ¨å‡ºA[i+1]/A[j]å’ŒA[i]/A[j+1]çš„å…³ç³»ï¼Œæ¯«æ— ç”¨å¤„ã€‚ è‡ªç„¶å¯ä»¥æƒ³åˆ°è¦ç”¨å †æ¥ç»´æŠ¤ç¬¬Kå°çš„æ•°ï¼Œè€Œç„¶è¶…æ—¶ã€‚ è¯„è®ºé‡Œæå‡ºä¸€ç§äºŒåˆ†çš„æ–¹æ³•ï¼Œ ä»£ç ï¼šå †ç»´æŠ¤æ•°ç»„ struct cmp{ bool operator () (pair&lt;int, int&gt; x, pair&lt;int, int&gt; y){ return x.first * 1.0 / x.second &lt; y.first * 1.0 / y.second; } }; class Solution { public: vector&lt;int&gt; kthSmallestPrimeFraction(vector&lt;int&gt;&amp; A, int K) { priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, cmp&gt; pq; for(int i = 0; i &lt; A.size() - 1; i++){ for(int j = i + 1; j &lt; A.size(); j++){ double temp = A[i] * 1.0 / A[j]; if(pq.size() &lt; K){ pq.push(make_pair(A[i], A[j])); }else if(pq.top().first * 1.0 / pq.top().second &gt; temp){ pq.pop(); pq.push(make_pair(A[i], A[j])); } } } vector&lt;int&gt; res = vector(2, 0); res[0] = pq.top().first, res[1] = pq.top().second; return res; } };","link":"/2020/08/07/shua-ti/qi-ta/786-di-k-ge-zui-xiao-de-su-shu-fen-shu/"},{"title":"79. Word Search","text":"79. Word Searchæ€è·¯ï¼šå›æº¯ç›´æ¥k.o. ä»£ç ï¼šå®˜æ–¹ class Solution { public: bool check(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt;&amp; visited, int i, int j, string&amp; s, int k) { if (board[i][j] != s[k]) { return false; } else if (k == s.length() - 1) { return true; } visited[i][j] = true; vector&lt;pair&lt;int, int&gt;&gt; directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; bool result = false; for (const auto&amp; dir: directions) { int newi = i + dir.first, newj = j + dir.second; if (newi &gt;= 0 &amp;&amp; newi &lt; board.size() &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].size()) { if (!visited[newi][newj]) { bool flag = check(board, visited, newi, newj, s, k + 1); if (flag) { result = true; break; } } } } visited[i][j] = false; return result; } bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { int h = board.size(), w = board[0].size(); vector&lt;vector&lt;int&gt;&gt; visited(h, vector&lt;int&gt;(w)); for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { bool flag = check(board, visited, i, j, word, 0); if (flag) { return true; } } } return false; } }; ä½œè€…ï¼šLeetCode-Solution é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ æˆ‘æ»´ï¼Œä¸è¿‡ç”±äºæ²¡æœ‰æŠŠåˆ¤æ–­æ¡ä»¶å†™åœ¨dfså‡½æ•°å…¥å£é‚£ï¼Œæ€§èƒ½æ˜¾å¾—ä¸å¤ªå¥½ã€‚ class Solution { public: int m, n; int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, vector&lt;vector&lt;bool&gt;&gt; &amp;vis, int x, int y, int pos){ //BUGS VECTOR &amp; if(x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || vis[x][y] || pos == word.size()) return false; vis[x][y] = true; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; if(board[x][y] == word[pos]){ if(pos == word.size() - 1) return true; for(int i = 0;i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; if(dfs(board, word, vis, nx, ny, pos + 1)) return true; } } return false; } bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { m = board.size(); if(m &gt; 0){ n = board[0].size(); } for(int i = 0; i &lt; m; ++i){ for(int j = 0; j &lt; n; ++j){ if(word[0] == board[i][j]){ cout &lt;&lt; &quot;i * j&quot; ; vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, 0)); if(dfs(board, word, vis, i, j, 0)) return true; } } } return false; } };","link":"/2020/11/26/shua-ti/qi-ta/79-word-search/"},{"title":"833.å­—ç¬¦ä¸²ä¸­çš„æŸ¥æ‰¾ä¸æ›¿æ¢","text":"ä¸­ç­‰é¢˜ è¿™é¢˜å‘è¿˜æ˜¯å¾ˆå¤šçš„ï¼Œå¦‚è¾“å…¥æ•°æ®éæœ‰åºï¼Œè€ƒè™‘åœ¨åŒä¸€å­—ç¬¦ä¸²æ’å…¥æ—¶å¤šä¸ªå­—ç¬¦ä¸²æ›¿æ¢æ—¶åŸå­—ç¬¦ä¸²çš„ä¸‹æ ‡ç»´æŒæˆ–æ˜¯å¯æ’å…¥æ€§ã€‚ æ€è·¯1: å°†indexesæ‰€æ ‡è®°å‡ºçš„ä¸‹æ ‡æ˜ å°„ä¸ºè¾“å…¥æ•°æ®çš„æ¬¡åºï¼Œåœ¨æ’åºindexesæ¥æœ‰åºéå†Sã€‚ä¹‹åå°±æ˜¯åˆ¤æ–­å“ªäº›Sçš„å­—æ¯å¯ä»¥æ›¿æ¢å¹¶æ›¿æ¢ã€‚ æ€è·¯2ï¼ˆå®˜æ–¹ï¼‰ï¼š ä¸ºäº†é¡ºåºåœ°æ„é€ ç›®æ ‡å­—ç¬¦ä¸²ï¼Œå…ˆæ ‡è®°å‡ºSä¸­æ‰€æœ‰å¯æ›¿æ¢çš„ä½ç½®ï¼Œå¹¶é¡ºåºéå†ï¼ˆé€†åºæˆ–è€…æ­£åºéƒ½å¯ä»¥ï¼Œæ„é€ æ–¹æ³•ä¸åŒç½¢äº†ï¼‰ã€‚ ä¾æ®é¢˜æ„ï¼Œå¯ä»¥æ¨å‡ºä»åå‘å‰æ›¿æ¢ï¼Œå¯ä»¥é¿å…ä¸‹æ ‡å˜æ¢çš„é—®é¢˜ã€‚ class Solution { public: //é¢˜ç›®æ²¡çœ‹æ¸…,å¤šå†™äº†ä¸€ä¸ªè½¬åŒ–å¤§å°å†™å‡½æ•° string lowercase(string S){ // return A iterator; std::transform(S.begin(), S.end(), S.begin(), [](unsigned char c){return std::tolower(c);} ); return S; } //æ€è·¯1 string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) { int idx2 = indexes.size() - 1; vector&lt;int&gt; repl( indexes.size() ); //å°†æ’åºåçš„å­—ç¬¦ä¸²ä¸‹æ ‡æ˜ å°„å›åŸæ¥çš„ä¸‹æ ‡ //åŒæ—¶ä¸èƒ½ æŠŠæ’åºåçš„indexä¸‹æ ‡æ˜ å°„æˆ–è€…è¢«æ˜ å°„; map&lt;int, int&gt; match; for(int i=0;i&lt;indexes.size();i++) match[ indexes[i] ] = i; sort(indexes.begin(), indexes.end()); //åˆ¤æ–­é€†åºåˆ¤æ–­èƒ½å¦æ›¿æ¢ï¼Œè‹¥å¯ä»¥åˆ™é€†åºæ›¿æ¢ï¼› //é€†åºæ›¿æ¢ä¸å½±å“ä¹‹å‰çš„å¯æ›¿æ¢æ€§åˆ¤æ–­ for(int i=S.size()-1;i&gt;=0 &amp;&amp; idx2 &gt;=0 ;i--){ if(i == indexes[idx2]){ if(lowercase( S.substr(i, sources[match[i]].size())) == sources[match[i]] ) S.replace(i, sources[match[i]].size(), targets[match[i]]); idx2 --; } } return S; } // æ€è·¯2ï¼šå®˜æ–¹è§£çš„å®ç°ï¼Œä¹Ÿæ˜¯ç©ºé—´æ¢æ—¶é—´ string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) { //å¯¹Sæ¯ä¸ªå­—æ¯å¯¹æœ‰æ•ˆæ›¿æ¢çš„åˆ¤æ–­, å¹¶è®°å½•ä¸‹æ ‡ vector&lt;int&gt; match(S.size(), -1); for(int i=0 ;i&lt;indexes.size();i++){ if( S.substr(indexes[i], sources[i].size()) == sources[i]) match[ indexes[i] ] = i; } //åˆ¤æ–­é€†åºåˆ¤æ–­èƒ½å¦æ›¿æ¢ï¼Œè‹¥å¯ä»¥åˆ™é€†åºæ›¿æ¢ï¼› for(int i=S.size()-1;i&gt;=0 ;i--){ if(match[i] != -1){ S.replace(i, sources[match[i]].size(), targets[match[i]] ); } cout&lt;&lt; S &lt;&lt; endl; } return S; } };","link":"/2020/08/07/shua-ti/qi-ta/833-zi-fu-chuan-zhong-de-cha-zhao-yu-ti-huan/"},{"title":"88. Merge Sorted Array","text":"æ€è·¯ï¼šåŒæŒ‡é’ˆä»åå‘å‰åˆå¹¶å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$n(o)$ï¼Œç©ºé—´å¤æ‚åº¦$O(1)$ã€‚ ä»£ç ï¼šclass Solution { public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int pos = m + n - 1, p1 = m - 1, p2 = n - 1; while(p1 &gt;= 0 &amp;&amp; p2 &gt;= 0){ if(nums1[p1] &gt; nums2[p2]){ nums1[pos] = nums1[p1--]; }else{ nums1[pos] = nums2[p2--]; } pos--; } while(p2 &gt;= 0){ nums1[pos--] = nums2[p2--]; } } };","link":"/2020/10/17/shua-ti/qi-ta/88-merge-sorted-array/"},{"title":"934. Shortest Bridge","text":"934. Shortest Bridgeæ€è·¯ï¼šä¸€æ¬¡dfsæœç´¢ä¸€ä¸ªå²›å±¿ï¼Œä¸€æ¬¡bfsæœæœ€çŸ­è·¯å¾„ã€‚ ä»£ç ï¼šclass Solution { public: int n, m; int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; class Point{ public: int x; int y; int dis; Point(int _dis, int _x, int _y){ x = _x; y = _y; dis = _dis; } friend bool operator &lt;(const Point &amp;a, const Point &amp;b){ return a.dis &gt; b.dis; } }; bool check(int x, int y){ return !(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n ); } void getIslang(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; vis, priority_queue&lt;Point&gt; &amp;island, int x, int y){ if( !check(x,y) || vis[x][y] || A[x][y] == 0) return; island.push(Point(0, x, y)); vis[x][y] = 1; for(int i = 0; i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; getIslang(A, vis, island, nx , ny); } } int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) { m = A.size(); if(m == 0) return -1; n = A[0].size(); vector&lt;vector&lt;int&gt;&gt; vis(m, vector&lt;int&gt;(n, 0)); priority_queue&lt;Point&gt; que; int flag = 1; for(int i = 0; flag &amp;&amp; i &lt; m; ++i){ for(int j = 0; j &lt; n; ++j){ if(A[i][j] == 1){ flag = 0; getIslang(A, vis, que, i, j); break; } } } // cout &lt;&lt; que.size() &lt;&lt; endl; while(que.size()){ Point p = que.top(); que.pop(); // cout &lt;&lt; p.x &lt;&lt; &quot; &quot; &lt;&lt; p.y &lt;&lt; endl; for(int i = 0; i &lt; 4; ++i){ int nx = p.x + dx[i]; int ny = p.y + dy[i]; if(!check(nx, ny)) continue; if(!vis[nx][ny]){ vis[nx][ny] = 1; if(A[nx][ny] == 1){ return p.dis; }else{ que.push(Point(p.dis + 1, nx, ny)); } } } } return -1; } };","link":"/2020/11/28/shua-ti/qi-ta/934-shortest-bridge/"},{"title":"é¢16-æ•°å€¼çš„Næ¬¡æ–¹","text":"é¢˜é¢ï¼šç»™ä¸€ä¸ªæµ®ç‚¹æ•°ï¼Œæ±‚å‡ºå…¶æ•°å€¼çš„æ•´æ•°æ¬¡æ–¹ã€‚ æ€è·¯ï¼šä¸»è¦è€ƒç‚¹è¿˜æ˜¯åœ¨å¼‚å¸¸å¤„ç†è¿™æ–¹é¢ã€‚ç”±äºå¹‚ä¸ºæ•´æ•°ï¼Œåœ¨æ•ˆç‡ä¸Šå¯ä»¥è€ƒè™‘å¿«é€Ÿå¹‚ã€‚ ä»£ç ï¼šint power(double base, int exponent){ //æ— ç©·å¤§çš„éæ³•è®¡ç®—å€¼ if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); unsigned int posExponent = (unsigned int)exponent; double mulBase = base, mulRes = 1; while(posExponent &gt; 0){ if(posExponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; posExponent = posExponent &gt;&gt; 1; } if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; } å¯èƒ½é™ä½è€¦åˆæ›´å¥½ä¸€ç‚¹ double PowerWithUnsighedExponent(double base, unsigned int exponent){ //ç‰¹åˆ¤ï¼šåŸºæ•°ä¸º0ï¼›æŒ‡æ•°ä¸º0æ— éœ€ç‰¹åˆ¤ if( equla(base, 0.0)) return 0.0; double mulRes = 1; while(exponent &gt; 0){ if(exponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; exponent = exponent &gt;&gt; 1; } return mulRes; } int power(double base, int exponent){ //æ— ç©·å¤§çš„éæ³•è®¡ç®—å€¼ if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); double mulRes = PowerWithUnsignedExponent(base, exponent); if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; }","link":"/2020/08/07/shua-ti/qi-ta/mian-16-shu-zhi-de-n-ci-fang/"},{"title":"é¢è¯•é¢˜-é€’å½’è¿­ä»£","text":"æ”¶é›†ä¸€äº›ç»å…¸çš„é¢˜ç›® æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®— ä¸‰ç§æ€è·¯ï¼šé€’å½’ã€dpå’Œå¿«é€ŸçŸ©é˜µä¹˜ dp long long Fobonacci(unsigned n){ if(n &lt;= 0) return -1; long long fibN1 = 0; long long fibN2 = 1; if(n == 1) return fibN1; else if(n == 2) return fibN2; for(int k = 2; k &lt;= n; k++){ int temp = fibN2; fibN2 = fibN2 + fibN2; fibN1 = temp; } return fibN2; } æ€è·¯æ‰©å±•ï¼šé’è›™è·³å°é˜¶é—®é¢˜ï¼Œ1*2æ–¹å—é“ºè®¾é—®é¢˜ï¼Œ","link":"/2020/08/07/shua-ti/qi-ta/mian-shi-ti-di-gui-die-dai/"},{"title":"é¢è¯•é¢˜44ï¼š1å‡ºç°çš„ä¸ªæ•°","text":"å¹¿å—æ¬¢è¿çš„å‰‘æŒ‡offerçš„ç¥å¥‡æ€è·¯åœ¨ç½‘ç»œä¸Šä¼¼ä¹å¹¶ä¸å¤šè§ï¼Œæˆ‘ä¸ªäººä¹Ÿæ²¡çœ‹æ‡‚å¥¹çš„æ¨ç† é¢˜ç›®ï¼šç»Ÿè®¡ä»1åˆ°Nçš„æ‰€æœ‰æ•°å­—çš„1çš„å‡ºç°æ¬¡æ•°ã€‚ æ€è·¯ï¼šç¬¬ä¸€ç§ï¼šæ‰€æœ‰äººéƒ½èƒ½æƒ³å‡ºç›´æ¥æš´åŠ›è§£çš„ç®—æ³•ã€‚ ç¬¬äºŒç§ï¼šå‚è€ƒå…¶ä»–äººçš„è§£æ³•ã€‚ è®¾N = abcde ,å…¶ä¸­abcdeåˆ†åˆ«ä¸ºåè¿›åˆ¶ä¸­å„ä½ä¸Šçš„æ•°å­—ã€‚å¦‚æœè¦è®¡ç®—ç™¾ä½ä¸Š1å‡ºç°çš„æ¬¡æ•°ï¼Œå®ƒè¦å—åˆ°3æ–¹é¢çš„å½±å“ï¼šç™¾ä½ä¸Šçš„æ•°å­—ï¼Œç™¾ä½ä»¥ä¸‹ï¼ˆä½ä½ï¼‰çš„æ•°å­—ï¼Œç™¾ä½ä»¥ä¸Šï¼ˆé«˜ä½ï¼‰çš„æ•°å­—ã€‚â‘  å¦‚æœç™¾ä½ä¸Šæ•°å­—ä¸º0ï¼Œç™¾ä½ä¸Šå¯èƒ½å‡ºç°1çš„æ¬¡æ•°ç”±æ›´é«˜ä½å†³å®šã€‚æ¯”å¦‚ï¼š12013ï¼Œåˆ™å¯ä»¥çŸ¥é“ç™¾ä½å‡ºç°1çš„æƒ…å†µå¯èƒ½æ˜¯ï¼š100199ï¼Œ11001199,21002199ï¼Œï¼Œâ€¦ï¼Œ1110011199ï¼Œä¸€å…±1200ä¸ªã€‚å¯ä»¥çœ‹å‡ºæ˜¯ç”±æ›´é«˜ä½æ•°å­—ï¼ˆ12ï¼‰å†³å®šï¼Œå¹¶ä¸”ç­‰äºæ›´é«˜ä½æ•°å­—ï¼ˆ12ï¼‰ä¹˜ä»¥ å½“å‰ä½æ•°ï¼ˆ100ï¼‰ã€‚â‘¡ å¦‚æœç™¾ä½ä¸Šæ•°å­—ä¸º1ï¼Œç™¾ä½ä¸Šå¯èƒ½å‡ºç°1çš„æ¬¡æ•°ä¸ä»…å—æ›´é«˜ä½å½±å“è¿˜å—ä½ä½å½±å“ã€‚æ¯”å¦‚ï¼š12113ï¼Œåˆ™å¯ä»¥çŸ¥é“ç™¾ä½å—é«˜ä½å½±å“å‡ºç°çš„æƒ…å†µæ˜¯ï¼š100199ï¼Œ11001199,21002199ï¼Œï¼Œâ€¦.ï¼Œ1110011199ï¼Œä¸€å…±1200ä¸ªã€‚å’Œä¸Šé¢æƒ…å†µä¸€æ ·ï¼Œå¹¶ä¸”ç­‰äºæ›´é«˜ä½æ•°å­—ï¼ˆ12ï¼‰ä¹˜ä»¥ å½“å‰ä½æ•°ï¼ˆ100ï¼‰ã€‚ä½†åŒæ—¶å®ƒè¿˜å—ä½ä½å½±å“ï¼Œç™¾ä½å‡ºç°1çš„æƒ…å†µæ˜¯ï¼š1210012113,ä¸€å…±114ä¸ªï¼Œç­‰äºä½ä½æ•°å­—ï¼ˆ113ï¼‰+1ã€‚â‘¢ å¦‚æœç™¾ä½ä¸Šæ•°å­—å¤§äº1ï¼ˆ29ï¼‰ï¼Œåˆ™ç™¾ä½ä¸Šå‡ºç°1çš„æƒ…å†µä»…ç”±æ›´é«˜ä½å†³å®šï¼Œæ¯”å¦‚12213ï¼Œåˆ™ç™¾ä½å‡ºç°1çš„æƒ…å†µæ˜¯ï¼š100199,11001199ï¼Œ21002199ï¼Œâ€¦ï¼Œ1110011199,12100~12199,ä¸€å…±æœ‰1300ä¸ªï¼Œå¹¶ä¸”ç­‰äºæ›´é«˜ä½æ•°å­—+1ï¼ˆ12+1ï¼‰ä¹˜ä»¥å½“å‰ä½æ•°ï¼ˆ100ï¼‰ã€‚â€”â€”å‚è€ƒç‰›å®¢ç½‘@è—è£™å­çš„ç™¾åˆé­‚ ä»£ç ï¼šint CounterOf1(int x){ if(x &lt;= 0) return 0; int len = 0, tempX = x, judugNum = 1; while(tempX){ tempX = tempX / 10; len ++; } int power = 10, counter = 0 ; for(int i = 0; i &lt; len; i++){ int liPower = power / 10; int num = x % power / liPower; if(num &gt; judugNum ){ counter += (x / power + 1) * liPower; }else if(num == judugNum ){ counter += (x / power) * liPower + x % liPower + 1; }else counter += x / power * liPower; power *= 10; } return counter; } æµ‹è¯•å¯è§ ç‰›å®¢","link":"/2020/08/07/shua-ti/qi-ta/mian-shi-ti-44-1-chu-xian-de-ge-shu/"},{"title":"é¢è¯•é¢˜49ï¼šä¸‘æ•°","text":"","link":"/2020/08/07/shua-ti/qi-ta/mian-shi-ti-49-chou-shu/"},{"title":"241. Different Ways to Add Parentheses","text":"241. ä¸ºè¿ç®—è¡¨è¾¾å¼è®¾è®¡ä¼˜å…ˆçº§æ€è·¯ï¼šåˆ†è§£ç®—æœ¯å¼å­ï¼Œåˆ†å¼€è®¡ç®—å³å¯ã€‚ åˆ†æ²»æ³•è‡ªä¸Šè€Œä¸‹æ±‚å–ç­”æ¡ˆï¼Œå½“ç„¶å¯ä»¥ç”¨ä¸Šè®°å¿†åŒ–çš„æŠ€å·§ã€‚ DPè‡ªä¸‹è€Œä¸Šæ±‚å–ç­”æ¡ˆï¼Œé€Ÿåº¦å’Œå†…å­˜æ¶ˆè€—æ›´å°‘ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; diffWaysToCompute(string input) { vector&lt;int&gt; nums; vector&lt;char&gt; ops; int a = 0; char op = ' '; input = input + '+'; for(int i = 0; i &lt; input.size(); ++i){ if(input[i] == '+' || input[i] == '-' || input[i] == '*'){ nums.push_back(a); cout &lt;&lt; a; a = 0; op = input[i]; } else{ a *= 10; a += input[i] - '0'; if(op != ' '){ ops.push_back(op); op = ' '; } } } set&lt;int&gt; res = getDivide(nums, ops, 0, nums.size() - 1); vector&lt;int&gt; ans = {}; for(auto it = res.begin(); it != res.end(); it++) ans.push_back(*it); return ans; } set&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e){ set&lt;int&gt; temp; if(s == e){ temp.insert(nums[s]); return temp; } for(int i = s; i &lt; e; ++i){ set&lt;int&gt; res1 = getDivide( nums, ops, s, i); set&lt;int&gt; res2 = getDivide( nums, ops, i + 1, e); for(auto it1 = res1.begin(); it1 != res1.end(); it1++){ for(auto it2 = res2.begin(); it2 != res2.end(); it2++){ if(ops[i] == '+') temp.insert(*it1 + *it2); else if(ops[i] == '-') temp.insert(*it1 - *it2); else if(ops[i] == '*') temp.insert(*it1 * *it2); } } } return temp; } }; AC80% class Solution { public: vector&lt;int&gt; diffWaysToCompute(string input) { vector&lt;int&gt; nums; vector&lt;char&gt; ops; int a = 0; char op = ' '; input = input + '+'; for(int i = 0; i &lt; input.size(); ++i){ if(input[i] == '+' || input[i] == '-' || input[i] == '*'){ nums.push_back(a); // cout &lt;&lt; a; a = 0; op = input[i]; } else{ a *= 10; a += input[i] - '0'; if(op != ' '){ ops.push_back(op); op = ' '; } } } return getDivide(nums, ops, 0, nums.size() - 1); } vector&lt;int&gt; getDivide( vector&lt;int&gt; &amp;nums, vector&lt;char&gt; &amp;ops, int s, int e){ vector&lt;int&gt; temp; if(s == e){ temp.push_back(nums[s]); return temp; } for(int i = s; i &lt; e; ++i){ vector&lt;int&gt; res1 = getDivide( nums, ops, s, i); vector&lt;int&gt; res2 = getDivide( nums, ops, i + 1, e); for(auto it1 = res1.begin(); it1 != res1.end(); it1++){ for(auto it2 = res2.begin(); it2 != res2.end(); it2++){ if(ops[i] == '+') temp.push_back(*it1 + *it2); else if(ops[i] == '-') temp.push_back(*it1 - *it2); else if(ops[i] == '*') temp.push_back(*it1 * *it2); } } } return temp; } }; DPè®°å¿†åŒ–æ–¹æ³• 100% class Solution { public: vector&lt;int&gt; diffWaysToCompute(string input) { vector&lt;int&gt; nums; vector&lt;char&gt; ops; int num; char op; istringstream ss(input + &quot;+&quot;); //! istringstream while(ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op){ nums.push_back(num); ops.push_back(op); } int n = nums.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;())); for(int i = 0; i &lt; n; ++i){ for(int j = i; j &gt;=0; j--){ if(i == j){ dp[j][i].push_back(nums[i]); }else{ for(int k = j; k &lt; i; k++){ for(auto l : dp[j][k]){ for(auto r : dp[k+1][i]){ int val = 0; switch(ops[k]){ case '+': val = l + r; break; case '-': val = l - r; break; case '*': val = l * r; break; } dp[j][i].push_back(val); } } } } } } return dp[0][n - 1]; } };","link":"/2021/01/02/shua-ti-fen-zhi-241-different-ways-to-add-parentheses/"},{"title":"932. Beautiful Array","text":"932. Beautiful Arrayæ€è·¯ï¼šè¿™é¢˜çš„éš¾åº¦æ˜¯æ€ä¹ˆæƒ³å‡ºä¸€ä¸ªç­–ç•¥æ¥ä¿å­˜æ¼‚äº®æ•°ç»„çš„å­˜åœ¨ã€‚ å°†1~Nçš„æ•°å­—åˆ’åˆ†ä¸ºå¥‡æ•°å’Œå¶æ•°ï¼Œå¹¶æ”¾åˆ°æ•°ç»„ä¸¤è¾¹ï¼Œå³å¯ä¿è¯ã€‚åŒæ—¶å¯ä»¥å‘ç°ä»¿å°„å˜åŒ–å¯¹æ¼‚äº®æ•°ç»„çš„æ€§è´¨æ²¡æœ‰å½±å“ã€‚$$2 *(k * a[k] + b) = k * a[i] + b + k * a[j] + b$$ é‚£ä¹ˆå°±æœ‰ä»»æ„ä¸€è¾¹çš„æ•°å­—éƒ½å¯ä»¥é€šè¿‡ä»¿å°„å˜åŒ–å˜ä¸º1-(N/2+1/2)çš„é—®é¢˜ã€‚æ¯”å¦‚ï¼ŒåŸæœ¬å·¦è¾¹æœ‰$(n + 1) / 2$ä¸ªå¥‡æ•°æ•°å­—ï¼Œå³è¾¹æœ‰$N/2$ä¸ªå¶æ•°æ•°å­—ã€‚é‚£ä¹ˆå·¦è¾¹çš„å¥‡æ•°æ•°å­—å¯ä»¥é€šè¿‡ä»¿å°„å˜åŒ–$a[i]â€™= a[i]/2 + 1/2$ï¼Œå³è¾¹çš„å¶æ•°æ•°å­—å¯ä»¥é€šè¿‡ä»¿å°„å˜åŒ–$a[i]â€™= a[i]/2$ï¼Œå°†é—®é¢˜åˆ†è§£æˆäº†è§„æ¨¡å‡åŠçš„ä¸¤ä¸ªå­é—®é¢˜ã€‚ é€šè¿‡é€’å½’åˆ†æ²»æˆ‘ä»¬å¯ä»¥è§£å†³è¯¥é—®é¢˜ã€‚ ä»£ç ï¼š100% class Solution { public: vector&lt;int&gt; beautifulArray(int N) { vector&lt;int&gt; arr(N); for(int i = 0; i &lt; arr.size(); ++i) arr[i] = i + 1; f(0, N - 1, N, arr); return arr; } void f(int s, int e, int N, vector&lt;int&gt; &amp;arr){ if(s == e){ arr[s] = 1; return; } int odd = (N + 1) / 2; f(s, s + odd - 1, odd, arr); for(int i = s; i &lt; s + odd; i++) arr[i] = arr[i] * 2 - 1; f(s + odd, e, N - odd, arr); for(int i = s + odd; i &lt;= e; ++i) arr[i] = arr[i] * 2; } };","link":"/2021/01/04/shua-ti-fen-zhi-932-beautiful-array/"},{"title":"142. Linked List Cycle II","text":"æ€è·¯ï¼šç”¨å¿«æ…¢æŒ‡é’ˆfastï¼Œslowå»å‘ç°é“¾è¡¨ä¸­çš„åœ†ï¼Œå†ä½¿ç”¨ä¸€ä¸ªæŒ‡é’ˆå’Œp1ä¸€èµ·éå†é“¾è¡¨ï¼š 2(a + b) = a + b + (b + c ) *n å¾—åˆ° a = c + (b + c ) *(n - 1) å¦‚æ­¤å¯ä»¥æ¨å¾—ï¼Œå¦‚æœä»p0ä»headå’Œslowä¸€èµ·å‡ºå‘ï¼Œä¼šåœ¨ç¯çš„å…¥å£å¤„ç›¸é‡ã€‚å¦‚æ­¤å°±å¯ä»¥æ¨å¾—ç®—æ³•çš„æ­£ç¡®æ€§ã€‚ å¦å¤–å¼€å§‹éªŒè¯ï¼Œfastå’Œlowä¼šåœ¨ç¬¬ä¸€ä¸ªlowæŒ‡é’ˆçš„ç¬¬ä¸€åœˆç›¸é‡ã€‚ è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡æ—¶ï¼ŒlowæŒ‡é’ˆèµ°äº†è·¯ç¨‹s1 = a + s + n(b + c)ï¼ŒfastæŒ‡é’ˆèµ°äº†è·¯ç¨‹s2 = a + s + k(b + c)ã€‚åŒæ—¶æœ‰s1 * 2 = s2ï¼Œåˆ™æœ‰a + s = (k - 2n)(b +c)ã€‚ ä¸Šé¢çš„è¯æ³•ä¸è¡Œï¼š è®¾slowåˆšå…¥ç¯çš„æ—¶å€™ï¼Œfaståœ¨è·ç¦»ç¯å…¥å£çš„ä½ç½®Bï¼Œæ…¢æŒ‡é’ˆèµ°äº†C,æœ€åè®¾ç¯é•¿ä¸ºLã€‚ C % L = (2 *C + B) % L ç­‰ä»·äº C + NL = 2 * C + B C = NL - B å½“N==1ï¼Œæœ‰0&lt;=C&lt;=B å½“ç„¶ï¼Œéœ€è¦å¦å¤–ä¸€ä¸ªæ¨ç†ï¼š ä¸¤ä¸ªæ­¥é•¿åˆ†åˆ«ä¸º1å’Œ2çš„æŒ‡é’ˆï¼Œç»è¿‡å¿…å®šèƒ½ç›¸é‡ï¼Œå¯ä»¥é€šè¿‡éå†æ‰€æœ‰çŠ¶æ€å¾—çŸ¥ã€‚ ä»£ç /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *p1 = head, *p2 = head; int flag = 0, cyclen = 0, tlen = 0; while(p1){ p1 = p1-&gt;next; if(p1 == nullptr) return nullptr; p1 = p1-&gt;next; p2 = p2-&gt;next; if(p1 == p2) break; } if(p1 == nullptr) return nullptr; // while(1){ // p1 = p1-&gt;next-&gt;next; // p2 = p2-&gt;next; // cyclen++; // if(p1 == p2) break; // } ListNode *p0 = head; while(p0 != p1){ p0 = p0-&gt;next; p1 = p1-&gt;next; tlen++; } return p0; } };","link":"/2020/10/19/shua-ti/shuang-zhi-zhen/142-linked-list-cycle-ii/"},{"title":"167. Two Sum II - Input array is sorted","text":"æ€è·¯ï¼šåŒæŒ‡é’ˆéå†ã€‚å¤æ‚åº¦$O(n)$ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int n = numbers.size(); int l = 0, r = n - 1; while(l &lt; r){ int s = numbers[l] + numbers[r]; if(s &gt; target) r--; else if(s &lt; target) l++; else break; } // vector&lt;int&gt; v(2,0); // v[0] = l + 1; v[1] = r + 1; // return v; return {l + 1, r + 1}; } };","link":"/2020/10/17/shua-ti/shuang-zhi-zhen/167-two-sum-ii-input-array-is-sorted/"},{"title":"287. Find the Duplicate Number","text":"287. Find the Duplicate Numberæ€è·¯å¿«æ…¢æŒ‡é’ˆç®—æ³•ï¼Œ$o(n), o(1)$ã€‚ è¿™é¢˜çš„éš¾ç‚¹æ˜¯çœ‹å‡ºèƒ½æŠŠæ•°ç»„è½¬åŒ–ä¸ºé“¾è¡¨ï¼Œè€Œä¸”é“¾è¡¨ä¸­æœ‰ç¯ã€‚ ä»£ç class Solution { public: int findDuplicate(vector&lt;int&gt;&amp; nums) { // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2; int p1 = 0, p2 = 0; do{ p1 = nums[nums[p1]]; p2 = nums[p2]; }while(p1 != p2); p2 = 0; while(p1 != p2){ p1 = nums[p1]; p2 = nums[p2]; } return p1; // p1æ‰æ˜¯é‡å¤çš„æ•°å­—/idx } };","link":"/2021/02/05/shua-ti/shuang-zhi-zhen/287-find-the-duplicate-number/"},{"title":"438. Find All Anagrams in a String","text":"æ€è·¯ï¼šåŒæŒ‡é’ˆï¼ŒæŒ‡å‘æ¨¡å¼ä¸²strçš„å­ä¸²é¦–ä½så’Œæœ«å°¾+1eã€‚ éå†æ€è·¯ï¼š ä¸æ–­æ·»åŠ eä½ç½®ä¸Šçš„å­—ç¬¦c å¦‚æœcä¸å±äºpï¼Œåˆ™åŒæŒ‡é’ˆè·³è¿‡c å¦‚æœcå±äºpï¼Œåˆ™æ›´æ–°ã€‚ ä½†æ˜¯å¦‚æœåŒ…æ‹¬çš„cå­—ç¬¦å¤ªå¤šäº†ï¼Œåˆ™ç§»åŠ¨sç›´è‡³æ•°é‡ç¬¦åˆæ¡ä»¶ å¦‚æœæ‰€æœ‰å­—ç¬¦æ•°é‡éƒ½æ·»åŠ å®Œå…¨ä¸€è‡´ï¼Œåˆ™æ·»åŠ ç»“æœã€‚ç§»åŠ¨sä¸€ä½ï¼Œæ›´æ–°å³å¯ã€‚ çœ‹äº†å…¶ä»–é¢˜è§£ï¼Œå‘ç°æœ‰ä¸€ä¸ªæ¡ä»¶æˆ‘å¿½ç•¥äº†ï¼ŒæŒ‡é’ˆä¹‹é—´çš„è·ç¦»æ˜¯ç›¸ç­‰çš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™æ˜¯ä¸€ä¸ªæ»‘åŠ¨çª—å£é—®é¢˜~è‰äº†ã€‚ é‚£è¿™å¾ˆç®€å•ï¼Œç»´æŠ¤ä¸€ä¸‹çª—å£å€¼å°±è¡Œäº†ã€‚ å¯ä»¥è¯´æ»‘åŠ¨çª—å£å°±æ˜¯ä¸€ä¸ªç®€å•çš„åŒæŒ‡é’ˆã€‚ ä»£ç ï¼š class Solution { map&lt;char, int&gt; group, times;// group: [s, e) ä¹‹é—´çš„å­—ç¬¦å‡ºç°æ¬¡æ•°ï¼Œ time: på­—ç¬¦å‡ºç°æ¬¡æ•° public: vector&lt;int&gt; findAnagrams(string str, string p) { int s = 0, e = 0; for(auto c : p) ++times[c]; int groopsize = p.size(); vector&lt;int&gt; indexes; while( s &lt; str.size() &amp;&amp; e &lt; str.size()){ if(times[str[e]] == 0) { s = e + 1; group.clear(); groopsize = p.size(); }else{ ++group[str[e]]; --groopsize; // å‡ºç°æ¬¡æ•°è¿‡å¤šï¼Œ å‘å‰æ”¶ç¼©s while( group[str[e]] &gt; times[str[e]]){ --group[str[s]]; ++s; ++groopsize; } // [s, e)å†…æ˜¯pçš„anagram if(groopsize == 0){ indexes.push_back(s); --group[str[s]]; ++s; ++groopsize; } } ++e; // cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; groopsize &lt;&lt; endl; } // cout &lt;&lt; endl; return indexes; } }; class Solution { public: vector&lt;int&gt; findAnagrams(string str, string p) { int s = 0, e = 0; vector&lt;int&gt; indexes, window, need; if(p.size()&gt;str.size()) return {}; window.resize(128); need.resize(128); for(int i = 0; i &lt; p.size(); ++i){ ++window[str[i]]; ++need[p[i]]; } e = p.size(); while(e &lt;= str.size()){ if(window == need) indexes.push_back(s); if(str.size() == e) break; window[str[e++]]++; window[str[s++]]--; } return indexes; } };","link":"/2021/04/30/shua-ti/shuang-zhi-zhen/438-find-all-anagrams-in-a-string/"},{"title":"633. Sum of Square Numbers","text":"633. Sum of Square Numbers æ€è·¯ï¼š äºŒåˆ† åˆ†è§£è´¨å› å­åˆ¤æ–­è´¹é©¬å¹³æ–¹å®šç†æ¡ä»¶æ˜¯å¦æˆç«‹ ä»»ä½•ä¸€ä¸ªç­‰äºä¸¤ä¸ªæ•°çš„å¹³æ–¹ä¹‹å’Œçš„æ•°çš„æ‰€æœ‰å€¼ä¸º$(4k+3)$çš„å› å­æ¬¡å¹‚æ˜¯å¶æ•°çš„ã€‚ åŒæŒ‡é’ˆæ³•éå†å³å¯ï¼ˆå‡»è´¥100%ï¼‰ ä»£ç ï¼šåŒæŒ‡é’ˆæ³• class Solution { public: bool judgeSquareSum(int c) { long long sum, a = 0, b = (long long)(sqrt(c)); while(a &lt;= b ){ sum = a * a + b * b; if(sum &gt; c) b--; else if(sum &lt; c) a++; else break; } if(sum == c) return true; else return false; } }; åˆ¤æ–­è´¹é©¬å¹³æ–¹å®šç†ï¼š class Solution { public: bool judgeSquareSum(int c) { // int d = (int)sqrt(c), ori = c ; // for(int i = 2; i &lt;= d + 1 &amp;&amp; c != 1; ++i){ for(int i = 2; i &lt;= c; ++i){ if(c % i == 0){ int t = 0; while(c % i == 0){ ++t; c /= i; } if((i + 1) % 4 == 0){ if(t &amp; 1) return false; } } } // if(c == ori &amp;&amp; (c + 1) % 4 == 0) return false; return true; } };","link":"/2020/10/24/shua-ti/shuang-zhi-zhen/633-sum-of-square-numbers/"},{"title":"680. Valid Palindrome II","text":"680. Valid Palindrome IIæ€è·¯ï¼šå…¸å‹çš„è´ªå¿ƒé¢˜ + äºŒæŒ‡é’ˆã€‚è¿™é¢˜è¿˜è›®ä¸é”™çš„ã€‚ è¿ç”¨é¢˜ç›®ç»™å‡ºçš„æœ€å¤šåˆ ä¸€ä¸ªçš„å…³é”®ä¿¡æ¯ï¼Œå°±å¯ä»¥å†™å‡ºä¸€ä¸ªç®€å•çš„ç®—æ³•ï¼šç”¨ä¸¤ä¸ªæŒ‡é’ˆå˜é‡éå†stringä¸¤è¾¹ï¼Œå¦‚æœæœ‰ä¸ç”¨çš„å­—ç¬¦ã€‚å°è¯•åˆ é™¤æ‰ä¸¤ä¸ªä¸­çš„ä¸€ä¸ªï¼Œåˆ¤æ–­å‰©ä¸‹çš„å­—ç¬¦ä¸²æ˜¯å¦æ˜¯Palindrome. ä»£ç ï¼šclass Solution { public: bool isPartialPalindrome(string &amp;s, int l, int r) { while(l &lt; r){ if(s[l] != s[r]) return false; ++l; --r; } return true; } bool validPalindrome(string s) { int l = 0, r = s.size() - 1; while(l &lt; r){ if(s[l] != s[r]){ return isPartialPalindrome(s, l + 1, r) || isPartialPalindrome(s, l , r - 1); } ++l; --r; } return true; } };","link":"/2020/10/26/shua-ti/shuang-zhi-zhen/680-valid-palindrome-ii/"},{"title":"76. Minimum Window Substring","text":"76. Minimum Window Substringæ€è·¯1:ç»å…¸åŒæŒ‡é’ˆä¸‹çš„æ»‘åŠ¨çª—å£ç®—æ³•ã€‚æ»‘åŠ¨çª—å£çš„å·¦å³éƒ¨åˆ†åˆ†åˆ«ç”±ä¸¤ä¸ªæŒ‡é’ˆl,ræŒ‡å‘ã€‚ ä½¿ç”¨æ»‘åŠ¨çª—å£è§‚å¯Ÿå¯èƒ½ç¬¦å·çš„æ¡ä»¶çš„å­ä¸²ï¼Œå¹¶ç”¨unordered_mapæˆ–è€…mapæ¥è®°å½•åŸå­—ç¬¦ä¸²så’Œæ»‘åŠ¨çª—å£winä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚ å…¶ç®—æ³•è¿‡ç¨‹å¦‚ä¸‹ï¼š çª—å£çš„å³æŒ‡é’ˆå‘å³æ»‘åŠ¨ä¸€æ¬¡ï¼Œå¹¶æ£€æŸ¥çª—å£å†…æ˜¯å¦æœ‰è¶³å¤Ÿå…ƒç´ ã€‚è‹¥æ˜¯ï¼Œåˆ™å·¦æŒ‡é’ˆå‘å³æ”¶ç¼©çª—å£ã€‚é‡å¤ä¸Šè¿°æ­¥éª¤å³å¯ã€‚ ä»£ç ï¼š class Solution { public: map&lt;char, int&gt; cur, ori; //ä¼˜åŒ–: å»é™¤æ— æ•ˆå­—ç¬¦ int ahash[800] = {0}; bool check(){ for(const auto &amp;p : ori){ if(cur[p.first] &lt; p.second) return false; } return true; } string minWindow(string s, string t) { for(int i = 0; i &lt; t.size(); ++i){ ++ori[t[i]]; ahash[t[i]] = 1; } int l = 0, r = -1, maxLen = 0x7fffffff; string ans = &quot;&quot; ; while(r &lt; int(s.size())){ while(++r &lt; s.size() &amp;&amp; !ahash[s[r]]); if(r == s.size()) break; ++cur[s[r]]; // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; while(check() &amp;&amp; l &lt;= r){ if(maxLen &gt; r - l + 1){ ans = s.substr(l, r - l + 1); maxLen = r - l + 1; } //å…ˆå‡å†ç§»åŠ¨â€¦â€¦è¿™ä¸ªbug --cur[s[l]]; while(++l &lt;= r &amp;&amp; !ahash[s[l]]); } } return ans; } }; æ€è·¯2ï¼šæ›´å·§å¦™çš„æ–¹æ³•ï¼š éŸ³é‡æ¨¡æ‹Ÿï¼šæƒ³è±¡ä¸€æ’éŸ³é‡ï¼Œåˆ†åˆ«ä»£è¡¨ç€æ¯ä¸ªtä¸­å…ƒç´ çš„ä¸ªæ•°ã€‚ åœ¨æ»‘åŠ¨çª—å£å‘ræŒ‡é’ˆåœ¨tå‘å³æ‰©å±•çª—å£ä¸­ï¼Œ æ¯é‡åˆ°ä¸€ä¸ªsä¸­çš„å…ƒç´ å°±å‡å»å¯¹åº”çš„éŸ³é‡å€¼ã€‚å¦‚æœæ»‘åŠ¨çª—å£ä¸­åŒ…å«äº†sä¸­çš„å„ä¸ªå…ƒç´ ï¼ˆåŒ…æ‹¬ç§ç±»å’Œæ•°é‡ï¼‰ï¼Œé‚£ä¹ˆå°±æœ‰éŸ³é‡å›¾çš„æ¯ä¸ªæŸ±å­éƒ½åœ¨æ°´å¹³ä¸‹ä»¥ä¸‹æˆ–è€…æŒå¹³ï¼Œå¦‚æœæˆ‘ä»¬è®°å½•åœ¨æ°´å¹³çº¿ä¹‹ä¸Šçš„æ•°å€¼å˜åŠ¨â€”â€”ç”¨cntè®°å½•--yin[s[i]] &gt;=0çš„å‰©ä½™æ¬¡æ•°å³å¯ã€‚ å¦‚æœcnt==0ï¼Œè¯´æ˜çª—å£å·²ç»åŒ…æ‹¬äº†æ‰€æœ‰å…ƒç´ ï¼Œå¯ä»¥ç¼©å°èŒƒå›´ï¼ŒæŠŠå·¦æŒ‡é’ˆå‘ğŸ‘‰å³æ»‘åŠ¨ã€‚cntçš„å˜åŠ¨ä¹Ÿæ˜¯åŒç†çš„ã€‚ ä»£ç å¦‚ä¸‹ï¼š ä»£ç 2ï¼šclass Solution { public: // éŸ³é‡æ¨¡æ‹Ÿ unordered_map&lt;char, int&gt; map; string minWindow(string s, string t){ for(int i = 0; i &lt; t.size(); ++i) ++map[t[i]]; int cnt = t.size(), l = 0, r = -1, start = l, maxl = s.size() + 1; while(r &lt; int(s.size())){ if(--map[s[++r]] &gt;= 0) --cnt; // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; endl; while(l &lt;= r &amp;&amp; cnt == 0){ if(maxl &gt; r - l + 1){ start = l; maxl = r - l + 1; } if(++map[s[l]] &gt; 0) cnt++; l++; } } return maxl == s.size() + 1 ? &quot;&quot; : s.substr(start, maxl); } }; ä»£ç 3ï¼šï¼ˆäºŒåˆ·ï¼‰class Solution { public: // åŒæŒ‡é’ˆå¿…å®šéƒ½æœç´¢åˆ°æ‰€æœ‰åŒ¹é…ä¸²çš„åŸå› æ˜¯ æ‰€æœ‰ä»¥ gä¸ºç»ˆç‚¹çš„ç¬¦åˆé¢˜æ„çš„çš„å­—ç¬¦ä¸²s1ï¼Œ // å…¶å·¦ç«¯ç‚¹å¿…å®šå¯ä»¥å‘å·¦ç§»åŠ¨ï¼Œå› ä¸ºç§»åŠ¨ä¼šåŒ…å«åˆ°æ›´å¤šå­—ç¬¦ä¸² // åè¿‡æ¥æƒ³ï¼Œä»èµ·ç‚¹å‡ºå‘ï¼Œå³ç«¯ç‚¹ç§»åŠ¨å…ˆå°½å¯èƒ½åŒ…å«å¤šç›´åˆ°è¶³å¤Ÿçš„å­—ç¬¦ï¼Œ // å†å‘å³ç§»åŠ¨å·¦ç«¯ç‚¹å°½å¯èƒ½å‡å°‘å¤šä½™çš„å­—ç¬¦ï¼Œè·å–ä¸€ä¸ªå°½å¯èƒ½çŸ­çš„å­—ç¬¦ä¸² // ä¸ºäº†å°è¯•å…¶ä»–ç»“æœï¼Œä¸æ–­åœ°è¿›è¡Œä»¥ä¸‹æ´»åŠ¨ // ç§»åŠ¨å³ç«¯ç‚¹ä¸€æ¬¡ï¼Œç¼©çŸ­å·¦ç«¯ç‚¹ï¼Œå¯ä»¥æœç´¢åˆ°å…¶ä»–ç»“æœ // æ¯”è¾ƒç»†èŠ‚çš„æ˜¯æ§åˆ¶è¿‡ç¨‹å’Œå¾ªç¯ç»“æŸ // string minWindow(string s, string t) { int ct[256] = {0}, allct = t.size(); string ans; // s += 'A'; for(int i = 0; i &lt; t.size(); ++i) ++ct[t[i]]; int p1 = 0, p2 = 0; // [)å·¦é—­å³å¼€ç©ºé—´ï¼Œç§’åœ¨ä¸éœ€è¦åˆå§‹åŒ– int minlen = s.size() + 1, minp1 = 0; while(p2 &lt; s.size()){ // è¦ä¹ˆå³ç§»p2ç›´åˆ°tå­—ç¬¦ä¸²å…¨éƒ¨è¢«å›Šæ‹¬ï¼Œè¦ä¹ˆè¯•æ¢æ€§ç§»åŠ¨p2ä¸€ä¸ªä½ç½®ï¼Œè¿›è¡Œå…¶ä»–ä½ç½®çš„æ¢ç´¢ while(p2 &lt; s.size()){ // p2 &lt;= s.size() if(ct[s[p2]] &gt; 0) --allct; // allctç»Ÿè®¡æ˜¯å¦å½“å‰[p1, p2)æ˜¯å¦æœ‰tçš„å…¨éƒ¨å­—ç¬¦ --ct[s[p2]]; // æ›´æ–°å­—ç¬¦æ•°é‡ ++p2; if(allct == 0) break; //å‰è¿›ä¸€æ­¥ } while(ct[s[p1]] &lt; 0){ // å¦‚æœè¯¥å­—ç¬¦å¤šä½™äº†ï¼Œç¼©å°å·¦ç«¯ç‚¹ ++ct[s[p1]]; ++p1; } if(allct == 0 &amp;&amp; p2 - p1 &lt; minlen){ minp1 = p1; minlen = p2 - p1; } // cout &lt;&lt; p1 &lt;&lt; ' ' &lt;&lt; p2 &lt;&lt; ' ' &lt;&lt; allct &lt;&lt; endl; } if(minlen &gt; s.size())ans = &quot;&quot;; else ans = s.substr(minp1, minlen); return ans; } };","link":"/2020/10/23/shua-ti/shuang-zhi-zhen/76-minimum-window-substring/"},{"title":"132. Palindrome Partitioning II","text":"132. Palindrome Partitioning IIæ€è·¯ï¼šdpï¼Œdp[i]è¡¨ç¤ºæœ€å°åˆ†å‰²å­ä¸²æ•°ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š å…¶ä¸­å­ä¸²æ˜¯å¦ä¸ºå›æ–‡ä¸²å¯ä»¥é¢„è®¡ç®—ï¼Œè¿™æ ·å°±æŠŠå¤æ‚åº¦ä»o(N^3)é™åˆ°o(N^2)ã€‚ ä»£ç ï¼šclass Solution { vector&lt;int&gt; dp; public: int minCut(string s) { int n = s.size(); dp.resize(n); for(int i = 0; i &lt; n; ++i){ dp[i] = i + 1; for(int j = i; j &gt;= 0; --j){ if(isPalindrome(s, j, i)){ dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]); } } } return dp[n - 1] - 1; } bool isPalindrome(string &amp;s, int i, int j){ if(i &gt;= j) swap(i, j); while(i != j &amp;&amp; i &lt; j){ if(s[i] != s[j]) return false; --j; ++i; } return true; } }; é¢„è®¡ç®— class Solution { vector&lt;int&gt; dp; vector&lt;vector&lt;int&gt;&gt; isPal; public: int minCut(string s) { int n = s.size(); dp.resize(n); isPal.resize(n, vector&lt;int&gt;(n,1)); for(int i = n - 1; i &gt;= 0; --i){ for(int j = i + 1; j &lt; n; ++j){ // if(i == j) isPal[i][j] = 1; // else if(i != n- 1 &amp;&amp; j != 0) isPal[i][j] = isPal[i + 1][j - 1] &amp;&amp; s[i] == s[j]; // s[i,j]çš„å›æ–‡éœ€è¦s[i + 1, j - 1]çš„å›æ–‡ï¼Œé‚£ä¹ˆåå‘éå†å³å¯ã€‚ } } for(int i = 0; i &lt; n; ++i){ dp[i] = i + 1; for(int j = i; j &gt;= 0; --j){ if(isPal[j][i]){ dp[i] = min(j == 0 ? 1 : dp[j - 1] + 1, dp[i]); } } } return dp[n - 1] - 1; } };","link":"/2021/03/08/shua-ti/zi-fu-chuan/132-palindrome-partitioning-ii/"},{"title":"227. Basic Calculator II","text":"227. Basic Calculator IIæ€è·¯ç»å…¸çš„ä¸­ç¼€è½¬åç¼€ç»ƒæ‰‹é¢˜ï¼Œä½†æ˜¯æˆ‘åä¸ã€‚ åœ¨éå†å­—ç¬¦ä¸²æŠŠæ•°å­—å’Œè¿ç®—ç¬¦å­˜å‚¨åˆ°ä¸€ä¸ªæ•°å­—æ ˆå’Œè¿ç®—æ ˆä¸­ï¼Œè€ƒè™‘åˆ°è¿ç®—é¡ºåºæ˜¯ä¹˜é™¤&gt;åŠ å‡ï¼Œä¸”å·¦è¾¹&gt;å³è¾¹ï¼Œæ‰€ä»¥åœ¨å‹å…¥æ–°è¿ç®—ç¬¦opå‰æŠŠæ ˆä¸­ä¼˜å…ˆçº§å¤§äºç­‰äºopçš„è¿ç®—æ³•å¼¹å‡ºï¼Œå¹¶è®¡ç®—ã€‚ éå†å®Œäº†è¿ç®—æ ˆå¯èƒ½è¿˜æœ‰è¿ç®—ç¬¦ï¼Œé€†å‘è®¡ç®—å³å¯ã€‚æœ€åæ•°æ®æ ˆå¼¹å‡ºç»“æœå°±å®Œäº‹ã€‚ ä»£ç class Solution { public: using ull = unsigned long long; ull func(char c, ull num1, ull num2){ if(c == '+') return num1 + num2; if(c == '-') return num1 - num2; if(c == '*') return num1 * num2; if(c == '/') return num1 / num2; return 0; } int calculate(string s) { s += ']'; stack&lt;char&gt; op; stack&lt;ull&gt; num; map&lt;char, int&gt; pri{{'+', 1},{'-', 1},{'*', 2},{'/', 2}}; ull cal = 0; for(auto c : s){ if(isdigit(c)) cal = cal * 10 + c - '0'; else{ if(c == ' ') continue; // cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; cal &lt;&lt; endl; num.push(cal); cal = 0; if(c == ']') continue; while(op.size() &amp;&amp; pri[c] &lt;= pri[op.top()]){ int num2 = num.top(); num.pop(); int num1 = num.top(); num.pop(); num.push( func(op.top(), num1, num2) ); op.pop(); } op.push(c); } } // cout &lt;&lt; num.size() &lt;&lt; ' ' &lt;&lt; op.size() &lt;&lt; endl; while(op.size()){ int num2 = num.top(); num.pop(); int num1 = num.top(); num.pop(); num.push( func(op.top(), num1, num2) ); op.pop(); } return num.top(); } };","link":"/2021/02/12/shua-ti/zi-fu-chuan/227-basic-calculator-ii/"},{"title":"28. Implement strStr()","text":"æ€è·¯ï¼šç»å…¸çš„å­—ç¬¦å­ä¸²åŒ¹é…é—®é¢˜ï¼š æš´åŠ›åŒ¹é…ï¼Œ$O(mn)$ Rabin Karp $O(n)$ KMPç®—æ³• KMPç®—æ³•KMPç®—æ³•çš„æ ¸å¿ƒåœ¨äºnextæ•°ç»„ï¼Œå…¶next[i]è®°å½•äº†å­—ç¬¦ä¸²str[0...i]çš„æœ€é•¿ç›¸åŒå‰åç¼€å­ä¸²ï¼ˆä¸åŒ…æ‹¬å­ä¸²æœ¬èº«ï¼‰çš„å‰ç¼€å°¾ä¸‹æ ‡ã€‚å¦‚æ­¤ï¼Œæˆ‘ä»¬åœ¨æ¯å­ä¸²åœ¨åŒ¹é…iï¼ˆæ¯ä¸²Saï¼‰ï¼Œjï¼ˆå­ä¸²Sbï¼‰å¤±è´¥æ—¶ï¼Œå­ä¸²çš„k = next[j - 1]è®°å½•äº†ä¿è¯äº†æœ€é•¿Saä¸Sb[0, k]å¯åŒ¹é…æˆåŠŸï¼ˆkä¸æ–­å‡å°ï¼Œä½†iæ²¡æœ‰å‡å°ï¼‰ï¼Œé‡æ–°åˆ¤æ–­Sa[i]==?Sb[k+1]å³å¯ã€‚é‡å¤è¿™ä¸ªæ­¥éª¤ï¼Œç›´åˆ°kæ— æ³•ç¼©å°ï¼Œæˆ–è€…åŒ¹é…æˆåŠŸã€‚è‹¥æˆåŠŸï¼Œ++iï¼Œ++jï¼›è‹¥å¤±è´¥ï¼Œåˆ™++iï¼Œj=0ã€‚ ä½†åœ¨æ­¤ä¹‹å‰ï¼Œè¿˜æœ‰æ„é€ nextæ•°ç»„ã€‚ç¥å¥‡çš„æ˜¯ï¼Œnext[i]æ„é€ ä¸åŒ¹é…çš„è¿‡ç¨‹æå…¶ç±»ä¼¼ã€‚é¦–å…ˆnext[0] = -1ã€‚è®°k = next[i - 1]ï¼Œæ¯”è¾ƒSb[k + 1] == ? Sb[i]ï¼Œè‹¥æˆåŠŸï¼Œåˆ™Sb[i]= k + 1ï¼›è‹¥å¤±è´¥ï¼Œåˆ™å¯»æ‰¾æ›´å°çš„å…¬å…±å‰åç¼€ï¼ˆä¸ºäº†å¯»æ‰¾æœ€é•¿çš„å…¬å…±å‰ç¼€é•¿åº¦ï¼Œåˆ©ç”¨äº†Sb[0,..,i-1]å­ä¸²çš„æœ€é•¿å‰ç¼€åå­ä¸²ï¼Œä»¥åŠæ›´çŸ­çš„å‰åç¼€å­ä¸²ï¼ï¼ˆåä¸¤è€…çš„æ€§è´¨ä¿è¯äº†å±äºå‰è€…çš„åç¼€å­ä¸²âœ¨âœ¨ï¼‰ï¼‰ï¼Œç¼©å°kä¸ºnext[k]ï¼Œå†æ¬¡æ¯”è¾ƒã€‚å…¶ä¸­k&gt;-1ã€‚å¦‚æœè¿˜æ˜¯å¤±è´¥äº†ï¼Œæ˜æ˜¾çš„ä¸å­˜åœ¨ç›¸åŒçš„å‰åç¼€å­ä¸²next[i] = -1ã€‚ ä»£ç ï¼šclass Solution { public: //æš´åŠ› int strStr(string haystack, string needle) { int m = haystack.size(), n = needle.size(); if(n == 0) return 0; int k = 0, j = 0; //aaaaaf //-----fs while(k &lt;= m - n){ while(j &lt; n &amp;&amp; haystack[k] == needle[j]) ++k, ++j; if(j == n) return k - j; k = k - j + 1; j = 0; } return -1; } }; class Solution { public: //æš´åŠ› int strStr(string haystack, string needle) { auto tonum = [](char a){return a - 'a';}; int m = haystack.size(), n = needle.size(); if(n == 0) return 0; using ktype = long long; ktype base = 26, key = 0; //MOD è¶…è¿‡ä¸Šé™è‡ªç„¶æº¢å‡º? ktype point = 0, hpow = 1, MOD = 1e9 + 7; for(int i = 0; i &lt; n; ++i){ // å­—ç¬¦ä¸²å‰ä½æƒé‡é«˜ key = (key * base + tonum(needle[i])) % MOD; hpow = (hpow * base) % MOD; // bugs point = (point * base + tonum(haystack[i])) % MOD; } // if(point &lt; 0 || key &lt; 0) cout &lt;&lt; &quot;+&quot;; if(key == point) return 0; for(int j = n; j &lt; m; ++j){ point = (((point * base - tonum(haystack[j - n]) * hpow) % MOD + MOD) + tonum(haystack[j])) % MOD; //ç–¯ç‹‚ä½¿ç”¨è¿ç®—ç¬¦é™åˆ¶å’Œeå–ä½™è¿ç®—é˜²æ­¢æº¢å‡º // if(point &lt; 0 ) cout &lt;&lt; '-'; if(key == point){ return j - n + 1; } } return -1; } }; class Solution { public: //KMP 100% int strStr(string haystack, string needle) { int n = haystack.size(), m = needle.size(); if(m == 0 ) return 0; vector&lt;int&gt; next(m, -1); //next[i] ä¸ºneedle[0,...., i]ç›¸åŒæœ€é•¿å‰åç¼€çš„å‰ç¼€æœ«ä¸‹æ ‡ for(int i = 1; i &lt; m; ++i){ int k = next[i - 1]; // needle[0,...., i - 1]ç›¸åŒæœ€é•¿å‰åç¼€çš„å‰ç¼€æœ«ä¸‹æ ‡ while(k != -1 &amp;&amp; needle[k + 1] != needle[i]){ // å°è¯•æ‰©å±•å‰åç¼€ needle[0, k + 1], needle[,..,i-1,i] k = next[k]; //åŒ¹é…å¤±è´¥ï¼Œç¼©çŸ­å‰åç¼€ } if(needle[k + 1] != needle[i]) next[i] = -1; else next[i] = k + 1; // cout &lt;&lt; next[i] &lt;&lt; endl; } int i = 0, j = 0; for(; i &lt; n; ++i ){ // i, j ä¸ºå½“å‰åŒ¹é…çš„ä¸‹æ ‡å­—ç¬¦ while(haystack[i] != needle[j] &amp;&amp; j &gt; 0){ // ä¸¤ä¸²åŒ¹é…å¤±è´¥ï¼Œä¸”jå¯å‹ç¼© j = next[j - 1] + 1; // å‹ç¼©needleä¸²çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ï¼Œ æœ€å°ä¸º0 } if(haystack[i] == needle[j]){ ++j; if(j == m) return i - j + 1; } } return -1; } };","link":"/2021/02/15/shua-ti/zi-fu-chuan/28-implement-strstr/"},{"title":"3. Longest Substring Without Repeating Characters","text":"3. Longest Substring Without Repeating Charactersæ€è·¯ï¼š æš´åŠ› åŒæŒ‡é’ˆ å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œç¬¦åˆé¢˜æ„çš„å­ä¸²åœ¨æŒ‰å·¦ç«¯ä¸‹æ ‡ä»å°åˆ°å¤§æ’åºæ—¶ï¼Œå³ç«¯ä¸‹æ ‡ä¹Ÿæ˜¯éä¸¥æ ¼é€’å¢çš„ã€‚ æƒŠå–œçš„æ˜¯ï¼ŒåŒæŒ‡é’ˆä¾¿å¯ä»¥æ´¾ä¸Šç”¨åœºäº†ï¼Œiï¼Œjåˆ†åˆ«æŒ‡å‘å­ä¸²ä¸¤ç«¯ï¼Œå¹¶ç»´æŠ¤ä¸é‡å¤çš„æ€§è´¨å³å¯ã€‚ ä»£ç ï¼šæš´åŠ›ï¼š class Solution { public: int lengthOfLongestSubstring(string s) { int ct= 0; for(int i = 0; i &lt; s.size(); ++i){ vector&lt;int&gt; pos(259, -1); for(int j = i; j &lt; s.size(); ++j){ if(pos[s[j]] != -1) break; pos[s[j]] = 1; ct = max(ct, j - i + 1); } } return ct; } }; åŒæŒ‡é’ˆ class Solution { public: int lengthOfLongestSubstring(string s) { unordered_set&lt;char&gt; hash; int i, j, ct, n = s.size(); i = j = ct = 0; while(j &lt; n){ if(!hash.count(s[j])){ ct = max(ct, j - i + 1); hash.insert(s[j++]); } else{ hash.erase(s[i++]); } } return ct; } };","link":"/2021/02/18/shua-ti/zi-fu-chuan/3-longest-substring-without-repeating-characters/"},{"title":"647. Palindromic Substrings","text":"647. Palindromic Substrings1æ€è·¯ï¼šManacherç®—æ³•ï¼š å›æ–‡å­—ç¬¦ä¸²çš„åˆ¤æ–­æ–¹å¼æ–¹å¼ä¼šä»ä¸­å¿ƒç‚¹ä»å‘å‘å¤–ä¸æ–­æ‰©å±•ï¼ŒManacherç®—æ³•ç»™å‡ºäº†ç¼©å‡äº†å­—ç¬¦ä¸²åˆ¤æ–­å›æ–‡çš„é‡å¤æ­¥éª¤ã€‚å…¶æ ¸å¿ƒæ€æƒ³åœ¨äºï¼Œä¸€æ®µå›æ–‡sä¸Šçš„å‘ˆå¯¹ç§°çŠ¶çš„å·¦å³Aå’ŒBä¸¤ç‚¹ï¼ŒBç‚¹çš„æœ€å°å›æ–‡é•¿åº¦å¯ä»¥é€šè¿‡Aç‚¹çš„å›æ–‡é•¿åº¦å’ŒBåˆ°sè¾¹å³è¾¹ç•Œçš„é•¿åº¦æœ€å°å€¼å†³å®šã€‚å¦å¤–ï¼Œä¸ºäº†æ”¹å˜å›æ–‡ä¸²é•¿åº¦ä¸ºå¶æ•°å’Œå¥‡æ•°çš„ä¸åŒï¼Œåœ¨æ¯ä¸ªå­—ç¬¦å‰å’Œåéƒ½æ’å…¥ä¸€ä¸ª#ï¼Œå¦‚æ­¤æ’å…¥åçš„Tçš„æœ€é•¿å›æ–‡ä¸²åŠå¾„dï¼Œä¸Sæœ€é•¿å›æ–‡ä¸²åŠå¾„çš„kæœ‰ï¼Œ k = [d / 2] ã€‚ []å‘ä¸‹å–æ•´ã€‚ ä»£ç ï¼šclass Solution { public: int countSubstrings(string s) { string t = &quot;!#&quot;; // æ’å…¥å“¨å…µ for(char c : s){ t += c + string(&quot;#&quot;); } t +=&quot;$&quot;; int amount = 0, n = t.size(); vector&lt;int&gt; f(n); int curmid = 1, right = 1; for(int i = 1; i &lt; n; ++i){ int j = curmid * 2 - i; int len = i &gt; right ? 1 : min(f[j], right - i + 1); while(t[i + len] == t[i - len]) ++len; //$ !ä½œä¸ºå“¨å…µè‡ªåŠ¨æ§åˆ¶è¾¹ç•Œ f[i] = len; if(i + len - 1 &gt; right){ curmid = i; right = i + len - 1; } amount += f[i] / 2; // cout&lt;&lt; f[i] &lt;&lt; &quot; &quot;; } // cout &lt;&lt; endl; return amount; } };","link":"/2021/02/14/shua-ti/zi-fu-chuan/647-palindromic-substrings/"},{"title":"215. Kth Largest Element in an Array","text":"215. Kth Largest Element in an Arrayå¤ä¹ ä¸€éç¬¬Kå¤§ç®—æ³•çš„ä¸‰ â• ä¸€ç§ç»å…¸è§£æ³• æ€è·¯ï¼š æš´åŠ›æ’åº å¿«é€Ÿæ’åºçš„Partition å»ºé•¿åº¦ä¸ºkçš„å°é¡¶å † â­â­â­å¿«é€ŸæŒ‡é’ˆç®—æ³•, $O(N)$ è¿™é¢˜çš„ç®—æ³•éå¸¸å·§å¦™ï¼åŒæ ·ä¹Ÿæ˜¯partitionæ€æƒ³ï¼Œå–ä¸€ä¸ªnums[k]ä½œä¸ºpivotï¼Œå¹¶æ”¾åœ¨æ•°ç»„æœ€å³è¾¹ä½œä¸ºå“¨å…µã€‚ç”¨ä¸¤ä¸ªæŒ‡é’ˆiå’Œjä»å·¦åˆ°å³éå†æ•°ç»„ï¼Œå…¶æ„ä¹‰åœ¨äºæŒ‡å‘æ¯”pivotå°çš„æ•°å­—åŒºé—´å·¦å³é—­åŒºé—´ã€‚å¦‚æœnums[j]&gt;pivotï¼Œåˆ™swap(nums[j++], nums[i++])ã€‚å¦åˆ™ï¼Œj++ã€‚è¿™ä¸€éå†åŠ¨ä½œç»´æŒäº†æŒ‡é’ˆçš„æ€§è´¨ã€‚æœ€åéå†ç»“æŸååï¼Œå¯èƒ½æœ‰[2, 1, 3, pivot, pivot, pivot, 10,9,]ï¼Œå…¶ä¸­i=4ã€‚ ä»£ç ï¼šclass Solution { public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int pos = -1; int s = 0, e = nums.size(); k = (int)nums.size() - k + 1; pos = sortPartVec(nums, s, e); while(1){ // cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; e &lt;&lt; &quot; &quot; &lt;&lt; pos &lt;&lt; endl; if(pos + 1 == k) return nums[pos]; else if(pos + 1 &gt; k){ s = s; e = pos; pos = sortPartVec(nums, s, e); } else{ s = pos + 1; e = e; pos = sortPartVec(nums, s, e); } } } int sortPartVec(vector&lt;int&gt;&amp; nums, int s, int e){ int len = min((int)nums.size(), e - s); if(len == 1) return s; else if(len == 0) return -1; // if(nums[len / 2] &gt; nums[0]) swap(nums[0], nums[len / 2]); int l = s, r = e - 1, pivot = nums[s]; while(l &lt; r){ while(l &lt; r &amp;&amp; nums[r] &gt; pivot) r--; nums[l] = nums[r]; while(l &lt; r &amp;&amp; nums[l] &lt;= pivot) l++; nums[r] = nums[l]; } nums[r] = pivot; return r; } }; å»ºå †ç®—æ³• class Solution { public: vector&lt;int&gt; heap; int maxlen; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { maxlen = k + 1; heap.push_back(1); for(int i = 0; i &lt; nums.size(); ++i) insert_heap(nums[i]); return heap[1]; } void upAdjust(int p, int len){ for(int x = p / 2; x &gt;= 1; x /= 2){ if(heap[x] &lt; heap[p]) break; swap(heap[x], heap[p]); p = x; } } void downAdjust(int p, int len){ for(int x = p * 2; x &lt; len; x += x){ if(x + 1 &lt; len) x = (heap[x] &lt; heap[x + 1]) ? x : x + 1; if(heap[x] &gt;= heap[p]) break; swap(heap[x], heap[p]); p = x; } } void insert_heap(int x){ int len = heap.size(); if(len == maxlen){ if(heap[1] &lt; x){ pop_heap(); len--; } else return; } heap.push_back(x); heap[len] = x; upAdjust(len, len + 1); } void pop_heap(){ int pos = 1, len = heap.size(); heap[1] = heap[len - 1]; len--; heap.pop_back(); downAdjust(1, len); } }; åˆ©ç”¨STLæ¨¡æ¿ class Solution { public: priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; que; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { for(int i = 0; i &lt; nums.size(); ++i){ if(que.size() == k &amp;&amp; que.top() &lt; nums[i]){ que.pop(); que.push(nums[i]); } else if(que.size() &lt; k) que.push(nums[i]); } return que.top(); } }; class Solution { public: // æœ€ä¼˜è§£ å¿«é€Ÿé€‰æ‹©ç®—æ³• int findth(vector&lt;int&gt;&amp; nums, int l, int r){ swap(nums[r], nums[rand() % (r - l + 1) + l]); int i, j; i = j = 0; while(j &lt;= r){ if(nums[j] &gt; nums[r]) ++j; else{ swap(nums[j++], nums[i++]); } } // cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; nums[i - 1] &lt;&lt; endl;; return i - 1; //povit } int recurfindth(vector&lt;int&gt;&amp; nums, int l, int r, int k){ int th = findth(nums, l, r); int findk = nums.size() - th; if( k == findk) return nums[th]; else if(k &lt; findk) return recurfindth(nums, th + 1, r, k); else return recurfindth(nums, l, th - 1, k); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { return recurfindth(nums, 0, nums.size() - 1, k); } };","link":"/2020/11/14/shua-ti-pai-xu-215-kth-largest-element-in-an-array/"},{"title":"451. Sort Characters By Frequency","text":"451. Sort Characters By Frequencyæ€è·¯ï¼šç»Ÿè®¡æ¯ä¸ªå­—ç¬¦å‡ºç°çš„é¢‘ç‡ï¼Œ æŒ‰é¢‘ç‡æ’åºæˆ–è€…å»ºç«‹å †è·å–æœ€å¤§å€¼ã€‚ å‡»è´¥100 ä»£ç ï¼š class Solution { public: string frequencySort(string s) { int count[258] = {0}; int len = s.size(); for(int i = 0; i &lt; len ; ++i){ count[s[i]]++; } priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, less&lt;pair&lt;int, int&gt; &gt; &gt; pq; for(int i = 0; i &lt; 258; ++i){ if(count[i] != 0) pq.push( make_pair(count[i], i)); } string ans = &quot;&quot;; while(pq.size()){ pair&lt;int, int&gt; t = pq.top(); pq.pop(); int time = t.first; int ichar = t.second; string single(time, (char)ichar); ans += single; } return ans; } };","link":"/2020/11/16/shua-ti-pai-xu-451-sort-characters-by-frequency/"},{"title":"é¢è¯•é¢˜51:é€†åºæ•°","text":"è¿™é“é¢˜ç›®è¿˜æ˜¯æ¯”è¾ƒç¥å¥‡çš„ã€‚ é¢˜ç›®ï¼šåœ¨ä¸€ä¸ªæ•°ç»„ä¸­æ‰¾å‡ºæ‰€æœ‰çš„é€†åºæ•°ã€‚ é€†åºæ•°å°±æ˜¯æŒ‡å‰ä¸€ä¸ªæ•°å­—å¤§äºåä¸€ä¸ªæ•°ç»„çš„ä¸€å¯¹æ•°å­—ã€‚ æ€è·¯ï¼šå¯ä»¥æš´åŠ›æŸ¥æ‰¾ï¼Œä½†æ˜¯å¤æ‚åº¦æ˜¯O(N)O(N)ã€‚ æƒ³å°è¯•ç”¨DPï¼Œä½†æ˜¯æ²¡æœ‰æ˜ç¡®çš„å­é—®é¢˜åˆ†è§£ç•Œçº¿ã€‚ æœ€ä¼˜ç®—æ³•æ˜¯åˆ†æ²»ç®—æ³•ã€‚å°†åºåˆ—é€’å½’çš„ä¸€åˆ†ä¸ºäºŒï¼Œç›´åˆ°åˆ†å‰²æˆé•¿åº¦ä¸º1çš„æ•°ç»„ã€‚åœ¨å›æœ”åœ°åˆå¹¶ç›¸é‚»çš„ä¸¤ä¸ªæ•°ç»„ï¼ŒåŒæ—¶ç»Ÿè®¡åºåˆ—çš„é€†åºæ•°ã€‚åœ¨å›æœ”çš„ä¸€ä¸ªåˆå¹¶è¿‡ç¨‹ä¸­ï¼Œä¸¤ä¸ªæ•°ç»„å·²ç»ä¿æŒæœ‰åºï¼Œä¹Ÿå°±æ˜¯è¯´æ•°ç»„å†…éƒ¨çš„é€†åºæ•°éƒ½ä¸å­˜åœ¨ï¼Œåªç»Ÿè®¡ä¸¤ä¸ªæ•°ç»„é—´çš„é€†åºæ•°ã€‚ ä»£ç ï¼šint InversePairCore(int *A, int *copy, int start, int end){ // the the len of array should be looger than 1. // for example, the function will struggle with [0, 1]. // becaues start = 0, mid = 0, end = 1. Moreover the situtaion never change. if(start + 1 &gt;= end) return 0; int mid = (end + start) / 2; int leftCount = InversePairCore(A, copy, start, mid); int rightCount = InversePairCore(A, copy, mid, end); int midCount = 0; int p1 = mid - 1, p2 = end - 1, p3 = end - 1; while(p1 &gt;= start &amp;&amp; p2 &gt;= mid){ if(A[p1] &gt; A[p2]){ copy[p3] = A[p1]; p3--; p1--; midCount += p2 - mid + 1; } else{ copy[p3] = A[p2]; p3--; p2--; } } while(p1 &gt;= start){ copy[p3] = A[p1]; p3--; p1--; } while(p2 &gt;= mid){ copy[p3] = A[p2]; p3--; p2--; } for(int i = start; i &lt; end; i++) A[i] = copy[i]; return rightCount + midCount + leftCount; } int InversePair(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int *copy = new int(length); // for(int i = 0; i &lt; length; i++) copy[i] = A[i]; return InversePairCore(A, copy, 0, length); }","link":"/2020/08/07/shua-ti-pai-xu-mian-shi-ti-51-ni-xu-shu/"},{"title":"168. Excel Sheet Column Title","text":"168. Excel Sheet Column Titleä»è¿›åˆ¶çš„æ ¹æºå‡ºå‘å¯ä»¥æ›´å½»åº•çš„æ¢ç©¶ç®—æ³•çš„æœ¬æºã€‚26è¿›åˆ¶çš„çš„10è¿›åˆ¶æ•°å€¼è®¡ç®—å¦‚ä¸‹ï¼š$$s = 26^3x_3 + 26^2x_2+ 26^1x_1 + 26^0x_0$$åœ¨è¯¥é¢˜ç›®æ¡ä»¶ä¸‹ï¼Œ$A-Z$åˆ†åˆ«ä»£è¡¨$1-26$ï¼Œä¸ç¬¦åˆä¸Šè¿°è®¡ç®—å…¬å¼ã€‚ä¸€èˆ¬é™¤æ•°å–ä½™æ³•ç›´æ¥é™¤äºè¿›åˆ¶å€¼Kï¼Œï¼ˆåœ¨æœ¬é¢˜ä¸­$K=26$ï¼‰å³å¯è·å–ä½ä½$x_i$ï¼Œä½†æ˜¯ç”±äºé›¶çš„ç¼ºå¤±ï¼Œ$Z=26$çš„æƒ…å†µï¼Œå¦‚ä¸‹å…¬å¼ï¼Œé™¤æ•°å–ä½™æ³•å¤±æ•ˆäº†ã€‚ $$s / 26 = 26^2x_3 + 26^1x_2+ 26^0x_1 + 1, if\\ x_0 = 26$$ä¿®æ”¹çš„è¯ï¼Œå½“æˆ‘ä»¬å‘ç°å½“å‰ä½æ˜¯ 26 çš„æ—¶å€™ï¼Œæˆ‘ä»¬åº”è¯¥åœ¨ç­‰å¼ä¸¤è¾¹å‡å»ä¸€ä¸ª 1 ã€‚å°±å¯ä»¥æŠŠ$$s - 1 = 26^3x_3 + 26^2x_2+ 26^1x_1 + 26^0*(x_0 -1), if\\ x_0 = 26$$ è¿™æ ·ä¸¤è¾¹å†åŒæ—¶é™¤ä»¥ 26 çš„æ—¶å€™ï¼Œå°±å¯ä»¥æŠŠ x1 å»æ‰äº†ã€‚ è¿™ç§æ€è·¯çš„ä»£ç ï¼š class Solution { public: string convertToTitle(int n) { string ans; while(n){ int c = n % 26; if(c == 0){ //æ›´æ·±å±‚æ¬¡ çš„è¯´ï¼Œæˆ‘ä»¬ä»å•†å€Ÿäº†ä¸€ä¸ª1ç»™ä½™æ•°ï¼ c = 26; --n; } ans += c - 1 + 'A'; n /= 26; } reverse(ans.begin(), ans.end()); return ans; } }; æ¢ä¸€ç§æƒ³æ³•ï¼Œä¸¾ä¸ªğŸŒ°æœ‰:$$\\begin{split}54 &amp;= 26 * 2 + 2 \\27 &amp;= 26 * 1 + 1\\end{split}$$54æœ‰ä¸ªä½æ•°2ï¼Œåä½æ•°2ï¼Œåˆ†åˆ«å¯¹åº”Bå’ŒBï¼Œ27æœ‰ä¸ªæ•°ä¸º1ï¼Œåä½æ•°1ï¼Œåˆ†åˆ«å¯¹åº”A,Aã€‚æ‰€ä»¥æœ‰ class Solution { public: string convertToTitle(int n) { string ans; while(n){ // æ³¨æ„è¿™é‡Œä¸ºä»€ä¹ˆä¸æ˜¯ ans = (n - 1) % 26 + 'A'ï¼Œ è€Œæ˜¯è®© n--; // å®é™…ä¸Šç»è¿‡å–ä½™è¿‡åï¼Œåç»­å—å½±å“çš„ç»“æœåªæœ‰ n % 26 == 0çš„æƒ…å†µ // ä¹Ÿå°±æ˜¯è¯´ æœ¬è´¨ä¸Š n-- ä¹Ÿæ˜¯ä¸ºäº†å‘å•†äº†å€Ÿä¸€ä¸ªæ•°å­— n--; ans += n % 26 + 'A'; n /= 26; } reverse(ans.begin(), ans.end()); return ans; } }; æ„Ÿè§‰å¥½ç®€å•ç²—æš´æœ‰æ•ˆå•Šï¼","link":"/2021/01/12/shua-ti-shu-xue-168-excel-sheet-column-title/"},{"title":"169. Majority Element","text":"169. Majority Elementæ€è·¯ï¼šBoyer-Moore æŠ•ç¥¨ç®—æ³• ä»£ç ï¼šclass Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return -1; int a = nums[0]; int ct = 0; for(auto k : nums){ if(k == a){ ++ct; }else if(ct &gt; 0){ --ct; }else{ a = k; ++ct; } } return a; } }; ç¨å¾®ç®€æ´ä¸€ç‚¹ class Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return -1; int a = nums[0]; int ct = 0; for(auto k : nums){ if(ct == 0){ a = k; } ct += k == a ? 1 : -1; } return a; } };","link":"/2021/01/15/shua-ti-shu-xue-169-majority-element/"},{"title":"172. Factorial Trailing Zeroes","text":"æ€è·¯ï¼šé€šè¿‡åˆ¤æ–­1 ~næ‰€æœ‰æ•°å­—å› å­5çš„ä¸ªæ•°åˆ¤æ–­å°¾é›¶çš„æ•°é‡ã€‚å¿«é€Ÿåˆ¤æ–­æ–¹æ³•æ˜¯ï¼šæ•´é™¤ 5ï¼Œ 25ï¼Œ 125ç­‰ç­‰5çš„å€æ•°çš„æ•°å­—å…¶å•†å°±æ˜¯5çš„å€æ•°çš„å› å­æ•°é‡ã€‚ ä»£ç ï¼šclass Solution { public: int trailingZeroes(int n) { int res = 0; while(n){ n /= 5; res += n; } return res; } };","link":"/2021/01/07/shua-ti-shu-xue-172-factorial-trailing-zeroes/"},{"title":"202. Happy Number","text":"202. Happy Numberæ€è·¯ï¼š setæŸ¥é‡å¤æ•°å­—ä½œä¸ºé‡å¤æ•°å­—çš„æŠ½å–æ–¹æ³•ï¼Œå¾ªç¯éå† å‡è®¾è¯¥æ­¥éª¤æ€»ä¼šæ‰¾åˆ°ä¸€ä¸ªæ•°å­—ç¯ï¼Œå¿«æ…¢æŒ‡é’ˆæ³•å¯ä»¥ç±»æ¯”åˆ°è¯¥ç®—æ³•ã€‚å€¼å¾—æ³¨æ„çš„ï¼Œæœ€åhappy numberæœ€åå½¢æˆæ˜¯çš„æ•°å­—1çš„è‡ªç¯ï¼Œå¿…å®šåœç•™åœ¨1ä¸Šã€‚è€Œé happy numberæœ€åå½¢æˆçš„ç¯ä¸€å®šæ²¡æœ‰1ã€‚ ä»£ç ï¼šclass Solution { public: bool isHappy(int n) { unordered_set&lt;int&gt; nums; //hashsetæ›´å¿« while(n != 1 &amp;&amp; nums.count(n) == 0){ int newn = n,sum = 0; while(newn){ sum += (newn % 10 ) * ( newn % 10 ); newn /= 10; } nums.insert(n); n = sum; } if(n == 1) return true; else return false; } }; å¿«æ…¢æŒ‡é’ˆæ³• class Solution { public: int next(int n){ int newn = n,sum = 0; while(newn){ sum += (newn % 10 ) * ( newn % 10 ); newn /= 10; } return sum; } bool isHappy(int n) { int p1 = next(n); int p2 = next(next(n)); while(p1 != p2){ p1 = next(p1); p2 = next(next(p2)); } if(p1 == 1) return true; else return false; } };","link":"/2021/01/15/shua-ti-shu-xue-202-happy-number/"},{"title":"204. Count Primes","text":"204. Count Primesæ€è·¯ï¼š åŸƒæ°ç­› $O(nloglogn)$ çº¿æ€§ç­›$O(nlogn)$ï¼Œä¸è¿‡ç”±äºå–æ¨¡çš„è¿ç®—é‡å¤ªå¤§ï¼Œé€Ÿåº¦å¯èƒ½è¿˜ä¸å¦‚åŸƒæ°ç­› ä»£ç ï¼šåŸƒæ°ç­› class Solution { public: int countPrimes(int n) { if(n &lt;= 1) return 0; vector&lt;int&gt; prime(n + 10); int idx = 0; for(int i = 2; i &lt; n; ++i){ if(prime[i] == 0){ prime[idx++] = i; if(sqrt(INT_MAX) &gt; i) for(int j = i * i; j &lt;= n; j += i) prime[j] = 1; } } return idx; } }; çº¿æ€§ç­› class Solution { public: int countPrimes(int n) { if(n &lt;= 1) return 0; vector&lt;int&gt; prime(n + 10); int idx = 0; for(int i = 2; i &lt; n; ++i){ if(prime[i] == 0) prime[idx++] = i; for(int j = 0; j &lt; idx &amp;&amp; prime[j] * i &lt; n; ++j){ prime[prime[j] * i] = 1; if(i % prime[j] == 0) break; } } return idx; } };","link":"/2021/01/07/shua-ti-shu-xue-204-count-primes/"},{"title":"238. Product of Array Except Self","text":"238. Product of Array Except Selfæ€è·¯ï¼šfollow up è¦æ±‚ç©ºé—´ä¸º$O(n)$ï¼Œå¦‚æœè¾“è¾“å‡ºæ•°ç»„ä¸ç®—ç©ºé—´çš„è¯ï¼Œå¯ä»¥è¿™æ˜¯å¯ä»¥è¾¾åˆ°çš„ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { getProduct(0, 1, nums); return nums; } using ll = long long; ll getProduct(int i, ll lprod, vector&lt;int&gt; &amp;nums){ if(i == nums.size()) return 1; ll nprod = lprod * nums[i]; ll rprod = getProduct(i + 1, nprod, nums); int val = nums[i]; nums[i] = lprod * rprod; return val * rprod; } };","link":"/2021/01/12/shua-ti-shu-xue-238-product-of-array-except-self/"},{"title":"313. Super Ugly Number","text":"313. Super Ugly Numberæ€è·¯ä¸‘æ•°çš„æ¯ä¸ªå‰èº«éƒ½æ˜¯ä¸‘æ•°ï¼Œä¸‘ä¸ŠåŠ ä¸‘ã€‚ ä»£ç class Solution { public: int findDuplicate(vector&lt;int&gt;&amp; nums) { // return accumulate(nums.begin(), nums.end(), 0) - (nums.size()- 1) * nums.size() / 2; int p1 = 0, p2 = 0; do{ p1 = nums[nums[p1]]; p2 = nums[p2]; }while(p1 != p2); p2 = 0; while(p1 != p2){ p1 = nums[p1]; p2 = nums[p2]; } return p1; // p1æ‰æ˜¯é‡å¤çš„æ•°å­—/idx } };","link":"/2021/02/05/shua-ti-shu-xue-313-super-ugly-number/"},{"title":"382. Linked List Random Node","text":"382. Linked List Random Nodeæ€è·¯ï¼šè®©æˆ‘æƒ³èµ·æ¥ä¹‹å‰æ¥å®å¤§è®²åº§çš„ç¾å›½æ•™æˆçš„å‡ºçš„æŠ½å–è½¦æµé¢˜ç›®ã€‚ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è“„æ°´æ± æŠ½æ ·ç®—æ³•ï¼ˆReservoir Samplingï¼‰: è€ƒè™‘æŠ½å–ä¸€ä¸ªæ ·ä¾‹çš„æƒ…å†µï¼šæˆ‘ä»¬ä»å¤´éå†ä¸€ä¸ªListï¼Œå¹¶ä»¥$1/k$çš„æ¦‚ç‡æŠŠç¬¬kä¸ªå…ƒç´ ä¿ç•™ä¸‹æ¥ã€‚ å¯ä»¥ç”±å½’çº³æ³•å¾—ï¼š ç¬¬k-1ä¸ªå…ƒç´ çš„ä¿ç•™æ¦‚ç‡æ˜¯$1/(k - 1)$ï¼Œåœ¨ç¬¬Kä¸ªå…ƒç´ éå†æ—¶ï¼Œç¬¬K-1æ¬¡éå†æ˜¯è¢«ä¿ç•™çš„å…ƒç´ åœ¨è¿™æ¬¡è¢«ä¿ç•™çš„æ¦‚ç‡æ˜¯$\\frac{1}{k-1} * \\frac{k - 1}{k}= \\frac{1}{k}$ ã€‚ è¿™å°±ä¿è¯äº†éå†ä¸€éå…¨éƒ¨æ•°ç»„åï¼Œå„ä¸ªå…ƒç´ è¢«æŠ½å–çš„ç­‰æ¦‚ç‡æ€§è´¨ã€‚ å†è€ƒè™‘k&gt;1çš„æƒ…å†µï¼Œè¯æ˜æ›´å¤æ‚ä¸€ç‚¹ï¼š å®ç°ä»£ç ï¼š import java.util.Random; Class Solution{ public static void main(String[] args){ int[] nums = new int[]{1, 2, 3, 4, 5}; Solution s = new Solution(); int[] ans = s.sample(nums, 3); for(int i = 0; i &lt; ans.length; i++){ System.out.printf(&quot;%d &quot;, ans[i]); } } private int[] sample(int[] nums, int n){ Random rd = new Random(); int[] ans = new int[n]; for(int i = 0; i &lt; nums.length; i++){ if(i &lt; n){ ans[i] = nums[i]; } else { if(rd.nextInt(i+1) &lt; n){ ans[rd.nextInt(n)] = nums[i]; } } } return ans; } } ä»£ç  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private: ListNode* head; int ct = 0; public: /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* _head): head(_head) { // newp = p = head; } /** Returns a random node's value. */ int getRandom() { //è“„æ°´æ± éšæœºæŠ½å–ç®—æ³• ListNode *p = head, *newp = head; int ct = 0; while(newp){ ++ct; if(rand() % ct == 0){ p = newp; } newp = newp-&gt;next; } return p-&gt;val; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(head); * int param_1 = obj-&gt;getRandom(); */","link":"/2021/01/10/shua-ti-shu-xue-382-linked-list-random-node/"},{"title":"384. Shuffle an Array","text":"æ€è·¯ï¼šFisher-Yates shuffleæ´—ç‰Œç®—æ³•ï¼šé€ä¸ªéå†äº¤æ¢åç»­éšæœºå…ƒç´ ã€‚ ä»£ç åæ´—ç®—æ³• class Solution { vector&lt;int&gt; origin; public: Solution(vector&lt;int&gt;&amp; nums) :origin(nums) {} /** Resets the array to its original configuration and return it. */ vector&lt;int&gt; reset() { return origin; } /** Returns a random shuffling of the array. */ vector&lt;int&gt; shuffle() { vector&lt;int&gt; shuffled(origin); if(origin.size() == 0) return shuffled; for(int i = origin.size() - 1; i &gt;= 0; --i){ //è¿˜å¯ä»¥åç€æ´— swap(shuffled[i], shuffled[rand() % (i + 1)]); } return shuffled; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(nums); * vector&lt;int&gt; param_1 = obj-&gt;reset(); * vector&lt;int&gt; param_2 = obj-&gt;shuffle(); */","link":"/2021/01/09/shua-ti-shu-xue-384-shuffle-an-array/"},{"title":"415. Add Strings","text":"415. Add Stringsæ€è·¯ï¼šä¸€èˆ¬çš„å¤§æ•°ç›¸åŠ ï¼Œä¸è¿‡ç”¨é«˜ä½è¡¥é›¶çš„æ–¹æ³•å¯ä»¥å¤§å¤§å‡å°‘ä»£ç å¤æ‚åº¦ï¼Œæ–¹ä¾¿ç¼–ç¨‹ã€‚ æ€è·¯ï¼šclass Solution { public: string addStrings(string num1, string num2) { string ans; int add = 0; int i = num1.size() - 1, j = num2.size() - 1; //ä½ä½ç›¸åŠ  while(i &gt;= 0 &amp;&amp; j &gt;= 0){ int sum = add + num1[i--] + num2[j--] - 2 * '0'; ans = to_string(sum % 10) + ans; add = sum / 10; } string c; //å‰©ä½™é«˜ä½ if(i &gt;= 0) c = num1.substr(0, i + 1); if(j &gt;= 0) c = num2.substr(0, j + 1); string num3; // é«˜ä½ä¸addç›¸åŠ  if(add){ int k = c.size() - 1; while(k &gt;= 0){ int sum = add + c[k--] - '0'; num3 = to_string(sum % 10) + num3;//é‡å»ºä¸€ä¸ªstringå¤ªè€—æ—¶é—´äº† add = sum / 10; } if(add) num3 = to_string(add) + num3; }else num3 = c; return num3 + ans; } }; ä¼˜åŒ–ä¸€ä¸‹ class Solution { public: string addStrings(string num1, string num2) { string ans; int add = 0; int i = num1.size() - 1, j = num2.size() - 1; while(i &gt;= 0 || j &gt;= 0){ int a1 = i &gt;= 0 ? num1[i--] - '0' : 0; int a2 = j &gt;= 0 ? num2[j--] - '0' : 0; int sum = add + a1 + a2; ans = to_string(sum % 10) + ans; add = sum / 10; } return (add == 0 ? &quot;&quot; : &quot;1&quot;) + ans; } };","link":"/2021/01/07/shua-ti-shu-xue-415-add-strings/"},{"title":"462. Minimum Moves to Equal Array Elements II","text":"462. Minimum Moves to Equal Array Elements II ç¬¬Kå¤§æ€è·¯ï¼š ç¬¬ä¸€æ¬¡åšï¼Œçœ‹çœ‹æ•°æ®çš„å½¢å¼ä¼¼ä¹å…·æœ‰å‡¹å‡½æ•°çš„æ€§è´¨ï¼Œäºæ˜¯ç”¨ä¸‰åˆ†æ³•æœç´¢æ•°å€¼ã€‚èœé¸¡å¦‚æˆ‘ï¼Œæ²¡æœ‰æ€»ç»“è¿‡ä¸‰åˆ†ï¼Œæœ‰äº›åœ°æ–¹å†™é”™äº†ï¼Œwaäº†ä¸€æ¬¡ï¼Œintè¶…èŒƒå›´äº†ä¸€æ¬¡ã€‚è¿™é¢˜å¥½åå•Šã€‚ç®—æ³•å¤æ‚åº¦$o(nlogn)$ã€‚ è¿˜æœ‰ä¸€ç§æ€è·¯æ˜¯æ’åºåï¼Œä¾ç…§å‡¹å‡½æ•°æ€§è´¨äºŒåˆ†æœç´¢ä¹Ÿå¯ä»¥ï¼å¤æ‚åº¦$o(nlogn + nlogn)$ ï¼Œè¿˜æ˜¯æˆ‘å¿«ï¼Œä¸è¿‡æˆ‘çš„nä¸æ˜¯ä»–çš„nã€‚ çœ‹é¢˜è§£ï¼Œå‘ç°å¯»æ‰¾ä¸­ä½æ•°çš„æ–¹æ³•ï¼Œæ›´å¥½æ›´å®¹æ˜“è¯æ˜ï¼Œ å¯ä»¥å‘ç°ï¼Œå¥‡æ•°ä¸ªæ•°ç»„çš„ä¸­ä½æ•°å®¹æ˜“çš„ï¼Œå¦‚æœåœ¨å¶æ•°ä¸ªæ•°å­—çš„æ•°ç»„ä¸­ï¼Œä¸­ä½æ•°å…¬å¼ï¼š$$mid_element = \\frac{Arr[size / 2] + Arr[size / 2 + 1]}{2}$$å¹¸è¿çš„æ˜¯ï¼Œåœ¨è¯¥é¢˜æ„ä¸‹ï¼Œç›´æ¥ä½¿ç”¨$Arr[size / 2]$çš„è®¡ç®—å€¼å’Œä½¿ç”¨$min_element$æ•ˆæœä¸€è‡´ã€‚é¢˜æ„å¯ä»¥åŒ–ç®€ã€‚ ä¸Šé¢˜çš„ä»£ç ï¼Œè¿˜å¯æ˜¯ä½¿ç”¨ç¬¬$k$å¤§æ•°å­—é¢˜ç›®ä½¿ç”¨çš„ç®—æ³•æ¥æ±‚è§£ã€‚ ä»£ç ï¼š1 class Solution { public: using ll = long long; //è¿™é¢˜å¤ªåäº† ll gap(vector&lt;int&gt; &amp; nums, ll g){ ll res = 0; for(auto k : nums){ res += abs(k - g); } return res; } ll minMoves2(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int maxv = *max_element(nums.begin(), nums.end()); int minv = *min_element(nums.begin(), nums.end()); while(minv &lt; maxv){ int mid1 = (maxv - minv) / 3 + minv; int mid2 = (maxv - minv) * 2 / 3 + minv; if(mid1 == mid2) ++mid2; //[minv, maxv] = [0, 1] ll r1 =gap(nums, mid1), r2 = gap(nums, mid2); if(r1 &gt; r2){ minv = mid1 + 1; }else if(r2 &gt; r1){ maxv = mid2 - 1; }else{ if(mid1 == mid2){ minv = maxv = mid1; break; } minv = mid1 + 1; maxv = mid2 - 1; } // cout &lt;&lt; minv &lt;&lt; ' ' &lt;&lt; maxv &lt;&lt; endl; } return gap(nums, minv); } }; 2 class Solution { public: int minMoves2(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int l=0,r=nums.size()-1,mid; while(l&lt;r){ mid=(l+r)&gt;&gt;1; if(sumof(nums[mid],nums)&lt;sumof(nums[mid]+1,nums)) r=mid; //åˆ©ç”¨äº†å‡¹å‡½æ•°çš„ç‰¹æ€§ else l=mid+1; } return sumof(nums[l],nums); } long sumof(int n,vector&lt;int&gt;&amp; nums){ long sum=0; for(int i=0;i&lt;nums.size();i++){ sum+=abs(nums[i]-n); } return sum; } }; 3 class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ sort(nums.begin(), nums.end()); ll sum = 0; for(auto k : nums){ sum+=abs(k - nums[nums.size() / 2]); } return sum; } }; 4 class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end());//å·æ‡’ ll sum = 0; for(auto k : nums){ sum+=abs(k - nums[nums.size() / 2]); } return sum; } }; æˆ‘çš„å®ç°ï¼šæ•ˆç‡å·¨ä½ class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ my_nth_element(nums, 0, nums.size(), nums.size() / 2); ll sum = 0; for(auto k : nums){ sum+= abs(k - nums[nums.size() / 2]); } return sum; } int partition(vector&lt;int&gt; &amp;nums, int s, int e){ int l = s, r = e - 1, temp = nums[s]; while(l &lt; r){ while(l &lt; r &amp;&amp; nums[r] &gt;= temp) --r; swap(nums[r], nums[l]); while(l &lt; r &amp;&amp; nums[l] &lt;= temp) ++l; swap(nums[r], nums[l]); } // nums[l] = temp; return l; } void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k){ if(s == e) return; int idx = partition(nums, s, e); if(idx == k) return; else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k); else my_nth_element(nums, s, idx, k); // bugs, e æ˜¯è¾¹ç•Œï¼Œ æ‰€ä»¥ä¸èƒ½å– s - 1 } }; ç¬¬Kå¤§ç®—æ³•ä¸­å¦ä¸€ç§patitionç®—æ³•ã€‚ class Solution { public: using ll = long long; long minMoves2(vector&lt;int&gt;&amp; nums){ my_nth_element(nums, 0, nums.size(), nums.size() / 2); ll sum = 0; for(auto k : nums){ sum+= abs(k - nums[nums.size() / 2]); } return sum; } // int partition(vector&lt;int&gt; &amp;nums, int s, int e){ // int l = s, r = e - 1, temp = nums[s]; // while(l &lt; r){ // while(l &lt; r &amp;&amp; nums[r] &gt;= temp) --r; // swap(nums[r], nums[l]); // while(l &lt; r &amp;&amp; nums[l] &lt;= temp) ++l; // swap(nums[r], nums[l]); // } // // nums[l] = temp; // return l; // } // è¯¥ç®—æ³•åŸºäºä¸€ç§æœ´ç´ çš„æƒ³æ³•ï¼šæŠŠå°çš„å‰é¢ï¼Œå¤§çš„æ”¾åé¢ int partition(vector&lt;int&gt; &amp;nums, int s, int e){ int i = s, pivot = nums[e - 1]; for(int j = s; j &lt; e; ++j){ if(nums[j] &lt; pivot){ swap(nums[i], nums[j]); ++i; } } swap(nums[i], nums[e - 1]); return i; } void my_nth_element(vector&lt;int&gt; &amp;nums, int s, int e, int k){ if(s == e) return; int idx = partition(nums, s, e); if(idx == k) return; else if(idx &lt; k) my_nth_element(nums, idx + 1, e, k); else my_nth_element(nums, s, idx, k); // bugs, e æ˜¯è¾¹ç•Œï¼Œ æ‰€ä»¥ä¸èƒ½å– s - 1 } };","link":"/2021/01/14/shua-ti-shu-xue-462-minimum-moves-to-equal-array-elements-ii/"},{"title":"470. Implement Rand10() Using Rand7()","text":"470. Implement Rand10() Using Rand7()æ€è·¯ï¼šåˆ©ç”¨7è¿›åˆ¶ç”Ÿæˆç­‰æ¦‚ç‡æ•°å€¼ï¼ŒåŒæ—¶é™åˆ¶ç”Ÿæˆæ•°çš„èŒƒå›´ï¼Œä¿è¯å–ä½™çš„èŒƒå›´å†…å„ä¸ªä½™æ•°çš„ç”Ÿæˆæ¦‚ç‡ç›¸ç­‰ ä»£ç ï¼šç¬¬ä¸€æ¬¡waæ˜¯å› æ²¡æœ‰è€ƒè™‘å–ä½™åæ˜ å°„çš„æ•°å­—çš„ç”Ÿæˆæ¦‚ç‡ä¸ç­‰äº†ã€‚ // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 class Solution { public: //åˆ©ç”¨7è¿›åˆ¶ç”Ÿæˆç­‰æ¦‚ç‡æ•°å€¼ï¼ŒåŒæ—¶é™åˆ¶ç”Ÿæˆæ•°çš„èŒƒå›´ï¼Œä¿è¯å–ä½™çš„èŒƒå›´å†…å„ä¸ªä½™æ•°çš„ç”Ÿæˆæ¦‚ç‡ç›¸ç­‰ int rand10() { int c; do{ int a = rand7()- 1; int b = rand7() - 1; c = a * 7 + b; }while(c &gt;= 40); return c % 10 + 1; } };","link":"/2021/01/15/shua-ti-shu-xue-470-implement-rand10-using-rand7/"},{"title":"504. Base 7","text":"504. Base 7æ€è·¯ï¼šåˆ©ç”¨å–ä½™å’Œæ±‚æ¨¡è·å–å„ä¸ªä½çš„æ•°å€¼ï¼Œè¦æ³¨æ„é›¶ï¼Œæ­£è´Ÿç¬¦å·ï¼Œæ•°å­—å¤§å°ï¼ˆå¯èƒ½ä¼šæº¢å‡ºï¼‰ç­‰æ¡ä»¶ã€‚ ä»£ç ï¼šclass Solution { public: string convertToBase7(int num) { if(num == 0) return &quot;0&quot;; string res , flag; if( num &lt; 0){ flag = &quot;-&quot;; num = -num; } while(num){ int w = num % 7; num = num / 7; res = char('0' + w) + res; //è¿™é‡Œçš„å¼ºåˆ¶ç±»å‹è½¬æ¢æ˜¯å¿…è¦çš„ } return flag + res; } };","link":"/2021/01/07/shua-ti-shu-xue-504-base-7/"},{"title":"528. Random Pick with Weight","text":"528. Random Pick with Weightæ€è·¯ï¼šé€šè¿‡å‰ç¼€å’Œæ˜ å°„æƒé‡åˆ°æ•°ç»„ï¼Œæ–¹ä¾¿é€šè¿‡äºŒåˆ†æŸ¥æ‰¾è¿›è¡ŒéšæœºæŠ½å–ã€‚ ä»£ç ï¼šclass Solution { vector&lt;int&gt; w; int n; int mod; public: Solution(vector&lt;int&gt;&amp; _w) : w(_w) { int sum = 0; for(auto &amp;i : w){ sum += i; i = sum; } mod = sum; n = w.size(); } int pickIndex() { int s = rand() % mod; // åœ¨[0, sum) éšæœºæŠ½å–ä¸€ä¸ªæ•°ï¼Œä½œä¸ºæ˜ å°„ä¸‹æ ‡ auto it = lower_bound(w.begin(), w.end(), s); // find the first iterator that this element is not less the value; value &lt;= (*it) if(*it == s) it++; return it - w.begin(); } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-&gt;pickIndex(); */ æ‰‹å†™äºŒåˆ† class Solution { vector&lt;int&gt; w; int n; int mod; public: Solution(vector&lt;int&gt;&amp; _w) : w(_w) { int sum = 0; for(auto &amp;i : w){ sum += i; i = sum; } mod = sum; n = w.size(); } int pickIndex() { int s = rand() % mod; // åœ¨[0, sum) éšæœºæŠ½å–ä¸€ä¸ªæ•°ï¼Œä½œä¸ºæ˜ å°„ä¸‹æ ‡ int l = 0, r = n - 1; while(l &lt; r){ int mid = (r - l) / 2 + l; if(w[mid] &lt;= s) l = mid + 1; else r = mid; } return r; } }; /** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(w); * int param_1 = obj-&gt;pickIndex(); */","link":"/2021/01/10/shua-ti-shu-xue-528-random-pick-with-weight/"},{"title":"67. Add Binary","text":"67. Add Binary ä»£ç ï¼šclass Solution { public: string addBinary(string a, string b) { if(a == &quot;&quot; || b == &quot;&quot;) return a == &quot;&quot; ? b : a; int i = a.size() - 1, j = b.size() - 1, add = 0; string ans = &quot;&quot;; while(i &gt;= 0 || j &gt;= 0){ int numa = i &lt; 0 ? 0 : a[i] - '0'; int numb = j &lt; 0 ? 0 : b[j] - '0'; --i, --j; int sum = numa + numb + add; add = sum / 2; sum %= 2; ans.push_back(sum + '0'); } if(add){ ans.push_back(add + '0'); } reverse(ans.begin(), ans.end()); return ans; } };","link":"/2021/01/12/shua-ti-shu-xue-67-add-binary/"},{"title":"972.Equal Rational Numbers","text":"972. Equal Rational Numbersæ€è·¯ä¸æ­¢ä¸€ç§ï¼Œè€è€å®å®æ•²æ•²ä»£ç ä½†ä¸æƒ³ä¼˜åŒ–æ–¹æ³•çš„äººæ˜¯æ²¡æœ‰å‰é€”çš„ã€‚ æ€è·¯ï¼šç¬¬ä¸€ç§ï¼šæŒ‰å­—ç¬¦åŒ¹é…æ¨¡å¼åˆ†ç±»è®¨è®º ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½æ²¡æœ‰é‡å¤å­—ç¬¦ä¸²ï¼šç›´æ¥å»å°¾é›¶æ¯”è¾ƒç›¸ç­‰å€¼ã€‚ åªæœ‰ä¸€ä¸ªå­—ç¬¦ä¸²æœ‰é‡å¤å­—ç¬¦ä¸²ï¼šåªæœ‰ä¸€ç§æƒ…å†µå¯ä»¥ç›¸ç­‰ï¼Œå°±æ˜¯é¢˜ç›®ä¸­æ— é™æ¥è¿‘çš„æƒ…å†µï¼Œæ¯”å¦‚â€œ0.9(9)==1.0â€ã€‚å½“ç„¶å¯ä»¥ç”¨æ•°å­¦è¯æ˜çš„ï¼Œä¸¤è€…ç›¸ç­‰ã€‚ç”¨è¯­è¨€æè¿°æ¯”è¾ƒéº»çƒ¦ï¼Œæ„ä¼šå§ã€‚ ä¸¤ä¸ªå­—ç¬¦ä¸²éƒ½æœ‰é‡å¤å­—ç¬¦ä¸²ï¼šå°†é‡å¤å­—ç¬¦ä¸²å±•å¼€å¤šæ¬¡ï¼Œå°½å¯èƒ½æ¯”è¾ƒç›¸åŒé•¿åº¦å†…å®¹å³å¯ã€‚ ç¬¬äºŒç§ï¼šåŒ–ä¸ºæ•°å€¼æ³•ï¼ é‡å¤æ¨¡å¼ä¸²çš„æ•°å€¼éƒ¨åˆ†å¯ä»¥è®¡ç®—,æ¯”å¦‚ï¼š$$0.00(66)=\\frac{1}{100} + \\frac{66}{100} + \\frac{66}{10000}\\cdots$$é‚£ä¹ˆä¸€èˆ¬å°±æœ‰$$0.(s) = \\frac{s}{10^k }+ \\frac{s}{10^{2k} \\cdots} \\\\= s*(\\frac{1}{10^k} + \\frac{1}{10^{2k}} \\cdots)\\\\= s * (limt_{ \\ n\\rightarrow\\infty}\\frac{\\frac{1}{10^k}-\\frac{1}{(10^k)^n}}{1-\\frac{1}{10^k}})\\\\= s * \\frac{\\frac{1}{10^k}}{1-\\frac{1}{10^k}}\\\\which\\ k \\ is \\ the\\ len\\ of\\ s.$$éé‡å¤éƒ¨åˆ†æ›´å®¹æ˜“è®¡ç®—ã€‚ é‚£ä¹ˆä¹‹åç”¨åˆ†æ•°ç±»æ¥è®¡ç®—ç»“æœå³å¯ã€‚ ä»£ç ï¼šè€å®äººä»£ç  class Solution { public: // if find() cant find the char or string, it will retunr str::string::npos; // static const size_t npos = -1; the size_t is unsigned int type. void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS){ int pointPos = input.find(&quot;.&quot;); if(pointPos != string::npos) integerS = input.substr(0, pointPos); else{ integerS = input; nonreS = reS = &quot;&quot;; return; } int parPos = input.find(&quot;(&quot;); if(parPos != string::npos){ nonreS = input.substr(pointPos + 1, parPos - pointPos - 1); reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1); }else{ nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1); reS = &quot;&quot;; } if( reS == &quot;&quot; || stol(reS) == 0){ reS = &quot;&quot;; int pos = nonreS.size() - 1; while(pos &gt;= 0 &amp;&amp; nonreS[pos] == '0') pos--; if(pos &gt;= 0) nonreS = nonreS.substr(0, pos + 1); else nonreS = &quot;&quot;; if(integerS == &quot;&quot; || stol(integerS) == 0) integerS = &quot;0&quot;; } } bool isNineNum(string S){ for(int i = 0; i &lt; S.size(); i++) { if(S[i] != '9') return false; } return true; } string strmul(string s, int time){ string res = &quot;&quot;; for(int i = 0; i &lt; time; i++){ res += s; } return res; } //must comfire reS2 == &quot;&quot; bool isfiniteEqual(string integerS1, string nonreS1, string reS1, string integerS2, string nonreS2, string reS2){ if(!isNineNum(reS1) || reS2.size() != 0) return false; int pos = nonreS1.size() - 1; for(;pos &gt;= 0; pos --){ if(nonreS1[pos] != '9') break; } if(nonreS2.size() != pos + 1) return false; int num1 = stol(integerS1 + nonreS1.substr(0, pos + 1)); int num2 = stol(integerS2 + nonreS2); if(num1 + 1 != num2) return false; return true; } bool ispartEqual(string s1, string s2){ // cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2 &lt;&lt; endl; if(s1.size() &gt; s2.size()) return false; if(s2.substr(0, s1.size()) == s1) return true; return false; } bool isRationalEqual(string S, string T) { string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2; getNum(S, integerS1, nonreS1, reS1); getNum(T, integerS2, nonreS2, reS2); if(reS1.size() == 0 &amp;&amp; reS2.size() == 0){ if(integerS1 == integerS2 &amp;&amp; nonreS1 == nonreS2) return true; } else if(reS1.size() == 0 || reS2.size() == 0){ if(isfiniteEqual(integerS1, nonreS1, reS1, integerS2, nonreS2, reS2) || isfiniteEqual(integerS2, nonreS2, reS2, integerS1, nonreS1, reS1)) return true; } else{ int l1 = reS1.size(), l2= reS2.size(); string str1 = integerS1 + nonreS1 + strmul(reS1, reS2.size() + 2); string str2 = integerS2 + nonreS2 + strmul(reS2, reS1.size() + 2); if(ispartEqual(str1, str2) || ispartEqual(str2, str1)) return true; } return false; } }; æ•°å€¼è®¡ç®— å¼±é¸¡çš„ä»£ç  typedef long long ll; class fraction{ public: ll n, d; fraction(ll _n, ll _d){ n = _n; d = _d; if(_d == 0) d = 1; } void add(fraction s){ n = n * s.d + d * s.n; d *= s.d; clear(); print(fraction(n, d)); print(s); } bool equal(fraction s){ if(s.d == d &amp;&amp; s.n == n) return true; return false; } private: ll gcd(ll a, ll b){ return b?gcd(b, a%b):a; } void clear(){ int gcdN = 1; if(n == 0) gcdN = 1; else gcdN = gcd(d , n); n /= gcdN; d /= gcdN; if(n == 0) d = 1; } }; // class Solution { public: void getNum(string input, string &amp;integerS, string &amp;nonreS, string &amp;reS){ int pointPos = input.find(&quot;.&quot;); if(pointPos != string::npos) integerS = input.substr(0, pointPos); else{ integerS = input; nonreS = reS = &quot;&quot;; return; } int parPos = input.find(&quot;(&quot;); if(parPos != string::npos){ nonreS = input.substr(pointPos + 1, parPos - pointPos - 1); reS = input.substr(parPos + 1, input.size() - 1 - parPos - 1); }else{ nonreS = input.substr(pointPos + 1, input.size() - pointPos - 1); reS = &quot;&quot;; } } ll pow10(ll l){ ll ans = 1; while(l &gt; 0){ ans *= 10; l--; } return ans; } ll mystol(string s){ if(s == &quot;&quot;) return 0; else return stol(s); } fraction getFraction(string integer, string nonreS, string reS){ fraction no1 = fraction(mystol(integer), 1); int nonreLen = nonreS.size(); int reLen = reS.size(); fraction no2 = fraction(mystol(nonreS), pow10(nonreLen)); fraction no3 = fraction(mystol(reS), pow10(nonreLen) * (pow10(reLen) - 1) ); no1.add(no2); no1.add(no3); return no1; } bool isRationalEqual(string S, string T) { string integerS1 , integerS2, nonreS1, nonreS2, reS1, reS2; getNum(S, integerS1, nonreS1, reS1); getNum(T, integerS2, nonreS2, reS2); fraction frac1 = getFraction(integerS1, nonreS1, reS1); fraction frac2 = getFraction(integerS2, nonreS2, reS2); if(frac1.equal(frac2)) return true; return false; } };","link":"/2020/09/21/shua-ti-shu-xue-972-equal-rational-numbers/"},{"title":"é”™æ’é—®é¢˜:å¹´ä¼šæŠ½å¥–","text":"æ‰€è°“é”™æ’é—®é¢˜å°±æ˜¯Nä¸ª1~Næ•°å­—çš„åºåˆ—éƒ½æ°å¥½ä¸åœ¨å¯¹åº”ä½ä¸Šï¼Œæ¯”å¦‚åºåˆ—3 1 2 ã€‚ é¢˜ç›®ï¼šå¹´ä¼šæŠ½å¥–ä»Šå¹´å…¬å¸å¹´ä¼šçš„å¥–å“ç‰¹åˆ«ç»™åŠ›ï¼Œä½†è·å¥–çš„è§„çŸ©å´å¾ˆå¥‡è‘©ï¼š é¦–å…ˆï¼Œæ‰€æœ‰äººå‘˜éƒ½å°†ä¸€å¼ å†™æœ‰è‡ªå·±åå­—çš„å­—æ¡æ”¾å…¥æŠ½å¥–ç®±ä¸­ï¼› å¾…æ‰€æœ‰å­—æ¡åŠ å…¥å®Œæ¯•ï¼Œæ¯äººä»ç®±ä¸­å–ä¸€ä¸ªå­—æ¡ï¼› å¦‚æœæŠ½åˆ°çš„å­—æ¡ä¸Šå†™çš„å°±æ˜¯è‡ªå·±çš„åå­—ï¼Œé‚£ä¹ˆâ€œæ­å–œä½ ï¼Œä¸­å¥–äº†ï¼â€ç°åœ¨å‘Šè¯‰ä½ å‚åŠ æ™šä¼šçš„äººæ•°ï¼Œè¯·ä½ è®¡ç®—æœ‰å¤šå°‘æ¦‚ç‡ä¼šå‡ºç°æ— äººè·å¥–ï¼Ÿ æ€è·¯é¦–å…ˆæ‰€æœ‰æ•°å­—å¯èƒ½çš„æ’åˆ—é¡ºåºä¸º$n!$ï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚å‡ºæ‰€æœ‰å¯èƒ½å‡ºç°çš„é”™æ’ä¹¦å°±è¡Œã€‚ é‡‡ç”¨æ’é™¤æ³•ï¼Œè®°$a_i$æ˜¯$i$ä¸ªæ•°å­—é”™æ’çš„æ•°é‡ï¼Œ é€šè¿‡å¹¶é›†è®¡ç®—å…¬å¼ï¼Œæ’é™¤æ‰$k, 1 &lt;= k &lt;= n $ä¸ªæ•°å­—æ’åˆ—æ­£ç¡®æ’åˆ—çš„æ‰€æœ‰æƒ…å†µ$$P(A) = n! - n * a_{n -1} + n * (n -1) /2 * a_{n-2} â€¦. \\\\= n! - n * (n - 1)! + \\frac{n!}{2!} - \\frac{n!}{3!} â€¦.=\\frac{n!}{2!} - \\frac{n!}{3!} â€¦.= \\sum_{k=2}^{n}{(-1)^k} \\frac{n!}{k!}$$ä¸Šå¼ä¸­ï¼Œ1ä¸ªæ•°å­—æ’åˆ—æ­£ç¡®çš„åºåˆ—ä¿æŠ¤äº†2ä¸ªæ•°åˆ—æ’åˆ—æ­£ç¡®çš„æƒ…å†µï¼Œ2ä¸ªæ•°å­—æ’åˆ—æ­£ç¡®çš„åºåˆ—ä¿æŠ¤äº†3ä¸ªæ•°åˆ—æ’åˆ—æ­£ç¡®çš„æƒ…å†µï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨å¹¶é›†å…¬å¼ã€‚ æ¢ä¸€ç§æƒ³æ³•ï¼š å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œé”™æ’çš„åºåˆ—3 4 1 2æœ‰ä½ç½®å¯¹æ¢çš„æ•°å­—2å’Œ4ï¼Œå¦‚æœå›ºå®šè¿™ä¸¤ä¸ªæ•°å­—ï¼Œå‰©ä¸‹çš„æ•°å­—è¿›è¡Œé”™æ’æœ‰3 1ã€‚å¯ä»¥è§‚å¯Ÿåˆ°åºåˆ—æ•°é‡å‡å°‘äº†ï¼Œä¸ç”±æœ‰é€’æ¨çš„å‘³é“ã€‚ é‚£å¦‚æœæœ€åä¸€ä¸ªæ•°å­—æ²¡æœ‰ä¸ä½ç½®å¯¹æ¢å‘¢ï¼Ÿå¦‚2 3 4 1 ï¼Œä¸ºäº†åŒæ ·è·å–n-1ä¸ªå¯ä»¥é”™æ’çš„æ•°æ®ï¼ˆæ•°æ®å’Œå‘ä½å¯ä»¥ä¸€ä¸€å¯¹åº”ï¼‰ï¼ŒæŠŠ4æ’é™¤å»ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠç¬¬å››ä¸ªæ•°å­—çœ‹æˆè¢«4å æ®çš„ç¬¬ä¸‰ä½ï¼Œæ„æˆäº†2 3 1ã€‚ å…¬å¼åŒ–ä¸€ä¸‹ï¼š ç”±é¢˜æ„a1=0ï¼Œa2=1ï¼Œå½“nâ‰¥3æ—¶ï¼Œåœ¨é”™æ’ä¸­nå¿…ä¸åœ¨ç¬¬nä½ï¼Œè®¾næ”¾åœ¨ç¬¬kä½ä¸Šï¼ˆ1â‰¤kâ‰¤n-1ï¼‰ï¼Œåˆ™ç¬¬nä½ä¸Šæœ‰ä¸¤ç§å¯èƒ½ï¼š ï¼ˆ1ï¼‰å¦‚æœç¬¬nä½ä¸Šä¸æ˜¯kï¼Œé‚£ä¹ˆæŠŠç¬¬nä½çœ‹ä½œç¬¬kä½ï¼Œå°†nä»¥å¤–çš„nï¼1ä¸ªæ•°è¿›è¡Œé”™æ’ï¼Œé”™æ’ä¸ªæ•°æ˜¯an-1ï¼› ï¼ˆ2ï¼‰å¦‚æœç¬¬nä½ä¸Šæ˜¯kï¼Œé‚£ä¹ˆé™¤nå’Œkä»¥å¤–çš„nï¼2ä¸ªæ•°çš„é”™æ’æ˜¯an-2ï¼Œ æ‰€ä»¥nåœ¨ç¬¬kä½ä¸Šçš„é”™æ’æ•°å…±æœ‰an-1ï¼‹an-2ï¼Œç”±äºkå¯å–1ã€2ã€3ã€4ã€â€¦â€¦ã€nï¼1å…± n -1 ç§å–æ³•ï¼Œæ‰€ä»¥nä¸ªæ•°çš„é”™æ’ä¸ªæ•°ã€‚ æ‰€ä»¥æœ‰é€’æ¨å…¬å¼ï¼šan= (n - 1)(an-1 + an-2)ã€‚","link":"/2021/03/10/shua-ti-shu-xue-cuo-pai-wen-ti-nian-hui-chou-jiang/"},{"title":"é¢16-æ•°å€¼çš„Næ¬¡æ–¹","text":"é¢˜é¢ï¼šç»™ä¸€ä¸ªæµ®ç‚¹æ•°ï¼Œæ±‚å‡ºå…¶æ•°å€¼çš„æ•´æ•°æ¬¡æ–¹ã€‚ æ€è·¯ï¼šä¸»è¦è€ƒç‚¹è¿˜æ˜¯åœ¨å¼‚å¸¸å¤„ç†è¿™æ–¹é¢ã€‚ç”±äºå¹‚ä¸ºæ•´æ•°ï¼Œåœ¨æ•ˆç‡ä¸Šå¯ä»¥è€ƒè™‘å¿«é€Ÿå¹‚ã€‚ ä»£ç ï¼šint power(double base, int exponent){ //æ— ç©·å¤§çš„éæ³•è®¡ç®—å€¼ if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); unsigned int posExponent = (unsigned int)exponent; double mulBase = base, mulRes = 1; while(posExponent &gt; 0){ if(posExponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; posExponent = posExponent &gt;&gt; 1; } if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; } å¯èƒ½é™ä½è€¦åˆæ›´å¥½ä¸€ç‚¹ double PowerWithUnsighedExponent(double base, unsigned int exponent){ //ç‰¹åˆ¤ï¼šåŸºæ•°ä¸º0ï¼›æŒ‡æ•°ä¸º0æ— éœ€ç‰¹åˆ¤ if( equla(base, 0.0)) return 0.0; double mulRes = 1; while(exponent &gt; 0){ if(exponent &amp; 1) mulRes *= mulBase; mulBase *= mulBase; exponent = exponent &gt;&gt; 1; } return mulRes; } int power(double base, int exponent){ //æ— ç©·å¤§çš„éæ³•è®¡ç®—å€¼ if( equal(base, 0.0) &amp;&amp; exponent &lt; 0) throw new exception(&quot;Invalid parameters.&quot;); double mulRes = PowerWithUnsignedExponent(base, exponent); if(exponent &lt; 0) mulRes = 1 / mulRes; return mulRes; }","link":"/2020/08/07/shua-ti-shu-xue-mian-16-shu-zhi-de-n-ci-fang/"},{"title":"é¢è¯•é¢˜ 16.05. Factorial Zeros LCCI","text":"é¢è¯•é¢˜ 16.05. Factorial Zeros LCCI æ€è·¯ï¼šå°¾é›¶ä¸ªæ•°ç­‰äºæ‰€æœ‰ç›¸ä¹˜æ•°å­—çš„5çš„è´¨å› å­ä¸ªæ•°ï¼Œæ¯”å¦‚$f(11)= 1 + 1$ å…³äºå¿«é€Ÿæ±‚å‡ºï¼šå¯ä»¥ä½¿ç”¨æ•´é™¤5ï¼Œ25ï¼Œ125â€¦â€¦$5^k$çš„æ€è·¯æ±‚å‡ºã€‚ ä»£ç ï¼šclass Solution { public: int trailingZeroes(int n) { int numof5 = 0; while(n &gt;= 5){ n /= 5; numof5 += n; } return numof5; } };","link":"/2020/09/24/shua-ti-shu-xue-mian-shi-ti-16-05-factorial-zeros-lcci/"},{"title":"é¢è¯•é¢˜-å¤§æ•°","text":"å¤§æ•°ç›¸å…³ é¢17ï¼šæ‰“å°ä»1åˆ°æœ€å¤§çš„nä½æ•°é¢˜ç›®ï¼šå¦‚é¢˜ æ€è·¯1ï¼šæ˜æ˜¾çš„å¤ªç®€å•äº†ã€‚å‘è¿˜æ˜¯åœ¨æ•°æ®èŒƒå›´ä¸Šï¼Œè€ƒè™‘ä½¿ç”¨å¤§æ•°åŠ æ³•æ¨¡æ‹Ÿè®¡ç®—ã€‚ æ€è·¯2ï¼šä¹Ÿå¯ä»¥ä½¿ç”¨å…¨æ’åˆ—çš„æ€è·¯ï¼Œæ€è€ƒé™¤äº†å¼€å¤´ä¸º0çš„nä¸ª0~9æ•°å­—çš„æ’åˆ—ç»„åˆå°±æ˜¯é¢˜ç›®æ‰€è¦æ±‚çš„çš„æ•°æ®ã€‚ ä»£ç ï¼šå¤§æ•° #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; bool isIncreaseDigit(int *numbers, char* n){ for(int i = 0; n[i] != '\\0'; i++) if(numbers[i] != n[i] - '0') return true; return false; } void PrintNumber(int *numbers, int MAXLEN){ int idx = MAXLEN - 1; while(idx &gt;= 0 &amp;&amp; numbers[idx] == 0) idx --; for(int i = idx; i &gt;= 0; --i) putchar(numbers[i] + '0'); putchar('\\n'); } void Print1ToMaxDigits(char *n){ const int MAXLEN = 1000; if(n == nullptr || strlen(n) &lt;= 0 || strlen(n) &gt;= MAXLEN) return; char test0[2] = &quot;0&quot;; if(strcmp(test0, n) == 0){ printf(&quot;0\\n&quot;); return; } //reverse the input string char *newN = new char(MAXLEN); int lenN = strlen(n); for(int i = 0; i &lt; lenN; i++) newN[lenN - i - 1] = n[i]; //big data. int *numbers = new int[MAXLEN]; memset(numbers, 0, sizeof(numbers)); //Calculate the numbers. while(isIncreaseDigit(numbers, newN)){ numbers[0]++; int idx = 0; while(numbers[idx] == 10){ numbers[idx] = 0; ++idx; numbers[idx]++; } PrintNumber(numbers, MAXLEN); } delete []numbers; } int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); char a[5] = {&quot;1239&quot;}; Print1ToMaxDigits(a); } å…¨æ’åˆ—ç»„åˆ #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; bool isIncreaseDigit(int *numbers, char* n){ for(int i = 0; n[i] != '\\0'; i++) if(numbers[i] != n[i] - '0') return true; return false; } void PrintNumber(int *numbers, int MAXLEN){ int idx = MAXLEN - 1; //ä¸è¾“å‡ºå‰ç½®é›¶å’Œå…¨é›¶ while(idx &gt;= 0 &amp;&amp; numbers[idx] == 0) idx --; if(idx == -1) return; for(int i = idx; i &gt;= 0; --i) putchar(numbers[i] + '0'); putchar('\\n'); } void Print1ToMaxDigitsRecursively(int *numbers, int pos, char *newN, int lenOfN, int &amp;flag){ if(flag) return; if(pos == -1) { //ç›´æ¥ç”¨flagå‰ªæ if(!isIncreaseDigit(numbers, newN)) flag = 1; PrintNumber(numbers, lenOfN); return; } if(!isIncreaseDigit(numbers, newN)) return; for(int i = 0; i &lt;= 9; i++){ numbers[pos] = i; Print1ToMaxDigitsRecursively(numbers, pos - 1, newN, lenOfN, flag); } } void Print1ToMaxDigits(char *n){ if(n == nullptr || strlen(n) &lt;= 0) return; char test0[2] = &quot;0&quot;; if(strcmp(test0, n) == 0){ printf(&quot;0\\n&quot;); return; } //reverse the input string int lenOfN = strlen(n); char *newN = new char(lenOfN); for(int i = 0; i &lt; lenOfN; i++) newN[lenOfN - i - 1] = n[i]; newN[lenOfN] = '\\0'; //big data. int *numbers = new int[lenOfN]; memset(numbers, 0, sizeof(numbers)); //Calculate the numbers. int flag = 0; Print1ToMaxDigitsRecursively(numbers, lenOfN - 1, newN, lenOfN, flag); delete []numbers; } int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); // char a[5] = {&quot;1239&quot;}; // char a[5] = {&quot;0&quot;}; char a[50] = {&quot;100&quot;}; Print1ToMaxDigits(a); // int t1[5] = {1, 2}; // printf(&quot;%d&quot;, isIncreaseDigit(t1, a)); } æŠŠè‡ªå·±å†™æ‡µé€¼äº†ï¼Œè°ƒè¯•äº†å¥½ä¹…ï¼ŒåŸæ¥å‘ç°è‡ªå·±å‰ªæé”™äº†ã€‚ ç”±äºåˆ¤æ–­æ¡ä»¶åœ¨å˜åŒ–ï¼Œè€Œå‰ªææ¡ä»¶æ˜¯ä¸å˜çš„ï¼Œæ‰€ä»¥ä¸èƒ½åœ¨æ›´å˜æ¡ä»¶åå‰ªæ","link":"/2020/08/07/shua-ti-shu-xue-mian-shi-ti-da-shu/"},{"title":"é¢è¯•é¢˜-å»ºæ¨¡","text":"æ”¶é›†æŠ½è±¡å»ºæ¨¡é¢˜ç›®ã€‚ é¢60ï¼šnä¸ªéª°å­çš„ç‚¹æ•°é¢˜é¢ï¼šæŠŠnä¸ªéª°å­æ‰”åœ¨åœ°ä¸Šï¼Œæ‰€æœ‰éª°å­æœä¸Šä¸€é¢çš„ç‚¹æ•°ä¹‹å’Œä¸ºsã€‚è¾“å…¥nï¼Œæ‰“å°å‡ºsçš„æ‰€æœ‰å¯èƒ½çš„å€¼å‡ºç°çš„æ¦‚ç‡ã€‚ ä½ éœ€è¦ç”¨ä¸€ä¸ªæµ®ç‚¹æ•°æ•°ç»„è¿”å›ç­”æ¡ˆï¼Œå…¶ä¸­ç¬¬ i ä¸ªå…ƒç´ ä»£è¡¨è¿™ n ä¸ªéª°å­æ‰€èƒ½æ·å‡ºçš„ç‚¹æ•°é›†åˆä¸­ç¬¬ i å°çš„é‚£ä¸ªçš„æ¦‚ç‡ã€‚ æ€è·¯ï¼šç¬¬ä¸€ç§å¯ä»¥ç”¨é€’å½’DFSçš„æ€è·¯å»æ±‚å’ŒNä¸ªéª°å­çš„ç‚¹æ•°ä¹‹å’Œã€‚ç¬¬äºŒç§å¯ä»¥ç”¨å¾ªç¯ä¾æ¬¡è®¡ç®—å‰Kä¸ªéª°å­ç‚¹æ•°çš„å¯èƒ½å‡ºç°æ¬¡æ•°ã€‚ ä»£ç ï¼šclass Solution { public: int maxGV = 6; void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS){ if(currentN == 0){ prob[addS - originN]++; return; } for(int i = 1; i &lt;= maxGV; i++) calProb(prob, originN, currentN - 1, addS + i); } vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); vector&lt;int&gt; prob(n * maxGV - n + 1, 0); calProb(prob, n, n, 0); double allProb = pow(maxGV, n); vector&lt;double&gt; res(n * maxGV - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[i] / allProb; return res; } }; class Solution { public: int maxGV = 6; vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); int addLen = n * maxGV; vector&lt;int&gt;prob[2]; for(int i = 0; i &lt; 2; i++){ prob[i].resize(addLen); for(int j = 0; j &lt; addLen; j++) prob[i][j] = 0; } int calIdx = 0; for(int i = 0; i &lt; maxGV; i++) prob[1 - calIdx][i] = 1; for(int i = 0; i &lt; n - 1; i++){ for(int k = 0; k &lt; addLen; k++){ prob[calIdx][k] = 0; for(int j = max(0, k - maxGV); j &lt; k; j++){ prob[calIdx][k] += prob[1 - calIdx][j]; } } calIdx = 1 - calIdx; } double allProb = pow(maxGV, n); vector&lt;double&gt; res(addLen - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[1 - calIdx][i + n -1 ] / allProb; return res; } }; é¢61ï¼šçº¦ç‘Ÿå¤«ç¯è¿™é¢˜è€æœ‹å‹äº†ã€‚ é¢˜é¢ï¼š0,1,,n-1è¿™nä¸ªæ•°å­—æ’æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹ï¼Œæ¯æ¬¡ä»è¿™ä¸ªåœ†åœˆé‡Œåˆ é™¤ç¬¬mä¸ªæ•°å­—ã€‚æ±‚å‡ºè¿™ä¸ªåœ†åœˆé‡Œå‰©ä¸‹çš„æœ€åä¸€ä¸ªæ•°å­—ã€‚ ä¾‹å¦‚ï¼Œ0ã€1ã€2ã€3ã€4è¿™5ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹æ¯æ¬¡åˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼Œåˆ™åˆ é™¤çš„å‰4ä¸ªæ•°å­—ä¾æ¬¡æ˜¯2ã€0ã€4ã€1ï¼Œå› æ­¤æœ€åå‰©ä¸‹çš„æ•°å­—æ˜¯3ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ€è·¯ï¼šæ•°å­¦+ è¿­ä»£ã€‚ æ±‚å‡ºnä¸ªå…ƒç´ çš„æœ€åç•™ä¸‹çš„æ•°å­—ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸ªé¢˜ç›®ä»æœ‰é€’å½’æ‹†åˆ†æˆå°é—®é¢˜çš„æ½œè´¨ã€‚ å°†åŸé—®é¢˜å»ºæ¨¡ä¸º$f(n,m)$ ã€‚é‚£ä¹ˆæœ‰$f(n-1,m)$ä»£è¡¨äº†é•¿åº¦ä¸º$n-1$çš„æœ€åç•™ä¸‹çš„æ•°å­—ç¼–å·ã€‚é‡ç‚¹æ¥äº†ï¼Œé‚£ä¹ˆå°±æœ‰$f(n,m)=(f(n-1,m) + m)%n$ï¼Œä¹Ÿå°±æ˜¯è¯´é•¿åº¦ä¸º$n$çš„ç•™ä¸‹çš„æ•°å­—ç¼–å·æ˜¯æ•°è¿‡$m$ä¸ªæ•°å­—åçš„é•¿åº¦ä¸º$n-1$çš„æ•°ç»„ç•™ä¸‹æ¥çš„æ•°å­—ä¸‹æ ‡ã€‚ è€Œä¸”æœ‰$f(0,m) = 0$ï¼Œå¯ä»¥å¿«é€Ÿç”¨è¿­ä»£è®¡ç®—å‡ºæ¥ã€‚ ä»£ç ï¼š class Solution { public: int lastRemaining(int n, int m) { int res = 0; for(int i = 1;i &lt;= n; i++){ res = (res + m) % i; } return res; } };","link":"/2020/08/11/shua-ti-shu-xue-mian-shi-ti-jian-mo/"},{"title":"é¢è¯•é¢˜44ï¼š1å‡ºç°çš„ä¸ªæ•°","text":"å¹¿å—æ¬¢è¿çš„å‰‘æŒ‡offerçš„ç¥å¥‡æ€è·¯åœ¨ç½‘ç»œä¸Šä¼¼ä¹å¹¶ä¸å¤šè§ï¼Œæˆ‘ä¸ªäººä¹Ÿæ²¡çœ‹æ‡‚å¥¹çš„æ¨ç† é¢˜ç›®ï¼šç»Ÿè®¡ä»1åˆ°Nçš„æ‰€æœ‰æ•°å­—çš„1çš„å‡ºç°æ¬¡æ•°ã€‚ æ€è·¯ï¼šç¬¬ä¸€ç§ï¼šæ‰€æœ‰äººéƒ½èƒ½æƒ³å‡ºç›´æ¥æš´åŠ›è§£çš„ç®—æ³•ã€‚ ç¬¬äºŒç§ï¼šå‚è€ƒå…¶ä»–äººçš„è§£æ³•ã€‚ è®¾N = abcde ,å…¶ä¸­abcdeåˆ†åˆ«ä¸ºåè¿›åˆ¶ä¸­å„ä½ä¸Šçš„æ•°å­—ã€‚å¦‚æœè¦è®¡ç®—ç™¾ä½ä¸Š1å‡ºç°çš„æ¬¡æ•°ï¼Œå®ƒè¦å—åˆ°3æ–¹é¢çš„å½±å“ï¼šç™¾ä½ä¸Šçš„æ•°å­—ï¼Œç™¾ä½ä»¥ä¸‹ï¼ˆä½ä½ï¼‰çš„æ•°å­—ï¼Œç™¾ä½ä»¥ä¸Šï¼ˆé«˜ä½ï¼‰çš„æ•°å­—ã€‚â‘  å¦‚æœç™¾ä½ä¸Šæ•°å­—ä¸º0ï¼Œç™¾ä½ä¸Šå¯èƒ½å‡ºç°1çš„æ¬¡æ•°ç”±æ›´é«˜ä½å†³å®šã€‚æ¯”å¦‚ï¼š12013ï¼Œåˆ™å¯ä»¥çŸ¥é“ç™¾ä½å‡ºç°1çš„æƒ…å†µå¯èƒ½æ˜¯ï¼š100199ï¼Œ11001199,21002199ï¼Œï¼Œâ€¦ï¼Œ1110011199ï¼Œä¸€å…±1200ä¸ªã€‚å¯ä»¥çœ‹å‡ºæ˜¯ç”±æ›´é«˜ä½æ•°å­—ï¼ˆ12ï¼‰å†³å®šï¼Œå¹¶ä¸”ç­‰äºæ›´é«˜ä½æ•°å­—ï¼ˆ12ï¼‰ä¹˜ä»¥ å½“å‰ä½æ•°ï¼ˆ100ï¼‰ã€‚â‘¡ å¦‚æœç™¾ä½ä¸Šæ•°å­—ä¸º1ï¼Œç™¾ä½ä¸Šå¯èƒ½å‡ºç°1çš„æ¬¡æ•°ä¸ä»…å—æ›´é«˜ä½å½±å“è¿˜å—ä½ä½å½±å“ã€‚æ¯”å¦‚ï¼š12113ï¼Œåˆ™å¯ä»¥çŸ¥é“ç™¾ä½å—é«˜ä½å½±å“å‡ºç°çš„æƒ…å†µæ˜¯ï¼š100199ï¼Œ11001199,21002199ï¼Œï¼Œâ€¦.ï¼Œ1110011199ï¼Œä¸€å…±1200ä¸ªã€‚å’Œä¸Šé¢æƒ…å†µä¸€æ ·ï¼Œå¹¶ä¸”ç­‰äºæ›´é«˜ä½æ•°å­—ï¼ˆ12ï¼‰ä¹˜ä»¥ å½“å‰ä½æ•°ï¼ˆ100ï¼‰ã€‚ä½†åŒæ—¶å®ƒè¿˜å—ä½ä½å½±å“ï¼Œç™¾ä½å‡ºç°1çš„æƒ…å†µæ˜¯ï¼š1210012113,ä¸€å…±114ä¸ªï¼Œç­‰äºä½ä½æ•°å­—ï¼ˆ113ï¼‰+1ã€‚â‘¢ å¦‚æœç™¾ä½ä¸Šæ•°å­—å¤§äº1ï¼ˆ29ï¼‰ï¼Œåˆ™ç™¾ä½ä¸Šå‡ºç°1çš„æƒ…å†µä»…ç”±æ›´é«˜ä½å†³å®šï¼Œæ¯”å¦‚12213ï¼Œåˆ™ç™¾ä½å‡ºç°1çš„æƒ…å†µæ˜¯ï¼š100199,11001199ï¼Œ21002199ï¼Œâ€¦ï¼Œ1110011199,12100~12199,ä¸€å…±æœ‰1300ä¸ªï¼Œå¹¶ä¸”ç­‰äºæ›´é«˜ä½æ•°å­—+1ï¼ˆ12+1ï¼‰ä¹˜ä»¥å½“å‰ä½æ•°ï¼ˆ100ï¼‰ã€‚â€”â€”å‚è€ƒç‰›å®¢ç½‘@è—è£™å­çš„ç™¾åˆé­‚ ä»£ç ï¼šint CounterOf1(int x){ if(x &lt;= 0) return 0; int len = 0, tempX = x, judugNum = 1; while(tempX){ tempX = tempX / 10; len ++; } int power = 10, counter = 0 ; for(int i = 0; i &lt; len; i++){ int liPower = power / 10; int num = x % power / liPower; if(num &gt; judugNum ){ counter += (x / power + 1) * liPower; }else if(num == judugNum ){ counter += (x / power) * liPower + x % liPower + 1; }else counter += x / power * liPower; power *= 10; } return counter; } æµ‹è¯•å¯è§ ç‰›å®¢","link":"/2020/08/07/shua-ti-shu-xue-mian-shi-ti-44-1-chu-xian-de-ge-shu/"},{"title":"é¢è¯•é¢˜49ï¼šä¸‘æ•°","text":"","link":"/2020/08/07/shua-ti-shu-xue-mian-shi-ti-49-chou-shu/"},{"title":"146. LRU Cache","text":"æ€è·¯ï¼šLRUå®ç°ä¸­â€åˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„æ•°æ®å€¼â€œè¡¨è¾¾å¯èƒ½ä¼šè®©äººäº§ç”Ÿè¯¯è§£ï¼Œæ›´å‡†ç¡®çš„æ„æ€æ˜¯â€åˆ é™¤æœ€é•¿æ—¶é—´æœªä½¿ç”¨çš„æ•°æ®å€¼â€œã€‚ ç¡¬ä»¶çš„å®ç°å¯ä»¥ç”¨æ¯æ¬¡æ›´æ–°å’Œæ·»åŠ å…ƒç´ Aï¼Œç´¯åŠ é™¤Aä¹‹å¤–çš„æ‰€æœ‰å…ƒç´ çš„è®¡æ•°å€¼ã€‚ ä»£ç ï¼šclass LRUCache { public: // è½¯ä»¶å®ç°LRUæ¯•ç«Ÿå’Œç¡¬ä»¶ä¸åŒï¼Œéœ€è¦è€ƒè™‘å…ƒç´ çš„æ”¾ç½®å’Œç»„æˆä½ç½®ï¼› // hash + åŒå‘é“¾è¡¨çš„ç»“æ„ç»„æˆèƒ½å¤Ÿåœ¨O(1)çš„é€Ÿåº¦ä¸‹è·å–å…ƒç´ ä½ç½® // åŒå‘é“¾è¡¨çš„æ”¯æŒä¿è¯äº†åˆ é™¤å’Œåœ¨é¦–ä½æ·»åŠ å…ƒç´ çš„é€Ÿåº¦ä¹Ÿåœ¨O(1) using pairii = pair&lt;int,int&gt;; list&lt;pairii&gt; content; unordered_map&lt;int, list&lt;pairii&gt;::iterator&gt; hash; int capacity; LRUCache(int _capacity) : capacity(_capacity) { //å¦‚æœæ‰‹å†™ list æ·»åŠ  è™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹æ›´ä½³ } int get(int key) { if(hash.find(key) == hash.end()){ return -1; } // å¦‚æœèƒ½å¤Ÿå£°æ˜ä¸€ä¸ªå±äºå‹å…ƒçš„ list ç›´æ¥å¯¹æŒ‡é’ˆè¿›è¡Œæ“ä½œ æ•ˆç‡ä¼šæ›´å¥½ pairii node = *hash[key]; //æ…ç”¨ åˆ é™¤åçš„iterator content.erase(hash[key]); content.emplace_front(node); hash[key] = content.begin(); return node.second; } void put(int key, int value) { pairii node{key, value}; if(hash.find(key) != hash.end()){ // æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„value content.erase(hash[key]); }else if(content.size() == capacity){ // cacheå®¹é‡å·²æ»¡, åˆ é™¤æœ€é•¿æ—¶é—´æœªä½¿ç”¨çš„æ•°æ®å€¼ hash.erase(content.back().first); content.pop_back(); // } content.emplace_front(node); hash[key] = content.begin(); } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","link":"/2021/02/27/shua-ti-mo-ni-146-lru-cache/"},{"title":"é¢5ï¼šåˆå¹¶æ•°ç»„","text":"é¢˜ç›®å°†ä¸€ä¸ªå­—ç¬¦ä¸²åœ¨ä¸æ–°å»ºå­—ç¬¦ä¸²çš„åŸºç¡€ä¸Šå°†æºå­—ç¬¦ä¸²çš„ç©ºæ ¼æ›¿æ¢ä¸º%20ã€‚è¾“å…¥å­—ç¬¦ä¸²å’Œæ€»ç©ºé—´é•¿åº¦ã€‚ æ€è·¯æ˜æ˜¾å°±æ˜¯éå†ä¸€æ¬¡ç»Ÿè®¡ç©ºæ ¼ï¼Œè®¡ç®—å‡ºå¤šä½™çš„å­—ç¬¦æ•°ï¼Œå¹¶ä»åå‘å‰å¤åˆ¶å­—ç¬¦å¹¶æ›¿æ¢å­—ç¬¦ã€‚ æ ·ä¾‹# # ä»£ç void replaceBlank(char str[], int length){ int len = 0, addLen = 0; for(int i = 0; str[i] != '\\0'; i++){ if(str[i] == ' ') addlen + = 2; len ++; } int endP1 = len - 1, endP2 = len + addLen - 1; if(endP2 &gt;= length) return; for(; endP1 != endP2; endP1--, endP2-- ) if(str[endP1] == ' '){ str[endP2] = '0'; str[endP2 - 1] = '2'; str[endP2 - 2] = '0' endP2 -= 2; }else str[endP2] = str[endP1]; } return; } ç›¸å…³é¢˜ç›®æ¯”å¦‚è¯´å°†ä¸€ä¸ªä»¥æ’åºçš„æ•°ç»„æ’å…¥åˆ°å¦ä¸€ä¸ªå·²æ’åºçš„æ•°ç»„ï¼Œå¹¶ä¿æŒæœ‰åºã€‚åŒæ ·ä»å°¾éƒ¨æ’å…¥æ›´å¿«ã€‚ æ€ç»´å†å‘æ•£ä¸€ä¸‹å°±æœ‰å½’å¹¶æ’åºä¸­çš„ä¸¤ä¸ªæ•°ç»„çš„åˆå¹¶é—®é¢˜ï¼Œä¸è¿‡æ­¤æ—¶æ˜¯åˆ›å»ºä¸€ä¸ªè¾…åŠ©æ•°ç»„ ã€‚","link":"/2020/08/07/shua-ti-mo-ni-mian-5-he-bing-shu-zu/"},{"title":"é¢è¯• æ¨¡æ‹Ÿé¢˜","text":"æ”¶é›†ä¸€äº›æ¨¡æ‹Ÿé¢˜ã€‚ é¢29ï¼šæ‰“å°çŸ©é˜µé¢˜é¢ï¼šç»™å‡ºä¸€ä¸ªN*Mçš„çŸ©é˜µï¼ŒæŒ‰ç…§ä»é‡Œåˆ°å¤–çš„é¡ºåºé¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µã€‚ æ€è·¯ï¼šï¼ˆä»£ç ä¸€ï¼‰æ¨¡æ‹Ÿé¢˜å°±æ˜¯ç¡¬ä¸Šã€‚ç”±äºæ•´ä¸ªæ‰“å°è¿‡ç¨‹å¯ä»¥çœ‹æˆä¸€åœˆåœˆçš„æ‰“å°ï¼Œæ‰€ä»¥æŒ‰åœˆåœ°æ‰“å°ã€‚åŒæ—¶ä¸ºäº†ä¿æŒæ‰“å°åŠ¨ä½œçš„ä¸€è‡´è¡Œï¼Œéƒ½æ˜¯æ‰“å°ä¸€è¡Œæˆ–è€…ä¸€åˆ—å·®ä¸€ä¸ªå•å…ƒçŸ©é˜µã€‚ ä¸è€ƒè™‘ä¸Šé¢çš„ä¸€è‡´æ€§ï¼Œç›´æ¥è€ƒè™‘å¡«æ¶‚æ¡ä»¶çš„è¯ï¼Œä¹Ÿå°±å¤æ‚ä¸€ç‚¹ç‚¹ã€‚ ä»£ç ï¼šä¸€ç§å¯ä»¥ä¼˜ç¾çš„å®ç°N*Nçš„æ­£æ–¹å½¢çŸ©é˜µå¡«å……çš„ä»£ç ã€‚ #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;map&gt; #include&lt;cstring&gt; using namespace std; void printNumberRect(int n, int m){ vector&lt;vector&lt;int&gt; &gt; rect; rect.resize(n); for(int i = 0; i &lt; rect.size(); i++) rect[i].resize(m); int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1; int counter = 1; while(xLeftUp &lt;= xRightDown &amp;&amp; yLeftUp &lt;= yRightDown){ for(; y &lt; yRightDown; y++){ rect[x][y] = counter; counter++; } for(; x &lt; xRightDown; x++){ rect[x][y] = counter; counter++; } for(; y &gt; yLeftUp; y--){ rect[x][y] = counter; counter++; } for(; x &gt; xLeftUp; x--){ rect[x][y] = counter; counter++; } x++; y++; xLeftUp++; yLeftUp++; xRightDown--; yRightDown--; } if(xLeftUp == xRightDown + 2 &amp;&amp; yLeftUp == yRightDown + 2 ) rect[x - 1][y - 1] = counter; for(int i = 0; i &lt; rect.size(); i++){ for(int j = 0; j &lt; rect[i].size(); j++) printf(&quot;%d &quot;, rect[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;); } int main(){ //freopen(&quot;data.in&quot;, &quot;r&quot;, stdin); printNumberRect(0, 0); printNumberRect(2, 3); printNumberRect(6, 3); printNumberRect(3, 3); } å°±ç›´æ¥å¡«å†™ã€‚ void printNumberRect(int n, int m){ vector&lt;vector&lt;int&gt; &gt; rect; rect.resize(n); for(int i = 0; i &lt; rect.size(); i++) rect[i].resize(m); int x = 0, y = 0, xLeftUp = 0, yLeftUp = 0, xRightDown = n - 1, yRightDown = m - 1; int counter = 1; while(xLeftUp &lt;= xRightDown &amp;&amp; yLeftUp &lt;= yRightDown){ for(; y &lt;= yRightDown; y++){ rect[x][y] = counter; counter++; } for(x++, y--; x &lt;= xRightDown; x++){ rect[x][y] = counter; counter++; } //æ¨ªç€ç”»å¯èƒ½ä¼šé‡å  for(x--, y--; y &gt;= yLeftUp &amp;&amp; x &gt; xLeftUp; y--){ rect[x][y] = counter; counter++; } //åŒä¸Š for(y++, x--; x &gt; xLeftUp &amp;&amp; y &lt; yRightDown; x--){ rect[x][y] = counter; counter++; } x++; y++; xLeftUp++; yLeftUp++; xRightDown--; yRightDown--; } for(int i = 0; i &lt; rect.size(); i++){ for(int j = 0; j &lt; rect[i].size(); j++) printf(&quot;%d &quot;, rect[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;); }","link":"/2020/08/07/shua-ti-mo-ni-mian-shi-mo-ni-ti/"},{"title":"é¢è¯•é¢˜-å»ºæ¨¡","text":"æ”¶é›†æŠ½è±¡å»ºæ¨¡é¢˜ç›®ã€‚ é¢60ï¼šnä¸ªéª°å­çš„ç‚¹æ•°é¢˜é¢ï¼šæŠŠnä¸ªéª°å­æ‰”åœ¨åœ°ä¸Šï¼Œæ‰€æœ‰éª°å­æœä¸Šä¸€é¢çš„ç‚¹æ•°ä¹‹å’Œä¸ºsã€‚è¾“å…¥nï¼Œæ‰“å°å‡ºsçš„æ‰€æœ‰å¯èƒ½çš„å€¼å‡ºç°çš„æ¦‚ç‡ã€‚ ä½ éœ€è¦ç”¨ä¸€ä¸ªæµ®ç‚¹æ•°æ•°ç»„è¿”å›ç­”æ¡ˆï¼Œå…¶ä¸­ç¬¬ i ä¸ªå…ƒç´ ä»£è¡¨è¿™ n ä¸ªéª°å­æ‰€èƒ½æ·å‡ºçš„ç‚¹æ•°é›†åˆä¸­ç¬¬ i å°çš„é‚£ä¸ªçš„æ¦‚ç‡ã€‚ æ€è·¯ï¼šç¬¬ä¸€ç§å¯ä»¥ç”¨é€’å½’DFSçš„æ€è·¯å»æ±‚å’ŒNä¸ªéª°å­çš„ç‚¹æ•°ä¹‹å’Œã€‚ç¬¬äºŒç§å¯ä»¥ç”¨å¾ªç¯ä¾æ¬¡è®¡ç®—å‰Kä¸ªéª°å­ç‚¹æ•°çš„å¯èƒ½å‡ºç°æ¬¡æ•°ã€‚ ä»£ç ï¼šclass Solution { public: int maxGV = 6; void calProb(vector&lt;int&gt;&amp;prob, int originN, int currentN, int addS){ if(currentN == 0){ prob[addS - originN]++; return; } for(int i = 1; i &lt;= maxGV; i++) calProb(prob, originN, currentN - 1, addS + i); } vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); vector&lt;int&gt; prob(n * maxGV - n + 1, 0); calProb(prob, n, n, 0); double allProb = pow(maxGV, n); vector&lt;double&gt; res(n * maxGV - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[i] / allProb; return res; } }; class Solution { public: int maxGV = 6; vector&lt;double&gt; twoSum(int n) { // if(n &lt; 1) return vector&lt;int&gt;(); int addLen = n * maxGV; vector&lt;int&gt;prob[2]; for(int i = 0; i &lt; 2; i++){ prob[i].resize(addLen); for(int j = 0; j &lt; addLen; j++) prob[i][j] = 0; } int calIdx = 0; for(int i = 0; i &lt; maxGV; i++) prob[1 - calIdx][i] = 1; for(int i = 0; i &lt; n - 1; i++){ for(int k = 0; k &lt; addLen; k++){ prob[calIdx][k] = 0; for(int j = max(0, k - maxGV); j &lt; k; j++){ prob[calIdx][k] += prob[1 - calIdx][j]; } } calIdx = 1 - calIdx; } double allProb = pow(maxGV, n); vector&lt;double&gt; res(addLen - n + 1); for(int i = 0; i &lt; res.size(); i++) res[i] = prob[1 - calIdx][i + n -1 ] / allProb; return res; } }; é¢61ï¼šçº¦ç‘Ÿå¤«ç¯è¿™é¢˜è€æœ‹å‹äº†ã€‚ é¢˜é¢ï¼š0,1,,n-1è¿™nä¸ªæ•°å­—æ’æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹ï¼Œæ¯æ¬¡ä»è¿™ä¸ªåœ†åœˆé‡Œåˆ é™¤ç¬¬mä¸ªæ•°å­—ã€‚æ±‚å‡ºè¿™ä¸ªåœ†åœˆé‡Œå‰©ä¸‹çš„æœ€åä¸€ä¸ªæ•°å­—ã€‚ ä¾‹å¦‚ï¼Œ0ã€1ã€2ã€3ã€4è¿™5ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹æ¯æ¬¡åˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼Œåˆ™åˆ é™¤çš„å‰4ä¸ªæ•°å­—ä¾æ¬¡æ˜¯2ã€0ã€4ã€1ï¼Œå› æ­¤æœ€åå‰©ä¸‹çš„æ•°å­—æ˜¯3ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ æ€è·¯ï¼šæ•°å­¦+ è¿­ä»£ã€‚ æ±‚å‡ºnä¸ªå…ƒç´ çš„æœ€åç•™ä¸‹çš„æ•°å­—ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸ªé¢˜ç›®ä»æœ‰é€’å½’æ‹†åˆ†æˆå°é—®é¢˜çš„æ½œè´¨ã€‚ å°†åŸé—®é¢˜å»ºæ¨¡ä¸º$f(n,m)$ ã€‚é‚£ä¹ˆæœ‰$f(n-1,m)$ä»£è¡¨äº†é•¿åº¦ä¸º$n-1$çš„æœ€åç•™ä¸‹çš„æ•°å­—ç¼–å·ã€‚é‡ç‚¹æ¥äº†ï¼Œé‚£ä¹ˆå°±æœ‰$f(n,m)=(f(n-1,m) + m)%n$ï¼Œä¹Ÿå°±æ˜¯è¯´é•¿åº¦ä¸º$n$çš„ç•™ä¸‹çš„æ•°å­—ç¼–å·æ˜¯æ•°è¿‡$m$ä¸ªæ•°å­—åçš„é•¿åº¦ä¸º$n-1$çš„æ•°ç»„ç•™ä¸‹æ¥çš„æ•°å­—ä¸‹æ ‡ã€‚ è€Œä¸”æœ‰$f(0,m) = 0$ï¼Œå¯ä»¥å¿«é€Ÿç”¨è¿­ä»£è®¡ç®—å‡ºæ¥ã€‚ ä»£ç ï¼š class Solution { public: int lastRemaining(int n, int m) { int res = 0; for(int i = 1;i &lt;= n; i++){ res = (res + m) % i; } return res; } };","link":"/2020/08/11/shua-ti-mo-ni-mian-shi-ti-jian-mo/"},{"title":"435. Non-overlapping Intervals","text":"è¿˜æ˜¯è›®ç»å…¸çš„é¢˜ï¼Œæƒ³äº†æƒ³å°±å‡ºæ¥äº†ã€‚ æ€è·¯ï¼šæ±‚å‡ºæœ€å°‘èˆå¼ƒçš„åŒºé—´ï¼Œæ¢ä¸€ä¸ªè§’åº¦å°±æ˜¯ç•™ä¸‹æ›´å¤šçš„åŒºé—´ã€‚ä¸ºäº†ç•™ä¸‹çš„åŒºé—´æœ€å¤šï¼Œç›´è§‚ä¸Šæ¥çœ‹æœ€å¥½æ˜¯åŒºé—´é•¿åº¦å°ï¼Œèµ·ç‚¹å’Œç»ˆç‚¹éƒ½å°çš„åŒºé—´ã€‚ é€šè¿‡ä»”ç»†çš„æ€è€ƒï¼Œåªæœ‰ç»ˆç‚¹æœ€å°æ‰èƒ½æ»¡è¶³åŒºé—´å°½å¯èƒ½ç•™ä¸‹çš„æ¡ä»¶ã€‚ ä»£ç ï¼š bool cmp(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ if(a[1] == b[1]) return a[0] &lt; b[0]; else return a[1] &lt; b[1]; } class Solution { public: int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { // bool (Solution::*cmpabc)(vertor&lt;int&gt;, vertor&lt;int&gt;); // cmpabc = &amp;Solution::cmpab; int n = intervals.size(); // for(int i = 0; i &lt; n; i++) // intervals[i].push_back(intervals[i][1] - intervals[i][0]); sort(intervals.begin(), intervals.end(), cmp); int add = 0, start = -0x7fffffff; for(int i = 0; i &lt; n; ++i){ if(start &lt;= intervals[i][0]){ add++; start = intervals[i][1]; } } return n - add; } }; sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){return a[1] &lt; b[1];});æœ€åçš„sortå¯ä»¥ç”¨åŒ¿åå‡½æ•°å†™å†™ã€‚","link":"/2020/10/12/shua-ti-tan-xin-435-non-overlapping-intervals/"},{"title":"452. Minimum Number of Arrows to Burst Balloons","text":"452. Minimum Number of Arrows to Burst Balloonsç±»ä¼¼äºleetcode435è´ªå¿ƒé¢˜ æ€è·¯ï¼šç”¨è´ªå¿ƒçš„ç­–ç•¥å°½å¯èƒ½çš„å°„å‡»æ°”çƒæœ«å°¾ï¼Œå¯ä»¥ç”¨æœ«å°¾æ’åºï¼Œéå†å¢åŠ ç®­æ•°å³å¯ã€‚ ä»£ç ï¼š æŒ‰æ°”çƒå¼€å§‹æ’åºï¼Œä¸åŸæœ¬æ€è·¯ä¸Šçš„æ€è·¯ç­‰ä»· class Solution { public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { sort(points.begin(), points.end(), [](vector&lt;int&gt; a, vector&lt;int&gt; b) { if(a[0] == b[0]) return a[1] &lt; b[1]; else return a[0] &lt; b[0];} ); int num = 0; int end = -1; for(int i = 0; i &lt; points.size();){ num++; end = points[i][1]; i++; while(i &lt; points.size() &amp;&amp; end &gt;= points[i][0]){ end = min(end, points[i][1]); i++; } } return num; } };","link":"/2020/10/13/shua-ti-tan-xin-452-minimum-number-of-arrows-to-burst-balloons/"},{"title":"455. Assign Cookies","text":"455. Assign Cookiesè´ªå¿ƒ + äºŒåˆ† æ€è·¯ï¼šè´ªå¿ƒ ä»£ç ï¼šclass Solution { public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end(), less&lt;int&gt;()); sort(s.begin(), s.end(), less&lt;int&gt;()); vector&lt;bool&gt; vis(s.size(), 0); int ans = 0; for(int i = 0; i &lt; g.size(); ++i){ int l = 0, r = s.size(), mid; while(l &lt; r){ mid = (l + r) / 2; if(s[mid] &gt;= g[i]) r = mid; else l = mid + 1; } mid = r; while(mid &lt; s.size() &amp;&amp; vis[mid]) ++mid; if(mid &lt; s.size()){ vis[mid] = 1; ++ans; } } return ans; } }; é”™è¯¯ä¹‹å¤„ï¼š sortçš„é»˜è®¤æŒ‰å‡åºæ‹æˆï¼Œä½¿ç”¨greateræŒ‰é™åºæ’åº äºŒåˆ†åmidä¸ºæš‚å­˜å€¼ï¼Œlræ‰æ˜¯æœ€åç›®çš„åœ°ã€‚","link":"/2020/10/09/shua-ti-tan-xin-455-assign-cookies/"},{"title":"5674. Largest Merge Of Two Strings","text":"å‘¨èµ›çš„é¢˜ç›®3 ç®—æ³•ï¼šæ˜æ˜¾æ˜¯è´ªå¿ƒï¼Œä½†æˆ‘è´ªé”™äº†ï¼ ä¸€å¼€å§‹æƒ³ç€æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦åˆ›çš„å¼€å¤´å­—ç¬¦ï¼Œé€‰æ‹©å­—å…¸åºå¤§çš„å­—ç¬¦åŠ å…¥ã€‚å¦‚æœä¸¤ä¸ªå­—ç¬¦ç›¸ç­‰å°±æ”¾ç€æ¯”è¾ƒä¸‹ä¸€ä¸ªï¼Œç›´åˆ°æœ‰ä¸åŒçš„å°±å¯ä»¥å…¨éƒ¨åŠ å…¥ã€‚ç„¶åwaäº†4å‘ã€‚ æ­£ç¡®çš„æ€è·¯æ˜¯ï¼šæ¯”è¾ƒå‰©ä¸‹çš„å­—ç¬¦ä¸²ï¼Œé€‰æ‹©å­—å…¸åºå¤§çš„å­—ç¬¦åˆ›çš„çš„é¦–ä¸ªå­—ç¬¦åŠ å…¥å³å¯ã€‚ ä»£ç ï¼šclass Solution { public: string largestMerge(string word1, string word2) { int i, j; i = j = 0; string res; int n = word1.size(), m = word2.size(); while(i &lt; n &amp;&amp; j &lt; m){ // è´ªå¿ƒç®—æ³•ï¼š // ç›´æ¥æ¯”è¾ƒ å‰©ä¸‹å­ä¸²ï¼Œ é€‰æ‹©å­—å…¸çš„åºå¤§çš„å­ä¸²çš„ç¬¬ä¸€ä¸ªå­—æ¯åŠ å…¥ if(word1.substr(i) &gt; word2.substr(j)) res += word1[i++]; else res += word2[j++]; } if(i &lt; n) res += word1.substr(i); if(j &lt; m) res += word2.substr(j); return res; } };","link":"/2021/02/07/shua-ti-tan-xin-5674-largest-merge-of-two-strings/"},{"title":"665. Non-decreasing Array","text":"665. Non-decreasing Arrayæ€è·¯ï¼šå¯¹äºä»»æ„ä¸€ä¸ª$A[i]&gt;A[i+1]$ï¼Œ$A[i]$å’Œ$A[i+1]$åˆ†åˆ«ä»£è¡¨ä¸¤ä¸ªnon-decreasing arrayï¼Œè€Œåˆå¹¶ä¸¤ä¸ªçš„æ–¹æ³•åªæœ‰ï¼šA[i] = A[i - 1]å’ŒA[i +1 ] = A[i + 2]ã€‚ æ¥ä¸‹æ¥åªéœ€è¦è®¨è®ºè¾¹ç•Œæ¡ä»¶å’Œåˆå¹¶æ¬¡æ•°å³å¯ã€‚ ä»£ç ï¼š class Solution { public: bool checkPossibility(vector&lt;int&gt;&amp; nums) { int ansnum = 0; int n = nums.size(); for(int i = 0; i &lt; n - 1; ++i){ if(nums[i] &gt; nums[i + 1]){ if(i ==0 || nums[i - 1] &lt;= nums[i + 1] || i == n - 2 || nums[i] &lt;= nums[i + 2]){ ansnum++; if(ansnum &gt; 1) return false; } else return false; } } return true;;;;;;;;;; } };","link":"/2020/10/16/shua-ti-tan-xin-665-non-decreasing-array/"},{"title":"763. Partition Labels","text":"æ€è·¯ï¼šé¢˜ç›®ä¸é”™ï¼Œè´ªå¿ƒåˆ°æœ€æ™šå‡ºç°çš„å­—ç¬¦å°±è¡Œäº†ã€‚ ä»£ç ï¼š class Solution { public: vector&lt;int&gt; partitionLabels(string S) { int vis[26] = {0}, num[26] = {0}; vector&lt;int&gt; par; int k = 0, n = S.size(), last = -1; for(int i = 0; i &lt; n; ++i) num[S[i] - 'a']++; while(k &lt; n){ memset(vis, 0, sizeof(vis)); for(k; k &lt; n; ++k){ int idx = S[k] - 'a'; vis[idx]++; int flag = 0; if(vis[idx] == num[idx] ){ for(int j = 0; j &lt; 26; ++j){ if(vis[j] &amp;&amp; vis[j] != num[j]){ flag = 1; break; } } if(!flag){ break; } } } par.push_back(k - last); last = k; k++; } return par; } }; pyç‰ˆï¼šå®ç°æ›´ä¼˜é›… class Solution(object): def partitionLabels(self, S): last = {c: i for i, c in enumerate(S)} j = anchor = 0 ans = [] for i, c in enumerate(S): j = max(j, last[c]) if i == j: ans.append(i - anchor + 1) anchor = i + 1 return ans ä½œè€…ï¼šLeetCode é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode/ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","link":"/2020/10/14/shua-ti-tan-xin-763-partition-labels/"},{"title":"870. Advantage Shuffle","text":"870. Advantage Shuffleæ€è·¯ä¸€çœ‹å°±æ˜¯è´ªå¿ƒ ä»å°åˆ°å¤§é€ä¸ªå¯»æ‰¾Bçš„ç‰Œbï¼Œæ‰¾å‡ºä¸€ä¸ªåˆšåˆšå¥½æ¯”bå¤§çš„åœ¨Aä¸­çš„ç‰Œaã€‚å› ä¸ºaåˆšåˆšæ¯”bå¤§ï¼Œæ‰€ä»¥æœ€ä¼˜ã€‚æ‰¾å‡ºåï¼ŒåŠ å…¥æ˜ å°„ï¼Œæœ€åé‡æ„æ•°ç»„å³å¯ã€‚ ä»£ç ä¸‹é¥­æ“ä½œ class Solution { public: vector&lt;int&gt; advantageCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { int n = A.size(); vector&lt;int&gt; sortb(B); sort(A.begin(), A.end()); vector&lt;int&gt; leftA; sort(sortb.begin(), sortb.end()); // unordered_multimap&lt;int, int&gt; map; multimap&lt;int, int&gt; map; // å¯ä»¥ç”¨ unorder_map&lt;int, deque&lt;int&gt;&gt; ä»£æ›¿ï¼Œ ä»£ç æ›´ç®€æ´ int g = 0; for(auto b : sortb){ while(g &lt; n &amp;&amp; A[g] &lt;= b) leftA.push_back(A[g++]); if(g &lt; n) map.insert({b, A[g++]}); } int k = 0; for(int i = 0; i &lt; n; ++i){ auto it = map.lower_bound(B[i]); if(it != map.end()){ auto [b, a]= *it; if(b == B[i]){ A[i] = a; map.erase(it); } } else A[i] = leftA[k++]; } return A; } };","link":"/2021/02/05/shua-ti-tan-xin-870-advantage-shuffle/"},{"title":"é¢è¯•é¢˜ DP è´ªå¿ƒ","text":"æ”¶é›†è´ªå¿ƒã€DPé¢è¯•é¢˜ é¢14ï¼šå‰ªç»³å­é¢˜é¢ï¼šå°†ä¸€ä¸²é•¿ä¸ºKçš„ç»³å­å‰ªæˆmï¼ˆm&gt;=2ï¼Œå„æ®µé•¿åº¦å–æ•´æ•°å€¼ï¼‰æ®µï¼Œå„æ®µçš„é•¿åº¦å¤§äº0ï¼Œæ±‚å‡ºæœ€å¤§çš„å„æ®µç»³å­é•¿åº¦ä¹‹ç§¯ã€‚ æ€è·¯1ï¼šç”±ä¹˜æ³•äº¤æ¢å¾‹å¯çŸ¥ç»³å­çš„ä¹˜ç§¯å¯ä»¥åˆ†è§£ï¼Œæå–å‡ºæ¥ã€‚æ‰€ä»¥æœ‰f(m+n)=f(n)*f(m)ï¼Œå…¶ä¸­f(n)æ˜¯é•¿åº¦nçš„ç»³å­çš„æœ€å¤§ä¹˜ç§¯ã€‚åˆ†æå…·ä½“é—®é¢˜å¯ä»¥äº†è§£åˆ°åˆå§‹æ¡ä»¶æ¯”è¾ƒç‰¹æ®Šï¼Œå®ƒå¯¹äºå°æ•°å­—æ¥è¯´ï¼Œåˆ†è§£è¿˜ä¸å¦‚å…¶æœ¬èº«å¤§ï¼Œæ‰€ä»¥å®šä¹‰è¾¹ç•Œæ¡ä»¶f(1) = 1, f(2) = 2, f(3) = 3ã€‚åŒæ—¶åœ¨DPè¡¨ç¤ºå¼ä¸ºï¼š f(n)=maxif(nâˆ’i)âˆ—f(i)f(n)=maxif(nâˆ’i)âˆ—f(i) æ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸ºO(N2)O(N2)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(N)O(N)ã€‚ æ€è·¯2ï¼šå¦ä¸€ç§å°±æ˜¯è´ªå¿ƒï¼Œå¯¹äºé•¿åº¦må¤§äº5çš„ç»³å­å°½å¯èƒ½çš„å‰ªæˆé•¿åº¦ä¸º3çš„ç»³å­ï¼ŒåŒæ—¶å¦‚æœm%3==1ï¼Œé‚£ä¹ˆå°±å°‘å‰ªä¸€æ®µç»³å­ï¼Œå‰ªæˆä¸¤æ®µé•¿ä¸º2çš„ç»³å­ã€‚è¯æ˜å¦‚ä¸‹:$$if \\ n \\geq 53*(n-3) \\geq n2*(n-2) \\geq n3*(n -3 ) \\geq 2*(n-2)$$ æµ‹è¯•ï¼š2 2 , 3 2 , 5 6 , 6 9 ä»£ç ï¼šDP int maxProduct_DP(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int* products = new int[length + 1]; //åˆè¯•æ¡ä»¶æ¯”è¾ƒç‰¹æ®Šï¼Œå°äº4çš„å¤§äº1çš„æ•°çš„åˆ†æ®µä¹˜ç§¯ä¸å¦‚å…¶æœ¬èº«å¤§ products[0] = 0; products[1] = 1; products[2] = 2; products[3] = 3; for(int i = 4; i &lt;= length; i++){ int mavV = 0; for(int j = 1; j &lt;= i / 2; j++){ maxV = max(maxV, products[i - j] * products[j]); } products[i] = maxv; } int res = products[length]; //é˜²æ­¢å†…å­˜æ³„æ¼ del[] products; return res; } è´ªå¿ƒ int maxProduct_greedy(int length){ if(length &lt; 2) return 0; if(length == 2) return 1; if(length == 3) return 2; int timesOf3 = length / 3; if(legnth % 3 == 1) timesOf3 -= 1; int timesOf2 = (length - timesOf3 * 3) / 2; return (int)pow(3, timeOf3) * (int)pow(2, timesOf2); } é¢42ï¼šæœ€å¤§å­æ•°ç»„å’Œé¢˜é¢ï¼šå¦‚é¢˜ æ€è·¯ï¼šDPæ€æƒ³ã€‚æ•°ç»„ä¹‹é—´çš„é€‰æ‹©ä¸å†å²æ— å…³ï¼Œå¯ä»¥é‡‡å–DPçš„æ–¹æ³•ã€‚è®°f(i)ä¸ºä»¥A[i]ä¸ºç»“å°¾çš„æœ€å¤§æ•°ç»„å’Œã€‚è½¬ç§»æ–¹ç¨‹ä¸ºï¼š f(i)={A[i],if f(i-1)&lt;0 A[i]+f(iâˆ’1),if f(i-1)&gt;0f(i)={A[i],if f(i-1)&lt;0 A[i]+f(iâˆ’1),if f(i-1)&gt;0 å½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥ä»æ•°æ®çš„è§’åº¦ç†è§£ï¼Œä»£ç éƒ½æ˜¯ç›¸åŒçš„ã€‚ ä»£ç ï¼šint MaxSumOfSubArray(int A[], int length){ int dp[] = new int(length); int maxSum = A[0]; dp[0] = A[0]; for(int i = 1; i &lt; length; i++){ dp[i] = max(A[i], A[i] + dp[i-1]); maxSum = max(dp[i], maxSum); } delete[] dp; return maxSum; } å½“ç„¶è¿™é‡Œçš„dpæ•°ç»„ä¹Ÿå¯ä»¥ä¸è¦ã€‚ é¢45ï¼šæŠŠæ•°å­—æ’æˆæœ€å°çš„æ•°å­—é¢˜ç›®ï¼šç»™å®šä¸€ä¸²æ•°å­—ï¼Œç»„åˆæˆçš„ä¸€ä¸ªæ•°å­—ã€‚æ±‚å‡ºç»„åˆåæœ€å°æ•°å­—çš„ æ€è·¯ï¼šå¯ä»¥ç›´æ¥è´ªå¿ƒ+åè¯ã€‚æŒ‰å­—å…¸åºæ’åºæ•°å­—å³å¯ã€‚ ä»£ç ï¼šå°±ä¸å†™äº†ï¼Œç›´æ¥stringæ’åºè¾“å‡ºå³å¯ã€‚ é¢46ï¼šæ•°å­—ç¿»è¯‘æˆå­—ç¬¦ä¸²é¢˜ç›®ï¼šæŠŠä¸€ä¸²æ•°å­—ç¿»è¯‘æˆæ•°å­—å¯¹åº”çš„å­—æ¯ï¼Œå¹¶æŒ‰åŸé¡ºåºç»„æˆå­—ç¬¦ä¸²ã€‚ç”±äºæ•°å­—åˆ†è£‚çš„ä¸åŒï¼Œç¿»è¯‘æ–¹æ³•æœ‰è®¸å¤šï¼Œæ±‚å‡ºç¿»è¯‘çš„æ–¹æ³•çš„ä¸ªæ•°ã€‚ æ€è·¯ï¼šç¬¬ä¸€ç§å°±æ˜¯ç›´æ¥é€’å½’åˆ†å‰²å­—ç¬¦ä¸²ã€‚æ˜¾ç„¶æœ‰å­é—®é¢˜é‡å çš„ç°è±¡ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨DPã€‚ ç¬¬äºŒç§ç”¨DPæ€æƒ³ï¼Œè€ƒè™‘dp[i]ä¸ºä»0åˆ°içš„å­—ç¬¦ä¸²ç¿»è¯‘æ–¹æ³•ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š dp[i]={dp[iâˆ’1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[iâˆ’1]+dp[iâˆ’2],else dp[i]={dp[iâˆ’1],if 10&lt;=S[i-1] *10 + S[i] &lt;26 dp[iâˆ’1]+dp[iâˆ’2],else ä»£ç ï¼šint GetTranslateCount(int A[], int length){ if(A == nullptr || length &lt;= 0) return 0; int dp[] = new int(length); dp[0] = 1; for(int i = 1; i &lt; length; i++){ int add = A[i - 1] * 10 + A[i]; if( add &gt; 9 &amp;&amp; add &lt; 26){ if(i &lt; 2) dp = dp[i - 1] + 1; else dp[i] = dp[i - 1] + dp[i - 2]; } else dp[i] = dp[i - 1]; } delete[] dp; return dp[length - 1]; } é¢47ï¼šç¤¼ç‰©çš„æœ€å¤§ä»·å€¼é¢˜ç›®ï¼šä»ä¸€åœ¨æ ¼å­ä¸Šè£…æ»¡ç¤¼ç‰©çš„m*nçš„çŸ©å½¢æ£‹ç›˜ä¸Šï¼Œä»å·¦ä¸Šè§’å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ ¼åˆ°å³ä¸‹è§’ï¼Œæ±‚å‡ºè·¯å¾„ä¸Šç¤¼ç‰©ä»·å€¼çš„æœ€å¤§å€¼ã€‚ æ€è·¯ï¼šæ˜æ˜¾å°±æ˜¯DP ä»£ç ï¼šä¸å†™äº†ã€‚ é¢48ï¼šæœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸²é¢˜ç›®ï¼šå¦‚é¢˜ æ€è·¯ï¼šæš´åŠ›ä¸å¯å–ã€‚ é‡‡ç”¨ç”¨DPæ€æƒ³ï¼Œè€ƒè™‘dp[i]ä¸ºä»¥S[i]ä¸ºç»“å°¾çš„æœ€é•¿ä¸é‡å¤å­—ç¬¦ä¸²ã€‚ä¸€ä¸ªä¸å«é‡å¤å­—ç¬¦çš„å­—ç¬¦ä¸²å¯ä»¥åœ¨ç”±å¦ä¸€ä¸ªä¸åŒçš„å­—ç¬¦ç»„æˆå¦ä¸€ä¸ªä¸å«é‡å¤å­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚å¯ä»¥åœ¨dpè¿‡ç¨‹ä¸­ï¼Œè®°å½•ä¸‹æœ€æ–°çš„å­—ç¬¦çš„ä½ç½®POSï¼Œåˆ¤æ–­S[i]çš„å‰ä¸€ä¸ªç›¸åŒå­—ç¬¦æ˜¯å¦åœ¨ä¸Šä¸€ä¸ªS[i-1]ä¸ºç»“å°¾çš„æœ€é•¿ä¸é‡å¤å­—ç¬¦ä¸²ä¹‹å†…ã€‚è®°ä¸Šä¸€ä¸ªå­—ç¬¦ä¸S[i-1]çš„é•¿åº¦dä¸ºi - POSã€‚ çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š dp[i]={dp[iâˆ’1]+1,if d &gt; dp[i - 1] d,else dp[i]={dp[iâˆ’1]+1,if d &gt; dp[i - 1] d,else ä»£ç ï¼šint MaxSubStr(String s){ int dp[] = new int(s.length()); int pos[26]; for(int i = 0; i &lt; 26; i++) pos[[i] = -1; int maxL = 1; dp[0] = 1; for(int i = 1; i &lt; s.length(); i++){ int d = i - pos[s[i] - 'a']; if(dp[i - 1] &lt; d){ dp[i] = dp[i - 1] + 1; }else dp[i] = d; maxL = max(maxL, dp[i]); pos[s[i] - 'a'] = i; } delete[] dp; return maxL; }","link":"/2020/08/07/shua-ti-tan-xin-mian-shi-ti-dp-tan-xin/"},{"title":"ç¼–ç¨‹å®Œæ•´æ€§","text":"ç¼–ç¨‹å®Œæ•´æ€§ç¼–ç¨‹å®Œæ•´æ€§æ˜¯æŒ‡ä»£ç å¯¹å„ç§è¾“å…¥ï¼Œæ¡ä»¶çš„è€ƒè™‘ï¼Œé¿å…å‡ºç°å„ç§å„æ ·çš„ç¨‹åºæ¼æ´ï¼Œå®Œæˆå¯¹ç¼–ç çš„éœ€æ±‚ã€‚å¯ä»¥ä»ä¸‰ä¸ªæµ‹è¯•è§’åº¦è€ƒè™‘ï¼ŒåŠŸèƒ½æµ‹è¯•ã€è¾¹ç•Œæµ‹è¯•å’Œè´Ÿé¢æµ‹è¯•ã€‚åŠŸèƒ½æµ‹è¯•å°±æ˜¯æŒ‡å¯¹ä»£ç æœ¬èº«éœ€è¦å®Œæˆçš„åŠŸèƒ½è¿›è¡Œç¼–ç ã€‚è¾¹ç•Œæµ‹è¯•å°±æ˜¯å¯¹è¾¹ç•Œæ•°æ®è¿›è¡Œæµ‹è¯•ã€‚è´Ÿé¢æµ‹è¯•å°±æ˜¯å¯¹ä¸ç¬¦åˆè¦æ±‚çš„è¾“å…¥æ•°æ®è¿›è¡Œæµ‹è¯•ã€‚ 3ä¸­é”™è¯¯å¤„ç†æ–¹æ³•é”™è¯¯å¤„ç†æ–¹æ³•å°±æ˜¯ä¸ºäº†æŠŠç¨‹åºå‡ºç°çš„é”™è¯¯è½¬å‘Šç»™å‡½æ•°è°ƒç”¨è€…ã€‚å¤§æ¦‚æœ‰ä¸‰ç§æ–¹æ³•ï¼Œä¸€æ˜¯å®šä¹‰ç‰¹å®šå‡½æ•°è¿”å›å€¼ä¸ºå‡½æ•°è¿è¡ŒçŠ¶æ€ï¼Œä½†æ˜¯å¢åŠ äº†å‡½æ•°è°ƒç”¨çš„ä¸ä¾¿ï¼Œä¸èƒ½ç›´æ¥èµ‹å€¼ç»™å¦ä¸€ä¸ªå‡½æ•°çš„å‚æ•°ã€‚äºŒæ˜¯å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œè‹¥å‡½æ•°è°ƒç”¨ä¸­å‡ºç°é”™è¯¯å°±æ”¹å˜å…¨å±€å˜é‡ï¼Œç›¸æ¯”ç¬¬ä¸€ç§æ–¹æ³•æ–¹ä¾¿å¾ˆå¤šï¼Œä½†æ˜¯å­˜åœ¨å‡½æ•°è°ƒç”¨ä¸æ£€æŸ¥å…¨å±€å˜é‡çš„å®‰å…¨éšæ‚£ã€‚ä¸‰æ˜¯æŠ›å‡ºå¼‚å¸¸ï¼Œæˆ–è€…ä½¿ç”¨try.....catchè¯­å¥å®šä¹‰ä¸åŒçŠ¶æ€çš„è¿è¡Œç¨‹åºï¼Œå¯è‡ªå®šä¹‰å¼‚å¸¸ç±»å‹ï¼Œé€»è¾‘æ¸…æ™°ï¼Œä½†æ˜¯æŸäº›è¯­è¨€å¯èƒ½ä¸æ”¯æŒã€‚ ä»£ç é²é‚¦æ€§ä»£ç é²æ£’æ€§å°±æ˜¯æŒ‡ä»£ç å¯¹å¼‚å¸¸è¾“å…¥ï¼Œè¿è¡Œé”™è¯¯çš„å¤„ç†çš„èƒ½åŠ›ã€‚å› ä¸ºç”¨æˆ·å’Œç¯å¢ƒçš„é”™è¯¯æ˜¯å¯èƒ½ä¸è§„èŒƒçš„ï¼Œä¸ºäº†è®©ç¨‹åºæ­£ç¡®è¿è¡Œï¼Œå…»æˆé˜²å¾¡æ€§ç¼–ç¨‹ä¹ æƒ¯æœ‰åˆ©äºæé«˜ä»£ç è´¨é‡ã€‚æœ€ç®€å•æœ€å®ç”¨ä¾‹å­å°±æ˜¯åœ¨å‡½æ•°å…¥å£æ£€æŸ¥å‚æ•°ã€‚","link":"/2020/08/07/shua-ti-qi-ta-code-neng-li-dai-ma-gui-fan-bian-cheng-wan-zheng-xing/"},{"title":"é¢è¯•ç´ è´¨","text":"é¢è¯•å®˜å¸Œæœ›é¢è¯•è€…æ‰€å±•ç°çš„ç´ è´¨å¦‚ä¸‹ï¼š èƒ½å¤Ÿæ¸…æ™°è¡¨è¾¾é¡¹ç›®çš„å…·ä½“ç»†èŠ‚å’Œå¤§ä½“æµç¨‹ï¼Œå¯ä»¥æµç•…çš„è¡¨è¿°å‡ºå¯¹æŠ€æœ¯ã€åšæ³•çš„çœ‹æ³• è¦æ±‚é€»è¾‘æ¸…æ™°ï¼Œè¯¦ç•¥å¾—å½“ï¼Œé‡ç‚¹çªå‡ºï¼Œè§‚ç‚¹æ˜ç¡® ä¼šä¸»åŠ¨ä¸æé—®è€…æ²Ÿé€šé¡¹ç›®æˆ–è€…é—®é¢˜ä¸­ä¸æ¸…æ¥šçš„åœ°æ–¹ å¯¹äºå¤–ä¼è€Œè¨€æµç•…çš„è‹±è¯­äº¤æµæ˜¯å¿…é¡»çš„ å­¦ä¹ èƒ½åŠ› çŸ¥è¯†è¿ç§»èƒ½åŠ›","link":"/2020/08/07/shua-ti-qi-ta-code-neng-li-gou-tong-neng-li-mian-shi-su-zhi/"},{"title":"218. The Skyline Problem","text":"218. The Skyline Problemæ€è·¯ï¼šæ‰«æçº¿ç®—æ³•ï¼š æƒ³åƒä¸€æ ¹ç«–çº¿ï¼Œä»å·¦åˆ°å³è¿›è¡Œæ‰«æï¼Œè®°å½•ä¸‹å½“å‰ç«–çº¿æ‰€æœ‰çº¿æ®µçš„é«˜åº¦ï¼ˆé™¤å»å·¦ç«¯ç‚¹ï¼‰ï¼Œæ¯é‡åˆ°ä¸€ä¸ªç«¯ç‚¹å°±æŒ‘é€‰å‡ºæœ€é«˜ç‚¹ï¼Œå¹¶è¾“å‡ºå³å¯ã€‚è¿™é‡Œå¯ä»¥è§‚å¯Ÿåˆ°ï¼Œæ­¤ç®—æ³•æŠŠä¸€æ ¹ç›´çº¿æ‹†åˆ†ä¸¤ä¸ªç«¯ç‚¹æ¥çœ‹å¾…ï¼Œé‡åˆ°å³ç«¯ç‚¹å°±è®°å½•ç»´æŒè¯¥çº¿æ®µçš„é«˜åº¦ï¼Œé‡åˆ°å·¦ç«¯ç‚¹å°±åˆ é™¤è¯¥çº¿æ®µçš„é«˜åº¦ã€‚ å…·ä½“ç®—æ³•ï¼Œç›´æ¥çœ‹ä»£ç ï¼Œå…¶ä¸­å·¦ç«¯ç‚¹çš„Heightå–è´Ÿå€¼è®°å½•éå¸¸å·§å¦™ï¼Œæ—¢åˆ©ç”¨äº†seté›†åˆçš„å‡åºæ€§è´¨ï¼ŒåŒæ—¶åœ¨éå†çš„æ—¶ä¼˜å…ˆé€‰æ‹©äº†æ–°å»ºç­‘ï¼Œä¸è‡³äºäº§ç”Ÿâ€œå»ºç­‘é—´çš„ç©ºéš™â€ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;vector&lt;int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) { multiset&lt;pair&lt;int, int&gt;&gt; loc; for(auto &amp;e : buildings){ loc.insert({e[0], -e[2]}); loc.insert({e[1], e[2]}); } vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; last{0,0}; multiset&lt;int&gt; height{0}; //å¤šä¸ªé«˜åº¦å¯èƒ½ç›¸åŒ cout &lt;&lt; last[0] &lt;&lt; endl; for(auto &amp;[pos, h] : loc){ if(h &lt; 0) height.insert(-h); else height.erase(height.find(h)); int maxh = *height.rbegin(); // cout &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; h &lt;&lt; ' ' &lt;&lt; maxh &lt;&lt; endl; if(maxh != last[1]){ last[0] = pos; last[1] = maxh; ans.emplace_back(last); } } return ans; } };","link":"/2021/01/26/shua-ti-qi-ta-sao-miao-xian-218-the-skyline-problem/"},{"title":"126. Word Ladder II","text":"126. Word Ladder IIæ€è·¯ï¼š è¿™æ¬¡çš„bugså¾ˆå°‘ï¼Œå¼€å¿ƒã€‚ è¿™é¢˜æ ¸å¿ƒå°±æ˜¯BFSï¼ˆDFSï¼‰çš„åŸºç¡€ä¸ŠåŠ ä¸Šå‰ªæä¼˜åŒ–ã€‚æˆ–è€…TBFS å»ºç«‹æœç´¢æ ‘BFSæœç´¢ç»“æœå³å¯ã€‚ æœ€å¥½ç”¨é‚»æ¥çŸ©é˜µä¼˜åŒ–BFSæœç´¢æ•°é‡ï¼ŒåŒæ—¶æ˜¾ç„¶çš„ï¼Œä½ æ²¡æ³•é€šè¿‡ç»•ä¸€ä¸ªå°å¼¯æ‰¾åˆ°æœ€çŸ­è·¯ï¼Œè¿™å¯ä»¥å‰ªæã€‚ ç¬¬äºŒç§æ€è·¯å°±æ˜¯åŒå¤´æœç´¢ã€‚å› ä¸ºé¢˜ç›®ç»™å‡ºäº†èµ·å§‹åœ°ç‚¹å’Œç»“æŸåœ°ç‚¹çš„å­—ç¬¦ä¸²ã€‚åœ¨æœç´¢çš„æ—¶å€™æ§åˆ¶ä¸€ä¸‹æœç´¢ç©ºé—´ï¼Œæœç´¢æ·±åº¦å°±ACäº†ã€‚å‡»è´¥96%ï¼ã€‚ ä»£ç ï¼š// 26thæ ·ä¾‹è¶…æ—¶ class Solution { public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; ans; int n = wordList.size(), flag = 0; for(int i = 0; i &lt; n; ++i){ if(wordList[i] == endWord) flag = 1; } if(!flag) return ans; queue&lt;SN*&gt; que; wordList.push_back(beginWord); // size++ que.push(new SN(n, -1, 0, nullptr)); int endlevel = -1; while(que.size()){ SN *p = que.front(); que.pop(); // cout &lt;&lt; wordList[p.x] &lt;&lt;&quot; &quot; &lt;&lt; p.l &lt;&lt; '#'; // if(p.plink != nullptr) // cout &lt;&lt; p.x &lt;&lt; (p.plink)-&gt;x &lt;&lt; endl; // cout &lt;&lt; (p.plink == &amp;p) &lt;&lt; endl; // bugs: p.plink == &amp;p //search the final points. if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue; if(wordList[p-&gt;x] == endWord){ endlevel = p-&gt;l; vector&lt;string&gt; tmp; SN* np = p; while(np != nullptr){ tmp.push_back(wordList[np-&gt;x]); np = np-&gt;plink; // cout &lt;&lt; np-&gt;x &lt;&lt; &quot; &quot;; } // cout &lt;&lt; endl; reverse(tmp.begin(), tmp.end()); ans.push_back(tmp); } // emplace more points. for(int j = 0; j &lt; n; ++j){ if(islink(wordList[j], wordList[p-&gt;x])){ SN* newp = new SN(j, p-&gt;x, p-&gt;l + 1, p); //bugs: è¿™é‡Œå–çš„åœ°å€æ˜¯å˜é‡pçš„åœ°å€ï¼ŒåŒæ—¶åœ°å€æŒ‡å‘ä¸å˜ï¼Œä½†æ˜¯pæŒ‡å‘çš„å†…å®¹ä¼šå—æš‚å­˜å˜é‡pèµ‹å€¼è€Œå˜åŒ–ã€‚ è¿™å¯æ˜¯C++åŸºç¡€å•Š //è§£å†³æ–¹æ³•ï¼š ç»™æ¯ä¸ªå˜é‡ä¸€ä¸ªæ–°çš„åœ°å€å³å¯ // cout &lt;&lt; (&amp;newp == &amp;p) &lt;&lt; endl; que.push(newp); } } } return ans; } bool islink(const string &amp;a, const string &amp;b){ int len = a.size(), t = 0; for(int i = 0; i &lt; len; ++i){ if(a[i] != b[i]) t++; if(t &gt; 1) return false; } if(t == 0) return false; return true; } class SN{ public: int x; int px; int l; SN * plink; SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){} }; }; AC //å›¾ä¼˜åŒ–ç‰ˆæœ¬ // æ‰§è¡Œç”¨æ—¶ï¼š // 644 ms // , åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº† // 61.99% // çš„ç”¨æˆ· // å†…å­˜æ¶ˆè€—ï¼š // 19.1 MB // , åœ¨æ‰€æœ‰ C++ æäº¤ä¸­å‡»è´¥äº† // 66.81% // çš„ç”¨æˆ· class Solution { public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; ans; int n = wordList.size(), flag = 0; for(int i = 0; i &lt; n; ++i){ if(wordList[i] == endWord) flag = 1; } if(!flag) return ans; //bulid the map. wordList.push_back(beginWord); // size++ n++; vector&lt;vector&lt;int&gt;&gt; edges; edges.resize(n + 1); for(int i = 0; i &lt; n; ++i){ for(int j = i + 1; j &lt; n; ++j){ if(islink(wordList[i], wordList[j])){ edges[i].push_back(j); edges[j].push_back(i); } } } vector&lt;int&gt; cost(n, n + 1); cost[n - 1] = 0; //bfs queue&lt;SN*&gt; que; que.push(new SN(n - 1, -1, 0, nullptr)); int endlevel = -1; while(que.size()){ SN *p = que.front(); que.pop(); if(endlevel &gt; 0 &amp;&amp; p-&gt;l &gt; endlevel) continue; if(wordList[p-&gt;x] == endWord){ endlevel = p-&gt;l; vector&lt;string&gt; tmp; SN* np = p; while(np != nullptr){ tmp.push_back(wordList[np-&gt;x]); np = np-&gt;plink; } reverse(tmp.begin(), tmp.end()); ans.push_back(tmp); } // emplace more points. for(auto j : edges[p-&gt;x]){ if(cost[j] &gt; cost[p-&gt;x]){ // æ²¡æ³•ç»•ä¸€ä¸ªåœˆå­æ‰¾åˆ°æœ€çŸ­è·¯ cost[j] = cost[p-&gt;x] + 1; SN* newp = new SN(j, p-&gt;x, p-&gt;l + 1, p); que.push(newp); } } } return ans; } bool islink(const string &amp;a, const string &amp;b){ int len = a.size(), t = 0; for(int i = 0; i &lt; len; ++i){ if(a[i] != b[i]) t++; if(t &gt; 1) return false; } if(t == 0) return false; return true; } class SN{ public: int x; int px; int l; SN * plink; SN(int _x, int _px, int _l, SN* _plink):x(_x), px(_px), l(_l), plink(_plink){} //ç”±äºå†å²åŸå› ï¼Œpxå’Œlæœ‰ç‚¹å¤šä½™ }; }; åŒå‘bfsæ€è·¯å­¦ä¹ ï¼›ï¼ˆæœªå®Œæˆï¼‰ class Solution { public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) { vector&lt;vector&lt;string&gt;&gt; path; unordered_set&lt;string&gt; dict ,q1, q2; //dictï¼šæœç´¢ç©ºé—´ q1q2:åŒå¤´æœç´¢ unordered_map&lt;string, vector&lt;string&gt;&gt; next; for(const auto &amp;p : wordList){ dict.insert(p); } if(!dict.count(endWord)) return path; dict.erase(beginWord); dict.erase(endWord); q1.insert(beginWord); q2.insert(endWord); bool reverse = false, found = false; while(!q1.empty()){ unordered_set&lt;string&gt; q; for(const auto &amp;w : q1){ string cw = w; for(size_t i = 0 ; i &lt; cw.size(); ++i){ char c = cw[i]; for(int j = 0; j &lt; 26; ++j){ cw[i] = j + 'a'; if(q2.count(cw)){ reverse ? next[cw].push_back(w) : next[w].push_back(cw); found = true; } if(dict.count(cw)){ //count æ¯” findå¥½ç”¨ reverse ? next[cw].push_back(w) : next[w].push_back(cw); q.insert(cw); } } cw[i] = c; } } // for(const auto &amp;w :q) // cout &lt;&lt; w &lt;&lt; &quot; &quot;; // cout &lt;&lt; endl; //æ§åˆ¶æœç´¢å±‚æ•° if(found) break; for(const auto &amp;w : q){ dict.erase(w); } //é€‰æ‹©æ‰©å±•èŒƒå›´å°çš„å¼€å§‹æœç´¢ï¼Œé™ä½æœç´¢æ•°é‡ if(q.size() &lt; q2.size()){ q1 = q; }else{ reverse = !reverse; q1 = q2; q2 = q; } } vector&lt;string&gt; oneway = {beginWord}; buildPath(next, path, oneway, beginWord, endWord); return path; } void buildPath(unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; next, vector&lt;vector&lt;string&gt;&gt;&amp; path, vector&lt;string&gt; &amp;oneway, string nword, string endWord){ if(nword == endWord){ path.push_back(oneway); return; } for(const auto &amp;w : next[nword]){ oneway.push_back(w); buildPath(next, path, oneway, w, endWord); oneway.pop_back(); } } };","link":"/2020/11/29/shua-ti-sou-suo-bfs-126-word-ladder-ii/"},{"title":"22. Generate Parentheses","text":"æ€è·¯ï¼šæ­£ç¡®çš„è¿­ä»£æ–¹å¼æ˜¯ï¼Œä»å·¦åˆ°å³çš„éå†ä¸­ï¼Œæ¯ä¸€ä¸ªæ­£ç¡®åºåˆ—éƒ½æœ‰å·¦æ‹¬å·çš„æ•°é‡å¤§äºç­‰äºå³æ‹¬å·çš„æ•°é‡ã€‚è€Œæ¯ä¸€å¤„ç¬¦å·è¦ä¹ˆæ˜¯å·¦æ‹¬å·ï¼Œè¦ä¹ˆæ˜¯å³æ‹¬å·ï¼Œåè€…ç¬¦å·éƒ½æœ‰é€‰æ‹©çš„ç”Ÿæˆå³å¯ã€‚ å¦‚ä½•ä¾¿å¯ä»¥é€’å½’ç”Ÿæˆæ‰€æœ‰ç¬¦åˆé¢˜æ„çš„æ‹¬å·ã€‚ ä»£ç ï¼šclass Solution { vector&lt;string&gt; ans; set&lt;string&gt; sset; public: vector&lt;string&gt; generateParenthesis(int n) { generateParenthesisCore(0, 0, n, &quot;&quot;); for(string s : sset) ans.push_back(s); return ans; } void generateParenthesisCore(int left, int right, int n, string str){ if(left == n){ ans.push_back(str + string((n - right), ')')); return; } generateParenthesisCore(left + 1, right, n, str + &quot;(&quot;); if(left &gt; right){ generateParenthesisCore(left, right + 1, n, str + &quot;)&quot;); } } };","link":"/2021/04/26/shua-ti-sou-suo-bfs-22-generate-parentheses/"},{"title":"130. Surrounded Regions","text":"130. Surrounded Regionsæ€è·¯ï¼šå¦‚æœç”¨æ™®é€šdfsæœç´¢æ‰€æœ‰åŒºåŸŸæ˜¯é€Ÿåº¦æœ‰ç‚¹æ…¢çš„ã€‚ ä½†åªæ˜¯åè¿‡æ¥æ€è€ƒï¼Œå¦‚æœåªæ‰€æœç´¢æ‰€æœ‰ä¸è¢«åŒ…å›´çš„Oå¹¶æ ‡è®°ï¼ŒåŒæ—¶ç¿»è½¬æ‰€æœ‰å‰©ä¸‹çš„Xï¼Œæœ€åæŠŠæ‰€æœ‰çš„Pç¿»è½¬å›æ¥æ˜¯ä¸æ˜¯ä¼šæ›´å¿«ã€‚ ä¸æç‰¹ä¾‹çš„è¯ï¼Œä¸€èˆ¬éƒ½æ˜¯åè€…å¿«ã€‚ ä»£ç ï¼šclass Solution { public: int n, m; int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; void fill(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;bool&gt;&gt;&amp; vis,vector&lt;pair&lt;int, int&gt;&gt; &amp;path, int &amp;isea, int x , int y){ // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; vis[x][y] = 1; path.push_back(make_pair(x, y)); for(int i = 0; i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m){ isea = 1; continue; } if(!vis[nx][ny] &amp;&amp; board[nx][ny] == 'O'){ fill(board, vis, path, isea, nx, ny); } } } void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) { n = board.size(); if(n == 0) return; m = board[0].size(); vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m, false)); for(int i = 0; i &lt; n; ++i){ for(int j = 0;j &lt; m; ++j){ if(!vis[i][j] &amp;&amp; board[i][j] == 'O'){ vector&lt;pair&lt;int, int&gt;&gt; path; int isea = 0; fill(board, vis, path, isea, i, j); if(isea) continue; // bugs: forgets to clear path for(auto p : path){ board[p.first][p.second] = 'X'; } } } } } }; 16msèŒƒä¾‹ class Solution { public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) { // ç»™å‡ºä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œæ‰¾åˆ°è¢« x åŒ…å›´çš„ oï¼Œç„¶åå°†å…¶è½¬æ¢ä¸ºx // dfs if(board.empty()) return; int m = board.size(), n = board[0].size(); if (m == 1 || n == 1) return ; // åè¿‡æ¥æ€è€ƒï¼Œåªæ”¹å˜å’Œè¾¹ç•Œç›´æ¥ç›¸è¿çš„å…ƒç´  // é¦–å…ˆæ£€æŸ¥ç¬¬ä¸€è¡Œå’Œæœ€åä¸€è¡Œçš„ O for(int i = 0;i&lt;m;i+=m-1) for(int j = 0;j&lt;n;j++) if(board[i][j] == 'O') dfs(board,i,j,m,n); // å†æ£€æŸ¥ç¬¬ä¸€åˆ—å’Œæœ€åä¸€åˆ—çš„ O for(int j = 0;j&lt;n;j+=n-1) for(int i = 0;i&lt;m;i++) if(board[i][j] == 'O') dfs(board,i,j,m,n); // å°† board ä¸­çš„ O æ”¹ä¸º X // å†å°† board ä¸­çš„ P æ”¹ä¸º O for (auto &amp;i:board) replace(i.begin(),i.end(),'O','X'); for (auto &amp;i:board) replace(i.begin(),i.end(),'P','O'); } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp;board,int i, int j,int m, int n) { if(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp; board[i][j] == 'O') { board[i][j] = 'P'; dfs(board,i+1,j,m,n); dfs(board,i,j+1,m,n); dfs(board,i-1,j,m,n); dfs(board,i,j-1,m,n); } } };","link":"/2020/12/01/shua-ti-sou-suo-dfs-130-surrounded-regions/"},{"title":"417. Pacific Atlantic Water Flow","text":"417. Pacific Atlantic Water Flowæ€è·¯ï¼šæŒ‰ç€é¢˜ç›®çš„æ„æ€é¡ºç€æµå‘DFSæœ‰ä»¥ä¸‹é—®é¢˜ã€‚åšäº†æ­£å‘çš„ä»£ç å‘ç°æœ‰ä¸ªDFSä¾èµ–é—®é¢˜ã€‚ ç½‘ä¸Šå¤§ç¥ç»™å‡ºäº†**é€†æµ**DFSçš„æ€è·¯ã€‚ ä»£ç ï¼šclass Solution { public: int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; int m, n; // é¡ºæµdfsæœç´¢å¾—è‰²5re'rs'ze'd [re'rong'ze'dui] // å›æµä¾èµ–é—®é¢˜ï¼š when height[x, y] == height[nx, ny] : // type[x ,y] =&gt; type[dx, dy], type[dx ,dy] =&gt; type[x, y] , åŒæ—¶DFSå¼çš„éå†æ–¹å¼ä¿è¯äº†äº†æ¯ä¸ª // èŠ‚ç‚¹åªè¢«è®¿é—®ä¸€æ¬¡ï¼Œæ‰€ä»¥å­˜åœ¨ç±»å‹ç›¸äº’ä¾èµ–å…³ç³» // å³å­˜åœ¨ä¸€ä¸ªé¸¡ç”Ÿè›‹ï¼Œè›‹ç”Ÿé¸¡çš„é—®é¢˜ã€‚ // è§£å†³æ–¹æ³•æ˜¯ï¼šæ²¡æƒ³å‡ºæ¥ int flow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type, int x, int y){ // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; if(x &lt; 0 || y &lt; 0 ) return -1; else if( x &gt;= m || y &gt;= n) return -2; if(type[x][y] != 0) return type[x][y]; type[x][y] = 4; // the visited point. int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1; for(int i = 0; i &lt; 4; ++i){ nx = x + dx[i]; ny = y + dy[i]; if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;= m || ny &gt;= n) || matrix[nx][ny] &lt;= matrix[x][y]){ //bugs: nx, ny t = flow(matrix, type, nx, ny); if(t == -1 || t == 1 || t == 3) f1 = 1; if(t == -2 || t == 2 || t == 3) f2 = 1; } } if(f1 &amp; f2) type[x][y] = 3; else if(f1) type[x][y] = 1; else if(f2) type[x][y] = 2; // type[x][y] = f1 &amp; f2; // bugs 1 &amp; 1 return type[x][y]; } int flow2(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type, int x, int y){ // cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl; if(x &lt; 0 || y &lt; 0 ) return -1; else if( x &gt;= m || y &gt;= n) return -2; int nx, ny, f1 = 0, f2 = 0, t = 0; //bugs: initailization: flag = 1; for(int i = 0; i &lt; 4; ++i){ nx = x + dx[i]; ny = y + dy[i]; if( (nx &lt; 0 || ny &lt; 0) || (nx &gt;= m || ny &gt;= n) || matrix[nx][ny] &lt;= matrix[x][y]){ //bugs: nx, ny t = flow(matrix, type, nx, ny); if(t == -1 || t == 1 || t == 3) f1 = 1; if(t == -2 || t == 2 || t == 3) f2 = 1; } } if(f1 &amp; f2) type[x][y] = 3; else if(f1) type[x][y] = 1; else if(f2) type[x][y] = 2; // type[x][y] = f1 &amp; f2; // bugs 1 &amp; 2 ï¼š 1 | 2 return type[x][y]; } // é¢˜è§£ï¼šé€†æµå†™æ³• void reflow(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, vector&lt;vector&lt;int&gt;&gt; &amp;type, int x, int y, int wtype){ type[x][y] = type[x][y] | wtype; int nx, ny; for(int i = 0; i &lt; 4; ++i){ nx = x + dx[i]; ny = y + dy[i]; if(nx &gt;=0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) if(matrix[x][y] &lt;= matrix[nx][ny] &amp;&amp; ((type[nx][ny] &amp; wtype) == 0)) reflow(matrix, type, nx, ny, wtype); } } vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { m = matrix.size(); if(m == 0) return matrix; //return empty vector; n = matrix[0].size(); vector&lt; vector&lt;int&gt;&gt; type(m, vector&lt;int&gt;(n, 0)), ans; for(int i = 0; i &lt; m; ++i){ reflow(matrix, type, i, 0, 1); reflow(matrix, type, i, n - 1, 2); } for(int i = 0; i &lt; n; ++i){ reflow(matrix, type, 0, i, 1); reflow(matrix, type, m - 1, i, 2); } for(int i = 0; i &lt; m; ++i){ for(int j = 0; j &lt; n; ++j){ // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; type[i][j] &lt;&lt; endl; if(type[i][j] == 3){ ans.emplace_back( vector&lt;int&gt;({i, j})); // bugs initialize vector&lt;int&gt; a(n, i) } } } return ans; } };","link":"/2020/11/24/shua-ti-sou-suo-dfs-417-pacific-atlantic-water-flow/"},{"title":"547. Friend Circles","text":"547. Friend Circlesæ€è·¯ï¼šdfsæœç´¢äººå¤´å°±è¡Œã€‚ ä»£ç ï¼šclass Solution { public: int n; void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; M, vector&lt;int&gt;&amp; vis,int x){ vis[x] = 1; for(int i = 0; i &lt; n; ++i){ if(!vis[i] &amp;&amp; M[x][i]){ colorize(M, vis, i); } } } int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) { n = M.size(); vector&lt;int&gt; vis(n, 0); int ct = 0; for(int i = 0; i &lt; n; ++i){ if(!vis[i]){ ct++; colorize(M, vis, i); } } return ct; } };","link":"/2020/11/22/shua-ti-sou-suo-dfs-547-friend-circles/"},{"title":"547. Number of Provinces","text":"547. Number of Provincesæ€è·¯ï¼šå¤šæ¬¡dfsåˆ¤æ–­è¿é€šå›¢å³å¯ ä»£ç ï¼šclass Solution { public: int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { int res = 0, n = isConnected.size(); vector&lt;int&gt; vis(n); for(int i = 0; i &lt; n; ++i){ if(!vis[i]){ ++res; dfs(vis, isConnected, i); } } return res; } void dfs(vector&lt;int&gt; &amp;vis, vector&lt;vector&lt;int&gt;&gt; &amp;g, int k){ if(vis[k]) return; vis[k] = 1; for(int i = 0; i &lt; g.size(); ++i){ if(g[k][i]) dfs(vis, g, i); } } };","link":"/2021/01/07/shua-ti-sou-suo-dfs-547-number-of-provinces/"},{"title":"695. Max Area of Island","text":"695. Max Area of Islandã€ æ€è·¯ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ ä»£ç ï¼š class Solution { public: int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, 1, -1}; int n, m; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if(grid[0].size() == 0) return 0; n = grid.size(), m = grid[0].size(); vector&lt; vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m, 0)); int maxA = 0; for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; m; ++j){ int tempA = 0; if(grid[i][j] == 1 &amp;&amp; vis[i][j] == 0){ area(grid, i, j, vis, tempA); maxA = max(maxA, tempA); } } } return maxA; } void area(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; vis, int &amp;ct){//bug // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; if( x &lt; 0 || x &gt;=n || y &lt; 0 || y &gt;= m || vis[x][y] == 1 || grid[x][y] == 0 ) return;//bug vis[x][y] = 1; //bug ct += 1; for(int k = 0; k &lt; 4; ++k) area(grid, x + dx[k], y + dy[k], vis, ct); } };","link":"/2020/11/19/shua-ti-sou-suo-dfs-695-max-area-of-island/"},{"title":"154. Find Minimum in Rotated Sorted Array II","text":"154. Find Minimum in Rotated Sorted Array IIæ€è·¯ï¼šè¿™é¢˜éå¸¸å…·æœ‰å¯å‘æ€§è´¨ï¼Œhard~ è™½ç„¶è¿˜æ˜¯äºŒåˆ†ï¼Œä½†æ˜¯é¢˜ç›®æ¡ä»¶æ›´åŠ å¤æ‚ã€‚ è¯é¢˜å¯è§†åŒ–è¿˜æ˜¯ä¸é”™çš„åˆ†ææ–¹æ³•ï¼Œå¯æƒœæˆ‘å¤ªæ‡’äº†â€¦â€¦ æ³¨æ„é¢˜ç›®çš„è¢«æ—‹è½¬æ•°ç»„éƒ¨åˆ†å¯èƒ½é•¿åº¦ä¸ºé›¶ã€‚ å€Ÿç”¨ç­”æ¡ˆçš„åˆ†ææ€è·¯ï¼š ç”±äºæ•°ç»„â€œå³è¾¹â€çš„æ•°å­—ä¸€å®šæ˜¯æœªè¢«æ—‹è½¬çš„ï¼Œé‚£ä¹ˆä¸€å®šæœ‰$$nums[mid] &lt; num[right] -&gt; å³è¾¹æœ‰åº\\nums[mid] &gt; num[right] -&gt; å·¦è¾¹æœ‰åº$$ å¦‚æ­¤ä¾¿å¯ä»¥äºŒåˆ†ï¼Œå…¶ä»–æƒ…å†µä¸‹ï¼Œå¯èƒ½å­˜åœ¨$$nums[mid] == nums[l] == nums[r]$$æ— æ³•è¿›è¡ŒäºŒåˆ†ï¼Œä½†å¯ä»¥å‘ç°ï¼Œnum[r]ç­‰äºnums[mid]ï¼Œæ‰€ä»¥ræ˜¯å¯ä»¥ç¼©å‡èŒƒå›´çš„ã€‚ å›¾å½¢åŒ–æè¿°è§å®˜æ–¹é¢˜è§£ ä»£ç ï¼šclass Solution { public: int findMin(vector&lt;int&gt;&amp; nums) { int l = 0, r = nums.size() - 1, mid; if(r &lt; 0) return -1;//bug //åŠ ä¸ªåˆ¤æ–­å‡»è´¥14%-&gt;98%,è¯´æ˜å¤§å¤šæ•°äººè¿˜æ˜¯ç›´æ¥å¤åˆ¶ç²˜ç²˜ç­”æ¡ˆçš„ if(nums[l] &lt; nums[r]) return nums[l]; while(l &lt; r){ mid = l + (r - l) / 2; if(nums[mid] &lt; nums[r]) r = mid; else if(nums[mid] &gt; nums[r]) l = mid + 1; else r--; } return nums[l]; } };","link":"/2020/11/01/shua-ti-sou-suo-er-fen-154-find-minimum-in-rotated-sorted-array-ii/"},{"title":"81. Search in Rotated Sorted Array II","text":"81. Search in Rotated Sorted Array IIæ€è·¯ï¼šè¿™é¢˜å¥½åƒæ˜¯33é¢˜çš„follow upã€‚ å¢æ·»äº†å„ä¸ªå…ƒç´ å¯èƒ½ç›¸ç­‰çš„æ¡ä»¶ã€‚ æ²¡åšå‡ºæ¥ã€‚ å¦‚æœè€ƒè™‘åœ¨ä¸Šä¸€é¢˜çš„æ€è·¯ï¼Œå…ˆå¯»æ‰¾æ‰¾å‡ºäºŒåˆ†ç‚¹ï¼Œåœ¨äºŒåˆ†ä¸¤ç«¯æ•°å­—ã€‚å¦‚æœé‡åˆ° nums[mid]==nums[l]é‚£å°±éœ€è¦éå†ç¡®å®šå“ªè¾¹æ˜¯ç›¸ç­‰çš„ï¼Œå·´æ‹‰å·´æ‹‰â€¦â€¦ï¼Œå¤šäº†ä¸€å †æ¡ä»¶è®¾ç½®å’Œæ¡ä»¶åˆ¤æ–­ã€‚ è·³å‡ºè¿™å±‚ï¼Œèƒ½ä¸èƒ½ç›´æ¥åœ¨äºŒåˆ†æœç´¢å‘¢ï¼Ÿ å‚è€ƒé¢˜è§£ // å¤±è´¥çš„äºŒåˆ† // class Solution { // public: // bool search(vector&lt;int&gt;&amp; nums, int target) { // int n = nums.size(); // int l = 0, r = n, mid, start = l; // while(l &lt; r){ // mid = (l + r) / 2; // if(nums[mid] &lt; nums[start]) r = mid; // else if(nums[mid] == nums[start]) start++; // else l = mid + 1; // // cout &lt;&lt; l &lt;&lt; endl; // } // // cout &lt;&lt; l &lt;&lt; endl; // vector&lt;int&gt;::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target); // vector&lt;int&gt;::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target); // if( iter1 != nums.end() &amp;&amp; *iter1 == target || iter2 != nums.end() &amp;&amp; *iter2 == target) // return true; // else return false; // } // }; class Solution { public: bool search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int l = 0, r = n - 1, mid, start = l; while(l &lt;= r){ mid = ( r + l) / 2; if(nums[mid] == target) return true; else if(nums[mid] &gt; nums[l]){ if(nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) r = mid - 1; else l = mid + 1; } else if(nums[mid] &lt; nums[l]){ if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) l = mid + 1; else r = mid - 1; } else if(nums[mid] == nums[l]) l++; } return false; } };","link":"/2020/10/30/shua-ti-sou-suo-er-fen-2020-10-30-81-search-in-rotated-sorted-array-ii/"},{"title":"34. Find First and Last Position of Element in Sorted Array","text":"34. Find First and Last Position of Element in Sorted Array æ€è·¯ï¼šäºŒåˆ† ä»£ç ï¼šclass Solution { public: int getFirst(vector&lt;int&gt; nums, int l, int r, int tar){ if(nums.size() == 0) return -1; int mid ; while(l &lt; r){ mid = (r + l) / 2; if(nums[mid] &lt; tar) l = mid + 1; else r = mid; } // ä¸´ç•Œåˆ¤æ–­éœ€è¦å°å¿ƒ return l != nums.size() &amp;&amp; nums[l] == tar ? l : -1; } int getLast(vector&lt;int&gt; nums, int l, int r, int tar){ if(nums.size() == 0) return -1; int mid ; while(l &lt; r){ mid = (r + l) / 2; if(nums[mid] &lt;= tar) l = mid + 1; else r = mid; } return l != 0 &amp;&amp; nums[l - 1] == tar ? l - 1 : -1; } vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int s = -1 , e = -1, l = 0, r = nums.size(); vector&lt;int&gt; res({getFirst(nums, 0, nums.size(), target) , getLast(nums, 0, nums.size(), target) }); return res; } };","link":"/2020/10/28/shua-ti-sou-suo-er-fen-34-find-first-and-last-position-of-element-in-sorted-array/"},{"title":"4. Median of Two Sorted Arrays","text":"4. Median of Two Sorted Arrays - ç¬¬Kå¤§ + äºŒåˆ·æ€è·¯ï¼šå°†æŸ¥æ‰¾ä¸­ä½æ•°æ‰©å¤§ä¸ºæ›´å¹¿ä¹‰çš„è§£æ³•ï¼šæ±‚è§£ç¬¬$K$ä½çš„æ•°å­—ã€‚æ¯æ¬¡åœ¨A,Bä¸¤ä¸ªæ•°ç»„ä¸­åˆ’åˆ†å‡ºä¸¤ä¸ªk/2ä¸ªå…ƒç´ ï¼Œå¹¶æ’é™¤åˆ’åˆ†å‡ºçš„æœ€åä¸€ä¸ªæ•°å­—æ¯”è¾ƒå°çš„æ•°ç»„ï¼Œç„¶åå‡å»å¯¹åº”çš„æ’é™¤çš„æ•°ç»„çš„æ•°å­—ä¸ªæ•°ï¼Œæ›´æ–°$K$å€¼ã€‚ç›´åˆ°$K==1$ï¼Œæˆ–è€…å…¶ä¸­ä¸€ä¸ªæ•°ç»„ä¸ºç©ºã€‚ è¯¦ç»†é¢˜è§£å¦‚ä¸‹ ä»£ç ï¼šclass Solution { public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len1 = nums1.size(), len2 = nums2.size(); int alllen = len1 + len2; if(alllen % 2 == 1){ return findKthNum(nums1, nums2, alllen / 2 + 1); }else return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2; } double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k){ int idx1 = 0, idx2 = 0; int len1 = nums1.size(), len2 = nums2.size(); while(1){ if(idx1 == len1) return nums2[idx2 + k - 1]; if(idx2 == len2) return nums1[idx1 + k - 1]; if(k == 1) return min(nums1[idx1], nums2[idx2]); int half = k / 2; int newidx1 = min(idx1 + half, len1) - 1; int newidx2 = min(idx2 + half, len2) - 1; if(nums1[newidx1] &gt; nums2[newidx2]){ k -= newidx2 - idx2 + 1; idx2 = newidx2 + 1; }else{ k -= newidx1 - idx1 + 1; idx1 = newidx1 + 1; } } } }; // æ€è€ƒä¸€ä¸‹follow up // å¦‚æœKç»„æœ‰åºæ•°æ®ï¼Œè¦é€‰å‡ºç¬¬Kå¤§æ•°æ®ä½ æ€ä¹ˆè®¡ç®—å‘¢ï¼Ÿ æ‰©å±•ä¸€ä¸‹å°±å¯ä»¥äº†ï¼ //ä»¥ä¸‹æ˜¯äºŒåˆ·ï¼Œä¸æ˜¯followup class Solution { public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int len1 = nums1.size(), len2 = nums2.size(); int alllen = len1 + len2; if(alllen % 2 == 1){ return findKthNum(nums1, nums2, alllen / 2 + 1); }else return (findKthNum(nums1, nums2, alllen / 2 ) + findKthNum(nums1, nums2, alllen / 2 + 1) ) / 2; } // kï¼š ç¬¬Kä¸ªæ•°æ®ï¼ˆâ€˜ç¬¬â€™é»˜è®¤ä»1å¼€å§‹æ•°èµ· ï¼‰ double findKthNum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k){ int n = nums1.size(), m = nums2.size(); int idx1 = 0, idx2 = 0; while(1){ if(idx1 == n) return nums2[idx2 + k - 1]; // åˆ¤æ–­ä¸´ç•Œç‚¹ if(idx2 == m) return nums1[idx1 + k - 1]; if(k == 1) return min(nums1[idx1], nums2[idx2]); // k &gt;= 2 int newidx1 = min(k / 2 + idx1, n) - 1; // min é˜²æ­¢æº¢å‡º int newidx2 = min(k / 2 + idx2, m) - 1; if(nums1[newidx1] &gt; nums2[newidx2]){// ç»“å°¾æ•°å­—å°çš„å¯ä»¥ç›´æ¥å¿½ç•¥å‰ä¸² k -= newidx2 - idx2 + 1; idx2 = newidx2 + 1; // å¤šè¿›ä¸€ä¸ªæ•°å­— }else{ k -= newidx1 - idx1 + 1; idx1 = newidx1 + 1; } } } };","link":"/2020/11/12/shua-ti-sou-suo-er-fen-4-median-of-two-sorted-arrays/"},{"title":"69. Sqrt(x)","text":"è¿™é¢˜è¿˜æ˜¯è›®ä¸é”™çš„ï¼ŒäºŒåˆ†å’Œç‰›é¡¿è¿­ä»£æ³•çš„ç»ƒä¹ å…¥é—¨é¢˜ã€‚ 69. Sqrt(x) äºŒåˆ† - ç‰›é¡¿è¿­ä»£æ³•æ€è·¯ï¼šäºŒåˆ†xæˆ–è€…ç‰›é¡¿è¿­ä»£è®¡ç®—éƒ½å¯ã€‚ ä»£ç ï¼š class Solution { public: int mySqrt(int x) { long l = 0, r = x, mid; while(l &lt; r){ mid = (l + r) / 2; if(mid * mid &lt; x) l = mid + 1; else r = mid; } if(l * l == x) return l; else return l - 1; } }; â€‹ ç‰›é¡¿è¿­ä»£æ³• // ç‰›é¡¿è¿­ä»£æ³• class Solution { public: //å†™çš„æ—¶å€™çæƒ³çš„ æŒºå¥½ç”¨ int mySqrt(int x) { double ans = x, last = ans + 1; double gap = 1e-3; if(x == 0) return 0; while(abs(ans - last) &gt; gap){ last = ans; ans = ans - (ans * ans - x) / (double)(2 * ans); } return int(ans); } }; //ä¸Šä¸€ä¸ªæ–¹æ³•çš„å…¬å¼ç®€åŒ–ç‰ˆï¼Œ å‡»è´¥100% //è€Œä¸”è€ƒè™‘åˆ°äº†doubleè¿ç®—é€Ÿåº¦æ…¢ï¼Œç²¾åº¦è¦æ±‚ä¸é«˜ï¼Œå¯ä»¥ä½¿ç”¨longæ¥ä»£æ›¿ï¼Œä¸”ä¿è¯ä¸ä¼šé—æ¼ç­”æ¡ˆã€‚ class Solution { public: int mySqrt(int x) { long res = x; while(res * res &gt; x){ res = (res + x/ res ) /2; } return res; } };","link":"/2020/10/27/shua-ti-sou-suo-er-fen-69-sqrt-x/"},{"title":"75. Sort Colors","text":"75. Sort Colorså½©è™¹é¢˜ æ€è·¯ï¼š ç›´æ¥æ¡¶æ’ æœ‰è¶£çš„ä¸‰æŒ‡é’ˆç®—æ³•ã€‚ ä»£ç ï¼šæ¡¶æ’ class Solution { public: void sortColors(vector&lt;int&gt;&amp; nums) { int count[3] = {0}; for(int i = 0; i &lt; nums.size(); ++i){ count[nums[i]]++; } int k = 0; for(int i = 0; i &lt; 3; ++i){ while(count[i] &gt; 0){ nums[k++] = i; count[i]--; } } } }; ä¸‰æŒ‡é’ˆ class Solution { public: void sortColors(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int p0 = 0, p1 = n - 1; for(int i = 0; i &lt;= p1; ++i){ while(nums[i] == 2 &amp;&amp; p1 &gt;= i){ swap(nums[i], nums[p1]); p1--; } if(nums[i] == 0){ swap(nums[p0], nums[i]); p0++; } } } };","link":"/2020/11/17/shua-ti-sou-suo-er-fen-75-sort-colors/"},{"title":"81. Search in Rotated Sorted Array II","text":"81. Search in Rotated Sorted Array IIæ€è·¯ï¼šè¿™é¢˜å¥½åƒæ˜¯33é¢˜çš„follow upã€‚ å¢æ·»äº†å„ä¸ªå…ƒç´ å¯èƒ½ç›¸ç­‰çš„æ¡ä»¶ã€‚ æ²¡åšå‡ºæ¥ã€‚ å¦‚æœè€ƒè™‘åœ¨ä¸Šä¸€é¢˜çš„æ€è·¯ï¼Œå…ˆå¯»æ‰¾æ‰¾å‡ºäºŒåˆ†ç‚¹ï¼Œåœ¨äºŒåˆ†ä¸¤ç«¯æ•°å­—ã€‚å¦‚æœé‡åˆ° nums[mid]==nums[l]é‚£å°±éœ€è¦éå†ç¡®å®šå“ªè¾¹æ˜¯ç›¸ç­‰çš„ï¼Œå·´æ‹‰å·´æ‹‰â€¦â€¦ï¼Œå¤šäº†ä¸€å †æ¡ä»¶è®¾ç½®å’Œæ¡ä»¶åˆ¤æ–­ã€‚ è·³å‡ºè¿™å±‚ï¼Œèƒ½ä¸èƒ½ç›´æ¥åœ¨äºŒåˆ†æœç´¢å‘¢ï¼Ÿ å‚è€ƒé¢˜è§£ // å¤±è´¥çš„äºŒåˆ† // class Solution { // public: // bool search(vector&lt;int&gt;&amp; nums, int target) { // int n = nums.size(); // int l = 0, r = n, mid, start = l; // while(l &lt; r){ // mid = (l + r) / 2; // if(nums[mid] &lt; nums[start]) r = mid; // else if(nums[mid] == nums[start]) start++; // else l = mid + 1; // // cout &lt;&lt; l &lt;&lt; endl; // } // // cout &lt;&lt; l &lt;&lt; endl; // vector&lt;int&gt;::iterator iter1 = std::lower_bound(nums.begin(), nums.begin() + l, target); // vector&lt;int&gt;::iterator iter2 = std::lower_bound(nums.begin() + l, nums.end(), target); // if( iter1 != nums.end() &amp;&amp; *iter1 == target || iter2 != nums.end() &amp;&amp; *iter2 == target) // return true; // else return false; // } // }; class Solution { public: bool search(vector&lt;int&gt;&amp; nums, int target) { int n = nums.size(); int l = 0, r = n - 1, mid, start = l; while(l &lt;= r){ mid = ( r + l) / 2; if(nums[mid] == target) return true; else if(nums[mid] &gt; nums[l]){ if(nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) r = mid - 1; else l = mid + 1; } else if(nums[mid] &lt; nums[l]){ if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) l = mid + 1; else r = mid - 1; } else if(nums[mid] == nums[l]) l++; } return false; } };","link":"/2021/01/28/shua-ti-sou-suo-er-fen-81-search-in-rotated-sorted-array-ii/"},{"title":"é¢è¯•é¢˜-äºŒåˆ†","text":"æ”¶é›†æŸ¥æ‰¾äºŒåˆ†æŸ¥æ‰¾ç›¸å…³é¢˜ç›® é¢11ï¼šæ—‹è½¬æ•°ç»„ é¢˜é¢ï¼šæ—‹è½¬æ•°ç»„å³æŠŠæ•°ç»„çš„å‰ä¸€éƒ¨åˆ†æ”¾åˆ°æ•°ç»„çš„æœ«å°¾ã€‚ç°æœ‰ä¸€ä¸é€’å‡æ•°ç»„ç»è¿‡æ—‹è½¬åï¼Œè¯·æ‰¾å‡ºæ•°ç»„å†…å…ƒç´ æœ€å°çš„æ•°ã€‚ æ€è·¯ï¼šä¸€ç§å°±æ˜¯ç›´æ¥éå†ã€‚ æ›´å¿«åœ°å¯æ˜¯ä½¿ç”¨äºŒåˆ†æ³•æŸ¥æ‰¾å…ƒç´ ã€‚ä¾æ®äºŒåˆ†æ³•ï¼Œè®°æŒ‡é’ˆæœ‰Aï¼ŒBï¼Œmidï¼›ã€‚è‹¥æœ‰æ•°ç»„array[mid]&gt;=array[A]åˆ™æœ‰midåœ¨å‰ä¸€ä¸ªæ²¡æœ‰ç§»åŠ¨çš„åŒºé—´ï¼ˆå°±æ˜¯æŒ‡æ²¡æœ‰è¢«é€‰æ‹©çš„éƒ¨åˆ†ï¼Œå¯¹åº”çš„å°±æ˜¯æŒ‡è¢«æ—‹è½¬çš„éƒ¨åˆ†ï¼‰ï¼Œåº”è¯¥å‘ååŠéƒ¨åˆ†ç»§ç»­äºŒåˆ†ã€‚å¦åˆ™midåœ¨åä¸€ä¸ªç§»åŠ¨è¿‡çš„åŒºé—´ï¼Œåº”è¯¥å‘å‰åŠéƒ¨åˆ†äºŒåˆ†ã€‚ ä½†æ˜¯ç”±äºé¢˜é¢è¯´æ•°æ®å¯èƒ½ä¸æ˜¯é€’å¢çš„ï¼Œæ‰€ä»¥å¯èƒ½å‡ºç°array[A]=array[mid]=array[B]çš„æƒ…å†µï¼Œè¿™æ—¶å¦‚æœmidæŒ‡å‘ç§»åŠ¨è¿‡çš„åŒºé—´å°±ä¼šå‡ºç°é”™è¯¯ï¼Œæ¯”å¦‚1,0,1,1,1ï¼ŒA=0,B=4,mid=2ã€‚å¦‚ä½•é¿å…å‘¢ï¼Ÿåªèƒ½æ˜¯ç›´æ¥éå†ã€‚ å¦‚ä½•å‘ç°è®¾è®¡ç®—æ³•é”™è¯¯å‘¢ï¼Ÿä¸¤ç§æ€è·¯ä¸€ç§æ˜¯ç»™æµ‹è¯•æ ·ä¾‹ï¼Œå¦ä¸€ç§æ˜¯åˆ¤æ–­ç®—æ³•æœ¬èº«æ˜¯å¦æœ‰æ¼æ´ã€‚åƒè¿™é‡Œçš„äºŒåˆ†æ³•å°±å‡è®¾äº†array[mid]&lt;=array[A]ä¸”array[mid]&gt;array[B]ï¼Œè¿™ä¸ªå‡è®¾ä¸€æå‡ºæ¥å°±æ˜¾å¾—éå¸¸çš„è’è°¬äº†ã€‚ æ ·ä¾‹ï¼š4,5,6,7,1,2,3 1,1,0,1,1,1,1 1,1,1,1,0,1,1 ä»£ç :int Min(int* numbers, int length){ if(numbers == null || length &lt;= 0) throw new std::exception(&quot;Invalid parameters&quot;); int start = 0, end = length - 1, mid; while(start &lt; end){ int mid = ((end - start) &gt;&gt; 1) + start; if(numbers[start] == numbers[mid] == numbers[end] ){ int minNum = numbers[0]; for(int i = 1; i &lt; length; i++) if( numbers[i] &lt; minNum) minNum = numbers[i]; return minNum; } if(numbers[mid] &gt;= numbers[start]) start = mid + 1; else end = mid; } return numbers[end]; } é¢53:(å¾…å®Œæˆ)é¢˜é¢ï¼šæ—‹è½¬æ•°ç»„å³æŠŠæ•°ç»„çš„å‰ä¸€éƒ¨åˆ†æ”¾åˆ°æ•°ç»„çš„æœ«å°¾ã€‚ç°æœ‰ä¸€ä¸é€’å‡æ•°ç»„ç»è¿‡æ—‹è½¬åï¼Œè¯·æ‰¾å‡ºæ•°ç»„å†…å…ƒç´ æœ€å°çš„æ•°ã€‚ æ€è·¯ï¼šä¸€ç§å°±æ˜¯ç›´æ¥éå†ã€‚ æ›´å¿«åœ°å¯æ˜¯ä½¿ç”¨äºŒåˆ†æ³•æŸ¥æ‰¾å…ƒç´ ã€‚ä¾æ®äºŒåˆ†æ³•ï¼Œè®°æŒ‡é’ˆæœ‰Aï¼ŒBï¼Œmidï¼›ã€‚è‹¥æœ‰æ•°ç»„array[mid]&gt;=array[A]åˆ™æœ‰midåœ¨å‰ä¸€ä¸ªæ²¡æœ‰ç§»åŠ¨çš„åŒºé—´ï¼ˆå°±æ˜¯æŒ‡æ²¡æœ‰è¢«é€‰æ‹©çš„éƒ¨åˆ†ï¼Œå¯¹åº”çš„å°±æ˜¯æŒ‡è¢«æ—‹è½¬çš„éƒ¨åˆ†ï¼‰ï¼Œåº”è¯¥å‘ååŠéƒ¨åˆ†ç»§ç»­äºŒåˆ†ã€‚å¦åˆ™midåœ¨åä¸€ä¸ªç§»åŠ¨è¿‡çš„åŒºé—´ï¼Œåº”è¯¥å‘å‰åŠéƒ¨åˆ†äºŒåˆ†ã€‚ ä½†æ˜¯ç”±äºé¢˜é¢è¯´æ•°æ®å¯èƒ½ä¸æ˜¯é€’å¢çš„ï¼Œæ‰€ä»¥å¯èƒ½å‡ºç°array[A]=array[mid]=array[B]çš„æƒ…å†µï¼Œè¿™æ—¶å¦‚æœmidæŒ‡å‘ç§»åŠ¨è¿‡çš„åŒºé—´å°±ä¼šå‡ºç°é”™è¯¯ï¼Œæ¯”å¦‚1,0,1,1,1ï¼ŒA=0,B=4,mid=2ã€‚å¦‚ä½•é¿å…å‘¢ï¼Ÿåªèƒ½æ˜¯ç›´æ¥éå†ã€‚ å¦‚ä½•å‘ç°è®¾è®¡ç®—æ³•é”™è¯¯å‘¢ï¼Ÿä¸¤ç§æ€è·¯ä¸€ç§æ˜¯ç»™æµ‹è¯•æ ·ä¾‹ï¼Œå¦ä¸€ç§æ˜¯åˆ¤æ–­ç®—æ³•æœ¬èº«æ˜¯å¦æœ‰æ¼æ´ã€‚åƒè¿™é‡Œçš„äºŒåˆ†æ³•å°±å‡è®¾äº†array[mid]&lt;=array[A]ä¸”array[mid]&gt;array[B]ï¼Œè¿™ä¸ªå‡è®¾ä¸€æå‡ºæ¥å°±æ˜¾å¾—éå¸¸çš„è’è°¬äº†ã€‚ æ ·ä¾‹ï¼š4,5,6,7,1,2,3 1,1,0,1,1,1,1 1,1,1,1,0,1,1 ä»£ç :","link":"/2020/08/07/shua-ti-sou-suo-er-fen-mian-shi-ti-er-fen/"},{"title":"é¢è¯•é¢˜53 - II. 0ï½n-1ä¸­ç¼ºå¤±çš„æ•°å­—","text":"å¥½èœå•Šï¼ŒäºŒåˆ†éƒ½ä¸ä¼šäº†å†™äº†å‡ºäº†ä¸‰ä¸ªbugï¼Œè¿˜å¥½æ£€æŸ¥çš„å¿«ã€‚ Leecodeçš„æ— è°ƒè¯•debugè¿˜æ˜¯ç›¸å½“é”»ç‚¼äººçš„ã€‚ ç®€å•æ€è·¯ï¼šhashä¸€ä¸‹æ¯ä¸ªæ•°æ®ï¼Œæ‰¾å‡ºç©ºç™½å€¼å³å¯ã€‚ äºŒåˆ†æ€è·¯ï¼šä¾æ®å‰åŠéƒ¨åˆ†æœ‰nums[i] == içš„æ€§è´¨ï¼Œå’ŒååŠéƒ¨åˆ†nums[i] ï¼= içš„ä¸åŒå¯ä»¥äºŒåˆ†æ•°æ®ï¼Œä»è€Œæ‰¾å‡ºé”™ä½çš„ç¬¬ä¸€ä¸ªæ•°æ®ã€‚ä½†æ˜¯é”™ä½çš„æ•°æ®ä¸ä¸€å®šæ˜¯ç¼ºå°‘çš„æ•°æ®ï¼Œå¦‚æœi==len(nums)å°±å¯èƒ½æœ‰ç¼ºå¤±æ•°æ®nâˆ’1nâˆ’1çš„å¯èƒ½æ€§ã€‚ cpp class Solution { public: // int missingNumber(vector&lt;int&gt;&amp; nums) { // int len = nums.size(); // int *hs = new int[len + 1]; // //æœªåˆå§‹åŒ–ï¼Œæˆ–è€…è¯´å‡½æ•°ä¸­newçš„æ•°ç»„åˆå§‹çŠ¶æ€éé›¶ // memset(hs,0, sizeof(int) * (len + 1) ); // for(int i = 0;i &lt; len ; ++i) hs[nums[i]] = 1; // for(int i = 0;i &lt; len + 1; ++i) // if( hs[i] == 0) // return i; // return 0; // } // }; int missingNumber(vector&lt;int&gt;&amp; nums) { int right = nums.size() - 1, left = 0, mid = right; //bug1 è¾¹ç•Œæƒ…å†µ if(nums[right] == right) return right + 1; while(left &lt; right){ mid = (left + right) / 2; //bug2 äºŒåˆ†é”™è¯¯ if( nums[mid] == mid ) left = mid + 1; else if( nums[mid] != mid) right = mid; } //bug3 midå€¼æ²¡è¢«æ›´æ–°, è€Œ left å’Œ right éƒ½å¯ä»¥ return left; w } };","link":"/2020/08/07/shua-ti-sou-suo-er-fen-mian-shi-ti-53-ii-0-n-1-zhong-que-shi-de-shu-zi/"},{"title":"37. Sudoku Solver","text":"37. Sudoku Solveræ€è·¯ï¼šdfsæœç´¢ï¼Œå¯ä»¥ç”¨ä½è¿ç®—ä¼˜åŒ–ï¼Œæ‡’å¾—çœ‹äº† ä»£ç ï¼šclass Solution { public: vector&lt;vector&lt;int&gt;&gt; col, row, cell; vector&lt;pair&lt;int, int&gt;&gt; blank; // int dx[4] = {0, 0, -1, 1}; // int dy[4] = {-1, 1, 0, 0}; int n; int flag = 0; int getC(int x, int y){ return (x / 3) * 3 + y / 3; } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { n = board.size(); row = cell = col = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n + 1, 0)); //bugs: num -&gt; idx // cout &lt;&lt; row[0][0]; for(int i = 0; i &lt; n; ++i){ for(int j = 0; j &lt; n; ++j){ if(board[i][j] == '.') { blank.push_back(make_pair(i, j)); continue; } int t = board[i][j] - '0'; row[i][t] = 1; col[j][t] = 1; cell[getC(i, j)][t] = 1; } } dfs(board, 0); } void dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board, int pos){ // cout &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; flag &lt;&lt; &quot; &quot; &lt;&lt; blank.size() &lt;&lt; endl; if(flag || pos == blank.size()){ flag = 1; return; } int x = blank[pos].first; int y = blank[pos].second; // cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl; if(board[x][y] == '.'){ for(int i = 1; i &lt;= 9; ++i){ if(!row[x][i] &amp;&amp; !col[y][i] &amp;&amp; !cell[getC(x, y)][i]){ // cout &lt;&lt; i &lt;&lt; &quot;@&quot; &lt;&lt; endl; row[x][i] = 1; col[y][i] = 1; cell[getC(x, y)][i] = 1; board[x][y] = i + '0'; dfs(board, pos + 1); if(flag) return; row[x][i] = 0; col[y][i] = 0; cell[getC(x, y)][i] = 0; board[x][y] = '.'; } } } } };","link":"/2020/12/05/shua-ti-sou-suo-hui-su-37-sudoku-solver/"},{"title":"37.è§£æ•°ç‹¬","text":"37 è§£æ•°ç‹¬ - ä½è¿ç®— å›æº¯ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œé€šè¿‡å·²å¡«å……çš„ç©ºæ ¼æ¥è§£å†³æ•°ç‹¬é—®é¢˜ã€‚ ä¸€ä¸ªæ•°ç‹¬çš„è§£æ³•éœ€éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š æ•°å­— 1-9 åœ¨æ¯ä¸€è¡Œåªèƒ½å‡ºç°ä¸€æ¬¡ã€‚æ•°å­— 1-9 åœ¨æ¯ä¸€åˆ—åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚æ•°å­— 1-9 åœ¨æ¯ä¸€ä¸ªä»¥ç²—å®çº¿åˆ†éš”çš„ 3x3 å®«å†…åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ç©ºç™½æ ¼ç”¨ â€˜.â€™ è¡¨ç¤ºã€‚ æ€è·¯ï¼šå›æº¯ã€‚ é”™è¯¯æƒ³æ³•ï¼šæ¨¡æ‹Ÿå¹³æ—¶ç©æ•°ç‹¬çš„æ–¹æ³•ï¼Œå¯»æ‰¾å¯èƒ½æ€§æœ€å°çš„æ ¼å­å¹¶ç¡®å®šï¼Œè¿™ç§æ–¹æ³•åè€Œå®ç°å¤æ‚ï¼Œéš¾ä»¥æŸ¥æ‰¾BUGã€‚ ç®€å•æ–¹æ³•åè€Œæœ€æœ‰æ•ˆ æ‰©å±•ï¼šå¦‚ä½•è®¡ç®—å¤æ‚åº¦ï¼Ÿ ä»£ç ï¼š1A //é”™è¯¯ä»£ç  class Solution { public: const static int len = 9; void print(vector&lt;vector&lt;char&gt;&gt; &amp;board){ static int sum = 1; printf(&quot;-----------------\\n%d \\n&quot;, sum++); if(sum &lt; 5) return; for(int i = 0; i &lt; len; i++){ for(int j = 0; j &lt; len; j++) printf(&quot;%c &quot;, board[i][j]); printf(&quot;\\n&quot;); } } void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, vector&lt;char&gt; poss[][len], int &amp;flag){ int minPoss = 20; int x = -1, y = -1; //print print(board); if(flag == 0) return; for(int i = 0; i &lt; len; i++) for(int j = 0; j &lt; len; j++){ int size = poss[i][j].size(); if(size == 1){ // do it. board[i][j] = poss[i][j][0]; poss[i][j].clear(); // remove the impossible number. for(int t = 0; t &lt; len; t++){ vector&lt;char&gt; &amp;rowP = poss[i][t]; vector&lt;char&gt; &amp;colP = poss[t][j]; rowP.erase(remove(rowP.begin(), rowP.end(), board[i][j]), rowP.end()); colP.erase(remove(colP.begin(), colP.end(), board[i][j]), colP.end()); } // int block = (i % 3) * 3 + j / 3; int x = i / 3 * 3; int y = j % 3 * 3; for(int p = x; p &lt; x + 3; p++) for(int q = y; q &lt; y + 3; q++) { vector&lt;char&gt; &amp;vecP = poss[p][q]; vecP.erase(remove(vecP.begin(), vecP.end(), board[i][j]), vecP.end()); } solveSudokuCore(board, poss, flag); return; } // This is a bad path. else if( size == 0 &amp;&amp; board[i][j] == '.'){ printf(&quot;[End point]:%d %d\\n&quot;, i, j); return; } // Find the minimum possibly grid; else if(minPoss &gt; size &amp;&amp; size &gt; 1){ minPoss = size; x = i; y = j; } } //The no more possbility. End the Search. if(minPoss == 20){ flag = 0; return; } // there are none grid that has only one possible result. vector&lt;char&gt; ans = poss[x][y]; poss[x][y].clear(); for(int i = 0; i &lt; ans.size(); i++){ poss[x][y].push_back(ans[i]); solveSudokuCore(board, poss, flag); poss[x][y].clear(); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { vector&lt;char&gt; pos[len][len]; bool hasNum[len + 1] = {0}; for(int i=0; i &lt; len; i++) for(int j=0; j &lt; len; j++){ if(board[i][j] == '.'){ memset(hasNum, 0, sizeof(bool) * (len + 1)); for(int k = 0; k &lt; len; k++){ if(board[k][j] != '.') hasNum[board[k][j] -'0'] = 1; if(board[i][k] != '.') hasNum[board[i][k] -'0'] = 1; } int x = i / 3 * 3; int y = j / 3 * 3; for(int p = x; p &lt; x + 3; p++) for(int q = y; q &lt; y + 3; q++) { if(board[p][q] != '.') hasNum[board[p][q] - '0'] = 1; } for(int l = 1; l &lt; len + 1; l++) if(hasNum[l] == 0) pos[i][j].push_back(l + '0'); } } int flag = 1; solveSudokuCore(board, pos, flag); } }; //1A class Solution { public: const static int len = 9; void print(vector&lt;vector&lt;char&gt;&gt; &amp;board, int x, int y){ static int sum = 1; printf(&quot;-----------------\\n%d %d %d;\\n&quot;, sum++, x, y); if(sum &lt; 8) return; for(int i = 0; i &lt; len; i++){ for(int j = 0; j &lt; len; j++) printf(&quot;%c &quot;, board[i][j]); printf(&quot;\\n&quot;); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { int rowNum[len][len] = {0}; int colNum[len][len] = {0}; int cubeNum[len][len] = {0}; memset(rowNum, 0, sizeof(int) * len * len); memset(colNum, 0, sizeof(int) * len * len); memset(cubeNum, 0, sizeof(int) * len * len); for(int i=0; i &lt; len; i++) for(int j=0; j &lt; len; j++){ if(board[i][j] != '.'){ rowNum[i][board[i][j] - '0' - 1] = 1; colNum[j][board[i][j] - '0' - 1] = 1; int cube = i / 3 * 3 + j / 3; cubeNum[cube][board[i][j] - '0' - 1] = 1; } } int flag = 0; solveSudokuCore(board, rowNum, colNum, cubeNum, 0, 0, flag); } void changeXY(int x , int y, int &amp;nx, int &amp;ny){ y++; if(y == 9){ y = 0; x++; } nx = x; ny = y; } void solveSudokuCore(vector&lt;vector&lt;char&gt;&gt; &amp;board, int rowNum[][len], int colNum[][len], int cubeNum[][len], int x, int y, int &amp;flag){ //å›æº¯å‰ªæ // if(x == 8) // print(board, x, y); if(x == 9){ flag = 1; return; } int nx, ny; if(board[x][y] == '.'){ for(int i = 0; i &lt; len; i++){ int cube = (x / 3 * 3 + y / 3); if(!rowNum[x][i] &amp;&amp; !colNum[y][i] &amp;&amp; !cubeNum[cube][i]){ board[x][y] = i + 1 + '0'; rowNum[x][i] = 1; colNum[y][i] = 1; cubeNum[cube][i] = 1; changeXY(x, y, nx, ny); solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag); //å›æº¯å‰ªæ if(flag) return; board[x][y] = '.'; rowNum[x][i] = 0; colNum[y][i] = 0; cubeNum[cube][i] = 0; } } } else{ changeXY(x, y, nx, ny); solveSudokuCore(board, rowNum, colNum, cubeNum, nx, ny, flag); } } }; ä½è¿ç®—ç‰ˆæœ¬ class Solution { private: int line[9]; int column[9]; int block[3][3]; bool valid; vector&lt;pair&lt;int, int&gt;&gt; spaces; public: void flip(int i, int j, int digit) { line[i] ^= (1 &lt;&lt; digit); column[j] ^= (1 &lt;&lt; digit); block[i / 3][j / 3] ^= (1 &lt;&lt; digit); } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) { if (pos == spaces.size()) { valid = true; return; } auto [i, j] = spaces[pos]; int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) &amp; 0x1ff; for (; mask &amp;&amp; !valid; mask &amp;= (mask - 1)) { int digitMask = mask &amp; (-mask); int digit = __builtin_ctz(digitMask); flip(i, j, digit); board[i][j] = digit + '0' + 1; dfs(board, pos + 1); flip(i, j, digit); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { memset(line, 0, sizeof(line)); memset(column, 0, sizeof(column)); memset(block, 0, sizeof(block)); valid = false; for (int i = 0; i &lt; 9; ++i) { for (int j = 0; j &lt; 9; ++j) { if (board[i][j] == '.') { spaces.emplace_back(i, j); } else { int digit = board[i][j] - '0' - 1; flip(i, j, digit); } } } dfs(board, 0); } }; ä½è¿ç®—æŠ€å·§ï¼š â€‹ å–å‡ºæœ€ä½ä½çš„1ï¼Œå…¶ä»–ä½ä¸ºé›¶ï¼šx &amp; (-x) â€‹ æ¶ˆé™¤æœ€ä½ä½çš„1ï¼šx &amp; (x - 1 ) â€‹ å˜æ¢ç¬¬posä½ï¼šx ^ (1 &lt;&lt; pos) å¾—åˆ°æœ€ä½ä½1çš„åºæ•°ï¼ˆä½ä½é›¶çš„ä¸ªæ•°ï¼‰ï¼š__builtin_ctz(unsigned_int x) ä¼˜åŒ–class Solution { private: int line[9]; int column[9]; int block[3][3]; bool valid; vector&lt;pair&lt;int, int&gt;&gt; spaces; public: void flip(int i, int j, int digit) { line[i] ^= (1 &lt;&lt; digit); column[j] ^= (1 &lt;&lt; digit); block[i / 3][j / 3] ^= (1 &lt;&lt; digit); } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) { if (pos == spaces.size()) { valid = true; return; } auto [i, j] = spaces[pos]; int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) &amp; 0x1ff; for (; mask &amp;&amp; !valid; mask &amp;= (mask - 1)) { int digitMask = mask &amp; (-mask); int digit = __builtin_ctz(digitMask); flip(i, j, digit); board[i][j] = digit + '0' + 1; dfs(board, pos + 1); flip(i, j, digit); } } void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { memset(line, 0, sizeof(line)); memset(column, 0, sizeof(column)); memset(block, 0, sizeof(block)); valid = false; for (int i = 0; i &lt; 9; ++i) { for (int j = 0; j &lt; 9; ++j) { if (board[i][j] != '.') { int digit = board[i][j] - '0' - 1; flip(i, j, digit); } } } int len = 9; bool flag = true; while(flag){ flag = false; for(int i = 0; i &lt; len; i++){ for(int j = 0; j &lt; len; j++){ if(board[i][j] != '.') continue; int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) &amp; 0x1FF; if( !(mask &amp; (mask - 1))){ int digitnum = __builtin_ctz(mask &amp; (-mask)) ; flip(i, j, digitnum); board[i][j] = digitnum + '0' + 1; flag = true; } } } } for (int i = 0; i &lt; 9; ++i) { for (int j = 0; j &lt; 9; ++j) { if (board[i][j] == '.') { spaces.emplace_back(i, j); } } } dfs(board, 0); } };","link":"/2020/09/17/shua-ti-sou-suo-hui-su-37-jie-shu-du/"},{"title":"39. Combination Sum","text":"39. Combination Sum åœ¨dfsæœç´¢é¢˜ä¸­ï¼Œå½¢è±¡åŒ–ä¸€ä¸ªdfsæœç´¢æ ‘æ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£çš„ï¼Œå½¢è±¡çš„æè¿°æ–¹æ³•ã€‚æ¯”å¦‚ä¸‹é¢è¿™ä¸ªæ²¡æœ‰å‰ªæçš„dfsæœç´¢æ ‘ã€‚ä¹Ÿå¯ä»¥æ¯”è¾ƒä¸€ä¸‹ï¼Œä¸‹é¢ä¸¤ç§è§£æ³•çš„dfsæœç´¢æ ‘çš„ä¸åŒä¹‹å¤„ã€‚ æ€è·¯ï¼šdfsæœç´¢å‰ªæä»£ç ã€‚éå¸¸æ ‡å‡†çš„ä¸€é“æœç´¢é¢˜ã€‚ å®˜æ–¹ç»™å‡ºçš„æ—¶é—´å¤æ‚åº¦åˆ†æ ä»£ç ï¼š66% class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); //sortä¼˜åŒ–é¡ºåº 33%-&gt;47% vector&lt;int&gt; aim; dfsCombinate(candidates, aim, target, 0); return res; } void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos){ if(pos == candidates.size()) return; if(target &lt;=0){ if(target == 0){ res.push_back(aim); } return; } aim.push_back(candidates[pos]); dfsCombinate(candidates, aim, target - candidates[pos], pos); aim.pop_back(); dfsCombinate(candidates, aim, target, pos + 1); } }; 99% class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); //sortä¼˜åŒ–é¡ºåº 33%-&gt;47% vector&lt;int&gt; aim; dfsCombinate(candidates, aim, target, 0); return res; } void dfsCombinate(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt;&amp; aim, int target, int pos){ if(target == 0){ res.push_back(aim); return; } for(int i = pos;i &lt; candidates.size(); ++i){ //forå¾ªç¯ä»£æ›¿é€’å½’å¯»æ‰¾ï¼Œå‡å°‘å‡½æ•°è°ƒç”¨ï¼Œå¢åŠ æ•ˆç‡ if(candidates[i] &gt; target) break; if(i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) continue; // é‡å¤æ•°å­—æ— éœ€å†åˆ¤æ–­ aim.push_back(candidates[i]); dfsCombinate(candidates, aim, target - candidates[i],i); aim.pop_back(); } } };","link":"/2020/12/04/shua-ti-sou-suo-hui-su-39-combination-sum/"},{"title":"40. Combination Sum II","text":"40. Combination Sum IIæ€è·¯ï¼š ç”¨mapè®°å½•æ•°å­—å‡ºç°æ¬¡æ•°ï¼Œè½¬åŒ–ä¸ºæ™®é€šçš„dfs é¿å…åœ¨å¡«å……idxæ•°å­—çš„æ—¶å€™ï¼Œéå†åˆ°é‡å¤æ•°å­—ï¼Œå³å¯ã€‚æ— éœ€mapè®°å½•æ•°å­—ã€‚æ˜¯ä¸€ç§æˆç†Ÿçš„é¿å…é‡å¤æ•°å­—çš„æ–¹æ³•ã€‚ ä»£ç ï¼š40% class Solution { public: unordered_map&lt;int, int&gt; ct; vector&lt;int&gt; arr; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); for(auto i : candidates){ ct[i]++; if(ct[i] == 1) arr.push_back(i); } vector&lt;int&gt; aim; dfs(aim, 0, target); return res; } void dfs(vector&lt;int&gt; &amp;aim, int pos, int target){ if(target == 0){ res.push_back(aim); return; } for(int i = pos; i &lt; arr.size(); ++i){ if(arr[i] &gt; target) break; if(ct[arr[i]] == 0) continue; //ct[arr[i]]å¿…è¡Œå­˜åœ¨ aim.push_back(arr[i]); ct[arr[i]]--; dfs(aim, i, target - arr[i]); ct[arr[i]]++; aim.pop_back(); } } }; 98% class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { sort(candidates.begin(), candidates.end(), less&lt;int&gt;()); vector&lt;int&gt; aim; dfs(candidates,aim, 0, target); return res; } void dfs(vector&lt;int&gt;&amp; candidates, vector&lt;int&gt; &amp;aim, int pos, int target){ // for(auto i : aim){ // cout &lt;&lt; i &lt;&lt; ' ' ; // } // cout &lt;&lt; endl; if(target == 0){ res.push_back(aim); return; } for(int i = pos; i &lt; candidates.size() &amp;&amp; candidates[i] &lt;= target; ++i){ //åœ¨ä¸€å±‚çš„æœç´¢ä¸­é€‰æ‹©ä¸é‡å¤çš„æ•°å­—ï¼ŒåŒæ—¶å·§å¦™çš„ç»´æŒäº†å¯æœç´¢ä¸Šä¸€å±‚æ•°å­—çš„çŠ¶æ€ if(i &gt; 0 &amp;&amp; i &gt; pos &amp;&amp; candidates[i] == candidates[i - 1]) continue; aim.push_back(candidates[i]); dfs(candidates, aim, i + 1, target - candidates[i]); aim.pop_back(); } } };","link":"/2020/12/04/shua-ti-sou-suo-hui-su-40-combination-sum-ii/"},{"title":"46. Permutations","text":"46. Permutations2æ€è·¯ï¼šå›æº¯æ³•ç¡®å®šå…¨æ’åˆ—ã€‚å¤æ‚åº¦$o(n*n!)$ï¼Œï¼ˆå¤åˆ¶ * permuteè°ƒç”¨æ¬¡æ•°ï¼‰ã€‚ ä»£ç ï¼šclass Solution { public: void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;res, int pos){ int n = nums.size(); if(n - 1 &lt; pos){ res.push_back(nums); return; } for(int i = pos; i &lt; n; ++i){ swap(nums[pos], nums[i]); permuteCore(nums, res, pos + 1); swap(nums[pos], nums[i]); } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; permuteCore(nums, res, 0); return res; } };","link":"/2020/11/24/shua-ti-sou-suo-hui-su-46-permutations/"},{"title":"47. Permutations II","text":"47. Permutations II2æ€è·¯ï¼šä¿è¯idxä½çš„å…ƒç´ ä¸é‡å¤å³å¯ã€‚ å¯ä»¥ç”¨setå»é‡nums[idx] ç”¨setå»é‡res ä»£ç ï¼š66% class Solution { public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; permute; permuteUniqueCore(permute, nums, 0); return permute; } void permuteUniqueCore(vector&lt;vector&lt;int&gt;&gt; &amp;permute, vector&lt;int&gt;&amp;nums, int pos){ if(nums.size() == 0 ) return; if(pos == nums.size() - 1){ permute.push_back(nums); return; } // setæ— è„‘å»é‡ï¼Œç©ºé—´æœ‰ç‚¹å¤§ unordered_set&lt;int&gt; vis; for(int i = pos; i &lt; nums.size(); ++i){ if(pos != i &amp;&amp; vis.count(nums[i])) continue; vis.insert(nums[i]); swap(nums[pos], nums[i]); permuteUniqueCore(permute, nums, pos + 1); swap(nums[pos], nums[i]); } } }; 88% class Solution { public: vector&lt;int&gt; temp;vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); vector&lt;int&gt; vis(nums.size()); permuteCore(nums, vis, 0); return res; } void permuteCore(vector&lt;int&gt;&amp;nums, vector&lt;int&gt; &amp;vis, int pos){ if(pos == nums.size()){ res.push_back(temp); return; } for(int i = 0; i &lt; nums.size(); i++){ if(vis[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i -1] &amp;&amp; !vis[i - 1])) continue; vis[i] = 1; temp.push_back(nums[i]); permuteCore(nums, vis, pos + 1); temp.pop_back(); vis[i] = 0; } } };","link":"/2020/12/03/shua-ti-sou-suo-hui-su-47-permutations-ii/"},{"title":"51. N-Queens","text":"51. N-Queensæ€è·¯:å…«çš‡åé—®é¢˜ï¼Œç»å…¸é—®é¢˜ã€‚å›æº¯è§£å†³ã€‚ ä»£ç ï¼šclass Solution { public: void generate(vector&lt;vector&lt;string&gt;&gt; &amp;outs, vector&lt;int&gt; &amp;chess, vector&lt;int&gt; &amp;hashorpos, int depth, int n){ if(n == depth){ vector&lt;string&gt; res(n, string(n, '.')); for(int i = 0; i &lt; n; ++i){ res[i].replace(chess[i], 1, &quot;Q&quot;); // cout &lt;&lt; chess[i] &lt;&lt; ' ' ; } // cout &lt;&lt; endl; outs.emplace_back(res); return; } for(int i = 0; i &lt; n; ++i){ int flag = 1; if(!hashorpos[i]){ #è¿™éƒ¨åˆ†åˆ¤æ–­ä»£ç å¯ä»¥ä¼˜åŒ–ï¼Œä½†æ˜¯å¾ˆéº»çƒ¦ï¼Œå¯ä»¥ç”¨hasverposä»£è¡¨ä¸€å±‚ä¸­è¢«ç¦æ­¢çš„ä½ç½®,éœ€è¦æ ‡è®°å·¦å³æ–¹å‘ï¼Œå¾ˆéº»çƒ¦ã€‚è€ƒè™‘åˆ°nçš„æ•°é‡ç›´æ¥éå†å°±è¡Œï¼Œå¯ä»¥å½“åšä¸€ä¸ªä¸å˜é‡ã€‚ for(int j = 1; j &lt;= depth ; ++j){ if(chess[depth - j] == i - j || chess[depth - j] == i + j){ flag = 0; break; } } if(!flag) continue; chess[depth] = i; hashorpos[i] = 1; generate(outs, chess, hashorpos, depth + 1, n); chess[depth] = -1; hashorpos[i] = 0; } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;vector&lt;string&gt;&gt; outs; vector&lt;int&gt; chess(n, -1), hashorpos(n, 0); generate(outs, chess, hashorpos, 0, n); return outs; } };","link":"/2020/11/27/shua-ti-sou-suo-hui-su-51-n-queens/"},{"title":"77. Combinations","text":"77. Combinationsæ€è·¯ï¼šå›æº¯ï¼Œè·å–æ­é…æ•°ç»„ï¼Œ $s &lt;= n - k + 1$ ä»£ç : class Solution { public: void getKnumber(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt; &amp;addt, int n, int k, int s){ if(addt.size() == k){ ans.push_back(addt); return; } if(s &gt; n) return; for(int i = s; i &lt;= n - k + addt.size() + 1; ++i){ addt.push_back(i); getKnumber(ans, addt, n, k, i + 1); addt.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; addt; getKnumber(res, addt, n, k, 1); return res; } };","link":"/2020/11/25/shua-ti-sou-suo-hui-su-77-combinations/"},{"title":"é¢è¯•é¢˜-å›æº¯DFs","text":"æ”¶é›†å›æº¯ç›¸å…³é¢˜ç›® é¢13 é¢12å’Œ13å¾ˆç›¸ä¼¼ï¼Œä¸é‡å¤å†™äº†ã€‚ é¢˜é¢ï¼šåœ¨ä¸€ä¸ªå­—ç¬¦çŸ©é˜µä¸­å¯»æ‰¾ä¸€æ¡è·¯å¾„ï¼Œè·¯å¾„ä¸Šçš„å­—ç¬¦ä»å¤´åˆ°å°¾æ’åˆ—èµ·æ¥æ˜¯ç»™å®šçš„å­—ç¬¦ä¸²sã€‚åˆ¤æ–­æœ‰æ— è¿™ä¹ˆä¸€æ¡è·¯å¾„ã€‚ æ€è·¯ï¼šDFSæˆ–è€…è¯´å’Œå›æœ”ç›´æ¥æš´åŠ›æœã€‚ ä»£ç ï¼šbool hasPathCore(char *matrix, int rows, int cols, int row, int col, char *str, int strIdx, int &amp;isFound){ if(strIdx &lt; 0){ isFound = 1; return true; } if(isFound) return true; visited[row * cols + col] = 1; int dX[] = {0, 0, -1, 1}, dY[] = {-1, 1, 0, 0}; for(int i = 0; i &lt; 4; ++i){ int nX = dX[i] + row, nY = dY[i] + col, p = row * cols + col; if( nX &gt;= 0 &amp;&amp; nY &gt;= 0 &amp;&amp; nX &lt; rows &amp;&amp; nY &lt; cols &amp;&amp; !visited[p] &amp;&amp; str[strIdx] == matrix[p]) hashPathCore(matrix, rows, cols, row, col, str, strIdx - 1); } } bool hasPath(char *matrix, int rows, int cols, char *str, int length){ if(str == nullptr || matrix == nullptr) throw new std::exception(&quot;Invalid parameters.&quot;); int visited = new int[rows * cols], isFound = 0; memset(visited, 0, sizeof(visited)); for(int i = 0; i &lt; rows; ++i) for(int j = 0; j &lt; cols; ++j) if( hasPathCore(matrix, rows, cols, i, j, str, length - 1, isFound)){//å€’ç€æœ del[] visited; return true; } }","link":"/2020/08/07/shua-ti-sou-suo-hui-su-mian-shi-ti-hui-su-dfs/"},{"title":"1340. Jump Game V","text":"è¿™ä¸ªé¢˜ç›®è¿˜æ˜¯è›®å…¥é—¨çš„â€¦â€¦ æ€è·¯ï¼šè¿™é¢˜å¦‚æœé‡‡ç”¨DPçš„æ€æƒ³å»åšï¼Œå¾ˆéš¾ã€‚ç¬¬ä¸€ï¼Œå¦‚æœè®¾$dp[t][i]$ä¸ºç¬¬iä¸ªæ•°å­—ä¸ºç»ˆç‚¹,æœ€å¤šç§»åŠ¨tæ­¥çš„æƒ…å†µä¸‹æœ€å¤§ç»è¿‡çš„æ•°å­—ä¸ªæ•°ï¼Œé‚£ä¹ˆDPè½¬ç§»æ–¹ç¨‹å°±æ¶‰åŠåˆ°æœç´¢ä¸Šä¸€å±‚åˆç†æ•°å­—ï¼Œå¤æ‚åº¦å¤§å¢ï¼ˆç¦»çº¿å¯è®¡ç®—ï¼Œä½†æ˜¯è¿˜æ˜¯ä¸å¿«ï¼‰ã€‚ åé¢ç»™çš„ç¬¬äºŒç§ç®—æ³•å°±æ˜¯è¯¥ç‰ˆæœ¬ã€‚ ç¬¬äºŒï¼Œå¦‚æœ$dp[t][i]$ä¸ºç¬¬iä¸ªæ•°å­—ä¸ºèµ·ç‚¹,æœ€å¤šèµ°tæ­¥çš„æœ€å¤§ç»è¿‡çš„æ•°å­—ä¸ªæ•°ï¼Œè™½ç„¶ç”±äºé¡ºç€é¢˜ç›®çš„æ„æ€ï¼Œç›¸æ¯”ä¸Šä¸€ç§æ–¹æ³•å‡å°‘äº†æœç´¢ä¸Šä¸€å±‚çš„åˆç†æ•°å­—ï¼Œä½†è¿˜æ˜¯ä¸å¤Ÿå¿«ã€‚å¯ä»¥ä»DPç‰ˆæœ¬1ä¸­çœ‹å‡ºæ¥ï¼Œè®¸å¤šçŠ¶æ€è½¬ç§»çš„è®¡ç®—éƒ½æ˜¯æ— è°“çš„ã€‚æ—¶é—´å¤æ‚åº¦ä¸º$O(N^2D)$ï¼Œå³ä½¿æœ‰ä¸€ç‚¹ç‚¹å‰ªæä¹Ÿæ²¡æ³•ACã€‚ ç¬¬ä¸‰ï¼Œé€šè¿‡è®°å¿†åŒ–æœç´¢çš„æ–¹æ³•ï¼Œå¯ä»¥å¤§å¹…å‡å°‘é‡å¤è®¡ç®—ã€‚ ä»£ç ï¼šclass Solution { public: // f[i]:ä»iå¼€å§‹æœ€å¤šå¯ä»¥visitçš„æ•°å­— vector&lt;int&gt; f; void dfs(vector&lt;int&gt; &amp;arr, int id, int d, int n){ if(f[id] != -1) return; f[id] = 1; for(int i = id + 1; i &lt; id + d + 1 &amp;&amp; i &lt; n &amp;&amp; arr[id] &gt; arr[i]; i++){ dfs(arr, i, d, n); f[id] = max(f[id], f[i] + 1); } for(int i = id - 1; i &gt; id - d - 1 &amp;&amp; i &gt;= 0 &amp;&amp; arr[id] &gt; arr[i]; i--){ dfs(arr, i, d, n); f[id] = max(f[id], f[i] + 1); } } int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int len = arr.size(); f.resize(len, -1); for(int i = 0;i &lt; len; i++){ dfs(arr, i, d ,len); } return *max_element(f.begin(), f.end()); } }; DPç‰ˆæœ¬1ï¼š class Solution { public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int len = arr.size(); vector&lt;int&gt; dp[2]; dp[0].resize(len, 1); dp[1].resize(len, 0); int maxstep = 0, flag = 1; int newl = 0, oldl = 1; while(flag){ flag = 0; swap(newl, oldl); for(int i = 0; i &lt; len; i++){ for(int j = i + 1; j &lt; d + i + 1 &amp;&amp; j &lt; len &amp;&amp; arr[j] &lt; arr[i]; ++j){ int newv = dp[oldl][j] + 1; if(newv &gt; dp[newl][i]){ dp[newl][i] = newv; flag = 1; } } for(int j = i - 1; j &gt; i - d - 1 &amp;&amp; j &gt;= 0 &amp;&amp; arr[j] &lt; arr[i]; --j){ int newv = dp[oldl][j] + 1; if(newv &gt; dp[newl][i]){ dp[newl][i] = newv; flag = 1; } } } } int v = -1; // for(int i = 0; i &lt; len; ++i) // v = max(v, dp[newl][i]); for(int i = 0; i &lt; len; ++i) v = max(v, dp[oldl][i]); return v; } }; DPç‰ˆæœ¬2ï¼š class Solution { public: int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int len = arr.size(); vector&lt;vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(len, 0)); vector&lt;vector&lt;int&gt; &gt; bigger(len,vector&lt;int&gt;(0,0)); vector&lt;int&gt; ischanged(len, 1); for(int i = 0;i &lt; len; i++){ int low = max(0, i - d); int high = min(len - 1, i + d); for(int j = i - 1; j &gt;= low; j--) if(arr[i] &gt; arr[j]) bigger[j].push_back(i); else break; for(int j = i + 1; j &lt;= high; j++) if(arr[i] &gt; arr[j]) bigger[j].push_back(i); else break; } int maxstep = 0, flag = 1; int newl = 0, oldl = 1; while(flag){ flag = 0; swap(newl, oldl); for(int i = 0; i &lt; len; i++){ if(ischanged[i] == 0) continue; ischanged[i] = 0; for(int j = 0; j &lt; bigger[i].size(); j++){ int newv = dp[oldl][bigger[i][j]] + 1; if(newv &gt; dp[newl][i]){ dp[newl][i] = newv; flag = 1; ischanged[i] = 1; } // dp[newl][i] = max(dp[newl][i], dp[oldl][bigger[i][j]] + 1); } maxstep = max(dp[newl][i], maxstep); } } return maxstep + 1; } };","link":"/2020/10/05/shua-ti-sou-suo-ji-yi-hua-sou-suo-1340-jump-game-v/"},{"title":"135. Candy","text":"è¿™é¢˜è¿˜è¡Œå§ï¼Œä¸€èˆ¬ä¸€èˆ¬ã€‚ 135. Candyæ€è·¯ï¼šç®€å•æ€è·¯ï¼šè®°å¿†åŒ–æœç´¢candy[i]ã€‚ æ›´æœ‰æŠ€å·§æ€§ï¼šä»å·¦åˆ°å³éå†æ›´æ–°candy[i],å†ä»å³åˆ°å·¦éå†æ›´æ–°candy. æ›´å¤§çš„è„‘æ´ï¼šæŒ‰å³°å€¼å’Œè°·å€¼è®¡ç®—æœºæ€»å€¼ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; candys; int len; int getcandys(int pos, vector&lt;int&gt;&amp; ratings){ if(candys[pos] == -1){ if(pos == 0 &amp;&amp; ratings[pos] &gt; ratings[pos + 1]) candys[pos] = getcandys(pos + 1, ratings) + 1; else if(pos == len - 1 &amp;&amp; ratings[pos] &gt; ratings[pos - 1]) candys[pos] = getcandys(pos - 1, ratings) + 1; else if(pos &lt; len - 1 &amp;&amp; pos &gt; 0 &amp;&amp; ratings[pos] &gt; min(ratings[pos -1], ratings[pos + 1])){ if(ratings[pos] &gt; ratings[pos - 1]) candys[pos] = getcandys(pos - 1, ratings) + 1; if(ratings[pos] &gt; ratings[pos + 1]) candys[pos] = max(getcandys(pos + 1, ratings) + 1, candys[pos]); } else candys[pos] = 1; } cout &lt;&lt; pos &lt;&lt; candys[pos] &lt;&lt; endl; return candys[pos]; } int candy(vector&lt;int&gt;&amp; ratings) { len = ratings.size(); candys.resize(len, -1); int res = 0; if(len &gt; 1) for(int i = 0;i &lt; len; i++){ res += getcandys(i, ratings); } else return 1; return res; } };","link":"/2020/10/10/shua-ti-sou-suo-ji-yi-hua-sou-suo-135-candy/"},{"title":"1. Two Sum","text":"1. Two Sumæ€è·¯ï¼šhashå³å¯ ç»ƒä¹ ä¸€ä¸‹ STLã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_set&lt;int&gt; sset; map&lt;int, int&gt; ridx; for(int i = 0; i &lt; nums.size(); ++i){ int k = nums[i]; if(sset.count(target - k)){ return {ridx[target - k], i}; } sset.insert(k); ridx[k] = i; } return {0 , 0}; } }; ç›´æ¥ç”¨mapæ›´å¥½ class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { map&lt;int, int&gt; ridx; for(int i = 0; i &lt; nums.size(); ++i){ int k = nums[i]; if(ridx.count(target - k)){ return {ridx[target - k], i}; } ridx[k] = i; } return {0 , 0}; } };","link":"/2021/01/25/shua-ti-shu-ju-jie-gou-set-1-two-sum/"},{"title":"128. Longest Consecutive Sequence","text":"128. Longest Consecutive Sequenceæ€è·¯ï¼š sortæ’åº ç”¨setå»é‡ï¼Œåœ¨åºåˆ—çš„ç¬¬ä¸€ä¸ªæ•°å­—ä¸Šæœç´¢è¿ç»­æ•°å­—é•¿åº¦å€¼ï¼ ä»£ç ï¼šsort class Solution { public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; sort(nums.begin(), nums.end()); int mlen = 1, len = 1; for(int i = 1; i &lt; nums.size(); ++i){ if(nums[i] == nums[i - 1] + 1){ len++; }else if(nums[i] != nums[i - 1]) len = 1; mlen = max(mlen, len); } return mlen; } }; setä¼˜åŒ– class Solution { public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { if(nums.size() == 0) return 0; int mlen = 1; unordered_set&lt;int&gt; sset; for(auto &amp;v : nums) sset.insert(v); for(auto &amp;v : sset){ if(sset.count(v - 1)) continue; // åªæœ‰è¿ç»­åºåˆ—çš„ç¬¬ä¸€ä¸ªæ•°æ‰èƒ½è®¡ç®—åç»­é•¿åº¦ int len = 1; while(sset.count(len + v)){ len++; } mlen = max(mlen, len); // cout &lt;&lt; v &lt;&lt; ' ' &lt;&lt; len; // unordered_set éå†çš„æ•°å­—ä¸æ˜¯æœ‰åºçš„ } return mlen; } };","link":"/2021/01/25/shua-ti-shu-ju-jie-gou-set-128-longest-consecutive-sequence/"},{"title":"23. Merge k Sorted Lists","text":"23. Merge k Sorted Listsæ€è·¯ï¼šä¼˜å…ˆé˜Ÿåˆ—æ’nodeå°±è¡Œã€‚ ä»£ç ï¼š/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { class Node{ public: ListNode *p; Node(ListNode *_p): p(_p){} friend bool operator &lt; (Node p1, Node p2){ return p1.p-&gt;val &gt; p2.p-&gt;val; } // friend bool operator &lt; (string s1, string s2){ // return s1.name &lt; s2.name; // } }; priority_queue&lt;Node&gt; pq; public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { for(auto &amp;p : lists) if(p) pq.push(Node(p)); ListNode *root , *p, *oldp; p = nullptr; oldp = root = new ListNode(); while(pq.size()){ p = pq.top().p; pq.pop(); if(p-&gt;next) pq.push(Node(p-&gt;next)); oldp-&gt;next = p; oldp = p; } return root-&gt;next; } };","link":"/2021/01/24/shua-ti-shu-ju-jie-gou-you-xian-dui-lie-23-merge-k-sorted-lists/"},{"title":"149. Max Points on a Line","text":"149. Max Points on a Lineæ€è·¯ï¼šæ€è·¯å·®ä¸å¤šï¼Œä½†æ˜¯èµ°æ­ªäº†ã€‚å®³~ æ•´ä½“æ€è·¯æ˜¯ä¸¤å±‚åµŒå¥—çš„forå¾ªç¯ã€‚ä¸¤ç‚¹å¯ä»¥ç¡®å®šä¸€æ¡ç›´çº¿ï¼Œé‚£ä¹ˆé€‰æ‹©å›ºå®šä¸€ä¸ªç‚¹ï¼Œæ±‚å…¶ä»–ç‚¹ä¸å›ºå®šç‚¹çš„æ–œç‡ï¼Œå¦‚æœæ–œç‡ç›¸åŒï¼Œé‚£ä¹ˆæ–œç‡ç›¸åŒçš„ç‚¹åœ¨åŒä¸€æ¡ç›´çº¿ä¸Šã€‚åŒæ—¶è¦è€ƒè™‘ï¼Œæ–œç‡å¯èƒ½ä¸ºæ— ç©·å¤§ï¼Œä¹Ÿæœ‰å¯èƒ½ä¸¤ä¸ªç‚¹ä¸ºåŒä¸€ä¸ªç‚¹ã€‚é”®å€¼åº”è¯¥ä¸ºæ–œç‡ã€‚ é€šè¿‡dupè®°å½•è¿™ä¸€æ¬¡å†…å±‚å¾ªç¯ä¸­ä¸p1ç›¸åŒçš„ç‚¹ã€‚é€šè¿‡one_round_resç»Ÿè®¡æ¯ä¸€æ¬¡å†…å±‚forå¾ªç¯çš„ç»“æœã€‚å°†æ–œç‡æ— ç©·å¤§å®šä¹‰ä¸ºFLT_MAXã€‚ é”®å€¼keyä¸ºæ–œç‡ï¼Œå…¶æ•°æ®ç±»å‹é€‰æ‹©ä¸ºlong doubleå³å¯é€šè¿‡vector&lt;vector&lt;int&gt;&gt; points = { {0,0},{94911150,94911151},{94911151,94911152} };æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰ ä»£ç ï¼šclass Solution { public: int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if(points.size() == 0 ) return 0; int maxct = 1; for(int i = 0; i &lt; points.size(); ++i){ // è®°å½•ç»è¿‡ä¸€ä¸ªç‚¹æ‰€æœ‰ç›´çº¿ï¼Œå³ä½¿æ–œç‡ä¸ºæ— ç©·å¤§ // å› ä¸ºåªæœ‰ä¸€ä¸ªç‚¹ï¼Œæ— éœ€è®°å½•ç›´çº¿å…¬å¼ä¸­çš„x = c å’Œ x = k * y + b ä¸­çš„ c, b unordered_map&lt;long double, int&gt; record; int ct = 1; int depu = 0; for(int j = i + 1; j &lt; points.size(); ++j){ auto p1 = points[i]; auto p2 = points[j]; if(p1 == p2){ // é‡åˆç‚¹ ++depu; continue; } if(p1[0] &gt; p2[0]) swap(p1, p2); if(p2[0] == p1[0]){ ct = max(ct, ++record[DBL_MAX] + 1); }else{ long double k = (long double)(p2[1] - p1[1]) / (p2[0] - p1[0]); // double b = p2[1] - k * p2[0]; ct = max(ct, ++record[k] + 1); } } maxct = max(maxct, ct + depu); } return maxct; } };","link":"/2021/01/27/shua-ti/shu-ju-jie-gou/ha-xi/149-max-points-on-a-line/"},{"title":"210. Course Schedule II (Medium)","text":"210. Course Schedule IIæ€è·¯ï¼š dfs + åˆ¤ç¯ + å›æº¯ å…¥åº¦ ä»£ç ï¼šclass Solution { public: vector&lt;vector&lt;int&gt;&gt; map; stack&lt;int&gt; track; vector&lt;int&gt; vis; int flag = 0; vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { map.resize(numCourses); vis.resize(numCourses); for(auto e : prerequisites){ int u = e[0], v = e[1]; map[v].emplace_back(u); } for(int i = 0; i &lt; numCourses; ++i) if(!vis[i]) dfs(i); vector&lt;int&gt; ans; while(!track.empty()){ ans.emplace_back(track.top()); track.pop(); } if(flag) return {}; else return ans; } void dfs(int u){ vis[u] = -1; for(auto v : map[u]){ if(!vis[v]){ dfs(v); }else if(vis[v] == -1){ // å¦‚æœç¬¬ä¸€æ¬¡éå†åˆ°ä¸€ä¸ªç¯ï¼Œé‚£ä¹ˆè¿™ä¸ªç¯ä¸€å®šä¼šè¢«å…¨éƒ¨éå†åˆ° flag = 1; } } vis[u] = 1; track.push(u); } }; class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; indegrees; queue&lt;int&gt; que; int flag = 0; vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { map.resize(numCourses); indegrees.resize(numCourses); for(auto e : prerequisites){ int u = e[0], v = e[1]; map[v].emplace_back(u); ++indegrees[u]; } for(int i = 0; i &lt; numCourses; ++i) if(!indegrees[i]) que.push(i); vector&lt;int&gt; ans; while(!que.empty()){ int t = que.front(); ans.push_back(t); que.pop(); for(auto v : map[t]){ --indegrees[v]; if(indegrees[v] == 0) que.push(v); } } if(ans.size() != numCourses) return {}; else return ans; } };","link":"/2021/02/27/shua-ti-shu-ju-jie-gou-tu-210-course-schedule-ii-medium/"},{"title":"332. Reconstruct Itinerary","text":"332. Reconstruct Itineraryå›¾è®ºè¡¥å……çŸ¥è¯†ï¼š é€šè¿‡å›¾ä¸­æ‰€æœ‰è¾¹æ°å¥½ä¸€æ¬¡ä¸”è¡Œéæ‰€æœ‰é¡¶ç‚¹çš„é€šè·¯ç§°ä¸ºæ¬§æ‹‰é€šè·¯ã€‚ é€šè¿‡å›¾ä¸­æ‰€æœ‰è¾¹æ°å¥½ä¸€æ¬¡ä¸”è¡Œéæ‰€æœ‰é¡¶ç‚¹çš„å›è·¯ç§°ä¸ºæ¬§æ‹‰å›è·¯ã€‚ å…·æœ‰æ¬§æ‹‰å›è·¯çš„æ— å‘å›¾ç§°ä¸ºæ¬§æ‹‰å›¾ã€‚ å…·æœ‰æ¬§æ‹‰é€šè·¯ä½†ä¸å…·æœ‰æ¬§æ‹‰å›è·¯çš„æ— å‘å›¾ç§°ä¸ºåŠæ¬§æ‹‰å›¾ã€‚ å› ä¸ºæœ¬é¢˜ä¿è¯è‡³å°‘å­˜åœ¨ä¸€ç§åˆç†çš„è·¯å¾„ï¼Œä¹Ÿå°±å‘Šè¯‰äº†æˆ‘ä»¬ï¼Œè¿™å¼ å›¾æ˜¯ä¸€ä¸ªæ¬§æ‹‰å›¾æˆ–è€…åŠæ¬§æ‹‰å›¾ã€‚æˆ‘ä»¬åªéœ€è¦è¾“å‡ºè¿™æ¡æ¬§æ‹‰é€šè·¯çš„è·¯å¾„å³å¯ã€‚ å¦‚æœæ²¡æœ‰ä¿è¯è‡³å°‘å­˜åœ¨ä¸€ç§åˆç†çš„è·¯å¾„ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤åˆ«è¿™å¼ å›¾æ˜¯å¦æ˜¯æ¬§æ‹‰å›¾æˆ–è€…åŠæ¬§æ‹‰å›¾ï¼Œå…·ä½“åœ°ï¼š å¯¹äºæ— å‘å›¾ Gï¼ŒG æ˜¯æ¬§æ‹‰å›¾å½“ä¸”ä»…å½“ G æ˜¯è¿é€šçš„ä¸”æ²¡æœ‰å¥‡åº¦é¡¶ç‚¹ã€‚ å¯¹äºæ— å‘å›¾ Gï¼ŒG æ˜¯åŠæ¬§æ‹‰å›¾å½“ä¸”ä»…å½“ G æ˜¯è¿é€šçš„ä¸” G ä¸­æ°æœ‰ 2ä¸ªå¥‡åº¦é¡¶ç‚¹ã€‚ å¯¹äºæœ‰å‘å›¾ Gï¼ŒG æ˜¯æ¬§æ‹‰å›¾å½“ä¸”ä»…å½“ G çš„æ‰€æœ‰é¡¶ç‚¹å±äºåŒä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸”æ¯ä¸ªé¡¶ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦ç›¸åŒã€‚ å¯¹äºæœ‰å‘å›¾ Gï¼ŒG æ˜¯åŠæ¬§æ‹‰å›¾å½“ä¸”ä»…å½“ G çš„æ‰€æœ‰é¡¶ç‚¹å±äºåŒä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸” æ°æœ‰ä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦ä¸å…¥åº¦å·®ä¸º 1ï¼› æ°æœ‰ä¸€ä¸ªé¡¶ç‚¹çš„å…¥åº¦ä¸å‡ºåº¦å·®ä¸º 1ï¼› æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦ç›¸åŒã€‚ æ€è·¯ï¼šé¦–å…ˆï¼Œä»¥ç«™ç‚¹ä¸ºç‚¹ï¼Œticketsä¸ºå•å‘è¾¹ï¼Œå¯å»ºæœ‰å‘å›¾ã€‚ é¢˜ç›®ä¿è¯äº†æ¬§æ‹‰å›¾çš„å­˜åœ¨ï¼Œæˆ‘ä»¬éœ€è¦åœ¨å›¾ä¸Šå¯»æ‰¾ä¸€æ¡å­—æ¯åºæœ€å°çš„æ¬§æ‹‰é€šè·¯ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨Hierholzer ç®—æ³•æ±‚å‡ºè¯¥é€šè·¯ï¼Œå…¶ä¸­ä¼˜å…ˆéå†å­—æ¯åºæœ€å°çš„ç«™ç‚¹å³å¯ã€‚ Hierholzer ç®—æ³•ç®—æ³•æµç¨‹å¦‚ä¸‹ï¼š ä»æŸç‚¹å¼€å§‹å‡ºå‘ï¼Œéå†è¯¥å›¾ æ¯æ¬¡ç§»åŠ¨åï¼Œåˆ é™¤åˆšåˆšç»è¿‡çš„è¾¹ï¼ˆDFSï¼‰ å½“éå†è¯¥èŠ‚ç‚¹ç»“æŸåï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å…¶ä»–è·¯å¾„å¯èµ°ï¼ŒæŠŠèŠ‚ç‚¹è®°å½•ä¸‹æ¥ã€‚ å› ä¸ºæ¯æ¬¡è®°å½•çš„èŠ‚ç‚¹éƒ½æ˜¯å½“æ—¶éå†æ—¶æœ€åé€€å‡ºçš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥å¿…å®šæ¯”ä¹‹å‰å‹å…¥çš„èŠ‚ç‚¹åœ¨æ¬§æ‹‰å›¾å‰ï¼ŒåŒæ—¶ç”±äºåˆ è¾¹çš„æ€§è´¨å’Œèµ·ç‚¹æ˜¯æ¬§æ‹‰é€šè·¯çš„èµ·ç‚¹ï¼Œä¿è¯äº†è·¯å¾„çš„æœ‰æ•ˆæ€§ã€‚æ‰€ä»¥ä¸€å®šèƒ½æœåˆ°ã€‚ ä¸€å¼€å§‹æŠŠç¥¨å½“æˆç‚¹ï¼Œç›¸åŒçš„ç‚¹å½“æˆè¾¹ï¼ŒæŠŠç®€å•çš„æ¬§æ‹‰é—®é¢˜å˜æˆäº†å¤æ‚çš„æ—…è¡Œå•†é—®é¢˜ï¼Œæˆ‘å¹²ï¼ ä»£ç ï¼šclass Solution { public: map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;&gt; vec; vector&lt;string&gt; path; void dfs(string curr){ while(vec.count(curr) &amp;&amp; vec[curr].size()){ string tmp = vec[curr].top(); vec[curr].pop(); dfs(tmp); } path.emplace_back(curr); } vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) { for(auto &amp;item : tickets){ vec[item[0]].push(item[1]); } dfs(&quot;JFK&quot;); reverse(path.begin(), path.end()); return path; } };","link":"/2021/01/28/shua-ti-shu-ju-jie-gou-tu-332-reconstruct-itinerary/"},{"title":"785. Is Graph Bipartite?","text":"785. Is Graph Bipartite?æ€è·¯ï¼šäºŒåˆ†å›¾æŸ“è‰²é—®é¢˜ï¼Œå®é™…æ˜¯å°±æ˜¯åˆ¤æ–­ä»»æ„ä¸€æ¡è¾¹çš„å½¢å¼æ˜¯å¦æœ‰çŸ›ç›¾ã€‚ $O(E +N )$ ä»£ç ï¼šclass Solution { public: int flag = 0; vector&lt;int&gt; color; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); color.resize(n, 0); for(int i = 0;i &lt; n; ++i){ if(color[i] == 0) colorize(graph, i, 1); if(flag) return false; } return true; } void colorize(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u, int ctype){ if(color[u]){ if(color[u] * ctype == -1) flag = 1; return; } color[u] = ctype; for(auto v : graph[u]) colorize(graph, v, -ctype); } };","link":"/2021/02/24/shua-ti-shu-ju-jie-gou-tu-785-is-graph-bipartite/"},{"title":"847. è®¿é—®æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„","text":"847. è®¿é—®æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„æ€è·¯ï¼šæ—…è¡Œå•†é—®é¢˜~çœŸéš¾ï¼ DFSæœç´¢dfsæœç´¢å›æº¯è²Œä¼¼å¯è¡Œï¼Œä½†æ˜¯æ²¡æœ‰æ˜ç¡®çš„åœæ­¢æ¡ä»¶ BFSæœç´¢bfsæœç´¢çŠ¶æ€state(cover, head)å¯è¡Œã€‚å…¶ä¸­coverç”¨ä½çŠ¶æ€è¡¨ç¤ºæœç´¢è¿‡çš„èŠ‚ç‚¹çš„é›†åˆï¼Œheadè¡¨ç¤ºå½“å‰éå†çš„å¤´ç»“ç‚¹ã€‚æœç´¢çš„æ›´æ–°çš„new cover = cover | 1 &lt;&lt; newheadã€‚ ä»£ç å·§å¦™åœ¨äºç›´æ¥å­˜å‚¨èŠ‚ç‚¹ï¼Œè€Œéè·¯å¾„ï¼Œå‹ç¼©äº†æœç´¢èŒƒå›´ã€‚ å®è·µå‘ç°å¦‚æ­¤ç®€å•çš„æ€è·¯è¿˜æ˜¯ä¼šè¶…æ—¶ï¼ è€ƒè™‘ç”¨dist[cover][head]è®°å½•æœ€çŸ­è·¯çŠ¶æ€ï¼Œå‡å°‘æœç´¢èŒƒå›´ã€‚ DAGåŒ–DPè®¡ç®—åœ¨ä¸Šè¿°æ€è·¯çš„å‰æä¸‹ï¼Œdist[cover][head]åœ¨æ›´æ–°ä¹‹åæ€»æœ‰newcover&gt;=coverã€‚æŠŠdistå½“æˆä¸€ä¸ªå›¾ï¼Œè€Œè¿™ä¸ªå›¾ä¿è¯äº†DAGçš„æ€§è´¨æˆç«‹ï¼Œé‚£æˆ‘ä»¬å¯ä»¥ç”¨DPæ–¹æ³•è®¡ç®—æœ€çŸ­è·¯ã€‚åœ¨æ­£å‘éå†coveråˆ°1&lt;&lt;Nï¼Œéå†æ—¶å°è¯•ç”¨ä¸åŒçš„è¾¹è¿›è¡Œæ›´æ–°ã€‚ æ³¨æ„ï¼Œæ›´æ–°è®¡ç®—å¯èƒ½ä¼šæ›´æ–°åˆ°ç›¸åŒcoveré›†ï¼Œå³é‡å¤éå†äº†èŠ‚ç‚¹ï¼Œé‚£ä¹ˆéœ€è¦å†æ¬¡å°è¯•æ›´æ–°ï¼ å¤æ‚åº¦è¯´æ˜ä¸€å…±æœ‰$2^N*N$ç§çŠ¶æ€ï¼Œè€Œæ¯ç§çŠ¶æ€çš„æ›´æ–°æœ€å¤šNæ¬¡è®¡ç®—ã€‚æ‰€ä»¥å¤æ‚åº¦æ˜¯O(2^N*N^2) ä»£ç ï¼š class Solution { queue&lt;pair&lt;int, int&gt;&gt; que; // queue of statue and head. public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int times = 0;; int n = graph.size(), visall = (1 &lt;&lt; n) - 1; vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, n * n)); for(int i = 0; i &lt; n; ++i){ que.push({1 &lt;&lt; i, i}); dist[1 &lt;&lt; i][i] = 0; } while(que.size()){ auto [cover, head] = que.front(); que.pop(); int d = dist[cover][head]; if(cover == visall) return d; for(auto v : graph[head]){ int newcover = cover | 1 &lt;&lt; v; if(d + 1 &lt; dist[newcover][v]){ que.push({newcover, v}); dist[newcover][v] = d + 1; } } } return 0; } }; class Solution { vector&lt;int&gt; trace; vector&lt;int&gt; newtrace; map&lt;pair&lt;int, int&gt;, int&gt; linker; set&lt;int&gt; intarce; int n; public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { n = graph.size(); for(int i = 0; i &lt; n; ++i){ // cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; endl; dfs(graph, i); } return trace.size() - 1; } inline pair&lt;int, int&gt; minpair(int a, int b){ if(a &gt; b ) return {b, a}; return {a, b}; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int u){ newtrace.push_back(u); intarce.insert(u); // for(auto c : newtrace) cout &lt;&lt; c &lt;&lt; ' ' ; // cout &lt;&lt; endl; if(intarce.size() == n){ if(trace.size() == 0 || trace.size() &gt; newtrace.size()){ trace = newtrace; } }else{ for(auto v : graph[u]){ if(++linker[minpair(u, v)] &lt;= 4){ dfs(graph, v); } --linker[minpair(u, v)]; } } newtrace.erase(newtrace.end() - 1); intarce.erase(u); } }; DAG class Solution { queue&lt;pair&lt;int, int&gt;&gt; que; // queue of statue and head. public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int times = 0;; int n = graph.size(), visall = (1 &lt;&lt; n) - 1; const int maxlen = n * n; vector&lt;vector&lt;int&gt;&gt; dist(1&lt;&lt;n, vector&lt;int&gt;(n, maxlen)); for(int i = 0; i &lt; n; ++i){ dist[1 &lt;&lt; i][i] = 0; } for(int cover = 1; cover &lt;= visall; ++cover){ bool repeat = true; while(repeat){ repeat = false; for(int u = 0; u &lt; n; ++u){ if(dist[cover][u] == maxlen) continue; // jump over the states no exist. int d = dist[cover][u]; for(auto v : graph[u]){ int newcover = cover | (1 &lt;&lt; v); if(d + 1 &lt; dist[newcover][v]){ dist[newcover][v] = d + 1; if(newcover == cover) repeat = true; // if visited node set is the same as last set, just update again. } } } } } int minans = maxlen; for(auto c : dist[visall]) minans = min(minans, c); return minans; } };","link":"/2021/05/08/shua-ti-shu-ju-jie-gou-tu-847-fang-wen-suo-you-jie-dian-de-zui-duan-lu-jing/"},{"title":"882. Reachable Nodes In Subdivided Graph","text":"æ€è·¯ï¼šsubdivision nodeså¯ä»¥åŒ–ä¸ºè·¯å¾„çš„é•¿åº¦ï¼Œå°†æ­¤é—®é¢˜è½¬åŒ–ä¸ºå¯ä»¥ç”¨dijstraæ±‚è§£çš„é—®é¢˜ã€‚ æ¯æ¬¡éå†åˆ°æœ€æ–°æœ€çŸ­çš„èŠ‚ç‚¹éƒ½å¯ä»¥è¿›è¡Œæ±‚å‡ºæ­¤ç‚¹ç›¸è¿çš„è¾¹çš„å¯ä»¥ç´¯åŠ subdivistion nodesçš„ä¸ªæ•°ï¼Œä½†æ˜¯éœ€è¦æ§åˆ¶é‡å¤ç´¯åŠ æ¯”è¾ƒéº»çƒ¦ã€‚æœ€åé‡‡ç”¨è®°å½•ä¸‹æ¯æ¡è¾¹å¯åˆ°è¾¾çš„ç‚¹ï¼Œæœ€åç»Ÿä¸€ç´¯è®¡å³å¯ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; road; vector&lt;int&gt; vis, dis; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; map&lt;pair&lt;int, int&gt;, int&gt; used; // å…¶å®dijsktraç®—æ³•å¯¹äºæ˜¯å¯ä»¥åšåˆ°æ¯subdivision nodesåªæ›´æ–°ä¸€æ¬¡çš„ï¼Œä½†æ˜¯ä¸å¥½è®¡ç®—; int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { road.resize(n); vis.resize(n); dis.resize(n, INT_MAX); for(auto e : edges){ road[e[0]].emplace_back(e[1], e[2] + 1); road[e[1]].emplace_back(e[0], e[2] + 1); // node, subdivision nodes + 1 = distantce } pq.push({0, 0}); // distance, node; dis[0] = 0; int sumnode = 0; while(pq.size()){ auto [_, u] = pq.top(); pq.pop(); // cout &lt;&lt; u &lt;&lt; endl; if(vis[u]) continue; if(dis[u] &gt; maxMoves) break; vis[u] = 1; ++sumnode; for(auto [v, len] : road[u]){ if(dis[v] &gt; dis[u] + len){ dis[v] = dis[u] + len; pq.push({dis[v], v}); } used[{u, v}] = min(dis[u] + len, maxMoves) - dis[u]; } } for(auto edges : edges){ int u = edges[0], v = edges[1], len = edges[2]; sumnode += min(used[{u, v}] + used[{v, u}], len); } return sumnode; } };","link":"/2021/03/02/shua-ti-shu-ju-jie-gou-tu-882-reachable-nodes-in-subdivided-graph/"},{"title":"äºŒåˆ†å›¾åŒ¹é…","text":"äºŒåˆ†å›¾åŒ¹é…äºŒåˆ†å›¾åŒ¹é…æ˜¯ä¸ªç»å…¸é—®é¢˜â€”â€”ä¸¤ç»„èŠ‚ç‚¹åœ¨å›¾ä¸Šå°½å¯èƒ½çš„åŒ¹é…ã€‚ åŒˆç‰™åˆ©ç®—æ³•ä»¥ä¸æ–­å¯»æ‰¾å¢å…‰è·¯çš„æ–¹å¼ï¼Œå¯»æ‰¾æ›´å¤šçš„åŒ¹é…; æ€æƒ³å¦‚ä¸‹ï¼š ä»æœªåŒ¹é…çš„ç‚¹cå¼€å§‹å¯»æ‰¾é“¾æ¥çš„ç‚¹vï¼Œå¦‚æœvä¹Ÿæ˜¯æœªåŒ¹é…ï¼Œåˆ™åŒ¹é…æˆåŠŸã€‚å¦‚æœè¯¥ç‚¹å·²ç»åŒ¹é…äº†uï¼Œåˆ™é€’å½’å°è¯•è®©uåŒ¹é…å…¶ä»–èŠ‚ç‚¹ã€‚ å¦‚æœvåŒ¹é…å¤±è´¥ï¼Œé‚£å°±æ‰¾æ‰¾cçš„å…¶ä»–ç‚¹ã€‚ é¢˜è§£å‚è€ƒ æ¨¡æ¿å†™æ³•const int N=605; const int n=105; vector&lt;int&gt; g[N]; int from[N], tot=0; bool use[N]; bool match(int x){ for(int i=0; i&lt;g[x].size(); ++i) if(!use[g[x][i]]){ use[g[x][i]]=true; if(from[g[x][i]]==-1 || match(from[g[x][i]])){ from[g[x][i]]=x; return true; } } return false; } int hungary(){ tot=0; memset(from, -1, sizeof from); for(int i=1; i&lt;=n; ++i){ memset(use, 0x00, sizeof use); if(from[i] != -1 &amp;&amp; match(i)) ++tot; } return tot; } äºŒåˆ†å›¾æŸ“è‰²é—®é¢˜785. åˆ¤æ–­äºŒåˆ†å›¾æ€è·¯ï¼šç‚«é…·çš„lambdaå†™æ³•~ ä»£ç ï¼šclass Solution { public: int flag = 0; vector&lt;int&gt; color; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) { int n = graph.size(); int colors[n]; memset(colors, -1, sizeof colors); function&lt;bool(int, int)&gt; dfs = [&amp;](int node, int color) -&gt; bool { colors[node] = color; for(auto c : graph[node]){ if(colors[c] == -1 &amp;&amp; !dfs(c, 1 - color)) return false; if(colors[c] == color) return false; } return true; }; for(int i = 0; i &lt; n; ++i) if(colors[i] == -1 &amp;&amp; !dfs(i, 1)) return false; return true; } }; æ£‹ç›˜è¦†ç›–æ€è·¯ï¼šæ£‹ç›˜å°±æ˜¯ä¸ªæŠ½è±¡çš„å›¾ã€‚ äºŒåˆ†å›¾æ€è·¯åšä¸‹æ¥å°±è¡Œã€‚ ä»£ç ï¼š#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int N = 105; using PII = pair&lt;int,int&gt;; int n, m; bool maze[N][N]; PII match[N][N]; // ç›´æ¥å­˜å‚¨åŒ¹é…é‡ï¼Œæ¯”è¾ƒæ–¹ä¾¿~ bool vis[N][N]; int dx[] = {-1, 0, 0, 1}; //1 ä¸ 4 å¯¹åº” int dy[] = {0, 1, -1, 0}; // 2ä¸3 å¯¹åº” bool find(int x, int y){ // vis[x][y] = 1; for(int i = 0 ;i &lt; 4; ++i){ int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;&amp; nx &lt;= n &amp;&amp; ny &amp;&amp; ny &lt;= n &amp;&amp; !maze[nx][ny] &amp;&amp; !vis[nx][ny]){ // è®¿é—®æœ‰æ•ˆçš„ï¼Œä¸åœ¨è¯¥æ¬¡æ‰©å±•ä¸­è®¿é—®è¿‡çš„èŠ‚ç‚¹ vis[nx][ny] = 1; // è¯¥èŠ‚ç‚¹å·²ç»è®¿é—® auto t1 = match[nx][ny].first; auto t2 = match[nx][ny].second; if(t1 == -1 || find(t1, t2)){ // å¦‚æœè¯¥èŠ‚ç‚¹æœªåŒ¹é…æˆ–è€…è¯¥èŠ‚ç‚¹çš„åŒ¹é…è¢«æ›´æ–°äº† match[x][y] = {nx, ny}; match[nx][ny] = {x, y}; return true; } } } return false; } int main(){ int a, b; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); while(m--){ scanf(&quot;%d%d&quot;, &amp;a, &amp;b); maze[a][b] = 1; } memset(match, -1, sizeof match); int cnt = 0; for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= n; ++j){ // if((i+j)&amp;0x01 &amp;&amp; !maze[i][j]){ // ä¸ºä»€ä¹ˆä¸æ’é™¤å·²åŒ¹é…æˆåŠŸçš„èŠ‚ç‚¹ if(match[i][j].first != -1 &amp;&amp; !maze[i][j]){ // ä¸ºä»€ä¹ˆä¸æ’é™¤å·²åŒ¹é…æˆåŠŸçš„èŠ‚ç‚¹ memset(vis, 0x00, sizeof vis); if(find(i, j)) cnt++; } } } printf(&quot;%d&quot;, cnt); return 0; }","link":"/2021/05/09/shua-ti-shu-ju-jie-gou-tu-er-fen-tu-pi-pei/"},{"title":"å‰²ç‚¹ç®—æ³•","text":"å‰²ç‚¹ç®—æ³•Tarjanå‰²ç‚¹ç®—æ³• å¼•å…¥äº†å»ºç«‹åœ¨DFSç”Ÿæˆæ ‘çš„éå†èŠ‚ç‚¹çš„æ—¶é—´æˆ³æ¦‚å¿µï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹uçš„å­èŠ‚ç‚¹vå¯ä»¥æ‰¾åˆ°ä¸€æ¡ä¸ç»è¿‡uä»¥å¤–çš„è·¯å¾„åˆ°è¾¾uçš„ç¥–å…ˆï¼Œé‚£ä¹ˆæ˜¾ç„¶æœ‰ä¸€æ¡é€šè·¯å¯ä»¥å›åˆ°uçš„ç¥–å…ˆã€‚åä¹‹ï¼Œå¦‚æœå­˜åœ¨væ‰¾ä¸åˆ°è¿™ä¹ˆä¸€æ¡è·¯å¾„å›åˆ°uçš„ç¥–å…ˆï¼Œé‚£ä¹ˆæ˜¾ç„¶uæ˜¯ä¸€ä¸ªå‰²ç‚¹ï¼Œä»–åˆ†å‰²äº†væ‰€åœ¨çš„å­æ ‘å’Œå…¶ä»–å­æ ‘ï¼ˆå¦‚æœuä¸æ˜¯æ ¹çš„è¯ï¼ŒåŒ…æ‹¬ç¥–å…ˆæ‰€åœ¨å­æ ‘ï¼‰ã€‚ é‚£ä¹ˆä¸€ä¸ªå‰²ç‚¹æœ‰å¤šå°‘å­æ ‘å‘¢ï¼Ÿé¦–å…ˆï¼Œä¸€ä¸ªå‰²ç‚¹çš„å¯¹åº”çš„væ˜¯ç‹¬ç«‹åœ¨å„ä¸ªå­æ ‘çš„å—ï¼Ÿæ˜¯çš„ï¼Œå¦‚æœå­˜åœ¨v1å’Œv2éƒ½æ‰¾åˆ°è·¯å¾„ï¼Œä¸”åœ¨ä¸€ä¸ªå­æ ‘ä¸­ï¼Œé‚£ä¹ˆå¿…ç„¶æœ‰v1å¯ä»¥é€šè¿‡v2æ‰¾åˆ°uï¼Œé‚£ä¹ˆåœ¨DFSæœç´¢çš„æ—¶å€™ï¼Œå¿…å®šä¼šä¸€æ¬¡éå†v1å’Œv2ã€‚æ‰€ä»¥æ¯ä¸ªå‰²ç‚¹å¯¹åº”çš„å­æ ‘åªä¼šæœç´¢åˆ°ä¸€ä¸ªvã€‚æ‰©å±•ä¸€ä¸‹ï¼Œ é‚£ä¹ˆç»è¿‡å»æ‰å‰²ç‚¹çš„å›¾æœ€å¤šæœ‰å‡ ä¸ªè¿é€šå—ï¼Ÿ POJ 2117 Electricity å‚è€ƒè§£ç­” #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;cstring&gt; using namespace std; const int N = 10005; const int M = 30005; int tot; int to[M], nxt[M], head[M]; // graph é“¾å¼å‰å‘æ˜Ÿå­˜å‚¨æ–¹å¼ int dfn[N]; int low[N]; int ts; int n, m; int bp, cnt; int root; void add(int u, int v){ // connstruct graph; ++tot; to[tot] = v; nxt[tot] = head[u]; head[u] = tot; } void tarjan(int u){ // cout &lt;&lt; u &lt;&lt; ' '; int subtree = 0; dfn[u] = low[u] = ++ts; for(int i = head[u]; i; i = nxt[i]){ int v = to[i]; if(dfn[v]) low[u] = min(low[u], dfn[v]); else{ tarjan(v); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) ++subtree;; // èŠ‚ç‚¹uæ˜¯å‰²ç‚¹ï¼Œä¸”å‰²ç‚¹å¯¹åº”çš„å­èŠ‚ç‚¹væ˜¯åœ¨ä¸€ä¸ªè¢«åˆ†å‰²å­æ ‘ä¸­ } } if( u != root) ++subtree; bp = max(bp, subtree); } int main(){ while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m){ ts = tot = bp = cnt = 0; memset(head, 0x00, sizeof head); // to å’Œ edge ä¸éœ€è¦é‡ç½® memset(dfn, 0x00, sizeof dfn); memset(low, 0x00, sizeof low); int a ,b; while(m--){ scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); add(b, a); } for(root = 0; root &lt; n; ++root){ if(!dfn[root]){ tarjan(root); cnt++; } } printf(&quot;%d\\n&quot;, cnt + bp - 1); } return 0; } è¡¥å……çŸ¥è¯†ç‚¹ å‰å‘æ˜Ÿ é“¾å¼å‰å‘æ˜Ÿ å‰å‘æ˜Ÿä¸è¿‡æ˜¯æŠŠè¾¹æŒ‰å‡ºå‘ç‚¹æ’åºå¹¶é¡ºåºå­˜å‚¨ä¸‹æ¥ï¼Œ é€šè¿‡è®°å½•é¦–éƒ¨ä½ç½®æ¥éå†ï¼›é“¾å¼å‰å‘æ˜Ÿæ›´è¿›ä¸€æ­¥ï¼Œé€šè¿‡åœ¨å¤´éƒ¨ä½ç½®è®°å½•è¾¹çš„åœ°ç‚¹ï¼ŒåŒæ—¶ä»¥é™æ€æ–¹å¼å­˜å‚¨è¾¹ï¼Œåœ¨é™æ€è¾¹ä¸­å­˜å‚¨ä¸‹ä¸‹æ¡è¾¹çš„åœ°å€ã€‚ æœ€åè¿˜æœ‰å¸¸ç”¨çš„å¯¹æ‹ç¨‹åºï¼š #!/bin/sh g++ $1 -o ./a.out ./a.out &lt; input &gt; myoutput diff myoutput output -s -u","link":"/2021/05/09/shua-ti-shu-ju-jie-gou-tu-ge-dian-suan-fa/"},{"title":"347. Top K Frequent Elements","text":"æ€è·¯:mapè®°å½•å‡ºç°åˆæ¬¡ï¼Œ å †ç»´æŠ¤å‰Kå¤§ ä»£ç ï¼š class Solution { public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end()); map&lt;int, int&gt; counter; map&lt;int, int&gt;::iterator iter; priority_queue&lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int,int&gt; &gt; &gt; pq; for(auto i : nums) counter[i]++; iter = counter.begin(); pair&lt;int, int&gt; tp; int s1, s2, e1, e2; // cout &lt;&lt; counter.size() &lt;&lt; endl; while(iter != counter.end()){ s1 = iter-&gt;first; s2 = iter-&gt;second; if(pq.size() == k){ tp = pq.top(); e2 = tp.first; e1 = tp.second; if(e2 &lt; s2){ pq.pop(); pq.push(make_pair(s2, s1)); } }else pq.push(make_pair(s2, s1)); iter++; } vector&lt;int&gt; ans; while(pq.size() &gt; 0){ ans.push_back(pq.top().second); pq.pop(); } return ans; } };","link":"/2020/11/15/shua-ti-shu-ju-jie-gou-dui-347-top-k-frequent-elements/"},{"title":"380. Insert Delete GetRandom O(1)","text":"æ€è·¯ï¼šè¦æ±‚æ’å…¥ï¼Œåˆ é™¤ï¼Œéšæœºè·å–å…ƒç´ ç”¨$O(1)$ ä¸è¦æ±‚æ•°æ®æœ‰åºï¼Œä¹Ÿä¸è¦è¦æ±‚æ•°æ®æŒ‰åŸåºã€‚ hash + åŠ¨æ€æ•°ç»„å³å¯ã€‚ åˆ é™¤çš„æ—¶å€™ï¼Œäº¤æ¢å¾…åˆ é™¤å…ƒç´ åˆ°åŠ¨æ€æ•°ç»„æœ«å°±è¡Œäº†ã€‚ ä»£ç ï¼š class RandomizedSet { vector&lt;int&gt; arr; unordered_map&lt;int, int&gt; idx; public: /** Initialize your data structure here. */ RandomizedSet() { } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) { if(idx.count(val)){ return false; } arr.push_back(val); idx[val] = arr.size() - 1; return true; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) { if(!idx.count(val)) return false; int pos = idx[val]; idx[arr[arr.size() - 1]] = pos; swap(arr[pos], arr[arr.size() - 1]); arr.pop_back(); idx.erase(val); return true; } /** Get a random element from the set. */ int getRandom() { return arr[random() % arr.size()]; } }; /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj-&gt;insert(val); * bool param_2 = obj-&gt;remove(val); * int param_3 = obj-&gt;getRandom(); */","link":"/2021/03/03/shua-ti/shu-ju-jie-gou/fu-za-shu-ju-jie-gou/380-insert-delete-getrandom-o-1/"},{"title":"706. Design HashMap","text":"æ€è·¯æ€è·¯ï¼š hash table é…ç½® STLå¼ºå¤§çš„APIåŒ…è£…å®Œæˆäº†ã€‚ ä»£ç ï¼šclass MyHashMap { vector&lt;list&lt;pair&lt;int, int&gt;&gt;&gt; data; static const int base = 1931; static int hash(int key){ return key % base; } auto findit(int key, int pos){ auto iskey = [key](pair&lt;int, int&gt; item){return item.first == key;}; return find_if(data[pos].begin(), data[pos].end(), iskey); } public: /** Initialize your data structure here. */ MyHashMap() { data.resize(1931); // eraseä¸ä¼šæ£€æŸ¥å°¾æŒ‡é’ˆ // int key = 0, pos = 0; // auto it = findit(key, pos); // cout &lt;&lt; &quot;start&quot; &lt;&lt; key &lt;&lt; endl; // data[pos].erase(it); } /** value will always be non-negative. */ void put(int key, int value) { int pos = hash(key); auto it = findit(key, pos); if(it == data[pos].end()) data[pos].insert(it, {key, value}); else it-&gt;second = value; } /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) { int pos = hash(key); auto it = findit(key, pos); // cout &lt;&lt; &quot;find&quot; &lt;&lt; key &lt;&lt; endl; return it == data[pos].end() ? -1 : (*it).second; } /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) { int pos = hash(key); auto it = findit(key, pos); // cout &lt;&lt; &quot;remove&quot; &lt;&lt; key &lt;&lt; endl; if(it != data[pos].end()) data[pos].erase(it); } }; /** * Your MyHashMap object will be instantiated and called as such: * MyHashMap* obj = new MyHashMap(); * obj-&gt;put(key,value); * int param_2 = obj-&gt;get(key); * obj-&gt;remove(key); */","link":"/2021/03/15/shua-ti/shu-ju-jie-gou/fu-za-shu-ju-jie-gou/706-design-hashmap/"},{"title":"155. Min Stack","text":"155. Min Stackæ€è·¯ï¼šç”¨å¦ä¸€ä¸ªæ ˆä¿å­˜å¦ä¸€ä¸ªæ ˆçš„å„ä¸ªå…ƒç´ æ’å…¥ï¼Œåˆ é™¤åçš„æœ€å°å€¼ã€‚ ä»–åˆ©ç”¨è¿™ä¹ˆä¸€ä¸ªç°è±¡ï¼šåæ’å…¥çš„å¤§å…ƒç´ ä¸ä¼šå½±å“è¿™ä¸ªæ ˆçš„æœ€å°å€¼ï¼Œåä¹‹å°å…ƒç´ ä¼šæ”¹å˜ã€‚é‚£ä¹ˆåªè¦æŠŠæ­¤æ—¶å°å…ƒç´ æ’å…¥åˆ°æœ€å°æ ˆå³å¯ï¼ŒåŒç†åˆ é™¤å…ƒç´ çš„æ—¶å€™ä¹ŸæŒ‰å€¼åˆ é™¤ã€‚ ä»£ç ï¼šclass MinStack { stack&lt;int&gt; s1, mins; public: /** initialize your data structure here. */ MinStack() { } void push(int x) { s1.push(x); if(mins.empty() || mins.top() &gt;= x){ mins.push(x); } } void pop() { if(s1.size()){ int f = s1.top(); s1.pop(); if(mins.size() &amp;&amp; f == mins.top()){ mins.pop(); } } } int top() { return s1.top(); } int getMin() { return mins.top(); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */","link":"/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/155-min-stack/"},{"title":"20. Valid Parentheses","text":"20. Valid Parenthesesæ€è·¯ï¼šç”¨æ ˆåˆ¤æ–­å³å¯ã€‚ ä»£ç ï¼šclass Solution { stack&lt;char&gt; sta; public: bool isValid(string s) { for(auto c : s){ if(c == '(' || c == '[' || c == '{'){ sta.push(c); continue; } if(sta.size()){ char topc = sta.top(); switch(topc){ case '(' : if(c == ')') sta.pop(); else return false; break; case '[' : if(c == ']') sta.pop(); else return false; break; case '{' : if(c == '}') sta.pop(); else return false; break; } }else return false; } if(sta.empty()) return true; else return false; } }; mapç®€æ´å†™æ³• class Solution { stack&lt;char&gt; sta; public: bool isValid(string s) { map&lt;char, char&gt; pairs = { {'[',']'}, {'(', ')'}, {'{', '}'} }; for(auto c : s){ if(pairs.count(c)){ sta.push(c); } else{ if(sta.empty() || pairs[sta.top()] != c) return false; sta.pop(); } } return sta.empty(); } };","link":"/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/20-valid-parentheses/"},{"title":"225. Implement Stack using Queues","text":"225. Implement Stack using Queuesæ€è·¯ï¼šå…¶å®æˆ‘æƒ³åˆ°äº†ï¼Œä½†æ˜¯è¿™ä¸ªæ•ˆç‡çœŸçš„å·®ã€‚ ä»£ç ï¼šclass MyStack { queue&lt;int&gt; q1, q2; public: /** Initialize your data structure here. */ MyStack() { } /** Push element x onto stack. */ void push(int x) { q2.push(x); while(q1.size()){ q2.push(q1.front()); q1.pop(); } swap(q1 ,q2); } /** Removes the element on top of the stack and returns that element. */ int pop() { int temp = q1.front(); q1.pop(); return temp; } /** Get the top element. */ int top() { return q1.front(); } /** Returns whether the stack is empty. */ bool empty() { return q1.size() == 0; } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */","link":"/2021/01/30/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/225-implement-stack-using-queues/"},{"title":"232. Implement Queue using Stacks","text":"232. Implement Queue using Stacksæ€è·¯ï¼šä¸¤ä¸ªé˜Ÿåˆ—ä¸€ä¸ªå…¥é˜Ÿå…ƒç´ ï¼Œä¸€ä¸ªå‡ºé˜Ÿå…ƒç´ ã€‚ ä»£ç ï¼šclass MyQueue { stack&lt;int&gt; s1, s2; public: /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { s1.push(x); // cout &lt;&lt; x &lt;&lt; endl; } /** Removes the element from in front of queue and returns that element. */ int pop() { if(s2.size() == 0){ while(s1.size()){ s2.push(s1.top()); s1.pop(); } } if(s2.size() == 0) return -1; int t = s2.top(); s2.pop(); return t; } /** Get the front element. */ int peek() { if(s2.size() == 0){ while(s1.size()){ s2.push(s1.top()); s1.pop(); } } return s2.top(); } /** Returns whether the queue is empty. */ bool empty() { return s1.size() == 0 &amp;&amp; s2.size() == 0; } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */","link":"/2021/01/23/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/232-implement-queue-using-stacks/"},{"title":"239. Sliding Window Maximum","text":"239. Sliding Window Maximumæ€è·¯ï¼šæƒ³äº†ä¸‰ç§æ–¹æ³•ï¼š æœ´ç´ åœ°ç¡®è®¤æœ€å¤§å€¼æ˜¯å¦åœ¨çª—å£å†… ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤çª—å£ä¸­çš„æœ€å€¼ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„æœ€å€¼æ˜¯å¦è¿˜åœ¨çª—å£å†… ä½¿ç”¨å•è°ƒåŒå¤´é˜Ÿåˆ—ç»´æŠ¤çª—å£å†…çš„å•è°ƒé˜Ÿåˆ— æ–¹æ³•3çš„å•è°ƒé˜Ÿåˆ—å…¶å®å’Œå•è°ƒæ ˆçš„æ€§è´¨å¦‚å‡ºä¸€è¾™ï¼Œåªä¸è¿‡æ¢äº†ä¸ªé˜Ÿåˆ—çš„æ€§è´¨ã€‚ ä»£ç ï¼štle class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(k &gt; n) return vector&lt;int&gt;(); vector&lt;int&gt; ans(n - k + 1); auto p = max_element(nums.begin(), nums.begin() + k); ans[0] = *p; for(int i = 1; i &lt; n - k + 1; ++i){ if(nums[i - 1] == *p){ p = max_element(nums.begin() + i, nums.begin() + i + k); } if(*(nums.begin() + i + k - 1) &gt; *p) p = nums.begin() + i + k - 1; ans[i] = *p; } return ans; } }; ä¼˜å…ˆé˜Ÿåˆ— $o(nlogn)$ class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(k &gt; n) return vector&lt;int&gt;(); vector&lt;int&gt; ans(n - k + 1); priority_queue&lt;pair&lt;int, int&gt;&gt; pq; for(int i = 0; i &lt; k; ++i) pq.push({nums[i], i}); ans[0] = pq.top().first; for(int i = 1; i &lt; n - k + 1; ++i){ pq.push({nums[i + k - 1], i + k - 1}); auto [val, idx] = pq.top(); while(idx &lt; i){ pq.pop(); val = pq.top().first; idx = pq.top().second; } ans[i] = val; } return ans; } }; åŒå¤´å•è°ƒé˜Ÿåˆ—ï¼ class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if(k &gt; n) return vector&lt;int&gt;(); vector&lt;int&gt; ans(n - k + 1); deque&lt;int&gt; que; // å•è°ƒé€’å‡çš„é˜Ÿåˆ— for(int i = 0; i &lt; n; ++i){ if(i &gt;= k &amp;&amp; nums[i - k] == que.front()){ // ç‰¹å®šå…ƒç´ åˆ é™¤pop que.pop_front(); } int t = nums[i]; while(que.size() &amp;&amp; que.back() &lt; t){ // å¾ˆåƒå•è°ƒæ ˆçš„ç»´æŠ¤è¿‡ç¨‹ que.pop_back(); } que.push_back(t); if(i &gt;= k - 1) ans[i - k + 1] = que.front(); // è®°å½• } return ans; } };","link":"/2021/01/25/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/239-sliding-window-maximum/"},{"title":"32. Longest Valid Parentheses","text":"æ€è·¯ï¼šæ ˆéªŒè¯åŒ¹é…æ‹¬å·å¾ˆç®€å•ï¼Œä½†æ˜¯ç”¨å¦‚ä½•è·å–å¤šä¸ªåŒ¹é…æˆåŠŸçš„æ‹¬å·ç»„åˆé•¿åº¦å°±å¾ˆéº»çƒ¦ï¼ éš¾çš„æ˜¯æƒ³åˆ°ï¼Œè¿ç»­çš„æœ‰æ•ˆæ‹¬å·()())()()åªéœ€è¦è®°å½•ä¸€ä¸ªæœ€å…ˆæœªåŒ¹é…çš„ä½ç½®ã€‚å…·ä½“åšæ³•æ˜¯ï¼Œåœ¨æ ˆä¸­å­˜å‚¨ä¸€ä¸ªæœ€åæ²¡æœ‰åŒ¹é…åˆ°çš„å³æ‹¬å·ä¸‹æ ‡ã€‚ ä»£ç class Solution { public: int longestValidParentheses(string s) { int maxlen = 0; stack&lt;int&gt; st; st.push(-1); // å‹å…¥ä¸€ä¸ªæœ€åæœªåŒ¹é…çš„)ã€‚ for(int i = 0; i &lt; s.size(); ++i){ if(s[i] == ')'){ st.pop(); if(!st.empty()){ // åˆšåˆšçš„ï¼‰åŒ¹é…æˆåŠŸï¼Œå¯ä»¥è®¡ç®—æœ€é•¿åŒ¹é… maxlen = max(maxlen, i - st.top()); }else st.push(i); // è¯´æ˜è¯¥)æ²¡æœ‰åŒ¹é…åˆ°ï¼Œæ˜¯æ–°çš„æœ€åçš„æœ€å³æ‹¬å· }else st.push(i); } return maxlen; } };","link":"/2021/04/25/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/32-longest-valid-parentheses/"},{"title":"503. Next Greater Element II","text":"503. Next Greater Element IIæ€è·¯ï¼šå•è°ƒæ ˆï¼æ¯”è¾ƒæ›´å¤§å€¼çš„ç¥ã€‚ éå†æ•°ç»„ç»´æŠ¤å•è°ƒæ ˆï¼Œåœ¨æ’é™¤æ ˆä¸­æ›´å°çš„å…ƒç´ æ—¶ï¼Œå°±å·²ç»ä¸ºä»–ä»¬æ‰¾åˆ°äº†æ›´å¤§å€¼ã€‚ä¸ºäº†ä¿è¯æ•°ç»„æ˜¯ç¯å½¢æŸ¥æ‰¾çš„ï¼Œå¯ä»¥æ’å…¥ä¸¤æ¬¡æ•°ç»„å…ƒç´ ã€‚ ä»£ç ï¼šclass Solution { public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; bigger(n, -1); stack&lt;pair&lt;int, int&gt;&gt; sta; for(int i = 0; i &lt; 2; ++i){ for(int j = 0; j &lt; n; ++j){ while(sta.size() &amp;&amp; sta.top().second &lt;nums[j]){ auto [pos, num] = sta.top(); sta.pop(); if(bigger[pos] == -1 )bigger[pos] = nums[j]; } sta.push({j, nums[j]}); } } return bigger; } };","link":"/2021/01/30/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/503-next-greater-element-ii/"},{"title":"98. Validate Binary Search Tree","text":"98. Validate Binary Search Treeæ€è·¯ï¼šä¸è¦æŠŠäºŒå‰æ ‘çš„æ€§è´¨æé”™äº†ï¼Œæ˜¯ä»»ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼å¤§äºå…¶æ‰€æœ‰å·¦èŠ‚ç‚¹çš„å€¼ï¼Œå°äºç­‰äºæ‰€æœ‰å³èŠ‚ç‚¹çš„å€¼ï¼Œè€Œéå·¦èŠ‚ç‚¹ã€‚ å¦‚æ­¤ç›´æ¥éªŒè¯æ‰€æœ‰èŠ‚ç‚¹çš„æ˜¯å¦å¤§äºå·¦å­æ ‘çš„æœ€å¤§å€¼ï¼Œå°äºå³å­æ ‘çš„æœ€å°å€¼å³å¯ã€‚ ä»£ç /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ // class Solution { // public: // bool isValidBST(TreeNode* root) { // if(!root) return true; // bool flag = (root-&gt;right ? (root-&gt;val &lt; root-&gt;right-&gt;val) : true) // &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; root-&gt;left-&gt;val) : true); // return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left); // } // }; class Solution { public: inline TreeNode* minNode(TreeNode* root){ while(root-&gt;left) root = root-&gt;left; return root; } inline TreeNode* maxNode(TreeNode* root){ while(root-&gt;right) root = root-&gt;right; return root; } bool isValidBST(TreeNode* root) { if(!root) return true; bool flag = (root-&gt;right ? (root-&gt;val &lt; minNode(root-&gt;right)-&gt;val) : true) &amp;&amp; (root-&gt;left ? (root-&gt;val &gt; maxNode(root-&gt;left)-&gt;val) : true); return flag &amp;&amp; isValidBST(root-&gt;right) &amp;&amp; isValidBST(root-&gt;left); } };","link":"/2021/04/22/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/98-validate-binary-search-tree/"},{"title":"é¢è¯•é¢˜-æ ˆå’Œé˜Ÿåˆ—","text":"æ”¶é›†äº†æ ˆå’Œé˜Ÿåˆ—ç›¸å…³é¢˜ç›®ã€‚ é¢è¯•9ï¼šä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ— é¢˜é¢ï¼šå¦‚é¢˜ æ€è·¯ï¼šæ ˆæ˜¯FILOç»“æ„ï¼Œå°†ä¸¤ä¸ªæ ˆçš„ç»“åˆèµ·æ¥å°±å¯ä»¥è¾¾åˆ°FIFOçš„æ•ˆæœã€‚ ä»£ç ï¼štemplate &lt;typename T&gt; class CQueue { public: CQueue(void); ~CQueue(void); void appendTail(const T&amp; node){ stack2.push(node); } T deleteHead(){ if(stack1.empty()){ while(!stack2.empty()){ stack1.push(stack2.top()); stack2.pop(); } } //å¼¹ç©ºæ ˆåº”æŠ›å‡ºå¼‚å¸¸ if(stack1.empty()) throw new exception(&quot;queue is empty.&quot;); T topValue = stack1.top(); stack1.pop(); return topValue; } private: stack&lt;T&gt; stack1, stack2; } é¢è¯•é¢˜9ç›¸å…³é¢˜ï¼šä¸¤ä¸ªé˜Ÿåˆ—å®ç°æ ˆ//æ€è€ƒäº†ä¸€ä¸‹åªèƒ½ç”¨ä¸€ä¸ªé˜Ÿåˆ—å¾ªåºå­˜å‚¨æ•°æ®ï¼Œåœ¨æ’å…¥æ“ä½œæ—¶ç›´æ¥æ’å…¥ã€‚åˆ é™¤æ—¶æŠŠä¸€ä¸ªé˜Ÿåˆ—çš„é™¤äº†æœ€åä¸€ä¸ªå…¶ä»–æ•°æ®é¡ºåºæ”¾åˆ°ä¸´æ—¶å­˜å‚¨é˜Ÿåˆ—ï¼Œæœ€ååˆ é™¤æœ€åä¸€ä¸ªæ•°æ®ã€‚ åŒ…å«minå‡½æ•°çš„æ ˆé¢˜é¢ï¼šç»™å®šæ ˆçš„æ•°æ®ç»“æ„ï¼Œè¦æ±‚å®ç°å¯¹æ ˆçš„æ“ä½œminï¼Œpushï¼Œpopï¼Œå¹¶ä¸”å¤æ‚åº¦ä¸ºO(1)O(1)ã€‚ æ€è·¯ï¼šè¿™é¢˜çš„éš¾åº¦ä¸åœ¨äºæ€ç»´ï¼Œè€Œåœ¨äºä¸€ç§æ€æƒ³ã€‚ä¸ºäº†ä¿æŒæ ˆFILOçš„ç‰¹æ€§ï¼Œå¿…é¡»æœ‰ä¸€ä¸ªæ ˆè´Ÿè´£å­˜å‚¨åŸæ•°æ®ã€‚ä½†æ˜¯å¦‚ä½•å®ç°minï¼Ÿä¸€å¼€å§‹çš„æƒ³æ³•æ˜¯ç»´æŠ¤ä¸€ä¸ªé€’å¢çš„æ ˆï¼Œä½†æ˜¯æ˜æ˜¾çš„å¤æ‚åº¦é«˜ï¼Œä¸”ä¸æ˜“ç»´æŠ¤ã€‚ç®€å•å¦‚æˆ‘æ²¡æœ‰æƒ³åˆ°å¯ä»¥ç›´æ¥ç»´æŠ¤ä¸€ä¸ªæ¯ä¸€ä¸ªå…ƒç´ éƒ½ä»£è¡¨ç€å½“å‰è¢«å‹å…¥æ ˆæ—¶çš„æ ˆçš„æœ€å°å€¼çš„çŠ¶æ€æ ˆã€‚ä¹Ÿå°±æ˜¯è¯´åœ¨æ•°æ®å‹å…¥æ ˆçš„æ—¶å€™æ±‚å‡ºä¹‹å‰è®°å½•çš„æœ€å°å€¼å’Œè¢«å‹å…¥å…ƒç´ çš„æœ€å°å€¼ï¼Œç„¶åå‹å…¥çŠ¶æ€æ ˆã€‚popçš„æ—¶å€™ä¹Ÿå¾ˆç®€å•ï¼Œç›´æ¥ä¸¤ä¸ªæ ˆéƒ½popå°±okã€‚ å¯ä»¥è¿™ä¹ˆåšçš„ç†ç”±ï¼Œæ˜¯æ ˆçš„minå€¼æ˜¯ä¸å°†æ¥æ— å…³çš„ï¼Œä»…ä¸è¿‡å»æœ‰å…³ï¼Œæ¢å¥è¯è¯´å°±æ˜¯çŠ¶æ€å€¼ä»…ä¸å½“å‰æ ˆçš„å†…å®¹æœ‰å…³ã€‚ å¥½ä¼˜é›…ã€‚ class StackMin{ private: stack&lt;int&gt; s, sMin; public: void push(int x){ if(sMin.size() &gt; 0) sMin.push(min(x, sMin.top())); else sMin.push(x); s.push(x); } void pop(){ if(sMin.size() == 0) return; sMin.pop(); s.pop(); } int min(){ if(sMin.size() &gt; 0) return sMin.top(); else throw new exception(); } } é”™è¯¯ï¼šæ²¡æœ‰æ£€æŸ¥æ ˆçš„å…ƒç´ æ•°é‡ã€‚ é¢31ï¼šåˆæ³•çš„æ ˆçš„å¼¹å‡ºåºåˆ—é¢˜é¢ï¼šç»™å‡ºä¸€ä¸ªæŒ‰å¢åºçš„æ•°å­—åºåˆ—1ï¼Œ2ï¼Œ3ï¼Œ4â€¦â€¦å‹å…¥æ ˆçš„åºåˆ—ï¼Œ åŒæ—¶ç»™å‡ºä¸€ä¸ªå¯¹åº”æ•°å­—çš„å¼¹å‡ºåºåˆ—ï¼Œåˆ¤æ–­å¼¹å‡ºåºåˆ—æ˜¯å¦æ˜¯å‹å…¥åºåˆ—çš„å¼¹å‡ºåºåˆ—ã€‚ æ€è·¯ï¼šä¸è€ƒè™‘æ•°æ®çš„é”™è¯¯è¾“å…¥çš„è¯ã€‚ä¸€ä¸ªç®€å•è€Œè‡ªç„¶çš„æ€è·¯å°±æ˜¯æ¨¡æ‹Ÿï¼Œå»ºç«‹ä¸€ä¸ªè¾…åŠ©æ ˆã€‚å¯¹äºå¼¹å‡ºåºåˆ—çš„å½“å‰æ•°æ®ï¼Œå¦‚æœæ¯”æ ˆé¡¶æ•°æ®å¤§æˆ–è€…æ ˆæ²¡æœ‰æ•°æ®ï¼Œåˆ™å‹å…¥æ•°æ®ï¼Œç›´åˆ°æ ˆé¡¶å’Œå½“å‰å¼¹å‡ºåºåˆ—çš„å€¼ä¸€æ ·å¤§ã€‚å¦‚æœç­‰äºæ ˆé¡¶æ•°æ®ï¼Œå¼¹å‡ºæ ˆé¡¶ã€‚å¦‚æœæ¯”æ ˆé¡¶æ•°æ®å°ï¼Œåˆ™åºåˆ—é”™è¯¯ã€‚å¦‚æœæ­£å¸¸è¿è¡Œç»“æŸåˆ™åºåˆ—æ­£ç¡®ã€‚ ä¸å¤ªå®¹æ˜“è®²æ¸…æ¥šï¼Œæœ€å¥½ä¸¾ä¸ªä¾‹å­ã€‚ æƒ³äº†ä¸€ä¸¢ä¸¢ï¼Œç»ˆäºè®²æ¸…æ¥šäº†ã€‚é‡ç‚¹åœ¨äºåˆ¤æ–­æ¨¡æ‹Ÿè¿‡ç¨‹çš„æ¡ä»¶éœ€è¦ç¼•æ¸…ã€‚ æ ·ä¾‹ï¼štrue: 1,2,3 1,2,3 1,2,3 3,2,1 1,2,3 3,1,2 1,2,3,4,5,6 3,4,2,5,1,6 1,2,3,4,5,6 3,4,2,6,1,5 ä»£ç ï¼šbool isPopSerial(int aPush[], int lenPush, int aPop[], int lenPop){ stack&lt;int&gt; s; int pushMax = 0; if(lenPush != lenPop) return false; for(int i = 0; i &lt; lenPush; i++){ if(s.empty() || aPush[i] &gt; s.top()){ int k = pushMax + 1; while(k &lt;= aPush[i]){ s.push(k); k++; } pushMax = k - 1; } if(s.top() == aPush[i]){ s.pop(); }else{ return false; } } return true; } é¢59 é¢˜äºŒï¼šé˜Ÿåˆ—çš„æœ€å¤§å€¼é¢˜é¢ï¼šè¯·å®šä¹‰ä¸€ä¸ªé˜Ÿåˆ—å¹¶å®ç°å‡½æ•° max_value å¾—åˆ°é˜Ÿåˆ—é‡Œçš„æœ€å¤§å€¼ï¼Œè¦æ±‚å‡½æ•°max_valueã€push_back å’Œ pop_front çš„å‡æ‘Šæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(1)ã€‚ è‹¥é˜Ÿåˆ—ä¸ºç©ºï¼Œpop_front å’Œ max_value éœ€è¦è¿”å› -1 æ€è·¯ï¼šç¬¬ä¸€ç§è‚¯å®šä¼šæƒ³åˆ°æŠŠä¸€ä¸ªé˜Ÿåˆ—æ‹†æˆä¸¤ä¸ªæ ˆæ¥åšï¼›ç¬¬äºŒç§æ¯”è¾ƒå·§å¦™ï¼Œé€šè¿‡åˆ†ææ»‘åŠ¨çª—å£å†…å…ƒç´ æœ€å¤§å€¼çš„å˜åŒ–ï¼Œå¯ä»¥å†™å‡ºç±»ä¼¼çš„å¦‚ä¸‹ä»£ç ã€‚å…·ä½“æ€è·¯ï¼Œæ˜¯ç”¨åŒå¤´é˜Ÿåˆ—ç»´æŠ¤é˜Ÿåˆ—æœ€å¤§å€¼ã€‚ ä»£ç ï¼šclass MaxQueue { public: deque&lt;int&gt; value; deque&lt;int&gt; maxValue; MaxQueue() { value.clear(); maxValue.clear(); } int max_value() { if(value.size() &gt; 0){ return maxValue.front(); } else // throw new exception; return -1; } void push_back(int number) { value.push_back(number); while(maxValue.size() &gt; 0 &amp;&amp; maxValue.back() &lt; number){ maxValue.pop_back(); } maxValue.push_back(number); } int pop_front() { if(value.size() &gt; 0){ int popValue = value.front(); if(maxValue.front() == popValue){ maxValue.pop_front(); } value.pop_front(); return popValue; }else // throw new exception; return -1; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-&gt;max_value(); * obj-&gt;push_back(value); * int param_3 = obj-&gt;pop_front(); */","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/zhan-he-dui-lie/mian-shi-ti-zhan-he-dui-lie/"},{"title":"106. Construct Binary Tree from Inorder and Postorder Traversal","text":"hello world 106. Construct Binary Tree from Inorder and Postorder Traversal æ€è·¯ï¼šé€’å½’çš„å°†ä¸­åºéå†çš„åºåˆ—åˆ†å¼€ï¼Œå¹¶å»ºç«‹ä¸­é—´èŠ‚ç‚¹çš„å€¼ ä»£ç ï¼šé€’å½’ã€‚ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* buildTreeCore(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int ins, int inend, int posts, int poste){ if(ins &gt;= inend || posts &gt;= poste) return NULL; TreeNode *node = new TreeNode(postorder[poste - 1]); int pos = ins; while(inorder[pos] != postorder[poste - 1]){ pos++; } node-&gt;left = buildTreeCore(inorder, postorder, ins, pos, posts, posts + pos - ins); node-&gt;right = buildTreeCore(inorder, postorder, pos + 1, inend, posts + pos - ins, poste - 1); return node; } TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { return buildTreeCore(inorder, postorder, 0, inorder.size(), 0, postorder.size()); } };","link":"/2020/09/25/shua-ti/shu-ju-jie-gou/shu/106-construct-binary-tree-from-inorder-and-postorder-traversal/"},{"title":"109. Convert Sorted List to Binary Search Tree","text":"æ€è·¯ï¼šé“¾è¡¨å®é™…ä¸Šç»™å‡ºçš„æ˜¯äºŒå‰æ ‘å‰åºçš„ç»“æœï¼Œå› ä¸ºAVLæ ‘ä»»æ„å·¦å³å­æ ‘é«˜åº¦ä¸è¶…è¿‡1ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©é“¾è¡¨ä¸­ç‚¹ï¼Œå¹¶å°†é“¾è¡¨çš„é•¿åº¦å°½å¯èƒ½ä¸€æ ·é•¿çš„ä¸¤éƒ¨åˆ†åˆ’åˆ†åˆ°å·¦å³å­æ ‘ï¼Œæ‰€ä»¥é«˜åº¦æ€§è´¨å¯ä»¥ç»´æŒä½ã€‚ åœ¨ä¸­åºéå†é“¾è¡¨ï¼Œæ§åˆ¶å­æ ‘é•¿åº¦ï¼Œå³å¯æ„å»ºç¬¦åˆé¢˜æ„çš„AVLæ ‘ã€‚ ä»£ç ï¼š/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedListToBST(ListNode* head) { int len = sizeOfList(head); return sortedListToBSTCore(head, 0, len - 1); } int sizeOfList(ListNode* head){ ListNode *p = head; int len = 0; while(p){ p = p-&gt;next; ++len; } return len; } TreeNode* sortedListToBSTCore(ListNode* &amp;head, int lhs, int rhs) { if(lhs &gt; rhs) return nullptr; int mid = (lhs + rhs + 1) / 2; TreeNode* lchild = sortedListToBSTCore(head, lhs, mid - 1); TreeNode* root = new TreeNode(head-&gt;val); head = head-&gt;next; TreeNode* rchild = sortedListToBSTCore(head, mid + 1, rhs); root-&gt;left = lchild; root-&gt;right = rchild; return root; } };","link":"/2021/03/04/shua-ti/shu-ju-jie-gou/shu/109-convert-sorted-list-to-binary-search-tree/"},{"title":"1609. Even Odd Tree","text":"æ€è·¯:å±‚åºéå†ã€‚è®°å½•è¾¹ç•Œå³å¯ã€‚ ä»£ç ï¼š /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isEvenOddTree(TreeNode* root) { if(root == nullptr ) return false; queue&lt;TreeNode *&gt; que; vector&lt;int&gt; a; int level = 0, num = 1, nextn = 0;; que.push(root); while(!que.empty()){ TreeNode *t = que.front(); que.pop(); a.push_back(t-&gt;val); num--; if(t-&gt;left){ que.push(t-&gt;left); nextn++; } if(t-&gt;right){ que.push(t-&gt;right); nextn++; } if(num == 0){ num = nextn; nextn = 0; int flag = 1; if(a.size() &lt; 1) continue; if(level &amp; 1){ for(int i = 1; i &lt; a.size(); i++){ if(a[i] &gt;= a[i - 1] || a[i]%2 == 1 ) flag = 0; } if(a[0]%2 == 1) flag = 0; } else{ for(int i = 1; i &lt; a.size(); i++){ if(a[i] &lt;= a[i - 1] || a[i]%2 == 0) flag = 0; } if(a[0]%2 == 0) flag = 0; } a.clear(); level ++; if(!flag) return false; } } return true; } };","link":"/2020/10/18/shua-ti/shu-ju-jie-gou/shu/1609-even-odd-tree/"},{"title":"235. Lowest Common Ancestor of a Binary Search Tree","text":"235. Lowest Common Ancestor of a Binary Search Tree æ€è·¯ï¼šæœç´¢æ ‘çš„LCAæ¯”è¾ƒç®€å•ï¼Œåˆ©äºäºŒåˆ†æ€§è´¨å³å¯ã€‚ ä»£ç ï¼š/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root-&gt;val &lt; min(p-&gt;val, q-&gt;val)){ return lowestCommonAncestor(root-&gt;right, p, q); }else if(root-&gt;val &gt; max(p-&gt;val, q-&gt;val) ){ return lowestCommonAncestor(root-&gt;left, p, q); }else{ return root; } } };","link":"/2020/09/27/shua-ti/shu-ju-jie-gou/shu/235-lowest-common-ancestor-of-a-binary-search-tree/"},{"title":"236. Lowest Common Ancestor of a Binary Tree","text":"æ€è·¯ï¼š é€’å½’æœç´¢ï¼Œåˆ¤æ–­å·¦å³å­æ ‘å·²ç»å½“å‰èŠ‚ç‚¹æ˜¯å¦æœ‰på’Œqã€‚ è®°å½•ä¸‹çˆ¶èŠ‚ç‚¹ï¼Œè½¬åŒ–ä¸ºä¸¤æ¡é“¾è¡¨çš„å…¬å…±å­èŠ‚ç‚¹ã€‚ ä»£ç ï¼š/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode *target; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return target; } int dfs(TreeNode* root, TreeNode* p, TreeNode* q){ if(!root) return 0; int leftRes = dfs(root-&gt;left, p, q); int rightRes = dfs(root-&gt;right, p, q); int midRes = 0; if(root == p) midRes = 1; else if(root == q) midRes = 2; if(!target &amp;&amp; (root == p &amp;&amp; root == q || leftRes + rightRes + midRes == 3)) target = root; return leftRes + rightRes + midRes; } }; /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode *target; unordered_map&lt;TreeNode*, TreeNode*&gt; fa; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, nullptr); TreeNode* p1 = p, *p2 = q; while(p1 != p2){ p1 = fa[p1] ? fa[p1] : q; p2 = fa[p2] ? fa[p2] : p; } return p1; } void dfs(TreeNode* root, TreeNode* father){ if(!root) return; fa[root] = father; dfs(root-&gt;left, root); dfs(root-&gt;right, root); } };","link":"/2021/03/04/shua-ti/shu-ju-jie-gou/shu/236-lowest-common-ancestor-of-a-binary-tree/"},{"title":"297. Serialize and Deserialize Binary Tree","text":"297. Serialize and Deserialize Binary Treeæ€è·¯ï¼šå¯¹äºäºŒå‰æ ‘åºåˆ—åŒ–ï¼Œleetcodeå·²ç»ç»™å‡ºäº†å¾ˆå¥½çš„ç¤ºèŒƒã€‚æ€è€ƒä¸€ä¸‹ï¼Œå®Œæ•´å‰ç¼€éå†ï¼ˆåŒ…æ‹¬ç©ºèŠ‚ç‚¹ä¿¡æ¯ï¼‰èƒ½å¦æ„å»ºäºŒå‰æ ‘ï¼Ÿå¯ä»¥ï¼Œä»æ ¹åˆ°å­èŠ‚ç‚¹å‰ç¼€éå†çš„åŒæ—¶æ„å»ºäºŒå‰æ ‘ã€‚åŒç†åç¼€ä¹Ÿå¯ä»¥ã€‚ è¿™é‡Œæˆ‘é‡‡ç”¨å±‚åºéå†çš„æ–¹å¼ï¼Œæ„å»ºåºåˆ—åŒ–å’Œè§£åºåˆ—åŒ–ã€‚ ä¸‹é¢çš„ä»£ç æœ‰ä¸€ä¸ªå°æŠ€å·§ï¼ŒæŠŠè¿­ä»£å™¨çš„è®¾è®¡æ€æƒ³èå…¥åˆ°ä»£ç é‡Œï¼šæŠŠéå†çš„åŠŸèƒ½ç‹¬ç«‹å‡ºæ¥ï¼Œåªæä¾›æ¥å£ï¼Œä»¥ä¾¿å¿«é€Ÿåˆ¤æ–­æœ‰æ— å‰©ä½™èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹æ˜¯å¦æœ‰æ•ˆã€‚ ä»£ç ï¼š/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { string ser; int pos; // decoded pos. public: // Encodes a tree to a single string. string serialize(TreeNode* root) { queue&lt;TreeNode*&gt; que; que.push(root); while(que.size()){ TreeNode* pnode = que.front(); que.pop(); if(pnode){ ser += to_string(pnode-&gt;val) + &quot;,&quot;; que.push(pnode-&gt;left); que.push(pnode-&gt;right); } else ser += &quot;null,&quot;; } if(ser != &quot;&quot;) ser.erase(ser.size() - 1); // cout &lt;&lt; ser &lt;&lt; endl; return ser; } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { ser = data; TreeNode *root = nullptr, *p = root; pos = 0; queue&lt;TreeNode*&gt; que; if(_isvalue()){ root = new TreeNode(_next()); que.push(root); } else return nullptr; while(que.size()){ p = que.front(); // ä¸ºè¯¥èŠ‚ç‚¹æ„é€ å·¦å³èŠ‚ç‚¹ que.pop(); // cout &lt;&lt; p-&gt;val &lt;&lt; ' '; if(!_hasnext()) break; if(_isvalue()){ p-&gt;left = new TreeNode(_next()); que.push(p-&gt;left); }else _next(); // è¯¥èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸ºç©º if(_isvalue()){ p-&gt;right = new TreeNode(_next()); que.push(p-&gt;right); }else _next(); // è¯¥èŠ‚ç‚¹çš„å³å­æ ‘ä¸ºç©º } //cout &lt;&lt; endl; return root; } bool _isvalue(){ if(!_hasnext()) return false; if(isdigit(ser[pos]) || ser[pos] == '-') return true; return false; } inline bool _hasnext(){ return !(pos &gt;= ser.size()); } int _next(){ bool isnum = _isvalue(); int t = pos; while(t &lt; ser.size() &amp;&amp; ser[t] != ',') ++t; int pre = pos; pos = t + 1; // æŠŠposç§»åˆ°ä¸‹ä¸€ä¸ªç©ºèŠ‚ç‚¹nullæˆ–è€…æ•°å­—å¼€å¤´å¤„ if(isnum) return stoi(ser.substr(pre, t - pre)); else return -1; } }; // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root));","link":"/2021/04/26/shua-ti/shu-ju-jie-gou/shu/297-serialize-and-deserialize-binary-tree/"},{"title":"307. Range Sum Query - Mutable","text":"307. Range Sum Query - Mutableæ€è·¯çº¿æ®µæ ‘ + lazyæ“ä½œ ä»£ç çº¿æ®µæ ‘ç´¯åŠ æ“ä½œï¼ˆä»£ç åº”è¯¥æ­£ç¡®ï¼Œé¡ºæ‰‹å†™ä¸€å†™ï¼‰ class NumArray { public: int n = 0, m = 0; vector&lt;int&gt; d, b, a; void build(int l, int r, int no){ int m = (l + r) / 2; if(l == r){ d[no] = a[l]; return; } else { build(l, m, no * 2), build(m + 1, r, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } } void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated if(s &lt;= l &amp;&amp; r &lt;= t){ d[no] += (r - l + 1) * c; b[no] += c; return; } int mid = (l + r) / 2; if(b[no] &amp;&amp; l != r){ d[no * 2] += (mid - l + 1) * b[no]; d[no * 2 + 1] += (r - mid) * b[no]; b[no * 2] += b[no]; b[no * 2 + 1] += b[no]; b[no] = 0; } if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2); if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } int query_big(int l, int r, int s, int t, int no){ // [s, t] is queried. if(s &lt;= l &amp;&amp; r &lt;= t){ return d[no]; } int mid = (l + r) / 2; if(b[no] &amp;&amp; l != r){ d[no * 2] += (mid - l + 1) * b[no]; d[no * 2 + 1] += (r - mid) * b[no]; b[no * 2] += b[no]; b[no * 2 + 1] += b[no]; b[no] = 0; } int sum = 0; if(s &lt; mid + 1) sum += query_big(l, mid, s, t, no * 2); if(t &gt; mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1); return sum; } NumArray(vector&lt;int&gt;&amp; nums) { m = nums.size(); n = m * 2 + 10; d.resize(n); b.resize(n); a = nums; build(0, m - 1, 1); } void update(int index, int val) { update_big(0, m, index, index, val, 1); } int sumRange(int left, int right) { return query_big(0, m, left, right, 1); // return 0; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */ çº¿æ®µæ ‘æ›´æ–°ä¸ºå®šå€¼ï¼ˆAC ï¼‰ 17% class NumArray { public: int n = 0, m = 0; vector&lt;int&gt; d, b, a, isb; void build(int l, int r, int no){ int m = (l + r) / 2; if(l == r){ d[no] = a[l]; return; } else { build(l, m, no * 2), build(m + 1, r, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } } void update_big(int l, int r, int s, int t, int c, int no){ // [s, t] is updated if(s &lt;= l &amp;&amp; r &lt;= t){ d[no] = (r - l + 1) * c; b[no] = c; isb[no] = 1; return; } int mid = (l + r) / 2; if(l &lt; r &amp;&amp; isb[no]){ d[no * 2] = (mid - l + 1) * b[no]; d[no * 2 + 1] = (r - mid) * b[no]; b[no * 2] = b[no]; b[no * 2 + 1] = b[no]; isb[no * 2] = isb[no * 2] = 1; b[no] = isb[no] = 0; } if(s &lt; mid + 1) update_big(l, mid, s, t, c, no * 2); if(t &gt; mid)update_big(mid + 1, r, s, t, c, no * 2 + 1); d[no] = d[no * 2] + d[no * 2 + 1]; } int query_big(int l, int r, int s, int t, int no){ // [s, t] is queried. if(s &lt;= l &amp;&amp; r &lt;= t){ return d[no]; } int mid = (l + r) / 2; if(l &lt; r &amp;&amp; b[no]){ d[no * 2] = (mid - l + 1) * b[no]; d[no * 2 + 1] = (r - mid) * b[no]; b[no * 2] = b[no]; b[no * 2 + 1] = b[no]; isb[no * 2] = isb[no * 2] = 1; b[no] = isb[no] = 0; } int sum = 0; if(s &lt; mid + 1) sum += query_big(l, mid, s, t, no * 2); if(t &gt; mid) sum += query_big(mid + 1, r, s, t, no * 2 + 1); return sum; } NumArray(vector&lt;int&gt;&amp; nums) { m = nums.size(); n = m * 4 + 10; // n * 2 å¼€å¤ªå°äº† d.resize(n); b.resize(n); isb.resize(n); a = nums; build(0, m - 1, 1); } void update(int index, int val) { update_big(0, m - 1, index, index, val, 1); } int sumRange(int left, int right) { return query_big(0, m - 1, left, right, 1); // return 0; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * obj-&gt;update(index,val); * int param_2 = obj-&gt;sumRange(left,right); */","link":"/2021/02/05/shua-ti/shu-ju-jie-gou/shu/307-range-sum-query-mutable/"},{"title":"310. Minimum Height Trees","text":"310. Minimum Height Treesæ€è·¯ï¼š ï¼ˆè¶…æ—¶ï¼‰bfs æ‹“æ‰‘æ’åºå˜å½¢ã€‚ä»å›¾çš„è¾¹ç¼˜ç‚¹é€†å‘è¿½æº¯åˆ°ä¸­å¿ƒç‚¹ï¼Œå¯ä»¥ç›´æ¥è·å–åˆ°ç›®æ ‡ç‚¹ã€‚åˆæœ‰é¢˜ç›®æ€§è´¨çŒœå¾—ï¼Œæ²¡æœ‰å­¤ç«‹ç‚¹ï¼ˆé™¤én=1ï¼‰ï¼Œæ²¡æœ‰ç¯ã€‚é‚£ä¹ˆç›®æ ‡ç‚¹è‡³å¤šåªæœ‰ä¸¤ä¸ªã€‚ s class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { map.resize(n); for(int i = 0; i &lt; edges.size(); ++i){ int x = edges[i][0]; int y = edges[i][1]; map[x].emplace_back(y); map[y].emplace_back(x); } int minl = n - 1; vector&lt;int&gt; root; for(int i = 0; i &lt; n; ++i){ vector&lt;bool&gt; vis(n, false); int len = dfs(i, vis, 0); if(len &lt; minl){ root.clear(); minl = len; } if(len == minl){ root.push_back(i); } } return root; } int dfs(int v, vector&lt;bool&gt;&amp;vis, int len){ vis[v] = 1; int maxlen = len; for(auto u : map[v]){ if(!vis[u]){ // cout &lt;&lt; v &lt;&lt; ' ' &lt;&lt; u &lt;&lt; ' ' &lt;&lt; len &lt;&lt; endl; maxlen = max(maxlen, dfs(u, vis, len + 1)); // bugs: maxv = max(maxv, dfs(maxv + 1)); } } return maxlen; } }; æ‹“æ‰‘AC class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; degree; vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { map.resize(n); degree.resize(n); for(int i = 0; i &lt; edges.size(); ++i){ int x = edges[i][0]; int y = edges[i][1]; map[x].emplace_back(y); map[y].emplace_back(x); degree[x]++; degree[y]++; } queue&lt;int&gt; que; int m = 0; for(int i = 0;i &lt; n; ++i){ if(degree[i] == 1){ que.push(i); } if(degree[i] &gt; 0) ++m; } vector&lt;int&gt; root; while(que.size()){ m -= que.size(); if(m == 0) break; // cout &lt;&lt; m &lt;&lt; endl; while(que.size()){ int u = que.front(); que.pop(); for(auto v : map[u]){ degree[v]--; degree[u]--; if(degree[v] == 0) root.push_back(v); } } for(int i = 0; i &lt; n; ++i){ if(degree[i] == 1){ que.push(i); } } } if(root.size() == 0) while(que.size()){ root.push_back(que.front()); que.pop(); } if(n == 1) root.push_back(0); return root; } }; åˆ©ç”¨æ€§è´¨ä¼˜åŒ–ä¸€ä¸‹ class Solution { public: vector&lt;vector&lt;int&gt;&gt; map; vector&lt;int&gt; degree; vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { map.resize(n); degree.resize(n); for(int i = 0; i &lt; edges.size(); ++i){ int x = edges[i][0]; int y = edges[i][1]; map[x].emplace_back(y); map[y].emplace_back(x); degree[x]++; degree[y]++; } queue&lt;int&gt; que; int m = n; for(int i = 0;i &lt; n; ++i){ if(degree[i] == 1){ que.push(i); } } vector&lt;int&gt; root; while(m &gt; 2){ m -= que.size(); int size = que.size(); for(int i = 0; i &lt; size; ++i){ int u = que.front(); que.pop(); for(auto v : map[u]){ degree[v]--; if(degree[v] == 1){ que.push(v); } } } } if(root.size() == 0) while(que.size()){ root.push_back(que.front()); que.pop(); } if(n == 1) root.push_back(0); return root; } };","link":"/2020/12/06/shua-ti/shu-ju-jie-gou/shu/310-minimum-height-trees/"},{"title":"331. Verify Preorder Serialization of a Binary Tree","text":"331. Verify Preorder Serialization of a Binary Treeæ€è·¯ï¼š æŒ‰ç…§å­—ç¬¦ä¸²æä¾›çš„æ•°æ®æŒ‰å‰åºéå†ä¼ªå»ºæ ‘ï¼Œå¦‚æœç”¨å®Œäº†æ‰€æœ‰å­—ç¬¦å°±å»ºæ ‘æˆåŠŸã€‚ å‰åºéå†å…è®¸æˆ‘ä»¬çš„ç”¨æ ˆè®°å½•å½“å‰èŠ‚ç‚¹ä»¥åŠä¹‹å‰èŠ‚ç‚¹åº”è¯¥ç”Ÿé•¿çš„åˆ†æ”¯æ•°ï¼Œæ¯”å¦‚ç¢°åˆ°ä¸€ä¸ªæ•°å­—ï¼Œä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å‡ä¸€åˆ†æ”¯æ•°ï¼Œæ’å…¥ä¸€ä¸ªå½“ç‚¹èŠ‚ç‚¹çš„åˆ†æ”¯æ•°2ã€‚éå†è¿‡ç¨‹ä¸­ï¼Œæ ˆä¸ºç©ºæˆ–è€…éå†åï¼Œå­—ç¬¦æ•°è¿˜æœ‰å‰©ä½™ï¼Œæ˜¾ç„¶å»ºæ ‘å¤±è´¥ã€‚ ä»£ç ï¼šclass Solution { public: bool isValidSerialization(string preorder) { int pos = 0; // if(preorder) return isValidSerializationCore(preorder, pos) &amp;&amp; pos == preorder.size() - 1; //å®Œæˆæ¡ä»¶ï¼šå¯ä»¥æ„å»ºå‡ºä¸€æ£µæ ‘ï¼Œå¹¶ä¸”æ¯ä¸ªå­—ç¬¦éƒ½ä½¿ç”¨åˆ° } bool isValidSerializationCore(string &amp;preorder, int &amp;pos) { cout &lt;&lt; pos &lt;&lt; endl; if(preorder.size() &lt;= pos) return false; if(preorder[pos] == '#') return true; while(isdigit(preorder[++pos])); --pos; //è·³åˆ°æ•°å­—çš„æœ€åä¸€ä¸ªcharçš„pos if(isValidSerializationCore(preorder, pos += 2) &amp;&amp; isValidSerializationCore(preorder, pos += 2)) return true; return false; } }; class Solution { public: bool isValidSerialization(string preorder) { int pos = 0; stack&lt;int&gt; post; post.push(1); while(pos &lt; preorder.size()){ cout &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; post.size() &lt;&lt; endl; if(post.size() == 0) return false; if(preorder[pos] == ',') ++pos; else if(preorder[pos] == '#'){ ++pos; if(--post.top() == 0){ post.pop(); } }else if(isdigit(preorder[pos])){ if(--post.top() == 0){ post.pop(); } post.push(2); while(isdigit(preorder[++pos])); } } return post.size() == 0; } };","link":"/2021/03/12/shua-ti/shu-ju-jie-gou/shu/331-verify-preorder-serialization-of-a-binary-tree/"},{"title":"450. Delete Node in a BST","text":"æ€è·¯ï¼šåˆ é™¤ä¸€ä¸ªåªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œæˆ–è€…æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼Œæ¯”è¾ƒç®€å•ã€‚ åˆ é™¤æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹Aï¼Œéœ€è¦æŠŠæ‰¾ä¸€ä¸ªæ¯”Aå¤§çš„æœ€å°å­èŠ‚ç‚¹Bæ¥æ›¿æ¢è¯¥Aã€‚é‚£ä¹ˆåŒæ—¶ä¹Ÿéœ€è¦é€’å½’çš„åˆ é™¤èŠ‚ç‚¹Bã€‚ ä»£ç ï¼šå¦‚æœäºŒå‰æ ‘ç»“æ„æ˜¯çˆ¶å­å„¿å­ç»“æ„ä»£ç ä¼šæ›´ç®€å•ã€‚ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void print(TreeNode* root){ if(!root) return; print(root-&gt;left); cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot; ; print(root-&gt;right); } TreeNode* deleteNode(TreeNode* root, int key) { if(!root) return nullptr; // print(root); cout &lt;&lt; root-&gt;val &lt;&lt; endl; if(key &gt; root-&gt;val){ root-&gt;right = deleteNode(root-&gt;right, key); return root; } if(key &lt; root-&gt;val){ root-&gt;left = deleteNode(root-&gt;left, key); return root; } //delete the note without right child. if(!root-&gt;right){ TreeNode *temp = root-&gt;left; delete root; return temp; } //delete the node with right child. TreeNode* rightMinP = getMinNode(root-&gt;right); TreeNode* newp = new TreeNode(rightMinP-&gt;val); // recursively delete the minimum node. root-&gt;right = deleteNode(root-&gt;right, rightMinP-&gt;val); //Because of updating left child link //bugs // cout &lt;&lt; &quot;@&quot; &lt;&lt; root-&gt;val &lt;&lt; endl; // print(root); // cout &lt;&lt; &quot;$&quot; &lt;&lt; newp-&gt;val &lt;&lt; endl; newp-&gt;left = root-&gt;left; newp-&gt;right = root-&gt;right; delete root; return newp; } TreeNode * getMinNode(TreeNode* root){ if(!root) return nullptr; TreeNode* p = root; while(p-&gt;left){ p = p-&gt;left; } return p; } };","link":"/2021/03/03/shua-ti/shu-ju-jie-gou/shu/450-delete-node-in-a-bst/"},{"title":"653. Two Sum IV - Input is a BST","text":"æ€è·¯ï¼šåˆ©ç”¨BSTæ€§è´¨ï¼Œ å‰åºéå†æ•°æ®çš„åŒæ—¶ï¼Œæœç´¢å¯¹åº”çš„k - valã€‚ å½“ç„¶å¯ä»¥æœç´¢ä¸€éï¼ŒåŒæ—¶hashéå†çš„æ•°æ®ï¼Œè½¬åŒ–ä¸ºä¸€èˆ¬çš„ä¸¤æ•°ä¹‹å’Œã€‚ ä»£ç ï¼š/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool findTarget(TreeNode* root, int k) { int flag = 0; findSum(root, root, k, flag); return flag; } void findSum(TreeNode* root, TreeNode* head, int k, int &amp;flag){ if(!root) return; findSum(root-&gt;left, head, k, flag); if(root-&gt;val &gt; (k + 1) / 2) return; //å‰ªæ TreeNode* p = findT(head, k - root-&gt;val); if(p != nullptr &amp;&amp; p != root){ flag = 1; return; } findSum(root-&gt;right, head, k, flag); } TreeNode* findT(TreeNode* root, int T){ if(!root) return nullptr; if(root-&gt;val == T) return root; if(root-&gt;val &lt; T) return findT(root-&gt;right, T); else return findT(root-&gt;left, T); } };","link":"/2021/03/03/shua-ti/shu-ju-jie-gou/shu/653-two-sum-iv-input-is-a-bst/"},{"title":"654. æœ€å¤§äºŒå‰æ ‘","text":"ä¸€ä¸ªåŸºç¡€çš„é€’å½’å»ºæ ‘å°±å¯ä»¥è§£å†³ã€‚ ä»¥é€’å½’çš„æ€æƒ³å¤„ç†æ¯ä¸€ä¸ªæ–°æ•°ç»„ï¼Œå…ˆæ‰¾å‡ºæœ€å¤§å€¼æ‰€åœ¨å¹¶ä»¥æ­¤å€¼ä¸€åˆ†æ•°ç»„ä¸º2ä¸ªæ•°ç»„ï¼ŒåŒæ—¶é€’å½’å»ºæ ‘å³å¯ã€‚ Noteï¼šæ³¨æ„è¾¹ç•Œé”™è¯¯ï¼Œå¦‚rightåˆ°åº•æ²¡æœ‰æ²¡å€¼ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { return constructBT(nums, 0, nums.size() - 1); } TreeNode* constructBT(vector&lt;int&gt;&amp; nums, int left, int right){ if(left &gt; right) return NULL; int index = left, nmax = nums[left]; for(int i = left + 1; i &lt;= right; i++){ if(nmax &lt; nums[i]){ nmax = nums[i]; index = i; } } TreeNode* root = new TreeNode(nmax); root-&gt;left = constructBT(nums, left, index - 1); root-&gt;right = constructBT(nums, index + 1, right); return root; } };","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/654-zui-da-er-cha-shu/"},{"title":"897. Increasing Order Search Tree","text":"æ€è·¯å‰åºéå† + å»ºæ ‘ ä»£ç ï¼š/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* head; TreeNode* increasingBST(TreeNode* root) { TreeNode* p = nullptr; increasingBSTCore(root, p); return head; } TreeNode* increasingBSTCore(TreeNode* root, TreeNode* &amp;pre) { if(!root) return nullptr; increasingBSTCore(root-&gt;left, pre); root-&gt;left = nullptr; if(pre) pre-&gt;right = root; else head = root; // The list of head; pre = root; increasingBSTCore(root-&gt;right, pre); return root; } };","link":"/2021/03/04/shua-ti/shu-ju-jie-gou/shu/897-increasing-order-search-tree/"},{"title":"PAT 1043 äºŒå‰æ ‘é‡å»º","text":"æœç´¢äºŒå‰æ ‘çš„å‰åºåˆ—æ¨å‡ºæ•´ä¸ªäºŒå‰æ ‘æˆ–è€…æ¨å‡ºååºåˆ—æ€æƒ³ï¼šåˆ©ç”¨äºŒå‰æ ‘çš„å­æ ‘çš„æ€§è´¨ï¼Œåˆ†éš”å¼€ä¸¤ä¸ªå­æ ‘ï¼Œé€’å½’çš„éå†æ ¹èŠ‚ç‚¹ï¼› éš¾ç‚¹ï¼šåˆ©ç”¨åŒé’ˆæ€æƒ³ä¿æŒå¹¶åˆ¤æ–­ä¸¤ä¸ªåŒºé—´çš„å†…å®¹ï¼ŒåŒæ—¶ç¡®å®šæ— å­æ ‘çš„é”™è¯¯å’Œé€’å½’è¾¹ç•Œï¼› PAT 1043 å…¶å®æœ‰ç‚¹æ„æ€ æŸ³ç¥çš„ä»£ç æ¯”æˆ‘çš„æ„æ€å¥½å¤šäº† vector&lt;int&gt;pre,post; bool isMirror; void checkPre(int root,int tail)//ã€rootï¼Œtailã€‘ { if(root&gt;tail) return;//! ç©ºèŠ‚ç‚¹é€€å‡º int i=root+1,j=tail; if(!isMirror) { //!whileé€€å‡ºä¹‹æ—¶ å°±æ˜¯åˆ°äº†å¦ä¸€ä¸ªå­æ ‘åºåˆ—çš„å¼€å¤´ä¸ç»“å°¾ while(i&lt;=tail&amp;&amp;pre[root]&gt;pre[i]) i++; while(j&gt;root&amp;&amp;pre[root]&lt;=pre[j]) j--;//!è‹¥è¯¥åºåˆ—æ˜¯äºŒå‰æœç´¢æ ‘åˆ™å¿…æœ‰i==j+1 } else { while(i&lt;=tail&amp;&amp;pre[root]&lt;=pre[i]) i++; while(j&gt;root&amp;&amp;pre[root]&gt;pre[j]) j--; } if(i-j!=1) return;//!ç”±äºæ ‘å¯èƒ½ä¸å­˜åœ¨ éœ€è¦å¤„ç†å¼‚å¸¸æƒ…å†µ checkPre(root+1,j); checkPre(i,tail); post.push_back(pre[root]);//!å‰åºéå†å‹å…¥å½“å‰æ ¹èŠ‚ç‚¹ï¼› } int main() { int n, flag = 1; scanf(&quot;%d&quot;,&amp;n); pre.resize(n+1); for(int i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;pre[i]); checkPre(0,n-1); if(post.size()!=n)//! ä¸ä¸ºäºŒã€ printf(&quot;YES\\n&quot;); for(int i=0; i&lt;n; i++) { printf(&quot;%d&quot;,post[i]); printf(&quot;%c&quot;,i!=n-1?' ':'\\n'); } } else printf(&quot;NO\\n&quot;); }","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/pat-1043-er-cha-shu-chong-jian/"},{"title":"PATé£æ ¼äºŒå‰æ ‘æ€»ç»“","text":"æ€»ç»“ä¸€ä¸‹PATå‡ºç°çš„æ‰€æœ‰æ ‘çš„å¥—è·¯ å‰åºä¸­åºè½¬ååºint post[40], n, pos = 0; vector&lt;int&gt; pre, in; stack&lt;int&gt;s; void dfs(int l1, int h1, int l2, int h2){ if(l1 &gt; h1) return; int k = l2; for(;in[k]!=pre[l1];k++); dfs(l1 + 1, l1 + k - l2, l2 , k - 1); dfs(l1 + k - l2 + 1, h1, k + 1, h2); post[pos++] = pre[l1]; } int main(){ int t; cin &gt;&gt; n; for(int i =0 ;i &lt; 2 * n; i++){ string a; cin &gt;&gt; a; if(a[1] == 'u'){ cin &gt;&gt; t; s.push(t); pre.push_back(t); }else{ in.push_back(s.top()); s.pop(); } } dfs(0, n - 1, 0, n - 1); for(int i = 0;i &lt; n; i++){ if(i == n - 1) cout &lt;&lt; post[i]; else cout &lt;&lt; post[i] &lt;&lt; ' ' ; } } BST + CMT è½¬å±‚åºint cbst[2000], n, pos = 1, in[2000]; int dfs(int u){ if(u &gt; n ) return 0; dfs(u * 2); cbst[u] = in[pos++]; dfs(u * 2 + 1); } int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; in[i]; } sort(in + 1, in + n + 1); dfs(1); for(int i = 1;i &lt;= n; i++){ if(i == n ) printf(&quot;%d&quot;, cbst[i]); else printf(&quot;%d &quot;, cbst[i]); } } å‰åºä¸­åºè½¬ååºvector&lt;int&gt; in, post, pre; int n, flag = 1; void dfs(int l1, int h1, int l2, int h2){ if(l1 &gt;= h1){ if(l1 == h1) in.push_back(pre[l1]); // l1 &gt; h1æ—¶ æ‰èƒ½å‹å…¥ å¦åˆ™æ˜¯é”™è¯¯çš„ return; } int k = l1 + 1; while(k &lt;= h1 &amp;&amp; pre[k] != post[h2 - 1]) k++; if(k == l1 + 1) flag = 0; dfs(l1 + 1, k - 1, l2, l2 + k - l1 - 2 ); in.push_back(pre[l1]); dfs(k, h1, l2 + k - l1 - 1, h2 - 1 ); } int main(){ cin &gt;&gt; n; post.resize(n); pre.resize(n); for(int i = 0; i &lt; n; i++) cin &gt;&gt; pre[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; post[i]; dfs(0, n - 1, 0 , n - 1); if(flag) cout &lt;&lt; &quot;Yes\\n&quot;; else cout &lt;&lt; &quot;No\\n&quot;; for(int i = 0; i &lt; n; i++) if(i == n - 1) printf(&quot;%d\\n&quot;, in[i]); else printf(&quot;%d &quot;, in[i]); } å±‚åºä¸­åºè½¬å‰åºååºè¿™ä¸ªé—®é¢˜ä¹Ÿéå¸¸çš„å·§å¦™ï¼Œæœ¬æ¥æ˜¯ä¸€ä¸ªå±‚æ¬¡éå†åˆ’åˆ†å‡ºä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œä½†æ˜¯ä¸‹ä¸€æ­¥å·¦å³å­æ ‘åˆ’åˆ†å´æˆäº†é—®é¢˜ï¼Œè¿™ä¸ªç®—æ³•æœ‰ä¸€æ¬¡åˆ·æ–°äº†æˆ‘çš„ä¸–ç•Œè§‚ã€‚ä½¿ç”¨ä¸­åºéå†çš„æ€æƒ³ï¼Œåœ¨å±‚æ¬¡éå†ä¸­æŸ¥è¯¢æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å½’å±çˆ¶èŠ‚ç‚¹çš„å·¦å­æ ‘è¿˜æ˜¯å³å­æ ‘ const ll mod = 1000000007; int tree[40][2], val[40], n; int in[40]; vector&lt;int&gt; pre, post, lay; int build(vector&lt;int&gt; lay, int l, int r){ if(l &gt; r) return 0; int k = 1; while(lay[0] != in[k]) k++; vector&lt;int&gt; llay, rlay; for(int i = 1;i &lt; lay.size(); i++){ int isl = 0; for(int j = l; j&lt; k; j++) if(lay[i] == in[j]){ isl = 1; break; } if(isl) llay.push_back(lay[i]); else rlay.push_back(lay[i]); } pre.push_back(in[k]); tree[k][0] = build(llay, l, k - 1); tree[k][1] = build(rlay, k + 1, r); post.push_back(in[k]); return k; } int main(){ cin &gt;&gt; n; lay.resize(n); int root = 0; for(int i = 0;i &lt; n; i++) cin &gt;&gt; lay[i]; for(int i = 0;i &lt; n; i++) cin &gt;&gt; in[i + 1]; root = build(lay, 1, n); for(int i = 0;i &lt; n;i++) if(i == n - 1) printf(&quot;%d\\n&quot;, pre[i]); else printf(&quot;%d &quot;, pre[i]); for(int i = 0;i &lt; n;i++) if(i == n - 1) printf(&quot;%d\\n&quot;, post[i]); else printf(&quot;%d &quot;, post[i]); } åˆ¤æ–­å®Œå…¨äºŒå‰æ ‘int tree[200][2], n, ingree[200], root, lastnood, flag = 1; int bfs(int u){ int tn = 1; queue&lt;int&gt; que; que.push(u); while(que.size()){ int v = que.front(); que.pop(); lastnood = v; if(tree[v][0] == -1){ if(tn != n) flag = 0; }else{ que.push(tree[v][0]); tn++; } if(tree[v][1] == -1){ if(tn != n) flag = 0; }else{ que.push(tree[v][1]); tn++; } } } int main(){ fill(tree[0], tree[0] + 200 * 2 , - 1 ); cin &gt;&gt; n; for(int i = 0;i &lt; n; i++) { string a, b; cin &gt;&gt; a &gt;&gt; b; if(a != &quot;-&quot;){ int v = atoi(a.c_str()); tree[i][0] = v; ingree[v] ++; } if(b != &quot;-&quot;) { int v = atoi(b.c_str()); tree[i][1] = v; ingree[v] ++; } } for(int i = 0; i &lt; n ;i++) if(ingree[i] == 0) root = i; bfs(root); if(flag) cout &lt;&lt; &quot;YES &quot; &lt;&lt; lastnood; else cout &lt;&lt; &quot;NO &quot; &lt;&lt; root; } é™æ€é“¾è¡¨å»ºæ ‘int tree[2000][3], lay[2000], n, depest, ct = 0; int insert(int u, int val, int dep){ depest = max(depest,dep); // cout &lt;&lt; u &lt;&lt; endl; if(u == 0){ lay[dep] ++; tree[++ct][2] = val; return ct; }else if(val &lt;= tree[u][2]){ tree[u][0] = insert(tree[u][0], val, dep + 1); }else if(val &gt; tree[u][2]){ tree[u][1] = insert(tree[u][1], val, dep + 1); } return u; } int main() { int root = 0, tmp; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++){ cin &gt;&gt; tmp; root = insert(root, tmp, 1); } cout &lt;&lt; lay[depest ] &lt;&lt; &quot; + &quot; &lt;&lt; lay[depest - 1] &lt;&lt; &quot; = &quot; &lt;&lt; lay[depest] + lay[depest - 1] &lt;&lt; endl; } åˆ¤æ–­æ ‘æ™´ç¥çš„ä¸€é“é¢˜1016 int tree[100][3], val[40], n, ingree[20]; int navln, layer[23], isct = 1, switime; stack&lt;int&gt; s; //avl int ctavl(int root){ if(root == 0) return 0; int h1 = ctavl(tree[root][0]); int h2 = ctavl(tree[root][1]); if( abs(h1 - h2) &gt; 1) navln ++; return max(h1, h2) + 1; } //å±‚åºéå†åŒæ—¶å­˜å‚¨ é€†å±‚åºéå†çš„é¡ºåºä»¥ä¾¿è°ƒæ•´å †ï¼ void isctree(int root){ int nt = 1; queue&lt;int&gt; que, lay; que.push(root); lay.push(1); while(que.size()){ int u = que.front(); que.pop(); int ll = lay.front(); lay.pop(); s.push(u); layer[ll] ++; // cout &lt;&lt; u &lt;&lt; endl; if( tree[u][0] ){ que.push(tree[u][0]); lay.push(ll + 1); nt ++; }else if(nt != n) isct = 0; if( tree[u][1] ){ que.push(tree[u][1]); lay.push(ll + 1); nt ++; }else if(nt != n) isct = 0; } } // å‘ä¸‹è°ƒæ•´ å¤§é¡¶å † void downAdjust(int root){ for(int p = tree[root][0];p !=0; p = tree[root][0]){ int pp = tree[root][1]; if(val[pp] &gt; val[p]) p = pp; if(val[p] &lt; val[root]) break; swap( val[root], val[p]); switime ++; root = p; } } int main(){ string s1, s2; cin &gt;&gt; n; for(int i = 0;i &lt; n; i++){ cin &gt;&gt; val[i]; } for(int i = 1;i &lt;= n; i++){ cin &gt;&gt; s1 &gt;&gt; s2; if(s1 != &quot;-&quot;){ tree[i][0] = atoi(s1.c_str()); ingree[atoi(s1.c_str())]++; } if(s2 != &quot;-&quot;){ tree[i][1] = atoi(s2.c_str()); ingree[atoi(s2.c_str())]++; } } int rt = -1; for(int i = 0;i &lt; n; i++) if( ingree[i] == 0) rt = i; // cout &lt;&lt; rt ; ctavl(rt); if(navln != 0) cout &lt;&lt; &quot;NOT AVL TREE!!!\\n&quot; &lt;&lt; navln &lt;&lt; endl; else{ isctree(rt); int p = 1, noden = 1; while(noden == layer[p]){ noden *= 2; p++; } if(!isct) cout &lt;&lt; &quot;NOT COMPLETE TREE!!!\\n&quot; &lt;&lt; p - 1 &lt;&lt; endl; else{ while(s.size()){ int u = s.top(); s.pop(); downAdjust(u); } cout &lt;&lt; &quot;OHHHHH HEAP!!!\\n&quot; &lt;&lt; switime &lt;&lt; endl; } } }","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/pat-feng-ge-er-cha-shu-zong-jie/"},{"title":"é¢è¯•é¢˜ 04.09. BST Sequences LCCI","text":"é¢è¯•é¢˜ 04.09. BST Sequences LCCIæ‡µæ ‘ä¸‹ä½ å’Œæˆ‘ï¼Œå¿«ä¹åˆ·åˆ·é¢˜ æ€è·¯äºŒå‰æ ‘çš„æ„å»ºï¼Œæ˜¯ä»æ ¹èŠ‚ç‚¹å¼€å§‹çš„ï¼Œæ¯æ„å»ºçš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°±æ·»åŠ äº†ä¸€ä¸ªå¯èƒ½ä¸¤ä¸ªæ–°æ‰©å±•èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å…¶ä¸­ä»»æ„é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹æ–°æ„å»ºï¼Œå¦‚æ­¤é€’å½’ä¸‹å»ï¼Œå®Œæˆæ•´æ£µæ ‘çš„æ„å»ºã€‚ é‚£ä¹ˆï¼Œæˆ‘ä»¬éœ€è¦æ¨¡æ‹Ÿæ•´æ£µæ ‘çš„æ„å»ºéå†è¿‡ç¨‹ï¼Œç”¨dequeå­˜å‚¨æ¯æ¬¡æ„å»ºæ—¶å¯ä»¥é€‰æ‹©çš„èŠ‚ç‚¹ï¼Œé€’å½’æ„é€ ã€‚å¦‚æœdequeä¸ºç©ºï¼Œè¯´æ˜å»ºæ„å®Œæˆï¼ŒæŠŠè®°å½•æ„å»ºé¡ºåºçš„pathåŠ å…¥ç­”æ¡ˆå³å¯ã€‚å»ºæ„å®Œæˆåå›æº¯è¿›è¡Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æ„å»ºã€‚ ä»£ç ï¼š/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { vector&lt;vector&lt;int&gt;&gt; ansSet; vector&lt;int&gt; path; deque&lt;TreeNode*&gt; que; public: vector&lt;vector&lt;int&gt;&gt; BSTSequences(TreeNode* root){ if(root) que.push_back(root); BSTSequencesCore(); return ansSet; } void BSTSequencesCore() { if(que.size() == 0){ ansSet.push_back(path); return; } for(int i = 0, size = que.size(); i &lt; size; ++i){ auto node = que.front(); que.pop_front(); path.push_back(node-&gt;val); if(node-&gt;left) que.push_back(node-&gt;left); if(node-&gt;right) que.push_back(node-&gt;right); // é€‰æ‹©æœ‰æ•ˆèŠ‚ç‚¹ï¼Œè¿›å…¥é€’å½’ BSTSequencesCore(); // å›æº¯çŠ¶æ€ path.pop_back(); if(node-&gt;left) que.pop_back(); if(node-&gt;right) que.pop_back(); que.push_back(node); // å›æº¯çŠ¶æ€è¦é€†åºâ€˜â€™ } } };","link":"/2021/04/01/shua-ti/shu-ju-jie-gou/shu/mian-shi-ti-04-09-bst-sequences-lcci/"},{"title":"148. æ’åºé“¾è¡¨","text":"148. æ’åºé“¾è¡¨æˆ‘å†™è¿‡æœ€ç´¯æœ€çƒ¦çš„é“¾è¡¨é¢˜ï¼Œå¾ªç¯å½’å¹¶æ’åºæ€è·¯æ¯”è¾ƒå¥½æƒ³ï¼Œä½†æ˜¯å®¹æ˜“é”™ï¼Œéå¸¸å®¹æ˜“é”™ï¼Œå“ˆå“ˆã€‚ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* midNode(ListNode* head, ListNode* end = nullptr){ ListNode* fastp = head, *slowp = head; while(fastp){ fastp = fastp-&gt;next; if(fastp) fastp = fastp-&gt;next; slowp = slowp-&gt;next; } return slowp; } ListNode *split(ListNode* node, int nums){ ListNode* p = node; if(p == nullptr) return nullptr; int k = 1; while(k &lt; nums &amp;&amp; p-&gt;next){ p = p-&gt;next; ++k; } ListNode *ans = p-&gt;next; p-&gt;next = nullptr; return ans; } ListNode* merger(ListNode* heada, ListNode* headb, ListNode* &amp;pre) { ListNode *p1 = heada, *p2 = headb, *head = new ListNode(), *p = head; if(!p1 &amp;&amp; !p2){ pre-&gt;next = nullptr; return nullptr; } while(p1 &amp;&amp; p2){ if(p1-&gt;val &lt; p2-&gt;val){ p-&gt;next = p1; p1 = p1-&gt;next; }else{ p-&gt;next = p2; p2 = p2-&gt;next; } p = p-&gt;next; } p-&gt;next = p1 ? p1 : p2; while(p-&gt;next) p = p-&gt;next; // link prenode and endnode. if(pre) pre-&gt;next = head-&gt;next; pre = p; // return merged list head; p = head-&gt;next; delete head; //print(p, &quot;p-&gt;next&quot;); return p; } ListNode* sortList(ListNode* head) { ListNode* p1 = head, *p2 = head; ListNode * prehead = new ListNode(); prehead-&gt;next = head; int flag = 1; for(int i = 1; flag; i *= 2){ ListNode* pre = prehead; ListNode * nextp1 = prehead-&gt;next; // #bug: nextp1 = headï¼› but head has be reset. flag = 0; p2 = prehead; // @reset p2 //print(prehead, &quot;@&quot;); while(p2){ flag++; p1 = nextp1; p2 = split(p1, i); nextp1 = split(p2, i); // print(p1, &quot;p1&quot;); // print(p2, &quot;p2&quot;); merger(p1, p2, pre); // merge and link. // print(prehead, &quot;#&quot;); if(p1 == prehead-&gt;next &amp;&amp; !p2 &amp;&amp; flag == 1) flag = 0; } } head = prehead-&gt;next; delete prehead; return head; } void print(ListNode* head, string s = &quot;@&quot;){ cout &lt;&lt; s + &quot;:&quot; ; while(head){ cout &lt;&lt; head-&gt;val &lt;&lt; ' '; head = head-&gt;next; } cout &lt;&lt;endl; } };","link":"/2021/03/31/shua-ti-shu-ju-jie-gou-lian-biao-148-pai-xu-lian-biao/"},{"title":"42. Trapping Rain Water","text":"42. Trapping Rain Wateræ€è·¯ï¼šè¿™é¢˜è›®hardçš„ï¼ŒæŒºè€ƒéªŒæ€è·¯ï¼› æ€è€ƒä¸€ä¸‹ï¼Œä¸‹é›¨çš„è¿‡ç¨‹ï¼Œæ°´å¾€ä½å¤„æµï¼Œä¸€ç‚¹ä¸€ç‚¹æ±‡èšèµ·æ¥ï¼Œé€æ¸é€æ¸å‡é«˜æ°´é¢ã€‚æˆ‘ä»¬æ˜¯å¦å¯ä»¥åœ¨å…ˆæ±‚å‡ºä½æ°´å¹³é¢çš„æ°´é‡ï¼Œåœ¨æ­¤ä¹‹ä¸Šæ±‚å‡ºé«˜æ°´å¹³é¢çš„æ°´é‡ã€‚ 43234ä¸­å°±æœ‰ä¸¤ä¸ªæ°´æ²Ÿï¼š2ä¸Šçš„1*1çš„æ°´æ²Ÿï¼Œå’Œ323ä¸Šçš„3*1æ°´æ²Ÿã€‚ ç”¨è¿™ç§æƒ³æ³•ï¼Œæˆ‘ä»¬åªéœ€è¦éå†å¾—åˆ°ä¸€ä¸ªæ°´å¹³é¢çš„å³è¾¹ç•Œï¼Œè®°å½•è¯¥æ°´å¹³é¢çš„å·¦è¾¹ç•Œï¼Œè·å–ä½æ°´å¹³é¢çš„é«˜åº¦ï¼Œå¡«å……ä¸‹æ–°æ°´å¹³é¢çš„æ°´é‡å³å¯ã€‚ æœ€å°å€¼å•è°ƒæ ˆSå¯ä»¥å¸®åŠ©æˆ‘ä»¬ç»´æŒå·¦è¾¹ç•Œçš„posï¼Œè®°Sçš„æ ˆé¡¶å…ƒç´ æŒ‡å‘çš„é«˜åº¦ä¸ºaï¼Œaä¹‹ä¸‹çš„å…ƒç´ æŒ‡å‘çš„é«˜åº¦ä¸ºbã€‚å…¶æ€§è´¨å¿…ç„¶æœ‰a &gt; bã€‚éå†åˆ°é«˜åº¦cï¼Œ è‹¥c &lt; aï¼Œåˆ™å¯¹è“„æ°´æ²¡æœ‰å½±å“ã€‚ å¦‚æœc &gt; bï¼Œåˆ™ä¸‰è€…å½¢æˆäº†ä¸€ä¸ªæ°´æ²Ÿï¼Œè®¡ç®—ğŸ¦å¼å­è§ä»£ç ï¼Œå¹¶ä¸”è¯¥æ°´æ²Ÿå¯èƒ½å¯ä»¥ç»§ç»­å¾€ä¸Šâ€œçœ‹çœ‹â€ï¼Œåœ¨é€‚å½“æ¡ä»¶ä¸Šçœ‹çœ‹å•è°ƒæ ˆï¼Œå¾ªç¯å¡«å……é«˜æ°´ä½æ°´æ²Ÿã€‚ å¦‚æœc==aï¼Œåˆ™æ˜¾ç„¶åº”è¯¥æ›¿æ¢æ‰aï¼Œå› ä¸ºå•è°ƒæ ˆç»´æŒçš„æ˜¯ç­‰é«˜æ°´æ²Ÿçš„æœ€æ–°ç«¯ï¼Œè¯•æƒ³33323ã€‚ ç»è¿‡ä¸Šè¿°å¡«å……è¿‡ç¨‹ï¼Œå•è°ƒæ ˆçš„æ€§è´¨ä¹Ÿè¦ç»´æŠ¤ä¸€ä¸‹ï¼Œè¯¦ç»†è§ä»£ç ã€‚ ä»£ç ï¼š class Solution { public: int trap(vector&lt;int&gt;&amp; height) { if(height.size() &lt;= 1) return 0; stack&lt;int&gt; sck; int amount = 0; for(int i = 0; i &lt; height.size(); ++i){ while(sck.size() &gt;= 2 &amp;&amp; height[sck.top()] &lt;= height[i]){ int lowh = height[sck.top()]; sck.pop(); amount += (i - sck.top() - 1) * (min(height[i], height[sck.top()]) - lowh); // cout &lt;&lt; amount &lt;&lt; endl; } while(!sck.empty() &amp;&amp; height[sck.top()] &lt;= height[i]) sck.pop(); // &lt;= æŒ‰æ¬¡åºå‡ºç°çš„ç­‰é«˜çš„å±±å³°A,Bï¼Œ æ˜æ˜¾çš„æœ‰ABå¡«å……äº†æ°´é‡ï¼Œä¸‹ä¸€ä¸ªè¢«å¡«å……çš„åº”è¯¥æ˜¯B,æ‰€ä»¥Aå¿…é¡»è¢«pop if(sck.empty() || height[i] &lt; height[sck.top()]) sck.push(i); } return amount; } };","link":"/2021/04/16/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-42-trapping-rain-water/"},{"title":"739. Daily Temperatures","text":"739. Daily Temperaturesæ€è·¯ï¼š å•è°ƒæ ˆï¼›ç”¨å•è°ƒæ ˆç»´æŠ¤ä»åå¾€å‰éå†å½“å‰å…ƒç´ çš„æœ€å¤§å€¼ï¼Œä¾¿å¯ä»¥è½»æ¾è·å–å½“å‰å…ƒç´ ä¹‹åçš„æœ€å¤§å€¼ä¸‹æ ‡ï¼Œå³å¯ä»¥æ›´æ–°ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ çš„æ—¶é—´å·®ã€‚ KMPå¤±è´¥åŒ¹é…ç®—æ³•ï¼›ä»åå¾€å‰éå†ï¼Œå½“å‰å…ƒç´ çš„æ›´å¤§å€¼è¦ä¹ˆæ˜¯å½“å‰å…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè¦ä¹ˆæ˜¯ä¸‹ä¸€ä¸ªå…ƒç´ çš„æ›´å¤§å€¼ï¼Œè¦ä¹ˆæ˜¯ä¸‹ä¸€ä¸ªå…ƒç´ çš„æ›´å¤§å€¼çš„æ›´å¤§å€¼â€¦â€¦å¦‚æ­¤â€œé€’å½’â€æŸ¥æ‰¾å¯å¾—ä¸‹ä¸€ä¸ªæœ€å¤§å€¼ã€‚å¦‚æœæŸ¥æ‰¾ä¸åˆ°ï¼Œå°±ä¸å­˜åœ¨æœ€å¤§å€¼ã€‚ æ€è·¯ï¼šclass Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { int n = T.size(); stack&lt;int&gt; pos, val; vector&lt;int&gt; day(n); for(int i = n - 1; i &gt;= 0; --i){ if(!val.empty()){ while(val.size() &amp;&amp; val.top() &lt;= T[i]){ val.pop(); pos.pop(); } } if(val.empty()) day[i] = 0; else day[i] = pos.top() - i; if(val.empty() || val.top() &gt;= T[i]){ pos.push(i); val.push(T[i]); } } return day; } }; ç®€åŒ–ç‰ˆ class Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { int n = T.size(); stack&lt;int&gt; pos, val; vector&lt;int&gt; day(n); for(int i = n - 1; i &gt;= 0; --i){ while(val.size() &amp;&amp; val.top() &lt;= T[i]){ val.pop(); pos.pop(); } if(val.size())day[i] = pos.top() - i; if(val.empty() || val.top() &gt;= T[i]){ // å–smallerå…ƒç´ åŠ å…¥é˜Ÿåˆ—ï¼Œä¹Ÿå¯ä»¥ç›´æ¥æ·»åŠ ï¼Œæ¯•ç«Ÿä¸Šé¢æœ‰pop; pos.push(i); val.push(T[i]); } } return day; } }; // KPMæ„é€ æ•°ç»„æ€è·¯å¯å‘å¾—æ¥ class Solution { public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { int n = T.size(); vector&lt;int&gt; day(n); for(int i = n - 2; i &gt;= 0; --i){ int pos = i + 1; while(T[pos] &lt;= T[i]){ // å°½é‡ä»dayåç§»æ›´å¤šå…ƒç´  if(day[pos] == 0) break; // æ­¤åæ²¡æœ‰æ›´å¤§çš„å…ƒç´  pos += day[pos]; } if(T[pos] &gt; T[i]) day[i] = pos - i; } return day; } };","link":"/2021/01/23/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-739-daily-temperatures/"},{"title":"84. Largest Rectangle in Histogram","text":"84. Largest Rectangle in Histogramæ€è·¯ï¼š éå†é«˜åº¦æ•°ç»„çš„åŒæ—¶ï¼Œç»´æŠ¤å½¢æˆçš„çŸ©é˜µï¼Œå¹¶æ›´æ–°æœ€å¤§é¢ç§¯ã€‚ è§‚å¯Ÿï¼ŒçŸ©é˜µçš„é¢ç§¯å¯ä»¥ä¸ä¸¥æ ¼é€’å¢çš„æƒ…å†µä¸‹åœ¨ä»å·¦åˆ°å³æ‰©å±•çš„ï¼Œå†ä¸¥æ ¼é€’å‡çš„æƒ…å†µä¸‹å¯ä»¥ç¡®å®šå‡ºçŸ©é˜µé¢ç§¯ã€‚æ­£å‘æ•°æ®ç¼“å­˜ï¼Œé€†å‘é¢ç§¯è®¡ç®—-&gt; å•è°ƒæ ˆã€‚read more ä»£ç ï¼šclass Solution { map&lt;int, pair&lt;int,int&gt;&gt; reg; public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int maxarea = 0; for(int i = 0; i &lt; heights.size(); ++i){ for(auto &amp;item : reg){ auto high = item.first; auto &amp;pii = item.second; auto l = pii.first; auto &amp;r = pii.second; if(high &gt; heights[i]){ reg.insert({heights[i], {l, i}}); maxarea = max(maxarea, heights[i] *(i - l + 1)); reg.erase(reg.find(high), reg.end()); break; } else if(high &lt;= heights[i]){ r = i; maxarea = max(high * (r - l + 1), maxarea); } } if(reg.count(heights[i]) == 0){ reg.insert({heights[i], {i, i}}); maxarea = max(maxarea, heights[i]); } } return maxarea; } }; class Solution { stack&lt;int&gt; s; public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int maxarea = 0; heights.push_back(0); // ä¸ºäº†è®¡ç®—æ‰€æœ‰é¢ç§¯ for(int i = 0; i &lt; heights.size(); ++i){ if(s.empty()) s.push(i); else if(heights[s.top()] &lt; heights[i]) s.push(i); else if(heights[s.top()] == heights[i]) s.top() = i; // å¦‚æœç›¸é‚»çš„é«˜åº¦ç›¸åŒï¼Œåˆ™æ›´æ–°ï¼›å› ä¸ºä¸æ›´æ–°å•è°ƒæ ˆä¸­çŸ©é˜µå·¦è¾¹ç•Œä¼šæ‰©å±•æ›´å¤š else if(heights[s.top()] &gt; heights[i]){ while(!s.empty() &amp;&amp; (heights[s.top()] &gt; heights[i])){ int high = heights[s.top()]; s.pop(); int temparea = ( i - (s.empty() ? -1 : s.top()) - 1) * high; maxarea = max(maxarea, temparea); } s.push(i); } } return maxarea; } }; å½“ç„¶ï¼Œè¿™é‡Œä¹Ÿå¯ä»¥æ·»åŠ ä¸€ä¸ªå“¨å…µï¼Œä¸è¿‡æ²¡ä»€ä¹ˆå½±å“ã€‚","link":"/2021/04/30/shua-ti-shu-ju-jie-gou-zhan-he-dui-lie-dan-diao-zhan-84-largest-rectangle-in-histogram/"},{"title":"é¢è¯•é¢˜ äºŒå‰æ ‘","text":"æ”¶é›†äºŒå‰æ ‘ç›¸å…³é¢˜ç›®ï¼Œç›¸å…³æµ‹è¯•ä»£ç è§æ­¤ã€‚ sCmd = â€˜C:; cd C:\\Users\\xusx\\Sumo\\SUMO\\bin; duarouter -n xsxlankershim.net.xml â€“route-files xsx.flow.xml -o rou.rou.xmlâ€™os.system(sCmd) ç»“æ„struct BinaryTreeNode{ double dbValue; BinaryTreeNode *pLeft; BinaryTreeNode *pRight; } é¢7ï¼šä¸­åºéå†å’Œå‰åºéå†åºåˆ—æ¥é‡å»ºäºŒå‰æ ‘BinaryTreeNode* ConstructNode(int *startPreorder, int *endPreordrer, int *startInorder, int *endInorder){ //è¿™ä¸ªä»£ç å¥å£®æ€§å°±å¾ˆå¥½ï¼å¯¹ç©ºå€¼å’Œéæ³•è¾“å‡ºè¿›è¡Œäº†åŒºåˆ†ã€‚ if(startPreorder &gt; endPreorder || startInorder &gt; endInorder ){ if(startPreorder == endPreorder - 1 &amp;&amp; startInorder == endInorder - 1) return nullptr; else throw std::exception(&quot;Invalid Input.\\n&quot;); } //å¯»æ‰¾ä¸­åºéå†ä¸­çš„æ ¹èŠ‚ç‚¹å€¼åæ ‡ int nodeValue = startPreordre[0]; int *rootInorder = startInorder; for(; rootInorder &lt;= enInorder &amp;&amp; *rootInordre != nodevalue; rootInorder++); //å¥å£®ä¸€ä¸‹ if(enInorder &lt; rootInorder){ throw std::exception(&quot;Invalid input!\\n&quot;); } //æ„å»ºå·¦å³å­æ ‘ BinaryTreeNode* pNode = new BinaryTreeNode(); int lNodeNum = rootInorder - startInorder; pNode-&gt;pLeft = ConstructNode(startPreorder + 1, startPreorder + lNodeNum, startInorder, rootInorder - 1); pNode-&gt;pRight = ConstructNode(startPreorder + lNodeNum + 1, endPreorder, rootInorder + 1, endInorder); pNode-&gt;value = nodeValue; return pNode; } BinaryTreeNode* ConstructTree(int *preorder, int *inorder, int length){ //length == 0çš„ä»£ç çš„å¥å£®æ€§æ˜¾ç„¶ä¸å¦‚ length &lt;= 0 if(preorder == null || inorder == null || length &lt;= 0) return nullptr; return ConstructNode(preorder, preorder + length - 1 , inorder, inorde + length - 1); } é¢8ï¼šäºŒå‰æ ‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ç¬¬ä¸€æ¬¡è€ƒè™‘çš„æ—¶å€™å±…ç„¶è¿˜æƒ³é”™äº†ï¼Œåˆ†æä¸å¤Ÿå…¨é¢ã€‚ä»äºŒå‰æ ‘ä¸­åºéå†æ¥çœ‹ï¼Œè‹¥ä¸€ä¸ªèŠ‚ç‚¹æœ‰å³å­æ ‘ï¼Œåˆ™ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯å…¶å³å­æ ‘çš„æœ€å·¦èŠ‚ç‚¹ã€‚å€˜è‹¥æ²¡æœ‰ï¼Œåˆ™å¿…ç„¶æ˜¯è€ƒè™‘çˆ¶äº²èŠ‚ç‚¹ã€‚å¦‚æœè¯¥èŠ‚ç‚¹æ˜¯çˆ¶äº²èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¸‹ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯çˆ¶äº²èŠ‚ç‚¹ï¼Œä¸ç„¶å¯ä»¥æº¯æºæŸ¥æ‰¾å…¶çˆ¶è¾ˆèŠ‚ç‚¹æ˜¯å·¦å­æ ‘çš„ç¥–çˆ¶èŠ‚ç‚¹ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥ä½¿ç”¨çˆ¶äº²èŠ‚ç‚¹å’Œè¿­ä»£å®Œæˆã€‚ BinaryTreeNode *GetNext(BinaryTreeNode *pNode){ if(pNode == nullptr) return; if(pNode-&gt;pRight){ BinaryTreeNode* pChild = pNode-&gt;pRight; while(pChild-&gt;pLeft != nullptr) pChild = pChild-&gt;pRight; return pChild; }else{ BinaryTreeNode* pParent = pNode-&gt;pParent, *pCurrent = pNode; //å¾ªç¯æ§åˆ¶æ¡ä»¶æœ‰ç‚¹åƒå“¨å…µï¼Œæ²¡æœ‰æ‰¾åˆ°çš„è¯pParentè‡ªç„¶å°±æ˜¯unllptr,ä»£ç æ›´åŠ ç®€æ´äº† while(pParent != nullptr &amp;&amp; pParent-&gt;pRight != pCurrent){ pCurrent = pParent; pParent = pParent-&gt;pParent; } return pParent; } return nullptr; } ç›¸æ¯”ä¹‹å‰çš„ä»£ç è¿™ä¸ªå†™æ³•å·®ä¸€ç‚¹ç‚¹ while(pParent-&gt;pParent != nullptr &amp;&amp; pParent-&gt;pRight != pCurrent){ pCurrent = pParent; pParent = pParent-&gt;pParent; } if(pParent-&gt;pRight == pCurrent){ return pParent; } é¢26ï¼šæ ‘çš„å­ç»“æ„é¢˜é¢ï¼šè¾“å…¥ä¸¤æ£µæ ‘Aå’ŒBï¼Œåˆ¤æ–­Bæ˜¯å¦æ˜¯Açš„å­ç»“æ„ã€‚Bæ˜¯Açš„å­ç»“æ„å­ç»“æ„å®šä¹‰ä¸ºAçš„ä¸€éƒ¨åˆ†å’ŒBå®Œå…¨ç›¸åŒã€‚ æ€è·¯ï¼šé€’å½’çš„åˆ¤æ–­å¯¹Açš„æ¯ä¸€ä¸ªèŠ‚ç‚¹åˆ¤æ–­è¯¥èŠ‚ç‚¹ä¸‹çš„æ˜¯å¦æœ‰Bçš„ç»“æ„ã€‚ ä»£ç ï¼šbool judgeSameTree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot2 == nullptr) return true; else if(pRoot1 == nullptr) return false; if(equal(pRoot1-&gt;dbValue, pRoot2-&gt;dbValue)){ if(pRoot2-&gt;pRight == nullptr &amp;&amp; pRoot2-&gt;pLeft == nullptr) return true; return judgeSameTree(pRoot1-&gt;pLeft, pRoot2-&gt;pLeft) &amp;&amp; judgeSameTree(pRoot2-&gt;pRight, pRoot2-&gt;pRight); } return false; } bool HasSubtreeCore(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot1){ if(judgeSameTree(pRoot1, pRoot2)) return true; else return HasSubtreeCore(pRoot1-&gt;pLeft, pRoot2) || HasSubtreeCore(pRoot1-&gt;pRight, pRight); } return false; } bool HasSubtree(BinaryTreeNode *pRoot1, BinaryTreeNode *pRoot2){ if(pRoot2 == nullptr) return true; if(pRoot1 == nullptr) return false; return HasSubtreeCore(pRoot1, pRoot2); } æµ‹è¯•ï¼šå‚è§ é¢27ï¼šç¿»è½¬äºŒå‰æ ‘é¢˜é¢ï¼šç»™å‡ºä¸€æ£µäºŒå‰æ ‘å¹¶è¿”å›å…¶é•œåƒäºŒå‰æ ‘ã€‚ æ€è·¯ï¼šç›´æ¥äº¤æ¢èŠ‚ç‚¹çš„å·¦å³æŒ‡é’ˆèŠ‚ç‚¹å³å¯ã€‚ ä»£ç ï¼šBinaryTreeNode *MirrorRecursively(BinaryTreeNode* pNode){ if(pNode == nullptr) return nullptr; BinaryTreeNode *pTemp = pNode-&gt;pRight; pNode-&gt;pRight = pNode-&gt;pLeft; pNode-&gt;pLeft = pTemp; MirrorRecursively(pNode-&gt;pLeft); MirrorRecursively(pNode-&gt;pRight); return pNode; } é¢28ï¼šå¯¹ç§°äºŒå‰æ ‘é¢˜é¢ï¼šåˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦å¯¹ç§°ã€‚ æ€è·¯ï¼šä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å·¦å­æ ‘å¼€å§‹é€’å½’çš„åˆ¤æ–­ï¼Œå…¶å³å­æ ‘çš„èŠ‚ç‚¹æ˜¯å¦å®Œå…¨ç›¸åŒã€‚åªéœ€è¦ä¸€è¾¹å¯¹å¦ä¸€è¾¹é•œåƒæ“ä½œå°±okã€‚ ä»£ç ï¼šbool isSymmetrical(BinaryTreeNode* pHead){ if(pHead == nullptr) return true; return isSymmetricalCore(pHead-&gt;pLeft, pHead-&gt;pRight); } bool isSemmetricalCore(BinaryTreeNode *p1, BinaryTreeNode *p2){ if(p1 == nullptr &amp;&amp; p2 == nullptr) return true; if(p1 == nullptr &amp;&amp; p2 != nullptr || p2 == nullptr &amp;&amp; p1 != nullptr || p1-&gt;value != p2-&gt;value) return false; return isSemmetricalCore(p1-&gt;left, p2-&gt;right) &amp;&amp; isSemmetricalCore(p1-&gt;right, p2-&gt;left); } æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘è¿™ç§å†™æ³•ä¹Ÿå¯ä»¥çœ‹æˆå‰åºéå†åºåˆ—å’Œå¯¹ç§°å‰åºéå†åºåˆ—çš„æ¯”è¾ƒã€‚ é¢32ï¼šå±‚åºéå†äºŒå‰æ ‘é¢˜é¢ï¼šå¦‚æ ‡é¢˜ æ€è·¯ï¼šå±‚åºéå† ä»£ç ï¼švoid PrintByLayer(BinaryTreeNode* pHead){ if(pHead == nullptr) return; queue&lt;BinaryTreeNode*&gt; que; que.push(pHead); while(que.size()){ BinaryTreeNode *pNode = que.front(); que.pop(); printf(&quot;%.2f &quot;, pNode-&gt;dbValue); if(pNode-&gt;pLeft) que.push(pNode-&gt;pLeft); if(pNode-&gt;pRight) que.push(pNode-&gt;pRight); } printf(&quot;\\n&quot;); } é¢32ç›¸å…³é¢˜ï¼šåˆ†è¡Œæ‰“å°å±‚åºéå†äºŒå‰æ ‘é¢˜é¢ï¼šå¦‚æ ‡é¢˜ æ€è·¯ï¼šåœ¨å±‚åºéå†çš„åŸºç¡€ä¸Šï¼Œæœ‰ä¸¤ç§è§£é¢˜æ€è·¯ï¼šä¸€æ˜¯è®°å½•å½“å‰å±‚æœªæ‰“å°çš„èŠ‚ç‚¹æ•°é‡å’Œä¸‹ä¸€å±‚çš„éœ€è¦æ‰“å°çš„èŠ‚ç‚¹æ•°é‡ï¼ŒäºŒæ˜¯åœ¨é˜Ÿåˆ—ä¸­æ·»åŠ ä¸€ä¸ªä¸€å±‚çš„èŠ‚ç‚¹æœ«ç«¯çš„æ ‡å¿—ç¬¦ã€ ä»£ç ï¼švoid PrintByLayerSparate(BinaryTreeNode* pHead){ if(pHead == nullptr) return; queue&lt;BinaryTreeNode*&gt; que; que.push(pHead); int printValue = 1, nextValue = 0; while(que.size()){ BinaryTreeNode *pNode = que.front(); que.pop(); printValue--; printf(&quot;%.2f &quot;, pNode-&gt;dbValue); if(pNode-&gt;pLeft){ que.push(pNode-&gt;pLeft); nextValue++; } if(pNode-&gt;pRight){ que.push(pNode-&gt;pRight); nextValue++; } if(printValue == 0){ printValue = nextValue; nextValue = 0; printf(&quot;\\n&quot;); } } } é¢32ç›¸å…³é¢˜ï¼šä¹‹å­—å½¢æ‰“å°äºŒå‰æ ‘é¢˜é¢ï¼šå¦‚æ ‡é¢˜ æ€è·¯ï¼šä¸€ç§æ–¹æ³•å°±æ˜¯åˆ†å±‚å±‚åºéå†+æ ˆé€†åºå­˜å‚¨å¹¶è¾“å‡ºã€‚ ç¬¬äºŒç§æ–¹æ³•å°±ç”¨æ ˆæŠŠä¸€å±‚çš„èŠ‚ç‚¹é€†åºè¾“å‡ºï¼Œå¹¶å°†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹è®°å½•åœ¨å¦ä¸€ä¸ªæ ˆä¸­ï¼Œå¦‚æ­¤å¾ªç¯ï¼Œè¾“å‡ºæ‰€æœ‰çš„å±‚ã€‚ ä»£ç ï¼švoid PirntZhi(BinaryTreeNode *pHead){ if(pHead == nullptr) return; stack&lt;BinaryTreeNode*&gt; s[2]; int cur = 0; s[cur].push(pHead); BinaryTreeNode *pNode = nullptr; while(s[cur].size()){ while(s[cur].size()){ pNode = s[cur].top(); s[cur].pop(); printf(&quot;%.2 &quot;, pNode-&gt;dbValue); if(cur == 0){ if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft); if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight); }else{ if(pNode-&gt;pRight) s[1 - cur].push(pNode-&gt;pRight); if(pNode-&gt;pLeft) s[1 - cur].push(pNode-&gt;pLeft); } } printf(&quot;\\n&quot;); cur = 1- cur; } } 103. Binary Tree Zigzag Level Order Traversal/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { if(!root) return {}; stack&lt;TreeNode*&gt; cur1, cur2; cur1.push(root); vector&lt;vector&lt;int&gt;&gt; zigarr; int flag = 1; while(cur1.size() || cur2.size()){ if(flag) zigview(cur1, cur2, zigarr, flag), flag = 1 - flag ; else zigview(cur2, cur1, zigarr, flag), flag = 1 - flag; } return zigarr; } void zigview(stack&lt;TreeNode*&gt;&amp; now, stack&lt;TreeNode*&gt;&amp; next, vector&lt;vector&lt;int&gt;&gt; &amp;zigarr, int flag){ vector&lt;int&gt; arr; while(!now.empty()){ arr.push_back(now.top()-&gt;val); if(flag){ if(now.top()-&gt;left) next.push(now.top()-&gt;left); if(now.top()-&gt;right) next.push(now.top()-&gt;right); now.pop(); }else{ if(now.top()-&gt;right) next.push(now.top()-&gt;right); if(now.top()-&gt;left) next.push(now.top()-&gt;left); now.pop(); } } zigarr.push_back(arr); } }; é¢33:åˆ¤æ–­ååºéå†åºåˆ—æœ‰æ•ˆæ€§é¢˜é¢ï¼šç»™å®šä¸€é¢—äºŒå‰æœç´¢æ ‘çš„åç»­éå†åºåˆ—ï¼Œåˆ¤æ–­è¯¥ååºéå†åºåˆ—æ˜¯å¦åˆæ³•ã€‚ æ€è·¯ï¼šä¾æ®åç»­éå†çš„å®šä¹‰ï¼Œå¯ä»¥æŠŠåºåˆ—ä¾æ®æœ€åä¸€ä¸ªå…ƒç´ Kåˆ†æˆä¸¤åŠï¼Œä¸”æ»¡è¶³å‰ä¸€éƒ¨åˆ†å…¨éƒ¨å°äºKçš„å€¼ï¼Œåä¸€éƒ¨åˆ†å…¨éƒ¨å¤§äºKçš„å€¼ï¼Œè‹¥ä¸ç¬¦åˆè¿™ä¸ªç»“è®ºï¼Œåˆ™è¯¥ååºéå†ä¸å¯èƒ½å­˜åœ¨ä¸€é¢—äºŒå‰æ ‘ä¸ä¹‹å¯¹åº”ã€‚é€’å½’çš„åˆ¤æ–­è¿™ä¸¤éƒ¨åˆ†æ˜¯å¦ç¬¦åˆè¿™äº›å®šä¹‰ã€‚ ä»£ç ï¼šbool isPostSequenceCore(int sequence[], int start, int end){ if(start &gt;= end) return true; int key = sequence[end - 1]; int split = start; while(sequence[split] &lt; key) split++; for(int i = split; i &lt; end; i++){ if(sequence[i] &lt; key) return false; } return isPostSequenceCore(sequence, start, split) &amp;&amp; isPostSequenceCore(sequence, split, end - 1); } bool isPostSequence(int sequence[], int len){ if(sequence == nullptr || len &lt;= 0) return false; return isPostSequenceCore(sequence, 0, len); } å¦‚æœæ˜¯c++çš„è¯ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ç”¨æŒ‡é’ˆä»£æ›¿startã€‚ é¢34ï¼šæ ‘çš„è·¯å¾„çš„å…ƒç´ ä¹‹å’Œé¢˜é¢ï¼šæ‰“å°å‡ºæ ‘çš„è·¯å¾„ä¸Šçš„å€¼ä¹‹å’Œä¸ç»™å®šæ•°å­—ç›¸åŒçš„æ‰€æœ‰è·¯å¾„ã€‚è·¯å¾„ä»æ ¹åˆ°å¶å­ã€‚ æ€è·¯ï¼šdfséå† + è®°å½•è·¯å¾„å³å¯ã€‚ ä»£ç ï¼švoid PrintPathCore(BinaryTreeNode* pNode, stack&lt;int&gt; &amp;s, int add, int expectedSum){ s.push((int)pNode-&gt;dbValue); add += (int)(pNode-&gt;dbValue); if(pNode-&gt;pLeft == nullptr &amp;&amp; pNode-&gt;pRight == nullptr){ if(add == expectedSum){ stack&lt;int&gt; sTemp; while(s.size()){ sTemp.push(s.top()); s.pop(); } while(sTemp.size()){ printf(&quot;%d-&gt;&quot;, sTemp.top()); s.push(sTemp.top()); sTemp.pop(); } printf(&quot;\\n&quot;); } // printf(&quot;%d, %d, %d\\n&quot;, expectedSum, add, s.size()); s.pop(); return; } if(pNode-&gt;pLeft) PrintPathCore(pNode-&gt;pLeft, s, add, expectedSum); if(pNode-&gt;pRight) PrintPathCore(pNode-&gt;pRight, s, add, expectedSum); s.pop(); } void PrintPath(BinaryTreeNode* pHead, int expectedSum){ if(pHead == nullptr) return; stack&lt;int&gt; s; PrintPathCore(pHead, s, 0, expectedSum); printf(&quot;\\n&quot;); } ä¸­åˆæ—¶é—´ä¸è¦æ‰“ä»£ç ï¼Œå¤ªå›°äº† 437. Path Sum III è·¯å¾„ä¹‹å’Œç±»ä¼¼ï¼Œä½†ä¸ç›¸åŒã€‚ å‰ç¼€å’Œ + é€’å½’ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int count = 0; int pathSum(TreeNode* root, int sum) { add(root, 0); findNode(root, sum, 0); return count; } void findNode(TreeNode* root, int num, int presum){ if(!root) return; cal(root, num, presum); findNode(root-&gt;left, num, root-&gt;val); findNode(root-&gt;right, num, root-&gt;val); } void cal(TreeNode* root, int target, int presum){ if(!root) return; if(root-&gt;val - presum == target) count++; cal(root-&gt;left, target, presum); cal(root-&gt;right, target, presum); } void add(TreeNode* root, int presum){ if(!root) return; root-&gt;val += presum; add(root-&gt;left, root-&gt;val); add(root-&gt;right, root-&gt;val); } }; å†™æ³•äºŒï¼šæä¾›ä¸€ç§é€’å½’çš„å°å°æ€è·¯ class Solution { public: int count = 0; int pathSum(TreeNode* root, int sum) { if(!root) return 0; return cal(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); } int cal(TreeNode* root, int sum){ if(!root) return 0; sum -= root-&gt;val; return (sum == 0) + cal(root-&gt;left, sum) + cal(root-&gt;right, sum); } }; æœ€ä¼˜è§£æ³•ï¼šå‰ç¼€å’Œ + å›æº¯ + ç»´æŠ¤å‰ç¼€å’Œå‡ºç°çš„æ¬¡æ•°ï¼štimes[presum] çªç„¶æƒ³åˆ°3æ•°ä¹‹å’Œã€‚ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map&lt;int, int&gt; ct = {{0,1}}; int pathSum(TreeNode* root, int sum) { int amount = 0; dfs(root, 0, sum, amount); return amount; } void dfs(TreeNode *root, int presum, int sum, int &amp;amount){ if(!root) return; root-&gt;val += presum; amount += ct[root-&gt;val - sum]; ++ct[root-&gt;val]; dfs(root-&gt;left, root-&gt;val, sum, amount); dfs(root-&gt;right, root-&gt;val, sum, amount); --ct[root-&gt;val]; } }; é¢36ï¼šæŠŠäºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºåŒå‘é“¾è¡¨ï¼ˆåŒé“¾è¡¨ä¸­çš„å†…å®¹ï¼‰é¢˜é¢ï¼šå¦‚é¢˜ï¼Œè¦æ±‚ä¸åˆ›å»ºä»»ä½•æ–°èŠ‚ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­èŠ‚ç‚¹çš„æŒ‡å‘ã€‚è¾“å‡ºè°ƒæ•´åçš„æ’åºé“¾è¡¨ã€‚ æ€è·¯ï¼šå¯ä»¥ä»é€’å½’çš„è§’åº¦å…¥æ‰‹ã€‚å¯¹äºä¸€ä¸ªèŠ‚ç‚¹Aï¼Œä¸­åºéå†åˆ°Aï¼Œåˆ™Açš„å·¦å­æ ‘å·²ç»è½¬åŒ–ä¸ºäº†é“¾è¡¨ï¼Œè¿æ¥å¥½Aå’ŒAçš„å·¦å­æ ‘çš„æœ€å¤§èŠ‚ç‚¹ï¼ˆå‰ä¸€ä¸ªæŒ‡é’ˆï¼‰çš„æŒ‡é’ˆåˆ™è¿æ¥å®Œæˆã€‚ é‚£å¯¹äºAçš„å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹Bä¸Aä¹‹é—´çš„è¿æ¥ï¼Œä¹Ÿå¯ä»¥çœ‹æˆBä¸å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆç›¸äº’é“¾æ¥ã€‚é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦åœ¨ä¸­åºéå†çš„è¿‡ç¨‹ä¸­æ”¹å˜å‰ä¸€ä¸ªæŒ‡é’ˆçš„å†…å®¹å³å¯ã€‚ æ³¨æ„ä¸€ä¸‹æ•´æ£µæ ‘çš„æœ€å¤§çš„å³æŒ‡é’ˆå’Œæœ€å°èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆï¼Œå‘ç°éƒ½åº”è¯¥æ˜¯ç©ºï¼Œæ— éœ€é¢å¤–ä¿®æ”¹ã€‚ å¯¹äºä¸€ä¸ªèŠ‚ç‚¹Açš„å·¦å³æŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘æŒ‰é¡ºåºæ’åˆ—çš„æ—è¾¹ä¸¤ä¸ªèŠ‚ç‚¹ã€‚å¯ä»¥ç”¨ä¸­åºéå†æ¥è·å–è¯¥èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹Bçš„æŒ‡é’ˆï¼Œå¹¶è®¾ç½®å¥½Bçš„å³æŒ‡é’ˆå’ŒAçš„å·¦æŒ‡é’ˆã€‚å¦‚æ­¤å°±å¯ä»¥åœ¨ä¸­åºéå†çš„åè®¾ç½®é™¤äº†æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å³æŒ‡é’ˆï¼Œä½†æ˜¯å³æŒ‡é’ˆæœ¬æ¥å°±åº”è¯¥æ˜¯NULLï¼Œæ‰€ä»¥æ— éœ€ä¿®æ”¹ã€‚ ä»£ç ï¼švoid AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead){ if(pRoot == nullptr) return; AdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead); if(pHead == nullptr) pHead = pRoot; pRoot-&gt;pLeft = preNode; if(preNode) preNode-&gt;pRight = pRoot; preNode = pRoot; AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead); } BinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){ BinaryTreeNode *preNode = nullptr; BinaryTreeNode *pHead = nullptr; AdjustLinkCore(pRoot, preNode, pHead); return pHead; } é¢36ï¼šåºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘é¢˜é¢ï¼šåºåˆ—åŒ–å®šä¹‰ï¼š åºåˆ—åŒ– (Serialization)æ˜¯å°†å¯¹è±¡çš„çŠ¶æ€ä¿¡æ¯è½¬æ¢ä¸ºå¯ä»¥å­˜å‚¨æˆ–ä¼ è¾“çš„å½¢å¼çš„è¿‡ç¨‹ã€‚åœ¨åºåˆ—åŒ–æœŸé—´ï¼Œå¯¹è±¡å°†å…¶å½“å‰çŠ¶æ€å†™å…¥åˆ°ä¸´æ—¶æˆ–æŒä¹…æ€§å­˜å‚¨åŒºã€‚ä»¥åï¼Œå¯ä»¥é€šè¿‡ä»å­˜å‚¨åŒºä¸­è¯»å–æˆ–ååºåˆ—åŒ–å¯¹è±¡çš„çŠ¶æ€ï¼Œé‡æ–°åˆ›å»ºè¯¥å¯¹è±¡ã€‚ äºŒå‰æ ‘çš„åºåˆ—åŒ–å¯ä»¥æŠŠéç©ºèŠ‚ç‚¹çš„å€¼åºåˆ—åŒ–ï¼ŒæŠŠç©ºèŠ‚ç‚¹åºåˆ—åŒ–ä¸º$ã€‚ æ€è·¯ï¼šç”±äºåºåˆ—åŒ–æŠŠç©ºèŠ‚ç‚¹çš„ä¿¡æ¯ä¹ŸåŒ…å«è¿›æ¥äº†ï¼Œæ‰€ä»¥æ— éœ€æ·»åŠ æ›´å¤šåºåˆ—ã€‚ è¿™é¢˜æ›´åƒæµçš„åº”ç”¨é¢˜ ä»£ç ï¼švoid Serialize(BinaryTreeNode *pRoot, ostream&amp; stream){ if(pRoot == nullptr){ stream &lt;&lt; '$'; return; } stream &lt;&lt; pRoot-&gt;value &lt;&lt; ','; Serialize(pRoot-&gt;pLeft); Serialize(pRoot-&gt;pRight); } void Deserialize(BinaryTreeNode *&amp;pRoot, istream&amp; stream){ int number; if(ReadSteam(stream, &amp;number)){ pRoot = new BinaryTreeNode(); pNew-&gt;pLeft = nullptr; pNew-&gt;pRight = nullptr; pNew-&gt;value = number; } Deserialize(pRoot-&gt;pLeft, stream); Deserialize(pRoot-&gt;pRight, steam); }","link":"/2020/08/07/shua-ti/shu-ju-jie-gou/shu/mian-shi-ti-er-cha-shu/"},{"title":"é¢è¯•é¢˜ é“¾è¡¨ç›¸å…³","text":"æ‰€æœ‰å…³äºé“¾è¡¨çš„é¢˜ç›®éƒ½ä¼šæ€»ç»“åœ¨è¿™é‡Œã€‚å‡è®¾è¿™äº›é¢˜ç›®çš„é“¾è¡¨çš„å¤´ç»“ç‚¹éƒ½æ˜¯å¸¦æœ‰æ•ˆå€¼çš„ å®šä¹‰é“¾è¡¨struct ListNode{ int Value; ListNode* pNext; }; å°¾æ’å…¥èŠ‚ç‚¹æ³¨æ„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œå› ä¸ºæœ‰å¯èƒ½éœ€è¦ä¿®æ”¹ç¬¬ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹ã€‚ void AddToTail(ListNode **pHead, int value){ if(pHead == null) return; ListNode *pNew = new ListNode(); pNew-&gt;Value = value; pNew-&gt;pNext = nullptr; if(*pHead == null){ *pHead = pNew; }else{ ListNode* pNode = *pHead; while(pNode-&gt;pNext != null){ pNode = pNode-&gt;pNext; } *pNode-&gt;pNext = pNew; } } åˆ é™¤ç¬¬ä¸€ä¸ªå¯¹åº”å€¼çš„é“¾è¡¨viod RemoveNode(ListNode** pHead, int value){ if(pHead == nullptr || *pHead == nullptr) return; ListNode *pToDeleted = nullptr; if((*pHead)-&gt;value == value){ pToDeleted = *pHead; *pHead = (*pHead)-&gt;pNext; }else{ ListNode *pNode = *pHead; //pNodeæŒ‡å‘æ£€æŸ¥èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ while((*pNode)-&gt;pNext != null &amp;&amp; (*pNode)-&gt;pNext-&gt;value != value){ pNode = pNode-&gt;pNext; } if((*pNode)-&gt;pNext != null &amp;&amp; (*pNode)-&gt;pNext-&gt;value == value){ pToDeleted = (*pNode)-&gt;pNext; } } if(pToDeleted != nullptr){ delte pToDelted; pToDelted = nullptr; //é‡Šæ”¾å†…å­˜åï¼Œå³ä½¿æ˜¯ä¸éœ€è¦ä½¿ç”¨çš„æŒ‡é’ˆï¼Œä¹Ÿè¦åšå¥½æ¸…é™¤å·¥ä½œï¼Œä¸ç„¶ä¸å®¹æ˜“ç»´æŠ¤ } } pToDeleted = *pNode-&gt;pNext;ä¸Šé¢éå†é“¾è¡¨ä¸­ä»£ç ä¸åº”è¯¥ç”¨pToDeletedæ¥è®°å½•é“¾è¡¨å€¼ï¼Œå¦ç„¶å®¹æ˜“å‡ºç°ä»£ç æŒ‡é’ˆå€¼æ„ä¹‰æ··ä¹±ï¼Œé€ æˆä¸è¯¥åˆ çš„æŒ‡é’ˆå´åˆ æ‰äº†ã€‚ é¢è¯•é¢˜6 ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨å‡å¦‚å¯¹ç©ºé—´å¤æ‚åº¦åœ¨O(N)O(N)ä¹‹ä¸Šï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨æ ˆæˆ–è€…é€’å½’ã€‚ æ ˆä»£ç å¦‚ä¸‹ void PrintListReversingly_Iteratively(ListNode* pHead){ //ä½¿ç”¨æŒ‡é’ˆç±»å‹çš„STACKæ›´çœå†…å­˜ï¼Ÿ std::stack&lt;ListNode*&gt; nodes; ListNode* pNode = pHead; while(pNode != nullptr){ nodes.push(pNode); pNode = pNode-&gt;pNext; } while(!nodes.empty()){ pNode = nodes.top(); printf(&quot;%d\\n&quot;, pNode-&gt;value); nodes.pop(); } } é€’ å½’ä»£ç  void PrintListReversingly_Recursively(ListNode* pHead){ if(pHead == nullptr) return; PrintListReversingly_Recursively(pHead-&gt;pNext); printf(&quot;%d\\n&quot;, pHead-&gt;pNext); } é¢è¯•18ï¼šåˆ é™¤ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹é¢˜é¢ï¼šç»™å®šä¸€ä¸ªå•å‘é“¾è¡¨çš„å¤´ç»“ç‚¹æŒ‡é’ˆå’Œä¸€ä¸ªæŒ‡å‘å¾…åˆ é™¤çš„èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œè¦æ±‚ç”¨O(N)O(N)æ—¶é—´åˆ é™¤èŠ‚ç‚¹ã€‚ æ€è·¯ï¼šæ•™ç§‘ä¹¦ä¸Šçš„é“¾è¡¨åˆ é™¤éƒ½æ˜¯éå†å¾—åˆ°ä¸Šä¸€ä¸ªå¾…åˆ é™¤çš„èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œæ—¶é—´å¤æ‚åº¦O(N)O(N)ã€‚æ˜¾ç„¶ä¸è¡Œï¼Œä¹Ÿå¯ä»¥ç›´æ¥æŠŠå¾…åˆ é™¤çš„èŠ‚ç‚¹Kçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹Jçš„å†…å®¹å¤åˆ¶åˆ°Kä¸Šï¼Œå†åˆ é™¤Jï¼Œå°±å¯ä»¥å¿«é€Ÿåˆ é™¤ã€‚è€ƒè™‘è¾¹ç•Œä¸Šï¼Œå¦‚æœæ²¡æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åˆ™éœ€è¦ä»å¤´éå†ï¼›å¦‚æœåªæœ‰ä¸€ä¸ªå¤´ç»“ç‚¹ä¸”åˆ é™¤çš„æ˜¯å¤´ç»“ç‚¹ï¼Œé‚£ä¹ˆåªèƒ½æŠŠå¤´ç»“ç‚¹ç½®nullptrã€‚ å…¶æ—¶é—´å¤æ‚åº¦ä¸º(nâˆ’1)âˆ—O(1)+O(N)(nâˆ’1)âˆ—O(1)+O(N)ã€‚ ä»£ç ï¼švoid DeleteNode(ListNode **pHead, ListNode *pToBeDeleted){ if(pHead == nullptr || (*phead) == nullptr || (*pToBeDeleted) == nullptr ) return; ListNode *pFree = nullptr; if(pToBeDeleted-&gt;pNext){ pFree = ToBeDeleted-&gt;pNext; pToBeDeleted-&gt;value = pToBeDeleted-&gt;pNext-&gt;value; pToBeDeleted-&gt;pNext = pToBeDeleted-&gt;pNext-&gt;pNext; } //åˆ é™¤èŠ‚ç‚¹æ— åç»§èŠ‚ç‚¹ï¼Œä¸”æ˜¯å¤´ç»“ç‚¹ else if( *pHead == pToBeDeleted){ pFree = *pHead; *pHead = nullptr; } // é“¾è¡¨ä¸­å¤šä¸ªèŠ‚ç‚¹ï¼Œä¸”åˆ é™¤èŠ‚ç‚¹åœ¨æœ«å°¾ else{ ListNode *pCur = *pHead for(; pCur-&gt;pNext-&gt;pNext != nullptr; pCur = pCur-&gt;pNext); pFree = pCur-&gt;pNext; pCur-&gt;pNext = nullptr; } Delete pFree; } é”™è¯¯ç‚¹ï¼š the properiry of â€œ*â€ &gt; the properity of â€œ==â€ é“¾è¡¨æ’å…¥å’Œåˆ é™¤åæ²¡æœ‰è®¾ç½®æŒ‡é’ˆ æ³¨æ„ç‚¹ï¼š è¿™ä¸ªå‡½æ•°å‡è®¾äº†å¾…åˆ é™¤çš„èŠ‚ç‚¹ä¸€å®šåœ¨é“¾è¡¨ä¸­ï¼› å¤´ç»“ç‚¹å¯èƒ½åˆ é™¤æ‰ï¼Œæ‰€ä»¥è®¾ç½®äº†å¤´ç»“ç‚¹ä¸ºæŒ‡é’ˆçš„æŒ‡é’ˆã€‚ é¢18ï¼ˆé¢˜ç›®äºŒï¼‰ï¼šåˆ é™¤é‡å¤å€¼çš„é“¾è¡¨èŠ‚ç‚¹é¢˜é¢ï¼šåˆ é™¤ä¸€æ¡å·²æ’åºçš„é“¾è¡¨ä¸­çš„æ‰€æœ‰çš„å…¶å€¼é‡å¤å‡ºç°çš„èŠ‚ç‚¹ã€‚ æ€è·¯ï¼šåœ¨ä¸Šé¢å­¦ä¹ çš„åŸºç¡€ä¸Šï¼Œè¿ç»­åˆ é™¤å°±è¡Œï¼Œåº”è¯¥æ˜¯æ¯”è¾ƒç®€å•çš„ã€‚ ä»£ç ï¼švoid DeleteDuplication(ListNode **pHead){ if(pHead == nullptr || *pHead == nullptr) return; ListNode *pCur = *pHead, *pPre = nullptr, *pFree = nullptr; //å®šä¹‰ä¸€ä¸ªå¤´ç»“ç‚¹ï¼Œé¿å…ä¸åŒæƒ…å†µçš„åˆ é™¤ ListNode *pKid = new ListNode(); pKid-&gt;pNext = *pHead; pPre = pKid; while(pCur != nullptr){ int value = pCur-&gt;value, isDuplication = 0; //åˆ é™¤åé¢çš„é‡å¤èŠ‚ç‚¹ while(pCur-&gt;pNext &amp;&amp; pCur-&gt;pNext-&gt;value == value){ pFree = pCur-&gt;pNext; pCur-&gt;pNext = pFree-&gt;pNext; delete pFree; isDuplication = 1; } //è‹¥é‡å¤ï¼Œåˆ™åˆ é™¤ç¬¬ä¸€ä¸ªé‡å¤èŠ‚ç‚¹ if(isDuplication){ pFree = pCur; pCur = pCur-&gt;pNext; pPre-&gt;pNext = pCur; delete pFree; // if(pFree) printf(&quot;@&quot;); } //ä¸é‡å¤åˆ™ä¸‹ç§» else{ pPre = pPre-&gt;pNext; pCur = pCur-&gt;pNext; } } *pHead = pKid-&gt;pNext; delete pKid; } æµ‹è¯•å‚è§ é¢22ï¼šå€’æ•°ç¬¬Kä¸ªèŠ‚ç‚¹é¢˜é¢ï¼šç»™å‡ºä¸€ä¸ªé“¾è¡¨ï¼Œè¿”å›å€’æ•°ç¬¬Kä¸ªèŠ‚ç‚¹ã€‚ æ€è·¯ï¼šæœ€ç›´è§‚çš„æ€è·¯æ˜¯éå†åˆ°ç»ˆç‚¹ï¼Œåå‘éå†K-1æ¬¡ï¼Œä½†æ˜¯å¯¹å•é“¾è¡¨æ— å¯å¥ˆä½•ï¼Œè€Œä¸”æ•ˆç‡ä¸é«˜ã€‚ ç¬¬äºŒç§æ€è·¯å¯ä»¥éå†ä¸€æ¬¡æ±‚é“¾è¡¨çš„é•¿åº¦Lï¼Œç¬¬äºŒæ¬¡éå†L - K + 1ä¸ªèŠ‚ç‚¹ã€‚ä½†æ˜¯éœ€è¦éå†ä¸¤æ¬¡é“¾è¡¨ã€‚ ä¸‰ç§æ€è·¯æ›´ç§’ï¼Œé‡‡ç”¨åŒæŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªæŒ‡é’ˆå…ˆéå†Kä¸ªèŠ‚ç‚¹ï¼Œéšåä¸¤ä¸ªèŠ‚ç‚¹ä¸€èµ·éå†ï¼Œç›´åˆ°ç¬¬ä¸€ä¸ªæŒ‡é’ˆä¸ºç©ºï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆå°±æŒ‡å‘äº†å€’æ•°ç¬¬Kä¸ªèŠ‚ç‚¹ã€‚ ä»£ç ï¼šListNode *FindKthToTail(ListNode *pHead, unsigned int K){ if(pHead == nullptr) return nullptr; ListNode *p1 = pHead, *p2 = pHead; for(int i = 0; i &lt; K; i++){ if(p1 == nullptr) return nullptr; p1 = p1-&gt;pNext; } while(p1!=nullptr){ p1 = p1-&gt;pNext; p2 = p2-&gt;pNext; } return p2; } è¿™ä»£ç å†™çš„æ¯”å‰‘æŒ‡offerä»£ç å†™çš„ä¼˜ç¾å¤šäº† ç›¸å…³æ‰©å±•ï¼šç›¸å…³é¢˜ç›®æœ‰æ‰¾å‡ºé“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ï¼›åˆ¤æ–­ä¸€ä¸ªé“¾è¡¨æ˜¯å¦æœ‰ç¯ï¼›æ›´éš¾ä¸€ç‚¹åˆ¤æ–­é“¾è¡¨çš„ç¯çš„å…¥å£èŠ‚ç‚¹ï¼ å…¶æ€è·¯å®—æ—¨éƒ½æ˜¯ä½¿ç”¨ä¸¤ä¸ªè¿›åº¦ä¸ä¸€æ ·çš„æŒ‡é’ˆæŒ‡å‘ä¸åŒçš„èŠ‚ç‚¹æ¥è§£å†³é—®é¢˜ï¼ é¢23ï¼šé“¾è¡¨ä¸­çš„ç¯çš„å…¥å£èŠ‚ç‚¹é¢˜é¢ï¼šç»™å‡ºä¸€ä¸ªé“¾è¡¨ï¼Œæ±‚å‡ºå…¶æˆç¯çš„å…¥å£èŠ‚ç‚¹ã€‚ æ€è·¯ï¼šé¦–å…ˆå¾—åˆ¤æ–­æœ‰ç¯ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¿«ä¸€æ…¢çš„ä¸¤åªæŒ‡é’ˆï¼ˆç§»åŠ¨é€Ÿåº¦åˆ†åˆ«ä¸º2å’Œ1ï¼‰æŒ‡å‘é“¾è¡¨å¤´ã€‚å¦‚æœé“¾è¡¨æœ‰ç¯ï¼Œåˆ™å¿«æ…¢æŒ‡é’ˆå°±ä¸€å®šä¼šç›¸é‡ã€‚ é‚£ä¹ˆå¯¹äºæœ‰ç¯çš„é“¾è¡¨å¦‚ä½•ç¡®å®šå…¶å…¥å£èŠ‚ç‚¹å‘¢ï¼Ÿå‡è®¾ç¯çš„ä¸­èŠ‚ç‚¹æœ‰Kä¸ªï¼Œå¿«æŒ‡é’ˆä»å¤´å…ˆéå†Kæ¬¡ä¹‹åï¼Œå¿«æ…¢æŒ‡é’ˆåŒæ—¶å¼€å§‹éå†ï¼Œæ­£å¥½ä¸¤ä¸ªæŒ‡é’ˆä¼šåœ¨å…¥å£èŠ‚ç‚¹ä¸Šæ±‡åˆï¼ å¦‚ä½•ç¡®å®šç¯ä¸­èŠ‚ç‚¹å‘¢ï¼Ÿè¿™ä¸ªï¼å¯ä»¥ç›´æ¥åœ¨ç¡®å®šæœ‰ç¯åï¼Œè®°å½•ä¸‹è¯¥èŠ‚ç‚¹çš„ä½ç½®ï¼Œå†ç»§ç»­éå†ç›´åˆ°é‡æ–°åˆ°è¯¥èŠ‚ç‚¹åŒæ—¶ç»Ÿè®¡ç»è¿‡çš„èŠ‚ç‚¹æ•°é‡å³å¯ã€‚ amazingå•Š ä»£ç ï¼šListNode *FindCycleNode(ListNode* pHead){ if(pHead == nullptr) return nullptr; ListNode *pSlow, *pQuick, *pRecord = nullptr ; //åˆ¤æ–­æœ‰æ²¡æœ‰ç¯ pSlow = pQuick = pHead; while(pQuick != nullptr){ pQuick = pQuick-&gt;pNext; if(pQuick) pQuick = pQuick-&gt;pNext; if(pSlow) pSlow = pSlow-&gt;pNext; if(pSlow == pQuick) break; } if(pQuick == nullptr) return nullptr; //ç¡®å®šç¯å†…æ•°é‡ pRecord = pSlow; int numberOfCycle = 0; while(pRecord != pSlow){ numberOfCycle++; pSlow = pSlow-&gt;pNext; } //ç¡®å®šç¯çš„å…¥å£èŠ‚ç‚¹ pSlow = pQuick = pHead; for(int i = 0; i &lt; numberOfCycle; i++){ pQuick = pQuick-&gt;pNext; } while(pSlow != pQuick){ pQuick = pQuick-&gt;pNext; pSlow = pSlow-&gt;pNext; } return pSlow; } é¢24ï¼šåè½¬é“¾è¡¨é¢˜é¢ï¼šè¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼Œåè½¬è¯¥é“¾è¡¨å¹¶è¾“å‡ºåè½¬åçš„é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚ æ€è·¯ï¼šåœ¨åè½¬è¿‡ç¨‹ä¸­ï¼Œå‡è®¾æœ‰ä¸‰ä¸ªé¡ºåºæ’åˆ—çš„å¾…åè½¬çš„é“¾è¡¨iï¼Œjï¼Œkï¼Œå…¶ä¸­jæ˜¯å¾…åè½¬çš„é“¾è¡¨ã€‚åˆå§‹åŒ–ï¼Œiä¸ºç©ºæŒ‡é’ˆï¼Œjä¸ºå¤´èŠ‚ç‚¹ï¼Œkä¸ºå¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ï¼Œå¹¶æŠŠiçš„æŒ‡é’ˆæŒ‡ç©ºã€‚åœ¨é“¾è¡¨åè½¬è¿‡ç¨‹å¦‚ä¸‹ï¼šjçš„æŒ‡é’ˆæŒ‡å‘iï¼Œç„¶åæŠŠiï¼Œjï¼Œkåˆ†åˆ«æŒ‰æ¬¡åºå‘åç§»åŠ¨ã€‚é‡å¤æ‰§è¡Œä¸Šè¿°æ­¥éª¤ç›´åˆ°jä¸ºç©ºã€‚ ä»£ç ï¼šListNode *ReverseList(ListNode *pHead){ if(pHead == nullptr) return nullptr; ListNode *p1 = nullptr, *p2 = pHead, *p3 = pHead-&gt;pNext; while(p2 != nullptr){ p2-&gt;pNext = p1; p1 = p2; p2 = p3; if(p3) p3 = p3-&gt;next; } return p2; } é¢25ï¼šåˆå¹¶é“¾è¡¨é¢˜é¢ï¼šå°†ä¸¤ä¸ªé“¾è¡¨å¢åºåˆå¹¶æˆä¸€æ¡é“¾è¡¨ã€‚ æ€è·¯ï¼šç”¨ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸¤æ¡é“¾è¡¨çš„å¤´ç»“ç‚¹ï¼Œç”¨åˆå¹¶æ•°ç»„çš„æ€è·¯åˆå¹¶å³å¯ã€‚æ³¨æ„ä¸€æ¡é“¾è¡¨ä¸ºç©ºåï¼Œå¦ä¸€æ¡ä¸ä¸ºç©ºçš„é“¾è¡¨å¯ä»¥ç›´æ¥è¿ä¸Šå»ã€‚ ä»£ç ï¼šListNode *Merge(ListNode *pHead1, ListNode *pHead2){ if( pHead1 == nullptr &amp;&amp; pHead2 == nullptr){ return nullptr; }else if(pHead1 == nullptr) return pHead2; else if(pHead2 == nullpr) return pHead1; ListNode *p1 = pHead1, *p2 = pHead2, *pHead3 = new ListNode(), *p3 = pHead3; while(p1 &amp;&amp; p2){ if(p1-&gt;value &lt;= p2-&gt;value){ p3-&gt;pNext = p1; p3 = p1; p1 = p1-&gt;pNext; }else{ p3-&gt;pNext = p2; p3 = p2; p2 = p2-&gt;pNext; } } p3-&gt;pNext = nullptr; if(p1){ p3-&gt;pNext = p1; }else if(p2){ p3-&gt;pNext = p2; } ListNode *pFree = pHead3; pHead3 = pHead-&gt;pNext; delete pFree; return pHead3; } æµ‹è¯•å‚è§ é¢35ï¼šå¤æ‚é“¾è¡¨çš„åˆ†è§£é¢˜é¢ï¼šç»™å‡ºä¸€ä¸ªæœ‰ä¸¤ä¸ªæŒ‡é’ˆçš„é“¾è¡¨æ•°æ®ç»“æ„ï¼Œä¸€ä¸ªæŒ‡é’ˆ1æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦ä¸€ä¸ªæŒ‡é’ˆ2å¯æŒ‡å‘ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ–è€…ä¸ºç©ºã€‚å°†ç»™å‡ºçš„é“¾è¡¨å¤åˆ¶å¹¶è¿”å›å¤´ç»“ç‚¹ã€‚ æ€è·¯ï¼šè¿™é¢˜ç›®è¿˜æ˜¯æŒºä¸é”™çš„ï¼å±äºæ¯”è¾ƒå¤æ‚çš„é¢˜ç›®ï¼Œè€Œä¸”æœ‰æ€è€ƒç©ºé—´ã€‚ å°†å¤åˆ¶çš„è¿‡ç¨‹åˆ†è§£ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œç¬¬ä¸€æ­¥å…ˆä¸ç®¡æŒ‡é’ˆ2ï¼Œå¤åˆ¶æ•´ä¸ªé“¾è¡¨ï¼›ç¬¬äºŒæ­¥å†è®¾ç½®æŒ‡é’ˆ2ã€‚ç¬¬ä¸€æ­¥éœ€è¦çš„å¤æ‚åº¦ä¸ºO(N)O(N)ã€‚ç¬¬äºŒæ­¥å†å¤åˆ¶çš„è¿‡ç¨‹ä¸­éœ€è¦ç¡®å®šå¤åˆ¶é“¾è¡¨ä¸­æŒ‡é’ˆ2æŒ‡å‘çš„èŠ‚ç‚¹çš„çš„ä½ç½®ã€‚ ç¬¬ä¸€ç§ç¡®å®šä½ç½®çš„æ€è·¯ï¼šå°±æ˜¯ä»åŸé“¾è¡¨éå†å¯»æ‰¾åŸæŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹ä½ç½®ï¼ŒåŒæ ·çš„åœ¨å¤åˆ¶é“¾è¡¨ä¸Šä¸€èµ·éå†ã€‚å¤æ‚åº¦ä¸ºO(N2)O(N2)ã€‚ ç¬¬äºŒç§ç¡®å®šä½ç½®çš„æ€è·¯ï¼šç›´æ¥ç”¨hashè¡¨è®°å½•ä¸‹åŸé“¾è¡¨ä¸­èŠ‚ç‚¹å’Œå¤åˆ¶é“¾è¡¨ä¸­å¯¹åº”èŠ‚ç‚¹çš„æ˜ å°„å…³ç³»ã€‚å¤æ‚åº¦ä¸ºO(N)O(N)ã€‚æ˜¯ç”¨äº†ç©ºé—´æ¢æ—¶é—´çš„æ€è·¯ã€‚ å®³æ€•ç¢°æ’ã€‚ è„±ç¦»ä¸Šé¢çš„æ–¹æ¡ˆçš„é™åˆ¶ï¼Œæ›´å·§å¦™çš„æ–¹æ³•æ¥äº†ã€‚é“¾è¡¨çš„é¡ºåºéå†è¿œè¿œæ¯”éšæœºéå†æ–¹ä¾¿å¾ˆå¤šï¼Œè€Œä¸”æŒ‡é’ˆæŒ‡å‘çš„èŠ‚ç‚¹çš„ä½ç½®ä¸éšé“¾è¡¨èŠ‚ç‚¹è€Œå˜åŒ–ã€‚å¯ä»¥è€ƒè™‘æŠŠå¤åˆ¶èŠ‚ç‚¹ç›´æ¥æ’å…¥åˆ°è¢«å¤åˆ¶èŠ‚ç‚¹çš„åé¢ã€‚å…¨éƒ¨å¤åˆ¶å®Œæˆåï¼Œç”±äºåŸèŠ‚ç‚¹çš„æŒ‡é’ˆ2æŒ‡å‘çš„èŠ‚ç‚¹çš„åä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯å¤åˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆ2æŒ‡å‘çš„èŠ‚ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥æŒ‡å‘ã€‚å¤æ‚åº¦ä¸ºO(N)O(N)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1)O(1)ã€‚ ä»£ç ï¼šstruct ComplexListNode{ int value; ComplexListNode *pNext; ComplexListNode *pSibling; } void CopyNode(ComplexListNode *pHead){ if(pHead == nullptr) return null; ComplexListNode *pNode = pHead; while(pNode){ ComplexListNode *pNew = new ComplexListNode(); pNew-&gt;value = pNode-&gt;value; pNew-&gt;pNext = pNode-&gt;pNext; pNew-&gt;pSibling = nullptr; pNode-&gt;pNext = pNew; pNode = pNew-&gt;pNext; } } void SetSiblingLink(ComplexListNode * pHead){ if(pHead == nullptr )return nullptr; ComplexListNode *pNode = pHead; while(pNode){ ComplexListNode *pNext = pNode-&gt;pNext; pNext-&gt;pSibling = pNode-&gt;pSibliing-&gt;pNext; pNode = pNext-&gt;pNext; } } ComplexListNode *GetComplexList(ComplexListNode *pHead){ if(pHead == nullptr) return nullptr; ComplexListNode *pNode = pHead; ComplexListNode *pClonedHead = pNode-&gt;pNext; ComplexListNode *pClonedNode = pNode-&gt;pNext; pNode-&gt;next = pClonedNode-&gt;next; pNode = pClneNode-&gt;next; while(pNode){ pClonedNode-&gt;pNext = pNode-&gt;pNext; pNode-&gt;pNext = pNode-&gt;pNext-&gt;pNext; pClonedNode = pNode-&gt;pNext; pNode = pClonedNode-&gt;pNext; /* //we can write in this way. pClonedNode-&gt;pNext = pNode-&gt;pNext; pClonedNode = pClonedNode-&gt;pNext; pNode-&gt;pNext = pClonedNode-&gt;pNext; pNode = pNode-&gt;pNext; */ } return pClonedHead; } ComplexListNode *Clone(ComplexListNode* pHead){ CopyNode(pHead); SetSiblingLink(pHead); return GetComplexList(pHead); } é¢36ï¼šæŠŠäºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºåŒå‘é“¾è¡¨é¢˜é¢ï¼šå¦‚é¢˜ï¼Œè¦æ±‚ä¸åˆ›å»ºä»»ä½•æ–°èŠ‚ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­èŠ‚ç‚¹çš„æŒ‡å‘ã€‚è¾“å‡ºè°ƒæ•´åçš„æ’åºé“¾è¡¨ã€‚ æ€è·¯ï¼šå¯ä»¥ä»é€’å½’çš„è§’åº¦å…¥æ‰‹ã€‚å¯¹äºä¸€ä¸ªèŠ‚ç‚¹Aï¼Œä¸­åºéå†åˆ°Aï¼Œåˆ™Açš„å·¦å­æ ‘å·²ç»è½¬åŒ–ä¸ºäº†é“¾è¡¨ï¼Œè¿æ¥å¥½Aå’ŒAçš„å·¦å­æ ‘çš„æœ€å¤§èŠ‚ç‚¹ï¼ˆå‰ä¸€ä¸ªæŒ‡é’ˆï¼‰çš„æŒ‡é’ˆåˆ™è¿æ¥å®Œæˆã€‚ é‚£å¯¹äºAçš„å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹Bä¸Aä¹‹é—´çš„è¿æ¥ï¼Œä¹Ÿå¯ä»¥çœ‹æˆBä¸å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆç›¸äº’é“¾æ¥ã€‚é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦åœ¨ä¸­åºéå†çš„è¿‡ç¨‹ä¸­æ”¹å˜å‰ä¸€ä¸ªæŒ‡é’ˆçš„å†…å®¹å³å¯ã€‚ æ³¨æ„ä¸€ä¸‹æ•´æ£µæ ‘çš„æœ€å¤§çš„å³æŒ‡é’ˆå’Œæœ€å°èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆï¼Œå‘ç°éƒ½åº”è¯¥æ˜¯ç©ºï¼Œæ— éœ€é¢å¤–ä¿®æ”¹ã€‚ å¯¹äºä¸€ä¸ªèŠ‚ç‚¹Açš„å·¦å³æŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘æŒ‰é¡ºåºæ’åˆ—çš„æ—è¾¹ä¸¤ä¸ªèŠ‚ç‚¹ã€‚å¯ä»¥ç”¨ä¸­åºéå†æ¥è·å–è¯¥èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹Bçš„æŒ‡é’ˆï¼Œå¹¶è®¾ç½®å¥½Bçš„å³æŒ‡é’ˆå’ŒAçš„å·¦æŒ‡é’ˆã€‚å¦‚æ­¤å°±å¯ä»¥åœ¨ä¸­åºéå†çš„åè®¾ç½®é™¤äº†æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å³æŒ‡é’ˆï¼Œä½†æ˜¯å³æŒ‡é’ˆæœ¬æ¥å°±åº”è¯¥æ˜¯NULLï¼Œæ‰€ä»¥æ— éœ€ä¿®æ”¹ã€‚ ä»£ç ï¼švoid AdjustLinkCore(BinaryTreeNode* pRoot, BinaryTreeNode *&amp;preNode, BinaryTreeNode *&amp;pHead){ if(pRoot == nullptr) return; AdjustLinkCore(pRoot-&gt;pLeft, preNode, pHead); if(pHead == nullptr) pHead = pRoot; pRoot-&gt;pLeft = preNode; if(preNode) preNode-&gt;pRight = pRoot; preNode = pRoot; AdjustLinkCore(pRoot-&gt;pRight, preNode, pHead); } BinaryTreeNode* AdjustLink(BinaryTreeNode* pRoot){ BinaryTreeNode *preNode = nullptr; BinaryTreeNode *pHead = nullptr; AdjustLinkCore(pRoot, preNode, pHead); return pHead; } é¢52ï¼šä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹é¢˜é¢ï¼šå¦‚é¢˜ã€‚ æ€è·¯ï¼šæ˜æ˜¾åœ°ï¼Œå¯ä»¥ç”¨æ ˆæ¥å­˜å‚¨ä¸¤ä¸ªé“¾è¡¨éå†è¿‡ç¨‹ã€‚ç©ºé—´å¤æ‚åº¦å’Œæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(N)O(N)ã€‚ æ¢ä¸€ç§æƒ³æ³•ï¼Œèƒ½ä¸èƒ½ç›´æ¥éå†å°±ä½¿ä¸¤ä¸ªé“¾è¡¨åŒæ—¶éå†åˆ°ç¬¬ä¸€ä¸ªå…¬å…±èŠ‚ç‚¹ã€‚å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆæ¥éå†ä¸¤æ¡é“¾è¡¨ã€‚åªè¦è®©ä¸€ä¸ªæŒ‡å‘é•¿é“¾è¡¨çš„èŠ‚ç‚¹çš„æŒ‡é’ˆå¤šèµ°å¤šå‡ºçš„èŠ‚ç‚¹ï¼Œå°±å¯ä»¥è®©ä¸¤ä¸ªèŠ‚ç‚¹åŒæ—¶åŒåºçš„éå†åˆ°å…¬å…±èŠ‚ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(N+M)O(N+M)ï¼Œç©ºé—´å¤æ‚åº¦O(1)O(1)ã€‚ ä»£ç ï¼šint GetLenOfList(ListNode *pHead){ int len = 0; ListNode *pNode = pHead; while(pNode){ pNode = pNode-&gt;pNext; len++; } return len; } ListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2){ if(pHead1 == nullptr || pHead2 == nullptr) return nullptr; int len1 = GetLenOfList(pHead1); int len2 = GetLenOfList(pHead2); if(len1 &lt; len2){ swap(pHead1, pHead2); swap(len1, len2); } int step = len1 - len2; ListNode *pNode1 = pHead1; ListNode *pNode2 = pHead2; while(step){ pNode1 = pNode-&gt;pNext; step--; } while(pNode1 != pNode2){ pNode1 = pNode1-&gt;pNext; pNode2 = pNode1-&gt;pNext; } //two pNodes maybe refer to null or the first common node. return pNode1; } æ›´ç®€å•çš„è§£æ³•ï¼š åŒæŒ‡é’ˆéå†ä¸¤æ¡é“¾è¡¨ï¼Œéå†åˆ°ç»“å°¾åˆ™è·³åˆ°å¦ä¸€æ¡é“¾è¡¨ä¸Šã€‚è·¯å¾„é•¿åº¦çš„ç›¸ç­‰ä¸€å®šä¼šæœ‰ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ã€‚ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p1 = headA, *p2 = headB; while(p1 != p2){ p1 = p1 == nullptr ? headB : p1-&gt;next; p2 = p2 == nullptr ? headA : p2-&gt;next; } return p1; } }; é“¾è¡¨å›æ–‡åˆ¤æ–­234. Palindrome Linked List O(n)æ—¶é—´ï¼ŒO(1)ç©ºé—´ æ€è·¯ï¼šæœ´ç´ çš„æ€è·¯ï¼šå…ˆç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é“¾è¡¨ä¸­é—´èŠ‚ç‚¹ï¼Œä¹‹åç¿»è½¬ååŠéƒ¨åˆ†é“¾è¡¨ã€‚åˆ¤æ–­ä¸¤ä¸ªé“¾è¡¨æ˜¯å¦ç›¸åŒã€‚ å…¶ä¸­å¥‡æ•°ä¸ªèŠ‚ç‚¹é“¾è¡¨éœ€è¦è€ƒè™‘ä¸€ä¸‹ã€‚ ä»£ç /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { ListNode *slow ,*quick; slow = quick = head; while(quick &amp;&amp; quick-&gt;next){ slow = slow-&gt;next; quick = quick-&gt;next-&gt;next; } ListNode *p2 = reverseList(slow), *p1 = head; while(p1 &amp;&amp; p2){ if(p1-&gt;val != p2-&gt;val) return false; p1 = p1-&gt;next; p2 = p2-&gt;next; } return true; } ListNode *reverseList(ListNode* head){ if(head == nullptr) return head; ListNode *per = nullptr, *cur = head, *next = head-&gt;next; while(cur){ cur-&gt;next = per; per = cur; cur = next; if(next) next = next-&gt;next; } return per; } }; å¥‡å¶é“¾è¡¨èŠ‚ç‚¹åˆ†è§£éå¸¸å®¹æ˜“å†™å¤æ‚çš„é¢˜ç›®ã€‚ /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* oddEvenList(ListNode* head) { if(!(head &amp;&amp; head-&gt;next)) return head; // ListNode *p1 = head, *p2 = new ListNode(), *evenHead = p2, *pre = nullptr; // while(p1 &amp;&amp; p1-&gt;next){ // p2-&gt;next = p1-&gt;next; // p2 = p2-&gt;next; // p1-&gt;next = p2-&gt;next; // pre = p1; // p1 = p2-&gt;next; // } // p2-&gt;next = nullptr; // p1 = p1 ? p1 : pre; // p1-&gt;next = evenHead-&gt;next; // delete evenHead; // return head; ListNode *evenHead = head-&gt;next, *odd = head, *even = head-&gt;next; while(even &amp;&amp; even-&gt;next){ odd-&gt;next = even-&gt;next; odd = odd-&gt;next; even-&gt;next = odd-&gt;next; even = even-&gt;next; } odd-&gt;next = evenHead; return head; } }; åˆ é™¤å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode node, *pre = &amp;node; pre-&gt;next = head; ListNode *quick, *slow; quick = slow = pre; for(int i = 0; i &lt; n; ++i) quick = quick-&gt;next; while(quick-&gt;next){ quick = quick-&gt;next; slow = slow-&gt;next; } ListNode *fordel = slow-&gt;next; slow-&gt;next = fordel-&gt;next; if(fordel == head){ //åˆ é™¤èŠ‚ç‚¹ åŠ¡å¿…å°å¿ƒï¼š1.åˆ äº†å¤´ç»“ç‚¹ï¼Œéœ€è¦é‡ç½®å¤´ç»“ç‚¹ 2.è€ƒè™‘åç»­èŠ‚ç‚¹ head = fordel-&gt;next; } delete fordel; return head; } };","link":"/2020/08/07/shua-ti-shu-ju-jie-gou-lian-biao-mian-shi-ti-lian-biao-xiang-guan/"}],"tags":[],"categories":[{"name":"éšè°ˆ","slug":"éšè°ˆ","link":"/categories/%E9%9A%8F%E8%B0%88/"},{"name":"Code tools","slug":"Code-tools","link":"/categories/Code-tools/"},{"name":"åˆ·é¢˜","slug":"åˆ·é¢˜","link":"/categories/%E5%88%B7%E9%A2%98/"},{"name":"build","slug":"Code-tools/build","link":"/categories/Code-tools/build/"},{"name":"DP","slug":"åˆ·é¢˜/DP","link":"/categories/%E5%88%B7%E9%A2%98/DP/"},{"name":"ä½è¿ç®—","slug":"åˆ·é¢˜/ä½è¿ç®—","link":"/categories/%E5%88%B7%E9%A2%98/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"å…¶ä»–","slug":"åˆ·é¢˜/å…¶ä»–","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96/"},{"name":"åˆ†æ²»","slug":"åˆ·é¢˜/åˆ†æ²»","link":"/categories/%E5%88%B7%E9%A2%98/%E5%88%86%E6%B2%BB/"},{"name":"åŒæŒ‡é’ˆ","slug":"åˆ·é¢˜/åŒæŒ‡é’ˆ","link":"/categories/%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"å­—ç¬¦ä¸²","slug":"åˆ·é¢˜/å­—ç¬¦ä¸²","link":"/categories/%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"æ’åº","slug":"åˆ·é¢˜/æ’åº","link":"/categories/%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/"},{"name":"æ•°å­¦","slug":"åˆ·é¢˜/æ•°å­¦","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ‹Ÿ","slug":"åˆ·é¢˜/æ¨¡æ‹Ÿ","link":"/categories/%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/"},{"name":"è´ªå¿ƒ","slug":"åˆ·é¢˜/è´ªå¿ƒ","link":"/categories/%E5%88%B7%E9%A2%98/%E8%B4%AA%E5%BF%83/"},{"name":"~å…¶ä»–codeèƒ½åŠ›","slug":"åˆ·é¢˜/å…¶ä»–codeèƒ½åŠ›","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96code%E8%83%BD%E5%8A%9B/"},{"name":"æœç´¢","slug":"åˆ·é¢˜/æœç´¢","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/"},{"name":"æ•°æ®ç»“æ„","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"ä»£ç è§„èŒƒ","slug":"åˆ·é¢˜/å…¶ä»–codeèƒ½åŠ›/ä»£ç è§„èŒƒ","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96code%E8%83%BD%E5%8A%9B/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"æ²Ÿé€šèƒ½åŠ›","slug":"åˆ·é¢˜/å…¶ä»–codeèƒ½åŠ›/æ²Ÿé€šèƒ½åŠ›","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96code%E8%83%BD%E5%8A%9B/%E6%B2%9F%E9%80%9A%E8%83%BD%E5%8A%9B/"},{"name":"æ‰«æçº¿","slug":"åˆ·é¢˜/å…¶ä»–/æ‰«æçº¿","link":"/categories/%E5%88%B7%E9%A2%98/%E5%85%B6%E4%BB%96/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"bfs","slug":"åˆ·é¢˜/æœç´¢/bfs","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/bfs/"},{"name":"dfs","slug":"åˆ·é¢˜/æœç´¢/dfs","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/dfs/"},{"name":"äºŒåˆ†","slug":"åˆ·é¢˜/æœç´¢/äºŒåˆ†","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%88%86/"},{"name":"å›æº¯","slug":"åˆ·é¢˜/æœç´¢/å›æº¯","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/%E5%9B%9E%E6%BA%AF/"},{"name":"è®°å¿†åŒ–æœç´¢","slug":"åˆ·é¢˜/æœç´¢/è®°å¿†åŒ–æœç´¢","link":"/categories/%E5%88%B7%E9%A2%98/%E6%90%9C%E7%B4%A2/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"set","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/set","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/set/"},{"name":"ä¼˜å…ˆé˜Ÿåˆ—","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/ä¼˜å…ˆé˜Ÿåˆ—","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"å“ˆå¸Œ","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/å“ˆå¸Œ","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/"},{"name":"å›¾","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/å›¾","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"},{"name":"å †","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/å †","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"},{"name":"å¤æ‚æ•°æ®ç»“æ„","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/å¤æ‚æ•°æ®ç»“æ„","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ ˆå’Œé˜Ÿåˆ—","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/æ ˆå’Œé˜Ÿåˆ—","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"name":"æ ‘","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/æ ‘","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"},{"name":"é“¾è¡¨","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/é“¾è¡¨","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"},{"name":"å•è°ƒæ ˆ","slug":"åˆ·é¢˜/æ•°æ®ç»“æ„/æ ˆå’Œé˜Ÿåˆ—/å•è°ƒæ ˆ","link":"/categories/%E5%88%B7%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88/"}]}